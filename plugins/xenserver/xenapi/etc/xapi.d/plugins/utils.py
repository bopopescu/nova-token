begin_unit
comment|'# Copyright (c) 2012 Openstack, LLC'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
nl|'\n'
string|'"""Various utilities used by XenServer plugins."""'
newline|'\n'
nl|'\n'
name|'import'
name|'logging'
newline|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'shlex'
newline|'\n'
name|'import'
name|'shutil'
newline|'\n'
name|'import'
name|'subprocess'
newline|'\n'
name|'import'
name|'tempfile'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|CHUNK_SIZE
name|'CHUNK_SIZE'
op|'='
number|'8192'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|make_subprocess
name|'def'
name|'make_subprocess'
op|'('
name|'cmdline'
op|','
name|'stdout'
op|'='
name|'False'
op|','
name|'stderr'
op|'='
name|'False'
op|','
name|'stdin'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Make a subprocess according to the given command-line string\n    """'
newline|'\n'
name|'logging'
op|'.'
name|'info'
op|'('
string|'"Running cmd \'%s\'"'
op|'%'
name|'cmdline'
op|')'
newline|'\n'
name|'kwargs'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'kwargs'
op|'['
string|"'stdout'"
op|']'
op|'='
name|'stdout'
name|'and'
name|'subprocess'
op|'.'
name|'PIPE'
name|'or'
name|'None'
newline|'\n'
name|'kwargs'
op|'['
string|"'stderr'"
op|']'
op|'='
name|'stderr'
name|'and'
name|'subprocess'
op|'.'
name|'PIPE'
name|'or'
name|'None'
newline|'\n'
name|'kwargs'
op|'['
string|"'stdin'"
op|']'
op|'='
name|'stdin'
name|'and'
name|'subprocess'
op|'.'
name|'PIPE'
name|'or'
name|'None'
newline|'\n'
name|'args'
op|'='
name|'shlex'
op|'.'
name|'split'
op|'('
name|'cmdline'
op|')'
newline|'\n'
name|'logging'
op|'.'
name|'info'
op|'('
string|'"Running args \'%s\'"'
op|'%'
name|'args'
op|')'
newline|'\n'
name|'proc'
op|'='
name|'subprocess'
op|'.'
name|'Popen'
op|'('
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
name|'return'
name|'proc'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|finish_subprocess
dedent|''
name|'def'
name|'finish_subprocess'
op|'('
name|'proc'
op|','
name|'cmdline'
op|','
name|'ok_exit_codes'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Ensure that the process returned a zero exit code indicating success\n    """'
newline|'\n'
name|'if'
name|'ok_exit_codes'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'ok_exit_codes'
op|'='
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'out'
op|','
name|'err'
op|'='
name|'proc'
op|'.'
name|'communicate'
op|'('
op|')'
newline|'\n'
name|'ret'
op|'='
name|'proc'
op|'.'
name|'returncode'
newline|'\n'
name|'if'
name|'ret'
name|'not'
name|'in'
name|'ok_exit_codes'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'Exception'
op|'('
string|'"\'%(cmdline)s\' returned non-zero exit code: "'
nl|'\n'
string|'"retcode=%(ret)i, out=\'%(out)s\', stderr=\'%(err)s\'"'
nl|'\n'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'out'
op|','
name|'err'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|make_staging_area
dedent|''
name|'def'
name|'make_staging_area'
op|'('
name|'sr_path'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    The staging area is a place where we can temporarily store and\n    manipulate VHDs. The use of the staging area is different for upload and\n    download:\n\n    Download\n    ========\n\n    When we download the tarball, the VHDs contained within will have names\n    like "snap.vhd" and "image.vhd". We need to assign UUIDs to them before\n    moving them into the SR. However, since \'image.vhd\' may be a base_copy, we\n    need to link it to \'snap.vhd\' (using vhd-util modify) before moving both\n    into the SR (otherwise the SR.scan will cause \'image.vhd\' to be deleted).\n    The staging area gives us a place to perform these operations before they\n    are moved to the SR, scanned, and then registered with XenServer.\n\n    Upload\n    ======\n\n    On upload, we want to rename the VHDs to reflect what they are, \'snap.vhd\'\n    in the case of the snapshot VHD, and \'image.vhd\' in the case of the\n    base_copy. The staging area provides a directory in which we can create\n    hard-links to rename the VHDs without affecting what\'s in the SR.\n\n\n    NOTE\n    ====\n\n    The staging area is created as a subdirectory within the SR in order to\n    guarantee that it resides within the same filesystem and therefore permit\n    hard-linking and cheap file moves.\n    """'
newline|'\n'
name|'staging_path'
op|'='
name|'tempfile'
op|'.'
name|'mkdtemp'
op|'('
name|'dir'
op|'='
name|'sr_path'
op|')'
newline|'\n'
name|'return'
name|'staging_path'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|cleanup_staging_area
dedent|''
name|'def'
name|'cleanup_staging_area'
op|'('
name|'staging_path'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Remove staging area directory\n\n    On upload, the staging area contains hard-links to the VHDs in the SR;\n    it\'s safe to remove the staging-area because the SR will keep the link\n    count > 0 (so the VHDs in the SR will not be deleted).\n    """'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'staging_path'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'shutil'
op|'.'
name|'rmtree'
op|'('
name|'staging_path'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|import_vhds
dedent|''
dedent|''
name|'def'
name|'import_vhds'
op|'('
name|'sr_path'
op|','
name|'staging_path'
op|','
name|'uuid_stack'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Import the VHDs found in the staging path.\n\n    We cannot extract VHDs directly into the SR since they don\'t yet have\n    UUIDs, aren\'t properly associated with each other, and would be subject to\n    a race-condition of one-file being present and the other not being\n    downloaded yet.\n\n    To avoid these we problems, we use a staging area to fixup the VHDs before\n    moving them into the SR. The steps involved are:\n\n        1. Extracting tarball into staging area (done prior to this call)\n\n        2. Renaming VHDs to use UUIDs (\'snap.vhd\' -> \'ffff-aaaa-...vhd\')\n\n        3. Linking VHDs together if there\'s a snap.vhd\n\n        4. Pseudo-atomically moving the images into the SR. (It\'s not really\n           atomic because it takes place as multiple os.rename operations;\n           however, the chances of an SR.scan occuring between the rename()s\n           invocations is so small that we can safely ignore it)\n\n    Returns: A list of VDIs.  Each list element is a dictionary containing\n    information about the VHD.  Dictionary keys are:\n        1. "vdi_type" - The type of VDI. Currently they can be "root" or\n           "swap"\n        2. "vdi_uuid" - The UUID of the VDI\n\n    Example return: [{"vdi_type": "root","vdi_uuid": "ffff-aaa..vhd"},\n                     {"vdi_type": "swap","vdi_uuid": "ffff-bbb..vhd"}]\n    """'
newline|'\n'
DECL|function|rename_with_uuid
name|'def'
name|'rename_with_uuid'
op|'('
name|'orig_path'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Rename VHD using UUID so that it will be recognized by SR on a\n        subsequent scan.\n\n        Since Python2.4 doesn\'t have the `uuid` module, we pass a stack of\n        pre-computed UUIDs from the compute worker.\n        """'
newline|'\n'
name|'orig_dirname'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'dirname'
op|'('
name|'orig_path'
op|')'
newline|'\n'
name|'uuid'
op|'='
name|'uuid_stack'
op|'.'
name|'pop'
op|'('
op|')'
newline|'\n'
name|'new_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'orig_dirname'
op|','
string|'"%s.vhd"'
op|'%'
name|'uuid'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'rename'
op|'('
name|'orig_path'
op|','
name|'new_path'
op|')'
newline|'\n'
name|'return'
name|'new_path'
op|','
name|'uuid'
newline|'\n'
nl|'\n'
DECL|function|link_vhds
dedent|''
name|'def'
name|'link_vhds'
op|'('
name|'child_path'
op|','
name|'parent_path'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Use vhd-util to associate the snapshot VHD with its base_copy.\n\n        This needs to be done before we move both VHDs into the SR to prevent\n        the base_copy from being DOA (deleted-on-arrival).\n        """'
newline|'\n'
name|'modify_cmd'
op|'='
op|'('
string|'"vhd-util modify -n %(child_path)s -p %(parent_path)s"'
nl|'\n'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
name|'modify_proc'
op|'='
name|'make_subprocess'
op|'('
name|'modify_cmd'
op|','
name|'stderr'
op|'='
name|'True'
op|')'
newline|'\n'
name|'finish_subprocess'
op|'('
name|'modify_proc'
op|','
name|'modify_cmd'
op|')'
newline|'\n'
nl|'\n'
DECL|function|move_into_sr
dedent|''
name|'def'
name|'move_into_sr'
op|'('
name|'orig_path'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Move a file into the SR"""'
newline|'\n'
name|'filename'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'orig_path'
op|')'
newline|'\n'
name|'new_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'sr_path'
op|','
name|'filename'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'rename'
op|'('
name|'orig_path'
op|','
name|'new_path'
op|')'
newline|'\n'
name|'return'
name|'new_path'
newline|'\n'
nl|'\n'
DECL|function|assert_vhd_not_hidden
dedent|''
name|'def'
name|'assert_vhd_not_hidden'
op|'('
name|'path'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        This is a sanity check on the image; if a snap.vhd isn\'t\n        present, then the image.vhd better not be marked \'hidden\' or it will\n        be deleted when moved into the SR.\n        """'
newline|'\n'
name|'query_cmd'
op|'='
string|'"vhd-util query -n %(path)s -f"'
op|'%'
name|'locals'
op|'('
op|')'
newline|'\n'
name|'query_proc'
op|'='
name|'make_subprocess'
op|'('
name|'query_cmd'
op|','
name|'stdout'
op|'='
name|'True'
op|','
name|'stderr'
op|'='
name|'True'
op|')'
newline|'\n'
name|'out'
op|','
name|'err'
op|'='
name|'finish_subprocess'
op|'('
name|'query_proc'
op|','
name|'query_cmd'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'line'
name|'in'
name|'out'
op|'.'
name|'splitlines'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'line'
op|'.'
name|'startswith'
op|'('
string|"'hidden'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'value'
op|'='
name|'line'
op|'.'
name|'split'
op|'('
string|"':'"
op|')'
op|'['
number|'1'
op|']'
op|'.'
name|'strip'
op|'('
op|')'
newline|'\n'
name|'if'
name|'value'
op|'=='
string|'"1"'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'Exception'
op|'('
nl|'\n'
string|'"VHD %(path)s is marked as hidden without child"'
op|'%'
nl|'\n'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|prepare_if_exists
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'prepare_if_exists'
op|'('
name|'staging_path'
op|','
name|'vhd_name'
op|','
name|'parent_path'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check for existance of a particular VHD in the staging path and\n        preparing it for moving into the SR.\n\n        Returns: Tuple of (Path to move into the SR, VDI_UUID)\n                 None, if the vhd_name doesn\'t exist in the staging path\n\n        If the VHD exists, we will do the following:\n            1. Rename it with a UUID.\n            2. If parent_path exists, we\'ll link up the VHDs.\n        """'
newline|'\n'
name|'orig_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'staging_path'
op|','
name|'vhd_name'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'orig_path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'new_path'
op|','
name|'vdi_uuid'
op|'='
name|'rename_with_uuid'
op|'('
name|'orig_path'
op|')'
newline|'\n'
name|'if'
name|'parent_path'
op|':'
newline|'\n'
comment|"# NOTE(sirp): this step is necessary so that an SR scan won't"
nl|'\n'
comment|'# delete the base_copy out from under us (since it would be'
nl|'\n'
comment|'# orphaned)'
nl|'\n'
indent|'            '
name|'link_vhds'
op|'('
name|'new_path'
op|','
name|'parent_path'
op|')'
newline|'\n'
dedent|''
name|'return'
op|'('
name|'new_path'
op|','
name|'vdi_uuid'
op|')'
newline|'\n'
nl|'\n'
DECL|function|validate_vdi_chain
dedent|''
name|'def'
name|'validate_vdi_chain'
op|'('
name|'vdi_path'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        This check ensures that the parent pointers on the VHDs are valid\n        before we move the VDI chain to the SR. This is *very* important\n        because a bad parent pointer will corrupt the SR causing a cascade of\n        failures.\n        """'
newline|'\n'
DECL|function|get_parent_path
name|'def'
name|'get_parent_path'
op|'('
name|'path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'query_cmd'
op|'='
string|'"vhd-util query -n %(path)s -p"'
op|'%'
name|'locals'
op|'('
op|')'
newline|'\n'
name|'query_proc'
op|'='
name|'make_subprocess'
op|'('
name|'query_cmd'
op|','
name|'stdout'
op|'='
name|'True'
op|','
name|'stderr'
op|'='
name|'True'
op|')'
newline|'\n'
name|'out'
op|','
name|'err'
op|'='
name|'finish_subprocess'
op|'('
nl|'\n'
name|'query_proc'
op|','
name|'query_cmd'
op|','
name|'ok_exit_codes'
op|'='
op|'['
number|'0'
op|','
number|'22'
op|']'
op|')'
newline|'\n'
name|'first_line'
op|'='
name|'out'
op|'.'
name|'splitlines'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|'.'
name|'strip'
op|'('
op|')'
newline|'\n'
name|'if'
name|'first_line'
op|'.'
name|'endswith'
op|'('
string|'".vhd"'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'first_line'
newline|'\n'
dedent|''
name|'elif'
string|"'has no parent'"
name|'in'
name|'first_line'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'elif'
string|"'query failed'"
name|'in'
name|'first_line'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'Exception'
op|'('
string|'"VDI \'%(path)s\' not present which breaks"'
nl|'\n'
string|'" the VDI chain, bailing out"'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'Exception'
op|'('
string|'"Unexpected output \'%(out)s\' from vhd-util"'
op|'%'
nl|'\n'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'cur_path'
op|'='
name|'vdi_path'
newline|'\n'
name|'while'
name|'cur_path'
op|':'
newline|'\n'
indent|'            '
name|'cur_path'
op|'='
name|'get_parent_path'
op|'('
name|'cur_path'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'vdi_return_list'
op|'='
op|'['
op|']'
newline|'\n'
name|'paths_to_move'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'image_parent'
op|'='
name|'None'
newline|'\n'
name|'base_info'
op|'='
name|'prepare_if_exists'
op|'('
name|'staging_path'
op|','
string|"'base.vhd'"
op|')'
newline|'\n'
name|'if'
name|'base_info'
op|':'
newline|'\n'
indent|'        '
name|'paths_to_move'
op|'.'
name|'append'
op|'('
name|'base_info'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
name|'image_parent'
op|'='
name|'base_info'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'image_info'
op|'='
name|'prepare_if_exists'
op|'('
name|'staging_path'
op|','
string|"'image.vhd'"
op|','
name|'image_parent'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'image_info'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'Exception'
op|'('
string|'"Invalid image: image.vhd not present"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'paths_to_move'
op|'.'
name|'insert'
op|'('
number|'0'
op|','
name|'image_info'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'snap_info'
op|'='
name|'prepare_if_exists'
op|'('
name|'staging_path'
op|','
string|"'snap.vhd'"
op|','
nl|'\n'
name|'image_info'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
name|'if'
name|'snap_info'
op|':'
newline|'\n'
indent|'        '
name|'validate_vdi_chain'
op|'('
name|'snap_info'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
comment|'# NOTE(sirp): this is an insert rather than an append since the'
nl|'\n'
comment|"# 'snapshot' vhd needs to be copied into the SR before the base copy."
nl|'\n'
comment|"# If it doesn't, then there is a possibliity that snapwatchd will"
nl|'\n'
comment|'# delete the base_copy since it is an unreferenced parent.'
nl|'\n'
name|'paths_to_move'
op|'.'
name|'insert'
op|'('
number|'0'
op|','
name|'snap_info'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
comment|'# We return this snap as the VDI instead of image.vhd'
nl|'\n'
name|'vdi_return_list'
op|'.'
name|'append'
op|'('
name|'dict'
op|'('
name|'vdi_type'
op|'='
string|'"root"'
op|','
name|'vdi_uuid'
op|'='
name|'snap_info'
op|'['
number|'1'
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'validate_vdi_chain'
op|'('
name|'image_info'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
name|'assert_vhd_not_hidden'
op|'('
name|'image_info'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
comment|"# If there's no snap, we return the image.vhd UUID"
nl|'\n'
name|'vdi_return_list'
op|'.'
name|'append'
op|'('
name|'dict'
op|'('
name|'vdi_type'
op|'='
string|'"root"'
op|','
name|'vdi_uuid'
op|'='
name|'image_info'
op|'['
number|'1'
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'swap_info'
op|'='
name|'prepare_if_exists'
op|'('
name|'staging_path'
op|','
string|"'swap.vhd'"
op|')'
newline|'\n'
name|'if'
name|'swap_info'
op|':'
newline|'\n'
indent|'        '
name|'assert_vhd_not_hidden'
op|'('
name|'swap_info'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
name|'paths_to_move'
op|'.'
name|'append'
op|'('
name|'swap_info'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
name|'vdi_return_list'
op|'.'
name|'append'
op|'('
name|'dict'
op|'('
name|'vdi_type'
op|'='
string|'"swap"'
op|','
name|'vdi_uuid'
op|'='
name|'swap_info'
op|'['
number|'1'
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'path'
name|'in'
name|'paths_to_move'
op|':'
newline|'\n'
indent|'        '
name|'move_into_sr'
op|'('
name|'path'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'vdi_return_list'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|prepare_staging_area_for_upload
dedent|''
name|'def'
name|'prepare_staging_area_for_upload'
op|'('
name|'sr_path'
op|','
name|'staging_path'
op|','
name|'vdi_uuids'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Hard-link VHDs into staging area with appropriate filename\n    (\'snap\' or \'image.vhd\')\n    """'
newline|'\n'
name|'for'
name|'name'
op|','
name|'uuid'
name|'in'
name|'vdi_uuids'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'uuid'
op|':'
newline|'\n'
indent|'            '
name|'source'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'sr_path'
op|','
string|'"%s.vhd"'
op|'%'
name|'uuid'
op|')'
newline|'\n'
name|'link_name'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'staging_path'
op|','
string|'"%s.vhd"'
op|'%'
name|'name'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'link'
op|'('
name|'source'
op|','
name|'link_name'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|create_tarball
dedent|''
dedent|''
dedent|''
name|'def'
name|'create_tarball'
op|'('
name|'fileobj'
op|','
name|'path'
op|','
name|'callback'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Create a tarball from a given path.\n\n    :param fileobj: a file-like object holding the tarball byte-stream.\n                    If None, then only the callback will be used.\n    :param path: path to create tarball from\n    :param callback: optional callback to call on each chunk written\n    """'
newline|'\n'
name|'tar_cmd'
op|'='
string|'"tar -zc --directory=%(path)s ."'
op|'%'
name|'locals'
op|'('
op|')'
newline|'\n'
name|'tar_proc'
op|'='
name|'make_subprocess'
op|'('
name|'tar_cmd'
op|','
name|'stdout'
op|'='
name|'True'
op|','
name|'stderr'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'        '
name|'chunk'
op|'='
name|'tar_proc'
op|'.'
name|'stdout'
op|'.'
name|'read'
op|'('
name|'CHUNK_SIZE'
op|')'
newline|'\n'
name|'if'
name|'chunk'
op|'=='
string|"''"
op|':'
newline|'\n'
indent|'            '
name|'break'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'callback'
op|':'
newline|'\n'
indent|'            '
name|'callback'
op|'('
name|'chunk'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'fileobj'
op|':'
newline|'\n'
indent|'            '
name|'fileobj'
op|'.'
name|'write'
op|'('
name|'chunk'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'finish_subprocess'
op|'('
name|'tar_proc'
op|','
name|'tar_cmd'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|extract_tarball
dedent|''
name|'def'
name|'extract_tarball'
op|'('
name|'fileobj'
op|','
name|'path'
op|','
name|'callback'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Extract a tarball to a given path.\n\n    :param fileobj: a file-like object holding the tarball byte-stream\n    :param path: path to extract tarball into\n    :param callback: optional callback to call on each chunk read\n    """'
newline|'\n'
name|'tar_cmd'
op|'='
string|'"tar -zx --directory=%(path)s"'
op|'%'
name|'locals'
op|'('
op|')'
newline|'\n'
name|'tar_proc'
op|'='
name|'make_subprocess'
op|'('
name|'tar_cmd'
op|','
name|'stderr'
op|'='
name|'True'
op|','
name|'stdin'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'        '
name|'chunk'
op|'='
name|'fileobj'
op|'.'
name|'read'
op|'('
name|'CHUNK_SIZE'
op|')'
newline|'\n'
name|'if'
name|'chunk'
op|'=='
string|"''"
op|':'
newline|'\n'
indent|'            '
name|'break'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'callback'
op|':'
newline|'\n'
indent|'            '
name|'callback'
op|'('
name|'chunk'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'tar_proc'
op|'.'
name|'stdin'
op|'.'
name|'write'
op|'('
name|'chunk'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'finish_subprocess'
op|'('
name|'tar_proc'
op|','
name|'tar_cmd'
op|')'
newline|'\n'
dedent|''
endmarker|''
end_unit
