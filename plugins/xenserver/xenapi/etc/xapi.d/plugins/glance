#!/usr/bin/env python

# Copyright (c) 2010 Citrix Systems, Inc.
# Copyright 2010 United States Government as represented by the
# Administrator of the National Aeronautics and Space Administration.
# All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

#
# XenAPI plugin for managing glance images
#

import base64
import errno
import hmac
import httplib
import os
import os.path
import pickle
import sha
import shlex
import shutil
import subprocess
import tempfile
import time
import urlparse

import XenAPIPlugin

#FIXME(sirp): should this use pluginlib from 5.6?
from pluginlib_nova import *
configure_logging('glance')

CHUNK_SIZE = 8192
KERNEL_DIR = '/boot/guest'
FILE_SR_PATH = '/var/run/sr-mount'

def copy_kernel_vdi(session,args):
    vdi = exists(args, 'vdi-ref')
    size = exists(args,'image-size')
    #Use the uuid as a filename
    vdi_uuid=session.xenapi.VDI.get_uuid(vdi)
    copy_args={'vdi_uuid':vdi_uuid,'vdi_size':int(size)}
    filename=with_vdi_in_dom0(session, vdi, False,
                              lambda dev:
                              _copy_kernel_vdi('/dev/%s' % dev,copy_args))
    return filename

def _copy_kernel_vdi(dest,copy_args):
    vdi_uuid=copy_args['vdi_uuid']
    vdi_size=copy_args['vdi_size']
    logging.debug("copying kernel/ramdisk file from %s to /boot/guest/%s",dest,vdi_uuid)
    filename=KERNEL_DIR + '/' + vdi_uuid
    #read data from /dev/ and write into a file on /boot/guest
    of=open(filename,'wb')
    f=open(dest,'rb')
    #copy only vdi_size bytes
    data=f.read(vdi_size)
    of.write(data)
    f.close()
    of.close()
    logging.debug("Done. Filename: %s",filename)
    return filename


def execute(cmd):
    args = shlex.split(cmd)
    proc = subprocess.Popen(
        args, stdout=subprocess.PIPE, stdin=subprocess.PIPE)
    return proc


def get_vdi(session, args):
    """
    """
    params = pickle.loads(exists(args, 'params'))
    image_id = params["image_id"]
    glance_host = params["glance_host"]
    glance_port = params["glance_port"]

    def unbundle_xfer(sr_path, staging_path):
        """

        """
        conn = httplib.HTTPConnection(glance_host, glance_port)
        conn.request('GET', '/images/%s' % image_id)
        resp = conn.getresponse()
        if resp.status == httplib.NOT_FOUND:
            raise Exception("Image '%s' not found in Glance" % image_id)
        elif resp.status != httplib.OK:
            raise Exception("Unexpected response from Glance %i" % res.status)

        tar_proc = execute("tar -zx --directory=%(staging_path)s" % locals())
        chunk = resp.read(CHUNK_SIZE)
        while chunk:
            tar_proc.stdin.write(chunk)
            chunk = resp.read(CHUNK_SIZE)
        out, err = tar_proc.communicate()
        # TODO(sirp): write assert_process_success
        ret = tar_proc.returncode
        if ret != 0:
            raise Exception(
                "tar returned non-zero exit code (%i): '%s'" % (ret, err))
        conn.close()

    def fixup_vhds(sr_path, staging_path):
        """
        """
        def rename_with_uuid(orig_path):
            """Generate a uuid and rename the file with the uuid"""
            orig_dirname = os.path.dirname(orig_path)
            uuid = generate_uuid()
            new_path = os.path.join(orig_dirname, "%s.vhd" % uuid)
            os.rename(orig_path, new_path)
            return new_path, uuid

        def move_into_sr(orig_path):
            """Move a file into the SR"""
            filename = os.path.basename(orig_path)
            new_path = os.path.join(sr_path, filename)
            os.rename(orig_path, new_path)
            return new_path

        def link_vhds(child_path, parent_path):
            proc = execute("vhd-util modify -n %(child_path)s -p %(parent_path)s"
                           % locals())
            out, err = proc.communicate()
            if proc.returncode != 0:
                raise Exception("Failed to link vhds: '%s'" % err)

        image_path = os.path.join(staging_path, 'image')

        orig_base_copy_path = os.path.join(image_path, 'image.vhd')
        if not os.path.exists(orig_base_copy_path):
            raise Exception("Invalid image: image.vhd not present")

        base_copy_path, base_copy_uuid = rename_with_uuid(orig_base_copy_path)

        vdi_uuid = base_copy_uuid
        orig_snap_path = os.path.join(image_path, 'snap.vhd')
        if os.path.exists(orig_snap_path):
            snap_path, snap_uuid = rename_with_uuid(orig_snap_path)
            vdi_uuid = snap_uuid
            # NOTE(sirp): this step is necessary so that an SR scan won't
            # delete the base_copy out from under us (since it would be
            # orphaned)
            link_vhds(snap_path, base_copy_path) 
            move_into_sr(snap_path)

        move_into_sr(base_copy_path)
        return vdi_uuid

    sr_path = get_sr_path(session)
    staging_path = make_staging_area(sr_path)
    try:
        unbundle_xfer(sr_path, staging_path)
        vdi_uuid = fixup_vhds(sr_path, staging_path)
        return vdi_uuid
    finally:
        cleanup_staging_area(staging_path)


def put_vdis(session, args):
    """
    """
    params = pickle.loads(exists(args, 'params'))
    vdi_uuids = params["vdi_uuids"]
    image_id = params["image_id"]
    glance_host = params["glance_host"]
    glance_port = params["glance_port"]

    def prepare_staging_area(sr_path, staging_path):
        """
        Explain preparing staging area here...
        """
        image_path = os.path.join(staging_path, 'image')
        os.mkdir(image_path)
        for name, uuid in vdi_uuids.items():
            source = os.path.join(sr_path, "%s.vhd" % uuid)
            link_name = os.path.join(image_path, "%s.vhd" % name)
            os.link(source, link_name)

    def bundle_xfer(staging_path):
        conn = httplib.HTTPConnection(glance_host, glance_port)
        #NOTE(sirp): httplib under python2.4 won't accept a file-like object
        # to request
        conn.putrequest('PUT', '/images/%s' % image_id)

        headers = {
            'x-image-meta-store': 'file',
            'x-image-meta-is_public': 'True',
            'x-image-meta-type': 'raw',
            'x-image-meta-property-disk-format': 'vhd',
            'x-image-meta-property-container-format': 'tarball',
            'transfer-encoding': "chunked",
            'content-type': 'application/octet-stream',
         }
        for header, value in headers.iteritems():
            conn.putheader(header, value)
        conn.endheaders()

        tar_proc = execute("tar -zc --directory=%(staging_path)s ." % locals())

        chunk = tar_proc.stdout.read(CHUNK_SIZE)
        while chunk:
            conn.send("%x\r\n%s\r\n" % (len(chunk), chunk))
            chunk = tar_proc.stdout.read(CHUNK_SIZE)
        conn.send("0\r\n\r\n")

        resp = conn.getresponse()
        #FIXME(sirp): should this be 201 Created?
        if resp.status != httplib.OK:
            raise Exception("Unexpected response from Glance %i" % res.status)

        conn.close()

    sr_path = get_sr_path(session)
    staging_path = make_staging_area(sr_path)
    try:
        prepare_staging_area(sr_path, staging_path)
        bundle_xfer(staging_path)
    finally:
        cleanup_staging_area(staging_path)

    return "" # FIXME(sirp): return anything useful here?


def make_staging_area(sr_path):
    """
    Explain staging area here...
    """
    # NOTE(sirp): staging area is created in SR to allow hard-linking
    staging_path = tempfile.mkdtemp(dir=sr_path)
    return staging_path


def cleanup_staging_area(staging_path):
    shutil.rmtree(staging_path)


def get_sr_path(session):
    sr_ref = find_sr(session)

    if sr_ref is None:
        raise Exception('Cannot find SR to read VDI from')

    sr_rec = session.xenapi.SR.get_record(sr_ref)
    sr_uuid = sr_rec["uuid"]
    sr_path = os.path.join(FILE_SR_PATH, sr_uuid)
    return sr_path


#TODO(sirp): both objectstore and glance need this, should this be refactored
#into common lib
def find_sr(session):
    host = get_this_host(session)
    srs = session.xenapi.SR.get_all()
    for sr in srs:
        sr_rec = session.xenapi.SR.get_record(sr)
        if not ('i18n-key' in sr_rec['other_config'] and
                sr_rec['other_config']['i18n-key'] == 'local-storage'):
            continue
        for pbd in sr_rec['PBDs']:
            pbd_rec = session.xenapi.PBD.get_record(pbd)
            if pbd_rec['host'] == host:
                return sr
    return None

def generate_uuid():
    # NOTE(sirp): Python2.4 does not include the uuid module
    proc = execute("uuidgen")
    uuid = proc.stdout.read().strip()
    return uuid

if __name__ == '__main__':
    XenAPIPlugin.dispatch({'put_vdis': put_vdis,
                           'get_vdi': get_vdi,
                           'copy_kernel_vdi': copy_kernel_vdi})
