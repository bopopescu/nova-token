#!/usr/bin/env python

# Copyright (c) 2010 Citrix Systems, Inc.
# Copyright 2010 United States Government as represented by the
# Administrator of the National Aeronautics and Space Administration.
# All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.

#
# XenAPI plugin for managing glance images
#

import httplib
import os
import os.path
import pickle
import shlex
import shutil
import subprocess
import tempfile

import XenAPIPlugin

#FIXME(sirp): should this use pluginlib from 5.6?
from pluginlib_nova import *
configure_logging('glance')

CHUNK_SIZE = 8192
KERNEL_DIR = '/boot/guest'

def copy_kernel_vdi(session,args):
    vdi = exists(args, 'vdi-ref')
    size = exists(args,'image-size')
    #Use the uuid as a filename
    vdi_uuid=session.xenapi.VDI.get_uuid(vdi)
    copy_args={'vdi_uuid':vdi_uuid,'vdi_size':int(size)}
    filename=with_vdi_in_dom0(session, vdi, False,
                              lambda dev:
                              _copy_kernel_vdi('/dev/%s' % dev,copy_args))
    return filename

def _copy_kernel_vdi(dest,copy_args):
    vdi_uuid=copy_args['vdi_uuid']
    vdi_size=copy_args['vdi_size']
    logging.debug("copying kernel/ramdisk file from %s to /boot/guest/%s",dest,vdi_uuid)
    filename=KERNEL_DIR + '/' + vdi_uuid
    #read data from /dev/ and write into a file on /boot/guest
    of=open(filename,'wb')
    f=open(dest,'rb')
    #copy only vdi_size bytes
    data=f.read(vdi_size)
    of.write(data)
    f.close()
    of.close()
    logging.debug("Done. Filename: %s",filename)
    return filename


def get_vdi(session, args):
    """
    """
    params = pickle.loads(exists(args, 'params'))
    image_id = params["image_id"]
    glance_host = params["glance_host"]
    glance_port = params["glance_port"]
    uuid_stack = params["uuid_stack"]
    sr_path = params["sr_path"]

    def unbundle_xfer(sr_path, staging_path):
        """

        """
        conn = httplib.HTTPConnection(glance_host, glance_port)
        conn.request('GET', '/images/%s' % image_id)
        resp = conn.getresponse()
        if resp.status == httplib.NOT_FOUND:
            raise Exception("Image '%s' not found in Glance" % image_id)
        elif resp.status != httplib.OK:
            raise Exception("Unexpected response from Glance %i" % res.status)

        tar_args = shlex.split(
            "tar -zx --directory=%(staging_path)s" % locals())
        tar_proc = subprocess.Popen(
            tar_args, stderr=subprocess.PIPE, stdin=subprocess.PIPE)

        chunk = resp.read(CHUNK_SIZE)
        while chunk:
            tar_proc.stdin.write(chunk)
            chunk = resp.read(CHUNK_SIZE)

        _assert_process_success(tar_proc, "tar")
        conn.close()

    def fixup_vhds(sr_path, staging_path):
        """
        """
        def rename_with_uuid(orig_path):
            """Generate a uuid and rename the file with the uuid"""
            orig_dirname = os.path.dirname(orig_path)
            uuid = uuid_stack.pop()
            new_path = os.path.join(orig_dirname, "%s.vhd" % uuid)
            os.rename(orig_path, new_path)
            return new_path, uuid

        def move_into_sr(orig_path):
            """Move a file into the SR"""
            filename = os.path.basename(orig_path)
            new_path = os.path.join(sr_path, filename)
            os.rename(orig_path, new_path)
            return new_path

        def link_vhds(child_path, parent_path):
            modify_args = shlex.split(
                "vhd-util modify -n %(child_path)s -p %(parent_path)s"
                % locals())
            modify_proc = subprocess.Popen(
                modify_args, stderr=subprocess.PIPE)
            _assert_process_success(modify_proc, "vhd-util")


        image_path = os.path.join(staging_path, 'image')

        orig_base_copy_path = os.path.join(image_path, 'image.vhd')
        if not os.path.exists(orig_base_copy_path):
            raise Exception("Invalid image: image.vhd not present")

        base_copy_path, base_copy_uuid = rename_with_uuid(orig_base_copy_path)

        vdi_uuid = base_copy_uuid
        orig_snap_path = os.path.join(image_path, 'snap.vhd')
        if os.path.exists(orig_snap_path):
            snap_path, snap_uuid = rename_with_uuid(orig_snap_path)
            vdi_uuid = snap_uuid
            # NOTE(sirp): this step is necessary so that an SR scan won't
            # delete the base_copy out from under us (since it would be
            # orphaned)
            link_vhds(snap_path, base_copy_path) 
            move_into_sr(snap_path)

        move_into_sr(base_copy_path)
        return vdi_uuid

    staging_path = _make_staging_area(sr_path)
    try:
        unbundle_xfer(sr_path, staging_path)
        vdi_uuid = fixup_vhds(sr_path, staging_path)
        return vdi_uuid
    finally:
        _cleanup_staging_area(staging_path)


def put_vdis(session, args):
    """
    """
    params = pickle.loads(exists(args, 'params'))
    vdi_uuids = params["vdi_uuids"]
    image_id = params["image_id"]
    glance_host = params["glance_host"]
    glance_port = params["glance_port"]
    sr_path = params["sr_path"]

    staging_path = _make_staging_area(sr_path)
    try:
        _prepare_staging_area_for_upload(sr_path, staging_path, vdi_uuids)
        _bundle_xfer(staging_path, image_id, glance_host, glance_port)
    finally:
        _cleanup_staging_area(staging_path)

    return ""


def _prepare_staging_area_for_upload(sr_path, staging_path, vdi_uuids):
    """
    Explain preparing staging area here...
    """
    image_path = os.path.join(staging_path, 'image')
    os.mkdir(image_path)
    for name, uuid in vdi_uuids.items():
        source = os.path.join(sr_path, "%s.vhd" % uuid)
        link_name = os.path.join(image_path, "%s.vhd" % name)
        os.link(source, link_name)


def _bundle_xfer(staging_path, image_id, glance_host, glance_port):
    """
    """
    conn = httplib.HTTPConnection(glance_host, glance_port)
    #NOTE(sirp): httplib under python2.4 won't accept a file-like object
    # to request
    conn.putrequest('PUT', '/images/%s' % image_id)

    headers = {
        'x-image-meta-store': 'file',
        'x-image-meta-is_public': 'True',
        'x-image-meta-type': 'raw',
        'x-image-meta-property-disk-format': 'vhd',
        'x-image-meta-property-container-format': 'tarball',
        'transfer-encoding': "chunked",
        'content-type': 'application/octet-stream',
     }
    for header, value in headers.iteritems():
        conn.putheader(header, value)
    conn.endheaders()

    tar_args = shlex.split(
        "tar -zc --directory=%(staging_path)s ." % locals())
    tar_proc = subprocess.Popen(
        tar_args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    chunk = tar_proc.stdout.read(CHUNK_SIZE)
    while chunk:
        conn.send("%x\r\n%s\r\n" % (len(chunk), chunk))
        chunk = tar_proc.stdout.read(CHUNK_SIZE)
    conn.send("0\r\n\r\n")

    _assert_process_success(tar_proc, "tar")

    resp = conn.getresponse()
    if resp.status != httplib.OK:
        raise Exception("Unexpected response from Glance %i" % res.status)
    conn.close()


def _make_staging_area(sr_path):
    """
    Explain staging area here...
    """
    # NOTE(sirp): staging area is created in SR to allow hard-linking
    staging_path = tempfile.mkdtemp(dir=sr_path)
    return staging_path


def _cleanup_staging_area(staging_path):
    shutil.rmtree(staging_path)


def _assert_process_success(proc, cmd):
    """Ensure that the process returned a zero exit code indicating success
    """
    out, err = proc.communicate()
    ret = proc.returncode
    if ret != 0:
        msg = "%(cmd)s returned non-zero exit code (%i): '%s'" % (ret, err)
        raise Exception(msg)


if __name__ == '__main__':
    XenAPIPlugin.dispatch({'put_vdis': put_vdis,
                           'get_vdi': get_vdi,
                           'copy_kernel_vdi': copy_kernel_vdi})
