begin_unit
string|'"""Utilities to support packages."""'
newline|'\n'
nl|'\n'
comment|'# NOTE: This module must remain compatible with Python 2.3, as it is shared'
nl|'\n'
comment|'# by setuptools for distribution with Python 2.3 and up.'
nl|'\n'
nl|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'sys'
newline|'\n'
name|'import'
name|'imp'
newline|'\n'
name|'import'
name|'os'
op|'.'
name|'path'
newline|'\n'
name|'from'
name|'types'
name|'import'
name|'ModuleType'
newline|'\n'
nl|'\n'
DECL|variable|__all__
name|'__all__'
op|'='
op|'['
nl|'\n'
string|"'get_importer'"
op|','
string|"'iter_importers'"
op|','
string|"'get_loader'"
op|','
string|"'find_loader'"
op|','
nl|'\n'
string|"'walk_packages'"
op|','
string|"'iter_modules'"
op|','
nl|'\n'
string|"'ImpImporter'"
op|','
string|"'ImpLoader'"
op|','
string|"'read_code'"
op|','
string|"'extend_path'"
op|','
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|read_code
name|'def'
name|'read_code'
op|'('
name|'stream'
op|')'
op|':'
newline|'\n'
comment|'# This helper is needed in order for the PEP 302 emulation to'
nl|'\n'
comment|'# correctly handle compiled files'
nl|'\n'
indent|'    '
name|'import'
name|'marshal'
newline|'\n'
nl|'\n'
name|'magic'
op|'='
name|'stream'
op|'.'
name|'read'
op|'('
number|'4'
op|')'
newline|'\n'
name|'if'
name|'magic'
op|'!='
name|'imp'
op|'.'
name|'get_magic'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'stream'
op|'.'
name|'read'
op|'('
number|'4'
op|')'
comment|'# Skip timestamp'
newline|'\n'
name|'return'
name|'marshal'
op|'.'
name|'load'
op|'('
name|'stream'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|simplegeneric
dedent|''
name|'def'
name|'simplegeneric'
op|'('
name|'func'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Make a trivial single-dispatch generic function"""'
newline|'\n'
name|'registry'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
DECL|function|wrapper
name|'def'
name|'wrapper'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'ob'
op|'='
name|'args'
op|'['
number|'0'
op|']'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'cls'
op|'='
name|'ob'
op|'.'
name|'__class__'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'            '
name|'cls'
op|'='
name|'type'
op|'('
name|'ob'
op|')'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'mro'
op|'='
name|'cls'
op|'.'
name|'__mro__'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
nl|'\n'
DECL|class|cls
indent|'                '
name|'class'
name|'cls'
op|'('
name|'cls'
op|','
name|'object'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'pass'
newline|'\n'
nl|'\n'
dedent|''
name|'mro'
op|'='
name|'cls'
op|'.'
name|'__mro__'
op|'['
number|'1'
op|':'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'TypeError'
op|':'
newline|'\n'
indent|'                '
name|'mro'
op|'='
name|'object'
op|','
comment|'# must be an ExtensionClass or some such  :('
newline|'\n'
dedent|''
dedent|''
name|'for'
name|'t'
name|'in'
name|'mro'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'t'
name|'in'
name|'registry'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'registry'
op|'['
name|'t'
op|']'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'func'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'wrapper'
op|'.'
name|'__name__'
op|'='
name|'func'
op|'.'
name|'__name__'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'TypeError'
op|','
name|'AttributeError'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
comment|"# Python 2.3 doesn't allow functions to be renamed"
newline|'\n'
nl|'\n'
DECL|function|register
dedent|''
name|'def'
name|'register'
op|'('
name|'typ'
op|','
name|'func'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'func'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'lambda'
name|'f'
op|':'
name|'register'
op|'('
name|'typ'
op|','
name|'f'
op|')'
newline|'\n'
dedent|''
name|'registry'
op|'['
name|'typ'
op|']'
op|'='
name|'func'
newline|'\n'
name|'return'
name|'func'
newline|'\n'
nl|'\n'
dedent|''
name|'wrapper'
op|'.'
name|'__dict__'
op|'='
name|'func'
op|'.'
name|'__dict__'
newline|'\n'
name|'wrapper'
op|'.'
name|'__doc__'
op|'='
name|'func'
op|'.'
name|'__doc__'
newline|'\n'
name|'wrapper'
op|'.'
name|'register'
op|'='
name|'register'
newline|'\n'
name|'return'
name|'wrapper'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|walk_packages
dedent|''
name|'def'
name|'walk_packages'
op|'('
name|'path'
op|'='
name|'None'
op|','
name|'prefix'
op|'='
string|"''"
op|','
name|'onerror'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Yields (module_loader, name, ispkg) for all modules recursively\n    on path, or, if path is None, all accessible modules.\n\n    \'path\' should be either None or a list of paths to look for\n    modules in.\n\n    \'prefix\' is a string to output on the front of every module name\n    on output.\n\n    Note that this function must import all *packages* (NOT all\n    modules!) on the given path, in order to access the __path__\n    attribute to find submodules.\n\n    \'onerror\' is a function which gets called with one argument (the\n    name of the package which was being imported) if any exception\n    occurs while trying to import a package.  If no onerror function is\n    supplied, ImportErrors are caught and ignored, while all other\n    exceptions are propagated, terminating the search.\n\n    Examples:\n\n    # list all modules python can access\n    walk_packages()\n\n    # list all submodules of ctypes\n    walk_packages(ctypes.__path__, ctypes.__name__+\'.\')\n    """'
newline|'\n'
nl|'\n'
DECL|function|seen
name|'def'
name|'seen'
op|'('
name|'p'
op|','
name|'m'
op|'='
op|'{'
op|'}'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'p'
name|'in'
name|'m'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'m'
op|'['
name|'p'
op|']'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'importer'
op|','
name|'name'
op|','
name|'ispkg'
name|'in'
name|'iter_modules'
op|'('
name|'path'
op|','
name|'prefix'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'yield'
name|'importer'
op|','
name|'name'
op|','
name|'ispkg'
newline|'\n'
nl|'\n'
name|'if'
name|'ispkg'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'__import__'
op|'('
name|'name'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'onerror'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'onerror'
op|'('
name|'name'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'onerror'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'onerror'
op|'('
name|'name'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'path'
op|'='
name|'getattr'
op|'('
name|'sys'
op|'.'
name|'modules'
op|'['
name|'name'
op|']'
op|','
string|"'__path__'"
op|','
name|'None'
op|')'
name|'or'
op|'['
op|']'
newline|'\n'
nl|'\n'
comment|"# don't traverse path items we've seen before"
nl|'\n'
name|'path'
op|'='
op|'['
name|'p'
name|'for'
name|'p'
name|'in'
name|'path'
name|'if'
name|'not'
name|'seen'
op|'('
name|'p'
op|')'
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'item'
name|'in'
name|'walk_packages'
op|'('
name|'path'
op|','
name|'name'
op|'+'
string|"'.'"
op|','
name|'onerror'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'yield'
name|'item'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|iter_modules
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'iter_modules'
op|'('
name|'path'
op|'='
name|'None'
op|','
name|'prefix'
op|'='
string|"''"
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Yields (module_loader, name, ispkg) for all submodules on path,\n    or, if path is None, all top-level modules on sys.path.\n\n    \'path\' should be either None or a list of paths to look for\n    modules in.\n\n    \'prefix\' is a string to output on the front of every module name\n    on output.\n    """'
newline|'\n'
nl|'\n'
name|'if'
name|'path'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'importers'
op|'='
name|'iter_importers'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'importers'
op|'='
name|'map'
op|'('
name|'get_importer'
op|','
name|'path'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'yielded'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'importers'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'name'
op|','
name|'ispkg'
name|'in'
name|'iter_importer_modules'
op|'('
name|'i'
op|','
name|'prefix'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'name'
name|'not'
name|'in'
name|'yielded'
op|':'
newline|'\n'
indent|'                '
name|'yielded'
op|'['
name|'name'
op|']'
op|'='
number|'1'
newline|'\n'
name|'yield'
name|'i'
op|','
name|'name'
op|','
name|'ispkg'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'#@simplegeneric'
nl|'\n'
DECL|function|iter_importer_modules
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'iter_importer_modules'
op|'('
name|'importer'
op|','
name|'prefix'
op|'='
string|"''"
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'not'
name|'hasattr'
op|'('
name|'importer'
op|','
string|"'iter_modules'"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'['
op|']'
newline|'\n'
dedent|''
name|'return'
name|'importer'
op|'.'
name|'iter_modules'
op|'('
name|'prefix'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|iter_importer_modules
dedent|''
name|'iter_importer_modules'
op|'='
name|'simplegeneric'
op|'('
name|'iter_importer_modules'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ImpImporter
name|'class'
name|'ImpImporter'
op|':'
newline|'\n'
indent|'    '
string|'"""PEP 302 Importer that wraps Python\'s "classic" import algorithm\n\n    ImpImporter(dirname) produces a PEP 302 importer that searches that\n    directory.  ImpImporter(None) produces a PEP 302 importer that searches\n    the current sys.path, plus any modules that are frozen or built-in.\n\n    Note that ImpImporter does not currently support being used by placement\n    on sys.meta_path.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'path'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'path'
op|'='
name|'path'
newline|'\n'
nl|'\n'
DECL|member|find_module
dedent|''
name|'def'
name|'find_module'
op|'('
name|'self'
op|','
name|'fullname'
op|','
name|'path'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
comment|"# Note: we ignore 'path' argument since it is only used via meta_path"
nl|'\n'
indent|'        '
name|'subname'
op|'='
name|'fullname'
op|'.'
name|'split'
op|'('
string|'"."'
op|')'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
name|'if'
name|'subname'
op|'!='
name|'fullname'
name|'and'
name|'self'
op|'.'
name|'path'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'path'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'path'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'path'
op|'='
op|'['
name|'os'
op|'.'
name|'path'
op|'.'
name|'realpath'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
op|']'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'file'
op|','
name|'filename'
op|','
name|'etc'
op|'='
name|'imp'
op|'.'
name|'find_module'
op|'('
name|'subname'
op|','
name|'path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'return'
name|'ImpLoader'
op|'('
name|'fullname'
op|','
name|'file'
op|','
name|'filename'
op|','
name|'etc'
op|')'
newline|'\n'
nl|'\n'
DECL|member|iter_modules
dedent|''
name|'def'
name|'iter_modules'
op|'('
name|'self'
op|','
name|'prefix'
op|'='
string|"''"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'path'
name|'is'
name|'None'
name|'or'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'isdir'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'yielded'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'import'
name|'inspect'
newline|'\n'
nl|'\n'
name|'filenames'
op|'='
name|'os'
op|'.'
name|'listdir'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'filenames'
op|'.'
name|'sort'
op|'('
op|')'
comment|'# handle packages before same-named modules'
newline|'\n'
nl|'\n'
name|'for'
name|'fn'
name|'in'
name|'filenames'
op|':'
newline|'\n'
indent|'            '
name|'modname'
op|'='
name|'inspect'
op|'.'
name|'getmodulename'
op|'('
name|'fn'
op|')'
newline|'\n'
name|'if'
name|'modname'
op|'=='
string|"'__init__'"
name|'or'
name|'modname'
name|'in'
name|'yielded'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'path'
op|','
name|'fn'
op|')'
newline|'\n'
name|'ispkg'
op|'='
name|'False'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'modname'
name|'and'
name|'os'
op|'.'
name|'path'
op|'.'
name|'isdir'
op|'('
name|'path'
op|')'
name|'and'
string|"'.'"
name|'not'
name|'in'
name|'fn'
op|':'
newline|'\n'
indent|'                '
name|'modname'
op|'='
name|'fn'
newline|'\n'
name|'for'
name|'fn'
name|'in'
name|'os'
op|'.'
name|'listdir'
op|'('
name|'path'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'subname'
op|'='
name|'inspect'
op|'.'
name|'getmodulename'
op|'('
name|'fn'
op|')'
newline|'\n'
name|'if'
name|'subname'
op|'=='
string|"'__init__'"
op|':'
newline|'\n'
indent|'                        '
name|'ispkg'
op|'='
name|'True'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
comment|'# not a package'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'modname'
name|'and'
string|"'.'"
name|'not'
name|'in'
name|'modname'
op|':'
newline|'\n'
indent|'                '
name|'yielded'
op|'['
name|'modname'
op|']'
op|'='
number|'1'
newline|'\n'
name|'yield'
name|'prefix'
op|'+'
name|'modname'
op|','
name|'ispkg'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ImpLoader
dedent|''
dedent|''
dedent|''
dedent|''
name|'class'
name|'ImpLoader'
op|':'
newline|'\n'
indent|'    '
string|'"""PEP 302 Loader that wraps Python\'s "classic" import algorithm\n    """'
newline|'\n'
name|'code'
op|'='
name|'source'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'fullname'
op|','
name|'file'
op|','
name|'filename'
op|','
name|'etc'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'file'
op|'='
name|'file'
newline|'\n'
name|'self'
op|'.'
name|'filename'
op|'='
name|'filename'
newline|'\n'
name|'self'
op|'.'
name|'fullname'
op|'='
name|'fullname'
newline|'\n'
name|'self'
op|'.'
name|'etc'
op|'='
name|'etc'
newline|'\n'
nl|'\n'
DECL|member|load_module
dedent|''
name|'def'
name|'load_module'
op|'('
name|'self'
op|','
name|'fullname'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_reopen'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'mod'
op|'='
name|'imp'
op|'.'
name|'load_module'
op|'('
name|'fullname'
op|','
name|'self'
op|'.'
name|'file'
op|','
name|'self'
op|'.'
name|'filename'
op|','
name|'self'
op|'.'
name|'etc'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'file'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'file'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
comment|"# Note: we don't set __loader__ because we want the module to look"
nl|'\n'
comment|'# normal; i.e. this is just a wrapper for standard import machinery'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'mod'
newline|'\n'
nl|'\n'
DECL|member|get_data
dedent|''
name|'def'
name|'get_data'
op|'('
name|'self'
op|','
name|'pathname'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'open'
op|'('
name|'pathname'
op|','
string|'"rb"'
op|')'
op|'.'
name|'read'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_reopen
dedent|''
name|'def'
name|'_reopen'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'file'
name|'and'
name|'self'
op|'.'
name|'file'
op|'.'
name|'closed'
op|':'
newline|'\n'
indent|'            '
name|'mod_type'
op|'='
name|'self'
op|'.'
name|'etc'
op|'['
number|'2'
op|']'
newline|'\n'
name|'if'
name|'mod_type'
op|'=='
name|'imp'
op|'.'
name|'PY_SOURCE'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'file'
op|'='
name|'open'
op|'('
name|'self'
op|'.'
name|'filename'
op|','
string|"'rU'"
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'mod_type'
name|'in'
op|'('
name|'imp'
op|'.'
name|'PY_COMPILED'
op|','
name|'imp'
op|'.'
name|'C_EXTENSION'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'file'
op|'='
name|'open'
op|'('
name|'self'
op|'.'
name|'filename'
op|','
string|"'rb'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|_fix_name
dedent|''
dedent|''
dedent|''
name|'def'
name|'_fix_name'
op|'('
name|'self'
op|','
name|'fullname'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'fullname'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'fullname'
op|'='
name|'self'
op|'.'
name|'fullname'
newline|'\n'
dedent|''
name|'elif'
name|'fullname'
op|'!='
name|'self'
op|'.'
name|'fullname'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ImportError'
op|'('
string|'"Loader for module %s cannot handle "'
nl|'\n'
string|'"module %s"'
op|'%'
op|'('
name|'self'
op|'.'
name|'fullname'
op|','
name|'fullname'
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'fullname'
newline|'\n'
nl|'\n'
DECL|member|is_package
dedent|''
name|'def'
name|'is_package'
op|'('
name|'self'
op|','
name|'fullname'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'fullname'
op|'='
name|'self'
op|'.'
name|'_fix_name'
op|'('
name|'fullname'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'etc'
op|'['
number|'2'
op|']'
op|'=='
name|'imp'
op|'.'
name|'PKG_DIRECTORY'
newline|'\n'
nl|'\n'
DECL|member|get_code
dedent|''
name|'def'
name|'get_code'
op|'('
name|'self'
op|','
name|'fullname'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'fullname'
op|'='
name|'self'
op|'.'
name|'_fix_name'
op|'('
name|'fullname'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'code'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'mod_type'
op|'='
name|'self'
op|'.'
name|'etc'
op|'['
number|'2'
op|']'
newline|'\n'
name|'if'
name|'mod_type'
op|'=='
name|'imp'
op|'.'
name|'PY_SOURCE'
op|':'
newline|'\n'
indent|'                '
name|'source'
op|'='
name|'self'
op|'.'
name|'get_source'
op|'('
name|'fullname'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'code'
op|'='
name|'compile'
op|'('
name|'source'
op|','
name|'self'
op|'.'
name|'filename'
op|','
string|"'exec'"
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'mod_type'
op|'=='
name|'imp'
op|'.'
name|'PY_COMPILED'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_reopen'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'code'
op|'='
name|'read_code'
op|'('
name|'self'
op|'.'
name|'file'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'file'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'mod_type'
op|'=='
name|'imp'
op|'.'
name|'PKG_DIRECTORY'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'code'
op|'='
name|'self'
op|'.'
name|'_get_delegate'
op|'('
op|')'
op|'.'
name|'get_code'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'code'
newline|'\n'
nl|'\n'
DECL|member|get_source
dedent|''
name|'def'
name|'get_source'
op|'('
name|'self'
op|','
name|'fullname'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'fullname'
op|'='
name|'self'
op|'.'
name|'_fix_name'
op|'('
name|'fullname'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'source'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'mod_type'
op|'='
name|'self'
op|'.'
name|'etc'
op|'['
number|'2'
op|']'
newline|'\n'
name|'if'
name|'mod_type'
op|'=='
name|'imp'
op|'.'
name|'PY_SOURCE'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_reopen'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'source'
op|'='
name|'self'
op|'.'
name|'file'
op|'.'
name|'read'
op|'('
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'file'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'mod_type'
op|'=='
name|'imp'
op|'.'
name|'PY_COMPILED'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'self'
op|'.'
name|'filename'
op|'['
op|':'
op|'-'
number|'1'
op|']'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'f'
op|'='
name|'open'
op|'('
name|'self'
op|'.'
name|'filename'
op|'['
op|':'
op|'-'
number|'1'
op|']'
op|','
string|"'rU'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'source'
op|'='
name|'f'
op|'.'
name|'read'
op|'('
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'mod_type'
op|'=='
name|'imp'
op|'.'
name|'PKG_DIRECTORY'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'source'
op|'='
name|'self'
op|'.'
name|'_get_delegate'
op|'('
op|')'
op|'.'
name|'get_source'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'source'
newline|'\n'
nl|'\n'
DECL|member|_get_delegate
dedent|''
name|'def'
name|'_get_delegate'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'ImpImporter'
op|'('
name|'self'
op|'.'
name|'filename'
op|')'
op|'.'
name|'find_module'
op|'('
string|"'__init__'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_filename
dedent|''
name|'def'
name|'get_filename'
op|'('
name|'self'
op|','
name|'fullname'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'fullname'
op|'='
name|'self'
op|'.'
name|'_fix_name'
op|'('
name|'fullname'
op|')'
newline|'\n'
name|'mod_type'
op|'='
name|'self'
op|'.'
name|'etc'
op|'['
number|'2'
op|']'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'etc'
op|'['
number|'2'
op|']'
op|'=='
name|'imp'
op|'.'
name|'PKG_DIRECTORY'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'_get_delegate'
op|'('
op|')'
op|'.'
name|'get_filename'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'etc'
op|'['
number|'2'
op|']'
name|'in'
op|'('
name|'imp'
op|'.'
name|'PY_SOURCE'
op|','
name|'imp'
op|'.'
name|'PY_COMPILED'
op|','
name|'imp'
op|'.'
name|'C_EXTENSION'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'filename'
newline|'\n'
dedent|''
name|'return'
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'import'
name|'zipimport'
newline|'\n'
name|'from'
name|'zipimport'
name|'import'
name|'zipimporter'
newline|'\n'
nl|'\n'
DECL|member|iter_zipimport_modules
name|'def'
name|'iter_zipimport_modules'
op|'('
name|'importer'
op|','
name|'prefix'
op|'='
string|"''"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'dirlist'
op|'='
name|'zipimport'
op|'.'
name|'_zip_directory_cache'
op|'['
name|'importer'
op|'.'
name|'archive'
op|']'
op|'.'
name|'keys'
op|'('
op|')'
newline|'\n'
name|'dirlist'
op|'.'
name|'sort'
op|'('
op|')'
newline|'\n'
name|'_prefix'
op|'='
name|'importer'
op|'.'
name|'prefix'
newline|'\n'
name|'plen'
op|'='
name|'len'
op|'('
name|'_prefix'
op|')'
newline|'\n'
name|'yielded'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'import'
name|'inspect'
newline|'\n'
name|'for'
name|'fn'
name|'in'
name|'dirlist'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'fn'
op|'.'
name|'startswith'
op|'('
name|'_prefix'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'fn'
op|'='
name|'fn'
op|'['
name|'plen'
op|':'
op|']'
op|'.'
name|'split'
op|'('
name|'os'
op|'.'
name|'sep'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'fn'
op|')'
op|'=='
number|'2'
name|'and'
name|'fn'
op|'['
number|'1'
op|']'
op|'.'
name|'startswith'
op|'('
string|"'__init__.py'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'fn'
op|'['
number|'0'
op|']'
name|'not'
name|'in'
name|'yielded'
op|':'
newline|'\n'
indent|'                    '
name|'yielded'
op|'['
name|'fn'
op|'['
number|'0'
op|']'
op|']'
op|'='
number|'1'
newline|'\n'
name|'yield'
name|'fn'
op|'['
number|'0'
op|']'
op|','
name|'True'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'len'
op|'('
name|'fn'
op|')'
op|'!='
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'modname'
op|'='
name|'inspect'
op|'.'
name|'getmodulename'
op|'('
name|'fn'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
name|'if'
name|'modname'
op|'=='
string|"'__init__'"
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'modname'
name|'and'
string|"'.'"
name|'not'
name|'in'
name|'modname'
name|'and'
name|'modname'
name|'not'
name|'in'
name|'yielded'
op|':'
newline|'\n'
indent|'                '
name|'yielded'
op|'['
name|'modname'
op|']'
op|'='
number|'1'
newline|'\n'
name|'yield'
name|'prefix'
op|'+'
name|'modname'
op|','
name|'False'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'iter_importer_modules'
op|'.'
name|'register'
op|'('
name|'zipimporter'
op|','
name|'iter_zipimport_modules'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_importer
dedent|''
name|'def'
name|'get_importer'
op|'('
name|'path_item'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Retrieve a PEP 302 importer for the given path item\n\n    The returned importer is cached in sys.path_importer_cache\n    if it was newly created by a path hook.\n\n    If there is no importer, a wrapper around the basic import\n    machinery is returned. This wrapper is never inserted into\n    the importer cache (None is inserted instead).\n\n    The cache (or part of it) can be cleared manually if a\n    rescan of sys.path_hooks is necessary.\n    """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'importer'
op|'='
name|'sys'
op|'.'
name|'path_importer_cache'
op|'['
name|'path_item'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'path_hook'
name|'in'
name|'sys'
op|'.'
name|'path_hooks'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'importer'
op|'='
name|'path_hook'
op|'('
name|'path_item'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'importer'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'sys'
op|'.'
name|'path_importer_cache'
op|'.'
name|'setdefault'
op|'('
name|'path_item'
op|','
name|'importer'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'importer'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'importer'
op|'='
name|'ImpImporter'
op|'('
name|'path_item'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
indent|'            '
name|'importer'
op|'='
name|'None'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'importer'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|iter_importers
dedent|''
name|'def'
name|'iter_importers'
op|'('
name|'fullname'
op|'='
string|'""'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Yield PEP 302 importers for the given module name\n\n    If fullname contains a \'.\', the importers will be for the package\n    containing fullname, otherwise they will be importers for sys.meta_path,\n    sys.path, and Python\'s "classic" import machinery, in that order.  If\n    the named module is in a package, that package is imported as a side\n    effect of invoking this function.\n\n    Non PEP 302 mechanisms (e.g. the Windows registry) used by the\n    standard import machinery to find files in alternative locations\n    are partially supported, but are searched AFTER sys.path. Normally,\n    these locations are searched BEFORE sys.path, preventing sys.path\n    entries from shadowing them.\n\n    For this to cause a visible difference in behaviour, there must\n    be a module or package name that is accessible via both sys.path\n    and one of the non PEP 302 file system mechanisms. In this case,\n    the emulation will find the former version, while the builtin\n    import mechanism will find the latter.\n\n    Items of the following types can be affected by this discrepancy:\n        imp.C_EXTENSION, imp.PY_SOURCE, imp.PY_COMPILED, imp.PKG_DIRECTORY\n    """'
newline|'\n'
name|'if'
name|'fullname'
op|'.'
name|'startswith'
op|'('
string|"'.'"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'ImportError'
op|'('
string|'"Relative module names not supported"'
op|')'
newline|'\n'
dedent|''
name|'if'
string|"'.'"
name|'in'
name|'fullname'
op|':'
newline|'\n'
comment|"# Get the containing package's __path__"
nl|'\n'
indent|'        '
name|'pkg'
op|'='
string|"'.'"
op|'.'
name|'join'
op|'('
name|'fullname'
op|'.'
name|'split'
op|'('
string|"'.'"
op|')'
op|'['
op|':'
op|'-'
number|'1'
op|']'
op|')'
newline|'\n'
name|'if'
name|'pkg'
name|'not'
name|'in'
name|'sys'
op|'.'
name|'modules'
op|':'
newline|'\n'
indent|'            '
name|'__import__'
op|'('
name|'pkg'
op|')'
newline|'\n'
dedent|''
name|'path'
op|'='
name|'getattr'
op|'('
name|'sys'
op|'.'
name|'modules'
op|'['
name|'pkg'
op|']'
op|','
string|"'__path__'"
op|','
name|'None'
op|')'
name|'or'
op|'['
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'importer'
name|'in'
name|'sys'
op|'.'
name|'meta_path'
op|':'
newline|'\n'
indent|'            '
name|'yield'
name|'importer'
newline|'\n'
dedent|''
name|'path'
op|'='
name|'sys'
op|'.'
name|'path'
newline|'\n'
dedent|''
name|'for'
name|'item'
name|'in'
name|'path'
op|':'
newline|'\n'
indent|'        '
name|'yield'
name|'get_importer'
op|'('
name|'item'
op|')'
newline|'\n'
dedent|''
name|'if'
string|"'.'"
name|'not'
name|'in'
name|'fullname'
op|':'
newline|'\n'
indent|'        '
name|'yield'
name|'ImpImporter'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_loader
dedent|''
dedent|''
name|'def'
name|'get_loader'
op|'('
name|'module_or_name'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Get a PEP 302 "loader" object for module_or_name\n\n    If the module or package is accessible via the normal import\n    mechanism, a wrapper around the relevant part of that machinery\n    is returned.  Returns None if the module cannot be found or imported.\n    If the named module is not already imported, its containing package\n    (if any) is imported, in order to establish the package __path__.\n\n    This function uses iter_importers(), and is thus subject to the same\n    limitations regarding platform-specific special import locations such\n    as the Windows registry.\n    """'
newline|'\n'
name|'if'
name|'module_or_name'
name|'in'
name|'sys'
op|'.'
name|'modules'
op|':'
newline|'\n'
indent|'        '
name|'module_or_name'
op|'='
name|'sys'
op|'.'
name|'modules'
op|'['
name|'module_or_name'
op|']'
newline|'\n'
dedent|''
name|'if'
name|'isinstance'
op|'('
name|'module_or_name'
op|','
name|'ModuleType'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'module'
op|'='
name|'module_or_name'
newline|'\n'
name|'loader'
op|'='
name|'getattr'
op|'('
name|'module'
op|','
string|"'__loader__'"
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'loader'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'loader'
newline|'\n'
dedent|''
name|'fullname'
op|'='
name|'module'
op|'.'
name|'__name__'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'fullname'
op|'='
name|'module_or_name'
newline|'\n'
dedent|''
name|'return'
name|'find_loader'
op|'('
name|'fullname'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|find_loader
dedent|''
name|'def'
name|'find_loader'
op|'('
name|'fullname'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Find a PEP 302 "loader" object for fullname\n\n    If fullname contains dots, path must be the containing package\'s __path__.\n    Returns None if the module cannot be found or imported. This function uses\n    iter_importers(), and is thus subject to the same limitations regarding\n    platform-specific special import locations such as the Windows registry.\n    """'
newline|'\n'
name|'for'
name|'importer'
name|'in'
name|'iter_importers'
op|'('
name|'fullname'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'loader'
op|'='
name|'importer'
op|'.'
name|'find_module'
op|'('
name|'fullname'
op|')'
newline|'\n'
name|'if'
name|'loader'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'loader'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|extend_path
dedent|''
name|'def'
name|'extend_path'
op|'('
name|'path'
op|','
name|'name'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Extend a package\'s path.\n\n    Intended use is to place the following code in a package\'s __init__.py:\n\n        from pkgutil import extend_path\n        __path__ = extend_path(__path__, __name__)\n\n    This will add to the package\'s __path__ all subdirectories of\n    directories on sys.path named after the package.  This is useful\n    if one wants to distribute different parts of a single logical\n    package as multiple directories.\n\n    It also looks for *.pkg files beginning where * matches the name\n    argument.  This feature is similar to *.pth files (see site.py),\n    except that it doesn\'t special-case lines starting with \'import\'.\n    A *.pkg file is trusted at face value: apart from checking for\n    duplicates, all entries found in a *.pkg file are added to the\n    path, regardless of whether they are exist the filesystem.  (This\n    is a feature.)\n\n    If the input path is not a list (as is the case for frozen\n    packages) it is returned unchanged.  The input path is not\n    modified; an extended copy is returned.  Items are only appended\n    to the copy at the end.\n\n    It is assumed that sys.path is a sequence.  Items of sys.path that\n    are not (unicode or 8-bit) strings referring to existing\n    directories are ignored.  Unicode items of sys.path that cause\n    errors when used as filenames may cause this function to raise an\n    exception (in line with os.path.isdir() behavior).\n    """'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'path'
op|','
name|'list'
op|')'
op|':'
newline|'\n'
comment|'# This could happen e.g. when this is called from inside a'
nl|'\n'
comment|'# frozen package.  Return the path unchanged in that case.'
nl|'\n'
indent|'        '
name|'return'
name|'path'
newline|'\n'
nl|'\n'
dedent|''
name|'pname'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
op|'*'
name|'name'
op|'.'
name|'split'
op|'('
string|"'.'"
op|')'
op|')'
comment|'# Reconstitute as relative path'
newline|'\n'
comment|"# Just in case os.extsep != '.'"
nl|'\n'
name|'sname'
op|'='
name|'os'
op|'.'
name|'extsep'
op|'.'
name|'join'
op|'('
name|'name'
op|'.'
name|'split'
op|'('
string|"'.'"
op|')'
op|')'
newline|'\n'
name|'sname_pkg'
op|'='
name|'sname'
op|'+'
name|'os'
op|'.'
name|'extsep'
op|'+'
string|'"pkg"'
newline|'\n'
name|'init_py'
op|'='
string|'"__init__"'
op|'+'
name|'os'
op|'.'
name|'extsep'
op|'+'
string|'"py"'
newline|'\n'
nl|'\n'
name|'path'
op|'='
name|'path'
op|'['
op|':'
op|']'
comment|'# Start with a copy of the existing path'
newline|'\n'
nl|'\n'
name|'for'
name|'dir'
name|'in'
name|'sys'
op|'.'
name|'path'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'dir'
op|','
name|'basestring'
op|')'
name|'or'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'isdir'
op|'('
name|'dir'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
dedent|''
name|'subdir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'dir'
op|','
name|'pname'
op|')'
newline|'\n'
comment|'# XXX This may still add duplicate entries to path on'
nl|'\n'
comment|'# case-insensitive filesystems'
nl|'\n'
name|'initfile'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'subdir'
op|','
name|'init_py'
op|')'
newline|'\n'
name|'if'
name|'subdir'
name|'not'
name|'in'
name|'path'
name|'and'
name|'os'
op|'.'
name|'path'
op|'.'
name|'isfile'
op|'('
name|'initfile'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'path'
op|'.'
name|'append'
op|'('
name|'subdir'
op|')'
newline|'\n'
comment|'# XXX Is this the right thing for subpackages like zope.app?'
nl|'\n'
comment|'# It looks for a file named "zope.app.pkg"'
nl|'\n'
dedent|''
name|'pkgfile'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'dir'
op|','
name|'sname_pkg'
op|')'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'isfile'
op|'('
name|'pkgfile'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'f'
op|'='
name|'open'
op|'('
name|'pkgfile'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'IOError'
op|','
name|'msg'
op|':'
newline|'\n'
indent|'                '
name|'sys'
op|'.'
name|'stderr'
op|'.'
name|'write'
op|'('
string|'"Can\'t open %s: %s\\n"'
op|'%'
nl|'\n'
op|'('
name|'pkgfile'
op|','
name|'msg'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'line'
name|'in'
name|'f'
op|':'
newline|'\n'
indent|'                    '
name|'line'
op|'='
name|'line'
op|'.'
name|'rstrip'
op|'('
string|"'\\n'"
op|')'
newline|'\n'
name|'if'
name|'not'
name|'line'
name|'or'
name|'line'
op|'.'
name|'startswith'
op|'('
string|"'#'"
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'continue'
newline|'\n'
dedent|''
name|'path'
op|'.'
name|'append'
op|'('
name|'line'
op|')'
comment|"# Don't check for existence!"
newline|'\n'
dedent|''
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'path'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_data
dedent|''
name|'def'
name|'get_data'
op|'('
name|'package'
op|','
name|'resource'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Get a resource from a package.\n\n    This is a wrapper round the PEP 302 loader get_data API. The package\n    argument should be the name of a package, in standard module format\n    (foo.bar). The resource argument should be in the form of a relative\n    filename, using \'/\' as the path separator. The parent directory name \'..\'\n    is not allowed, and nor is a rooted name (starting with a \'/\').\n\n    The function returns a binary string, which is the contents of the\n    specified resource.\n\n    For packages located in the filesystem, which have already been imported,\n    this is the rough equivalent of\n\n        d = os.path.dirname(sys.modules[package].__file__)\n        data = open(os.path.join(d, resource), \'rb\').read()\n\n    If the package cannot be located or loaded, or it uses a PEP 302 loader\n    which does not support get_data(), then None is returned.\n    """'
newline|'\n'
nl|'\n'
name|'loader'
op|'='
name|'get_loader'
op|'('
name|'package'
op|')'
newline|'\n'
name|'if'
name|'loader'
name|'is'
name|'None'
name|'or'
name|'not'
name|'hasattr'
op|'('
name|'loader'
op|','
string|"'get_data'"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'mod'
op|'='
name|'sys'
op|'.'
name|'modules'
op|'.'
name|'get'
op|'('
name|'package'
op|')'
name|'or'
name|'loader'
op|'.'
name|'load_module'
op|'('
name|'package'
op|')'
newline|'\n'
name|'if'
name|'mod'
name|'is'
name|'None'
name|'or'
name|'not'
name|'hasattr'
op|'('
name|'mod'
op|','
string|"'__file__'"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
comment|'# Modify the resource name to be compatible with the loader.get_data'
nl|'\n'
comment|'# signature - an os.path format "filename" starting with the dirname of'
nl|'\n'
comment|"# the package's __file__"
nl|'\n'
dedent|''
name|'parts'
op|'='
name|'resource'
op|'.'
name|'split'
op|'('
string|"'/'"
op|')'
newline|'\n'
name|'parts'
op|'.'
name|'insert'
op|'('
number|'0'
op|','
name|'os'
op|'.'
name|'path'
op|'.'
name|'dirname'
op|'('
name|'mod'
op|'.'
name|'__file__'
op|')'
op|')'
newline|'\n'
name|'resource_name'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
op|'*'
name|'parts'
op|')'
newline|'\n'
name|'return'
name|'loader'
op|'.'
name|'get_data'
op|'('
name|'resource_name'
op|')'
newline|'\n'
dedent|''
endmarker|''
end_unit
