begin_unit
comment|'# -*- test-case-name: twisted.conch.test.test_manhole -*-'
nl|'\n'
comment|'# Copyright (c) 2001-2007 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nLine-input oriented interactive interpreter loop.\n\nProvides classes for handling Python source input and arbitrary output\ninteractively from a Twisted application.  Also included is syntax coloring\ncode with support for VT102 terminals, control code handling (^C, ^D, ^Q),\nand reasonable handling of Deferreds.\n\n@author: Jp Calderone\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'code'
op|','
name|'sys'
op|','
name|'StringIO'
op|','
name|'tokenize'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'conch'
name|'import'
name|'recvline'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'defer'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'htmlizer'
name|'import'
name|'TokenPrinter'
newline|'\n'
nl|'\n'
DECL|class|FileWrapper
name|'class'
name|'FileWrapper'
op|':'
newline|'\n'
indent|'    '
string|'"""Minimal write-file-like object.\n\n    Writes are translated into addOutput calls on an object passed to\n    __init__.  Newlines are also converted from network to local style.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|softspace
name|'softspace'
op|'='
number|'0'
newline|'\n'
DECL|variable|state
name|'state'
op|'='
string|"'normal'"
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'o'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'o'
op|'='
name|'o'
newline|'\n'
nl|'\n'
DECL|member|flush
dedent|''
name|'def'
name|'flush'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|write
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'o'
op|'.'
name|'addOutput'
op|'('
name|'data'
op|'.'
name|'replace'
op|'('
string|"'\\r\\n'"
op|','
string|"'\\n'"
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|writelines
dedent|''
name|'def'
name|'writelines'
op|'('
name|'self'
op|','
name|'lines'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'write'
op|'('
string|"''"
op|'.'
name|'join'
op|'('
name|'lines'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|class|ManholeInterpreter
dedent|''
dedent|''
name|'class'
name|'ManholeInterpreter'
op|'('
name|'code'
op|'.'
name|'InteractiveInterpreter'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Interactive Interpreter with special output and Deferred support.\n\n    Aside from the features provided by L{code.InteractiveInterpreter}, this\n    class captures sys.stdout output and redirects it to the appropriate\n    location (the Manhole protocol instance).  It also treats Deferreds\n    which reach the top-level specially: each is formatted to the user with\n    a unique identifier and a new callback and errback added to it, each of\n    which will format the unique identifier and the result with which the\n    Deferred fires and then pass it on to the next participant in the\n    callback chain.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|numDeferreds
name|'numDeferreds'
op|'='
number|'0'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'handler'
op|','
name|'locals'
op|'='
name|'None'
op|','
name|'filename'
op|'='
string|'"<console>"'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'code'
op|'.'
name|'InteractiveInterpreter'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'locals'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_pendingDeferreds'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'handler'
op|'='
name|'handler'
newline|'\n'
name|'self'
op|'.'
name|'filename'
op|'='
name|'filename'
newline|'\n'
name|'self'
op|'.'
name|'resetBuffer'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|resetBuffer
dedent|''
name|'def'
name|'resetBuffer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Reset the input buffer."""'
newline|'\n'
name|'self'
op|'.'
name|'buffer'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|push
dedent|''
name|'def'
name|'push'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Push a line to the interpreter.\n\n        The line should not have a trailing newline; it may have\n        internal newlines.  The line is appended to a buffer and the\n        interpreter\'s runsource() method is called with the\n        concatenated contents of the buffer as source.  If this\n        indicates that the command was executed or invalid, the buffer\n        is reset; otherwise, the command is incomplete, and the buffer\n        is left as it was after the line was appended.  The return\n        value is 1 if more input is required, 0 if the line was dealt\n        with in some way (this is the same as runsource()).\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'buffer'
op|'.'
name|'append'
op|'('
name|'line'
op|')'
newline|'\n'
name|'source'
op|'='
string|'"\\n"'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'buffer'
op|')'
newline|'\n'
name|'more'
op|'='
name|'self'
op|'.'
name|'runsource'
op|'('
name|'source'
op|','
name|'self'
op|'.'
name|'filename'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'more'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'resetBuffer'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'more'
newline|'\n'
nl|'\n'
DECL|member|runcode
dedent|''
name|'def'
name|'runcode'
op|'('
name|'self'
op|','
op|'*'
name|'a'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'orighook'
op|','
name|'sys'
op|'.'
name|'displayhook'
op|'='
name|'sys'
op|'.'
name|'displayhook'
op|','
name|'self'
op|'.'
name|'displayhook'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'origout'
op|','
name|'sys'
op|'.'
name|'stdout'
op|'='
name|'sys'
op|'.'
name|'stdout'
op|','
name|'FileWrapper'
op|'('
name|'self'
op|'.'
name|'handler'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'code'
op|'.'
name|'InteractiveInterpreter'
op|'.'
name|'runcode'
op|'('
name|'self'
op|','
op|'*'
name|'a'
op|','
op|'**'
name|'kw'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'                '
name|'sys'
op|'.'
name|'stdout'
op|'='
name|'origout'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'sys'
op|'.'
name|'displayhook'
op|'='
name|'orighook'
newline|'\n'
nl|'\n'
DECL|member|displayhook
dedent|''
dedent|''
name|'def'
name|'displayhook'
op|'('
name|'self'
op|','
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'locals'
op|'['
string|"'_'"
op|']'
op|'='
name|'obj'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'obj'
op|','
name|'defer'
op|'.'
name|'Deferred'
op|')'
op|':'
newline|'\n'
comment|'# XXX Ick, where is my "hasFired()" interface?'
nl|'\n'
indent|'            '
name|'if'
name|'hasattr'
op|'('
name|'obj'
op|','
string|'"result"'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'write'
op|'('
name|'repr'
op|'('
name|'obj'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'id'
op|'('
name|'obj'
op|')'
name|'in'
name|'self'
op|'.'
name|'_pendingDeferreds'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'write'
op|'('
string|'"<Deferred #%d>"'
op|'%'
op|'('
name|'self'
op|'.'
name|'_pendingDeferreds'
op|'['
name|'id'
op|'('
name|'obj'
op|')'
op|']'
op|'['
number|'0'
op|']'
op|','
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'d'
op|'='
name|'self'
op|'.'
name|'_pendingDeferreds'
newline|'\n'
name|'k'
op|'='
name|'self'
op|'.'
name|'numDeferreds'
newline|'\n'
name|'d'
op|'['
name|'id'
op|'('
name|'obj'
op|')'
op|']'
op|'='
op|'('
name|'k'
op|','
name|'obj'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'numDeferreds'
op|'+='
number|'1'
newline|'\n'
name|'obj'
op|'.'
name|'addCallbacks'
op|'('
name|'self'
op|'.'
name|'_cbDisplayDeferred'
op|','
name|'self'
op|'.'
name|'_ebDisplayDeferred'
op|','
nl|'\n'
name|'callbackArgs'
op|'='
op|'('
name|'k'
op|','
name|'obj'
op|')'
op|','
name|'errbackArgs'
op|'='
op|'('
name|'k'
op|','
name|'obj'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'write'
op|'('
string|'"<Deferred #%d>"'
op|'%'
op|'('
name|'k'
op|','
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'obj'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'write'
op|'('
name|'repr'
op|'('
name|'obj'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_cbDisplayDeferred
dedent|''
dedent|''
name|'def'
name|'_cbDisplayDeferred'
op|'('
name|'self'
op|','
name|'result'
op|','
name|'k'
op|','
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'write'
op|'('
string|'"Deferred #%d called back: %r"'
op|'%'
op|'('
name|'k'
op|','
name|'result'
op|')'
op|','
name|'True'
op|')'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'_pendingDeferreds'
op|'['
name|'id'
op|'('
name|'obj'
op|')'
op|']'
newline|'\n'
name|'return'
name|'result'
newline|'\n'
nl|'\n'
DECL|member|_ebDisplayDeferred
dedent|''
name|'def'
name|'_ebDisplayDeferred'
op|'('
name|'self'
op|','
name|'failure'
op|','
name|'k'
op|','
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'write'
op|'('
string|'"Deferred #%d failed: %r"'
op|'%'
op|'('
name|'k'
op|','
name|'failure'
op|'.'
name|'getErrorMessage'
op|'('
op|')'
op|')'
op|','
name|'True'
op|')'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'_pendingDeferreds'
op|'['
name|'id'
op|'('
name|'obj'
op|')'
op|']'
newline|'\n'
name|'return'
name|'failure'
newline|'\n'
nl|'\n'
DECL|member|write
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'data'
op|','
name|'async'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'handler'
op|'.'
name|'addOutput'
op|'('
name|'data'
op|','
name|'async'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|CTRL_C
dedent|''
dedent|''
name|'CTRL_C'
op|'='
string|"'\\x03'"
newline|'\n'
DECL|variable|CTRL_D
name|'CTRL_D'
op|'='
string|"'\\x04'"
newline|'\n'
DECL|variable|CTRL_BACKSLASH
name|'CTRL_BACKSLASH'
op|'='
string|"'\\x1c'"
newline|'\n'
DECL|variable|CTRL_L
name|'CTRL_L'
op|'='
string|"'\\x0c'"
newline|'\n'
nl|'\n'
DECL|class|Manhole
name|'class'
name|'Manhole'
op|'('
name|'recvline'
op|'.'
name|'HistoricRecvLine'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Mediator between a fancy line source and an interactive interpreter.\n\n    This accepts lines from its transport and passes them on to a\n    L{ManholeInterpreter}.  Control commands (^C, ^D, ^\\) are also handled\n    with something approximating their normal terminal-mode behavior.  It\n    can optionally be constructed with a dict which will be used as the\n    local namespace for any code executed.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|namespace
name|'namespace'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'namespace'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'recvline'
op|'.'
name|'HistoricRecvLine'
op|'.'
name|'__init__'
op|'('
name|'self'
op|')'
newline|'\n'
name|'if'
name|'namespace'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'namespace'
op|'='
name|'namespace'
op|'.'
name|'copy'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|connectionMade
dedent|''
dedent|''
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'recvline'
op|'.'
name|'HistoricRecvLine'
op|'.'
name|'connectionMade'
op|'('
name|'self'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'interpreter'
op|'='
name|'ManholeInterpreter'
op|'('
name|'self'
op|','
name|'self'
op|'.'
name|'namespace'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'keyHandlers'
op|'['
name|'CTRL_C'
op|']'
op|'='
name|'self'
op|'.'
name|'handle_INT'
newline|'\n'
name|'self'
op|'.'
name|'keyHandlers'
op|'['
name|'CTRL_D'
op|']'
op|'='
name|'self'
op|'.'
name|'handle_EOF'
newline|'\n'
name|'self'
op|'.'
name|'keyHandlers'
op|'['
name|'CTRL_L'
op|']'
op|'='
name|'self'
op|'.'
name|'handle_FF'
newline|'\n'
name|'self'
op|'.'
name|'keyHandlers'
op|'['
name|'CTRL_BACKSLASH'
op|']'
op|'='
name|'self'
op|'.'
name|'handle_QUIT'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|handle_INT
dedent|''
name|'def'
name|'handle_INT'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Handle ^C as an interrupt keystroke by resetting the current input\n        variables to their initial state.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'pn'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'lineBuffer'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'lineBufferIndex'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'interpreter'
op|'.'
name|'resetBuffer'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'nextLine'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'write'
op|'('
string|'"KeyboardInterrupt"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'nextLine'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'write'
op|'('
name|'self'
op|'.'
name|'ps'
op|'['
name|'self'
op|'.'
name|'pn'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|handle_EOF
dedent|''
name|'def'
name|'handle_EOF'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'lineBuffer'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'write'
op|'('
string|"'\\a'"
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'handle_QUIT'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|handle_FF
dedent|''
dedent|''
name|'def'
name|'handle_FF'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Handle a \'form feed\' byte - generally used to request a screen\n        refresh/redraw.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'eraseDisplay'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'cursorHome'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'drawInputLine'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|handle_QUIT
dedent|''
name|'def'
name|'handle_QUIT'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_needsNewline
dedent|''
name|'def'
name|'_needsNewline'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'w'
op|'='
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'lastWrite'
newline|'\n'
name|'return'
name|'not'
name|'w'
op|'.'
name|'endswith'
op|'('
string|"'\\n'"
op|')'
name|'and'
name|'not'
name|'w'
op|'.'
name|'endswith'
op|'('
string|"'\\x1bE'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|addOutput
dedent|''
name|'def'
name|'addOutput'
op|'('
name|'self'
op|','
name|'bytes'
op|','
name|'async'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'async'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'eraseLine'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'cursorBackward'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'lineBuffer'
op|')'
op|'+'
name|'len'
op|'('
name|'self'
op|'.'
name|'ps'
op|'['
name|'self'
op|'.'
name|'pn'
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'write'
op|'('
name|'bytes'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'async'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'_needsNewline'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'nextLine'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'write'
op|'('
name|'self'
op|'.'
name|'ps'
op|'['
name|'self'
op|'.'
name|'pn'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'lineBuffer'
op|':'
newline|'\n'
indent|'                '
name|'oldBuffer'
op|'='
name|'self'
op|'.'
name|'lineBuffer'
newline|'\n'
name|'self'
op|'.'
name|'lineBuffer'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'lineBufferIndex'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_deliverBuffer'
op|'('
name|'oldBuffer'
op|')'
newline|'\n'
nl|'\n'
DECL|member|lineReceived
dedent|''
dedent|''
dedent|''
name|'def'
name|'lineReceived'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'more'
op|'='
name|'self'
op|'.'
name|'interpreter'
op|'.'
name|'push'
op|'('
name|'line'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'pn'
op|'='
name|'bool'
op|'('
name|'more'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_needsNewline'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'nextLine'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'write'
op|'('
name|'self'
op|'.'
name|'ps'
op|'['
name|'self'
op|'.'
name|'pn'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|class|VT102Writer
dedent|''
dedent|''
name|'class'
name|'VT102Writer'
op|':'
newline|'\n'
indent|'    '
string|'"""Colorizer for Python tokens.\n\n    A series of tokens are written to instances of this object.  Each is\n    colored in a particular way.  The final line of the result of this is\n    generally added to the output.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|typeToColor
name|'typeToColor'
op|'='
op|'{'
nl|'\n'
string|"'identifier'"
op|':'
string|"'\\x1b[31m'"
op|','
nl|'\n'
string|"'keyword'"
op|':'
string|"'\\x1b[32m'"
op|','
nl|'\n'
string|"'parameter'"
op|':'
string|"'\\x1b[33m'"
op|','
nl|'\n'
string|"'variable'"
op|':'
string|"'\\x1b[1;33m'"
op|','
nl|'\n'
string|"'string'"
op|':'
string|"'\\x1b[35m'"
op|','
nl|'\n'
string|"'number'"
op|':'
string|"'\\x1b[36m'"
op|','
nl|'\n'
string|"'op'"
op|':'
string|"'\\x1b[37m'"
op|'}'
newline|'\n'
nl|'\n'
DECL|variable|normalColor
name|'normalColor'
op|'='
string|"'\\x1b[0m'"
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'written'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|color
dedent|''
name|'def'
name|'color'
op|'('
name|'self'
op|','
name|'type'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'r'
op|'='
name|'self'
op|'.'
name|'typeToColor'
op|'.'
name|'get'
op|'('
name|'type'
op|','
string|"''"
op|')'
newline|'\n'
name|'return'
name|'r'
newline|'\n'
nl|'\n'
DECL|member|write
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'token'
op|','
name|'type'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'token'
name|'and'
name|'token'
op|'!='
string|"'\\r'"
op|':'
newline|'\n'
indent|'            '
name|'c'
op|'='
name|'self'
op|'.'
name|'color'
op|'('
name|'type'
op|')'
newline|'\n'
name|'if'
name|'c'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'written'
op|'.'
name|'append'
op|'('
name|'c'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'written'
op|'.'
name|'append'
op|'('
name|'token'
op|')'
newline|'\n'
name|'if'
name|'c'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'written'
op|'.'
name|'append'
op|'('
name|'self'
op|'.'
name|'normalColor'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
dedent|''
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|"''"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'written'
op|')'
newline|'\n'
name|'return'
name|'s'
op|'.'
name|'strip'
op|'('
string|"'\\n'"
op|')'
op|'.'
name|'splitlines'
op|'('
op|')'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
nl|'\n'
DECL|function|lastColorizedLine
dedent|''
dedent|''
name|'def'
name|'lastColorizedLine'
op|'('
name|'source'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Tokenize and colorize the given Python source.\n\n    Returns a VT102-format colorized version of the last line of C{source}.\n    """'
newline|'\n'
name|'w'
op|'='
name|'VT102Writer'
op|'('
op|')'
newline|'\n'
name|'p'
op|'='
name|'TokenPrinter'
op|'('
name|'w'
op|'.'
name|'write'
op|')'
op|'.'
name|'printtoken'
newline|'\n'
name|'s'
op|'='
name|'StringIO'
op|'.'
name|'StringIO'
op|'('
name|'source'
op|')'
newline|'\n'
nl|'\n'
name|'tokenize'
op|'.'
name|'tokenize'
op|'('
name|'s'
op|'.'
name|'readline'
op|','
name|'p'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'str'
op|'('
name|'w'
op|')'
newline|'\n'
nl|'\n'
DECL|class|ColoredManhole
dedent|''
name|'class'
name|'ColoredManhole'
op|'('
name|'Manhole'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""A REPL which syntax colors input as users type it.\n    """'
newline|'\n'
nl|'\n'
DECL|member|getSource
name|'def'
name|'getSource'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a string containing the currently entered source.\n\n        This is only the code which will be considered for execution\n        next.\n        """'
newline|'\n'
name|'return'
op|'('
string|"'\\n'"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'interpreter'
op|'.'
name|'buffer'
op|')'
op|'+'
nl|'\n'
string|"'\\n'"
op|'+'
nl|'\n'
string|"''"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'lineBuffer'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|characterReceived
dedent|''
name|'def'
name|'characterReceived'
op|'('
name|'self'
op|','
name|'ch'
op|','
name|'moreCharactersComing'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'mode'
op|'=='
string|"'insert'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'lineBuffer'
op|'.'
name|'insert'
op|'('
name|'self'
op|'.'
name|'lineBufferIndex'
op|','
name|'ch'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'lineBuffer'
op|'['
name|'self'
op|'.'
name|'lineBufferIndex'
op|':'
name|'self'
op|'.'
name|'lineBufferIndex'
op|'+'
number|'1'
op|']'
op|'='
op|'['
name|'ch'
op|']'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'lineBufferIndex'
op|'+='
number|'1'
newline|'\n'
nl|'\n'
name|'if'
name|'moreCharactersComing'
op|':'
newline|'\n'
comment|"# Skip it all, we'll get called with another character in"
nl|'\n'
comment|'# like 2 femtoseconds.'
nl|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'ch'
op|'=='
string|"' '"
op|':'
newline|'\n'
comment|"# Don't bother to try to color whitespace"
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'write'
op|'('
name|'ch'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'source'
op|'='
name|'self'
op|'.'
name|'getSource'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Try to write some junk'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'coloredLine'
op|'='
name|'lastColorizedLine'
op|'('
name|'source'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'tokenize'
op|'.'
name|'TokenError'
op|':'
newline|'\n'
comment|"# We couldn't do it.  Strange.  Oh well, just add the character."
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'write'
op|'('
name|'ch'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Success!  Clear the source on this line.'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'eraseLine'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'cursorBackward'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'lineBuffer'
op|')'
op|'+'
name|'len'
op|'('
name|'self'
op|'.'
name|'ps'
op|'['
name|'self'
op|'.'
name|'pn'
op|']'
op|')'
op|'-'
number|'1'
op|')'
newline|'\n'
nl|'\n'
comment|'# And write a new, colorized one.'
nl|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'write'
op|'('
name|'self'
op|'.'
name|'ps'
op|'['
name|'self'
op|'.'
name|'pn'
op|']'
op|'+'
name|'coloredLine'
op|')'
newline|'\n'
nl|'\n'
comment|'# And move the cursor to where it belongs'
nl|'\n'
name|'n'
op|'='
name|'len'
op|'('
name|'self'
op|'.'
name|'lineBuffer'
op|')'
op|'-'
name|'self'
op|'.'
name|'lineBufferIndex'
newline|'\n'
name|'if'
name|'n'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'cursorBackward'
op|'('
name|'n'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
