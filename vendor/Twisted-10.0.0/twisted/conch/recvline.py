begin_unit
comment|'# -*- test-case-name: twisted.conch.test.test_recvline -*-'
nl|'\n'
comment|'# Copyright (c) 2001-2004 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nBasic line editing support.\n\n@author: Jp Calderone\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'string'
newline|'\n'
nl|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'implements'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'conch'
op|'.'
name|'insults'
name|'import'
name|'insults'
op|','
name|'helper'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'log'
op|','
name|'reflect'
newline|'\n'
nl|'\n'
DECL|variable|_counters
name|'_counters'
op|'='
op|'{'
op|'}'
newline|'\n'
DECL|class|Logging
name|'class'
name|'Logging'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Wrapper which logs attribute lookups.\n\n    This was useful in debugging something, I guess.  I forget what.\n    It can probably be deleted or moved somewhere more appropriate.\n    Nothing special going on here, really.\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'original'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'original'
op|'='
name|'original'
newline|'\n'
name|'key'
op|'='
name|'reflect'
op|'.'
name|'qual'
op|'('
name|'original'
op|'.'
name|'__class__'
op|')'
newline|'\n'
name|'count'
op|'='
name|'_counters'
op|'.'
name|'get'
op|'('
name|'key'
op|','
number|'0'
op|')'
newline|'\n'
name|'_counters'
op|'['
name|'key'
op|']'
op|'='
name|'count'
op|'+'
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'_logFile'
op|'='
name|'file'
op|'('
name|'key'
op|'+'
string|"'-'"
op|'+'
name|'str'
op|'('
name|'count'
op|')'
op|','
string|"'w'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'str'
op|'('
name|'super'
op|'('
name|'Logging'
op|','
name|'self'
op|')'
op|'.'
name|'__getattribute__'
op|'('
string|"'original'"
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'repr'
op|'('
name|'super'
op|'('
name|'Logging'
op|','
name|'self'
op|')'
op|'.'
name|'__getattribute__'
op|'('
string|"'original'"
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__getattribute__
dedent|''
name|'def'
name|'__getattribute__'
op|'('
name|'self'
op|','
name|'name'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'original'
op|'='
name|'super'
op|'('
name|'Logging'
op|','
name|'self'
op|')'
op|'.'
name|'__getattribute__'
op|'('
string|"'original'"
op|')'
newline|'\n'
name|'logFile'
op|'='
name|'super'
op|'('
name|'Logging'
op|','
name|'self'
op|')'
op|'.'
name|'__getattribute__'
op|'('
string|"'_logFile'"
op|')'
newline|'\n'
name|'logFile'
op|'.'
name|'write'
op|'('
name|'name'
op|'+'
string|"'\\n'"
op|')'
newline|'\n'
name|'return'
name|'getattr'
op|'('
name|'original'
op|','
name|'name'
op|')'
newline|'\n'
nl|'\n'
DECL|class|TransportSequence
dedent|''
dedent|''
name|'class'
name|'TransportSequence'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""An L{ITerminalTransport} implementation which forwards calls to\n    one or more other L{ITerminalTransport}s.\n\n    This is a cheap way for servers to keep track of the state they\n    expect the client to see, since all terminal manipulations can be\n    send to the real client and to a terminal emulator that lives in\n    the server process.\n    """'
newline|'\n'
name|'implements'
op|'('
name|'insults'
op|'.'
name|'ITerminalTransport'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'keyID'
name|'in'
op|'('
string|"'UP_ARROW'"
op|','
string|"'DOWN_ARROW'"
op|','
string|"'RIGHT_ARROW'"
op|','
string|"'LEFT_ARROW'"
op|','
nl|'\n'
string|"'HOME'"
op|','
string|"'INSERT'"
op|','
string|"'DELETE'"
op|','
string|"'END'"
op|','
string|"'PGUP'"
op|','
string|"'PGDN'"
op|','
nl|'\n'
string|"'F1'"
op|','
string|"'F2'"
op|','
string|"'F3'"
op|','
string|"'F4'"
op|','
string|"'F5'"
op|','
string|"'F6'"
op|','
string|"'F7'"
op|','
string|"'F8'"
op|','
string|"'F9'"
op|','
nl|'\n'
string|"'F10'"
op|','
string|"'F11'"
op|','
string|"'F12'"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'exec'
string|"'%s = object()'"
op|'%'
op|'('
name|'keyID'
op|','
op|')'
newline|'\n'
nl|'\n'
DECL|variable|TAB
dedent|''
name|'TAB'
op|'='
string|"'\\t'"
newline|'\n'
DECL|variable|BACKSPACE
name|'BACKSPACE'
op|'='
string|"'\\x7f'"
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
op|'*'
name|'transports'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'assert'
name|'transports'
op|','
string|'"Cannot construct a TransportSequence with no transports"'
newline|'\n'
name|'self'
op|'.'
name|'transports'
op|'='
name|'transports'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'method'
name|'in'
name|'insults'
op|'.'
name|'ITerminalTransport'
op|':'
newline|'\n'
indent|'        '
name|'exec'
string|'"""\\\ndef %s(self, *a, **kw):\n    for tpt in self.transports:\n        result = tpt.%s(*a, **kw)\n    return result\n"""'
op|'%'
op|'('
name|'method'
op|','
name|'method'
op|')'
newline|'\n'
nl|'\n'
DECL|class|LocalTerminalBufferMixin
dedent|''
dedent|''
name|'class'
name|'LocalTerminalBufferMixin'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""A mixin for RecvLine subclasses which records the state of the terminal.\n\n    This is accomplished by performing all L{ITerminalTransport} operations on both\n    the transport passed to makeConnection and an instance of helper.TerminalBuffer.\n\n    @ivar terminalCopy: A L{helper.TerminalBuffer} instance which efforts\n    will be made to keep up to date with the actual terminal\n    associated with this protocol instance.\n    """'
newline|'\n'
nl|'\n'
DECL|member|makeConnection
name|'def'
name|'makeConnection'
op|'('
name|'self'
op|','
name|'transport'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'terminalCopy'
op|'='
name|'helper'
op|'.'
name|'TerminalBuffer'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'terminalCopy'
op|'.'
name|'connectionMade'
op|'('
op|')'
newline|'\n'
name|'return'
name|'super'
op|'('
name|'LocalTerminalBufferMixin'
op|','
name|'self'
op|')'
op|'.'
name|'makeConnection'
op|'('
nl|'\n'
name|'TransportSequence'
op|'('
name|'transport'
op|','
name|'self'
op|'.'
name|'terminalCopy'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'str'
op|'('
name|'self'
op|'.'
name|'terminalCopy'
op|')'
newline|'\n'
nl|'\n'
DECL|class|RecvLine
dedent|''
dedent|''
name|'class'
name|'RecvLine'
op|'('
name|'insults'
op|'.'
name|'TerminalProtocol'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""L{TerminalProtocol} which adds line editing features.\n\n    Clients will be prompted for lines of input with all the usual\n    features: character echoing, left and right arrow support for\n    moving the cursor to different areas of the line buffer, backspace\n    and delete for removing characters, and insert for toggling\n    between typeover and insert mode.  Tabs will be expanded to enough\n    spaces to move the cursor to the next tabstop (every four\n    characters by default).  Enter causes the line buffer to be\n    cleared and the line to be passed to the lineReceived() method\n    which, by default, does nothing.  Subclasses are responsible for\n    redrawing the input prompt (this will probably change).\n    """'
newline|'\n'
DECL|variable|width
name|'width'
op|'='
number|'80'
newline|'\n'
DECL|variable|height
name|'height'
op|'='
number|'24'
newline|'\n'
nl|'\n'
DECL|variable|TABSTOP
name|'TABSTOP'
op|'='
number|'4'
newline|'\n'
nl|'\n'
DECL|variable|ps
name|'ps'
op|'='
op|'('
string|"'>>> '"
op|','
string|"'... '"
op|')'
newline|'\n'
DECL|variable|pn
name|'pn'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|member|connectionMade
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# A list containing the characters making up the current line'
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'lineBuffer'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
comment|'# A zero-based (wtf else?) index into self.lineBuffer.'
nl|'\n'
comment|'# Indicates the current cursor position.'
nl|'\n'
name|'self'
op|'.'
name|'lineBufferIndex'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'t'
op|'='
name|'self'
op|'.'
name|'terminal'
newline|'\n'
comment|'# A map of keyIDs to bound instance methods.'
nl|'\n'
name|'self'
op|'.'
name|'keyHandlers'
op|'='
op|'{'
nl|'\n'
name|'t'
op|'.'
name|'LEFT_ARROW'
op|':'
name|'self'
op|'.'
name|'handle_LEFT'
op|','
nl|'\n'
name|'t'
op|'.'
name|'RIGHT_ARROW'
op|':'
name|'self'
op|'.'
name|'handle_RIGHT'
op|','
nl|'\n'
name|'t'
op|'.'
name|'TAB'
op|':'
name|'self'
op|'.'
name|'handle_TAB'
op|','
nl|'\n'
nl|'\n'
comment|'# Both of these should not be necessary, but figuring out'
nl|'\n'
comment|'# which is necessary is a huge hassle.'
nl|'\n'
string|"'\\r'"
op|':'
name|'self'
op|'.'
name|'handle_RETURN'
op|','
nl|'\n'
string|"'\\n'"
op|':'
name|'self'
op|'.'
name|'handle_RETURN'
op|','
nl|'\n'
nl|'\n'
name|'t'
op|'.'
name|'BACKSPACE'
op|':'
name|'self'
op|'.'
name|'handle_BACKSPACE'
op|','
nl|'\n'
name|'t'
op|'.'
name|'DELETE'
op|':'
name|'self'
op|'.'
name|'handle_DELETE'
op|','
nl|'\n'
name|'t'
op|'.'
name|'INSERT'
op|':'
name|'self'
op|'.'
name|'handle_INSERT'
op|','
nl|'\n'
name|'t'
op|'.'
name|'HOME'
op|':'
name|'self'
op|'.'
name|'handle_HOME'
op|','
nl|'\n'
name|'t'
op|'.'
name|'END'
op|':'
name|'self'
op|'.'
name|'handle_END'
op|'}'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'initializeScreen'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|initializeScreen
dedent|''
name|'def'
name|'initializeScreen'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# Hmm, state sucks.  Oh well.'
nl|'\n'
comment|'# For now we will just take over the whole terminal.'
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'reset'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'write'
op|'('
name|'self'
op|'.'
name|'ps'
op|'['
name|'self'
op|'.'
name|'pn'
op|']'
op|')'
newline|'\n'
comment|'# XXX Note: I would prefer to default to starting in insert'
nl|'\n'
comment|'# mode, however this does not seem to actually work!  I do not'
nl|'\n'
comment|'# know why.  This is probably of interest to implementors'
nl|'\n'
comment|'# subclassing RecvLine.'
nl|'\n'
nl|'\n'
comment|'# XXX XXX Note: But the unit tests all expect the initial mode'
nl|'\n'
comment|'# to be insert right now.  Fuck, there needs to be a way to'
nl|'\n'
comment|'# query the current mode or something.'
nl|'\n'
comment|'# self.setTypeoverMode()'
nl|'\n'
name|'self'
op|'.'
name|'setInsertMode'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|currentLineBuffer
dedent|''
name|'def'
name|'currentLineBuffer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|"''"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'lineBuffer'
op|')'
newline|'\n'
name|'return'
name|'s'
op|'['
op|':'
name|'self'
op|'.'
name|'lineBufferIndex'
op|']'
op|','
name|'s'
op|'['
name|'self'
op|'.'
name|'lineBufferIndex'
op|':'
op|']'
newline|'\n'
nl|'\n'
DECL|member|setInsertMode
dedent|''
name|'def'
name|'setInsertMode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'mode'
op|'='
string|"'insert'"
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'setModes'
op|'('
op|'['
name|'insults'
op|'.'
name|'modes'
op|'.'
name|'IRM'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|setTypeoverMode
dedent|''
name|'def'
name|'setTypeoverMode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'mode'
op|'='
string|"'typeover'"
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'resetModes'
op|'('
op|'['
name|'insults'
op|'.'
name|'modes'
op|'.'
name|'IRM'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|drawInputLine
dedent|''
name|'def'
name|'drawInputLine'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write a line containing the current input prompt and the current line\n        buffer at the current cursor position.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'write'
op|'('
name|'self'
op|'.'
name|'ps'
op|'['
name|'self'
op|'.'
name|'pn'
op|']'
op|'+'
string|"''"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'lineBuffer'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|terminalSize
dedent|''
name|'def'
name|'terminalSize'
op|'('
name|'self'
op|','
name|'width'
op|','
name|'height'
op|')'
op|':'
newline|'\n'
comment|'# XXX - Clear the previous input line, redraw it at the new'
nl|'\n'
comment|'# cursor position'
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'eraseDisplay'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'cursorHome'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'width'
op|'='
name|'width'
newline|'\n'
name|'self'
op|'.'
name|'height'
op|'='
name|'height'
newline|'\n'
name|'self'
op|'.'
name|'drawInputLine'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|unhandledControlSequence
dedent|''
name|'def'
name|'unhandledControlSequence'
op|'('
name|'self'
op|','
name|'seq'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|keystrokeReceived
dedent|''
name|'def'
name|'keystrokeReceived'
op|'('
name|'self'
op|','
name|'keyID'
op|','
name|'modifier'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'m'
op|'='
name|'self'
op|'.'
name|'keyHandlers'
op|'.'
name|'get'
op|'('
name|'keyID'
op|')'
newline|'\n'
name|'if'
name|'m'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'m'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'keyID'
name|'in'
name|'string'
op|'.'
name|'printable'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'characterReceived'
op|'('
name|'keyID'
op|','
name|'False'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'log'
op|'.'
name|'msg'
op|'('
string|'"Received unhandled keyID: %r"'
op|'%'
op|'('
name|'keyID'
op|','
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|characterReceived
dedent|''
dedent|''
name|'def'
name|'characterReceived'
op|'('
name|'self'
op|','
name|'ch'
op|','
name|'moreCharactersComing'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'mode'
op|'=='
string|"'insert'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'lineBuffer'
op|'.'
name|'insert'
op|'('
name|'self'
op|'.'
name|'lineBufferIndex'
op|','
name|'ch'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'lineBuffer'
op|'['
name|'self'
op|'.'
name|'lineBufferIndex'
op|':'
name|'self'
op|'.'
name|'lineBufferIndex'
op|'+'
number|'1'
op|']'
op|'='
op|'['
name|'ch'
op|']'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'lineBufferIndex'
op|'+='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'write'
op|'('
name|'ch'
op|')'
newline|'\n'
nl|'\n'
DECL|member|handle_TAB
dedent|''
name|'def'
name|'handle_TAB'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'n'
op|'='
name|'self'
op|'.'
name|'TABSTOP'
op|'-'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'lineBuffer'
op|')'
op|'%'
name|'self'
op|'.'
name|'TABSTOP'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'cursorForward'
op|'('
name|'n'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'lineBufferIndex'
op|'+='
name|'n'
newline|'\n'
name|'self'
op|'.'
name|'lineBuffer'
op|'.'
name|'extend'
op|'('
string|"' '"
op|'*'
name|'n'
op|')'
newline|'\n'
nl|'\n'
DECL|member|handle_LEFT
dedent|''
name|'def'
name|'handle_LEFT'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'lineBufferIndex'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'lineBufferIndex'
op|'-='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'cursorBackward'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|handle_RIGHT
dedent|''
dedent|''
name|'def'
name|'handle_RIGHT'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'lineBufferIndex'
op|'<'
name|'len'
op|'('
name|'self'
op|'.'
name|'lineBuffer'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'lineBufferIndex'
op|'+='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'cursorForward'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|handle_HOME
dedent|''
dedent|''
name|'def'
name|'handle_HOME'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'lineBufferIndex'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'cursorBackward'
op|'('
name|'self'
op|'.'
name|'lineBufferIndex'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'lineBufferIndex'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|member|handle_END
dedent|''
dedent|''
name|'def'
name|'handle_END'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'offset'
op|'='
name|'len'
op|'('
name|'self'
op|'.'
name|'lineBuffer'
op|')'
op|'-'
name|'self'
op|'.'
name|'lineBufferIndex'
newline|'\n'
name|'if'
name|'offset'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'cursorForward'
op|'('
name|'offset'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'lineBufferIndex'
op|'='
name|'len'
op|'('
name|'self'
op|'.'
name|'lineBuffer'
op|')'
newline|'\n'
nl|'\n'
DECL|member|handle_BACKSPACE
dedent|''
dedent|''
name|'def'
name|'handle_BACKSPACE'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'lineBufferIndex'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'lineBufferIndex'
op|'-='
number|'1'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'lineBuffer'
op|'['
name|'self'
op|'.'
name|'lineBufferIndex'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'cursorBackward'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'deleteCharacter'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|handle_DELETE
dedent|''
dedent|''
name|'def'
name|'handle_DELETE'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'lineBufferIndex'
op|'<'
name|'len'
op|'('
name|'self'
op|'.'
name|'lineBuffer'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'del'
name|'self'
op|'.'
name|'lineBuffer'
op|'['
name|'self'
op|'.'
name|'lineBufferIndex'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'deleteCharacter'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|handle_RETURN
dedent|''
dedent|''
name|'def'
name|'handle_RETURN'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'line'
op|'='
string|"''"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'lineBuffer'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'lineBuffer'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'lineBufferIndex'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'nextLine'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'lineReceived'
op|'('
name|'line'
op|')'
newline|'\n'
nl|'\n'
DECL|member|handle_INSERT
dedent|''
name|'def'
name|'handle_INSERT'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'assert'
name|'self'
op|'.'
name|'mode'
name|'in'
op|'('
string|"'typeover'"
op|','
string|"'insert'"
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'mode'
op|'=='
string|"'typeover'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'setInsertMode'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'setTypeoverMode'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|lineReceived
dedent|''
dedent|''
name|'def'
name|'lineReceived'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|class|HistoricRecvLine
dedent|''
dedent|''
name|'class'
name|'HistoricRecvLine'
op|'('
name|'RecvLine'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""L{TerminalProtocol} which adds both basic line-editing features and input history.\n\n    Everything supported by L{RecvLine} is also supported by this class.  In addition, the\n    up and down arrows traverse the input history.  Each received line is automatically\n    added to the end of the input history.\n    """'
newline|'\n'
DECL|member|connectionMade
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'RecvLine'
op|'.'
name|'connectionMade'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'historyLines'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'historyPosition'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'t'
op|'='
name|'self'
op|'.'
name|'terminal'
newline|'\n'
name|'self'
op|'.'
name|'keyHandlers'
op|'.'
name|'update'
op|'('
op|'{'
name|'t'
op|'.'
name|'UP_ARROW'
op|':'
name|'self'
op|'.'
name|'handle_UP'
op|','
nl|'\n'
name|'t'
op|'.'
name|'DOWN_ARROW'
op|':'
name|'self'
op|'.'
name|'handle_DOWN'
op|'}'
op|')'
newline|'\n'
nl|'\n'
DECL|member|currentHistoryBuffer
dedent|''
name|'def'
name|'currentHistoryBuffer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'b'
op|'='
name|'tuple'
op|'('
name|'self'
op|'.'
name|'historyLines'
op|')'
newline|'\n'
name|'return'
name|'b'
op|'['
op|':'
name|'self'
op|'.'
name|'historyPosition'
op|']'
op|','
name|'b'
op|'['
name|'self'
op|'.'
name|'historyPosition'
op|':'
op|']'
newline|'\n'
nl|'\n'
DECL|member|_deliverBuffer
dedent|''
name|'def'
name|'_deliverBuffer'
op|'('
name|'self'
op|','
name|'buf'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'buf'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'ch'
name|'in'
name|'buf'
op|'['
op|':'
op|'-'
number|'1'
op|']'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'characterReceived'
op|'('
name|'ch'
op|','
name|'True'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'characterReceived'
op|'('
name|'buf'
op|'['
op|'-'
number|'1'
op|']'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
DECL|member|handle_UP
dedent|''
dedent|''
name|'def'
name|'handle_UP'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'lineBuffer'
name|'and'
name|'self'
op|'.'
name|'historyPosition'
op|'=='
name|'len'
op|'('
name|'self'
op|'.'
name|'historyLines'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'historyLines'
op|'.'
name|'append'
op|'('
name|'self'
op|'.'
name|'lineBuffer'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'historyPosition'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'handle_HOME'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'eraseToLineEnd'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'historyPosition'
op|'-='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'lineBuffer'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_deliverBuffer'
op|'('
name|'self'
op|'.'
name|'historyLines'
op|'['
name|'self'
op|'.'
name|'historyPosition'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|handle_DOWN
dedent|''
dedent|''
name|'def'
name|'handle_DOWN'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'historyPosition'
op|'<'
name|'len'
op|'('
name|'self'
op|'.'
name|'historyLines'
op|')'
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'handle_HOME'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'eraseToLineEnd'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'historyPosition'
op|'+='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'lineBuffer'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_deliverBuffer'
op|'('
name|'self'
op|'.'
name|'historyLines'
op|'['
name|'self'
op|'.'
name|'historyPosition'
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'handle_HOME'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'terminal'
op|'.'
name|'eraseToLineEnd'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'historyPosition'
op|'='
name|'len'
op|'('
name|'self'
op|'.'
name|'historyLines'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'lineBuffer'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'lineBufferIndex'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|member|handle_RETURN
dedent|''
dedent|''
name|'def'
name|'handle_RETURN'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'lineBuffer'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'historyLines'
op|'.'
name|'append'
op|'('
string|"''"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'lineBuffer'
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'historyPosition'
op|'='
name|'len'
op|'('
name|'self'
op|'.'
name|'historyLines'
op|')'
newline|'\n'
name|'return'
name|'RecvLine'
op|'.'
name|'handle_RETURN'
op|'('
name|'self'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
