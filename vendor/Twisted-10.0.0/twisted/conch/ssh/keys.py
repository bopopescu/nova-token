begin_unit
comment|'# -*- test-case-name: twisted.conch.test.test_keys -*-'
nl|'\n'
comment|'# Copyright (c) 2001-2010 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nHandling of RSA and DSA keys.\n\nMaintainer: U{Paul Swartz}\n"""'
newline|'\n'
nl|'\n'
comment|'# base library imports'
nl|'\n'
name|'import'
name|'base64'
newline|'\n'
name|'import'
name|'warnings'
newline|'\n'
name|'import'
name|'itertools'
newline|'\n'
nl|'\n'
comment|'# external library imports'
nl|'\n'
name|'from'
name|'Crypto'
op|'.'
name|'Cipher'
name|'import'
name|'DES3'
newline|'\n'
name|'from'
name|'Crypto'
op|'.'
name|'PublicKey'
name|'import'
name|'RSA'
op|','
name|'DSA'
newline|'\n'
name|'from'
name|'Crypto'
name|'import'
name|'Util'
newline|'\n'
name|'from'
name|'pyasn1'
op|'.'
name|'type'
name|'import'
name|'univ'
newline|'\n'
name|'from'
name|'pyasn1'
op|'.'
name|'codec'
op|'.'
name|'ber'
name|'import'
name|'decoder'
name|'as'
name|'berDecoder'
newline|'\n'
name|'from'
name|'pyasn1'
op|'.'
name|'codec'
op|'.'
name|'ber'
name|'import'
name|'encoder'
name|'as'
name|'berEncoder'
newline|'\n'
nl|'\n'
comment|'# twisted'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'randbytes'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'hashlib'
name|'import'
name|'md5'
op|','
name|'sha1'
newline|'\n'
nl|'\n'
comment|'# sibling imports'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'conch'
op|'.'
name|'ssh'
name|'import'
name|'common'
op|','
name|'sexpy'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|BadKeyError
name|'class'
name|'BadKeyError'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Raised when a key isn\'t what we expected from it.\n\n    XXX: we really need to check for bad keys\n    """'
newline|'\n'
nl|'\n'
DECL|class|EncryptedKeyError
dedent|''
name|'class'
name|'EncryptedKeyError'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Raised when an encrypted key is presented to fromString/fromFile without\n    a password.\n    """'
newline|'\n'
nl|'\n'
DECL|class|Key
dedent|''
name|'class'
name|'Key'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    An object representing a key.  A key can be either a public or\n    private key.  A public key can verify a signature; a private key can\n    create or verify a signature.  To generate a string that can be stored\n    on disk, use the toString method.  If you have a private key, but want\n    the string representation of the public key, use Key.public().toString().\n\n    @ivar keyObject: The C{Crypto.PublicKey.pubkey.pubkey} object that\n                  operations are performed with.\n    """'
newline|'\n'
nl|'\n'
DECL|member|fromFile
name|'def'
name|'fromFile'
op|'('
name|'Class'
op|','
name|'filename'
op|','
name|'type'
op|'='
name|'None'
op|','
name|'passphrase'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a Key object corresponding to the data in filename.  type\n        and passphrase function as they do in fromString.\n        """'
newline|'\n'
name|'return'
name|'Class'
op|'.'
name|'fromString'
op|'('
name|'file'
op|'('
name|'filename'
op|','
string|"'rb'"
op|')'
op|'.'
name|'read'
op|'('
op|')'
op|','
name|'type'
op|','
name|'passphrase'
op|')'
newline|'\n'
DECL|variable|fromFile
dedent|''
name|'fromFile'
op|'='
name|'classmethod'
op|'('
name|'fromFile'
op|')'
newline|'\n'
nl|'\n'
DECL|member|fromString
name|'def'
name|'fromString'
op|'('
name|'Class'
op|','
name|'data'
op|','
name|'type'
op|'='
name|'None'
op|','
name|'passphrase'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a Key object corresponding to the string data.\n        type is optionally the type of string, matching a _fromString_*\n        method.  Otherwise, the _guessStringType() classmethod will be used\n        to guess a type.  If the key is encrypted, passphrase is used as\n        the decryption key.\n\n        @type data: C{str}\n        @type type: C{None}/C{str}\n        @type passphrase: C{None}/C{str}\n        @rtype: C{Key}\n        """'
newline|'\n'
name|'if'
name|'type'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'type'
op|'='
name|'Class'
op|'.'
name|'_guessStringType'
op|'('
name|'data'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'type'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'BadKeyError'
op|'('
string|"'cannot guess the type of %r'"
op|'%'
name|'data'
op|')'
newline|'\n'
dedent|''
name|'method'
op|'='
name|'getattr'
op|'('
name|'Class'
op|','
string|"'_fromString_%s'"
op|'%'
name|'type'
op|'.'
name|'upper'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'method'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'BadKeyError'
op|'('
string|"'no _fromString method for %s'"
op|'%'
name|'type'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'method'
op|'.'
name|'func_code'
op|'.'
name|'co_argcount'
op|'=='
number|'2'
op|':'
comment|'# no passphrase'
newline|'\n'
indent|'            '
name|'if'
name|'passphrase'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'BadKeyError'
op|'('
string|"'key not encrypted'"
op|')'
newline|'\n'
dedent|''
name|'return'
name|'method'
op|'('
name|'data'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'method'
op|'('
name|'data'
op|','
name|'passphrase'
op|')'
newline|'\n'
DECL|variable|fromString
dedent|''
dedent|''
name|'fromString'
op|'='
name|'classmethod'
op|'('
name|'fromString'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_fromString_BLOB
name|'def'
name|'_fromString_BLOB'
op|'('
name|'Class'
op|','
name|'blob'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a public key object corresponding to this public key blob.\n        The format of a RSA public key blob is::\n            string \'ssh-rsa\'\n            integer e\n            integer n\n\n        The format of a DSA public key blob is::\n            string \'ssh-dss\'\n            integer p\n            integer q\n            integer g\n            integer y\n\n        @type blob: C{str}\n        @return: a C{Crypto.PublicKey.pubkey.pubkey} object\n        @raises BadKeyError: if the key type (the first string) is unknown.\n        """'
newline|'\n'
name|'keyType'
op|','
name|'rest'
op|'='
name|'common'
op|'.'
name|'getNS'
op|'('
name|'blob'
op|')'
newline|'\n'
name|'if'
name|'keyType'
op|'=='
string|"'ssh-rsa'"
op|':'
newline|'\n'
indent|'            '
name|'e'
op|','
name|'n'
op|','
name|'rest'
op|'='
name|'common'
op|'.'
name|'getMP'
op|'('
name|'rest'
op|','
number|'2'
op|')'
newline|'\n'
name|'return'
name|'Class'
op|'('
name|'RSA'
op|'.'
name|'construct'
op|'('
op|'('
name|'n'
op|','
name|'e'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'keyType'
op|'=='
string|"'ssh-dss'"
op|':'
newline|'\n'
indent|'            '
name|'p'
op|','
name|'q'
op|','
name|'g'
op|','
name|'y'
op|','
name|'rest'
op|'='
name|'common'
op|'.'
name|'getMP'
op|'('
name|'rest'
op|','
number|'4'
op|')'
newline|'\n'
name|'return'
name|'Class'
op|'('
name|'DSA'
op|'.'
name|'construct'
op|'('
op|'('
name|'y'
op|','
name|'g'
op|','
name|'p'
op|','
name|'q'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'BadKeyError'
op|'('
string|"'unknown blob type: %s'"
op|'%'
name|'keyType'
op|')'
newline|'\n'
DECL|variable|_fromString_BLOB
dedent|''
dedent|''
name|'_fromString_BLOB'
op|'='
name|'classmethod'
op|'('
name|'_fromString_BLOB'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_fromString_PRIVATE_BLOB
name|'def'
name|'_fromString_PRIVATE_BLOB'
op|'('
name|'Class'
op|','
name|'blob'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a private key object corresponding to this private key blob.\n        The blob formats are as follows:\n\n        RSA keys::\n            string \'ssh-rsa\'\n            integer n\n            integer e\n            integer d\n            integer u\n            integer p\n            integer q\n\n        DSA keys::\n            string \'ssh-dss\'\n            integer p\n            integer q\n            integer g\n            integer y\n            integer x\n\n        @type blob: C{str}\n        @return: a C{Crypto.PublicKey.pubkey.pubkey} object\n        @raises BadKeyError: if the key type (the first string) is unknown.\n        """'
newline|'\n'
name|'keyType'
op|','
name|'rest'
op|'='
name|'common'
op|'.'
name|'getNS'
op|'('
name|'blob'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'keyType'
op|'=='
string|"'ssh-rsa'"
op|':'
newline|'\n'
indent|'            '
name|'n'
op|','
name|'e'
op|','
name|'d'
op|','
name|'u'
op|','
name|'p'
op|','
name|'q'
op|','
name|'rest'
op|'='
name|'common'
op|'.'
name|'getMP'
op|'('
name|'rest'
op|','
number|'6'
op|')'
newline|'\n'
name|'rsakey'
op|'='
name|'Class'
op|'('
name|'RSA'
op|'.'
name|'construct'
op|'('
op|'('
name|'n'
op|','
name|'e'
op|','
name|'d'
op|','
name|'p'
op|','
name|'q'
op|','
name|'u'
op|')'
op|')'
op|')'
newline|'\n'
name|'return'
name|'rsakey'
newline|'\n'
dedent|''
name|'elif'
name|'keyType'
op|'=='
string|"'ssh-dss'"
op|':'
newline|'\n'
indent|'            '
name|'p'
op|','
name|'q'
op|','
name|'g'
op|','
name|'y'
op|','
name|'x'
op|','
name|'rest'
op|'='
name|'common'
op|'.'
name|'getMP'
op|'('
name|'rest'
op|','
number|'5'
op|')'
newline|'\n'
name|'dsakey'
op|'='
name|'Class'
op|'('
name|'DSA'
op|'.'
name|'construct'
op|'('
op|'('
name|'y'
op|','
name|'g'
op|','
name|'p'
op|','
name|'q'
op|','
name|'x'
op|')'
op|')'
op|')'
newline|'\n'
name|'return'
name|'dsakey'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'BadKeyError'
op|'('
string|"'unknown blob type: %s'"
op|'%'
name|'keyType'
op|')'
newline|'\n'
DECL|variable|_fromString_PRIVATE_BLOB
dedent|''
dedent|''
name|'_fromString_PRIVATE_BLOB'
op|'='
name|'classmethod'
op|'('
name|'_fromString_PRIVATE_BLOB'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_fromString_PUBLIC_OPENSSH
name|'def'
name|'_fromString_PUBLIC_OPENSSH'
op|'('
name|'Class'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a public key object corresponding to this OpenSSH public key\n        string.  The format of an OpenSSH public key string is::\n            <key type> <base64-encoded public key blob>\n\n        @type data: C{str}\n        @return: A {Crypto.PublicKey.pubkey.pubkey} object\n        @raises BadKeyError: if the blob type is unknown.\n        """'
newline|'\n'
name|'blob'
op|'='
name|'base64'
op|'.'
name|'decodestring'
op|'('
name|'data'
op|'.'
name|'split'
op|'('
op|')'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
name|'return'
name|'Class'
op|'.'
name|'_fromString_BLOB'
op|'('
name|'blob'
op|')'
newline|'\n'
DECL|variable|_fromString_PUBLIC_OPENSSH
dedent|''
name|'_fromString_PUBLIC_OPENSSH'
op|'='
name|'classmethod'
op|'('
name|'_fromString_PUBLIC_OPENSSH'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_fromString_PRIVATE_OPENSSH
name|'def'
name|'_fromString_PRIVATE_OPENSSH'
op|'('
name|'Class'
op|','
name|'data'
op|','
name|'passphrase'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a private key object corresponding to this OpenSSH private key\n        string.  If the key is encrypted, passphrase MUST be provided.\n        Providing a passphrase for an unencrypted key is an error.\n\n        The format of an OpenSSH private key string is::\n            -----BEGIN <key type> PRIVATE KEY-----\n            [Proc-Type: 4,ENCRYPTED\n            DEK-Info: DES-EDE3-CBC,<initialization value>]\n            <base64-encoded ASN.1 structure>\n            ------END <key type> PRIVATE KEY------\n\n        The ASN.1 structure of a RSA key is::\n            (0, n, e, d, p, q)\n\n        The ASN.1 structure of a DSA key is::\n            (0, p, q, g, y, x)\n\n        @type data: C{str}\n        @type passphrase: C{str}\n        @return: a C{Crypto.PublicKey.pubkey.pubkey} object\n        @raises BadKeyError: if\n            * a passphrase is provided for an unencrypted key\n            * a passphrase is not provided for an encrypted key\n            * the ASN.1 encoding is incorrect\n        """'
newline|'\n'
name|'lines'
op|'='
op|'['
name|'x'
op|'+'
string|"'\\n'"
name|'for'
name|'x'
name|'in'
name|'data'
op|'.'
name|'split'
op|'('
string|"'\\n'"
op|')'
op|']'
newline|'\n'
name|'kind'
op|'='
name|'lines'
op|'['
number|'0'
op|']'
op|'['
number|'11'
op|':'
number|'14'
op|']'
newline|'\n'
name|'if'
name|'lines'
op|'['
number|'1'
op|']'
op|'.'
name|'startswith'
op|'('
string|"'Proc-Type: 4,ENCRYPTED'"
op|')'
op|':'
comment|'# encrypted key'
newline|'\n'
indent|'            '
name|'ivdata'
op|'='
name|'lines'
op|'['
number|'2'
op|']'
op|'.'
name|'split'
op|'('
string|"','"
op|')'
op|'['
number|'1'
op|']'
op|'['
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
name|'iv'
op|'='
string|"''"
op|'.'
name|'join'
op|'('
op|'['
name|'chr'
op|'('
name|'int'
op|'('
name|'ivdata'
op|'['
name|'i'
op|':'
name|'i'
op|'+'
number|'2'
op|']'
op|','
number|'16'
op|')'
op|')'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
number|'0'
op|','
nl|'\n'
name|'len'
op|'('
name|'ivdata'
op|')'
op|','
number|'2'
op|')'
op|']'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'passphrase'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'EncryptedKeyError'
op|'('
string|"'encrypted key with no passphrase'"
op|')'
newline|'\n'
dedent|''
name|'ba'
op|'='
name|'md5'
op|'('
name|'passphrase'
op|'+'
name|'iv'
op|')'
op|'.'
name|'digest'
op|'('
op|')'
newline|'\n'
name|'bb'
op|'='
name|'md5'
op|'('
name|'ba'
op|'+'
name|'passphrase'
op|'+'
name|'iv'
op|')'
op|'.'
name|'digest'
op|'('
op|')'
newline|'\n'
name|'decKey'
op|'='
op|'('
name|'ba'
op|'+'
name|'bb'
op|')'
op|'['
op|':'
number|'24'
op|']'
newline|'\n'
name|'b64Data'
op|'='
name|'base64'
op|'.'
name|'decodestring'
op|'('
string|"''"
op|'.'
name|'join'
op|'('
name|'lines'
op|'['
number|'3'
op|':'
op|'-'
number|'1'
op|']'
op|')'
op|')'
newline|'\n'
name|'keyData'
op|'='
name|'DES3'
op|'.'
name|'new'
op|'('
name|'decKey'
op|','
name|'DES3'
op|'.'
name|'MODE_CBC'
op|','
name|'iv'
op|')'
op|'.'
name|'decrypt'
op|'('
name|'b64Data'
op|')'
newline|'\n'
name|'removeLen'
op|'='
name|'ord'
op|'('
name|'keyData'
op|'['
op|'-'
number|'1'
op|']'
op|')'
newline|'\n'
name|'keyData'
op|'='
name|'keyData'
op|'['
op|':'
op|'-'
name|'removeLen'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'b64Data'
op|'='
string|"''"
op|'.'
name|'join'
op|'('
name|'lines'
op|'['
number|'1'
op|':'
op|'-'
number|'1'
op|']'
op|')'
newline|'\n'
name|'keyData'
op|'='
name|'base64'
op|'.'
name|'decodestring'
op|'('
name|'b64Data'
op|')'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'decodedKey'
op|'='
name|'berDecoder'
op|'.'
name|'decode'
op|'('
name|'keyData'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|','
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'BadKeyError'
op|','
string|"'something wrong with decode'"
newline|'\n'
dedent|''
name|'if'
name|'kind'
op|'=='
string|"'RSA'"
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'len'
op|'('
name|'decodedKey'
op|')'
op|'=='
number|'2'
op|':'
comment|'# alternate RSA key'
newline|'\n'
indent|'                '
name|'decodedKey'
op|'='
name|'decodedKey'
op|'['
number|'0'
op|']'
newline|'\n'
dedent|''
name|'if'
name|'len'
op|'('
name|'decodedKey'
op|')'
op|'<'
number|'6'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'BadKeyError'
op|'('
string|"'RSA key failed to decode properly'"
op|')'
newline|'\n'
dedent|''
name|'n'
op|','
name|'e'
op|','
name|'d'
op|','
name|'p'
op|','
name|'q'
op|'='
op|'['
name|'long'
op|'('
name|'value'
op|')'
name|'for'
name|'value'
name|'in'
name|'decodedKey'
op|'['
number|'1'
op|':'
number|'6'
op|']'
op|']'
newline|'\n'
name|'if'
name|'p'
op|'>'
name|'q'
op|':'
comment|'# make p smaller than q'
newline|'\n'
indent|'                '
name|'p'
op|','
name|'q'
op|'='
name|'q'
op|','
name|'p'
newline|'\n'
dedent|''
name|'return'
name|'Class'
op|'('
name|'RSA'
op|'.'
name|'construct'
op|'('
op|'('
name|'n'
op|','
name|'e'
op|','
name|'d'
op|','
name|'p'
op|','
name|'q'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'kind'
op|'=='
string|"'DSA'"
op|':'
newline|'\n'
indent|'            '
name|'p'
op|','
name|'q'
op|','
name|'g'
op|','
name|'y'
op|','
name|'x'
op|'='
op|'['
name|'long'
op|'('
name|'value'
op|')'
name|'for'
name|'value'
name|'in'
name|'decodedKey'
op|'['
number|'1'
op|':'
number|'6'
op|']'
op|']'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'decodedKey'
op|')'
op|'<'
number|'6'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'BadKeyError'
op|'('
string|"'DSA key failed to decode properly'"
op|')'
newline|'\n'
dedent|''
name|'return'
name|'Class'
op|'('
name|'DSA'
op|'.'
name|'construct'
op|'('
op|'('
name|'y'
op|','
name|'g'
op|','
name|'p'
op|','
name|'q'
op|','
name|'x'
op|')'
op|')'
op|')'
newline|'\n'
DECL|variable|_fromString_PRIVATE_OPENSSH
dedent|''
dedent|''
name|'_fromString_PRIVATE_OPENSSH'
op|'='
name|'classmethod'
op|'('
name|'_fromString_PRIVATE_OPENSSH'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_fromString_PUBLIC_LSH
name|'def'
name|'_fromString_PUBLIC_LSH'
op|'('
name|'Class'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a public key corresponding to this LSH public key string.\n        The LSH public key string format is::\n            <s-expression: (\'public-key\', (<key type>, (<name, <value>)+))>\n\n        The names for a RSA (key type \'rsa-pkcs1-sha1\') key are: n, e.\n        The names for a DSA (key type \'dsa\') key are: y, g, p, q.\n\n        @type data: C{str}\n        @return: a C{Crypto.PublicKey.pubkey.pubkey} object\n        @raises BadKeyError: if the key type is unknown\n        """'
newline|'\n'
name|'sexp'
op|'='
name|'sexpy'
op|'.'
name|'parse'
op|'('
name|'base64'
op|'.'
name|'decodestring'
op|'('
name|'data'
op|'['
number|'1'
op|':'
op|'-'
number|'1'
op|']'
op|')'
op|')'
newline|'\n'
name|'assert'
name|'sexp'
op|'['
number|'0'
op|']'
op|'=='
string|"'public-key'"
newline|'\n'
name|'kd'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'name'
op|','
name|'data'
name|'in'
name|'sexp'
op|'['
number|'1'
op|']'
op|'['
number|'1'
op|':'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'kd'
op|'['
name|'name'
op|']'
op|'='
name|'common'
op|'.'
name|'getMP'
op|'('
name|'common'
op|'.'
name|'NS'
op|'('
name|'data'
op|')'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
dedent|''
name|'if'
name|'sexp'
op|'['
number|'1'
op|']'
op|'['
number|'0'
op|']'
op|'=='
string|"'dsa'"
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'Class'
op|'('
name|'DSA'
op|'.'
name|'construct'
op|'('
op|'('
name|'kd'
op|'['
string|"'y'"
op|']'
op|','
name|'kd'
op|'['
string|"'g'"
op|']'
op|','
name|'kd'
op|'['
string|"'p'"
op|']'
op|','
name|'kd'
op|'['
string|"'q'"
op|']'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'sexp'
op|'['
number|'1'
op|']'
op|'['
number|'0'
op|']'
op|'=='
string|"'rsa-pkcs1-sha1'"
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'Class'
op|'('
name|'RSA'
op|'.'
name|'construct'
op|'('
op|'('
name|'kd'
op|'['
string|"'n'"
op|']'
op|','
name|'kd'
op|'['
string|"'e'"
op|']'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'BadKeyError'
op|'('
string|"'unknown lsh key type %s'"
op|'%'
name|'sexp'
op|'['
number|'1'
op|']'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
DECL|variable|_fromString_PUBLIC_LSH
dedent|''
dedent|''
name|'_fromString_PUBLIC_LSH'
op|'='
name|'classmethod'
op|'('
name|'_fromString_PUBLIC_LSH'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_fromString_PRIVATE_LSH
name|'def'
name|'_fromString_PRIVATE_LSH'
op|'('
name|'Class'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a private key corresponding to this LSH private key string.\n        The LSH private key string format is::\n            <s-expression: (\'private-key\', (<key type>, (<name>, <value>)+))>\n\n        The names for a RSA (key type \'rsa-pkcs1-sha1\') key are: n, e, d, p, q.\n        The names for a DSA (key type \'dsa\') key are: y, g, p, q, x.\n\n        @type data: C{str}\n        @return: a {Crypto.PublicKey.pubkey.pubkey} object\n        @raises BadKeyError: if the key type is unknown\n        """'
newline|'\n'
name|'sexp'
op|'='
name|'sexpy'
op|'.'
name|'parse'
op|'('
name|'data'
op|')'
newline|'\n'
name|'assert'
name|'sexp'
op|'['
number|'0'
op|']'
op|'=='
string|"'private-key'"
newline|'\n'
name|'kd'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'name'
op|','
name|'data'
name|'in'
name|'sexp'
op|'['
number|'1'
op|']'
op|'['
number|'1'
op|':'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'kd'
op|'['
name|'name'
op|']'
op|'='
name|'common'
op|'.'
name|'getMP'
op|'('
name|'common'
op|'.'
name|'NS'
op|'('
name|'data'
op|')'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
dedent|''
name|'if'
name|'sexp'
op|'['
number|'1'
op|']'
op|'['
number|'0'
op|']'
op|'=='
string|"'dsa'"
op|':'
newline|'\n'
indent|'            '
name|'assert'
name|'len'
op|'('
name|'kd'
op|')'
op|'=='
number|'5'
op|','
name|'len'
op|'('
name|'kd'
op|')'
newline|'\n'
name|'return'
name|'Class'
op|'('
name|'DSA'
op|'.'
name|'construct'
op|'('
op|'('
name|'kd'
op|'['
string|"'y'"
op|']'
op|','
name|'kd'
op|'['
string|"'g'"
op|']'
op|','
name|'kd'
op|'['
string|"'p'"
op|']'
op|','
nl|'\n'
name|'kd'
op|'['
string|"'q'"
op|']'
op|','
name|'kd'
op|'['
string|"'x'"
op|']'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'sexp'
op|'['
number|'1'
op|']'
op|'['
number|'0'
op|']'
op|'=='
string|"'rsa-pkcs1'"
op|':'
newline|'\n'
indent|'            '
name|'assert'
name|'len'
op|'('
name|'kd'
op|')'
op|'=='
number|'8'
op|','
name|'len'
op|'('
name|'kd'
op|')'
newline|'\n'
name|'if'
name|'kd'
op|'['
string|"'p'"
op|']'
op|'>'
name|'kd'
op|'['
string|"'q'"
op|']'
op|':'
comment|'# make p smaller than q'
newline|'\n'
indent|'                '
name|'kd'
op|'['
string|"'p'"
op|']'
op|','
name|'kd'
op|'['
string|"'q'"
op|']'
op|'='
name|'kd'
op|'['
string|"'q'"
op|']'
op|','
name|'kd'
op|'['
string|"'p'"
op|']'
newline|'\n'
dedent|''
name|'return'
name|'Class'
op|'('
name|'RSA'
op|'.'
name|'construct'
op|'('
op|'('
name|'kd'
op|'['
string|"'n'"
op|']'
op|','
name|'kd'
op|'['
string|"'e'"
op|']'
op|','
name|'kd'
op|'['
string|"'d'"
op|']'
op|','
nl|'\n'
name|'kd'
op|'['
string|"'p'"
op|']'
op|','
name|'kd'
op|'['
string|"'q'"
op|']'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'BadKeyError'
op|'('
string|"'unknown lsh key type %s'"
op|'%'
name|'sexp'
op|'['
number|'1'
op|']'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
DECL|variable|_fromString_PRIVATE_LSH
dedent|''
dedent|''
name|'_fromString_PRIVATE_LSH'
op|'='
name|'classmethod'
op|'('
name|'_fromString_PRIVATE_LSH'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_fromString_AGENTV3
name|'def'
name|'_fromString_AGENTV3'
op|'('
name|'Class'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a private key object corresponsing to the Secure Shell Key\n        Agent v3 format.\n\n        The SSH Key Agent v3 format for a RSA key is::\n            string \'ssh-rsa\'\n            integer e\n            integer d\n            integer n\n            integer u\n            integer p\n            integer q\n\n        The SSH Key Agent v3 format for a DSA key is::\n            string \'ssh-dss\'\n            integer p\n            integer q\n            integer g\n            integer y\n            integer x\n\n        @type data: C{str}\n        @return: a C{Crypto.PublicKey.pubkey.pubkey} object\n        @raises BadKeyError: if the key type (the first string) is unknown\n        """'
newline|'\n'
name|'keyType'
op|','
name|'data'
op|'='
name|'common'
op|'.'
name|'getNS'
op|'('
name|'data'
op|')'
newline|'\n'
name|'if'
name|'keyType'
op|'=='
string|"'ssh-dss'"
op|':'
newline|'\n'
indent|'            '
name|'p'
op|','
name|'data'
op|'='
name|'common'
op|'.'
name|'getMP'
op|'('
name|'data'
op|')'
newline|'\n'
name|'q'
op|','
name|'data'
op|'='
name|'common'
op|'.'
name|'getMP'
op|'('
name|'data'
op|')'
newline|'\n'
name|'g'
op|','
name|'data'
op|'='
name|'common'
op|'.'
name|'getMP'
op|'('
name|'data'
op|')'
newline|'\n'
name|'y'
op|','
name|'data'
op|'='
name|'common'
op|'.'
name|'getMP'
op|'('
name|'data'
op|')'
newline|'\n'
name|'x'
op|','
name|'data'
op|'='
name|'common'
op|'.'
name|'getMP'
op|'('
name|'data'
op|')'
newline|'\n'
name|'return'
name|'Class'
op|'('
name|'DSA'
op|'.'
name|'construct'
op|'('
op|'('
name|'y'
op|','
name|'g'
op|','
name|'p'
op|','
name|'q'
op|','
name|'x'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'keyType'
op|'=='
string|"'ssh-rsa'"
op|':'
newline|'\n'
indent|'            '
name|'e'
op|','
name|'data'
op|'='
name|'common'
op|'.'
name|'getMP'
op|'('
name|'data'
op|')'
newline|'\n'
name|'d'
op|','
name|'data'
op|'='
name|'common'
op|'.'
name|'getMP'
op|'('
name|'data'
op|')'
newline|'\n'
name|'n'
op|','
name|'data'
op|'='
name|'common'
op|'.'
name|'getMP'
op|'('
name|'data'
op|')'
newline|'\n'
name|'u'
op|','
name|'data'
op|'='
name|'common'
op|'.'
name|'getMP'
op|'('
name|'data'
op|')'
newline|'\n'
name|'p'
op|','
name|'data'
op|'='
name|'common'
op|'.'
name|'getMP'
op|'('
name|'data'
op|')'
newline|'\n'
name|'q'
op|','
name|'data'
op|'='
name|'common'
op|'.'
name|'getMP'
op|'('
name|'data'
op|')'
newline|'\n'
name|'return'
name|'Class'
op|'('
name|'RSA'
op|'.'
name|'construct'
op|'('
op|'('
name|'n'
op|','
name|'e'
op|','
name|'d'
op|','
name|'p'
op|','
name|'q'
op|','
name|'u'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'BadKeyError'
op|'('
string|'"unknown key type %s"'
op|'%'
name|'keyType'
op|')'
newline|'\n'
DECL|variable|_fromString_AGENTV3
dedent|''
dedent|''
name|'_fromString_AGENTV3'
op|'='
name|'classmethod'
op|'('
name|'_fromString_AGENTV3'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_guessStringType
name|'def'
name|'_guessStringType'
op|'('
name|'Class'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Guess the type of key in data.  The types map to _fromString_*\n        methods.\n        """'
newline|'\n'
name|'if'
name|'data'
op|'.'
name|'startswith'
op|'('
string|"'ssh-'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"'public_openssh'"
newline|'\n'
dedent|''
name|'elif'
name|'data'
op|'.'
name|'startswith'
op|'('
string|"'-----BEGIN'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"'private_openssh'"
newline|'\n'
dedent|''
name|'elif'
name|'data'
op|'.'
name|'startswith'
op|'('
string|"'{'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"'public_lsh'"
newline|'\n'
dedent|''
name|'elif'
name|'data'
op|'.'
name|'startswith'
op|'('
string|"'('"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"'private_lsh'"
newline|'\n'
dedent|''
name|'elif'
name|'data'
op|'.'
name|'startswith'
op|'('
string|"'\\x00\\x00\\x00\\x07ssh-'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'ignored'
op|','
name|'rest'
op|'='
name|'common'
op|'.'
name|'getNS'
op|'('
name|'data'
op|')'
newline|'\n'
name|'count'
op|'='
number|'0'
newline|'\n'
name|'while'
name|'rest'
op|':'
newline|'\n'
indent|'                '
name|'count'
op|'+='
number|'1'
newline|'\n'
name|'ignored'
op|','
name|'rest'
op|'='
name|'common'
op|'.'
name|'getMP'
op|'('
name|'rest'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'count'
op|'>'
number|'4'
op|':'
newline|'\n'
indent|'                '
name|'return'
string|"'agentv3'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'return'
string|"'blob'"
newline|'\n'
DECL|variable|_guessStringType
dedent|''
dedent|''
dedent|''
name|'_guessStringType'
op|'='
name|'classmethod'
op|'('
name|'_guessStringType'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'keyObject'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Initialize a PublicKey with a C{Crypto.PublicKey.pubkey.pubkey}\n        object.\n\n        @type keyObject: C{Crypto.PublicKey.pubkey.pubkey}\n        """'
newline|'\n'
name|'self'
op|'.'
name|'keyObject'
op|'='
name|'keyObject'
newline|'\n'
nl|'\n'
DECL|member|__eq__
dedent|''
name|'def'
name|'__eq__'
op|'('
name|'self'
op|','
name|'other'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return True if other represents an object with the same key.\n        """'
newline|'\n'
name|'if'
name|'type'
op|'('
name|'self'
op|')'
op|'=='
name|'type'
op|'('
name|'other'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'type'
op|'('
op|')'
op|'=='
name|'other'
op|'.'
name|'type'
op|'('
op|')'
name|'and'
name|'self'
op|'.'
name|'data'
op|'('
op|')'
op|'=='
name|'other'
op|'.'
name|'data'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'NotImplemented'
newline|'\n'
nl|'\n'
DECL|member|__ne__
dedent|''
dedent|''
name|'def'
name|'__ne__'
op|'('
name|'self'
op|','
name|'other'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return True if other represents anything other than this key.\n        """'
newline|'\n'
name|'result'
op|'='
name|'self'
op|'.'
name|'__eq__'
op|'('
name|'other'
op|')'
newline|'\n'
name|'if'
name|'result'
op|'=='
name|'NotImplemented'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'result'
newline|'\n'
dedent|''
name|'return'
name|'not'
name|'result'
newline|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a pretty representation of this object.\n        """'
newline|'\n'
name|'lines'
op|'='
op|'['
string|"'<%s %s (%s bits)'"
op|'%'
op|'('
name|'self'
op|'.'
name|'type'
op|'('
op|')'
op|','
nl|'\n'
name|'self'
op|'.'
name|'isPublic'
op|'('
op|')'
name|'and'
string|"'Public Key'"
name|'or'
string|"'Private Key'"
op|','
nl|'\n'
name|'self'
op|'.'
name|'keyObject'
op|'.'
name|'size'
op|'('
op|')'
op|')'
op|']'
newline|'\n'
name|'for'
name|'k'
op|','
name|'v'
name|'in'
name|'self'
op|'.'
name|'data'
op|'('
op|')'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'lines'
op|'.'
name|'append'
op|'('
string|"'attr %s:'"
op|'%'
name|'k'
op|')'
newline|'\n'
name|'by'
op|'='
name|'common'
op|'.'
name|'MP'
op|'('
name|'v'
op|')'
op|'['
number|'4'
op|':'
op|']'
newline|'\n'
name|'while'
name|'by'
op|':'
newline|'\n'
indent|'                '
name|'m'
op|'='
name|'by'
op|'['
op|':'
number|'15'
op|']'
newline|'\n'
name|'by'
op|'='
name|'by'
op|'['
number|'15'
op|':'
op|']'
newline|'\n'
name|'o'
op|'='
string|"''"
newline|'\n'
name|'for'
name|'c'
name|'in'
name|'m'
op|':'
newline|'\n'
indent|'                    '
name|'o'
op|'='
name|'o'
op|'+'
string|"'%02x:'"
op|'%'
name|'ord'
op|'('
name|'c'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'len'
op|'('
name|'m'
op|')'
op|'<'
number|'15'
op|':'
newline|'\n'
indent|'                    '
name|'o'
op|'='
name|'o'
op|'['
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
dedent|''
name|'lines'
op|'.'
name|'append'
op|'('
string|"'\\t'"
op|'+'
name|'o'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'lines'
op|'['
op|'-'
number|'1'
op|']'
op|'='
name|'lines'
op|'['
op|'-'
number|'1'
op|']'
op|'+'
string|"'>'"
newline|'\n'
name|'return'
string|"'\\n'"
op|'.'
name|'join'
op|'('
name|'lines'
op|')'
newline|'\n'
nl|'\n'
DECL|member|isPublic
dedent|''
name|'def'
name|'isPublic'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns True if this Key is a public key.\n        """'
newline|'\n'
name|'return'
name|'not'
name|'self'
op|'.'
name|'keyObject'
op|'.'
name|'has_private'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|public
dedent|''
name|'def'
name|'public'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns a version of this key containing only the public key data.\n        If this is a public key, this may or may not be the same object\n        as self.\n        """'
newline|'\n'
name|'return'
name|'Key'
op|'('
name|'self'
op|'.'
name|'keyObject'
op|'.'
name|'publickey'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|fingerprint
dedent|''
name|'def'
name|'fingerprint'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Get the user presentation of the fingerprint of this L{Key}.  As\n        described by U{RFC 4716 section\n        4<http://tools.ietf.org/html/rfc4716#section-4>}::\n\n            The fingerprint of a public key consists of the output of the MD5\n            message-digest algorithm [RFC1321].  The input to the algorithm is\n            the public key data as specified by [RFC4253].  (...)  The output\n            of the (MD5) algorithm is presented to the user as a sequence of 16\n            octets printed as hexadecimal with lowercase letters and separated\n            by colons.\n\n        @since: 8.2\n\n        @return: the user presentation of this L{Key}\'s fingerprint, as a\n        string.\n\n        @rtype: L{str}\n        """'
newline|'\n'
name|'return'
string|"':'"
op|'.'
name|'join'
op|'('
op|'['
name|'x'
op|'.'
name|'encode'
op|'('
string|"'hex'"
op|')'
name|'for'
name|'x'
name|'in'
name|'md5'
op|'('
name|'self'
op|'.'
name|'blob'
op|'('
op|')'
op|')'
op|'.'
name|'digest'
op|'('
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|type
dedent|''
name|'def'
name|'type'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the type of the object we wrap.  Currently this can only be\n        \'RSA\' or \'DSA\'.\n        """'
newline|'\n'
comment|"# the class is Crypto.PublicKey.<type>.<stuff we don't care about>"
nl|'\n'
name|'klass'
op|'='
name|'str'
op|'('
name|'self'
op|'.'
name|'keyObject'
op|'.'
name|'__class__'
op|')'
newline|'\n'
name|'if'
name|'klass'
op|'.'
name|'startswith'
op|'('
string|"'Crypto.PublicKey'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'type'
op|'='
name|'klass'
op|'.'
name|'split'
op|'('
string|"'.'"
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'RuntimeError'
op|'('
string|"'unknown type of object: %r'"
op|'%'
name|'self'
op|'.'
name|'keyObject'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'type'
name|'in'
op|'('
string|"'RSA'"
op|','
string|"'DSA'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'type'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'RuntimeError'
op|'('
string|"'unknown type of key: %s'"
op|'%'
name|'type'
op|')'
newline|'\n'
nl|'\n'
DECL|member|sshType
dedent|''
dedent|''
name|'def'
name|'sshType'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the type of the object we wrap as defined in the ssh protocol.\n        Currently this can only be \'ssh-rsa\' or \'ssh-dss\'.\n        """'
newline|'\n'
name|'return'
op|'{'
string|"'RSA'"
op|':'
string|"'ssh-rsa'"
op|','
string|"'DSA'"
op|':'
string|"'ssh-dss'"
op|'}'
op|'['
name|'self'
op|'.'
name|'type'
op|'('
op|')'
op|']'
newline|'\n'
nl|'\n'
DECL|member|data
dedent|''
name|'def'
name|'data'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the values of the public key as a dictionary.\n\n        @rtype: C{dict}\n        """'
newline|'\n'
name|'keyData'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'name'
name|'in'
name|'self'
op|'.'
name|'keyObject'
op|'.'
name|'keydata'
op|':'
newline|'\n'
indent|'            '
name|'value'
op|'='
name|'getattr'
op|'('
name|'self'
op|'.'
name|'keyObject'
op|','
name|'name'
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'value'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'keyData'
op|'['
name|'name'
op|']'
op|'='
name|'value'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'keyData'
newline|'\n'
nl|'\n'
DECL|member|blob
dedent|''
name|'def'
name|'blob'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the public key blob for this key.  The blob is the\n        over-the-wire format for public keys:\n\n        RSA keys::\n            string  \'ssh-rsa\'\n            integer e\n            integer n\n\n        DSA keys::\n            string  \'ssh-dss\'\n            integer p\n            integer q\n            integer g\n            integer y\n\n        @rtype: C{str}\n        """'
newline|'\n'
name|'type'
op|'='
name|'self'
op|'.'
name|'type'
op|'('
op|')'
newline|'\n'
name|'data'
op|'='
name|'self'
op|'.'
name|'data'
op|'('
op|')'
newline|'\n'
name|'if'
name|'type'
op|'=='
string|"'RSA'"
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'('
name|'common'
op|'.'
name|'NS'
op|'('
string|"'ssh-rsa'"
op|')'
op|'+'
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'e'"
op|']'
op|')'
op|'+'
nl|'\n'
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'n'"
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'type'
op|'=='
string|"'DSA'"
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'('
name|'common'
op|'.'
name|'NS'
op|'('
string|"'ssh-dss'"
op|')'
op|'+'
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'p'"
op|']'
op|')'
op|'+'
nl|'\n'
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'q'"
op|']'
op|')'
op|'+'
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'g'"
op|']'
op|')'
op|'+'
nl|'\n'
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'y'"
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|privateBlob
dedent|''
dedent|''
name|'def'
name|'privateBlob'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the private key blob for this key.  The blob is the\n        over-the-wire format for private keys:\n\n        RSA keys::\n            string \'ssh-rsa\'\n            integer n\n            integer e\n            integer d\n            integer u\n            integer p\n            integer q\n\n        DSA keys::\n            string \'ssh-dss\'\n            integer p\n            integer q\n            integer g\n            integer y\n            integer x\n        """'
newline|'\n'
name|'type'
op|'='
name|'self'
op|'.'
name|'type'
op|'('
op|')'
newline|'\n'
name|'data'
op|'='
name|'self'
op|'.'
name|'data'
op|'('
op|')'
newline|'\n'
name|'if'
name|'type'
op|'=='
string|"'RSA'"
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'('
name|'common'
op|'.'
name|'NS'
op|'('
string|"'ssh-rsa'"
op|')'
op|'+'
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'n'"
op|']'
op|')'
op|'+'
nl|'\n'
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'e'"
op|']'
op|')'
op|'+'
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'d'"
op|']'
op|')'
op|'+'
nl|'\n'
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'u'"
op|']'
op|')'
op|'+'
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'p'"
op|']'
op|')'
op|'+'
nl|'\n'
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'q'"
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'type'
op|'=='
string|"'DSA'"
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'('
name|'common'
op|'.'
name|'NS'
op|'('
string|"'ssh-dss'"
op|')'
op|'+'
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'p'"
op|']'
op|')'
op|'+'
nl|'\n'
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'q'"
op|']'
op|')'
op|'+'
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'g'"
op|']'
op|')'
op|'+'
nl|'\n'
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'y'"
op|']'
op|')'
op|'+'
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'x'"
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|toString
dedent|''
dedent|''
name|'def'
name|'toString'
op|'('
name|'self'
op|','
name|'type'
op|','
name|'extra'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a string representation of this key.  If the key is a private\n        key and you want the represenation of its public key, use\n        C{key.public().toString()}.  type maps to a _toString_* method.\n\n        @param type: The type of string to emit.  Currently supported values\n            are C{\'OPENSSH\'}, C{\'LSH\'}, and C{\'AGENTV3\'}.\n        @type type: L{str}\n\n        @param extra: Any extra data supported by the selected format which\n            is not part of the key itself.  For public OpenSSH keys, this is\n            a comment.  For private OpenSSH keys, this is a passphrase to\n            encrypt with.\n        @type extra: L{str} or L{NoneType}\n\n        @rtype: L{str}\n        """'
newline|'\n'
name|'method'
op|'='
name|'getattr'
op|'('
name|'self'
op|','
string|"'_toString_%s'"
op|'%'
name|'type'
op|'.'
name|'upper'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'method'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'BadKeyError'
op|'('
string|"'unknown type: %s'"
op|'%'
name|'type'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'method'
op|'.'
name|'func_code'
op|'.'
name|'co_argcount'
op|'=='
number|'2'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'method'
op|'('
name|'extra'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'method'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_toString_OPENSSH
dedent|''
dedent|''
name|'def'
name|'_toString_OPENSSH'
op|'('
name|'self'
op|','
name|'extra'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a public or private OpenSSH string.  See\n        _fromString_PUBLIC_OPENSSH and _fromString_PRIVATE_OPENSSH for the\n        string formats.  If extra is present, it represents a comment for a\n        public key, or a passphrase for a private key.\n\n        @type extra: C{str}\n        @rtype: C{str}\n        """'
newline|'\n'
name|'data'
op|'='
name|'self'
op|'.'
name|'data'
op|'('
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'isPublic'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'b64Data'
op|'='
name|'base64'
op|'.'
name|'encodestring'
op|'('
name|'self'
op|'.'
name|'blob'
op|'('
op|')'
op|')'
op|'.'
name|'replace'
op|'('
string|"'\\n'"
op|','
string|"''"
op|')'
newline|'\n'
name|'if'
name|'not'
name|'extra'
op|':'
newline|'\n'
indent|'                '
name|'extra'
op|'='
string|"''"
newline|'\n'
dedent|''
name|'return'
op|'('
string|"'%s %s %s'"
op|'%'
op|'('
name|'self'
op|'.'
name|'sshType'
op|'('
op|')'
op|','
name|'b64Data'
op|','
name|'extra'
op|')'
op|')'
op|'.'
name|'strip'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'lines'
op|'='
op|'['
string|"'-----BEGIN %s PRIVATE KEY-----'"
op|'%'
name|'self'
op|'.'
name|'type'
op|'('
op|')'
op|']'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'type'
op|'('
op|')'
op|'=='
string|"'RSA'"
op|':'
newline|'\n'
indent|'                '
name|'p'
op|','
name|'q'
op|'='
name|'data'
op|'['
string|"'p'"
op|']'
op|','
name|'data'
op|'['
string|"'q'"
op|']'
newline|'\n'
name|'objData'
op|'='
op|'('
number|'0'
op|','
name|'data'
op|'['
string|"'n'"
op|']'
op|','
name|'data'
op|'['
string|"'e'"
op|']'
op|','
name|'data'
op|'['
string|"'d'"
op|']'
op|','
name|'q'
op|','
name|'p'
op|','
nl|'\n'
name|'data'
op|'['
string|"'d'"
op|']'
op|'%'
op|'('
name|'q'
op|'-'
number|'1'
op|')'
op|','
name|'data'
op|'['
string|"'d'"
op|']'
op|'%'
op|'('
name|'p'
op|'-'
number|'1'
op|')'
op|','
nl|'\n'
name|'data'
op|'['
string|"'u'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'objData'
op|'='
op|'('
number|'0'
op|','
name|'data'
op|'['
string|"'p'"
op|']'
op|','
name|'data'
op|'['
string|"'q'"
op|']'
op|','
name|'data'
op|'['
string|"'g'"
op|']'
op|','
name|'data'
op|'['
string|"'y'"
op|']'
op|','
nl|'\n'
name|'data'
op|'['
string|"'x'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'asn1Sequence'
op|'='
name|'univ'
op|'.'
name|'Sequence'
op|'('
op|')'
newline|'\n'
name|'for'
name|'index'
op|','
name|'value'
name|'in'
name|'itertools'
op|'.'
name|'izip'
op|'('
name|'itertools'
op|'.'
name|'count'
op|'('
op|')'
op|','
name|'objData'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'asn1Sequence'
op|'.'
name|'setComponentByPosition'
op|'('
name|'index'
op|','
name|'univ'
op|'.'
name|'Integer'
op|'('
name|'value'
op|')'
op|')'
newline|'\n'
dedent|''
name|'asn1Data'
op|'='
name|'berEncoder'
op|'.'
name|'encode'
op|'('
name|'asn1Sequence'
op|')'
newline|'\n'
name|'if'
name|'extra'
op|':'
newline|'\n'
indent|'                '
name|'iv'
op|'='
name|'randbytes'
op|'.'
name|'secureRandom'
op|'('
number|'8'
op|')'
newline|'\n'
name|'hexiv'
op|'='
string|"''"
op|'.'
name|'join'
op|'('
op|'['
string|"'%02X'"
op|'%'
name|'ord'
op|'('
name|'x'
op|')'
name|'for'
name|'x'
name|'in'
name|'iv'
op|']'
op|')'
newline|'\n'
name|'lines'
op|'.'
name|'append'
op|'('
string|"'Proc-Type: 4,ENCRYPTED'"
op|')'
newline|'\n'
name|'lines'
op|'.'
name|'append'
op|'('
string|"'DEK-Info: DES-EDE3-CBC,%s\\n'"
op|'%'
name|'hexiv'
op|')'
newline|'\n'
name|'ba'
op|'='
name|'md5'
op|'('
name|'extra'
op|'+'
name|'iv'
op|')'
op|'.'
name|'digest'
op|'('
op|')'
newline|'\n'
name|'bb'
op|'='
name|'md5'
op|'('
name|'ba'
op|'+'
name|'extra'
op|'+'
name|'iv'
op|')'
op|'.'
name|'digest'
op|'('
op|')'
newline|'\n'
name|'encKey'
op|'='
op|'('
name|'ba'
op|'+'
name|'bb'
op|')'
op|'['
op|':'
number|'24'
op|']'
newline|'\n'
name|'padLen'
op|'='
number|'8'
op|'-'
op|'('
name|'len'
op|'('
name|'asn1Data'
op|')'
op|'%'
number|'8'
op|')'
newline|'\n'
name|'asn1Data'
op|'+='
op|'('
name|'chr'
op|'('
name|'padLen'
op|')'
op|'*'
name|'padLen'
op|')'
newline|'\n'
name|'asn1Data'
op|'='
name|'DES3'
op|'.'
name|'new'
op|'('
name|'encKey'
op|','
name|'DES3'
op|'.'
name|'MODE_CBC'
op|','
nl|'\n'
name|'iv'
op|')'
op|'.'
name|'encrypt'
op|'('
name|'asn1Data'
op|')'
newline|'\n'
dedent|''
name|'b64Data'
op|'='
name|'base64'
op|'.'
name|'encodestring'
op|'('
name|'asn1Data'
op|')'
op|'.'
name|'replace'
op|'('
string|"'\\n'"
op|','
string|"''"
op|')'
newline|'\n'
name|'lines'
op|'+='
op|'['
name|'b64Data'
op|'['
name|'i'
op|':'
name|'i'
op|'+'
number|'64'
op|']'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
number|'0'
op|','
name|'len'
op|'('
name|'b64Data'
op|')'
op|','
number|'64'
op|')'
op|']'
newline|'\n'
name|'lines'
op|'.'
name|'append'
op|'('
string|"'-----END %s PRIVATE KEY-----'"
op|'%'
name|'self'
op|'.'
name|'type'
op|'('
op|')'
op|')'
newline|'\n'
name|'return'
string|"'\\n'"
op|'.'
name|'join'
op|'('
name|'lines'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_toString_LSH
dedent|''
dedent|''
name|'def'
name|'_toString_LSH'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a public or private LSH key.  See _fromString_PUBLIC_LSH and\n        _fromString_PRIVATE_LSH for the key formats.\n\n        @rtype: C{str}\n        """'
newline|'\n'
name|'data'
op|'='
name|'self'
op|'.'
name|'data'
op|'('
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'isPublic'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'type'
op|'('
op|')'
op|'=='
string|"'RSA'"
op|':'
newline|'\n'
indent|'                '
name|'keyData'
op|'='
name|'sexpy'
op|'.'
name|'pack'
op|'('
op|'['
op|'['
string|"'public-key'"
op|','
op|'['
string|"'rsa-pkcs1-sha1'"
op|','
nl|'\n'
op|'['
string|"'n'"
op|','
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'n'"
op|']'
op|')'
op|'['
number|'4'
op|':'
op|']'
op|']'
op|','
nl|'\n'
op|'['
string|"'e'"
op|','
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'e'"
op|']'
op|')'
op|'['
number|'4'
op|':'
op|']'
op|']'
op|']'
op|']'
op|']'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'type'
op|'('
op|')'
op|'=='
string|"'DSA'"
op|':'
newline|'\n'
indent|'                '
name|'keyData'
op|'='
name|'sexpy'
op|'.'
name|'pack'
op|'('
op|'['
op|'['
string|"'public-key'"
op|','
op|'['
string|"'dsa'"
op|','
nl|'\n'
op|'['
string|"'p'"
op|','
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'p'"
op|']'
op|')'
op|'['
number|'4'
op|':'
op|']'
op|']'
op|','
nl|'\n'
op|'['
string|"'q'"
op|','
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'q'"
op|']'
op|')'
op|'['
number|'4'
op|':'
op|']'
op|']'
op|','
nl|'\n'
op|'['
string|"'g'"
op|','
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'g'"
op|']'
op|')'
op|'['
number|'4'
op|':'
op|']'
op|']'
op|','
nl|'\n'
op|'['
string|"'y'"
op|','
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'y'"
op|']'
op|')'
op|'['
number|'4'
op|':'
op|']'
op|']'
op|']'
op|']'
op|']'
op|')'
newline|'\n'
dedent|''
name|'return'
string|"'{'"
op|'+'
name|'base64'
op|'.'
name|'encodestring'
op|'('
name|'keyData'
op|')'
op|'.'
name|'replace'
op|'('
string|"'\\n'"
op|','
string|"''"
op|')'
op|'+'
string|"'}'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'type'
op|'('
op|')'
op|'=='
string|"'RSA'"
op|':'
newline|'\n'
indent|'                '
name|'p'
op|','
name|'q'
op|'='
name|'data'
op|'['
string|"'p'"
op|']'
op|','
name|'data'
op|'['
string|"'q'"
op|']'
newline|'\n'
name|'return'
name|'sexpy'
op|'.'
name|'pack'
op|'('
op|'['
op|'['
string|"'private-key'"
op|','
op|'['
string|"'rsa-pkcs1'"
op|','
nl|'\n'
op|'['
string|"'n'"
op|','
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'n'"
op|']'
op|')'
op|'['
number|'4'
op|':'
op|']'
op|']'
op|','
nl|'\n'
op|'['
string|"'e'"
op|','
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'e'"
op|']'
op|')'
op|'['
number|'4'
op|':'
op|']'
op|']'
op|','
nl|'\n'
op|'['
string|"'d'"
op|','
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'d'"
op|']'
op|')'
op|'['
number|'4'
op|':'
op|']'
op|']'
op|','
nl|'\n'
op|'['
string|"'p'"
op|','
name|'common'
op|'.'
name|'MP'
op|'('
name|'q'
op|')'
op|'['
number|'4'
op|':'
op|']'
op|']'
op|','
nl|'\n'
op|'['
string|"'q'"
op|','
name|'common'
op|'.'
name|'MP'
op|'('
name|'p'
op|')'
op|'['
number|'4'
op|':'
op|']'
op|']'
op|','
nl|'\n'
op|'['
string|"'a'"
op|','
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'d'"
op|']'
op|'%'
op|'('
name|'q'
op|'-'
number|'1'
op|')'
op|')'
op|'['
number|'4'
op|':'
op|']'
op|']'
op|','
nl|'\n'
op|'['
string|"'b'"
op|','
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'d'"
op|']'
op|'%'
op|'('
name|'p'
op|'-'
number|'1'
op|')'
op|')'
op|'['
number|'4'
op|':'
op|']'
op|']'
op|','
nl|'\n'
op|'['
string|"'c'"
op|','
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'u'"
op|']'
op|')'
op|'['
number|'4'
op|':'
op|']'
op|']'
op|']'
op|']'
op|']'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'type'
op|'('
op|')'
op|'=='
string|"'DSA'"
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'sexpy'
op|'.'
name|'pack'
op|'('
op|'['
op|'['
string|"'private-key'"
op|','
op|'['
string|"'dsa'"
op|','
nl|'\n'
op|'['
string|"'p'"
op|','
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'p'"
op|']'
op|')'
op|'['
number|'4'
op|':'
op|']'
op|']'
op|','
nl|'\n'
op|'['
string|"'q'"
op|','
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'q'"
op|']'
op|')'
op|'['
number|'4'
op|':'
op|']'
op|']'
op|','
nl|'\n'
op|'['
string|"'g'"
op|','
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'g'"
op|']'
op|')'
op|'['
number|'4'
op|':'
op|']'
op|']'
op|','
nl|'\n'
op|'['
string|"'y'"
op|','
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'y'"
op|']'
op|')'
op|'['
number|'4'
op|':'
op|']'
op|']'
op|','
nl|'\n'
op|'['
string|"'x'"
op|','
name|'common'
op|'.'
name|'MP'
op|'('
name|'data'
op|'['
string|"'x'"
op|']'
op|')'
op|'['
number|'4'
op|':'
op|']'
op|']'
op|']'
op|']'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_toString_AGENTV3
dedent|''
dedent|''
dedent|''
name|'def'
name|'_toString_AGENTV3'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a private Secure Shell Agent v3 key.  See\n        _fromString_AGENTV3 for the key format.\n\n        @rtype: C{str}\n        """'
newline|'\n'
name|'data'
op|'='
name|'self'
op|'.'
name|'data'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'isPublic'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'type'
op|'('
op|')'
op|'=='
string|"'RSA'"
op|':'
newline|'\n'
indent|'                '
name|'values'
op|'='
op|'('
name|'data'
op|'['
string|"'e'"
op|']'
op|','
name|'data'
op|'['
string|"'d'"
op|']'
op|','
name|'data'
op|'['
string|"'n'"
op|']'
op|','
name|'data'
op|'['
string|"'u'"
op|']'
op|','
nl|'\n'
name|'data'
op|'['
string|"'p'"
op|']'
op|','
name|'data'
op|'['
string|"'q'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'type'
op|'('
op|')'
op|'=='
string|"'DSA'"
op|':'
newline|'\n'
indent|'                '
name|'values'
op|'='
op|'('
name|'data'
op|'['
string|"'p'"
op|']'
op|','
name|'data'
op|'['
string|"'q'"
op|']'
op|','
name|'data'
op|'['
string|"'g'"
op|']'
op|','
name|'data'
op|'['
string|"'y'"
op|']'
op|','
nl|'\n'
name|'data'
op|'['
string|"'x'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'common'
op|'.'
name|'NS'
op|'('
name|'self'
op|'.'
name|'sshType'
op|'('
op|')'
op|')'
op|'+'
string|"''"
op|'.'
name|'join'
op|'('
name|'map'
op|'('
name|'common'
op|'.'
name|'MP'
op|','
name|'values'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|sign
dedent|''
dedent|''
name|'def'
name|'sign'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns a signature with this Key.\n\n        @type data: C{str}\n        @rtype: C{str}\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'type'
op|'('
op|')'
op|'=='
string|"'RSA'"
op|':'
newline|'\n'
indent|'            '
name|'digest'
op|'='
name|'pkcs1Digest'
op|'('
name|'data'
op|','
name|'self'
op|'.'
name|'keyObject'
op|'.'
name|'size'
op|'('
op|')'
op|'/'
number|'8'
op|')'
newline|'\n'
name|'signature'
op|'='
name|'self'
op|'.'
name|'keyObject'
op|'.'
name|'sign'
op|'('
name|'digest'
op|','
string|"''"
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'ret'
op|'='
name|'common'
op|'.'
name|'NS'
op|'('
name|'Util'
op|'.'
name|'number'
op|'.'
name|'long_to_bytes'
op|'('
name|'signature'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'type'
op|'('
op|')'
op|'=='
string|"'DSA'"
op|':'
newline|'\n'
indent|'            '
name|'digest'
op|'='
name|'sha1'
op|'('
name|'data'
op|')'
op|'.'
name|'digest'
op|'('
op|')'
newline|'\n'
name|'randomBytes'
op|'='
name|'randbytes'
op|'.'
name|'secureRandom'
op|'('
number|'19'
op|')'
newline|'\n'
name|'sig'
op|'='
name|'self'
op|'.'
name|'keyObject'
op|'.'
name|'sign'
op|'('
name|'digest'
op|','
name|'randomBytes'
op|')'
newline|'\n'
comment|'# SSH insists that the DSS signature blob be two 160-bit integers'
nl|'\n'
comment|'# concatenated together. The sig[0], [1] numbers from obj.sign'
nl|'\n'
comment|'# are just numbers, and could be any length from 0 to 160 bits.'
nl|'\n'
comment|'# Make sure they are padded out to 160 bits (20 bytes each)'
nl|'\n'
name|'ret'
op|'='
name|'common'
op|'.'
name|'NS'
op|'('
name|'Util'
op|'.'
name|'number'
op|'.'
name|'long_to_bytes'
op|'('
name|'sig'
op|'['
number|'0'
op|']'
op|','
number|'20'
op|')'
op|'+'
nl|'\n'
name|'Util'
op|'.'
name|'number'
op|'.'
name|'long_to_bytes'
op|'('
name|'sig'
op|'['
number|'1'
op|']'
op|','
number|'20'
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'common'
op|'.'
name|'NS'
op|'('
name|'self'
op|'.'
name|'sshType'
op|'('
op|')'
op|')'
op|'+'
name|'ret'
newline|'\n'
nl|'\n'
DECL|member|verify
dedent|''
name|'def'
name|'verify'
op|'('
name|'self'
op|','
name|'signature'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns true if the signature for data is valid for this Key.\n\n        @type signature: C{str}\n        @type data: C{str}\n        @rtype: C{bool}\n        """'
newline|'\n'
name|'signatureType'
op|','
name|'signature'
op|'='
name|'common'
op|'.'
name|'getNS'
op|'('
name|'signature'
op|')'
newline|'\n'
name|'if'
name|'signatureType'
op|'!='
name|'self'
op|'.'
name|'sshType'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'type'
op|'('
op|')'
op|'=='
string|"'RSA'"
op|':'
newline|'\n'
indent|'            '
name|'numbers'
op|'='
name|'common'
op|'.'
name|'getMP'
op|'('
name|'signature'
op|')'
newline|'\n'
name|'digest'
op|'='
name|'pkcs1Digest'
op|'('
name|'data'
op|','
name|'self'
op|'.'
name|'keyObject'
op|'.'
name|'size'
op|'('
op|')'
op|'/'
number|'8'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'type'
op|'('
op|')'
op|'=='
string|"'DSA'"
op|':'
newline|'\n'
indent|'            '
name|'signature'
op|'='
name|'common'
op|'.'
name|'getNS'
op|'('
name|'signature'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'numbers'
op|'='
op|'['
name|'Util'
op|'.'
name|'number'
op|'.'
name|'bytes_to_long'
op|'('
name|'n'
op|')'
name|'for'
name|'n'
name|'in'
name|'signature'
op|'['
op|':'
number|'20'
op|']'
op|','
nl|'\n'
name|'signature'
op|'['
number|'20'
op|':'
op|']'
op|']'
newline|'\n'
name|'digest'
op|'='
name|'sha1'
op|'('
name|'data'
op|')'
op|'.'
name|'digest'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'keyObject'
op|'.'
name|'verify'
op|'('
name|'digest'
op|','
name|'numbers'
op|')'
newline|'\n'
nl|'\n'
DECL|function|getPublicKeyString
dedent|''
dedent|''
name|'def'
name|'getPublicKeyString'
op|'('
name|'filename'
op|'='
name|'None'
op|','
name|'line'
op|'='
number|'0'
op|','
name|'data'
op|'='
string|"''"
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Return a public key string suitable for being sent over the wire.\n    Takes a filename or data of a public key.  Currently handles OpenSSH\n    and LSH keys.\n\n    This function has been deprecated since Twisted Conch 0.9.  Use\n    Key.fromString() instead.\n\n    @type filename: C{str}\n    @type line:     C{int}\n    @type data:     C{str}\n    @rtype:         C{str}\n    """'
newline|'\n'
name|'warnings'
op|'.'
name|'warn'
op|'('
string|'"getPublicKeyString is deprecated since Twisted Conch 0.9."'
nl|'\n'
string|'"  Use Key.fromString().blob()."'
op|','
nl|'\n'
name|'DeprecationWarning'
op|','
name|'stacklevel'
op|'='
number|'2'
op|')'
newline|'\n'
name|'if'
name|'filename'
name|'and'
name|'data'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'BadKeyError'
op|'('
string|'"either filename or data, not both"'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'filename'
op|':'
newline|'\n'
indent|'        '
name|'lines'
op|'='
name|'open'
op|'('
name|'filename'
op|')'
op|'.'
name|'readlines'
op|'('
op|')'
newline|'\n'
name|'data'
op|'='
name|'lines'
op|'['
name|'line'
op|']'
newline|'\n'
dedent|''
name|'return'
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'data'
op|')'
op|'.'
name|'blob'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|makePublicKeyString
dedent|''
name|'def'
name|'makePublicKeyString'
op|'('
name|'obj'
op|','
name|'comment'
op|'='
string|"''"
op|','
name|'kind'
op|'='
string|"'openssh'"
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Return an public key given a C{Crypto.PublicKey.pubkey.pubkey}\n    object.\n    kind is one of (\'openssh\', \'lsh\')\n\n    This function is deprecated since Twisted Conch 0.9.  Instead use\n    Key(obj).toString().\n\n    @type obj:      C{Crypto.PublicKey.pubkey.pubkey}\n    @type comment:  C{str}\n    @type kind:     C{str}\n    @rtype:         C{str}\n    """'
newline|'\n'
name|'warnings'
op|'.'
name|'warn'
op|'('
string|'"makePublicKeyString is deprecated since Twisted Conch 0.9."'
nl|'\n'
string|'"  Use Key(obj).public().toString()."'
op|','
nl|'\n'
name|'DeprecationWarning'
op|','
name|'stacklevel'
op|'='
number|'2'
op|')'
newline|'\n'
name|'return'
name|'Key'
op|'('
name|'obj'
op|')'
op|'.'
name|'public'
op|'('
op|')'
op|'.'
name|'toString'
op|'('
name|'kind'
op|','
name|'comment'
op|')'
newline|'\n'
nl|'\n'
DECL|function|getPublicKeyObject
dedent|''
name|'def'
name|'getPublicKeyObject'
op|'('
name|'data'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Return a C{Crypto.PublicKey.pubkey.pubkey} corresponding to the SSHv2\n    public key data.  data is in the over-the-wire public key format.\n\n    This function is deprecated since Twisted Conch 0.9. Instead, use\n    Key.fromString().\n\n    @type data:     C{str}\n    @rtype:         C{Crypto.PublicKey.pubkey.pubkey}\n    """'
newline|'\n'
name|'warnings'
op|'.'
name|'warn'
op|'('
string|'"getPublicKeyObject is deprecated since Twisted Conch 0.9."'
nl|'\n'
string|'"  Use Key.fromString()."'
op|','
nl|'\n'
name|'DeprecationWarning'
op|','
name|'stacklevel'
op|'='
number|'2'
op|')'
newline|'\n'
name|'return'
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'data'
op|')'
op|'.'
name|'keyObject'
newline|'\n'
nl|'\n'
DECL|function|getPrivateKeyObject
dedent|''
name|'def'
name|'getPrivateKeyObject'
op|'('
name|'filename'
op|'='
name|'None'
op|','
name|'data'
op|'='
string|"''"
op|','
name|'passphrase'
op|'='
string|"''"
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Return a C{Crypto.PublicKey.pubkey.pubkey} object corresponding to the\n    private key file/data.  If the private key is encrypted, passphrase B{must}\n    be specified, other wise a L{BadKeyError} will be raised.\n\n    This method is deprecated since Twisted Conch 0.9.  Instead, use\n    the fromString or fromFile classmethods of Key.\n\n    @type filename:     C{str}\n    @type data:         C{str}\n    @type passphrase:   C{str}\n    @rtype: C{Crypto.PublicKey.pubkey.pubkey}\n    @raises BadKeyError: if the key is invalid or a passphrase is not specified\n    """'
newline|'\n'
name|'warnings'
op|'.'
name|'warn'
op|'('
string|'"getPrivateKeyObject is deprecated since Twisted Conch 0.9."'
nl|'\n'
string|'"  Use Key.fromString()."'
op|','
nl|'\n'
name|'DeprecationWarning'
op|','
name|'stacklevel'
op|'='
number|'2'
op|')'
newline|'\n'
name|'if'
name|'filename'
name|'and'
name|'data'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'BadKeyError'
op|'('
string|'"either filename or data, not both"'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'filename'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'Key'
op|'.'
name|'fromFile'
op|'('
name|'filename'
op|','
name|'passphrase'
op|'='
name|'passphrase'
op|')'
op|'.'
name|'keyObject'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'data'
op|','
name|'passphrase'
op|'='
name|'passphrase'
op|')'
op|'.'
name|'keyObject'
newline|'\n'
nl|'\n'
DECL|function|makePrivateKeyString
dedent|''
dedent|''
name|'def'
name|'makePrivateKeyString'
op|'('
name|'obj'
op|','
name|'passphrase'
op|'='
name|'None'
op|','
name|'kind'
op|'='
string|"'openssh'"
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Return an OpenSSH-style private key for a\n    C{Crypto.PublicKey.pubkey.pubkey} object.  If passphrase is given, encrypt\n    the private key with it.\n    kind is one of (\'openssh\', \'lsh\', \'agentv3\')\n\n    This function is deprecated since Twisted Conch 0.9. Instead use\n    Key(obj).toString().\n\n    @type obj:          C{Crypto.PublicKey.pubkey.pubkey}\n    @type passphrase:   C{str}/C{None}\n    @type kind:         C{str}\n    @rtype:             C{str}\n    """'
newline|'\n'
name|'warnings'
op|'.'
name|'warn'
op|'('
string|'"makePrivateKeyString is deprecated since Twisted Conch 0.9."'
nl|'\n'
string|'"  Use Key(obj).toString()."'
op|','
nl|'\n'
name|'DeprecationWarning'
op|','
name|'stacklevel'
op|'='
number|'2'
op|')'
newline|'\n'
name|'return'
name|'Key'
op|'('
name|'obj'
op|')'
op|'.'
name|'toString'
op|'('
name|'kind'
op|','
name|'passphrase'
op|')'
newline|'\n'
nl|'\n'
DECL|function|makePublicKeyBlob
dedent|''
name|'def'
name|'makePublicKeyBlob'
op|'('
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Make a public key blob from a C{Crypto.PublicKey.pubkey.pubkey}.\n\n    This function is deprecated since Twisted Conch 0.9.  Use\n    Key().blob() instead.\n    """'
newline|'\n'
name|'warnings'
op|'.'
name|'warn'
op|'('
string|'"makePublicKeyBlob is deprecated since Twisted Conch 0.9."'
nl|'\n'
string|'"  Use Key(obj).blob()."'
op|','
nl|'\n'
name|'DeprecationWarning'
op|','
name|'stacklevel'
op|'='
number|'2'
op|')'
newline|'\n'
name|'return'
name|'Key'
op|'('
name|'obj'
op|')'
op|'.'
name|'blob'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|objectType
dedent|''
name|'def'
name|'objectType'
op|'('
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Return the SSH key type corresponding to a C{Crypto.PublicKey.pubkey.pubkey}\n    object.\n\n    @type obj:  C{Crypto.PublicKey.pubkey.pubkey}\n    @rtype:     C{str}\n    """'
newline|'\n'
name|'keyDataMapping'
op|'='
op|'{'
nl|'\n'
op|'('
string|"'n'"
op|','
string|"'e'"
op|','
string|"'d'"
op|','
string|"'p'"
op|','
string|"'q'"
op|')'
op|':'
string|"'ssh-rsa'"
op|','
nl|'\n'
op|'('
string|"'n'"
op|','
string|"'e'"
op|','
string|"'d'"
op|','
string|"'p'"
op|','
string|"'q'"
op|','
string|"'u'"
op|')'
op|':'
string|"'ssh-rsa'"
op|','
nl|'\n'
op|'('
string|"'y'"
op|','
string|"'g'"
op|','
string|"'p'"
op|','
string|"'q'"
op|','
string|"'x'"
op|')'
op|':'
string|"'ssh-dss'"
nl|'\n'
op|'}'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'keyDataMapping'
op|'['
name|'tuple'
op|'('
name|'obj'
op|'.'
name|'keydata'
op|')'
op|']'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'KeyError'
op|','
name|'AttributeError'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'BadKeyError'
op|'('
string|'"invalid key object"'
op|','
name|'obj'
op|')'
newline|'\n'
nl|'\n'
DECL|function|pkcs1Pad
dedent|''
dedent|''
name|'def'
name|'pkcs1Pad'
op|'('
name|'data'
op|','
name|'messageLength'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Pad out data to messageLength according to the PKCS#1 standard.\n    @type data: C{str}\n    @type messageLength: C{int}\n    """'
newline|'\n'
name|'lenPad'
op|'='
name|'messageLength'
op|'-'
number|'2'
op|'-'
name|'len'
op|'('
name|'data'
op|')'
newline|'\n'
name|'return'
string|"'\\x01'"
op|'+'
op|'('
string|"'\\xff'"
op|'*'
name|'lenPad'
op|')'
op|'+'
string|"'\\x00'"
op|'+'
name|'data'
newline|'\n'
nl|'\n'
DECL|function|pkcs1Digest
dedent|''
name|'def'
name|'pkcs1Digest'
op|'('
name|'data'
op|','
name|'messageLength'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Create a message digest using the SHA1 hash algorithm according to the\n    PKCS#1 standard.\n    @type data: C{str}\n    @type messageLength: C{str}\n    """'
newline|'\n'
name|'digest'
op|'='
name|'sha1'
op|'('
name|'data'
op|')'
op|'.'
name|'digest'
op|'('
op|')'
newline|'\n'
name|'return'
name|'pkcs1Pad'
op|'('
name|'ID_SHA1'
op|'+'
name|'digest'
op|','
name|'messageLength'
op|')'
newline|'\n'
nl|'\n'
DECL|function|lenSig
dedent|''
name|'def'
name|'lenSig'
op|'('
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Return the length of the signature in bytes for a key object.\n\n    @type obj: C{Crypto.PublicKey.pubkey.pubkey}\n    @rtype: C{long}\n    """'
newline|'\n'
name|'return'
name|'obj'
op|'.'
name|'size'
op|'('
op|')'
op|'/'
number|'8'
newline|'\n'
nl|'\n'
DECL|function|signData
dedent|''
name|'def'
name|'signData'
op|'('
name|'obj'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Sign the data with the given C{Crypto.PublicKey.pubkey.pubkey} object.\n\n    This method is deprecated since Twisted Conch 0.9.  Instead use\n    Key().sign().\n\n    @type obj:  C{Crypto.PublicKey.pubkey.pubkey}\n    @type data: C{str}\n    @rtype:     C{str}\n    """'
newline|'\n'
name|'warnings'
op|'.'
name|'warn'
op|'('
string|'"signData is deprecated since Twisted Conch 0.9."'
nl|'\n'
string|'"  Use Key(obj).sign(data)."'
op|','
nl|'\n'
name|'DeprecationWarning'
op|','
name|'stacklevel'
op|'='
number|'2'
op|')'
newline|'\n'
name|'return'
name|'Key'
op|'('
name|'obj'
op|')'
op|'.'
name|'sign'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
DECL|function|verifySignature
dedent|''
name|'def'
name|'verifySignature'
op|'('
name|'obj'
op|','
name|'sig'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Verify that the signature for the data is valid.\n\n    This method is deprecated since Twisted Conch 0.9.  Use\n    Key().verify().\n\n    @type obj:  C{Crypto.PublicKey.pubkey.pubkey}\n    @type sig:  C{str}\n    @type data: C{str}\n    @rtype:     C{bool}\n    """'
newline|'\n'
name|'warnings'
op|'.'
name|'warn'
op|'('
string|'"verifySignature is deprecated since Twisted Conch 0.9."'
nl|'\n'
string|'"  Use Key(obj).verify(signature, data)."'
op|','
nl|'\n'
name|'DeprecationWarning'
op|','
name|'stacklevel'
op|'='
number|'2'
op|')'
newline|'\n'
name|'return'
name|'Key'
op|'('
name|'obj'
op|')'
op|'.'
name|'verify'
op|'('
name|'sig'
op|','
name|'data'
op|')'
newline|'\n'
nl|'\n'
DECL|function|printKey
dedent|''
name|'def'
name|'printKey'
op|'('
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Pretty print a C{Crypto.PublicKey.pubkey.pubkey} object.\n\n    This function is deprecated since Twisted Conch 0.9.  Use\n    repr(Key()).\n\n    @type obj: C{Crypto.PublicKey.pubkey.pubkey}\n    """'
newline|'\n'
name|'warnings'
op|'.'
name|'warn'
op|'('
string|'"printKey is deprecated since Twisted Conch 0.9."'
nl|'\n'
string|'"  Use repr(Key(obj))."'
op|','
nl|'\n'
name|'DeprecationWarning'
op|','
name|'stacklevel'
op|'='
number|'2'
op|')'
newline|'\n'
name|'return'
name|'repr'
op|'('
name|'Key'
op|'('
name|'obj'
op|')'
op|')'
op|'['
number|'1'
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
nl|'\n'
DECL|variable|ID_SHA1
dedent|''
name|'ID_SHA1'
op|'='
string|"'\\x30\\x21\\x30\\x09\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\\x05\\x00\\x04\\x14'"
newline|'\n'
endmarker|''
end_unit
