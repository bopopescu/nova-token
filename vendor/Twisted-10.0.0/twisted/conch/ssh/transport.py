begin_unit
comment|'# -*- test-case-name: twisted.conch.test.test_transport -*-'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Copyright (c) 2001-2008 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nThe lowest level SSH protocol.  This handles the key negotiation, the\nencryption and the compression.  The transport layer is described in\nRFC 4253.\n\nMaintainer: Paul Swartz\n"""'
newline|'\n'
nl|'\n'
comment|'# base library imports'
nl|'\n'
name|'import'
name|'struct'
newline|'\n'
name|'import'
name|'zlib'
newline|'\n'
name|'import'
name|'array'
newline|'\n'
nl|'\n'
comment|'# external library imports'
nl|'\n'
name|'from'
name|'Crypto'
name|'import'
name|'Util'
newline|'\n'
name|'from'
name|'Crypto'
op|'.'
name|'Cipher'
name|'import'
name|'XOR'
newline|'\n'
nl|'\n'
comment|'# twisted imports'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'protocol'
op|','
name|'defer'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'conch'
name|'import'
name|'error'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'log'
op|','
name|'randbytes'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'hashlib'
name|'import'
name|'md5'
op|','
name|'sha1'
newline|'\n'
nl|'\n'
comment|'# sibling imports'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'conch'
op|'.'
name|'ssh'
name|'import'
name|'keys'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'conch'
op|'.'
name|'ssh'
op|'.'
name|'common'
name|'import'
name|'NS'
op|','
name|'getNS'
op|','
name|'MP'
op|','
name|'getMP'
op|','
name|'_MPpow'
op|','
name|'ffs'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|SSHTransportBase
name|'class'
name|'SSHTransportBase'
op|'('
name|'protocol'
op|'.'
name|'Protocol'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Protocol supporting basic SSH functionality: sending/receiving packets\n    and message dispatch.  To connect to or run a server, you must use\n    SSHClientTransport or SSHServerTransport.\n\n    @ivar protocolVersion: A string representing the version of the SSH\n        protocol we support.  Currently defaults to \'2.0\'.\n\n    @ivar version: A string representing the version of the server or client.\n        Currently defaults to \'Twisted\'.\n\n    @ivar comment: An optional string giving more information about the\n        server or client.\n\n    @ivar supportedCiphers: A list of strings representing the encryption\n        algorithms supported, in order from most-preferred to least.\n\n    @ivar supportedMACs: A list of strings representing the message\n        authentication codes (hashes) supported, in order from most-preferred\n        to least.  Both this and supportedCiphers can include \'none\' to use\n        no encryption or authentication, but that must be done manually,\n\n    @ivar supportedKeyExchanges: A list of strings representing the\n        key exchanges supported, in order from most-preferred to least.\n\n    @ivar supportedPublicKeys:  A list of strings representing the\n        public key types supported, in order from most-preferred to least.\n\n    @ivar supportedCompressions: A list of strings representing compression\n        types supported, from most-preferred to least.\n\n    @ivar supportedLanguages: A list of strings representing languages\n        supported, from most-preferred to least.\n\n    @ivar isClient: A boolean indicating whether this is a client or server.\n\n    @ivar gotVersion: A boolean indicating whether we have receieved the\n        version string from the other side.\n\n    @ivar buf: Data we\'ve received but hasn\'t been parsed into a packet.\n\n    @ivar outgoingPacketSequence: the sequence number of the next packet we\n        will send.\n\n    @ivar incomingPacketSequence: the sequence number of the next packet we\n        are expecting from the other side.\n\n    @ivar outgoingCompression: an object supporting the .compress(str) and\n        .flush() methods, or None if there is no outgoing compression.  Used to\n        compress outgoing data.\n\n    @ivar outgoingCompressionType: A string representing the outgoing\n        compression type.\n\n    @ivar incomingCompression: an object supporting the .decompress(str)\n        method, or None if there is no incoming compression.  Used to\n        decompress incoming data.\n\n    @ivar incomingCompressionType: A string representing the incoming\n        compression type.\n\n    @ivar ourVersionString: the version string that we sent to the other side.\n        Used in the key exchange.\n\n    @ivar otherVersionString: the version string sent by the other side.  Used\n        in the key exchange.\n\n    @ivar ourKexInitPayload: the MSG_KEXINIT payload we sent.  Used in the key\n        exchange.\n\n    @ivar otherKexInitPayload: the MSG_KEXINIT payload we received.  Used in\n        the key exchange\n\n    @ivar sessionID: a string that is unique to this SSH session.  Created as\n        part of the key exchange, sessionID is used to generate the various\n        encryption and authentication keys.\n\n    @ivar service: an SSHService instance, or None.  If it\'s set to an object,\n        it\'s the currently running service.\n\n    @ivar kexAlg: the agreed-upon key exchange algorithm.\n\n    @ivar keyAlg: the agreed-upon public key type for the key exchange.\n\n    @ivar currentEncryptions: an SSHCiphers instance.  It represents the\n        current encryption and authentication options for the transport.\n\n    @ivar nextEncryptions: an SSHCiphers instance.  Held here until the\n        MSG_NEWKEYS messages are exchanged, when nextEncryptions is\n        transitioned to currentEncryptions.\n\n    @ivar first: the first bytes of the next packet.  In order to avoid\n        decrypting data twice, the first bytes are decrypted and stored until\n        the whole packet is available.\n\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|protocolVersion
name|'protocolVersion'
op|'='
string|"'2.0'"
newline|'\n'
DECL|variable|version
name|'version'
op|'='
string|"'Twisted'"
newline|'\n'
DECL|variable|comment
name|'comment'
op|'='
string|"''"
newline|'\n'
DECL|variable|ourVersionString
name|'ourVersionString'
op|'='
op|'('
string|"'SSH-'"
op|'+'
name|'protocolVersion'
op|'+'
string|"'-'"
op|'+'
name|'version'
op|'+'
string|"' '"
nl|'\n'
op|'+'
name|'comment'
op|')'
op|'.'
name|'strip'
op|'('
op|')'
newline|'\n'
DECL|variable|supportedCiphers
name|'supportedCiphers'
op|'='
op|'['
string|"'aes256-ctr'"
op|','
string|"'aes256-cbc'"
op|','
string|"'aes192-ctr'"
op|','
string|"'aes192-cbc'"
op|','
nl|'\n'
string|"'aes128-ctr'"
op|','
string|"'aes128-cbc'"
op|','
string|"'cast128-ctr'"
op|','
nl|'\n'
string|"'cast128-cbc'"
op|','
string|"'blowfish-ctr'"
op|','
string|"'blowfish-cbc'"
op|','
nl|'\n'
string|"'3des-ctr'"
op|','
string|"'3des-cbc'"
op|']'
comment|"# ,'none']"
newline|'\n'
DECL|variable|supportedMACs
name|'supportedMACs'
op|'='
op|'['
string|"'hmac-sha1'"
op|','
string|"'hmac-md5'"
op|']'
comment|"# , 'none']"
newline|'\n'
comment|"# both of the above support 'none', but for security are disabled by"
nl|'\n'
comment|'# default.  to enable them, subclass this class and add it, or do:'
nl|'\n'
comment|"#   SSHTransportBase.supportedCiphers.append('none')"
nl|'\n'
DECL|variable|supportedKeyExchanges
name|'supportedKeyExchanges'
op|'='
op|'['
string|"'diffie-hellman-group-exchange-sha1'"
op|','
nl|'\n'
string|"'diffie-hellman-group1-sha1'"
op|']'
newline|'\n'
DECL|variable|supportedPublicKeys
name|'supportedPublicKeys'
op|'='
op|'['
string|"'ssh-rsa'"
op|','
string|"'ssh-dss'"
op|']'
newline|'\n'
DECL|variable|supportedCompressions
name|'supportedCompressions'
op|'='
op|'['
string|"'none'"
op|','
string|"'zlib'"
op|']'
newline|'\n'
DECL|variable|supportedLanguages
name|'supportedLanguages'
op|'='
op|'('
op|')'
newline|'\n'
DECL|variable|isClient
name|'isClient'
op|'='
name|'False'
newline|'\n'
DECL|variable|gotVersion
name|'gotVersion'
op|'='
name|'False'
newline|'\n'
DECL|variable|buf
name|'buf'
op|'='
string|"''"
newline|'\n'
DECL|variable|outgoingPacketSequence
name|'outgoingPacketSequence'
op|'='
number|'0'
newline|'\n'
DECL|variable|incomingPacketSequence
name|'incomingPacketSequence'
op|'='
number|'0'
newline|'\n'
DECL|variable|outgoingCompression
name|'outgoingCompression'
op|'='
name|'None'
newline|'\n'
DECL|variable|incomingCompression
name|'incomingCompression'
op|'='
name|'None'
newline|'\n'
DECL|variable|sessionID
name|'sessionID'
op|'='
name|'None'
newline|'\n'
DECL|variable|service
name|'service'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionLost
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'service'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'service'
op|'.'
name|'serviceStopped'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'hasattr'
op|'('
name|'self'
op|','
string|"'avatar'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'logoutFunction'
op|'('
op|')'
newline|'\n'
dedent|''
name|'log'
op|'.'
name|'msg'
op|'('
string|"'connection lost'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionMade
dedent|''
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when the connection is made to the other side.  We sent our\n        version and the MSG_KEXINIT packet.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
string|"'%s\\r\\n'"
op|'%'
op|'('
name|'self'
op|'.'
name|'ourVersionString'
op|','
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'currentEncryptions'
op|'='
name|'SSHCiphers'
op|'('
string|"'none'"
op|','
string|"'none'"
op|','
string|"'none'"
op|','
string|"'none'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'currentEncryptions'
op|'.'
name|'setKeys'
op|'('
string|"''"
op|','
string|"''"
op|','
string|"''"
op|','
string|"''"
op|','
string|"''"
op|','
string|"''"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'sendKexInit'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|sendKexInit
dedent|''
name|'def'
name|'sendKexInit'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'ourKexInitPayload'
op|'='
op|'('
name|'chr'
op|'('
name|'MSG_KEXINIT'
op|')'
op|'+'
nl|'\n'
name|'randbytes'
op|'.'
name|'secureRandom'
op|'('
number|'16'
op|')'
op|'+'
nl|'\n'
name|'NS'
op|'('
string|"','"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'supportedKeyExchanges'
op|')'
op|')'
op|'+'
nl|'\n'
name|'NS'
op|'('
string|"','"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'supportedPublicKeys'
op|')'
op|')'
op|'+'
nl|'\n'
name|'NS'
op|'('
string|"','"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'supportedCiphers'
op|')'
op|')'
op|'+'
nl|'\n'
name|'NS'
op|'('
string|"','"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'supportedCiphers'
op|')'
op|')'
op|'+'
nl|'\n'
name|'NS'
op|'('
string|"','"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'supportedMACs'
op|')'
op|')'
op|'+'
nl|'\n'
name|'NS'
op|'('
string|"','"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'supportedMACs'
op|')'
op|')'
op|'+'
nl|'\n'
name|'NS'
op|'('
string|"','"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'supportedCompressions'
op|')'
op|')'
op|'+'
nl|'\n'
name|'NS'
op|'('
string|"','"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'supportedCompressions'
op|')'
op|')'
op|'+'
nl|'\n'
name|'NS'
op|'('
string|"','"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'supportedLanguages'
op|')'
op|')'
op|'+'
nl|'\n'
name|'NS'
op|'('
string|"','"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'supportedLanguages'
op|')'
op|')'
op|'+'
nl|'\n'
string|"'\\000'"
op|'+'
string|"'\\000\\000\\000\\000'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'sendPacket'
op|'('
name|'MSG_KEXINIT'
op|','
name|'self'
op|'.'
name|'ourKexInitPayload'
op|'['
number|'1'
op|':'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|sendPacket
dedent|''
name|'def'
name|'sendPacket'
op|'('
name|'self'
op|','
name|'messageType'
op|','
name|'payload'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Sends a packet.  If it\'s been set up, compress the data, encrypt it,\n        and authenticate it before sending.\n\n        @param messageType: The type of the packet; generally one of the\n                            MSG_* values.\n        @type messageType: C{int}\n        @param payload: The payload for the message.\n        @type payload: C{str}\n        """'
newline|'\n'
name|'payload'
op|'='
name|'chr'
op|'('
name|'messageType'
op|')'
op|'+'
name|'payload'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'outgoingCompression'
op|':'
newline|'\n'
indent|'            '
name|'payload'
op|'='
op|'('
name|'self'
op|'.'
name|'outgoingCompression'
op|'.'
name|'compress'
op|'('
name|'payload'
op|')'
nl|'\n'
op|'+'
name|'self'
op|'.'
name|'outgoingCompression'
op|'.'
name|'flush'
op|'('
number|'2'
op|')'
op|')'
newline|'\n'
dedent|''
name|'bs'
op|'='
name|'self'
op|'.'
name|'currentEncryptions'
op|'.'
name|'encBlockSize'
newline|'\n'
comment|'# 4 for the packet length and 1 for the padding length'
nl|'\n'
name|'totalSize'
op|'='
number|'5'
op|'+'
name|'len'
op|'('
name|'payload'
op|')'
newline|'\n'
name|'lenPad'
op|'='
name|'bs'
op|'-'
op|'('
name|'totalSize'
op|'%'
name|'bs'
op|')'
newline|'\n'
name|'if'
name|'lenPad'
op|'<'
number|'4'
op|':'
newline|'\n'
indent|'            '
name|'lenPad'
op|'='
name|'lenPad'
op|'+'
name|'bs'
newline|'\n'
dedent|''
name|'packet'
op|'='
op|'('
name|'struct'
op|'.'
name|'pack'
op|'('
string|"'!LB'"
op|','
nl|'\n'
name|'totalSize'
op|'+'
name|'lenPad'
op|'-'
number|'4'
op|','
name|'lenPad'
op|')'
op|'+'
nl|'\n'
name|'payload'
op|'+'
name|'randbytes'
op|'.'
name|'secureRandom'
op|'('
name|'lenPad'
op|')'
op|')'
newline|'\n'
name|'encPacket'
op|'='
op|'('
nl|'\n'
name|'self'
op|'.'
name|'currentEncryptions'
op|'.'
name|'encrypt'
op|'('
name|'packet'
op|')'
op|'+'
nl|'\n'
name|'self'
op|'.'
name|'currentEncryptions'
op|'.'
name|'makeMAC'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'outgoingPacketSequence'
op|','
name|'packet'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
name|'encPacket'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'outgoingPacketSequence'
op|'+='
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getPacket
dedent|''
name|'def'
name|'getPacket'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Try to return a decrypted, authenticated, and decompressed packet\n        out of the buffer.  If there is not enough data, return None.\n\n        @rtype: C{str}/C{None}\n        """'
newline|'\n'
name|'bs'
op|'='
name|'self'
op|'.'
name|'currentEncryptions'
op|'.'
name|'decBlockSize'
newline|'\n'
name|'ms'
op|'='
name|'self'
op|'.'
name|'currentEncryptions'
op|'.'
name|'verifyDigestSize'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'self'
op|'.'
name|'buf'
op|')'
op|'<'
name|'bs'
op|':'
name|'return'
comment|'# not enough data'
newline|'\n'
name|'if'
name|'not'
name|'hasattr'
op|'('
name|'self'
op|','
string|"'first'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'first'
op|'='
name|'self'
op|'.'
name|'currentEncryptions'
op|'.'
name|'decrypt'
op|'('
name|'self'
op|'.'
name|'buf'
op|'['
op|':'
name|'bs'
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'first'
op|'='
name|'self'
op|'.'
name|'first'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'first'
newline|'\n'
dedent|''
name|'packetLen'
op|','
name|'paddingLen'
op|'='
name|'struct'
op|'.'
name|'unpack'
op|'('
string|"'!LB'"
op|','
name|'first'
op|'['
op|':'
number|'5'
op|']'
op|')'
newline|'\n'
name|'if'
name|'packetLen'
op|'>'
number|'1048576'
op|':'
comment|'# 1024 ** 2'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sendDisconnect'
op|'('
name|'DISCONNECT_PROTOCOL_ERROR'
op|','
nl|'\n'
string|"'bad packet length %s'"
op|'%'
name|'packetLen'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'if'
name|'len'
op|'('
name|'self'
op|'.'
name|'buf'
op|')'
op|'<'
name|'packetLen'
op|'+'
number|'4'
op|'+'
name|'ms'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'first'
op|'='
name|'first'
newline|'\n'
name|'return'
comment|'# not enough packet'
newline|'\n'
dedent|''
name|'if'
op|'('
name|'packetLen'
op|'+'
number|'4'
op|')'
op|'%'
name|'bs'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sendDisconnect'
op|'('
nl|'\n'
name|'DISCONNECT_PROTOCOL_ERROR'
op|','
nl|'\n'
string|"'bad packet mod (%i%%%i == %i)'"
op|'%'
op|'('
name|'packetLen'
op|'+'
number|'4'
op|','
name|'bs'
op|','
nl|'\n'
op|'('
name|'packetLen'
op|'+'
number|'4'
op|')'
op|'%'
name|'bs'
op|')'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'encData'
op|','
name|'self'
op|'.'
name|'buf'
op|'='
name|'self'
op|'.'
name|'buf'
op|'['
op|':'
number|'4'
op|'+'
name|'packetLen'
op|']'
op|','
name|'self'
op|'.'
name|'buf'
op|'['
number|'4'
op|'+'
name|'packetLen'
op|':'
op|']'
newline|'\n'
name|'packet'
op|'='
name|'first'
op|'+'
name|'self'
op|'.'
name|'currentEncryptions'
op|'.'
name|'decrypt'
op|'('
name|'encData'
op|'['
name|'bs'
op|':'
op|']'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'packet'
op|')'
op|'!='
number|'4'
op|'+'
name|'packetLen'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sendDisconnect'
op|'('
name|'DISCONNECT_PROTOCOL_ERROR'
op|','
nl|'\n'
string|"'bad decryption'"
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'if'
name|'ms'
op|':'
newline|'\n'
indent|'            '
name|'macData'
op|','
name|'self'
op|'.'
name|'buf'
op|'='
name|'self'
op|'.'
name|'buf'
op|'['
op|':'
name|'ms'
op|']'
op|','
name|'self'
op|'.'
name|'buf'
op|'['
name|'ms'
op|':'
op|']'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'currentEncryptions'
op|'.'
name|'verify'
op|'('
name|'self'
op|'.'
name|'incomingPacketSequence'
op|','
nl|'\n'
name|'packet'
op|','
name|'macData'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'sendDisconnect'
op|'('
name|'DISCONNECT_MAC_ERROR'
op|','
string|"'bad MAC'"
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
dedent|''
name|'payload'
op|'='
name|'packet'
op|'['
number|'5'
op|':'
op|'-'
name|'paddingLen'
op|']'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'incomingCompression'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'payload'
op|'='
name|'self'
op|'.'
name|'incomingCompression'
op|'.'
name|'decompress'
op|'('
name|'payload'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
comment|'# bare except, because who knows what kind of errors'
newline|'\n'
comment|'# decompression can raise'
nl|'\n'
indent|'                '
name|'log'
op|'.'
name|'err'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'sendDisconnect'
op|'('
name|'DISCONNECT_COMPRESSION_ERROR'
op|','
nl|'\n'
string|"'compression error'"
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'incomingPacketSequence'
op|'+='
number|'1'
newline|'\n'
name|'return'
name|'payload'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|dataReceived
dedent|''
name|'def'
name|'dataReceived'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        First, check for the version string (SSH-2.0-*).  After that has been\n        received, this method adds data to the buffer, and pulls out any\n        packets.\n\n        @type data: C{str}\n        """'
newline|'\n'
name|'self'
op|'.'
name|'buf'
op|'='
name|'self'
op|'.'
name|'buf'
op|'+'
name|'data'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'gotVersion'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'buf'
op|'.'
name|'find'
op|'('
string|"'\\n'"
op|','
name|'self'
op|'.'
name|'buf'
op|'.'
name|'find'
op|'('
string|"'SSH-'"
op|')'
op|')'
op|'=='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'return'
newline|'\n'
dedent|''
name|'lines'
op|'='
name|'self'
op|'.'
name|'buf'
op|'.'
name|'split'
op|'('
string|"'\\n'"
op|')'
newline|'\n'
name|'for'
name|'p'
name|'in'
name|'lines'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'p'
op|'.'
name|'startswith'
op|'('
string|"'SSH-'"
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'gotVersion'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'otherVersionString'
op|'='
name|'p'
op|'.'
name|'strip'
op|'('
op|')'
newline|'\n'
name|'if'
name|'p'
op|'.'
name|'split'
op|'('
string|"'-'"
op|')'
op|'['
number|'1'
op|']'
name|'not'
name|'in'
op|'('
string|"'1.99'"
op|','
string|"'2.0'"
op|')'
op|':'
comment|'# bad version'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'sendDisconnect'
op|'('
nl|'\n'
name|'DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED'
op|','
nl|'\n'
string|"'bad version '"
op|'+'
name|'p'
op|'.'
name|'split'
op|'('
string|"'-'"
op|')'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'i'
op|'='
name|'lines'
op|'.'
name|'index'
op|'('
name|'p'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'buf'
op|'='
string|"'\\n'"
op|'.'
name|'join'
op|'('
name|'lines'
op|'['
name|'i'
op|'+'
number|'1'
op|':'
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'packet'
op|'='
name|'self'
op|'.'
name|'getPacket'
op|'('
op|')'
newline|'\n'
name|'while'
name|'packet'
op|':'
newline|'\n'
indent|'            '
name|'messageNum'
op|'='
name|'ord'
op|'('
name|'packet'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'dispatchMessage'
op|'('
name|'messageNum'
op|','
name|'packet'
op|'['
number|'1'
op|':'
op|']'
op|')'
newline|'\n'
name|'packet'
op|'='
name|'self'
op|'.'
name|'getPacket'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|dispatchMessage
dedent|''
dedent|''
name|'def'
name|'dispatchMessage'
op|'('
name|'self'
op|','
name|'messageNum'
op|','
name|'payload'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send a received message to the appropriate method.\n\n        @type messageNum: C{int}\n        @type payload: c{str}\n        """'
newline|'\n'
name|'if'
name|'messageNum'
op|'<'
number|'50'
name|'and'
name|'messageNum'
name|'in'
name|'messages'
op|':'
newline|'\n'
indent|'            '
name|'messageType'
op|'='
name|'messages'
op|'['
name|'messageNum'
op|']'
op|'['
number|'4'
op|':'
op|']'
newline|'\n'
name|'f'
op|'='
name|'getattr'
op|'('
name|'self'
op|','
string|"'ssh_%s'"
op|'%'
name|'messageType'
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'f'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'f'
op|'('
name|'payload'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'log'
op|'.'
name|'msg'
op|'('
string|'"couldn\'t handle %s"'
op|'%'
name|'messageType'
op|')'
newline|'\n'
name|'log'
op|'.'
name|'msg'
op|'('
name|'repr'
op|'('
name|'payload'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'sendUnimplemented'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'self'
op|'.'
name|'service'
op|':'
newline|'\n'
indent|'            '
name|'log'
op|'.'
name|'callWithLogger'
op|'('
name|'self'
op|'.'
name|'service'
op|','
name|'self'
op|'.'
name|'service'
op|'.'
name|'packetReceived'
op|','
nl|'\n'
name|'messageNum'
op|','
name|'payload'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'log'
op|'.'
name|'msg'
op|'('
string|'"couldn\'t handle %s"'
op|'%'
name|'messageNum'
op|')'
newline|'\n'
name|'log'
op|'.'
name|'msg'
op|'('
name|'repr'
op|'('
name|'payload'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'sendUnimplemented'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|ssh_KEXINIT
dedent|''
dedent|''
name|'def'
name|'ssh_KEXINIT'
op|'('
name|'self'
op|','
name|'packet'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when we receive a MSG_KEXINIT message.  Payload::\n            bytes[16] cookie\n            string keyExchangeAlgorithms\n            string keyAlgorithms\n            string incomingEncryptions\n            string outgoingEncryptions\n            string incomingAuthentications\n            string outgoingAuthentications\n            string incomingCompressions\n            string outgoingCompressions\n            string incomingLanguages\n            string outgoingLanguages\n            bool firstPacketFollows\n            unit32 0 (reserved)\n\n        Starts setting up the key exchange, keys, encryptions, and\n        authentications.  Extended by ssh_KEXINIT in SSHServerTransport and\n        SSHClientTransport.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'otherKexInitPayload'
op|'='
name|'chr'
op|'('
name|'MSG_KEXINIT'
op|')'
op|'+'
name|'packet'
newline|'\n'
comment|'#cookie = packet[: 16] # taking this is useless'
nl|'\n'
name|'k'
op|'='
name|'getNS'
op|'('
name|'packet'
op|'['
number|'16'
op|':'
op|']'
op|','
number|'10'
op|')'
newline|'\n'
name|'strings'
op|','
name|'rest'
op|'='
name|'k'
op|'['
op|':'
op|'-'
number|'1'
op|']'
op|','
name|'k'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
op|'('
name|'kexAlgs'
op|','
name|'keyAlgs'
op|','
name|'encCS'
op|','
name|'encSC'
op|','
name|'macCS'
op|','
name|'macSC'
op|','
name|'compCS'
op|','
name|'compSC'
op|','
name|'langCS'
op|','
nl|'\n'
name|'langSC'
op|')'
op|'='
op|'['
name|'s'
op|'.'
name|'split'
op|'('
string|"','"
op|')'
name|'for'
name|'s'
name|'in'
name|'strings'
op|']'
newline|'\n'
comment|'# these are the server directions'
nl|'\n'
name|'outs'
op|'='
op|'['
name|'encSC'
op|','
name|'macSC'
op|','
name|'compSC'
op|']'
newline|'\n'
name|'ins'
op|'='
op|'['
name|'encCS'
op|','
name|'macSC'
op|','
name|'compCS'
op|']'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'isClient'
op|':'
newline|'\n'
indent|'            '
name|'outs'
op|','
name|'ins'
op|'='
name|'ins'
op|','
name|'outs'
comment|'# switch directions'
newline|'\n'
dedent|''
name|'server'
op|'='
op|'('
name|'self'
op|'.'
name|'supportedKeyExchanges'
op|','
name|'self'
op|'.'
name|'supportedPublicKeys'
op|','
nl|'\n'
name|'self'
op|'.'
name|'supportedCiphers'
op|','
name|'self'
op|'.'
name|'supportedCiphers'
op|','
nl|'\n'
name|'self'
op|'.'
name|'supportedMACs'
op|','
name|'self'
op|'.'
name|'supportedMACs'
op|','
nl|'\n'
name|'self'
op|'.'
name|'supportedCompressions'
op|','
name|'self'
op|'.'
name|'supportedCompressions'
op|')'
newline|'\n'
name|'client'
op|'='
op|'('
name|'kexAlgs'
op|','
name|'keyAlgs'
op|','
name|'outs'
op|'['
number|'0'
op|']'
op|','
name|'ins'
op|'['
number|'0'
op|']'
op|','
name|'outs'
op|'['
number|'1'
op|']'
op|','
name|'ins'
op|'['
number|'1'
op|']'
op|','
nl|'\n'
name|'outs'
op|'['
number|'2'
op|']'
op|','
name|'ins'
op|'['
number|'2'
op|']'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'isClient'
op|':'
newline|'\n'
indent|'            '
name|'server'
op|','
name|'client'
op|'='
name|'client'
op|','
name|'server'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'kexAlg'
op|'='
name|'ffs'
op|'('
name|'client'
op|'['
number|'0'
op|']'
op|','
name|'server'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'keyAlg'
op|'='
name|'ffs'
op|'('
name|'client'
op|'['
number|'1'
op|']'
op|','
name|'server'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'nextEncryptions'
op|'='
name|'SSHCiphers'
op|'('
nl|'\n'
name|'ffs'
op|'('
name|'client'
op|'['
number|'2'
op|']'
op|','
name|'server'
op|'['
number|'2'
op|']'
op|')'
op|','
nl|'\n'
name|'ffs'
op|'('
name|'client'
op|'['
number|'3'
op|']'
op|','
name|'server'
op|'['
number|'3'
op|']'
op|')'
op|','
nl|'\n'
name|'ffs'
op|'('
name|'client'
op|'['
number|'4'
op|']'
op|','
name|'server'
op|'['
number|'4'
op|']'
op|')'
op|','
nl|'\n'
name|'ffs'
op|'('
name|'client'
op|'['
number|'5'
op|']'
op|','
name|'server'
op|'['
number|'5'
op|']'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'outgoingCompressionType'
op|'='
name|'ffs'
op|'('
name|'client'
op|'['
number|'6'
op|']'
op|','
name|'server'
op|'['
number|'6'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'incomingCompressionType'
op|'='
name|'ffs'
op|'('
name|'client'
op|'['
number|'7'
op|']'
op|','
name|'server'
op|'['
number|'7'
op|']'
op|')'
newline|'\n'
name|'if'
name|'None'
name|'in'
op|'('
name|'self'
op|'.'
name|'kexAlg'
op|','
name|'self'
op|'.'
name|'keyAlg'
op|','
name|'self'
op|'.'
name|'outgoingCompressionType'
op|','
nl|'\n'
name|'self'
op|'.'
name|'incomingCompressionType'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sendDisconnect'
op|'('
name|'DISCONNECT_KEY_EXCHANGE_FAILED'
op|','
nl|'\n'
string|'"couldn\'t match all kex parts"'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'if'
name|'None'
name|'in'
name|'self'
op|'.'
name|'nextEncryptions'
op|'.'
name|'__dict__'
op|'.'
name|'values'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sendDisconnect'
op|'('
name|'DISCONNECT_KEY_EXCHANGE_FAILED'
op|','
nl|'\n'
string|'"couldn\'t match all kex parts"'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'log'
op|'.'
name|'msg'
op|'('
string|"'kex alg, key alg: %s %s'"
op|'%'
op|'('
name|'self'
op|'.'
name|'kexAlg'
op|','
name|'self'
op|'.'
name|'keyAlg'
op|')'
op|')'
newline|'\n'
name|'log'
op|'.'
name|'msg'
op|'('
string|"'outgoing: %s %s %s'"
op|'%'
op|'('
name|'self'
op|'.'
name|'nextEncryptions'
op|'.'
name|'outCipType'
op|','
nl|'\n'
name|'self'
op|'.'
name|'nextEncryptions'
op|'.'
name|'outMACType'
op|','
nl|'\n'
name|'self'
op|'.'
name|'outgoingCompressionType'
op|')'
op|')'
newline|'\n'
name|'log'
op|'.'
name|'msg'
op|'('
string|"'incoming: %s %s %s'"
op|'%'
op|'('
name|'self'
op|'.'
name|'nextEncryptions'
op|'.'
name|'inCipType'
op|','
nl|'\n'
name|'self'
op|'.'
name|'nextEncryptions'
op|'.'
name|'inMACType'
op|','
nl|'\n'
name|'self'
op|'.'
name|'incomingCompressionType'
op|')'
op|')'
newline|'\n'
name|'return'
name|'kexAlgs'
op|','
name|'keyAlgs'
op|','
name|'rest'
comment|'# for SSHServerTransport to use'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|ssh_DISCONNECT
dedent|''
name|'def'
name|'ssh_DISCONNECT'
op|'('
name|'self'
op|','
name|'packet'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when we receive a MSG_DISCONNECT message.  Payload::\n            long code\n            string description\n\n        This means that the other side has disconnected.  Pass the message up\n        and disconnect ourselves.\n        """'
newline|'\n'
name|'reasonCode'
op|'='
name|'struct'
op|'.'
name|'unpack'
op|'('
string|"'>L'"
op|','
name|'packet'
op|'['
op|':'
number|'4'
op|']'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'description'
op|','
name|'foo'
op|'='
name|'getNS'
op|'('
name|'packet'
op|'['
number|'4'
op|':'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'receiveError'
op|'('
name|'reasonCode'
op|','
name|'description'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|ssh_IGNORE
dedent|''
name|'def'
name|'ssh_IGNORE'
op|'('
name|'self'
op|','
name|'packet'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when we receieve a MSG_IGNORE message.  No payload.\n        This means nothing; we simply return.\n        """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|ssh_UNIMPLEMENTED
dedent|''
name|'def'
name|'ssh_UNIMPLEMENTED'
op|'('
name|'self'
op|','
name|'packet'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when we receieve a MSG_UNIMPLEMENTED message.  Payload::\n            long packet\n\n        This means that the other side did not implement one of our packets.\n        """'
newline|'\n'
name|'seqnum'
op|','
op|'='
name|'struct'
op|'.'
name|'unpack'
op|'('
string|"'>L'"
op|','
name|'packet'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'receiveUnimplemented'
op|'('
name|'seqnum'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|ssh_DEBUG
dedent|''
name|'def'
name|'ssh_DEBUG'
op|'('
name|'self'
op|','
name|'packet'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when we receieve a MSG_DEBUG message.  Payload::\n            bool alwaysDisplay\n            string message\n            string language\n\n        This means the other side has passed along some debugging info.\n        """'
newline|'\n'
name|'alwaysDisplay'
op|'='
name|'bool'
op|'('
name|'packet'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
name|'message'
op|','
name|'lang'
op|','
name|'foo'
op|'='
name|'getNS'
op|'('
name|'packet'
op|'['
number|'1'
op|':'
op|']'
op|','
number|'2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'receiveDebug'
op|'('
name|'alwaysDisplay'
op|','
name|'message'
op|','
name|'lang'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|setService
dedent|''
name|'def'
name|'setService'
op|'('
name|'self'
op|','
name|'service'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Set our service to service and start it running.  If we were\n        running a service previously, stop it first.\n\n        @type service: C{SSHService}\n        """'
newline|'\n'
name|'log'
op|'.'
name|'msg'
op|'('
string|"'starting service %s'"
op|'%'
name|'service'
op|'.'
name|'name'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'service'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'service'
op|'.'
name|'serviceStopped'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'service'
op|'='
name|'service'
newline|'\n'
name|'service'
op|'.'
name|'transport'
op|'='
name|'self'
newline|'\n'
name|'self'
op|'.'
name|'service'
op|'.'
name|'serviceStarted'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|sendDebug
dedent|''
name|'def'
name|'sendDebug'
op|'('
name|'self'
op|','
name|'message'
op|','
name|'alwaysDisplay'
op|'='
name|'False'
op|','
name|'language'
op|'='
string|"''"
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send a debug message to the other side.\n\n        @param message: the message to send.\n        @type message: C{str}\n        @param alwaysDisplay: if True, tell the other side to always\n                              display this message.\n        @type alwaysDisplay: C{bool}\n        @param language: optionally, the language the message is in.\n        @type language: C{str}\n        """'
newline|'\n'
name|'self'
op|'.'
name|'sendPacket'
op|'('
name|'MSG_DEBUG'
op|','
name|'chr'
op|'('
name|'alwaysDisplay'
op|')'
op|'+'
name|'NS'
op|'('
name|'message'
op|')'
op|'+'
nl|'\n'
name|'NS'
op|'('
name|'language'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|sendIgnore
dedent|''
name|'def'
name|'sendIgnore'
op|'('
name|'self'
op|','
name|'message'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send a message that will be ignored by the other side.  This is\n        useful to fool attacks based on guessing packet sizes in the\n        encrypted stream.\n\n        @param message: data to send with the message\n        @type message: C{str}\n        """'
newline|'\n'
name|'self'
op|'.'
name|'sendPacket'
op|'('
name|'MSG_IGNORE'
op|','
name|'NS'
op|'('
name|'message'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|sendUnimplemented
dedent|''
name|'def'
name|'sendUnimplemented'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send a message to the other side that the last packet was not\n        understood.\n        """'
newline|'\n'
name|'seqnum'
op|'='
name|'self'
op|'.'
name|'incomingPacketSequence'
newline|'\n'
name|'self'
op|'.'
name|'sendPacket'
op|'('
name|'MSG_UNIMPLEMENTED'
op|','
name|'struct'
op|'.'
name|'pack'
op|'('
string|"'!L'"
op|','
name|'seqnum'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|sendDisconnect
dedent|''
name|'def'
name|'sendDisconnect'
op|'('
name|'self'
op|','
name|'reason'
op|','
name|'desc'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send a disconnect message to the other side and then disconnect.\n\n        @param reason: the reason for the disconnect.  Should be one of the\n                       DISCONNECT_* values.\n        @type reason: C{int}\n        @param desc: a descrption of the reason for the disconnection.\n        @type desc: C{str}\n        """'
newline|'\n'
name|'self'
op|'.'
name|'sendPacket'
op|'('
nl|'\n'
name|'MSG_DISCONNECT'
op|','
name|'struct'
op|'.'
name|'pack'
op|'('
string|"'>L'"
op|','
name|'reason'
op|')'
op|'+'
name|'NS'
op|'('
name|'desc'
op|')'
op|'+'
name|'NS'
op|'('
string|"''"
op|')'
op|')'
newline|'\n'
name|'log'
op|'.'
name|'msg'
op|'('
string|"'Disconnecting with error, code %s\\nreason: %s'"
op|'%'
op|'('
name|'reason'
op|','
nl|'\n'
name|'desc'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_getKey
dedent|''
name|'def'
name|'_getKey'
op|'('
name|'self'
op|','
name|'c'
op|','
name|'sharedSecret'
op|','
name|'exchangeHash'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Get one of the keys for authentication/encryption.\n\n        @type c: C{str}\n        @type sharedSecret: C{str}\n        @type exchangeHash: C{str}\n        """'
newline|'\n'
name|'k1'
op|'='
name|'sha1'
op|'('
name|'sharedSecret'
op|'+'
name|'exchangeHash'
op|'+'
name|'c'
op|'+'
name|'self'
op|'.'
name|'sessionID'
op|')'
newline|'\n'
name|'k1'
op|'='
name|'k1'
op|'.'
name|'digest'
op|'('
op|')'
newline|'\n'
name|'k2'
op|'='
name|'sha1'
op|'('
name|'sharedSecret'
op|'+'
name|'exchangeHash'
op|'+'
name|'k1'
op|')'
op|'.'
name|'digest'
op|'('
op|')'
newline|'\n'
name|'return'
name|'k1'
op|'+'
name|'k2'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_keySetup
dedent|''
name|'def'
name|'_keySetup'
op|'('
name|'self'
op|','
name|'sharedSecret'
op|','
name|'exchangeHash'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Set up the keys for the connection and sends MSG_NEWKEYS when\n        finished,\n\n        @param sharedSecret: a secret string agreed upon using a Diffie-\n                             Hellman exchange, so it is only shared between\n                             the server and the client.\n        @type sharedSecret: C{str}\n        @param exchangeHash: A hash of various data known by both sides.\n        @type exchangeHash: C{str}\n        """'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'sessionID'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sessionID'
op|'='
name|'exchangeHash'
newline|'\n'
dedent|''
name|'initIVCS'
op|'='
name|'self'
op|'.'
name|'_getKey'
op|'('
string|"'A'"
op|','
name|'sharedSecret'
op|','
name|'exchangeHash'
op|')'
newline|'\n'
name|'initIVSC'
op|'='
name|'self'
op|'.'
name|'_getKey'
op|'('
string|"'B'"
op|','
name|'sharedSecret'
op|','
name|'exchangeHash'
op|')'
newline|'\n'
name|'encKeyCS'
op|'='
name|'self'
op|'.'
name|'_getKey'
op|'('
string|"'C'"
op|','
name|'sharedSecret'
op|','
name|'exchangeHash'
op|')'
newline|'\n'
name|'encKeySC'
op|'='
name|'self'
op|'.'
name|'_getKey'
op|'('
string|"'D'"
op|','
name|'sharedSecret'
op|','
name|'exchangeHash'
op|')'
newline|'\n'
name|'integKeyCS'
op|'='
name|'self'
op|'.'
name|'_getKey'
op|'('
string|"'E'"
op|','
name|'sharedSecret'
op|','
name|'exchangeHash'
op|')'
newline|'\n'
name|'integKeySC'
op|'='
name|'self'
op|'.'
name|'_getKey'
op|'('
string|"'F'"
op|','
name|'sharedSecret'
op|','
name|'exchangeHash'
op|')'
newline|'\n'
name|'outs'
op|'='
op|'['
name|'initIVSC'
op|','
name|'encKeySC'
op|','
name|'integKeySC'
op|']'
newline|'\n'
name|'ins'
op|'='
op|'['
name|'initIVCS'
op|','
name|'encKeyCS'
op|','
name|'integKeyCS'
op|']'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'isClient'
op|':'
comment|'# reverse for the client'
newline|'\n'
indent|'            '
name|'log'
op|'.'
name|'msg'
op|'('
string|"'REVERSE'"
op|')'
newline|'\n'
name|'outs'
op|','
name|'ins'
op|'='
name|'ins'
op|','
name|'outs'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'nextEncryptions'
op|'.'
name|'setKeys'
op|'('
name|'outs'
op|'['
number|'0'
op|']'
op|','
name|'outs'
op|'['
number|'1'
op|']'
op|','
name|'ins'
op|'['
number|'0'
op|']'
op|','
name|'ins'
op|'['
number|'1'
op|']'
op|','
nl|'\n'
name|'outs'
op|'['
number|'2'
op|']'
op|','
name|'ins'
op|'['
number|'2'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'sendPacket'
op|'('
name|'MSG_NEWKEYS'
op|','
string|"''"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|isEncrypted
dedent|''
name|'def'
name|'isEncrypted'
op|'('
name|'self'
op|','
name|'direction'
op|'='
string|'"out"'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return True if the connection is encrypted in the given direction.\n        Direction must be one of ["out", "in", "both"].\n        """'
newline|'\n'
name|'if'
name|'direction'
op|'=='
string|'"out"'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'currentEncryptions'
op|'.'
name|'outCipType'
op|'!='
string|"'none'"
newline|'\n'
dedent|''
name|'elif'
name|'direction'
op|'=='
string|'"in"'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'currentEncryptions'
op|'.'
name|'inCipType'
op|'!='
string|"'none'"
newline|'\n'
dedent|''
name|'elif'
name|'direction'
op|'=='
string|'"both"'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'isEncrypted'
op|'('
string|'"in"'
op|')'
name|'and'
name|'self'
op|'.'
name|'isEncrypted'
op|'('
string|'"out"'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'TypeError'
op|'('
string|'\'direction must be "out", "in", or "both"\''
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|isVerified
dedent|''
dedent|''
name|'def'
name|'isVerified'
op|'('
name|'self'
op|','
name|'direction'
op|'='
string|'"out"'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return True if the connecction is verified/authenticated in the\n        given direction.  Direction must be one of ["out", "in", "both"].\n        """'
newline|'\n'
name|'if'
name|'direction'
op|'=='
string|'"out"'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'currentEncryptions'
op|'.'
name|'outMACType'
op|'!='
string|"'none'"
newline|'\n'
dedent|''
name|'elif'
name|'direction'
op|'=='
string|'"in"'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'currentEncryptions'
op|'.'
name|'inMACType'
op|'!='
string|"'none'"
newline|'\n'
dedent|''
name|'elif'
name|'direction'
op|'=='
string|'"both"'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'isVerified'
op|'('
string|'"in"'
op|')'
name|'and'
name|'self'
op|'.'
name|'isVerified'
op|'('
string|'"out"'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'TypeError'
op|'('
string|'\'direction must be "out", "in", or "both"\''
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|loseConnection
dedent|''
dedent|''
name|'def'
name|'loseConnection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Lose the connection to the other side, sending a\n        DISCONNECT_CONNECTION_LOST message.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'sendDisconnect'
op|'('
name|'DISCONNECT_CONNECTION_LOST'
op|','
nl|'\n'
string|'"user closed connection"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# client methods'
nl|'\n'
DECL|member|receiveError
dedent|''
name|'def'
name|'receiveError'
op|'('
name|'self'
op|','
name|'reasonCode'
op|','
name|'description'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when we receive a disconnect error message from the other\n        side.\n\n        @param reasonCode: the reason for the disconnect, one of the\n                           DISCONNECT_ values.\n        @type reasonCode: C{int}\n        @param description: a human-readable description of the\n                            disconnection.\n        @type description: C{str}\n        """'
newline|'\n'
name|'log'
op|'.'
name|'msg'
op|'('
string|"'Got remote error, code %s\\nreason: %s'"
op|'%'
op|'('
name|'reasonCode'
op|','
nl|'\n'
name|'description'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|receiveUnimplemented
dedent|''
name|'def'
name|'receiveUnimplemented'
op|'('
name|'self'
op|','
name|'seqnum'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when we receive an unimplemented packet message from the other\n        side.\n\n        @param seqnum: the sequence number that was not understood.\n        @type seqnum: C{int}\n        """'
newline|'\n'
name|'log'
op|'.'
name|'msg'
op|'('
string|"'other side unimplemented packet #%s'"
op|'%'
name|'seqnum'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|receiveDebug
dedent|''
name|'def'
name|'receiveDebug'
op|'('
name|'self'
op|','
name|'alwaysDisplay'
op|','
name|'message'
op|','
name|'lang'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when we receive a debug message from the other side.\n\n        @param alwaysDisplay: if True, this message should always be\n                              displayed.\n        @type alwaysDisplay: C{bool}\n        @param message: the debug message\n        @type message: C{str}\n        @param lang: optionally the language the message is in.\n        @type lang: C{str}\n        """'
newline|'\n'
name|'if'
name|'alwaysDisplay'
op|':'
newline|'\n'
indent|'            '
name|'log'
op|'.'
name|'msg'
op|'('
string|"'Remote Debug Message: %s'"
op|'%'
name|'message'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|SSHServerTransport
dedent|''
dedent|''
dedent|''
name|'class'
name|'SSHServerTransport'
op|'('
name|'SSHTransportBase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    SSHServerTransport implements the server side of the SSH protocol.\n\n    @ivar isClient: since we are never the client, this is always False.\n\n    @ivar ignoreNextPacket: if True, ignore the next key exchange packet.  This\n        is set when the client sends a guessed key exchange packet but with\n        an incorrect guess.\n\n    @ivar dhGexRequest: the KEX_DH_GEX_REQUEST(_OLD) that the client sent.\n        The key generation needs this to be stored.\n\n    @ivar g: the Diffie-Hellman group generator.\n\n    @ivar p: the Diffie-Hellman group prime.\n    """'
newline|'\n'
DECL|variable|isClient
name|'isClient'
op|'='
name|'False'
newline|'\n'
DECL|variable|ignoreNextPacket
name|'ignoreNextPacket'
op|'='
number|'0'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|ssh_KEXINIT
name|'def'
name|'ssh_KEXINIT'
op|'('
name|'self'
op|','
name|'packet'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when we receive a MSG_KEXINIT message.  For a description\n        of the packet, see SSHTransportBase.ssh_KEXINIT().  Additionally,\n        this method checks if a guessed key exchange packet was sent.  If\n        it was sent, and it guessed incorrectly, the next key exchange\n        packet MUST be ignored.\n        """'
newline|'\n'
name|'retval'
op|'='
name|'SSHTransportBase'
op|'.'
name|'ssh_KEXINIT'
op|'('
name|'self'
op|','
name|'packet'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'retval'
op|':'
comment|'# disconnected'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'kexAlgs'
op|','
name|'keyAlgs'
op|','
name|'rest'
op|'='
name|'retval'
newline|'\n'
dedent|''
name|'if'
name|'ord'
op|'('
name|'rest'
op|'['
number|'0'
op|']'
op|')'
op|':'
comment|'# first_kex_packet_follows'
newline|'\n'
indent|'            '
name|'if'
op|'('
name|'kexAlgs'
op|'['
number|'0'
op|']'
op|'!='
name|'self'
op|'.'
name|'supportedKeyExchanges'
op|'['
number|'0'
op|']'
name|'or'
nl|'\n'
name|'keyAlgs'
op|'['
number|'0'
op|']'
op|'!='
name|'self'
op|'.'
name|'supportedPublicKeys'
op|'['
number|'0'
op|']'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'ignoreNextPacket'
op|'='
name|'True'
comment|'# guess was wrong'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|ssh_KEX_DH_GEX_REQUEST_OLD
dedent|''
dedent|''
dedent|''
name|'def'
name|'ssh_KEX_DH_GEX_REQUEST_OLD'
op|'('
name|'self'
op|','
name|'packet'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        This represents two different key exchange methods that share the\n        same integer value.\n\n        KEXDH_INIT (for diffie-hellman-group1-sha1 exchanges) payload::\n\n                integer e (the client\'s Diffie-Hellman public key)\n\n            We send the KEXDH_REPLY with our host key and signature.\n\n        KEX_DH_GEX_REQUEST_OLD (for diffie-hellman-group-exchange-sha1)\n        payload::\n\n                integer ideal (ideal size for the Diffie-Hellman prime)\n\n            We send the KEX_DH_GEX_GROUP message with the group that is\n            closest in size to ideal.\n\n        If we were told to ignore the next key exchange packet by\n        ssh_KEXINIT, drop it on the floor and return.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'ignoreNextPacket'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'ignoreNextPacket'
op|'='
number|'0'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'kexAlg'
op|'=='
string|"'diffie-hellman-group1-sha1'"
op|':'
newline|'\n'
comment|'# this is really KEXDH_INIT'
nl|'\n'
indent|'            '
name|'clientDHpublicKey'
op|','
name|'foo'
op|'='
name|'getMP'
op|'('
name|'packet'
op|')'
newline|'\n'
name|'y'
op|'='
name|'Util'
op|'.'
name|'number'
op|'.'
name|'getRandomNumber'
op|'('
number|'512'
op|','
name|'randbytes'
op|'.'
name|'secureRandom'
op|')'
newline|'\n'
name|'serverDHpublicKey'
op|'='
name|'_MPpow'
op|'('
name|'DH_GENERATOR'
op|','
name|'y'
op|','
name|'DH_PRIME'
op|')'
newline|'\n'
name|'sharedSecret'
op|'='
name|'_MPpow'
op|'('
name|'clientDHpublicKey'
op|','
name|'y'
op|','
name|'DH_PRIME'
op|')'
newline|'\n'
name|'h'
op|'='
name|'sha1'
op|'('
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'NS'
op|'('
name|'self'
op|'.'
name|'otherVersionString'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'NS'
op|'('
name|'self'
op|'.'
name|'ourVersionString'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'NS'
op|'('
name|'self'
op|'.'
name|'otherKexInitPayload'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'NS'
op|'('
name|'self'
op|'.'
name|'ourKexInitPayload'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'NS'
op|'('
name|'self'
op|'.'
name|'factory'
op|'.'
name|'publicKeys'
op|'['
name|'self'
op|'.'
name|'keyAlg'
op|']'
op|'.'
name|'blob'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'MP'
op|'('
name|'clientDHpublicKey'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'serverDHpublicKey'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'sharedSecret'
op|')'
newline|'\n'
name|'exchangeHash'
op|'='
name|'h'
op|'.'
name|'digest'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'sendPacket'
op|'('
nl|'\n'
name|'MSG_KEXDH_REPLY'
op|','
nl|'\n'
name|'NS'
op|'('
name|'self'
op|'.'
name|'factory'
op|'.'
name|'publicKeys'
op|'['
name|'self'
op|'.'
name|'keyAlg'
op|']'
op|'.'
name|'blob'
op|'('
op|')'
op|')'
op|'+'
nl|'\n'
name|'serverDHpublicKey'
op|'+'
nl|'\n'
name|'NS'
op|'('
name|'self'
op|'.'
name|'factory'
op|'.'
name|'privateKeys'
op|'['
name|'self'
op|'.'
name|'keyAlg'
op|']'
op|'.'
name|'sign'
op|'('
name|'exchangeHash'
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_keySetup'
op|'('
name|'sharedSecret'
op|','
name|'exchangeHash'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'kexAlg'
op|'=='
string|"'diffie-hellman-group-exchange-sha1'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'dhGexRequest'
op|'='
name|'packet'
newline|'\n'
name|'ideal'
op|'='
name|'struct'
op|'.'
name|'unpack'
op|'('
string|"'>L'"
op|','
name|'packet'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'g'
op|','
name|'self'
op|'.'
name|'p'
op|'='
name|'self'
op|'.'
name|'factory'
op|'.'
name|'getDHPrime'
op|'('
name|'ideal'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'sendPacket'
op|'('
name|'MSG_KEX_DH_GEX_GROUP'
op|','
name|'MP'
op|'('
name|'self'
op|'.'
name|'p'
op|')'
op|'+'
name|'MP'
op|'('
name|'self'
op|'.'
name|'g'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'error'
op|'.'
name|'ConchError'
op|'('
string|"'bad kexalg: %s'"
op|'%'
name|'self'
op|'.'
name|'kexAlg'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|ssh_KEX_DH_GEX_REQUEST
dedent|''
dedent|''
name|'def'
name|'ssh_KEX_DH_GEX_REQUEST'
op|'('
name|'self'
op|','
name|'packet'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when we receive a MSG_KEX_DH_GEX_REQUEST message.  Payload::\n            integer minimum\n            integer ideal\n            integer maximum\n\n        The client is asking for a Diffie-Hellman group between minimum and\n        maximum size, and close to ideal if possible.  We reply with a\n        MSG_KEX_DH_GEX_GROUP message.\n\n        If we were told to ignore the next key exchange packekt by\n        ssh_KEXINIT, drop it on the floor and return.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'ignoreNextPacket'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'ignoreNextPacket'
op|'='
number|'0'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'dhGexRequest'
op|'='
name|'packet'
newline|'\n'
name|'min'
op|','
name|'ideal'
op|','
name|'max'
op|'='
name|'struct'
op|'.'
name|'unpack'
op|'('
string|"'>3L'"
op|','
name|'packet'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'g'
op|','
name|'self'
op|'.'
name|'p'
op|'='
name|'self'
op|'.'
name|'factory'
op|'.'
name|'getDHPrime'
op|'('
name|'ideal'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'sendPacket'
op|'('
name|'MSG_KEX_DH_GEX_GROUP'
op|','
name|'MP'
op|'('
name|'self'
op|'.'
name|'p'
op|')'
op|'+'
name|'MP'
op|'('
name|'self'
op|'.'
name|'g'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|ssh_KEX_DH_GEX_INIT
dedent|''
name|'def'
name|'ssh_KEX_DH_GEX_INIT'
op|'('
name|'self'
op|','
name|'packet'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when we get a MSG_KEX_DH_GEX_INIT message.  Payload::\n            integer e (client DH public key)\n\n        We send the MSG_KEX_DH_GEX_REPLY message with our host key and\n        signature.\n        """'
newline|'\n'
name|'clientDHpublicKey'
op|','
name|'foo'
op|'='
name|'getMP'
op|'('
name|'packet'
op|')'
newline|'\n'
comment|'# TODO: we should also look at the value they send to us and reject'
nl|'\n'
comment|"# insecure values of f (if g==2 and f has a single '1' bit while the"
nl|'\n'
comment|"# rest are '0's, then they must have used a small y also)."
nl|'\n'
nl|'\n'
comment|'# TODO: This could be computed when self.p is set up'
nl|'\n'
comment|"#  or do as openssh does and scan f for a single '1' bit instead"
nl|'\n'
nl|'\n'
name|'pSize'
op|'='
name|'Util'
op|'.'
name|'number'
op|'.'
name|'size'
op|'('
name|'self'
op|'.'
name|'p'
op|')'
newline|'\n'
name|'y'
op|'='
name|'Util'
op|'.'
name|'number'
op|'.'
name|'getRandomNumber'
op|'('
name|'pSize'
op|','
name|'randbytes'
op|'.'
name|'secureRandom'
op|')'
newline|'\n'
nl|'\n'
name|'serverDHpublicKey'
op|'='
name|'_MPpow'
op|'('
name|'self'
op|'.'
name|'g'
op|','
name|'y'
op|','
name|'self'
op|'.'
name|'p'
op|')'
newline|'\n'
name|'sharedSecret'
op|'='
name|'_MPpow'
op|'('
name|'clientDHpublicKey'
op|','
name|'y'
op|','
name|'self'
op|'.'
name|'p'
op|')'
newline|'\n'
name|'h'
op|'='
name|'sha1'
op|'('
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'NS'
op|'('
name|'self'
op|'.'
name|'otherVersionString'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'NS'
op|'('
name|'self'
op|'.'
name|'ourVersionString'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'NS'
op|'('
name|'self'
op|'.'
name|'otherKexInitPayload'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'NS'
op|'('
name|'self'
op|'.'
name|'ourKexInitPayload'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'NS'
op|'('
name|'self'
op|'.'
name|'factory'
op|'.'
name|'publicKeys'
op|'['
name|'self'
op|'.'
name|'keyAlg'
op|']'
op|'.'
name|'blob'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'self'
op|'.'
name|'dhGexRequest'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'MP'
op|'('
name|'self'
op|'.'
name|'p'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'MP'
op|'('
name|'self'
op|'.'
name|'g'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'MP'
op|'('
name|'clientDHpublicKey'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'serverDHpublicKey'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'sharedSecret'
op|')'
newline|'\n'
name|'exchangeHash'
op|'='
name|'h'
op|'.'
name|'digest'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'sendPacket'
op|'('
nl|'\n'
name|'MSG_KEX_DH_GEX_REPLY'
op|','
nl|'\n'
name|'NS'
op|'('
name|'self'
op|'.'
name|'factory'
op|'.'
name|'publicKeys'
op|'['
name|'self'
op|'.'
name|'keyAlg'
op|']'
op|'.'
name|'blob'
op|'('
op|')'
op|')'
op|'+'
nl|'\n'
name|'serverDHpublicKey'
op|'+'
nl|'\n'
name|'NS'
op|'('
name|'self'
op|'.'
name|'factory'
op|'.'
name|'privateKeys'
op|'['
name|'self'
op|'.'
name|'keyAlg'
op|']'
op|'.'
name|'sign'
op|'('
name|'exchangeHash'
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_keySetup'
op|'('
name|'sharedSecret'
op|','
name|'exchangeHash'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|ssh_NEWKEYS
dedent|''
name|'def'
name|'ssh_NEWKEYS'
op|'('
name|'self'
op|','
name|'packet'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when we get a MSG_NEWKEYS message.  No payload.\n        When we get this, the keys have been set on both sides, and we\n        start using them to encrypt and authenticate the connection.\n        """'
newline|'\n'
name|'log'
op|'.'
name|'msg'
op|'('
string|"'NEW KEYS'"
op|')'
newline|'\n'
name|'if'
name|'packet'
op|'!='
string|"''"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sendDisconnect'
op|'('
name|'DISCONNECT_PROTOCOL_ERROR'
op|','
nl|'\n'
string|'"NEWKEYS takes no data"'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'currentEncryptions'
op|'='
name|'self'
op|'.'
name|'nextEncryptions'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'outgoingCompressionType'
op|'=='
string|"'zlib'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'outgoingCompression'
op|'='
name|'zlib'
op|'.'
name|'compressobj'
op|'('
number|'6'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'incomingCompressionType'
op|'=='
string|"'zlib'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'incomingCompression'
op|'='
name|'zlib'
op|'.'
name|'decompressobj'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|ssh_SERVICE_REQUEST
dedent|''
dedent|''
name|'def'
name|'ssh_SERVICE_REQUEST'
op|'('
name|'self'
op|','
name|'packet'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when we get a MSG_SERVICE_REQUEST message.  Payload::\n            string serviceName\n\n        The client has requested a service.  If we can start the service,\n        start it; otherwise, disconnect with\n        DISCONNECT_SERVICE_NOT_AVAILABLE.\n        """'
newline|'\n'
name|'service'
op|','
name|'rest'
op|'='
name|'getNS'
op|'('
name|'packet'
op|')'
newline|'\n'
name|'cls'
op|'='
name|'self'
op|'.'
name|'factory'
op|'.'
name|'getService'
op|'('
name|'self'
op|','
name|'service'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'cls'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sendDisconnect'
op|'('
name|'DISCONNECT_SERVICE_NOT_AVAILABLE'
op|','
nl|'\n'
string|'"don\'t have service %s"'
op|'%'
name|'service'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sendPacket'
op|'('
name|'MSG_SERVICE_ACCEPT'
op|','
name|'NS'
op|'('
name|'service'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'setService'
op|'('
name|'cls'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|SSHClientTransport
dedent|''
dedent|''
dedent|''
name|'class'
name|'SSHClientTransport'
op|'('
name|'SSHTransportBase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    SSHClientTransport implements the client side of the SSH protocol.\n\n    @ivar isClient: since we are always the client, this is always True.\n\n    @ivar _gotNewKeys: if we receive a MSG_NEWKEYS message before we are\n        ready to transition to the new keys, this is set to True so we\n        can transition when the keys are ready locally.\n\n    @ivar x: our Diffie-Hellman private key.\n\n    @ivar e: our Diffie-Hellman public key.\n\n    @ivar g: the Diffie-Hellman group generator.\n\n    @ivar p: the Diffie-Hellman group prime\n\n    @ivar instance: the SSHService object we are requesting.\n    """'
newline|'\n'
DECL|variable|isClient
name|'isClient'
op|'='
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionMade
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when the connection is started with the server.  Just sets\n        up a private instance variable.\n        """'
newline|'\n'
name|'SSHTransportBase'
op|'.'
name|'connectionMade'
op|'('
name|'self'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_gotNewKeys'
op|'='
number|'0'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|ssh_KEXINIT
dedent|''
name|'def'
name|'ssh_KEXINIT'
op|'('
name|'self'
op|','
name|'packet'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when we receive a MSG_KEXINIT message.  For a description\n        of the packet, see SSHTransportBase.ssh_KEXINIT().  Additionally,\n        this method sends the first key exchange packet.  If the agreed-upon\n        exchange is diffie-hellman-group1-sha1, generate a public key\n        and send it in a MSG_KEXDH_INIT message.  If the exchange is\n        diffie-hellman-group-exchange-sha1, ask for a 2048 bit group with a\n        MSG_KEX_DH_GEX_REQUEST_OLD message.\n        """'
newline|'\n'
name|'if'
name|'SSHTransportBase'
op|'.'
name|'ssh_KEXINIT'
op|'('
name|'self'
op|','
name|'packet'
op|')'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
comment|'# we disconnected'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'kexAlg'
op|'=='
string|"'diffie-hellman-group1-sha1'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'x'
op|'='
name|'Util'
op|'.'
name|'number'
op|'.'
name|'getRandomNumber'
op|'('
number|'512'
op|','
name|'randbytes'
op|'.'
name|'secureRandom'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'e'
op|'='
name|'_MPpow'
op|'('
name|'DH_GENERATOR'
op|','
name|'self'
op|'.'
name|'x'
op|','
name|'DH_PRIME'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'sendPacket'
op|'('
name|'MSG_KEXDH_INIT'
op|','
name|'self'
op|'.'
name|'e'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'kexAlg'
op|'=='
string|"'diffie-hellman-group-exchange-sha1'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sendPacket'
op|'('
name|'MSG_KEX_DH_GEX_REQUEST_OLD'
op|','
string|"'\\x00\\x00\\x08\\x00'"
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'error'
op|'.'
name|'ConchError'
op|'('
string|'"somehow, the kexAlg has been set "'
nl|'\n'
string|'"to something we don\'t support"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|ssh_KEX_DH_GEX_GROUP
dedent|''
dedent|''
name|'def'
name|'ssh_KEX_DH_GEX_GROUP'
op|'('
name|'self'
op|','
name|'packet'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        This handles two different message which share an integer value.\n        If the key exchange is diffie-hellman-group1-sha1, this is\n        MSG_KEXDH_REPLY.  Payload::\n            string serverHostKey\n            integer f (server Diffie-Hellman public key)\n            string signature\n\n        We verify the host key by calling verifyHostKey, then continue in\n        _continueKEXDH_REPLY.\n\n        If the key exchange is diffie-hellman-group-exchange-sha1, this is\n        MSG_KEX_DH_GEX_GROUP.  Payload::\n            string g (group generator)\n            string p (group prime)\n\n        We generate a Diffie-Hellman public key and send it in a\n        MSG_KEX_DH_GEX_INIT message.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'kexAlg'
op|'=='
string|"'diffie-hellman-group1-sha1'"
op|':'
newline|'\n'
comment|'# actually MSG_KEXDH_REPLY'
nl|'\n'
indent|'            '
name|'pubKey'
op|','
name|'packet'
op|'='
name|'getNS'
op|'('
name|'packet'
op|')'
newline|'\n'
name|'f'
op|','
name|'packet'
op|'='
name|'getMP'
op|'('
name|'packet'
op|')'
newline|'\n'
name|'signature'
op|','
name|'packet'
op|'='
name|'getNS'
op|'('
name|'packet'
op|')'
newline|'\n'
name|'fingerprint'
op|'='
string|"':'"
op|'.'
name|'join'
op|'('
op|'['
name|'ch'
op|'.'
name|'encode'
op|'('
string|"'hex'"
op|')'
name|'for'
name|'ch'
name|'in'
nl|'\n'
name|'md5'
op|'('
name|'pubKey'
op|')'
op|'.'
name|'digest'
op|'('
op|')'
op|']'
op|')'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'verifyHostKey'
op|'('
name|'pubKey'
op|','
name|'fingerprint'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'_continueKEXDH_REPLY'
op|','
name|'pubKey'
op|','
name|'f'
op|','
name|'signature'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addErrback'
op|'('
nl|'\n'
name|'lambda'
name|'unused'
op|':'
name|'self'
op|'.'
name|'sendDisconnect'
op|'('
nl|'\n'
name|'DISCONNECT_HOST_KEY_NOT_VERIFIABLE'
op|','
string|"'bad host key'"
op|')'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'p'
op|','
name|'rest'
op|'='
name|'getMP'
op|'('
name|'packet'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'g'
op|','
name|'rest'
op|'='
name|'getMP'
op|'('
name|'rest'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'x'
op|'='
name|'Util'
op|'.'
name|'number'
op|'.'
name|'getRandomNumber'
op|'('
number|'320'
op|','
name|'randbytes'
op|'.'
name|'secureRandom'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'e'
op|'='
name|'_MPpow'
op|'('
name|'self'
op|'.'
name|'g'
op|','
name|'self'
op|'.'
name|'x'
op|','
name|'self'
op|'.'
name|'p'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'sendPacket'
op|'('
name|'MSG_KEX_DH_GEX_INIT'
op|','
name|'self'
op|'.'
name|'e'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_continueKEXDH_REPLY
dedent|''
dedent|''
name|'def'
name|'_continueKEXDH_REPLY'
op|'('
name|'self'
op|','
name|'ignored'
op|','
name|'pubKey'
op|','
name|'f'
op|','
name|'signature'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The host key has been verified, so we generate the keys.\n\n        @param pubKey: the public key blob for the server\'s public key.\n        @type pubKey: C{str}\n        @param f: the server\'s Diffie-Hellman public key.\n        @type f: C{long}\n        @param signature: the server\'s signature, verifying that it has the\n            correct private key.\n        @type signature: C{str}\n        """'
newline|'\n'
name|'serverKey'
op|'='
name|'keys'
op|'.'
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'pubKey'
op|')'
newline|'\n'
name|'sharedSecret'
op|'='
name|'_MPpow'
op|'('
name|'f'
op|','
name|'self'
op|'.'
name|'x'
op|','
name|'DH_PRIME'
op|')'
newline|'\n'
name|'h'
op|'='
name|'sha1'
op|'('
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'NS'
op|'('
name|'self'
op|'.'
name|'ourVersionString'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'NS'
op|'('
name|'self'
op|'.'
name|'otherVersionString'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'NS'
op|'('
name|'self'
op|'.'
name|'ourKexInitPayload'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'NS'
op|'('
name|'self'
op|'.'
name|'otherKexInitPayload'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'NS'
op|'('
name|'pubKey'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'self'
op|'.'
name|'e'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'MP'
op|'('
name|'f'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'sharedSecret'
op|')'
newline|'\n'
name|'exchangeHash'
op|'='
name|'h'
op|'.'
name|'digest'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
name|'serverKey'
op|'.'
name|'verify'
op|'('
name|'signature'
op|','
name|'exchangeHash'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sendDisconnect'
op|'('
name|'DISCONNECT_KEY_EXCHANGE_FAILED'
op|','
nl|'\n'
string|"'bad signature'"
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_keySetup'
op|'('
name|'sharedSecret'
op|','
name|'exchangeHash'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|ssh_KEX_DH_GEX_REPLY
dedent|''
name|'def'
name|'ssh_KEX_DH_GEX_REPLY'
op|'('
name|'self'
op|','
name|'packet'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when we receieve a MSG_KEX_DH_GEX_REPLY message.  Payload::\n            string server host key\n            integer f (server DH public key)\n\n        We verify the host key by calling verifyHostKey, then continue in\n        _continueGEX_REPLY.\n        """'
newline|'\n'
name|'pubKey'
op|','
name|'packet'
op|'='
name|'getNS'
op|'('
name|'packet'
op|')'
newline|'\n'
name|'f'
op|','
name|'packet'
op|'='
name|'getMP'
op|'('
name|'packet'
op|')'
newline|'\n'
name|'signature'
op|','
name|'packet'
op|'='
name|'getNS'
op|'('
name|'packet'
op|')'
newline|'\n'
name|'fingerprint'
op|'='
string|"':'"
op|'.'
name|'join'
op|'('
name|'map'
op|'('
name|'lambda'
name|'c'
op|':'
string|"'%02x'"
op|'%'
name|'ord'
op|'('
name|'c'
op|')'
op|','
nl|'\n'
name|'md5'
op|'('
name|'pubKey'
op|')'
op|'.'
name|'digest'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'verifyHostKey'
op|'('
name|'pubKey'
op|','
name|'fingerprint'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'_continueGEX_REPLY'
op|','
name|'pubKey'
op|','
name|'f'
op|','
name|'signature'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addErrback'
op|'('
nl|'\n'
name|'lambda'
name|'unused'
op|':'
name|'self'
op|'.'
name|'sendDisconnect'
op|'('
nl|'\n'
name|'DISCONNECT_HOST_KEY_NOT_VERIFIABLE'
op|','
string|"'bad host key'"
op|')'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_continueGEX_REPLY
dedent|''
name|'def'
name|'_continueGEX_REPLY'
op|'('
name|'self'
op|','
name|'ignored'
op|','
name|'pubKey'
op|','
name|'f'
op|','
name|'signature'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The host key has been verified, so we generate the keys.\n\n        @param pubKey: the public key blob for the server\'s public key.\n        @type pubKey: C{str}\n        @param f: the server\'s Diffie-Hellman public key.\n        @type f: C{long}\n        @param signature: the server\'s signature, verifying that it has the\n            correct private key.\n        @type signature: C{str}\n        """'
newline|'\n'
name|'serverKey'
op|'='
name|'keys'
op|'.'
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'pubKey'
op|')'
newline|'\n'
name|'sharedSecret'
op|'='
name|'_MPpow'
op|'('
name|'f'
op|','
name|'self'
op|'.'
name|'x'
op|','
name|'self'
op|'.'
name|'p'
op|')'
newline|'\n'
name|'h'
op|'='
name|'sha1'
op|'('
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'NS'
op|'('
name|'self'
op|'.'
name|'ourVersionString'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'NS'
op|'('
name|'self'
op|'.'
name|'otherVersionString'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'NS'
op|'('
name|'self'
op|'.'
name|'ourKexInitPayload'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'NS'
op|'('
name|'self'
op|'.'
name|'otherKexInitPayload'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'NS'
op|'('
name|'pubKey'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
string|"'\\x00\\x00\\x08\\x00'"
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'MP'
op|'('
name|'self'
op|'.'
name|'p'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'MP'
op|'('
name|'self'
op|'.'
name|'g'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'self'
op|'.'
name|'e'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'MP'
op|'('
name|'f'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'update'
op|'('
name|'sharedSecret'
op|')'
newline|'\n'
name|'exchangeHash'
op|'='
name|'h'
op|'.'
name|'digest'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
name|'serverKey'
op|'.'
name|'verify'
op|'('
name|'signature'
op|','
name|'exchangeHash'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sendDisconnect'
op|'('
name|'DISCONNECT_KEY_EXCHANGE_FAILED'
op|','
nl|'\n'
string|"'bad signature'"
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_keySetup'
op|'('
name|'sharedSecret'
op|','
name|'exchangeHash'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_keySetup
dedent|''
name|'def'
name|'_keySetup'
op|'('
name|'self'
op|','
name|'sharedSecret'
op|','
name|'exchangeHash'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        See SSHTransportBase._keySetup().\n        """'
newline|'\n'
name|'SSHTransportBase'
op|'.'
name|'_keySetup'
op|'('
name|'self'
op|','
name|'sharedSecret'
op|','
name|'exchangeHash'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_gotNewKeys'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'ssh_NEWKEYS'
op|'('
string|"''"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|ssh_NEWKEYS
dedent|''
dedent|''
name|'def'
name|'ssh_NEWKEYS'
op|'('
name|'self'
op|','
name|'packet'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when we receieve a MSG_NEWKEYS message.  No payload.\n        If we\'ve finished setting up our own keys, start using them.\n        Otherwise, remeber that we\'ve receieved this message.\n        """'
newline|'\n'
name|'if'
name|'packet'
op|'!='
string|"''"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sendDisconnect'
op|'('
name|'DISCONNECT_PROTOCOL_ERROR'
op|','
nl|'\n'
string|'"NEWKEYS takes no data"'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'nextEncryptions'
op|'.'
name|'encBlockSize'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_gotNewKeys'
op|'='
number|'1'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'log'
op|'.'
name|'msg'
op|'('
string|"'NEW KEYS'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'currentEncryptions'
op|'='
name|'self'
op|'.'
name|'nextEncryptions'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'outgoingCompressionType'
op|'=='
string|"'zlib'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'outgoingCompression'
op|'='
name|'zlib'
op|'.'
name|'compressobj'
op|'('
number|'6'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'incomingCompressionType'
op|'=='
string|"'zlib'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'incomingCompression'
op|'='
name|'zlib'
op|'.'
name|'decompressobj'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'connectionSecure'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|ssh_SERVICE_ACCEPT
dedent|''
name|'def'
name|'ssh_SERVICE_ACCEPT'
op|'('
name|'self'
op|','
name|'packet'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when we receieve a MSG_SERVICE_ACCEPT message.  Payload::\n            string service name\n\n        Start the service we requested.\n        """'
newline|'\n'
name|'name'
op|'='
name|'getNS'
op|'('
name|'packet'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'if'
name|'name'
op|'!='
name|'self'
op|'.'
name|'instance'
op|'.'
name|'name'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sendDisconnect'
op|'('
nl|'\n'
name|'DISCONNECT_PROTOCOL_ERROR'
op|','
nl|'\n'
string|'"received accept for service we did not request"'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'setService'
op|'('
name|'self'
op|'.'
name|'instance'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|requestService
dedent|''
name|'def'
name|'requestService'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Request that a service be run over this transport.\n\n        @type instance: subclass of L{twisted.conch.ssh.service.SSHService}\n        """'
newline|'\n'
name|'self'
op|'.'
name|'sendPacket'
op|'('
name|'MSG_SERVICE_REQUEST'
op|','
name|'NS'
op|'('
name|'instance'
op|'.'
name|'name'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'instance'
op|'='
name|'instance'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# client methods'
nl|'\n'
DECL|member|verifyHostKey
dedent|''
name|'def'
name|'verifyHostKey'
op|'('
name|'self'
op|','
name|'hostKey'
op|','
name|'fingerprint'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns a Deferred that gets a callback if it is a valid key, or\n        an errback if not.\n\n        @type hostKey:      C{str}\n        @type fingerprint:  C{str}\n        @rtype:             L{twisted.internet.defer.Deferred}\n        """'
newline|'\n'
comment|"# return if it's good"
nl|'\n'
name|'return'
name|'defer'
op|'.'
name|'fail'
op|'('
name|'NotImplementedError'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionSecure
dedent|''
name|'def'
name|'connectionSecure'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when the encryption has been set up.  Generally,\n        requestService() is called to run another service over the transport.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|_DummyCipher
dedent|''
dedent|''
name|'class'
name|'_DummyCipher'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A cipher for the none encryption method.\n\n    @ivar block_size: the block size of the encryption.  In the case of the\n    none cipher, this is 8 bytes.\n    """'
newline|'\n'
DECL|variable|block_size
name|'block_size'
op|'='
number|'8'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|encrypt
name|'def'
name|'encrypt'
op|'('
name|'self'
op|','
name|'x'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'x'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|decrypt
dedent|''
name|'decrypt'
op|'='
name|'encrypt'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|SSHCiphers
dedent|''
name|'class'
name|'SSHCiphers'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    SSHCiphers represents all the encryption operations that need to occur\n    to encrypt and authenticate the SSH connection.\n\n    @cvar cipherMap: A dictionary mapping SSH encryption names to 3-tuples of\n                     (<Crypto.Cipher.* name>, <block size>, <counter mode>)\n    @cvar macMap: A dictionary mapping SSH MAC names to hash modules.\n\n    @ivar outCipType: the string type of the outgoing cipher.\n    @ivar inCipType: the string type of the incoming cipher.\n    @ivar outMACType: the string type of the incoming MAC.\n    @ivar inMACType: the string type of the incoming MAC.\n    @ivar encBlockSize: the block size of the outgoing cipher.\n    @ivar decBlockSize: the block size of the incoming cipher.\n    @ivar verifyDigestSize: the size of the incoming MAC.\n    @ivar outMAC: a tuple of (<hash module>, <inner key>, <outer key>,\n        <digest size>) representing the outgoing MAC.\n    @ivar inMAc: see outMAC, but for the incoming MAC.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|cipherMap
name|'cipherMap'
op|'='
op|'{'
nl|'\n'
string|"'3des-cbc'"
op|':'
op|'('
string|"'DES3'"
op|','
number|'24'
op|','
number|'0'
op|')'
op|','
nl|'\n'
string|"'blowfish-cbc'"
op|':'
op|'('
string|"'Blowfish'"
op|','
number|'16'
op|','
number|'0'
op|')'
op|','
nl|'\n'
string|"'aes256-cbc'"
op|':'
op|'('
string|"'AES'"
op|','
number|'32'
op|','
number|'0'
op|')'
op|','
nl|'\n'
string|"'aes192-cbc'"
op|':'
op|'('
string|"'AES'"
op|','
number|'24'
op|','
number|'0'
op|')'
op|','
nl|'\n'
string|"'aes128-cbc'"
op|':'
op|'('
string|"'AES'"
op|','
number|'16'
op|','
number|'0'
op|')'
op|','
nl|'\n'
string|"'cast128-cbc'"
op|':'
op|'('
string|"'CAST'"
op|','
number|'16'
op|','
number|'0'
op|')'
op|','
nl|'\n'
string|"'aes128-ctr'"
op|':'
op|'('
string|"'AES'"
op|','
number|'16'
op|','
number|'1'
op|')'
op|','
nl|'\n'
string|"'aes192-ctr'"
op|':'
op|'('
string|"'AES'"
op|','
number|'24'
op|','
number|'1'
op|')'
op|','
nl|'\n'
string|"'aes256-ctr'"
op|':'
op|'('
string|"'AES'"
op|','
number|'32'
op|','
number|'1'
op|')'
op|','
nl|'\n'
string|"'3des-ctr'"
op|':'
op|'('
string|"'DES3'"
op|','
number|'24'
op|','
number|'1'
op|')'
op|','
nl|'\n'
string|"'blowfish-ctr'"
op|':'
op|'('
string|"'Blowfish'"
op|','
number|'16'
op|','
number|'1'
op|')'
op|','
nl|'\n'
string|"'cast128-ctr'"
op|':'
op|'('
string|"'CAST'"
op|','
number|'16'
op|','
number|'1'
op|')'
op|','
nl|'\n'
string|"'none'"
op|':'
op|'('
name|'None'
op|','
number|'0'
op|','
number|'0'
op|')'
op|','
nl|'\n'
op|'}'
newline|'\n'
DECL|variable|macMap
name|'macMap'
op|'='
op|'{'
nl|'\n'
string|"'hmac-sha1'"
op|':'
name|'sha1'
op|','
nl|'\n'
string|"'hmac-md5'"
op|':'
name|'md5'
op|','
nl|'\n'
string|"'none'"
op|':'
name|'None'
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'outCip'
op|','
name|'inCip'
op|','
name|'outMac'
op|','
name|'inMac'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'outCipType'
op|'='
name|'outCip'
newline|'\n'
name|'self'
op|'.'
name|'inCipType'
op|'='
name|'inCip'
newline|'\n'
name|'self'
op|'.'
name|'outMACType'
op|'='
name|'outMac'
newline|'\n'
name|'self'
op|'.'
name|'inMACType'
op|'='
name|'inMac'
newline|'\n'
name|'self'
op|'.'
name|'encBlockSize'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'decBlockSize'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'verifyDigestSize'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'outMAC'
op|'='
op|'('
name|'None'
op|','
string|"''"
op|','
string|"''"
op|','
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'inMAC'
op|'='
op|'('
name|'None'
op|','
string|"''"
op|','
string|"''"
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|setKeys
dedent|''
name|'def'
name|'setKeys'
op|'('
name|'self'
op|','
name|'outIV'
op|','
name|'outKey'
op|','
name|'inIV'
op|','
name|'inKey'
op|','
name|'outInteg'
op|','
name|'inInteg'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Set up the ciphers and hashes using the given keys,\n\n        @param outIV: the outgoing initialization vector\n        @param outKey: the outgoing encryption key\n        @param inIV: the incoming initialization vector\n        @param inKey: the incoming encryption key\n        @param outInteg: the outgoing integrity key\n        @param inInteg: the incoming integrity key.\n        """'
newline|'\n'
name|'o'
op|'='
name|'self'
op|'.'
name|'_getCipher'
op|'('
name|'self'
op|'.'
name|'outCipType'
op|','
name|'outIV'
op|','
name|'outKey'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'encrypt'
op|'='
name|'o'
op|'.'
name|'encrypt'
newline|'\n'
name|'self'
op|'.'
name|'encBlockSize'
op|'='
name|'o'
op|'.'
name|'block_size'
newline|'\n'
name|'o'
op|'='
name|'self'
op|'.'
name|'_getCipher'
op|'('
name|'self'
op|'.'
name|'inCipType'
op|','
name|'inIV'
op|','
name|'inKey'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'decrypt'
op|'='
name|'o'
op|'.'
name|'decrypt'
newline|'\n'
name|'self'
op|'.'
name|'decBlockSize'
op|'='
name|'o'
op|'.'
name|'block_size'
newline|'\n'
name|'self'
op|'.'
name|'outMAC'
op|'='
name|'self'
op|'.'
name|'_getMAC'
op|'('
name|'self'
op|'.'
name|'outMACType'
op|','
name|'outInteg'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'inMAC'
op|'='
name|'self'
op|'.'
name|'_getMAC'
op|'('
name|'self'
op|'.'
name|'inMACType'
op|','
name|'inInteg'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'inMAC'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'verifyDigestSize'
op|'='
name|'self'
op|'.'
name|'inMAC'
op|'['
number|'3'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_getCipher
dedent|''
dedent|''
name|'def'
name|'_getCipher'
op|'('
name|'self'
op|','
name|'cip'
op|','
name|'iv'
op|','
name|'key'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Creates an initialized cipher object.\n\n        @param cip: the name of the cipher: maps into Crypto.Cipher.*\n        @param iv: the initialzation vector\n        @param key: the encryption key\n        """'
newline|'\n'
name|'modName'
op|','
name|'keySize'
op|','
name|'counterMode'
op|'='
name|'self'
op|'.'
name|'cipherMap'
op|'['
name|'cip'
op|']'
newline|'\n'
name|'if'
name|'not'
name|'modName'
op|':'
comment|'# no cipher'
newline|'\n'
indent|'            '
name|'return'
name|'_DummyCipher'
op|'('
op|')'
newline|'\n'
dedent|''
name|'mod'
op|'='
name|'__import__'
op|'('
string|"'Crypto.Cipher.%s'"
op|'%'
name|'modName'
op|','
op|'{'
op|'}'
op|','
op|'{'
op|'}'
op|','
string|"'x'"
op|')'
newline|'\n'
name|'if'
name|'counterMode'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'mod'
op|'.'
name|'new'
op|'('
name|'key'
op|'['
op|':'
name|'keySize'
op|']'
op|','
name|'mod'
op|'.'
name|'MODE_CTR'
op|','
name|'iv'
op|'['
op|':'
name|'mod'
op|'.'
name|'block_size'
op|']'
op|','
nl|'\n'
name|'counter'
op|'='
name|'_Counter'
op|'('
name|'iv'
op|','
name|'mod'
op|'.'
name|'block_size'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'mod'
op|'.'
name|'new'
op|'('
name|'key'
op|'['
op|':'
name|'keySize'
op|']'
op|','
name|'mod'
op|'.'
name|'MODE_CBC'
op|','
name|'iv'
op|'['
op|':'
name|'mod'
op|'.'
name|'block_size'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_getMAC
dedent|''
dedent|''
name|'def'
name|'_getMAC'
op|'('
name|'self'
op|','
name|'mac'
op|','
name|'key'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Gets a 4-tuple representing the message authentication code.\n        (<hash module>, <inner hash value>, <outer hash value>,\n        <digest size>)\n\n        @param mac: a key mapping into macMap\n        @type mac: C{str}\n        @param key: the MAC key.\n        @type key: C{str}\n        """'
newline|'\n'
name|'mod'
op|'='
name|'self'
op|'.'
name|'macMap'
op|'['
name|'mac'
op|']'
newline|'\n'
name|'if'
name|'not'
name|'mod'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'('
name|'None'
op|','
string|"''"
op|','
string|"''"
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'ds'
op|'='
name|'mod'
op|'('
op|')'
op|'.'
name|'digest_size'
newline|'\n'
name|'key'
op|'='
name|'key'
op|'['
op|':'
name|'ds'
op|']'
op|'+'
string|"'\\x00'"
op|'*'
op|'('
number|'64'
op|'-'
name|'ds'
op|')'
newline|'\n'
name|'i'
op|'='
name|'XOR'
op|'.'
name|'new'
op|'('
string|"'\\x36'"
op|')'
op|'.'
name|'encrypt'
op|'('
name|'key'
op|')'
newline|'\n'
name|'o'
op|'='
name|'XOR'
op|'.'
name|'new'
op|'('
string|"'\\x5c'"
op|')'
op|'.'
name|'encrypt'
op|'('
name|'key'
op|')'
newline|'\n'
name|'return'
name|'mod'
op|','
name|'i'
op|','
name|'o'
op|','
name|'ds'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|encrypt
dedent|''
name|'def'
name|'encrypt'
op|'('
name|'self'
op|','
name|'blocks'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Encrypt blocks.  Overridden by the encrypt method of a\n        Crypto.Cipher.* object in setKeys().\n\n        @type blocks: C{str}\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|decrypt
dedent|''
name|'def'
name|'decrypt'
op|'('
name|'self'
op|','
name|'blocks'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Decrypt blocks.  See encrypt().\n\n        @type blocks: C{str}\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|makeMAC
dedent|''
name|'def'
name|'makeMAC'
op|'('
name|'self'
op|','
name|'seqid'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a message authentication code (MAC) for the given packet using\n        the outgoing MAC values.\n\n        @param seqid: the sequence ID of the outgoing packet\n        @type seqid: C{int}\n        @param data: the data to create a MAC for\n        @type data: C{str}\n        @rtype: C{str}\n        """'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'outMAC'
op|'['
number|'0'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"''"
newline|'\n'
dedent|''
name|'data'
op|'='
name|'struct'
op|'.'
name|'pack'
op|'('
string|"'>L'"
op|','
name|'seqid'
op|')'
op|'+'
name|'data'
newline|'\n'
name|'mod'
op|','
name|'i'
op|','
name|'o'
op|','
name|'ds'
op|'='
name|'self'
op|'.'
name|'outMAC'
newline|'\n'
name|'inner'
op|'='
name|'mod'
op|'('
name|'i'
op|'+'
name|'data'
op|')'
newline|'\n'
name|'outer'
op|'='
name|'mod'
op|'('
name|'o'
op|'+'
name|'inner'
op|'.'
name|'digest'
op|'('
op|')'
op|')'
newline|'\n'
name|'return'
name|'outer'
op|'.'
name|'digest'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|verify
dedent|''
name|'def'
name|'verify'
op|'('
name|'self'
op|','
name|'seqid'
op|','
name|'data'
op|','
name|'mac'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify an incoming MAC using the incoming MAC values.  Return True\n        if the MAC is valid.\n\n        @param seqid: the sequence ID of the incoming packet\n        @type seqid: C{int}\n        @param data: the packet data to verify\n        @type data: C{str}\n        @param mac: the MAC sent with the packet\n        @type mac: C{str}\n        @rtype: C{bool}\n        """'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'inMAC'
op|'['
number|'0'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'mac'
op|'=='
string|"''"
newline|'\n'
dedent|''
name|'data'
op|'='
name|'struct'
op|'.'
name|'pack'
op|'('
string|"'>L'"
op|','
name|'seqid'
op|')'
op|'+'
name|'data'
newline|'\n'
name|'mod'
op|','
name|'i'
op|','
name|'o'
op|','
name|'ds'
op|'='
name|'self'
op|'.'
name|'inMAC'
newline|'\n'
name|'inner'
op|'='
name|'mod'
op|'('
name|'i'
op|'+'
name|'data'
op|')'
newline|'\n'
name|'outer'
op|'='
name|'mod'
op|'('
name|'o'
op|'+'
name|'inner'
op|'.'
name|'digest'
op|'('
op|')'
op|')'
newline|'\n'
name|'return'
name|'mac'
op|'=='
name|'outer'
op|'.'
name|'digest'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|_Counter
dedent|''
dedent|''
name|'class'
name|'_Counter'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Stateful counter which returns results packed in a byte string\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'initialVector'
op|','
name|'blockSize'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @type initialVector: C{str}\n        @param initialVector: A byte string representing the initial counter\n                              value.\n        @type blockSize: C{int}\n        @param blockSize: The length of the output buffer, as well as the\n        number of bytes at the beginning of C{initialVector} to consider.\n        """'
newline|'\n'
name|'initialVector'
op|'='
name|'initialVector'
op|'['
op|':'
name|'blockSize'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'count'
op|'='
name|'getMP'
op|'('
string|"'\\xff\\xff\\xff\\xff'"
op|'+'
name|'initialVector'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'blockSize'
op|'='
name|'blockSize'
newline|'\n'
name|'self'
op|'.'
name|'count'
op|'='
name|'Util'
op|'.'
name|'number'
op|'.'
name|'long_to_bytes'
op|'('
name|'self'
op|'.'
name|'count'
op|'-'
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'count'
op|'='
string|"'\\x00'"
op|'*'
op|'('
name|'self'
op|'.'
name|'blockSize'
op|'-'
name|'len'
op|'('
name|'self'
op|'.'
name|'count'
op|')'
op|')'
op|'+'
name|'self'
op|'.'
name|'count'
newline|'\n'
name|'self'
op|'.'
name|'count'
op|'='
name|'array'
op|'.'
name|'array'
op|'('
string|"'c'"
op|','
name|'self'
op|'.'
name|'count'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'len'
op|'='
name|'len'
op|'('
name|'self'
op|'.'
name|'count'
op|')'
op|'-'
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__call__
dedent|''
name|'def'
name|'__call__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Increment the counter and return the new value.\n        """'
newline|'\n'
name|'i'
op|'='
name|'self'
op|'.'
name|'len'
newline|'\n'
name|'while'
name|'i'
op|'>'
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'count'
op|'['
name|'i'
op|']'
op|'='
name|'n'
op|'='
name|'chr'
op|'('
op|'('
name|'ord'
op|'('
name|'self'
op|'.'
name|'count'
op|'['
name|'i'
op|']'
op|')'
op|'+'
number|'1'
op|')'
op|'%'
number|'256'
op|')'
newline|'\n'
name|'if'
name|'n'
op|'=='
string|"'\\x00'"
op|':'
newline|'\n'
indent|'                '
name|'i'
op|'-='
number|'1'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'self'
op|'.'
name|'count'
op|'.'
name|'tostring'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'count'
op|'='
name|'array'
op|'.'
name|'array'
op|'('
string|"'c'"
op|','
string|"'\\x00'"
op|'*'
name|'self'
op|'.'
name|'blockSize'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'count'
op|'.'
name|'tostring'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
comment|'# Diffie-Hellman primes from Oakley Group 2 [RFC 2409]'
nl|'\n'
DECL|variable|DH_PRIME
dedent|''
dedent|''
name|'DH_PRIME'
op|'='
name|'long'
op|'('
string|"'17976931348623159077083915679378745319786029604875601170644'"
nl|'\n'
string|"'442368419718021615851936894783379586492554150218056548598050364644054819923'"
nl|'\n'
string|"'910005079287700335581663922955313623907650873575991482257486257500742530207'"
nl|'\n'
string|"'744771258955095793777842444242661733472762929938766870920560605027081084290'"
nl|'\n'
string|"'7692932019128194467627007L'"
op|')'
newline|'\n'
DECL|variable|DH_GENERATOR
name|'DH_GENERATOR'
op|'='
number|'2L'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|variable|MSG_DISCONNECT
name|'MSG_DISCONNECT'
op|'='
number|'1'
newline|'\n'
DECL|variable|MSG_IGNORE
name|'MSG_IGNORE'
op|'='
number|'2'
newline|'\n'
DECL|variable|MSG_UNIMPLEMENTED
name|'MSG_UNIMPLEMENTED'
op|'='
number|'3'
newline|'\n'
DECL|variable|MSG_DEBUG
name|'MSG_DEBUG'
op|'='
number|'4'
newline|'\n'
DECL|variable|MSG_SERVICE_REQUEST
name|'MSG_SERVICE_REQUEST'
op|'='
number|'5'
newline|'\n'
DECL|variable|MSG_SERVICE_ACCEPT
name|'MSG_SERVICE_ACCEPT'
op|'='
number|'6'
newline|'\n'
DECL|variable|MSG_KEXINIT
name|'MSG_KEXINIT'
op|'='
number|'20'
newline|'\n'
DECL|variable|MSG_NEWKEYS
name|'MSG_NEWKEYS'
op|'='
number|'21'
newline|'\n'
DECL|variable|MSG_KEXDH_INIT
name|'MSG_KEXDH_INIT'
op|'='
number|'30'
newline|'\n'
DECL|variable|MSG_KEXDH_REPLY
name|'MSG_KEXDH_REPLY'
op|'='
number|'31'
newline|'\n'
DECL|variable|MSG_KEX_DH_GEX_REQUEST_OLD
name|'MSG_KEX_DH_GEX_REQUEST_OLD'
op|'='
number|'30'
newline|'\n'
DECL|variable|MSG_KEX_DH_GEX_REQUEST
name|'MSG_KEX_DH_GEX_REQUEST'
op|'='
number|'34'
newline|'\n'
DECL|variable|MSG_KEX_DH_GEX_GROUP
name|'MSG_KEX_DH_GEX_GROUP'
op|'='
number|'31'
newline|'\n'
DECL|variable|MSG_KEX_DH_GEX_INIT
name|'MSG_KEX_DH_GEX_INIT'
op|'='
number|'32'
newline|'\n'
DECL|variable|MSG_KEX_DH_GEX_REPLY
name|'MSG_KEX_DH_GEX_REPLY'
op|'='
number|'33'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|variable|DISCONNECT_HOST_NOT_ALLOWED_TO_CONNECT
name|'DISCONNECT_HOST_NOT_ALLOWED_TO_CONNECT'
op|'='
number|'1'
newline|'\n'
DECL|variable|DISCONNECT_PROTOCOL_ERROR
name|'DISCONNECT_PROTOCOL_ERROR'
op|'='
number|'2'
newline|'\n'
DECL|variable|DISCONNECT_KEY_EXCHANGE_FAILED
name|'DISCONNECT_KEY_EXCHANGE_FAILED'
op|'='
number|'3'
newline|'\n'
DECL|variable|DISCONNECT_RESERVED
name|'DISCONNECT_RESERVED'
op|'='
number|'4'
newline|'\n'
DECL|variable|DISCONNECT_MAC_ERROR
name|'DISCONNECT_MAC_ERROR'
op|'='
number|'5'
newline|'\n'
DECL|variable|DISCONNECT_COMPRESSION_ERROR
name|'DISCONNECT_COMPRESSION_ERROR'
op|'='
number|'6'
newline|'\n'
DECL|variable|DISCONNECT_SERVICE_NOT_AVAILABLE
name|'DISCONNECT_SERVICE_NOT_AVAILABLE'
op|'='
number|'7'
newline|'\n'
DECL|variable|DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED
name|'DISCONNECT_PROTOCOL_VERSION_NOT_SUPPORTED'
op|'='
number|'8'
newline|'\n'
DECL|variable|DISCONNECT_HOST_KEY_NOT_VERIFIABLE
name|'DISCONNECT_HOST_KEY_NOT_VERIFIABLE'
op|'='
number|'9'
newline|'\n'
DECL|variable|DISCONNECT_CONNECTION_LOST
name|'DISCONNECT_CONNECTION_LOST'
op|'='
number|'10'
newline|'\n'
DECL|variable|DISCONNECT_BY_APPLICATION
name|'DISCONNECT_BY_APPLICATION'
op|'='
number|'11'
newline|'\n'
DECL|variable|DISCONNECT_TOO_MANY_CONNECTIONS
name|'DISCONNECT_TOO_MANY_CONNECTIONS'
op|'='
number|'12'
newline|'\n'
DECL|variable|DISCONNECT_AUTH_CANCELLED_BY_USER
name|'DISCONNECT_AUTH_CANCELLED_BY_USER'
op|'='
number|'13'
newline|'\n'
DECL|variable|DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE
name|'DISCONNECT_NO_MORE_AUTH_METHODS_AVAILABLE'
op|'='
number|'14'
newline|'\n'
DECL|variable|DISCONNECT_ILLEGAL_USER_NAME
name|'DISCONNECT_ILLEGAL_USER_NAME'
op|'='
number|'15'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|variable|messages
name|'messages'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'name'
op|','
name|'value'
name|'in'
name|'globals'
op|'('
op|')'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'name'
op|'.'
name|'startswith'
op|'('
string|"'MSG_'"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'messages'
op|'['
name|'value'
op|']'
op|'='
name|'name'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
