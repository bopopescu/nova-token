begin_unit
comment|'# -*- test-case-name: twisted.conch.test.test_knownhosts -*-'
nl|'\n'
comment|'# Copyright (c) 2008-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nAn implementation of the OpenSSH known_hosts database.\n\n@since: 8.2\n"""'
newline|'\n'
nl|'\n'
name|'from'
name|'binascii'
name|'import'
name|'Error'
name|'as'
name|'DecodeError'
op|','
name|'b2a_base64'
newline|'\n'
nl|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'implements'
newline|'\n'
nl|'\n'
name|'from'
name|'Crypto'
op|'.'
name|'Hash'
op|'.'
name|'HMAC'
name|'import'
name|'HMAC'
newline|'\n'
name|'from'
name|'Crypto'
op|'.'
name|'Hash'
name|'import'
name|'SHA'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'randbytes'
name|'import'
name|'secureRandom'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'defer'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'log'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'conch'
op|'.'
name|'interfaces'
name|'import'
name|'IKnownHostEntry'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'conch'
op|'.'
name|'error'
name|'import'
name|'HostKeyChanged'
op|','
name|'UserRejectedKey'
op|','
name|'InvalidEntry'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'conch'
op|'.'
name|'ssh'
op|'.'
name|'keys'
name|'import'
name|'Key'
op|','
name|'BadKeyError'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_b64encode
name|'def'
name|'_b64encode'
op|'('
name|'s'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Encode a binary string as base64 with no trailing newline.\n    """'
newline|'\n'
name|'return'
name|'b2a_base64'
op|'('
name|'s'
op|')'
op|'.'
name|'strip'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|_extractCommon
dedent|''
name|'def'
name|'_extractCommon'
op|'('
name|'string'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Extract common elements of base64 keys from an entry in a hosts file.\n\n    @return: a 4-tuple of hostname data (L{str}), ssh key type (L{str}), key\n    (L{Key}), and comment (L{str} or L{None}).  The hostname data is simply the\n    beginning of the line up to the first occurrence of whitespace.\n    """'
newline|'\n'
name|'elements'
op|'='
name|'string'
op|'.'
name|'split'
op|'('
name|'None'
op|','
number|'2'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'elements'
op|')'
op|'!='
number|'3'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'InvalidEntry'
op|'('
op|')'
newline|'\n'
dedent|''
name|'hostnames'
op|','
name|'keyType'
op|','
name|'keyAndComment'
op|'='
name|'elements'
newline|'\n'
name|'splitkey'
op|'='
name|'keyAndComment'
op|'.'
name|'split'
op|'('
name|'None'
op|','
number|'1'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'splitkey'
op|')'
op|'=='
number|'2'
op|':'
newline|'\n'
indent|'        '
name|'keyString'
op|','
name|'comment'
op|'='
name|'splitkey'
newline|'\n'
name|'comment'
op|'='
name|'comment'
op|'.'
name|'rstrip'
op|'('
string|'"\\n"'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'keyString'
op|'='
name|'splitkey'
op|'['
number|'0'
op|']'
newline|'\n'
name|'comment'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'key'
op|'='
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'keyString'
op|'.'
name|'decode'
op|'('
string|"'base64'"
op|')'
op|')'
newline|'\n'
name|'return'
name|'hostnames'
op|','
name|'keyType'
op|','
name|'key'
op|','
name|'comment'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|_BaseEntry
dedent|''
name|'class'
name|'_BaseEntry'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Abstract base of both hashed and non-hashed entry objects, since they\n    represent keys and key types the same way.\n\n    @ivar keyType: The type of the key; either ssh-dss or ssh-rsa.\n    @type keyType: L{str}\n\n    @ivar publicKey: The server public key indicated by this line.\n    @type publicKey: L{twisted.conch.ssh.keys.Key}\n\n    @ivar comment: Trailing garbage after the key line.\n    @type comment: L{str}\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'keyType'
op|','
name|'publicKey'
op|','
name|'comment'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'keyType'
op|'='
name|'keyType'
newline|'\n'
name|'self'
op|'.'
name|'publicKey'
op|'='
name|'publicKey'
newline|'\n'
name|'self'
op|'.'
name|'comment'
op|'='
name|'comment'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|matchesKey
dedent|''
name|'def'
name|'matchesKey'
op|'('
name|'self'
op|','
name|'keyObject'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check to see if this entry matches a given key object.\n\n        @type keyObject: L{Key}\n\n        @rtype: bool\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'publicKey'
op|'=='
name|'keyObject'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|PlainEntry
dedent|''
dedent|''
name|'class'
name|'PlainEntry'
op|'('
name|'_BaseEntry'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A L{PlainEntry} is a representation of a plain-text entry in a known_hosts\n    file.\n\n    @ivar _hostnames: the list of all host-names associated with this entry.\n    @type _hostnames: L{list} of L{str}\n    """'
newline|'\n'
nl|'\n'
name|'implements'
op|'('
name|'IKnownHostEntry'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'hostnames'
op|','
name|'keyType'
op|','
name|'publicKey'
op|','
name|'comment'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_hostnames'
op|'='
name|'hostnames'
newline|'\n'
name|'super'
op|'('
name|'PlainEntry'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'keyType'
op|','
name|'publicKey'
op|','
name|'comment'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|fromString
dedent|''
name|'def'
name|'fromString'
op|'('
name|'cls'
op|','
name|'string'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Parse a plain-text entry in a known_hosts file, and return a\n        corresponding L{PlainEntry}.\n\n        @param string: a space-separated string formatted like "hostname\n        key-type base64-key-data comment".\n\n        @type string: L{str}\n\n        @raise DecodeError: if the key is not valid encoded as valid base64.\n\n        @raise InvalidEntry: if the entry does not have the right number of\n        elements and is therefore invalid.\n\n        @raise BadKeyError: if the key, once decoded from base64, is not\n        actually an SSH key.\n\n        @return: an IKnownHostEntry representing the hostname and key in the\n        input line.\n\n        @rtype: L{PlainEntry}\n        """'
newline|'\n'
name|'hostnames'
op|','
name|'keyType'
op|','
name|'key'
op|','
name|'comment'
op|'='
name|'_extractCommon'
op|'('
name|'string'
op|')'
newline|'\n'
name|'self'
op|'='
name|'cls'
op|'('
name|'hostnames'
op|'.'
name|'split'
op|'('
string|'","'
op|')'
op|','
name|'keyType'
op|','
name|'key'
op|','
name|'comment'
op|')'
newline|'\n'
name|'return'
name|'self'
newline|'\n'
nl|'\n'
DECL|variable|fromString
dedent|''
name|'fromString'
op|'='
name|'classmethod'
op|'('
name|'fromString'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|matchesHost
name|'def'
name|'matchesHost'
op|'('
name|'self'
op|','
name|'hostname'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check to see if this entry matches a given hostname.\n\n        @type hostname: L{str}\n\n        @rtype: bool\n        """'
newline|'\n'
name|'return'
name|'hostname'
name|'in'
name|'self'
op|'.'
name|'_hostnames'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|toString
dedent|''
name|'def'
name|'toString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Implement L{IKnownHostEntry.toString} by recording the comma-separated\n        hostnames, key type, and base-64 encoded key.\n        """'
newline|'\n'
name|'fields'
op|'='
op|'['
string|"','"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'_hostnames'
op|')'
op|','
nl|'\n'
name|'self'
op|'.'
name|'keyType'
op|','
nl|'\n'
name|'_b64encode'
op|'('
name|'self'
op|'.'
name|'publicKey'
op|'.'
name|'blob'
op|'('
op|')'
op|')'
op|']'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'comment'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'fields'
op|'.'
name|'append'
op|'('
name|'self'
op|'.'
name|'comment'
op|')'
newline|'\n'
dedent|''
name|'return'
string|"' '"
op|'.'
name|'join'
op|'('
name|'fields'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|UnparsedEntry
dedent|''
dedent|''
name|'class'
name|'UnparsedEntry'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    L{UnparsedEntry} is an entry in a L{KnownHostsFile} which can\'t actually be\n    parsed; therefore it matches no keys and no hosts.\n    """'
newline|'\n'
nl|'\n'
name|'implements'
op|'('
name|'IKnownHostEntry'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'string'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create an unparsed entry from a line in a known_hosts file which cannot\n        otherwise be parsed.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_string'
op|'='
name|'string'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|matchesHost
dedent|''
name|'def'
name|'matchesHost'
op|'('
name|'self'
op|','
name|'hostname'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Always returns False.\n        """'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|matchesKey
dedent|''
name|'def'
name|'matchesKey'
op|'('
name|'self'
op|','
name|'key'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Always returns False.\n        """'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|toString
dedent|''
name|'def'
name|'toString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns the input line, without its newline if one was given.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_string'
op|'.'
name|'rstrip'
op|'('
string|'"\\n"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|_hmacedString
dedent|''
dedent|''
name|'def'
name|'_hmacedString'
op|'('
name|'key'
op|','
name|'string'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Return the SHA-1 HMAC hash of the given key and string.\n    """'
newline|'\n'
name|'hash'
op|'='
name|'HMAC'
op|'('
name|'key'
op|','
name|'digestmod'
op|'='
name|'SHA'
op|')'
newline|'\n'
name|'hash'
op|'.'
name|'update'
op|'('
name|'string'
op|')'
newline|'\n'
name|'return'
name|'hash'
op|'.'
name|'digest'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|HashedEntry
dedent|''
name|'class'
name|'HashedEntry'
op|'('
name|'_BaseEntry'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A L{HashedEntry} is a representation of an entry in a known_hosts file\n    where the hostname has been hashed and salted.\n\n    @ivar _hostSalt: the salt to combine with a hostname for hashing.\n\n    @ivar _hostHash: the hashed representation of the hostname.\n\n    @cvar MAGIC: the \'hash magic\' string used to identify a hashed line in a\n    known_hosts file as opposed to a plaintext one.\n    """'
newline|'\n'
nl|'\n'
name|'implements'
op|'('
name|'IKnownHostEntry'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|MAGIC
name|'MAGIC'
op|'='
string|"'|1|'"
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'hostSalt'
op|','
name|'hostHash'
op|','
name|'keyType'
op|','
name|'publicKey'
op|','
name|'comment'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_hostSalt'
op|'='
name|'hostSalt'
newline|'\n'
name|'self'
op|'.'
name|'_hostHash'
op|'='
name|'hostHash'
newline|'\n'
name|'super'
op|'('
name|'HashedEntry'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'keyType'
op|','
name|'publicKey'
op|','
name|'comment'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|fromString
dedent|''
name|'def'
name|'fromString'
op|'('
name|'cls'
op|','
name|'string'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Load a hashed entry from a string representing a line in a known_hosts\n        file.\n\n        @raise DecodeError: if the key, the hostname, or the is not valid\n        encoded as valid base64\n\n        @raise InvalidEntry: if the entry does not have the right number of\n        elements and is therefore invalid, or the host/hash portion contains\n        more items than just the host and hash.\n\n        @raise BadKeyError: if the key, once decoded from base64, is not\n        actually an SSH key.\n        """'
newline|'\n'
name|'stuff'
op|','
name|'keyType'
op|','
name|'key'
op|','
name|'comment'
op|'='
name|'_extractCommon'
op|'('
name|'string'
op|')'
newline|'\n'
name|'saltAndHash'
op|'='
name|'stuff'
op|'['
name|'len'
op|'('
name|'cls'
op|'.'
name|'MAGIC'
op|')'
op|':'
op|']'
op|'.'
name|'split'
op|'('
string|'"|"'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'saltAndHash'
op|')'
op|'!='
number|'2'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'InvalidEntry'
op|'('
op|')'
newline|'\n'
dedent|''
name|'hostSalt'
op|','
name|'hostHash'
op|'='
name|'saltAndHash'
newline|'\n'
name|'self'
op|'='
name|'cls'
op|'('
name|'hostSalt'
op|'.'
name|'decode'
op|'('
string|'"base64"'
op|')'
op|','
name|'hostHash'
op|'.'
name|'decode'
op|'('
string|'"base64"'
op|')'
op|','
nl|'\n'
name|'keyType'
op|','
name|'key'
op|','
name|'comment'
op|')'
newline|'\n'
name|'return'
name|'self'
newline|'\n'
nl|'\n'
DECL|variable|fromString
dedent|''
name|'fromString'
op|'='
name|'classmethod'
op|'('
name|'fromString'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|matchesHost
name|'def'
name|'matchesHost'
op|'('
name|'self'
op|','
name|'hostname'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Implement L{IKnownHostEntry.matchesHost} to compare the hash of the\n        input to the stored hash.\n        """'
newline|'\n'
name|'return'
op|'('
name|'_hmacedString'
op|'('
name|'self'
op|'.'
name|'_hostSalt'
op|','
name|'hostname'
op|')'
op|'=='
name|'self'
op|'.'
name|'_hostHash'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|toString
dedent|''
name|'def'
name|'toString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Implement L{IKnownHostEntry.toString} by base64-encoding the salt, host\n        hash, and key.\n        """'
newline|'\n'
name|'fields'
op|'='
op|'['
name|'self'
op|'.'
name|'MAGIC'
op|'+'
string|"'|'"
op|'.'
name|'join'
op|'('
op|'['
name|'_b64encode'
op|'('
name|'self'
op|'.'
name|'_hostSalt'
op|')'
op|','
nl|'\n'
name|'_b64encode'
op|'('
name|'self'
op|'.'
name|'_hostHash'
op|')'
op|']'
op|')'
op|','
nl|'\n'
name|'self'
op|'.'
name|'keyType'
op|','
nl|'\n'
name|'_b64encode'
op|'('
name|'self'
op|'.'
name|'publicKey'
op|'.'
name|'blob'
op|'('
op|')'
op|')'
op|']'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'comment'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'fields'
op|'.'
name|'append'
op|'('
name|'self'
op|'.'
name|'comment'
op|')'
newline|'\n'
dedent|''
name|'return'
string|"' '"
op|'.'
name|'join'
op|'('
name|'fields'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|KnownHostsFile
dedent|''
dedent|''
name|'class'
name|'KnownHostsFile'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A structured representation of an OpenSSH-format ~/.ssh/known_hosts file.\n\n    @ivar _entries: a list of L{IKnownHostEntry} providers.\n\n    @ivar _savePath: the L{FilePath} to save new entries to.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'savePath'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a new, empty KnownHostsFile.\n\n        You want to use L{KnownHostsFile.fromPath} to parse one of these.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_entries'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_savePath'
op|'='
name|'savePath'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|hasHostKey
dedent|''
name|'def'
name|'hasHostKey'
op|'('
name|'self'
op|','
name|'hostname'
op|','
name|'key'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @return: True if the given hostname and key are present in this file,\n        False if they are not.\n\n        @rtype: L{bool}\n\n        @raise HostKeyChanged: if the host key found for the given hostname\n        does not match the given key.\n        """'
newline|'\n'
name|'for'
name|'lineidx'
op|','
name|'entry'
name|'in'
name|'enumerate'
op|'('
name|'self'
op|'.'
name|'_entries'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'entry'
op|'.'
name|'matchesHost'
op|'('
name|'hostname'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'entry'
op|'.'
name|'matchesKey'
op|'('
name|'key'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'HostKeyChanged'
op|'('
name|'entry'
op|','
name|'self'
op|'.'
name|'_savePath'
op|','
name|'lineidx'
op|'+'
number|'1'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|verifyHostKey
dedent|''
name|'def'
name|'verifyHostKey'
op|'('
name|'self'
op|','
name|'ui'
op|','
name|'hostname'
op|','
name|'ip'
op|','
name|'key'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify the given host key for the given IP and host, asking for\n        confirmation from, and notifying, the given UI about changes to this\n        file.\n\n        @param ui: The user interface to request an IP address from.\n\n        @param hostname: The hostname that the user requested to connect to.\n\n        @param ip: The string representation of the IP address that is actually\n        being connected to.\n\n        @param key: The public key of the server.\n\n        @return: a L{Deferred} that fires with True when the key has been\n        verified, or fires with an errback when the key either cannot be\n        verified or has changed.\n\n        @rtype: L{Deferred}\n        """'
newline|'\n'
name|'hhk'
op|'='
name|'defer'
op|'.'
name|'maybeDeferred'
op|'('
name|'self'
op|'.'
name|'hasHostKey'
op|','
name|'hostname'
op|','
name|'key'
op|')'
newline|'\n'
DECL|function|gotHasKey
name|'def'
name|'gotHasKey'
op|'('
name|'result'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'result'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'not'
name|'self'
op|'.'
name|'hasHostKey'
op|'('
name|'ip'
op|','
name|'key'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'ui'
op|'.'
name|'warn'
op|'('
string|'"Warning: Permanently added the %s host key for "'
nl|'\n'
string|'"IP address \'%s\' to the list of known hosts."'
op|'%'
nl|'\n'
op|'('
name|'key'
op|'.'
name|'type'
op|'('
op|')'
op|','
name|'ip'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addHostKey'
op|'('
name|'ip'
op|','
name|'key'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'save'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
DECL|function|promptResponse
indent|'                '
name|'def'
name|'promptResponse'
op|'('
name|'response'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'response'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'addHostKey'
op|'('
name|'hostname'
op|','
name|'key'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addHostKey'
op|'('
name|'ip'
op|','
name|'key'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'save'
op|'('
op|')'
newline|'\n'
name|'return'
name|'response'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
name|'UserRejectedKey'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'ui'
op|'.'
name|'prompt'
op|'('
nl|'\n'
string|'"The authenticity of host \'%s (%s)\' "'
nl|'\n'
string|'"can\'t be established.\\n"'
nl|'\n'
string|'"RSA key fingerprint is %s.\\n"'
nl|'\n'
string|'"Are you sure you want to continue connecting (yes/no)? "'
op|'%'
nl|'\n'
op|'('
name|'hostname'
op|','
name|'ip'
op|','
name|'key'
op|'.'
name|'fingerprint'
op|'('
op|')'
op|')'
op|')'
op|'.'
name|'addCallback'
op|'('
name|'promptResponse'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'hhk'
op|'.'
name|'addCallback'
op|'('
name|'gotHasKey'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|addHostKey
dedent|''
name|'def'
name|'addHostKey'
op|'('
name|'self'
op|','
name|'hostname'
op|','
name|'key'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Add a new L{HashedEntry} to the key database.\n\n        Note that you still need to call L{KnownHostsFile.save} if you wish\n        these changes to be persisted.\n\n        @return: the L{HashedEntry} that was added.\n        """'
newline|'\n'
name|'salt'
op|'='
name|'secureRandom'
op|'('
number|'20'
op|')'
newline|'\n'
name|'keyType'
op|'='
string|'"ssh-"'
op|'+'
name|'key'
op|'.'
name|'type'
op|'('
op|')'
op|'.'
name|'lower'
op|'('
op|')'
newline|'\n'
name|'entry'
op|'='
name|'HashedEntry'
op|'('
name|'salt'
op|','
name|'_hmacedString'
op|'('
name|'salt'
op|','
name|'hostname'
op|')'
op|','
nl|'\n'
name|'keyType'
op|','
name|'key'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_entries'
op|'.'
name|'append'
op|'('
name|'entry'
op|')'
newline|'\n'
name|'return'
name|'entry'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|save
dedent|''
name|'def'
name|'save'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Save this L{KnownHostsFile} to the path it was loaded from.\n        """'
newline|'\n'
name|'p'
op|'='
name|'self'
op|'.'
name|'_savePath'
op|'.'
name|'parent'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
name|'p'
op|'.'
name|'isdir'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'p'
op|'.'
name|'makedirs'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_savePath'
op|'.'
name|'setContent'
op|'('
string|"'\\n'"
op|'.'
name|'join'
op|'('
nl|'\n'
op|'['
name|'entry'
op|'.'
name|'toString'
op|'('
op|')'
name|'for'
name|'entry'
name|'in'
name|'self'
op|'.'
name|'_entries'
op|']'
op|')'
op|'+'
string|'"\\n"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|fromPath
dedent|''
name|'def'
name|'fromPath'
op|'('
name|'cls'
op|','
name|'path'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @param path: A path object to use for both reading contents from and\n        later saving to.\n\n        @type path: L{FilePath}\n        """'
newline|'\n'
name|'self'
op|'='
name|'cls'
op|'('
name|'path'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'fp'
op|'='
name|'path'
op|'.'
name|'open'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'IOError'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
newline|'\n'
dedent|''
name|'for'
name|'line'
name|'in'
name|'fp'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'line'
op|'.'
name|'startswith'
op|'('
name|'HashedEntry'
op|'.'
name|'MAGIC'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'entry'
op|'='
name|'HashedEntry'
op|'.'
name|'fromString'
op|'('
name|'line'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'entry'
op|'='
name|'PlainEntry'
op|'.'
name|'fromString'
op|'('
name|'line'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'DecodeError'
op|','
name|'InvalidEntry'
op|','
name|'BadKeyError'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'entry'
op|'='
name|'UnparsedEntry'
op|'('
name|'line'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_entries'
op|'.'
name|'append'
op|'('
name|'entry'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
newline|'\n'
nl|'\n'
DECL|variable|fromPath
dedent|''
name|'fromPath'
op|'='
name|'classmethod'
op|'('
name|'fromPath'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ConsoleUI
dedent|''
name|'class'
name|'ConsoleUI'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A UI object that can ask true/false questions and post notifications on the\n    console, to be used during key verification.\n\n    @ivar opener: a no-argument callable which should open a console file-like\n    object to be used for reading and writing.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'opener'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'opener'
op|'='
name|'opener'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|prompt
dedent|''
name|'def'
name|'prompt'
op|'('
name|'self'
op|','
name|'text'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write the given text as a prompt to the console output, then read a\n        result from the console input.\n\n        @return: a L{Deferred} which fires with L{True} when the user answers\n        \'yes\' and L{False} when the user answers \'no\'.  It may errback if there\n        were any I/O errors.\n        """'
newline|'\n'
name|'d'
op|'='
name|'defer'
op|'.'
name|'succeed'
op|'('
name|'None'
op|')'
newline|'\n'
DECL|function|body
name|'def'
name|'body'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'='
name|'self'
op|'.'
name|'opener'
op|'('
op|')'
newline|'\n'
name|'f'
op|'.'
name|'write'
op|'('
name|'text'
op|')'
newline|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'                '
name|'answer'
op|'='
name|'f'
op|'.'
name|'readline'
op|'('
op|')'
op|'.'
name|'strip'
op|'('
op|')'
op|'.'
name|'lower'
op|'('
op|')'
newline|'\n'
name|'if'
name|'answer'
op|'=='
string|"'yes'"
op|':'
newline|'\n'
indent|'                    '
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'elif'
name|'answer'
op|'=='
string|"'no'"
op|':'
newline|'\n'
indent|'                    '
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'f'
op|'.'
name|'write'
op|'('
string|'"Please type \'yes\' or \'no\': "'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'body'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|warn
dedent|''
name|'def'
name|'warn'
op|'('
name|'self'
op|','
name|'text'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Notify the user (non-interactively) of the provided text, by writing it\n        to the console.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'='
name|'self'
op|'.'
name|'opener'
op|'('
op|')'
newline|'\n'
name|'f'
op|'.'
name|'write'
op|'('
name|'text'
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'log'
op|'.'
name|'err'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
