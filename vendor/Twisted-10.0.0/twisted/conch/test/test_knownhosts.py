begin_unit
comment|'# Copyright (c) 2008 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTests for L{twisted.conch.client.knownhosts}.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'os'
newline|'\n'
name|'from'
name|'binascii'
name|'import'
name|'Error'
name|'as'
name|'BinasciiError'
op|','
name|'b2a_base64'
op|','
name|'a2b_base64'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'import'
name|'Crypto'
newline|'\n'
name|'import'
name|'pyasn1'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
DECL|variable|skip
indent|'    '
name|'skip'
op|'='
string|'"PyCrypto and PyASN1 required for twisted.conch.knownhosts."'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'    '
name|'from'
name|'twisted'
op|'.'
name|'conch'
op|'.'
name|'ssh'
op|'.'
name|'keys'
name|'import'
name|'Key'
op|','
name|'BadKeyError'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'conch'
op|'.'
name|'client'
op|'.'
name|'knownhosts'
name|'import'
name|'PlainEntry'
op|','
name|'HashedEntry'
op|','
name|'KnownHostsFile'
op|','
name|'UnparsedEntry'
op|','
name|'ConsoleUI'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'conch'
op|'.'
name|'client'
name|'import'
name|'default'
newline|'\n'
nl|'\n'
dedent|''
name|'from'
name|'zope'
op|'.'
name|'interface'
op|'.'
name|'verify'
name|'import'
name|'verifyObject'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'filepath'
name|'import'
name|'FilePath'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
op|'.'
name|'unittest'
name|'import'
name|'TestCase'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'defer'
name|'import'
name|'Deferred'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'conch'
op|'.'
name|'interfaces'
name|'import'
name|'IKnownHostEntry'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'conch'
op|'.'
name|'error'
name|'import'
name|'HostKeyChanged'
op|','
name|'UserRejectedKey'
op|','
name|'InvalidEntry'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|sampleEncodedKey
name|'sampleEncodedKey'
op|'='
op|'('
nl|'\n'
string|"'AAAAB3NzaC1yc2EAAAABIwAAAQEAsV0VMRbGmzhqxxayLRHmvnFvtyNqgbNKV46dU1bVFB+3y'"
nl|'\n'
string|"'tNvue4Riqv/SVkPRNwMb7eWH29SviXaBxUhYyzKkDoNUq3rTNnH1Vnif6d6X4JCrUb5d3W+Dm'"
nl|'\n'
string|"'YClyJrZ5HgD/hUpdSkTRqdbQ2TrvSAxRacj+vHHT4F4dm1bJSewm3B2D8HVOoi/CbVh3dsIiC'"
nl|'\n'
string|"'dp8VltdZx4qYVfYe2LwVINCbAa3d3tj9ma7RVfw3OH2Mfb+toLd1N5tBQFb7oqTt2nC6I/6Bd'"
nl|'\n'
string|"'4JwPUld+IEitw/suElq/AIJVQXXujeyiZlea90HE65U2mF1ytr17HTAIT2ySokJWyuBANGACk'"
nl|'\n'
string|"'6iIaw=='"
op|')'
newline|'\n'
nl|'\n'
DECL|variable|otherSampleEncodedKey
name|'otherSampleEncodedKey'
op|'='
op|'('
nl|'\n'
string|"'AAAAB3NzaC1yc2EAAAABIwAAAIEAwaeCZd3UCuPXhX39+/p9qO028jTF76DMVd9mPvYVDVXuf'"
nl|'\n'
string|"'WckKZauF7+0b7qm+ChT7kan6BzRVo4++gCVNfAlMzLysSt3ylmOR48tFpAfygg9UCX3DjHz0E'"
nl|'\n'
string|"'lOOUKh3iifc9aUShD0OPaK3pR5JJ8jfiBfzSYWt/hDi/iZ4igsSs8='"
op|')'
newline|'\n'
nl|'\n'
DECL|variable|thirdSampleEncodedKey
name|'thirdSampleEncodedKey'
op|'='
op|'('
nl|'\n'
string|"'AAAAB3NzaC1yc2EAAAABIwAAAQEAl/TQakPkePlnwCBRPitIVUTg6Z8VzN1en+DGkyo/evkmLw'"
nl|'\n'
string|"'7o4NWR5qbysk9A9jXW332nxnEuAnbcCam9SHe1su1liVfyIK0+3bdn0YRB0sXIbNEtMs2LtCho'"
nl|'\n'
string|"'/aV3cXPS+Cf1yut3wvIpaRnAzXxuKPCTXQ7/y0IXa8TwkRBH58OJa3RqfQ/NsSp5SAfdsrHyH2'"
nl|'\n'
string|"'aitiVKm2jfbTKzSEqOQG/zq4J9GXTkq61gZugory/Tvl5/yPgSnOR6C9jVOMHf27ZPoRtyj9SY'"
nl|'\n'
string|"'343Hd2QHiIE0KPZJEgCynKeWoKz8v6eTSK8n4rBnaqWdp8MnGZK1WGy05MguXbyCDuTC8AmJXQ'"
nl|'\n'
string|"'=='"
op|')'
newline|'\n'
nl|'\n'
DECL|variable|sampleKey
name|'sampleKey'
op|'='
name|'a2b_base64'
op|'('
name|'sampleEncodedKey'
op|')'
newline|'\n'
DECL|variable|otherSampleKey
name|'otherSampleKey'
op|'='
name|'a2b_base64'
op|'('
name|'otherSampleEncodedKey'
op|')'
newline|'\n'
DECL|variable|thirdSampleKey
name|'thirdSampleKey'
op|'='
name|'a2b_base64'
op|'('
name|'thirdSampleEncodedKey'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|samplePlaintextLine
name|'samplePlaintextLine'
op|'='
op|'('
nl|'\n'
string|'"www.twistedmatrix.com ssh-rsa "'
op|'+'
name|'sampleEncodedKey'
op|'+'
string|'"\\n"'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|otherSamplePlaintextLine
name|'otherSamplePlaintextLine'
op|'='
op|'('
nl|'\n'
string|'"divmod.com ssh-rsa "'
op|'+'
name|'otherSampleEncodedKey'
op|'+'
string|'"\\n"'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|sampleHostIPLine
name|'sampleHostIPLine'
op|'='
op|'('
nl|'\n'
string|'"www.twistedmatrix.com,198.49.126.131 ssh-rsa "'
op|'+'
name|'sampleEncodedKey'
op|'+'
string|'"\\n"'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|sampleHashedLine
name|'sampleHashedLine'
op|'='
op|'('
nl|'\n'
string|'"|1|gJbSEPBG9ZSBoZpHNtZBD1bHKBA=|bQv+0Xa0dByrwkA1EB0E7Xop/Fo= ssh-rsa "'
op|'+'
nl|'\n'
name|'sampleEncodedKey'
op|'+'
string|'"\\n"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|EntryTestsMixin
name|'class'
name|'EntryTestsMixin'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for implementations of L{IKnownHostEntry}.  Subclasses must set the\n    \'entry\' attribute to a provider of that interface, the implementation of\n    that interface under test.\n\n    @ivar entry: a provider of L{IKnownHostEntry} with a hostname of\n    www.twistedmatrix.com and an RSA key of sampleKey.\n    """'
newline|'\n'
nl|'\n'
DECL|member|test_providesInterface
name|'def'
name|'test_providesInterface'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The given entry should provide IKnownHostEntry.\n        """'
newline|'\n'
name|'verifyObject'
op|'('
name|'IKnownHostEntry'
op|','
name|'self'
op|'.'
name|'entry'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_fromString
dedent|''
name|'def'
name|'test_fromString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Constructing a plain text entry from an unhashed known_hosts entry will\n        result in an L{IKnownHostEntry} provider with \'keyString\', \'hostname\',\n        and \'keyType\' attributes.  While outside the interface in question,\n        these attributes are held in common by L{PlainEntry} and L{HashedEntry}\n        implementations; other implementations should override this method in\n        subclasses.\n        """'
newline|'\n'
name|'entry'
op|'='
name|'self'
op|'.'
name|'entry'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'entry'
op|'.'
name|'publicKey'
op|','
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'sampleKey'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'entry'
op|'.'
name|'keyType'
op|','
string|'"ssh-rsa"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_matchesKey
dedent|''
name|'def'
name|'test_matchesKey'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{IKnownHostEntry.matchesKey} checks to see if an entry matches a given\n        SSH key.\n        """'
newline|'\n'
name|'twistedmatrixDotCom'
op|'='
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'sampleKey'
op|')'
newline|'\n'
name|'divmodDotCom'
op|'='
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'otherSampleKey'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'True'
op|','
nl|'\n'
name|'self'
op|'.'
name|'entry'
op|'.'
name|'matchesKey'
op|'('
name|'twistedmatrixDotCom'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'False'
op|','
nl|'\n'
name|'self'
op|'.'
name|'entry'
op|'.'
name|'matchesKey'
op|'('
name|'divmodDotCom'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_matchesHost
dedent|''
name|'def'
name|'test_matchesHost'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{IKnownHostEntry.matchesHost} checks to see if an entry matches a\n        given hostname.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'True'
op|','
name|'self'
op|'.'
name|'entry'
op|'.'
name|'matchesHost'
op|'('
nl|'\n'
string|'"www.twistedmatrix.com"'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'False'
op|','
name|'self'
op|'.'
name|'entry'
op|'.'
name|'matchesHost'
op|'('
nl|'\n'
string|'"www.divmod.com"'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|PlainEntryTests
dedent|''
dedent|''
name|'class'
name|'PlainEntryTests'
op|'('
name|'EntryTestsMixin'
op|','
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test cases for L{PlainEntry}.\n    """'
newline|'\n'
DECL|variable|plaintextLine
name|'plaintextLine'
op|'='
name|'samplePlaintextLine'
newline|'\n'
DECL|variable|hostIPLine
name|'hostIPLine'
op|'='
name|'sampleHostIPLine'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Set \'entry\' to a sample plain-text entry with sampleKey as its key.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'entry'
op|'='
name|'PlainEntry'
op|'.'
name|'fromString'
op|'('
name|'self'
op|'.'
name|'plaintextLine'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_matchesHostIP
dedent|''
name|'def'
name|'test_matchesHostIP'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A "hostname,ip" formatted line will match both the host and the IP.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'entry'
op|'='
name|'PlainEntry'
op|'.'
name|'fromString'
op|'('
name|'self'
op|'.'
name|'hostIPLine'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'True'
op|','
name|'self'
op|'.'
name|'entry'
op|'.'
name|'matchesHost'
op|'('
string|'"198.49.126.131"'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'test_matchesHost'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_toString
dedent|''
name|'def'
name|'test_toString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{PlainEntry.toString} generates the serialized OpenSSL format string\n        for the entry, sans newline.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'entry'
op|'.'
name|'toString'
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'plaintextLine'
op|'.'
name|'rstrip'
op|'('
string|'"\\n"'
op|')'
op|')'
newline|'\n'
name|'multiHostEntry'
op|'='
name|'PlainEntry'
op|'.'
name|'fromString'
op|'('
name|'self'
op|'.'
name|'hostIPLine'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'multiHostEntry'
op|'.'
name|'toString'
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'hostIPLine'
op|'.'
name|'rstrip'
op|'('
string|'"\\n"'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|PlainTextWithCommentTests
dedent|''
dedent|''
name|'class'
name|'PlainTextWithCommentTests'
op|'('
name|'PlainEntryTests'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test cases for L{PlainEntry} when parsed from a line with a comment.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|plaintextLine
name|'plaintextLine'
op|'='
name|'samplePlaintextLine'
op|'['
op|':'
op|'-'
number|'1'
op|']'
op|'+'
string|'" plain text comment.\\n"'
newline|'\n'
DECL|variable|hostIPLine
name|'hostIPLine'
op|'='
name|'sampleHostIPLine'
op|'['
op|':'
op|'-'
number|'1'
op|']'
op|'+'
string|'" text following host/IP line\\n"'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|HashedEntryTests
dedent|''
name|'class'
name|'HashedEntryTests'
op|'('
name|'EntryTestsMixin'
op|','
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{HashedEntry}.\n\n    This suite doesn\'t include any tests for host/IP pairs because hashed\n    entries store IP addresses the same way as hostnames and does not support\n    comma-separated lists.  (If you hash the IP and host together you can\'t\n    tell if you\'ve got the key already for one or the other.)\n    """'
newline|'\n'
DECL|variable|hashedLine
name|'hashedLine'
op|'='
name|'sampleHashedLine'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Set \'entry\' to a sample hashed entry for twistedmatrix.com with\n        sampleKey as its key.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'entry'
op|'='
name|'HashedEntry'
op|'.'
name|'fromString'
op|'('
name|'self'
op|'.'
name|'hashedLine'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_toString
dedent|''
name|'def'
name|'test_toString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{HashedEntry.toString} generates the serialized OpenSSL format string\n        for the entry, sans the newline.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'entry'
op|'.'
name|'toString'
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'hashedLine'
op|'.'
name|'rstrip'
op|'('
string|'"\\n"'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|HashedEntryWithCommentTests
dedent|''
dedent|''
name|'class'
name|'HashedEntryWithCommentTests'
op|'('
name|'HashedEntryTests'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test cases for L{PlainEntry} when parsed from a line with a comment.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|hashedLine
name|'hashedLine'
op|'='
name|'sampleHashedLine'
op|'['
op|':'
op|'-'
number|'1'
op|']'
op|'+'
string|'" plain text comment.\\n"'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|UnparsedEntryTests
dedent|''
name|'class'
name|'UnparsedEntryTests'
op|'('
name|'TestCase'
op|','
name|'EntryTestsMixin'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{UnparsedEntry}\n    """'
newline|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Set up the \'entry\' to be an unparsed entry for some random text.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'entry'
op|'='
name|'UnparsedEntry'
op|'('
string|'"    This is a bogus entry.  \\n"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_fromString
dedent|''
name|'def'
name|'test_fromString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Creating an L{UnparsedEntry} should simply record the string it was\n        passed.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
string|'"    This is a bogus entry.  \\n"'
op|','
nl|'\n'
name|'self'
op|'.'
name|'entry'
op|'.'
name|'_string'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_matchesHost
dedent|''
name|'def'
name|'test_matchesHost'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        An unparsed entry can\'t match any hosts.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'False'
op|','
name|'self'
op|'.'
name|'entry'
op|'.'
name|'matchesHost'
op|'('
string|'"www.twistedmatrix.com"'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_matchesKey
dedent|''
name|'def'
name|'test_matchesKey'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        An unparsed entry can\'t match any keys.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'False'
op|','
name|'self'
op|'.'
name|'entry'
op|'.'
name|'matchesKey'
op|'('
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'sampleKey'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_toString
dedent|''
name|'def'
name|'test_toString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{UnparsedEntry.toString} returns its input string, sans trailing newline.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
string|'"    This is a bogus entry.  "'
op|','
name|'self'
op|'.'
name|'entry'
op|'.'
name|'toString'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ParseErrorTests
dedent|''
dedent|''
name|'class'
name|'ParseErrorTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    L{HashedEntry.fromString} and L{PlainEntry.fromString} can raise a variety\n    of errors depending on misformattings of certain strings.  These tests make\n    sure those errors are caught.  Since many of the ways that this can go\n    wrong are in the lower-level APIs being invoked by the parsing logic,\n    several of these are integration tests with the L{base64} and\n    L{twisted.conch.ssh.keys} modules.\n    """'
newline|'\n'
nl|'\n'
DECL|member|invalidEntryTest
name|'def'
name|'invalidEntryTest'
op|'('
name|'self'
op|','
name|'cls'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If there are fewer than three elements, C{fromString} should raise\n        L{InvalidEntry}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'InvalidEntry'
op|','
name|'cls'
op|'.'
name|'fromString'
op|','
string|'"invalid"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|notBase64Test
dedent|''
name|'def'
name|'notBase64Test'
op|'('
name|'self'
op|','
name|'cls'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the key is not base64, C{fromString} should raise L{BinasciiError}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'BinasciiError'
op|','
name|'cls'
op|'.'
name|'fromString'
op|','
string|'"x x x"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|badKeyTest
dedent|''
name|'def'
name|'badKeyTest'
op|'('
name|'self'
op|','
name|'cls'
op|','
name|'prefix'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the key portion of the entry is valid base64, but is not actually an\n        SSH key, C{fromString} should raise L{BadKeyError}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'BadKeyError'
op|','
name|'cls'
op|'.'
name|'fromString'
op|','
string|"' '"
op|'.'
name|'join'
op|'('
nl|'\n'
op|'['
name|'prefix'
op|','
string|'"ssh-rsa"'
op|','
name|'b2a_base64'
op|'('
nl|'\n'
string|'"Hey, this isn\'t an SSH key!"'
op|')'
op|'.'
name|'strip'
op|'('
op|')'
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_invalidPlainEntry
dedent|''
name|'def'
name|'test_invalidPlainEntry'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If there are fewer than three whitespace-separated elements in an\n        entry, L{PlainEntry.fromString} should raise L{InvalidEntry}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'invalidEntryTest'
op|'('
name|'PlainEntry'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_invalidHashedEntry
dedent|''
name|'def'
name|'test_invalidHashedEntry'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If there are fewer than three whitespace-separated elements in an\n        entry, or the hostname salt/hash portion has more than two elements,\n        L{HashedEntry.fromString} should raise L{InvalidEntry}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'invalidEntryTest'
op|'('
name|'HashedEntry'
op|')'
newline|'\n'
name|'a'
op|','
name|'b'
op|','
name|'c'
op|'='
name|'sampleHashedLine'
op|'.'
name|'split'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'InvalidEntry'
op|','
name|'HashedEntry'
op|'.'
name|'fromString'
op|','
string|"' '"
op|'.'
name|'join'
op|'('
nl|'\n'
op|'['
name|'a'
op|'+'
string|'"||"'
op|','
name|'b'
op|','
name|'c'
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_plainNotBase64
dedent|''
name|'def'
name|'test_plainNotBase64'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the key portion of a plain entry is not decodable as base64,\n        C{fromString} should raise L{BinasciiError}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'notBase64Test'
op|'('
name|'PlainEntry'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_hashedNotBase64
dedent|''
name|'def'
name|'test_hashedNotBase64'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the key, host salt, or host hash portion of a hashed entry is not\n        encoded, it will raise L{BinasciiError}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'notBase64Test'
op|'('
name|'HashedEntry'
op|')'
newline|'\n'
name|'a'
op|','
name|'b'
op|','
name|'c'
op|'='
name|'sampleHashedLine'
op|'.'
name|'split'
op|'('
op|')'
newline|'\n'
comment|'# Salt not valid base64.'
nl|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
nl|'\n'
name|'BinasciiError'
op|','
name|'HashedEntry'
op|'.'
name|'fromString'
op|','
nl|'\n'
string|"' '"
op|'.'
name|'join'
op|'('
op|'['
string|'"|1|x|"'
op|'+'
name|'b2a_base64'
op|'('
string|'"stuff"'
op|')'
op|'.'
name|'strip'
op|'('
op|')'
op|','
name|'b'
op|','
name|'c'
op|']'
op|')'
op|')'
newline|'\n'
comment|'# Host hash not valid base64.'
nl|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
nl|'\n'
name|'BinasciiError'
op|','
name|'HashedEntry'
op|'.'
name|'fromString'
op|','
nl|'\n'
string|"' '"
op|'.'
name|'join'
op|'('
op|'['
name|'HashedEntry'
op|'.'
name|'MAGIC'
op|'+'
name|'b2a_base64'
op|'('
string|'"stuff"'
op|')'
op|'.'
name|'strip'
op|'('
op|')'
op|'+'
string|'"|x"'
op|','
name|'b'
op|','
name|'c'
op|']'
op|')'
op|')'
newline|'\n'
comment|'# Neither salt nor hash valid base64.'
nl|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
nl|'\n'
name|'BinasciiError'
op|','
name|'HashedEntry'
op|'.'
name|'fromString'
op|','
nl|'\n'
string|"' '"
op|'.'
name|'join'
op|'('
op|'['
string|'"|1|x|x"'
op|','
name|'b'
op|','
name|'c'
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_hashedBadKey
dedent|''
name|'def'
name|'test_hashedBadKey'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the key portion of the entry is valid base64, but is not actually an\n        SSH key, C{HashedEntry.fromString} should raise L{BadKeyError}.\n        """'
newline|'\n'
name|'a'
op|','
name|'b'
op|','
name|'c'
op|'='
name|'sampleHashedLine'
op|'.'
name|'split'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'badKeyTest'
op|'('
name|'HashedEntry'
op|','
name|'a'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_plainBadKey
dedent|''
name|'def'
name|'test_plainBadKey'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the key portion of the entry is valid base64, but is not actually an\n        SSH key, C{PlainEntry.fromString} should raise L{BadKeyError}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'badKeyTest'
op|'('
name|'PlainEntry'
op|','
string|'"hostname"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|KnownHostsDatabaseTests
dedent|''
dedent|''
name|'class'
name|'KnownHostsDatabaseTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{KnownHostsFile}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|pathWithContent
name|'def'
name|'pathWithContent'
op|'('
name|'self'
op|','
name|'content'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a FilePath with the given initial content.\n        """'
newline|'\n'
name|'fp'
op|'='
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'fp'
op|'.'
name|'setContent'
op|'('
name|'content'
op|')'
newline|'\n'
name|'return'
name|'fp'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|loadSampleHostsFile
dedent|''
name|'def'
name|'loadSampleHostsFile'
op|'('
name|'self'
op|','
name|'content'
op|'='
op|'('
nl|'\n'
name|'sampleHashedLine'
op|'+'
name|'otherSamplePlaintextLine'
op|'+'
nl|'\n'
string|'"\\n# That was a blank line.\\n"'
nl|'\n'
string|'"This is just unparseable.\\n"'
nl|'\n'
string|'"This also unparseable.\\n"'
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a sample hosts file, with keys for www.twistedmatrix.com and\n        divmod.com present.\n        """'
newline|'\n'
name|'return'
name|'KnownHostsFile'
op|'.'
name|'fromPath'
op|'('
name|'self'
op|'.'
name|'pathWithContent'
op|'('
name|'content'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_loadFromPath
dedent|''
name|'def'
name|'test_loadFromPath'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Loading a L{KnownHostsFile} from a path with six entries in it will\n        result in a L{KnownHostsFile} object with six L{IKnownHostEntry}\n        providers in it, each of the appropriate type.\n        """'
newline|'\n'
name|'hostsFile'
op|'='
name|'self'
op|'.'
name|'loadSampleHostsFile'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'len'
op|'('
name|'hostsFile'
op|'.'
name|'_entries'
op|')'
op|','
number|'6'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'hostsFile'
op|'.'
name|'_entries'
op|'['
number|'0'
op|']'
op|','
name|'HashedEntry'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'True'
op|','
name|'hostsFile'
op|'.'
name|'_entries'
op|'['
number|'0'
op|']'
op|'.'
name|'matchesHost'
op|'('
nl|'\n'
string|'"www.twistedmatrix.com"'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'hostsFile'
op|'.'
name|'_entries'
op|'['
number|'1'
op|']'
op|','
name|'PlainEntry'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'True'
op|','
name|'hostsFile'
op|'.'
name|'_entries'
op|'['
number|'1'
op|']'
op|'.'
name|'matchesHost'
op|'('
nl|'\n'
string|'"divmod.com"'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'hostsFile'
op|'.'
name|'_entries'
op|'['
number|'2'
op|']'
op|','
name|'UnparsedEntry'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'hostsFile'
op|'.'
name|'_entries'
op|'['
number|'2'
op|']'
op|'.'
name|'toString'
op|'('
op|')'
op|','
string|'""'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'hostsFile'
op|'.'
name|'_entries'
op|'['
number|'3'
op|']'
op|','
name|'UnparsedEntry'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'hostsFile'
op|'.'
name|'_entries'
op|'['
number|'3'
op|']'
op|'.'
name|'toString'
op|'('
op|')'
op|','
nl|'\n'
string|'"# That was a blank line."'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'hostsFile'
op|'.'
name|'_entries'
op|'['
number|'4'
op|']'
op|','
name|'UnparsedEntry'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'hostsFile'
op|'.'
name|'_entries'
op|'['
number|'4'
op|']'
op|'.'
name|'toString'
op|'('
op|')'
op|','
nl|'\n'
string|'"This is just unparseable."'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'hostsFile'
op|'.'
name|'_entries'
op|'['
number|'5'
op|']'
op|','
name|'UnparsedEntry'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'hostsFile'
op|'.'
name|'_entries'
op|'['
number|'5'
op|']'
op|'.'
name|'toString'
op|'('
op|')'
op|','
nl|'\n'
string|'"This also unparseable."'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_loadNonExistent
dedent|''
name|'def'
name|'test_loadNonExistent'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Loading a L{KnownHostsFile} from a path that does not exist should\n        result in an empty L{KnownHostsFile} that will save back to that path.\n        """'
newline|'\n'
name|'pn'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'knownHostsFile'
op|'='
name|'KnownHostsFile'
op|'.'
name|'fromPath'
op|'('
name|'FilePath'
op|'('
name|'pn'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
op|'['
op|']'
op|','
name|'list'
op|'('
name|'knownHostsFile'
op|'.'
name|'_entries'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'False'
op|','
name|'FilePath'
op|'('
name|'pn'
op|')'
op|'.'
name|'exists'
op|'('
op|')'
op|')'
newline|'\n'
name|'knownHostsFile'
op|'.'
name|'save'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'True'
op|','
name|'FilePath'
op|'('
name|'pn'
op|')'
op|'.'
name|'exists'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_loadNonExistentParent
dedent|''
name|'def'
name|'test_loadNonExistentParent'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Loading a L{KnownHostsFile} from a path whose parent directory does not\n        exist should result in an empty L{KnownHostsFile} that will save back\n        to that path, creating its parent directory(ies) in the process.\n        """'
newline|'\n'
name|'thePath'
op|'='
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'knownHostsPath'
op|'='
name|'thePath'
op|'.'
name|'child'
op|'('
string|'"foo"'
op|')'
op|'.'
name|'child'
op|'('
string|'"known_hosts"'
op|')'
newline|'\n'
name|'knownHostsFile'
op|'='
name|'KnownHostsFile'
op|'.'
name|'fromPath'
op|'('
name|'knownHostsPath'
op|')'
newline|'\n'
name|'knownHostsFile'
op|'.'
name|'save'
op|'('
op|')'
newline|'\n'
name|'knownHostsPath'
op|'.'
name|'restat'
op|'('
name|'False'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'True'
op|','
name|'knownHostsPath'
op|'.'
name|'exists'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_savingAddsEntry
dedent|''
name|'def'
name|'test_savingAddsEntry'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{KnownHostsFile.save()} will write out a new file with any entries\n        that have been added.\n        """'
newline|'\n'
name|'path'
op|'='
name|'self'
op|'.'
name|'pathWithContent'
op|'('
name|'sampleHashedLine'
op|'+'
nl|'\n'
name|'otherSamplePlaintextLine'
op|')'
newline|'\n'
name|'knownHostsFile'
op|'='
name|'KnownHostsFile'
op|'.'
name|'fromPath'
op|'('
name|'path'
op|')'
newline|'\n'
name|'newEntry'
op|'='
name|'knownHostsFile'
op|'.'
name|'addHostKey'
op|'('
string|'"some.example.com"'
op|','
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'thirdSampleKey'
op|')'
op|')'
newline|'\n'
name|'expectedContent'
op|'='
op|'('
nl|'\n'
name|'sampleHashedLine'
op|'+'
nl|'\n'
name|'otherSamplePlaintextLine'
op|'+'
name|'HashedEntry'
op|'.'
name|'MAGIC'
op|'+'
nl|'\n'
name|'b2a_base64'
op|'('
name|'newEntry'
op|'.'
name|'_hostSalt'
op|')'
op|'.'
name|'strip'
op|'('
op|')'
op|'+'
string|'"|"'
op|'+'
nl|'\n'
name|'b2a_base64'
op|'('
name|'newEntry'
op|'.'
name|'_hostHash'
op|')'
op|'.'
name|'strip'
op|'('
op|')'
op|'+'
string|'" ssh-rsa "'
op|'+'
nl|'\n'
name|'thirdSampleEncodedKey'
op|'+'
string|'"\\n"'
op|')'
newline|'\n'
nl|'\n'
comment|"# Sanity check, let's make sure the base64 API being used for the test"
nl|'\n'
comment|"# isn't inserting spurious newlines."
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
number|'3'
op|','
name|'expectedContent'
op|'.'
name|'count'
op|'('
string|'"\\n"'
op|')'
op|')'
newline|'\n'
name|'knownHostsFile'
op|'.'
name|'save'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'expectedContent'
op|','
name|'path'
op|'.'
name|'getContent'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_hasPresentKey
dedent|''
name|'def'
name|'test_hasPresentKey'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{KnownHostsFile.hasHostKey} returns C{True} when a key for the given\n        hostname is present and matches the expected key.\n        """'
newline|'\n'
name|'hostsFile'
op|'='
name|'self'
op|'.'
name|'loadSampleHostsFile'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'True'
op|','
name|'hostsFile'
op|'.'
name|'hasHostKey'
op|'('
nl|'\n'
string|'"www.twistedmatrix.com"'
op|','
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'sampleKey'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_hasNonPresentKey
dedent|''
name|'def'
name|'test_hasNonPresentKey'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{KnownHostsFile.hasHostKey} returns C{False} when a key for the given\n        hostname is not present.\n        """'
newline|'\n'
name|'hostsFile'
op|'='
name|'self'
op|'.'
name|'loadSampleHostsFile'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'False'
op|','
name|'hostsFile'
op|'.'
name|'hasHostKey'
op|'('
nl|'\n'
string|'"non-existent.example.com"'
op|','
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'sampleKey'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_hasKeyMismatch
dedent|''
name|'def'
name|'test_hasKeyMismatch'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{KnownHostsFile.hasHostKey} raises L{HostKeyChanged} if the host key\n        is present, but different from the expected one.  The resulting\n        exception should have an offendingEntry indicating the given entry.\n        """'
newline|'\n'
name|'hostsFile'
op|'='
name|'self'
op|'.'
name|'loadSampleHostsFile'
op|'('
op|')'
newline|'\n'
name|'exception'
op|'='
name|'self'
op|'.'
name|'assertRaises'
op|'('
nl|'\n'
name|'HostKeyChanged'
op|','
name|'hostsFile'
op|'.'
name|'hasHostKey'
op|','
nl|'\n'
string|'"www.twistedmatrix.com"'
op|','
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'otherSampleKey'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'exception'
op|'.'
name|'offendingEntry'
op|','
name|'hostsFile'
op|'.'
name|'_entries'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'exception'
op|'.'
name|'lineno'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'exception'
op|'.'
name|'path'
op|','
name|'hostsFile'
op|'.'
name|'_savePath'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_addHostKey
dedent|''
name|'def'
name|'test_addHostKey'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{KnownHostsFile.addHostKey} adds a new L{HashedEntry} to the host\n        file, and returns it.\n        """'
newline|'\n'
name|'hostsFile'
op|'='
name|'self'
op|'.'
name|'loadSampleHostsFile'
op|'('
op|')'
newline|'\n'
name|'aKey'
op|'='
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'thirdSampleKey'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'False'
op|','
nl|'\n'
name|'hostsFile'
op|'.'
name|'hasHostKey'
op|'('
string|'"somewhere.example.com"'
op|','
name|'aKey'
op|')'
op|')'
newline|'\n'
name|'newEntry'
op|'='
name|'hostsFile'
op|'.'
name|'addHostKey'
op|'('
string|'"somewhere.example.com"'
op|','
name|'aKey'
op|')'
newline|'\n'
nl|'\n'
comment|'# The code in OpenSSH requires host salts to be 20 characters long.'
nl|'\n'
comment|"# This is the required length of a SHA-1 HMAC hash, so it's just a"
nl|'\n'
comment|'# sanity check.'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
number|'20'
op|','
name|'len'
op|'('
name|'newEntry'
op|'.'
name|'_hostSalt'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'True'
op|','
nl|'\n'
name|'newEntry'
op|'.'
name|'matchesHost'
op|'('
string|'"somewhere.example.com"'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'newEntry'
op|'.'
name|'keyType'
op|','
string|'"ssh-rsa"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'aKey'
op|','
name|'newEntry'
op|'.'
name|'publicKey'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'True'
op|','
nl|'\n'
name|'hostsFile'
op|'.'
name|'hasHostKey'
op|'('
string|'"somewhere.example.com"'
op|','
name|'aKey'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_randomSalts
dedent|''
name|'def'
name|'test_randomSalts'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{KnownHostsFile.addHostKey} generates a random salt for each new key,\n        so subsequent salts will be different.\n        """'
newline|'\n'
name|'hostsFile'
op|'='
name|'self'
op|'.'
name|'loadSampleHostsFile'
op|'('
op|')'
newline|'\n'
name|'aKey'
op|'='
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'thirdSampleKey'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertNotEqual'
op|'('
nl|'\n'
name|'hostsFile'
op|'.'
name|'addHostKey'
op|'('
string|'"somewhere.example.com"'
op|','
name|'aKey'
op|')'
op|'.'
name|'_hostSalt'
op|','
nl|'\n'
name|'hostsFile'
op|'.'
name|'addHostKey'
op|'('
string|'"somewhere-else.example.com"'
op|','
name|'aKey'
op|')'
op|'.'
name|'_hostSalt'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_verifyValidKey
dedent|''
name|'def'
name|'test_verifyValidKey'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verifying a valid key should return a L{Deferred} which fires with\n        True.\n        """'
newline|'\n'
name|'hostsFile'
op|'='
name|'self'
op|'.'
name|'loadSampleHostsFile'
op|'('
op|')'
newline|'\n'
name|'hostsFile'
op|'.'
name|'addHostKey'
op|'('
string|'"1.2.3.4"'
op|','
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'sampleKey'
op|')'
op|')'
newline|'\n'
name|'ui'
op|'='
name|'FakeUI'
op|'('
op|')'
newline|'\n'
name|'d'
op|'='
name|'hostsFile'
op|'.'
name|'verifyHostKey'
op|'('
name|'ui'
op|','
string|'"www.twistedmatrix.com"'
op|','
string|'"1.2.3.4"'
op|','
nl|'\n'
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'sampleKey'
op|')'
op|')'
newline|'\n'
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'l'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'l'
op|','
op|'['
name|'True'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_verifyInvalidKey
dedent|''
name|'def'
name|'test_verifyInvalidKey'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verfying an invalid key should return a L{Deferred} which fires with a\n        L{HostKeyChanged} failure.\n        """'
newline|'\n'
name|'hostsFile'
op|'='
name|'self'
op|'.'
name|'loadSampleHostsFile'
op|'('
op|')'
newline|'\n'
name|'wrongKey'
op|'='
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'thirdSampleKey'
op|')'
newline|'\n'
name|'ui'
op|'='
name|'FakeUI'
op|'('
op|')'
newline|'\n'
name|'hostsFile'
op|'.'
name|'addHostKey'
op|'('
string|'"1.2.3.4"'
op|','
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'sampleKey'
op|')'
op|')'
newline|'\n'
name|'d'
op|'='
name|'hostsFile'
op|'.'
name|'verifyHostKey'
op|'('
nl|'\n'
name|'ui'
op|','
string|'"www.twistedmatrix.com"'
op|','
string|'"1.2.3.4"'
op|','
name|'wrongKey'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'HostKeyChanged'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|verifyNonPresentKey
dedent|''
name|'def'
name|'verifyNonPresentKey'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Set up a test to verify a key that isn\'t present.  Return a 3-tuple of\n        the UI, a list set up to collect the result of the verifyHostKey call,\n        and the sample L{KnownHostsFile} being used.\n\n        This utility method avoids returning a L{Deferred}, and records results\n        in the returned list instead, because the events which get generated\n        here are pre-recorded in the \'ui\' object.  If the L{Deferred} in\n        question does not fire, the it will fail quickly with an empty list.\n        """'
newline|'\n'
name|'hostsFile'
op|'='
name|'self'
op|'.'
name|'loadSampleHostsFile'
op|'('
op|')'
newline|'\n'
name|'absentKey'
op|'='
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'thirdSampleKey'
op|')'
newline|'\n'
name|'ui'
op|'='
name|'FakeUI'
op|'('
op|')'
newline|'\n'
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'d'
op|'='
name|'hostsFile'
op|'.'
name|'verifyHostKey'
op|'('
nl|'\n'
name|'ui'
op|','
string|'"sample-host.example.com"'
op|','
string|'"4.3.2.1"'
op|','
name|'absentKey'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addBoth'
op|'('
name|'l'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
op|'['
op|']'
op|','
name|'l'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'ui'
op|'.'
name|'promptText'
op|','
nl|'\n'
string|'"The authenticity of host \'sample-host.example.com (4.3.2.1)\' "'
nl|'\n'
string|'"can\'t be established.\\n"'
nl|'\n'
string|'"RSA key fingerprint is "'
nl|'\n'
string|'"89:4e:cc:8c:57:83:96:48:ef:63:ad:ee:99:00:4c:8f.\\n"'
nl|'\n'
string|'"Are you sure you want to continue connecting (yes/no)? "'
op|')'
newline|'\n'
name|'return'
name|'ui'
op|','
name|'l'
op|','
name|'hostsFile'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_verifyNonPresentKey_Yes
dedent|''
name|'def'
name|'test_verifyNonPresentKey_Yes'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verifying a key where neither the hostname nor the IP are present\n        should result in the UI being prompted with a message explaining as\n        much.  If the UI says yes, the Deferred should fire with True.\n        """'
newline|'\n'
name|'ui'
op|','
name|'l'
op|','
name|'knownHostsFile'
op|'='
name|'self'
op|'.'
name|'verifyNonPresentKey'
op|'('
op|')'
newline|'\n'
name|'ui'
op|'.'
name|'promptDeferred'
op|'.'
name|'callback'
op|'('
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
op|'['
name|'True'
op|']'
op|','
name|'l'
op|')'
newline|'\n'
name|'reloaded'
op|'='
name|'KnownHostsFile'
op|'.'
name|'fromPath'
op|'('
name|'knownHostsFile'
op|'.'
name|'_savePath'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'True'
op|','
nl|'\n'
name|'reloaded'
op|'.'
name|'hasHostKey'
op|'('
string|'"4.3.2.1"'
op|','
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'thirdSampleKey'
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'True'
op|','
nl|'\n'
name|'reloaded'
op|'.'
name|'hasHostKey'
op|'('
string|'"sample-host.example.com"'
op|','
nl|'\n'
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'thirdSampleKey'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_verifyNonPresentKey_No
dedent|''
name|'def'
name|'test_verifyNonPresentKey_No'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verifying a key where neither the hostname nor the IP are present\n        should result in the UI being prompted with a message explaining as\n        much.  If the UI says no, the Deferred should fail with\n        UserRejectedKey.\n        """'
newline|'\n'
name|'ui'
op|','
name|'l'
op|','
name|'knownHostsFile'
op|'='
name|'self'
op|'.'
name|'verifyNonPresentKey'
op|'('
op|')'
newline|'\n'
name|'ui'
op|'.'
name|'promptDeferred'
op|'.'
name|'callback'
op|'('
name|'False'
op|')'
newline|'\n'
name|'l'
op|'['
number|'0'
op|']'
op|'.'
name|'trap'
op|'('
name|'UserRejectedKey'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_verifyHostIPMismatch
dedent|''
name|'def'
name|'test_verifyHostIPMismatch'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verifying a key where the host is present (and correct), but the IP is\n        present and different, should result the deferred firing in a\n        HostKeyChanged failure.\n        """'
newline|'\n'
name|'hostsFile'
op|'='
name|'self'
op|'.'
name|'loadSampleHostsFile'
op|'('
op|')'
newline|'\n'
name|'wrongKey'
op|'='
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'thirdSampleKey'
op|')'
newline|'\n'
name|'ui'
op|'='
name|'FakeUI'
op|'('
op|')'
newline|'\n'
name|'d'
op|'='
name|'hostsFile'
op|'.'
name|'verifyHostKey'
op|'('
nl|'\n'
name|'ui'
op|','
string|'"www.twistedmatrix.com"'
op|','
string|'"4.3.2.1"'
op|','
name|'wrongKey'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'HostKeyChanged'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_verifyKeyForHostAndIP
dedent|''
name|'def'
name|'test_verifyKeyForHostAndIP'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verifying a key where the hostname is present but the IP is not should\n        result in the key being added for the IP and the user being warned\n        about the change.\n        """'
newline|'\n'
name|'ui'
op|'='
name|'FakeUI'
op|'('
op|')'
newline|'\n'
name|'hostsFile'
op|'='
name|'self'
op|'.'
name|'loadSampleHostsFile'
op|'('
op|')'
newline|'\n'
name|'expectedKey'
op|'='
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'sampleKey'
op|')'
newline|'\n'
name|'hostsFile'
op|'.'
name|'verifyHostKey'
op|'('
nl|'\n'
name|'ui'
op|','
string|'"www.twistedmatrix.com"'
op|','
string|'"5.4.3.2"'
op|','
name|'expectedKey'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'True'
op|','
name|'KnownHostsFile'
op|'.'
name|'fromPath'
op|'('
name|'hostsFile'
op|'.'
name|'_savePath'
op|')'
op|'.'
name|'hasHostKey'
op|'('
nl|'\n'
string|'"5.4.3.2"'
op|','
name|'expectedKey'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
op|'['
string|'"Warning: Permanently added the RSA host key for IP address "'
nl|'\n'
string|'"\'5.4.3.2\' to the list of known hosts."'
op|']'
op|','
nl|'\n'
name|'ui'
op|'.'
name|'userWarnings'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|FakeFile
dedent|''
dedent|''
name|'class'
name|'FakeFile'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A fake file-like object that acts enough like a file for\n    L{ConsoleUI.prompt}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'inlines'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'outchunks'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'closed'
op|'='
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|readline
dedent|''
name|'def'
name|'readline'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a line from the \'inlines\' list.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'inlines'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|write
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'chunk'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Append the given item to the \'outchunks\' list.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'closed'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'IOError'
op|'('
string|'"the file was closed"'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'outchunks'
op|'.'
name|'append'
op|'('
name|'chunk'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|close
dedent|''
name|'def'
name|'close'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Set the \'closed\' flag to True, explicitly marking that it has been\n        closed.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'closed'
op|'='
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ConsoleUITests
dedent|''
dedent|''
name|'class'
name|'ConsoleUITests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test cases for L{ConsoleUI}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a L{ConsoleUI} pointed at a L{FakeFile}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'fakeFile'
op|'='
name|'FakeFile'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'ui'
op|'='
name|'ConsoleUI'
op|'('
name|'self'
op|'.'
name|'openFile'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|openFile
dedent|''
name|'def'
name|'openFile'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the current fake file.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'fakeFile'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|newFile
dedent|''
name|'def'
name|'newFile'
op|'('
name|'self'
op|','
name|'lines'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a new fake file (the next file that self.ui will open) with the\n        given list of lines to be returned from readline().\n        """'
newline|'\n'
name|'self'
op|'.'
name|'fakeFile'
op|'='
name|'FakeFile'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'fakeFile'
op|'.'
name|'inlines'
op|'='
name|'lines'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_promptYes
dedent|''
name|'def'
name|'test_promptYes'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{ConsoleUI.prompt} writes a message to the console, then reads a line.\n        If that line is \'yes\', then it returns a L{Deferred} that fires with\n        True.\n        """'
newline|'\n'
name|'for'
name|'okYes'
name|'in'
op|'['
string|"'yes'"
op|','
string|"'Yes'"
op|','
string|"'yes\\n'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'newFile'
op|'('
op|'['
name|'okYes'
op|']'
op|')'
newline|'\n'
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'ui'
op|'.'
name|'prompt'
op|'('
string|'"Hello, world!"'
op|')'
op|'.'
name|'addCallback'
op|'('
name|'l'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
op|'['
string|'"Hello, world!"'
op|']'
op|','
name|'self'
op|'.'
name|'fakeFile'
op|'.'
name|'outchunks'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
op|'['
name|'True'
op|']'
op|','
name|'l'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'True'
op|','
name|'self'
op|'.'
name|'fakeFile'
op|'.'
name|'closed'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_promptNo
dedent|''
dedent|''
name|'def'
name|'test_promptNo'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{ConsoleUI.prompt} writes a message to the console, then reads a line.\n        If that line is \'no\', then it returns a L{Deferred} that fires with\n        False.\n        """'
newline|'\n'
name|'for'
name|'okNo'
name|'in'
op|'['
string|"'no'"
op|','
string|"'No'"
op|','
string|"'no\\n'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'newFile'
op|'('
op|'['
name|'okNo'
op|']'
op|')'
newline|'\n'
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'ui'
op|'.'
name|'prompt'
op|'('
string|'"Goodbye, world!"'
op|')'
op|'.'
name|'addCallback'
op|'('
name|'l'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
op|'['
string|'"Goodbye, world!"'
op|']'
op|','
name|'self'
op|'.'
name|'fakeFile'
op|'.'
name|'outchunks'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
op|'['
name|'False'
op|']'
op|','
name|'l'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'True'
op|','
name|'self'
op|'.'
name|'fakeFile'
op|'.'
name|'closed'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_promptRepeatedly
dedent|''
dedent|''
name|'def'
name|'test_promptRepeatedly'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{ConsoleUI.prompt} writes a message to the console, then reads a line.\n        If that line is neither \'yes\' nor \'no\', then it says "Please enter\n        \'yes\' or \'no\'" until it gets a \'yes\' or a \'no\', at which point it\n        returns a Deferred that answers either True or False.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'newFile'
op|'('
op|'['
string|"'what'"
op|','
string|"'uh'"
op|','
string|"'okay'"
op|','
string|"'yes'"
op|']'
op|')'
newline|'\n'
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'ui'
op|'.'
name|'prompt'
op|'('
string|'"Please say something useful."'
op|')'
op|'.'
name|'addCallback'
op|'('
name|'l'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
op|'['
name|'True'
op|']'
op|','
name|'l'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'fakeFile'
op|'.'
name|'outchunks'
op|','
nl|'\n'
op|'['
string|'"Please say something useful."'
op|']'
op|'+'
nl|'\n'
op|'['
string|'"Please type \'yes\' or \'no\': "'
op|']'
op|'*'
number|'3'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'True'
op|','
name|'self'
op|'.'
name|'fakeFile'
op|'.'
name|'closed'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'newFile'
op|'('
op|'['
string|"'blah'"
op|','
string|"'stuff'"
op|','
string|"'feh'"
op|','
string|"'no'"
op|']'
op|')'
newline|'\n'
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'ui'
op|'.'
name|'prompt'
op|'('
string|'"Please say something negative."'
op|')'
op|'.'
name|'addCallback'
op|'('
name|'l'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
op|'['
name|'False'
op|']'
op|','
name|'l'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'fakeFile'
op|'.'
name|'outchunks'
op|','
nl|'\n'
op|'['
string|'"Please say something negative."'
op|']'
op|'+'
nl|'\n'
op|'['
string|'"Please type \'yes\' or \'no\': "'
op|']'
op|'*'
number|'3'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'True'
op|','
name|'self'
op|'.'
name|'fakeFile'
op|'.'
name|'closed'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_promptOpenFailed
dedent|''
name|'def'
name|'test_promptOpenFailed'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the C{opener} passed to L{ConsoleUI} raises an exception, that\n        exception will fail the L{Deferred} returned from L{ConsoleUI.prompt}.\n        """'
newline|'\n'
DECL|function|raiseIt
name|'def'
name|'raiseIt'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'IOError'
op|'('
op|')'
newline|'\n'
dedent|''
name|'ui'
op|'='
name|'ConsoleUI'
op|'('
name|'raiseIt'
op|')'
newline|'\n'
name|'d'
op|'='
name|'ui'
op|'.'
name|'prompt'
op|'('
string|'"This is a test."'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'IOError'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_warn
dedent|''
name|'def'
name|'test_warn'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{ConsoleUI.warn} should output a message to the console object.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'ui'
op|'.'
name|'warn'
op|'('
string|'"Test message."'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
op|'['
string|'"Test message."'
op|']'
op|','
name|'self'
op|'.'
name|'fakeFile'
op|'.'
name|'outchunks'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'True'
op|','
name|'self'
op|'.'
name|'fakeFile'
op|'.'
name|'closed'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_warnOpenFailed
dedent|''
name|'def'
name|'test_warnOpenFailed'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{ConsoleUI.warn} should log a traceback if the output can\'t be opened.\n        """'
newline|'\n'
DECL|function|raiseIt
name|'def'
name|'raiseIt'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
number|'1'
op|'/'
number|'0'
newline|'\n'
dedent|''
name|'ui'
op|'='
name|'ConsoleUI'
op|'('
name|'raiseIt'
op|')'
newline|'\n'
name|'ui'
op|'.'
name|'warn'
op|'('
string|'"This message never makes it."'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'flushLoggedErrors'
op|'('
name|'ZeroDivisionError'
op|')'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|FakeUI
dedent|''
dedent|''
name|'class'
name|'FakeUI'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A fake UI object, adhering to the interface expected by\n    L{KnownHostsFile.verifyHostKey}\n\n    @ivar userWarnings: inputs provided to \'warn\'.\n\n    @ivar promptDeferred: last result returned from \'prompt\'.\n\n    @ivar promptText: the last input provided to \'prompt\'.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'userWarnings'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'promptDeferred'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'promptText'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|prompt
dedent|''
name|'def'
name|'prompt'
op|'('
name|'self'
op|','
name|'text'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Issue the user an interactive prompt, which they can accept or deny.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'promptText'
op|'='
name|'text'
newline|'\n'
name|'self'
op|'.'
name|'promptDeferred'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'promptDeferred'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|warn
dedent|''
name|'def'
name|'warn'
op|'('
name|'self'
op|','
name|'text'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Issue a non-interactive warning to the user.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'userWarnings'
op|'.'
name|'append'
op|'('
name|'text'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|FakeObject
dedent|''
dedent|''
name|'class'
name|'FakeObject'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A fake object that can have some attributes.  Used to fake\n    L{SSHClientTransport} and L{SSHClientFactory}.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DefaultAPITests
dedent|''
name|'class'
name|'DefaultAPITests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    The API in L{twisted.conch.client.default.verifyHostKey} is the integration\n    point between the code in the rest of conch and L{KnownHostsFile}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|patchedOpen
name|'def'
name|'patchedOpen'
op|'('
name|'self'
op|','
name|'fname'
op|','
name|'mode'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The patched version of \'open\'; this returns a L{FakeFile} that the\n        instantiated L{ConsoleUI} can use.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'fname'
op|','
string|'"/dev/tty"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'mode'
op|','
string|'"r+b"'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'fakeFile'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|setUp
dedent|''
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Patch \'open\' in verifyHostKey.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'fakeFile'
op|'='
name|'FakeFile'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'patch'
op|'('
name|'default'
op|','
string|'"_open"'
op|','
name|'self'
op|'.'
name|'patchedOpen'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'hostsOption'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'knownHostsFile'
op|'='
name|'KnownHostsFile'
op|'('
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'hostsOption'
op|')'
op|')'
newline|'\n'
name|'knownHostsFile'
op|'.'
name|'addHostKey'
op|'('
string|'"exists.example.com"'
op|','
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'sampleKey'
op|')'
op|')'
newline|'\n'
name|'knownHostsFile'
op|'.'
name|'addHostKey'
op|'('
string|'"4.3.2.1"'
op|','
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'sampleKey'
op|')'
op|')'
newline|'\n'
name|'knownHostsFile'
op|'.'
name|'save'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'fakeTransport'
op|'='
name|'FakeObject'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'fakeTransport'
op|'.'
name|'factory'
op|'='
name|'FakeObject'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'options'
op|'='
name|'self'
op|'.'
name|'fakeTransport'
op|'.'
name|'factory'
op|'.'
name|'options'
op|'='
op|'{'
nl|'\n'
string|"'host'"
op|':'
string|'"exists.example.com"'
op|','
nl|'\n'
string|"'known-hosts'"
op|':'
name|'self'
op|'.'
name|'hostsOption'
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_verifyOKKey
dedent|''
name|'def'
name|'test_verifyOKKey'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{default.verifyHostKey} should return a L{Deferred} which fires with\n        C{1} when passed a host, IP, and key which already match the\n        known_hosts file it is supposed to check.\n        """'
newline|'\n'
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'default'
op|'.'
name|'verifyHostKey'
op|'('
name|'self'
op|'.'
name|'fakeTransport'
op|','
string|'"4.3.2.1"'
op|','
name|'sampleKey'
op|','
nl|'\n'
string|'"I don\'t care."'
op|')'
op|'.'
name|'addCallback'
op|'('
name|'l'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
op|'['
number|'1'
op|']'
op|','
name|'l'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|replaceHome
dedent|''
name|'def'
name|'replaceHome'
op|'('
name|'self'
op|','
name|'tempHome'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Replace the HOME environment variable until the end of the current\n        test, with the given new home-directory, so that L{os.path.expanduser}\n        will yield controllable, predictable results.\n\n        @param tempHome: the pathname to replace the HOME variable with.\n\n        @type tempHome: L{str}\n        """'
newline|'\n'
name|'oldHome'
op|'='
name|'os'
op|'.'
name|'environ'
op|'.'
name|'get'
op|'('
string|"'HOME'"
op|')'
newline|'\n'
DECL|function|cleanupHome
name|'def'
name|'cleanupHome'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'oldHome'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'del'
name|'os'
op|'.'
name|'environ'
op|'['
string|"'HOME'"
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'environ'
op|'['
string|"'HOME'"
op|']'
op|'='
name|'oldHome'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'addCleanup'
op|'('
name|'cleanupHome'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'environ'
op|'['
string|"'HOME'"
op|']'
op|'='
name|'tempHome'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_noKnownHostsOption
dedent|''
name|'def'
name|'test_noKnownHostsOption'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{default.verifyHostKey} should find your known_hosts file in\n        ~/.ssh/known_hosts if you don\'t specify one explicitly on the command\n        line.\n        """'
newline|'\n'
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'tmpdir'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'oldHostsOption'
op|'='
name|'self'
op|'.'
name|'hostsOption'
newline|'\n'
name|'hostsNonOption'
op|'='
name|'FilePath'
op|'('
name|'tmpdir'
op|')'
op|'.'
name|'child'
op|'('
string|'".ssh"'
op|')'
op|'.'
name|'child'
op|'('
string|'"known_hosts"'
op|')'
newline|'\n'
name|'hostsNonOption'
op|'.'
name|'parent'
op|'('
op|')'
op|'.'
name|'makedirs'
op|'('
op|')'
newline|'\n'
name|'FilePath'
op|'('
name|'oldHostsOption'
op|')'
op|'.'
name|'moveTo'
op|'('
name|'hostsNonOption'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'replaceHome'
op|'('
name|'tmpdir'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'options'
op|'['
string|"'known-hosts'"
op|']'
op|'='
name|'None'
newline|'\n'
name|'default'
op|'.'
name|'verifyHostKey'
op|'('
name|'self'
op|'.'
name|'fakeTransport'
op|','
string|'"4.3.2.1"'
op|','
name|'sampleKey'
op|','
nl|'\n'
string|'"I don\'t care."'
op|')'
op|'.'
name|'addCallback'
op|'('
name|'l'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
op|'['
number|'1'
op|']'
op|','
name|'l'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_verifyHostButNotIP
dedent|''
name|'def'
name|'test_verifyHostButNotIP'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{default.verifyHostKey} should return a L{Deferred} which fires with\n        C{1} when passed a host which matches with an IP is not present in its\n        known_hosts file, and should also warn the user that it has added the\n        IP address.\n        """'
newline|'\n'
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'default'
op|'.'
name|'verifyHostKey'
op|'('
name|'self'
op|'.'
name|'fakeTransport'
op|','
string|'"8.7.6.5"'
op|','
name|'sampleKey'
op|','
nl|'\n'
string|'"Fingerprint not required."'
op|')'
op|'.'
name|'addCallback'
op|'('
name|'l'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
op|'['
string|'"Warning: Permanently added the RSA host key for IP address "'
nl|'\n'
string|'"\'8.7.6.5\' to the list of known hosts."'
op|']'
op|','
nl|'\n'
name|'self'
op|'.'
name|'fakeFile'
op|'.'
name|'outchunks'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
op|'['
number|'1'
op|']'
op|','
name|'l'
op|')'
newline|'\n'
name|'knownHostsFile'
op|'='
name|'KnownHostsFile'
op|'.'
name|'fromPath'
op|'('
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'hostsOption'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'True'
op|','
name|'knownHostsFile'
op|'.'
name|'hasHostKey'
op|'('
string|'"8.7.6.5"'
op|','
nl|'\n'
name|'Key'
op|'.'
name|'fromString'
op|'('
name|'sampleKey'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_verifyQuestion
dedent|''
name|'def'
name|'test_verifyQuestion'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{default.verifyHostKey} should return a L{Default} which fires with\n        C{0} when passed a unknown host that the user refuses to acknowledge.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'fakeTransport'
op|'.'
name|'factory'
op|'.'
name|'options'
op|'['
string|"'host'"
op|']'
op|'='
string|"'fake.example.com'"
newline|'\n'
name|'self'
op|'.'
name|'fakeFile'
op|'.'
name|'inlines'
op|'.'
name|'append'
op|'('
string|'"no"'
op|')'
newline|'\n'
name|'d'
op|'='
name|'default'
op|'.'
name|'verifyHostKey'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'fakeTransport'
op|','
string|'"9.8.7.6"'
op|','
name|'otherSampleKey'
op|','
string|'"No fingerprint!"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
op|'['
string|'"The authenticity of host \'fake.example.com (9.8.7.6)\' "'
nl|'\n'
string|'"can\'t be established.\\n"'
nl|'\n'
string|'"RSA key fingerprint is "'
nl|'\n'
string|'"57:a1:c2:a1:07:a0:2b:f4:ce:b5:e5:b7:ae:cc:e1:99.\\n"'
nl|'\n'
string|'"Are you sure you want to continue connecting (yes/no)? "'
op|']'
op|','
nl|'\n'
name|'self'
op|'.'
name|'fakeFile'
op|'.'
name|'outchunks'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'UserRejectedKey'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_verifyBadKey
dedent|''
name|'def'
name|'test_verifyBadKey'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{default.verifyHostKey} should return a L{Deferred} which fails with\n        L{HostKeyChanged} if the host key is incorrect.\n        """'
newline|'\n'
name|'d'
op|'='
name|'default'
op|'.'
name|'verifyHostKey'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'fakeTransport'
op|','
string|'"4.3.2.1"'
op|','
name|'otherSampleKey'
op|','
nl|'\n'
string|'"Again, not required."'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'HostKeyChanged'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
