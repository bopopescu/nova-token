begin_unit
comment|'# -*- test-case-name: twisted.conch.test.test_manhole -*-'
nl|'\n'
comment|'# Copyright (c) 2001-2007 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTests for L{twisted.conch.manhole}.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'traceback'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'error'
op|','
name|'defer'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'test'
op|'.'
name|'proto_helpers'
name|'import'
name|'StringTransport'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'conch'
op|'.'
name|'test'
op|'.'
name|'test_recvline'
name|'import'
name|'_TelnetMixin'
op|','
name|'_SSHMixin'
op|','
name|'_StdioMixin'
op|','
name|'stdio'
op|','
name|'ssh'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'conch'
name|'import'
name|'manhole'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'conch'
op|'.'
name|'insults'
name|'import'
name|'insults'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|determineDefaultFunctionName
name|'def'
name|'determineDefaultFunctionName'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Return the string used by Python as the name for code objects which are\n    compiled from interactive input or at the top-level of modules.\n    """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
number|'1'
op|'/'
number|'0'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
comment|'# The last frame is this function.  The second to last frame is this'
nl|'\n'
comment|"# function's caller, which is module-scope, which is what we want,"
nl|'\n'
comment|'# so -2.'
nl|'\n'
indent|'        '
name|'return'
name|'traceback'
op|'.'
name|'extract_stack'
op|'('
op|')'
op|'['
op|'-'
number|'2'
op|']'
op|'['
number|'2'
op|']'
newline|'\n'
DECL|variable|defaultFunctionName
dedent|''
dedent|''
name|'defaultFunctionName'
op|'='
name|'determineDefaultFunctionName'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ManholeInterpreterTests
name|'class'
name|'ManholeInterpreterTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{manhole.ManholeInterpreter}.\n    """'
newline|'\n'
DECL|member|test_resetBuffer
name|'def'
name|'test_resetBuffer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{ManholeInterpreter.resetBuffer} should empty the input buffer.\n        """'
newline|'\n'
name|'interpreter'
op|'='
name|'manhole'
op|'.'
name|'ManholeInterpreter'
op|'('
name|'None'
op|')'
newline|'\n'
name|'interpreter'
op|'.'
name|'buffer'
op|'.'
name|'extend'
op|'('
op|'['
string|'"1"'
op|','
string|'"2"'
op|']'
op|')'
newline|'\n'
name|'interpreter'
op|'.'
name|'resetBuffer'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'interpreter'
op|'.'
name|'buffer'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ManholeProtocolTests
dedent|''
dedent|''
name|'class'
name|'ManholeProtocolTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{manhole.Manhole}.\n    """'
newline|'\n'
DECL|member|test_interruptResetsInterpreterBuffer
name|'def'
name|'test_interruptResetsInterpreterBuffer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{manhole.Manhole.handle_INT} should cause the interpreter input buffer\n        to be reset.\n        """'
newline|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'terminal'
op|'='
name|'insults'
op|'.'
name|'ServerProtocol'
op|'('
name|'manhole'
op|'.'
name|'Manhole'
op|')'
newline|'\n'
name|'terminal'
op|'.'
name|'makeConnection'
op|'('
name|'transport'
op|')'
newline|'\n'
name|'protocol'
op|'='
name|'terminal'
op|'.'
name|'terminalProtocol'
newline|'\n'
name|'interpreter'
op|'='
name|'protocol'
op|'.'
name|'interpreter'
newline|'\n'
name|'interpreter'
op|'.'
name|'buffer'
op|'.'
name|'extend'
op|'('
op|'['
string|'"1"'
op|','
string|'"2"'
op|']'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'handle_INT'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'interpreter'
op|'.'
name|'buffer'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|WriterTestCase
dedent|''
dedent|''
name|'class'
name|'WriterTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|testInteger
indent|'    '
name|'def'
name|'testInteger'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'manhole'
op|'.'
name|'lastColorizedLine'
op|'('
string|'"1"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testDoubleQuoteString
dedent|''
name|'def'
name|'testDoubleQuoteString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'manhole'
op|'.'
name|'lastColorizedLine'
op|'('
string|'\'"1"\''
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testSingleQuoteString
dedent|''
name|'def'
name|'testSingleQuoteString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'manhole'
op|'.'
name|'lastColorizedLine'
op|'('
string|'"\'1\'"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testTripleSingleQuotedString
dedent|''
name|'def'
name|'testTripleSingleQuotedString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'manhole'
op|'.'
name|'lastColorizedLine'
op|'('
string|'"\'\'\'1\'\'\'"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testTripleDoubleQuotedString
dedent|''
name|'def'
name|'testTripleDoubleQuotedString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'manhole'
op|'.'
name|'lastColorizedLine'
op|'('
string|'\'"""1"""\''
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testFunctionDefinition
dedent|''
name|'def'
name|'testFunctionDefinition'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'manhole'
op|'.'
name|'lastColorizedLine'
op|'('
string|'"def foo():"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testClassDefinition
dedent|''
name|'def'
name|'testClassDefinition'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'manhole'
op|'.'
name|'lastColorizedLine'
op|'('
string|'"class foo:"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ManholeLoopbackMixin
dedent|''
dedent|''
name|'class'
name|'ManholeLoopbackMixin'
op|':'
newline|'\n'
DECL|variable|serverProtocol
indent|'    '
name|'serverProtocol'
op|'='
name|'manhole'
op|'.'
name|'ColoredManhole'
newline|'\n'
nl|'\n'
DECL|member|wfd
name|'def'
name|'wfd'
op|'('
name|'self'
op|','
name|'d'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'defer'
op|'.'
name|'waitForDeferred'
op|'('
name|'d'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testSimpleExpression
dedent|''
name|'def'
name|'testSimpleExpression'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'done'
op|'='
name|'self'
op|'.'
name|'recvlineClient'
op|'.'
name|'expect'
op|'('
string|'"done"'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_testwrite'
op|'('
nl|'\n'
string|'"1 + 1\\n"'
nl|'\n'
string|'"done"'
op|')'
newline|'\n'
nl|'\n'
DECL|function|finished
name|'def'
name|'finished'
op|'('
name|'ign'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_assertBuffer'
op|'('
nl|'\n'
op|'['
string|'">>> 1 + 1"'
op|','
nl|'\n'
string|'"2"'
op|','
nl|'\n'
string|'">>> done"'
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'done'
op|'.'
name|'addCallback'
op|'('
name|'finished'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testTripleQuoteLineContinuation
dedent|''
name|'def'
name|'testTripleQuoteLineContinuation'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'done'
op|'='
name|'self'
op|'.'
name|'recvlineClient'
op|'.'
name|'expect'
op|'('
string|'"done"'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_testwrite'
op|'('
nl|'\n'
string|'"\'\'\'\\n\'\'\'\\n"'
nl|'\n'
string|'"done"'
op|')'
newline|'\n'
nl|'\n'
DECL|function|finished
name|'def'
name|'finished'
op|'('
name|'ign'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_assertBuffer'
op|'('
nl|'\n'
op|'['
string|'">>> \'\'\'"'
op|','
nl|'\n'
string|'"... \'\'\'"'
op|','
nl|'\n'
string|'"\'\\\\n\'"'
op|','
nl|'\n'
string|'">>> done"'
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'done'
op|'.'
name|'addCallback'
op|'('
name|'finished'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testFunctionDefinition
dedent|''
name|'def'
name|'testFunctionDefinition'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'done'
op|'='
name|'self'
op|'.'
name|'recvlineClient'
op|'.'
name|'expect'
op|'('
string|'"done"'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_testwrite'
op|'('
nl|'\n'
string|'"def foo(bar):\\n"'
nl|'\n'
string|'"\\tprint bar\\n\\n"'
nl|'\n'
string|'"foo(42)\\n"'
nl|'\n'
string|'"done"'
op|')'
newline|'\n'
nl|'\n'
DECL|function|finished
name|'def'
name|'finished'
op|'('
name|'ign'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_assertBuffer'
op|'('
nl|'\n'
op|'['
string|'">>> def foo(bar):"'
op|','
nl|'\n'
string|'"...     print bar"'
op|','
nl|'\n'
string|'"... "'
op|','
nl|'\n'
string|'">>> foo(42)"'
op|','
nl|'\n'
string|'"42"'
op|','
nl|'\n'
string|'">>> done"'
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'done'
op|'.'
name|'addCallback'
op|'('
name|'finished'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testClassDefinition
dedent|''
name|'def'
name|'testClassDefinition'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'done'
op|'='
name|'self'
op|'.'
name|'recvlineClient'
op|'.'
name|'expect'
op|'('
string|'"done"'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_testwrite'
op|'('
nl|'\n'
string|'"class Foo:\\n"'
nl|'\n'
string|'"\\tdef bar(self):\\n"'
nl|'\n'
string|'"\\t\\tprint \'Hello, world!\'\\n\\n"'
nl|'\n'
string|'"Foo().bar()\\n"'
nl|'\n'
string|'"done"'
op|')'
newline|'\n'
nl|'\n'
DECL|function|finished
name|'def'
name|'finished'
op|'('
name|'ign'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_assertBuffer'
op|'('
nl|'\n'
op|'['
string|'">>> class Foo:"'
op|','
nl|'\n'
string|'"...     def bar(self):"'
op|','
nl|'\n'
string|'"...         print \'Hello, world!\'"'
op|','
nl|'\n'
string|'"... "'
op|','
nl|'\n'
string|'">>> Foo().bar()"'
op|','
nl|'\n'
string|'"Hello, world!"'
op|','
nl|'\n'
string|'">>> done"'
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'done'
op|'.'
name|'addCallback'
op|'('
name|'finished'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testException
dedent|''
name|'def'
name|'testException'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'done'
op|'='
name|'self'
op|'.'
name|'recvlineClient'
op|'.'
name|'expect'
op|'('
string|'"done"'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_testwrite'
op|'('
nl|'\n'
string|'"raise Exception(\'foo bar baz\')\\n"'
nl|'\n'
string|'"done"'
op|')'
newline|'\n'
nl|'\n'
DECL|function|finished
name|'def'
name|'finished'
op|'('
name|'ign'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_assertBuffer'
op|'('
nl|'\n'
op|'['
string|'">>> raise Exception(\'foo bar baz\')"'
op|','
nl|'\n'
string|'"Traceback (most recent call last):"'
op|','
nl|'\n'
string|'\'  File "<console>", line 1, in \''
op|'+'
name|'defaultFunctionName'
op|','
nl|'\n'
string|'"Exception: foo bar baz"'
op|','
nl|'\n'
string|'">>> done"'
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'done'
op|'.'
name|'addCallback'
op|'('
name|'finished'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testControlC
dedent|''
name|'def'
name|'testControlC'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'done'
op|'='
name|'self'
op|'.'
name|'recvlineClient'
op|'.'
name|'expect'
op|'('
string|'"done"'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_testwrite'
op|'('
nl|'\n'
string|'"cancelled line"'
op|'+'
name|'manhole'
op|'.'
name|'CTRL_C'
op|'+'
nl|'\n'
string|'"done"'
op|')'
newline|'\n'
nl|'\n'
DECL|function|finished
name|'def'
name|'finished'
op|'('
name|'ign'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_assertBuffer'
op|'('
nl|'\n'
op|'['
string|'">>> cancelled line"'
op|','
nl|'\n'
string|'"KeyboardInterrupt"'
op|','
nl|'\n'
string|'">>> done"'
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'done'
op|'.'
name|'addCallback'
op|'('
name|'finished'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_interruptDuringContinuation
dedent|''
name|'def'
name|'test_interruptDuringContinuation'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Sending ^C to Manhole while in a state where more input is required to\n        complete a statement should discard the entire ongoing statement and\n        reset the input prompt to the non-continuation prompt.\n        """'
newline|'\n'
name|'continuing'
op|'='
name|'self'
op|'.'
name|'recvlineClient'
op|'.'
name|'expect'
op|'('
string|'"things"'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_testwrite'
op|'('
string|'"(\\nthings"'
op|')'
newline|'\n'
nl|'\n'
DECL|function|gotContinuation
name|'def'
name|'gotContinuation'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_assertBuffer'
op|'('
nl|'\n'
op|'['
string|'">>> ("'
op|','
nl|'\n'
string|'"... things"'
op|']'
op|')'
newline|'\n'
name|'interrupted'
op|'='
name|'self'
op|'.'
name|'recvlineClient'
op|'.'
name|'expect'
op|'('
string|'">>> "'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_testwrite'
op|'('
name|'manhole'
op|'.'
name|'CTRL_C'
op|')'
newline|'\n'
name|'return'
name|'interrupted'
newline|'\n'
dedent|''
name|'continuing'
op|'.'
name|'addCallback'
op|'('
name|'gotContinuation'
op|')'
newline|'\n'
nl|'\n'
DECL|function|gotInterruption
name|'def'
name|'gotInterruption'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_assertBuffer'
op|'('
nl|'\n'
op|'['
string|'">>> ("'
op|','
nl|'\n'
string|'"... things"'
op|','
nl|'\n'
string|'"KeyboardInterrupt"'
op|','
nl|'\n'
string|'">>> "'
op|']'
op|')'
newline|'\n'
dedent|''
name|'continuing'
op|'.'
name|'addCallback'
op|'('
name|'gotInterruption'
op|')'
newline|'\n'
name|'return'
name|'continuing'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testControlBackslash
dedent|''
name|'def'
name|'testControlBackslash'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_testwrite'
op|'('
string|'"cancelled line"'
op|')'
newline|'\n'
name|'partialLine'
op|'='
name|'self'
op|'.'
name|'recvlineClient'
op|'.'
name|'expect'
op|'('
string|'"cancelled line"'
op|')'
newline|'\n'
nl|'\n'
DECL|function|gotPartialLine
name|'def'
name|'gotPartialLine'
op|'('
name|'ign'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_assertBuffer'
op|'('
nl|'\n'
op|'['
string|'">>> cancelled line"'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_testwrite'
op|'('
name|'manhole'
op|'.'
name|'CTRL_BACKSLASH'
op|')'
newline|'\n'
nl|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'recvlineClient'
op|'.'
name|'onDisconnection'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'error'
op|'.'
name|'ConnectionDone'
op|')'
newline|'\n'
nl|'\n'
DECL|function|gotClearedLine
dedent|''
name|'def'
name|'gotClearedLine'
op|'('
name|'ign'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_assertBuffer'
op|'('
nl|'\n'
op|'['
string|'""'
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'partialLine'
op|'.'
name|'addCallback'
op|'('
name|'gotPartialLine'
op|')'
op|'.'
name|'addCallback'
op|'('
name|'gotClearedLine'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testControlD
dedent|''
name|'def'
name|'testControlD'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_testwrite'
op|'('
string|'"1 + 1"'
op|')'
newline|'\n'
name|'helloWorld'
op|'='
name|'self'
op|'.'
name|'wfd'
op|'('
name|'self'
op|'.'
name|'recvlineClient'
op|'.'
name|'expect'
op|'('
string|'r"\\+ 1"'
op|')'
op|')'
newline|'\n'
name|'yield'
name|'helloWorld'
newline|'\n'
name|'helloWorld'
op|'.'
name|'getResult'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_assertBuffer'
op|'('
op|'['
string|'">>> 1 + 1"'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_testwrite'
op|'('
name|'manhole'
op|'.'
name|'CTRL_D'
op|'+'
string|'" + 1"'
op|')'
newline|'\n'
name|'cleared'
op|'='
name|'self'
op|'.'
name|'wfd'
op|'('
name|'self'
op|'.'
name|'recvlineClient'
op|'.'
name|'expect'
op|'('
string|'r"\\+ 1"'
op|')'
op|')'
newline|'\n'
name|'yield'
name|'cleared'
newline|'\n'
name|'cleared'
op|'.'
name|'getResult'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_assertBuffer'
op|'('
op|'['
string|'">>> 1 + 1 + 1"'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_testwrite'
op|'('
string|'"\\n"'
op|')'
newline|'\n'
name|'printed'
op|'='
name|'self'
op|'.'
name|'wfd'
op|'('
name|'self'
op|'.'
name|'recvlineClient'
op|'.'
name|'expect'
op|'('
string|'"3\\n>>> "'
op|')'
op|')'
newline|'\n'
name|'yield'
name|'printed'
newline|'\n'
name|'printed'
op|'.'
name|'getResult'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_testwrite'
op|'('
name|'manhole'
op|'.'
name|'CTRL_D'
op|')'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'recvlineClient'
op|'.'
name|'onDisconnection'
newline|'\n'
name|'disconnected'
op|'='
name|'self'
op|'.'
name|'wfd'
op|'('
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'error'
op|'.'
name|'ConnectionDone'
op|')'
op|')'
newline|'\n'
name|'yield'
name|'disconnected'
newline|'\n'
name|'disconnected'
op|'.'
name|'getResult'
op|'('
op|')'
newline|'\n'
DECL|variable|testControlD
dedent|''
name|'testControlD'
op|'='
name|'defer'
op|'.'
name|'deferredGenerator'
op|'('
name|'testControlD'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testControlL
name|'def'
name|'testControlL'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        CTRL+L is generally used as a redraw-screen command in terminal\n        applications.  Manhole doesn\'t currently respect this usage of it,\n        but it should at least do something reasonable in response to this\n        event (rather than, say, eating your face).\n        """'
newline|'\n'
comment|'# Start off with a newline so that when we clear the display we can'
nl|'\n'
comment|'# tell by looking for the missing first empty prompt line.'
nl|'\n'
name|'self'
op|'.'
name|'_testwrite'
op|'('
string|'"\\n1 + 1"'
op|')'
newline|'\n'
name|'helloWorld'
op|'='
name|'self'
op|'.'
name|'wfd'
op|'('
name|'self'
op|'.'
name|'recvlineClient'
op|'.'
name|'expect'
op|'('
string|'r"\\+ 1"'
op|')'
op|')'
newline|'\n'
name|'yield'
name|'helloWorld'
newline|'\n'
name|'helloWorld'
op|'.'
name|'getResult'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_assertBuffer'
op|'('
op|'['
string|'">>> "'
op|','
string|'">>> 1 + 1"'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_testwrite'
op|'('
name|'manhole'
op|'.'
name|'CTRL_L'
op|'+'
string|'" + 1"'
op|')'
newline|'\n'
name|'redrew'
op|'='
name|'self'
op|'.'
name|'wfd'
op|'('
name|'self'
op|'.'
name|'recvlineClient'
op|'.'
name|'expect'
op|'('
string|'r"1 \\+ 1 \\+ 1"'
op|')'
op|')'
newline|'\n'
name|'yield'
name|'redrew'
newline|'\n'
name|'redrew'
op|'.'
name|'getResult'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_assertBuffer'
op|'('
op|'['
string|'">>> 1 + 1 + 1"'
op|']'
op|')'
newline|'\n'
DECL|variable|testControlL
dedent|''
name|'testControlL'
op|'='
name|'defer'
op|'.'
name|'deferredGenerator'
op|'('
name|'testControlL'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testDeferred
name|'def'
name|'testDeferred'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_testwrite'
op|'('
nl|'\n'
string|'"from twisted.internet import defer, reactor\\n"'
nl|'\n'
string|'"d = defer.Deferred()\\n"'
nl|'\n'
string|'"d\\n"'
op|')'
newline|'\n'
nl|'\n'
name|'deferred'
op|'='
name|'self'
op|'.'
name|'wfd'
op|'('
name|'self'
op|'.'
name|'recvlineClient'
op|'.'
name|'expect'
op|'('
string|'"<Deferred #0>"'
op|')'
op|')'
newline|'\n'
name|'yield'
name|'deferred'
newline|'\n'
name|'deferred'
op|'.'
name|'getResult'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_testwrite'
op|'('
nl|'\n'
string|'"c = reactor.callLater(0.1, d.callback, \'Hi!\')\\n"'
op|')'
newline|'\n'
name|'delayed'
op|'='
name|'self'
op|'.'
name|'wfd'
op|'('
name|'self'
op|'.'
name|'recvlineClient'
op|'.'
name|'expect'
op|'('
string|'">>> "'
op|')'
op|')'
newline|'\n'
name|'yield'
name|'delayed'
newline|'\n'
name|'delayed'
op|'.'
name|'getResult'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'called'
op|'='
name|'self'
op|'.'
name|'wfd'
op|'('
name|'self'
op|'.'
name|'recvlineClient'
op|'.'
name|'expect'
op|'('
string|'"Deferred #0 called back: \'Hi!\'\\n>>> "'
op|')'
op|')'
newline|'\n'
name|'yield'
name|'called'
newline|'\n'
name|'called'
op|'.'
name|'getResult'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_assertBuffer'
op|'('
nl|'\n'
op|'['
string|'">>> from twisted.internet import defer, reactor"'
op|','
nl|'\n'
string|'">>> d = defer.Deferred()"'
op|','
nl|'\n'
string|'">>> d"'
op|','
nl|'\n'
string|'"<Deferred #0>"'
op|','
nl|'\n'
string|'">>> c = reactor.callLater(0.1, d.callback, \'Hi!\')"'
op|','
nl|'\n'
string|'"Deferred #0 called back: \'Hi!\'"'
op|','
nl|'\n'
string|'">>> "'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|testDeferred
dedent|''
name|'testDeferred'
op|'='
name|'defer'
op|'.'
name|'deferredGenerator'
op|'('
name|'testDeferred'
op|')'
newline|'\n'
nl|'\n'
DECL|class|ManholeLoopbackTelnet
dedent|''
name|'class'
name|'ManholeLoopbackTelnet'
op|'('
name|'_TelnetMixin'
op|','
name|'unittest'
op|'.'
name|'TestCase'
op|','
name|'ManholeLoopbackMixin'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
nl|'\n'
DECL|class|ManholeLoopbackSSH
dedent|''
name|'class'
name|'ManholeLoopbackSSH'
op|'('
name|'_SSHMixin'
op|','
name|'unittest'
op|'.'
name|'TestCase'
op|','
name|'ManholeLoopbackMixin'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'ssh'
name|'is'
name|'None'
op|':'
newline|'\n'
DECL|variable|skip
indent|'        '
name|'skip'
op|'='
string|'"Crypto requirements missing, can\'t run manhole tests over ssh"'
newline|'\n'
nl|'\n'
DECL|class|ManholeLoopbackStdio
dedent|''
dedent|''
name|'class'
name|'ManholeLoopbackStdio'
op|'('
name|'_StdioMixin'
op|','
name|'unittest'
op|'.'
name|'TestCase'
op|','
name|'ManholeLoopbackMixin'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'stdio'
name|'is'
name|'None'
op|':'
newline|'\n'
DECL|variable|skip
indent|'        '
name|'skip'
op|'='
string|'"Terminal requirements missing, can\'t run manhole tests over stdio"'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
DECL|variable|serverProtocol
indent|'        '
name|'serverProtocol'
op|'='
name|'stdio'
op|'.'
name|'ConsoleManhole'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
