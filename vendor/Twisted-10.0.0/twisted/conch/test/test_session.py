begin_unit
comment|'# Copyright (c) 2007-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTests for the \'session\' channel implementation in twisted.conch.ssh.session.\n\nSee also RFC 4254.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'os'
op|','
name|'signal'
op|','
name|'sys'
op|','
name|'struct'
newline|'\n'
nl|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'implements'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'error'
name|'import'
name|'ProcessTerminated'
op|','
name|'ProcessDone'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'failure'
name|'import'
name|'Failure'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'conch'
op|'.'
name|'ssh'
name|'import'
name|'common'
op|','
name|'session'
op|','
name|'connection'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'defer'
op|','
name|'protocol'
op|','
name|'error'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'components'
op|','
name|'failure'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|SubsystemOnlyAvatar
name|'class'
name|'SubsystemOnlyAvatar'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A stub class representing an avatar that is only useful for\n    getting a subsystem.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|lookupSubsystem
name|'def'
name|'lookupSubsystem'
op|'('
name|'self'
op|','
name|'name'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the other side requests the \'subsystem\' subsystem, allow it by\n        returning a MockProtocol to implement it.  Otherwise, return\n        None which is interpreted by SSHSession as a failure.\n        """'
newline|'\n'
name|'if'
name|'name'
op|'=='
string|"'subsystem'"
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'MockProtocol'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|StubAvatar
dedent|''
dedent|''
dedent|''
name|'class'
name|'StubAvatar'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A stub class representing the avatar representing the authenticated user.\n    It implements the I{ISession} interface.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|lookupSubsystem
name|'def'
name|'lookupSubsystem'
op|'('
name|'self'
op|','
name|'name'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the user requests the TestSubsystem subsystem, connect them to a\n        MockProtocol.  If they request neither, then None is returned which is\n        interpreted by SSHSession as a failure.\n        """'
newline|'\n'
name|'if'
name|'name'
op|'=='
string|"'TestSubsystem'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'subsystem'
op|'='
name|'MockProtocol'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'subsystem'
op|'.'
name|'packetData'
op|'='
name|'data'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'subsystem'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|StubSessionForStubAvatar
dedent|''
dedent|''
dedent|''
name|'class'
name|'StubSessionForStubAvatar'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A stub ISession implementation for our StubAvatar.  The instance\n    variables generally keep track of method invocations so that we can test\n    that the methods were called.\n\n    @ivar avatar: the L{StubAvatar} we are adapting.\n    @ivar ptyRequest: if present, the terminal, window size, and modes passed\n        to the getPty method.\n    @ivar windowChange: if present, the window size passed to the\n        windowChangned method.\n    @ivar shellProtocol: if present, the L{SSHSessionProcessProtocol} passed\n        to the openShell method.\n    @ivar shellTransport: if present, the L{EchoTransport} connected to\n        shellProtocol.\n    @ivar execProtocol: if present, the L{SSHSessionProcessProtocol} passed\n        to the execCommand method.\n    @ivar execTransport: if present, the L{EchoTransport} connected to\n        execProtocol.\n    @ivar execCommandLine: if present, the command line passed to the\n        execCommand method.\n    @ivar gotEOF: if present, an EOF message was received.\n    @ivar gotClosed: if present, a closed message was received.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
name|'implements'
op|'('
name|'session'
op|'.'
name|'ISession'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'avatar'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Store the avatar we\'re adapting.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'avatar'
op|'='
name|'avatar'
newline|'\n'
name|'self'
op|'.'
name|'shellProtocol'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getPty
dedent|''
name|'def'
name|'getPty'
op|'('
name|'self'
op|','
name|'terminal'
op|','
name|'window'
op|','
name|'modes'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the terminal is \'bad\', fail.  Otherwise, store the information in\n        the ptyRequest variable.\n        """'
newline|'\n'
name|'if'
name|'terminal'
op|'!='
string|"'bad'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'ptyRequest'
op|'='
op|'('
name|'terminal'
op|','
name|'window'
op|','
name|'modes'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'RuntimeError'
op|'('
string|"'not getting a pty'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|windowChanged
dedent|''
dedent|''
name|'def'
name|'windowChanged'
op|'('
name|'self'
op|','
name|'window'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If all the window sizes are 0, fail.  Otherwise, store the size in the\n        windowChange variable.\n        """'
newline|'\n'
name|'if'
name|'window'
op|'=='
op|'('
number|'0'
op|','
number|'0'
op|','
number|'0'
op|','
number|'0'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'RuntimeError'
op|'('
string|"'not changing the window size'"
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'windowChange'
op|'='
name|'window'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|openShell
dedent|''
dedent|''
name|'def'
name|'openShell'
op|'('
name|'self'
op|','
name|'pp'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If we have gotten a shell request before, fail.  Otherwise, store the\n        process protocol in the shellProtocol variable, connect it to the\n        EchoTransport and store that as shellTransport.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'shellProtocol'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'RuntimeError'
op|'('
string|"'not getting a shell this time'"
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'shellProtocol'
op|'='
name|'pp'
newline|'\n'
name|'self'
op|'.'
name|'shellTransport'
op|'='
name|'EchoTransport'
op|'('
name|'pp'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|execCommand
dedent|''
dedent|''
name|'def'
name|'execCommand'
op|'('
name|'self'
op|','
name|'pp'
op|','
name|'command'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the command is \'true\', store the command, the process protocol, and\n        the transport we connect to the process protocol.  Otherwise, just\n        store the command and raise an error.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'execCommandLine'
op|'='
name|'command'
newline|'\n'
name|'if'
name|'command'
op|'=='
string|"'success'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'execProtocol'
op|'='
name|'pp'
newline|'\n'
dedent|''
name|'elif'
name|'command'
op|'['
op|':'
number|'6'
op|']'
op|'=='
string|"'repeat'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'execProtocol'
op|'='
name|'pp'
newline|'\n'
name|'self'
op|'.'
name|'execTransport'
op|'='
name|'EchoTransport'
op|'('
name|'pp'
op|')'
newline|'\n'
name|'pp'
op|'.'
name|'outReceived'
op|'('
name|'command'
op|'['
number|'7'
op|':'
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'RuntimeError'
op|'('
string|"'not getting a command'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|eofReceived
dedent|''
dedent|''
name|'def'
name|'eofReceived'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Note that EOF has been received.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'gotEOF'
op|'='
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|closed
dedent|''
name|'def'
name|'closed'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Note that close has been received.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'gotClosed'
op|'='
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'components'
op|'.'
name|'registerAdapter'
op|'('
name|'StubSessionForStubAvatar'
op|','
name|'StubAvatar'
op|','
nl|'\n'
name|'session'
op|'.'
name|'ISession'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|MockProcessProtocol
name|'class'
name|'MockProcessProtocol'
op|'('
name|'protocol'
op|'.'
name|'ProcessProtocol'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A mock ProcessProtocol which echoes back data sent to it and\n    appends a tilde.  The tilde is appended so the tests can verify that\n    we received and processed the data.\n\n    @ivar packetData: C{str} of data to be sent when the connection is made.\n    @ivar data: a C{str} of data received.\n    @ivar err: a C{str} of error data received.\n    @ivar inConnectionOpen: True if the input side is open.\n    @ivar outConnectionOpen: True if the output side is open.\n    @ivar errConnectionOpen: True if the error side is open.\n    @ivar ended: False if the protocol has not ended, a C{Failure} if the\n        process has ended.\n    """'
newline|'\n'
DECL|variable|packetData
name|'packetData'
op|'='
string|"''"
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionMade
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Set up variables.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'data'
op|'='
string|"''"
newline|'\n'
name|'self'
op|'.'
name|'err'
op|'='
string|"''"
newline|'\n'
name|'self'
op|'.'
name|'inConnectionOpen'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'outConnectionOpen'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'errConnectionOpen'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'ended'
op|'='
name|'False'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'packetData'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'outReceived'
op|'('
name|'self'
op|'.'
name|'packetData'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|outReceived
dedent|''
dedent|''
name|'def'
name|'outReceived'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Data was received.  Store it and echo it back with a tilde.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'data'
op|'+='
name|'data'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'transport'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
name|'data'
op|'+'
string|"'~'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|errReceived
dedent|''
dedent|''
name|'def'
name|'errReceived'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Error data was received.  Store it and echo it back backwards.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'err'
op|'+='
name|'data'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
name|'data'
op|'['
op|':'
op|':'
op|'-'
number|'1'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|inConnectionLost
dedent|''
name|'def'
name|'inConnectionLost'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Close the input side.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'inConnectionOpen'
op|'='
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|outConnectionLost
dedent|''
name|'def'
name|'outConnectionLost'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Close the output side.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'outConnectionOpen'
op|'='
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|errConnectionLost
dedent|''
name|'def'
name|'errConnectionLost'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Close the error side.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'errConnectionOpen'
op|'='
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|processEnded
dedent|''
name|'def'
name|'processEnded'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        End the process and store the reason.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'ended'
op|'='
name|'reason'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|EchoTransport
dedent|''
dedent|''
name|'class'
name|'EchoTransport'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A transport for a ProcessProtocol which echos data that is sent to it with\n    a Window newline (CR LF) appended to it.  If a null byte is in the data,\n    disconnect.  When we are asked to disconnect, disconnect the\n    C{ProcessProtocol} with a 0 exit code.\n\n    @ivar proto: the C{ProcessProtocol} connected to us.\n    @ivar data: a C{str} of data written to us.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'processProtocol'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Initialize our instance variables.\n\n        @param processProtocol: a C{ProcessProtocol} to connect to ourself.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'='
name|'processProtocol'
newline|'\n'
name|'self'
op|'.'
name|'closed'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'data'
op|'='
string|"''"
newline|'\n'
name|'processProtocol'
op|'.'
name|'makeConnection'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|write
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        We got some data.  Give it back to our C{ProcessProtocol} with\n        a newline attached.  Disconnect if there\'s a null byte.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'data'
op|'+='
name|'data'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'outReceived'
op|'('
name|'data'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'outReceived'
op|'('
string|"'\\r\\n'"
op|')'
newline|'\n'
name|'if'
string|"'\\x00'"
name|'in'
name|'data'
op|':'
comment|"# mimic 'exit' for the shell test"
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|loseConnection
dedent|''
dedent|''
name|'def'
name|'loseConnection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If we\'re asked to disconnect (and we haven\'t already) shut down\n        the C{ProcessProtocol} with a 0 exit code.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'closed'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'closed'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'inConnectionLost'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'outConnectionLost'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'errConnectionLost'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'processEnded'
op|'('
name|'failure'
op|'.'
name|'Failure'
op|'('
nl|'\n'
name|'error'
op|'.'
name|'ProcessTerminated'
op|'('
number|'0'
op|','
name|'None'
op|','
name|'None'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|MockProtocol
dedent|''
dedent|''
name|'class'
name|'MockProtocol'
op|'('
name|'protocol'
op|'.'
name|'Protocol'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A sample Protocol which stores the data passed to it.\n\n    @ivar packetData: a C{str} of data to be sent when the connection is made.\n    @ivar data: a C{str} of the data passed to us.\n    @ivar open: True if the channel is open.\n    @ivar reason: if not None, the reason the protocol was closed.\n    """'
newline|'\n'
DECL|variable|packetData
name|'packetData'
op|'='
string|"''"
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionMade
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Set up the instance variables.  If we have any packetData, send it\n        along.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'data'
op|'='
string|"''"
newline|'\n'
name|'self'
op|'.'
name|'open'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'reason'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'packetData'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'dataReceived'
op|'('
name|'self'
op|'.'
name|'packetData'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|dataReceived
dedent|''
dedent|''
name|'def'
name|'dataReceived'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Store the received data and write it back with a tilde appended.\n        The tilde is appended so that the tests can verify that we processed\n        the data.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'data'
op|'+='
name|'data'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'transport'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
name|'data'
op|'+'
string|"'~'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionLost
dedent|''
dedent|''
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Close the protocol and store the reason.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'open'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'reason'
op|'='
name|'reason'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|StubConnection
dedent|''
dedent|''
name|'class'
name|'StubConnection'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A stub for twisted.conch.ssh.connection.SSHConnection.  Record the data\n    that channels send, and when they try to close the connection.\n\n    @ivar data: a C{dict} mapping C{SSHChannel}s to a C{list} of C{str} of data\n        they sent.\n    @ivar extData: a C{dict} mapping L{SSHChannel}s to a C{list} of C{tuple} of\n        (C{int}, C{str}) of extended data they sent.\n    @ivar requests: a C{dict} mapping L{SSHChannel}s to a C{list} of C{tuple}\n        of (C{str}, C{str}) of channel requests they made.\n    @ivar eofs: a C{dict} mapping L{SSHChannel}s to C{true} if they have sent\n        an EOF.\n    @ivar closes: a C{dict} mapping L{SSHChannel}s to C{true} if they have sent\n        a close.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Initialize our instance variables.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'data'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'extData'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'requests'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'eofs'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'closes'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|logPrefix
dedent|''
name|'def'
name|'logPrefix'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return our logging prefix.\n        """'
newline|'\n'
name|'return'
string|'"MockConnection"'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|sendData
dedent|''
name|'def'
name|'sendData'
op|'('
name|'self'
op|','
name|'channel'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Record the sent data.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'data'
op|'.'
name|'setdefault'
op|'('
name|'channel'
op|','
op|'['
op|']'
op|')'
op|'.'
name|'append'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|sendExtendedData
dedent|''
name|'def'
name|'sendExtendedData'
op|'('
name|'self'
op|','
name|'channel'
op|','
name|'type'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Record the sent extended data.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'extData'
op|'.'
name|'setdefault'
op|'('
name|'channel'
op|','
op|'['
op|']'
op|')'
op|'.'
name|'append'
op|'('
op|'('
name|'type'
op|','
name|'data'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|sendRequest
dedent|''
name|'def'
name|'sendRequest'
op|'('
name|'self'
op|','
name|'channel'
op|','
name|'request'
op|','
name|'data'
op|','
name|'wantReply'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Record the sent channel request.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'requests'
op|'.'
name|'setdefault'
op|'('
name|'channel'
op|','
op|'['
op|']'
op|')'
op|'.'
name|'append'
op|'('
op|'('
name|'request'
op|','
name|'data'
op|','
nl|'\n'
name|'wantReply'
op|')'
op|')'
newline|'\n'
name|'if'
name|'wantReply'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'defer'
op|'.'
name|'succeed'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|sendEOF
dedent|''
dedent|''
name|'def'
name|'sendEOF'
op|'('
name|'self'
op|','
name|'channel'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Record the sent EOF.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'eofs'
op|'['
name|'channel'
op|']'
op|'='
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|sendClose
dedent|''
name|'def'
name|'sendClose'
op|'('
name|'self'
op|','
name|'channel'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Record the sent close.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'closes'
op|'['
name|'channel'
op|']'
op|'='
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|StubTransport
dedent|''
dedent|''
name|'class'
name|'StubTransport'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A stub transport which records the data written.\n\n    @ivar buf: the data sent to the transport.\n    @type buf: C{str}\n\n    @ivar close: flags indicating if the transport has been closed.\n    @type close: C{bool}\n    """'
newline|'\n'
nl|'\n'
DECL|variable|buf
name|'buf'
op|'='
string|"''"
newline|'\n'
DECL|variable|close
name|'close'
op|'='
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|write
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Record data in the buffer.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'buf'
op|'+='
name|'data'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|loseConnection
dedent|''
name|'def'
name|'loseConnection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Note that the connection was closed.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'close'
op|'='
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|StubTransportWithWriteErr
dedent|''
dedent|''
name|'class'
name|'StubTransportWithWriteErr'
op|'('
name|'StubTransport'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A version of StubTransport which records the error data sent to it.\n\n    @ivar err: the extended data sent to the transport.\n    @type err: C{str}\n    """'
newline|'\n'
nl|'\n'
DECL|variable|err
name|'err'
op|'='
string|"''"
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|writeErr
name|'def'
name|'writeErr'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Record the extended data in the buffer.  This was an old interface\n        that allowed the Transports from ISession.openShell() or\n        ISession.execCommand() to receive extended data from the client.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'err'
op|'+='
name|'data'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|StubClient
dedent|''
dedent|''
name|'class'
name|'StubClient'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A stub class representing the client to a SSHSession.\n\n    @ivar transport: A L{StubTransport} object which keeps track of the data\n        passed to it.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'transport'
op|'='
name|'StubTransportWithWriteErr'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|SessionInterfaceTestCase
dedent|''
dedent|''
name|'class'
name|'SessionInterfaceTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for the SSHSession class interface.  This interface is not ideal, but\n    it is tested in order to maintain backwards compatibility.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Make an SSHSession object to test.  Give the channel some window\n        so that it\'s allowed to send packets.  500 and 100 are arbitrary\n        values.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'='
name|'session'
op|'.'
name|'SSHSession'
op|'('
name|'remoteWindow'
op|'='
number|'500'
op|','
nl|'\n'
name|'remoteMaxPacket'
op|'='
number|'100'
op|','
name|'conn'
op|'='
name|'StubConnection'
op|'('
op|')'
op|','
nl|'\n'
name|'avatar'
op|'='
name|'StubAvatar'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|assertSessionIsStubSession
dedent|''
name|'def'
name|'assertSessionIsStubSession'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Asserts that self.session.session is an instance of\n        StubSessionForStubOldAvatar.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'session'
op|','
nl|'\n'
name|'StubSessionForStubAvatar'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_init
dedent|''
name|'def'
name|'test_init'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        SSHSession initializes its buffer (buf), client, and ISession adapter.\n        The avatar should not need to be adaptable to an ISession immediately.\n        """'
newline|'\n'
name|'s'
op|'='
name|'session'
op|'.'
name|'SSHSession'
op|'('
name|'avatar'
op|'='
name|'object'
op|')'
comment|"# use object because it doesn't"
newline|'\n'
comment|'# have an adapter'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'s'
op|'.'
name|'buf'
op|','
string|"''"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'s'
op|'.'
name|'client'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'s'
op|'.'
name|'session'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_client_dataReceived
dedent|''
name|'def'
name|'test_client_dataReceived'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        SSHSession.dataReceived() passes data along to a client.  If the data\n        comes before there is a client, the data should be discarded.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'dataReceived'
op|'('
string|"'1'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'client'
op|'='
name|'StubClient'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'dataReceived'
op|'('
string|"'2'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'client'
op|'.'
name|'transport'
op|'.'
name|'buf'
op|','
string|"'2'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_client_extReceived
dedent|''
name|'def'
name|'test_client_extReceived'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        SSHSession.extReceived() passed data of type EXTENDED_DATA_STDERR along\n        to the client.  If the data comes before there is a client, or if the\n        data is not of type EXTENDED_DATA_STDERR, it is discared.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'extReceived'
op|'('
name|'connection'
op|'.'
name|'EXTENDED_DATA_STDERR'
op|','
string|"'1'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'extReceived'
op|'('
number|'255'
op|','
string|"'2'"
op|')'
comment|'# 255 is arbitrary'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'client'
op|'='
name|'StubClient'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'extReceived'
op|'('
name|'connection'
op|'.'
name|'EXTENDED_DATA_STDERR'
op|','
string|"'3'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'client'
op|'.'
name|'transport'
op|'.'
name|'err'
op|','
string|"'3'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_client_extReceivedWithoutWriteErr
dedent|''
name|'def'
name|'test_client_extReceivedWithoutWriteErr'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        SSHSession.extReceived() should handle the case where the transport\n        on the client doesn\'t have a writeErr method.\n        """'
newline|'\n'
name|'client'
op|'='
name|'self'
op|'.'
name|'session'
op|'.'
name|'client'
op|'='
name|'StubClient'
op|'('
op|')'
newline|'\n'
name|'client'
op|'.'
name|'transport'
op|'='
name|'StubTransport'
op|'('
op|')'
comment|"# doesn't have writeErr"
newline|'\n'
nl|'\n'
comment|'# should not raise an error'
nl|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'extReceived'
op|'('
name|'connection'
op|'.'
name|'EXTENDED_DATA_STDERR'
op|','
string|"'ignored'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_client_closed
dedent|''
name|'def'
name|'test_client_closed'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        SSHSession.closed() should tell the transport connected to the client\n        that the connection was lost.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'client'
op|'='
name|'StubClient'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'closed'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'client'
op|'.'
name|'transport'
op|'.'
name|'close'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'client'
op|'.'
name|'transport'
op|'.'
name|'close'
op|'='
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_badSubsystemDoesNotCreateClient
dedent|''
name|'def'
name|'test_badSubsystemDoesNotCreateClient'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When a subsystem request fails, SSHSession.client should not be set.\n        """'
newline|'\n'
name|'ret'
op|'='
name|'self'
op|'.'
name|'session'
op|'.'
name|'requestReceived'
op|'('
nl|'\n'
string|"'subsystem'"
op|','
name|'common'
op|'.'
name|'NS'
op|'('
string|"'BadSubsystem'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'ret'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'client'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_lookupSubsystem
dedent|''
name|'def'
name|'test_lookupSubsystem'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When a client requests a subsystem, the SSHSession object should get\n        the subsystem by calling avatar.lookupSubsystem, and attach it as\n        the client.\n        """'
newline|'\n'
name|'ret'
op|'='
name|'self'
op|'.'
name|'session'
op|'.'
name|'requestReceived'
op|'('
nl|'\n'
string|"'subsystem'"
op|','
name|'common'
op|'.'
name|'NS'
op|'('
string|"'TestSubsystem'"
op|')'
op|'+'
string|"'data'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'ret'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'client'
op|','
name|'protocol'
op|'.'
name|'ProcessProtocol'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'client'
op|'.'
name|'transport'
op|'.'
name|'proto'
op|','
nl|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'avatar'
op|'.'
name|'subsystem'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_lookupSubsystemDoesNotNeedISession
dedent|''
name|'def'
name|'test_lookupSubsystemDoesNotNeedISession'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Previously, if one only wanted to implement a subsystem, an ISession\n        adapter wasn\'t needed because subsystems were looked up using the\n        lookupSubsystem method on the avatar.\n        """'
newline|'\n'
name|'s'
op|'='
name|'session'
op|'.'
name|'SSHSession'
op|'('
name|'avatar'
op|'='
name|'SubsystemOnlyAvatar'
op|'('
op|')'
op|','
nl|'\n'
name|'conn'
op|'='
name|'StubConnection'
op|'('
op|')'
op|')'
newline|'\n'
name|'ret'
op|'='
name|'s'
op|'.'
name|'request_subsystem'
op|'('
nl|'\n'
name|'common'
op|'.'
name|'NS'
op|'('
string|"'subsystem'"
op|')'
op|'+'
string|"'data'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'ret'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertNotIdentical'
op|'('
name|'s'
op|'.'
name|'client'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'s'
op|'.'
name|'conn'
op|'.'
name|'closes'
op|'.'
name|'get'
op|'('
name|'s'
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'s'
op|'.'
name|'eofReceived'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'s'
op|'.'
name|'conn'
op|'.'
name|'closes'
op|'.'
name|'get'
op|'('
name|'s'
op|')'
op|')'
newline|'\n'
comment|'# these should not raise errors'
nl|'\n'
name|'s'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
name|'s'
op|'.'
name|'closed'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_lookupSubsystem_data
dedent|''
name|'def'
name|'test_lookupSubsystem_data'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        After having looked up a subsystem, data should be passed along to the\n        client.  Additionally, subsystems were passed the entire request packet\n        as data, instead of just the additional data.\n\n        We check for the additional tidle to verify that the data passed\n        through the client.\n        """'
newline|'\n'
comment|"#self.session.dataReceived('1')"
nl|'\n'
comment|"# subsystems didn't get extended data"
nl|'\n'
comment|"#self.session.extReceived(connection.EXTENDED_DATA_STDERR, '2')"
nl|'\n'
nl|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'requestReceived'
op|'('
string|"'subsystem'"
op|','
nl|'\n'
name|'common'
op|'.'
name|'NS'
op|'('
string|"'TestSubsystem'"
op|')'
op|'+'
string|"'data'"
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'conn'
op|'.'
name|'data'
op|'['
name|'self'
op|'.'
name|'session'
op|']'
op|','
nl|'\n'
op|'['
string|"'\\x00\\x00\\x00\\x0dTestSubsystemdata~'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'dataReceived'
op|'('
string|"'more data'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'conn'
op|'.'
name|'data'
op|'['
name|'self'
op|'.'
name|'session'
op|']'
op|'['
op|'-'
number|'1'
op|']'
op|','
nl|'\n'
string|"'more data~'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_lookupSubsystem_closeReceived
dedent|''
name|'def'
name|'test_lookupSubsystem_closeReceived'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        SSHSession.closeReceived() should sent a close message to the remote\n        side.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'requestReceived'
op|'('
string|"'subsystem'"
op|','
nl|'\n'
name|'common'
op|'.'
name|'NS'
op|'('
string|"'TestSubsystem'"
op|')'
op|'+'
string|"'data'"
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'closeReceived'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'conn'
op|'.'
name|'closes'
op|'['
name|'self'
op|'.'
name|'session'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|assertRequestRaisedRuntimeError
dedent|''
name|'def'
name|'assertRequestRaisedRuntimeError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Assert that the request we just made raised a RuntimeError (and only a\n        RuntimeError).\n        """'
newline|'\n'
name|'errors'
op|'='
name|'self'
op|'.'
name|'flushLoggedErrors'
op|'('
name|'RuntimeError'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'errors'
op|')'
op|','
number|'1'
op|','
string|'"Multiple RuntimeErrors raised: %s"'
op|'%'
nl|'\n'
string|"'\\n'"
op|'.'
name|'join'
op|'('
op|'['
name|'repr'
op|'('
name|'error'
op|')'
name|'for'
name|'error'
name|'in'
name|'errors'
op|']'
op|')'
op|')'
newline|'\n'
name|'errors'
op|'['
number|'0'
op|']'
op|'.'
name|'trap'
op|'('
name|'RuntimeError'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_requestShell
dedent|''
name|'def'
name|'test_requestShell'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When a client requests a shell, the SSHSession object should get\n        the shell by getting an ISession adapter for the avatar, then\n        calling openShell() with a ProcessProtocol to attach.\n        """'
newline|'\n'
comment|'# gets a shell the first time'
nl|'\n'
name|'ret'
op|'='
name|'self'
op|'.'
name|'session'
op|'.'
name|'requestReceived'
op|'('
string|"'shell'"
op|','
string|"''"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'ret'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertSessionIsStubSession'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'client'
op|','
nl|'\n'
name|'session'
op|'.'
name|'SSHSessionProcessProtocol'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'session'
op|'.'
name|'shellProtocol'
op|','
nl|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'client'
op|')'
newline|'\n'
comment|"# doesn't get a shell the second time"
nl|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'requestReceived'
op|'('
string|"'shell'"
op|','
string|"''"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRequestRaisedRuntimeError'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_requestShellWithData
dedent|''
name|'def'
name|'test_requestShellWithData'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When a client executes a shell, it should be able to give pass data\n        back and forth between the local and the remote side.\n        """'
newline|'\n'
name|'ret'
op|'='
name|'self'
op|'.'
name|'session'
op|'.'
name|'requestReceived'
op|'('
string|"'shell'"
op|','
string|"''"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'ret'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertSessionIsStubSession'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'dataReceived'
op|'('
string|"'some data\\x00'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'session'
op|'.'
name|'shellTransport'
op|'.'
name|'data'
op|','
nl|'\n'
string|"'some data\\x00'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'conn'
op|'.'
name|'data'
op|'['
name|'self'
op|'.'
name|'session'
op|']'
op|','
nl|'\n'
op|'['
string|"'some data\\x00'"
op|','
string|"'\\r\\n'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'session'
op|'.'
name|'shellTransport'
op|'.'
name|'closed'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'conn'
op|'.'
name|'requests'
op|'['
name|'self'
op|'.'
name|'session'
op|']'
op|','
nl|'\n'
op|'['
op|'('
string|"'exit-status'"
op|','
string|"'\\x00\\x00\\x00\\x00'"
op|','
name|'False'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_requestExec
dedent|''
name|'def'
name|'test_requestExec'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When a client requests a command, the SSHSession object should get\n        the command by getting an ISession adapter for the avatar, then\n        calling execCommand with a ProcessProtocol to attach and the\n        command line.\n        """'
newline|'\n'
name|'ret'
op|'='
name|'self'
op|'.'
name|'session'
op|'.'
name|'requestReceived'
op|'('
string|"'exec'"
op|','
nl|'\n'
name|'common'
op|'.'
name|'NS'
op|'('
string|"'failure'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'ret'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRequestRaisedRuntimeError'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'client'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'requestReceived'
op|'('
string|"'exec'"
op|','
nl|'\n'
name|'common'
op|'.'
name|'NS'
op|'('
string|"'success'"
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertSessionIsStubSession'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'client'
op|','
nl|'\n'
name|'session'
op|'.'
name|'SSHSessionProcessProtocol'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'session'
op|'.'
name|'execProtocol'
op|','
nl|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'client'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'session'
op|'.'
name|'execCommandLine'
op|','
nl|'\n'
string|"'success'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_requestExecWithData
dedent|''
name|'def'
name|'test_requestExecWithData'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When a client executes a command, it should be able to give pass data\n        back and forth.\n        """'
newline|'\n'
name|'ret'
op|'='
name|'self'
op|'.'
name|'session'
op|'.'
name|'requestReceived'
op|'('
string|"'exec'"
op|','
nl|'\n'
name|'common'
op|'.'
name|'NS'
op|'('
string|"'repeat hello'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'ret'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertSessionIsStubSession'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'dataReceived'
op|'('
string|"'some data'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'session'
op|'.'
name|'execTransport'
op|'.'
name|'data'
op|','
string|"'some data'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'conn'
op|'.'
name|'data'
op|'['
name|'self'
op|'.'
name|'session'
op|']'
op|','
nl|'\n'
op|'['
string|"'hello'"
op|','
string|"'some data'"
op|','
string|"'\\r\\n'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'eofReceived'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'closeReceived'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'closed'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'session'
op|'.'
name|'execTransport'
op|'.'
name|'closed'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'conn'
op|'.'
name|'requests'
op|'['
name|'self'
op|'.'
name|'session'
op|']'
op|','
nl|'\n'
op|'['
op|'('
string|"'exit-status'"
op|','
string|"'\\x00\\x00\\x00\\x00'"
op|','
name|'False'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_requestPty
dedent|''
name|'def'
name|'test_requestPty'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When a client requests a PTY, the SSHSession object should make\n        the request by getting an ISession adapter for the avatar, then\n        calling getPty with the terminal type, the window size, and any modes\n        the client gave us.\n        """'
newline|'\n'
comment|"# 'bad' terminal type fails"
nl|'\n'
name|'ret'
op|'='
name|'self'
op|'.'
name|'session'
op|'.'
name|'requestReceived'
op|'('
nl|'\n'
string|"'pty_req'"
op|','
name|'session'
op|'.'
name|'packRequest_pty_req'
op|'('
nl|'\n'
string|"'bad'"
op|','
op|'('
number|'1'
op|','
number|'2'
op|','
number|'3'
op|','
number|'4'
op|')'
op|','
string|"''"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'ret'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertSessionIsStubSession'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRequestRaisedRuntimeError'
op|'('
op|')'
newline|'\n'
comment|"# 'good' terminal type succeeds"
nl|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'requestReceived'
op|'('
string|"'pty_req'"
op|','
nl|'\n'
name|'session'
op|'.'
name|'packRequest_pty_req'
op|'('
string|"'good'"
op|','
op|'('
number|'1'
op|','
number|'2'
op|','
number|'3'
op|','
number|'4'
op|')'
op|','
string|"''"
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'session'
op|'.'
name|'ptyRequest'
op|','
nl|'\n'
op|'('
string|"'good'"
op|','
op|'('
number|'1'
op|','
number|'2'
op|','
number|'3'
op|','
number|'4'
op|')'
op|','
op|'['
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_requestWindowChange
dedent|''
name|'def'
name|'test_requestWindowChange'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When the client requests to change the window size, the SSHSession\n        object should make the request by getting an ISession adapter for the\n        avatar, then calling windowChanged with the new window size.\n        """'
newline|'\n'
name|'ret'
op|'='
name|'self'
op|'.'
name|'session'
op|'.'
name|'requestReceived'
op|'('
nl|'\n'
string|"'window_change'"
op|','
nl|'\n'
name|'session'
op|'.'
name|'packRequest_window_change'
op|'('
op|'('
number|'0'
op|','
number|'0'
op|','
number|'0'
op|','
number|'0'
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'ret'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRequestRaisedRuntimeError'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertSessionIsStubSession'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'requestReceived'
op|'('
string|"'window_change'"
op|','
nl|'\n'
name|'session'
op|'.'
name|'packRequest_window_change'
op|'('
op|'('
number|'1'
op|','
number|'2'
op|','
number|'3'
op|','
number|'4'
op|')'
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'session'
op|'.'
name|'windowChange'
op|','
nl|'\n'
op|'('
number|'1'
op|','
number|'2'
op|','
number|'3'
op|','
number|'4'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_eofReceived
dedent|''
name|'def'
name|'test_eofReceived'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When an EOF is received and a ISession adapter is present, it should\n        be notified of the EOF message.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'session'
op|'='
name|'session'
op|'.'
name|'ISession'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'avatar'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'eofReceived'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'session'
op|'.'
name|'gotEOF'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_closeReceived
dedent|''
name|'def'
name|'test_closeReceived'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When a close is received, the session should send a close message.\n        """'
newline|'\n'
name|'ret'
op|'='
name|'self'
op|'.'
name|'session'
op|'.'
name|'closeReceived'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'ret'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'conn'
op|'.'
name|'closes'
op|'['
name|'self'
op|'.'
name|'session'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_closed
dedent|''
name|'def'
name|'test_closed'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When a close is received and a ISession adapter is present, it should\n        be notified of the close message.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'session'
op|'='
name|'session'
op|'.'
name|'ISession'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'avatar'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'closed'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'session'
op|'.'
name|'gotClosed'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|SessionWithNoAvatarTestCase
dedent|''
dedent|''
name|'class'
name|'SessionWithNoAvatarTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test for the SSHSession interface.  Several of the methods (request_shell,\n    request_exec, request_pty_req, request_window_change) would create a\n    \'session\' instance variable from the avatar if one didn\'t exist when they\n    were called.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'session'
op|'='
name|'session'
op|'.'
name|'SSHSession'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'avatar'
op|'='
name|'StubAvatar'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'session'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|assertSessionProvidesISession
dedent|''
name|'def'
name|'assertSessionProvidesISession'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        self.session.session should provide I{ISession}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'session'
op|'.'
name|'ISession'
op|'.'
name|'providedBy'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'session'
op|')'
op|','
nl|'\n'
string|'"ISession not provided by %r"'
op|'%'
name|'self'
op|'.'
name|'session'
op|'.'
name|'session'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_requestShellGetsSession
dedent|''
name|'def'
name|'test_requestShellGetsSession'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If an ISession adapter isn\'t already present, request_shell should get\n        one.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'requestReceived'
op|'('
string|"'shell'"
op|','
string|"''"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertSessionProvidesISession'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_requestExecGetsSession
dedent|''
name|'def'
name|'test_requestExecGetsSession'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If an ISession adapter isn\'t already present, request_exec should get\n        one.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'requestReceived'
op|'('
string|"'exec'"
op|','
nl|'\n'
name|'common'
op|'.'
name|'NS'
op|'('
string|"'success'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertSessionProvidesISession'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_requestPtyReqGetsSession
dedent|''
name|'def'
name|'test_requestPtyReqGetsSession'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If an ISession adapter isn\'t already present, request_pty_req should\n        get one.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'requestReceived'
op|'('
string|"'pty_req'"
op|','
nl|'\n'
name|'session'
op|'.'
name|'packRequest_pty_req'
op|'('
nl|'\n'
string|"'term'"
op|','
op|'('
number|'0'
op|','
number|'0'
op|','
number|'0'
op|','
number|'0'
op|')'
op|','
string|"''"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertSessionProvidesISession'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_requestWindowChangeGetsSession
dedent|''
name|'def'
name|'test_requestWindowChangeGetsSession'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If an ISession adapter isn\'t already present, request_window_change\n        should get one.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'requestReceived'
op|'('
nl|'\n'
string|"'window_change'"
op|','
nl|'\n'
name|'session'
op|'.'
name|'packRequest_window_change'
op|'('
nl|'\n'
op|'('
number|'1'
op|','
number|'1'
op|','
number|'1'
op|','
number|'1'
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertSessionProvidesISession'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|WrappersTestCase
dedent|''
dedent|''
name|'class'
name|'WrappersTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A test for the wrapProtocol and wrapProcessProtocol functions.\n    """'
newline|'\n'
nl|'\n'
DECL|member|test_wrapProtocol
name|'def'
name|'test_wrapProtocol'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{wrapProtocol}, when passed a L{Protocol} should return something that\n        has write(), writeSequence(), loseConnection() methods which call the\n        Protocol\'s dataReceived() and connectionLost() methods, respectively.\n        """'
newline|'\n'
name|'protocol'
op|'='
name|'MockProtocol'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'transport'
op|'='
name|'StubTransport'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'connectionMade'
op|'('
op|')'
newline|'\n'
name|'wrapped'
op|'='
name|'session'
op|'.'
name|'wrapProtocol'
op|'('
name|'protocol'
op|')'
newline|'\n'
name|'wrapped'
op|'.'
name|'dataReceived'
op|'('
string|"'dataReceived'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'protocol'
op|'.'
name|'transport'
op|'.'
name|'buf'
op|','
string|"'dataReceived'"
op|')'
newline|'\n'
name|'wrapped'
op|'.'
name|'write'
op|'('
string|"'data'"
op|')'
newline|'\n'
name|'wrapped'
op|'.'
name|'writeSequence'
op|'('
op|'['
string|"'1'"
op|','
string|"'2'"
op|']'
op|')'
newline|'\n'
name|'wrapped'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'protocol'
op|'.'
name|'data'
op|','
string|"'data12'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'reason'
op|'.'
name|'trap'
op|'('
name|'error'
op|'.'
name|'ConnectionDone'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_wrapProcessProtocol_Protocol
dedent|''
name|'def'
name|'test_wrapProcessProtocol_Protocol'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{wrapPRocessProtocol}, when passed a L{Protocol} should return\n        something that follows the L{IProcessProtocol} interface, with\n        connectionMade() mapping to connectionMade(), outReceived() mapping to\n        dataReceived() and processEnded() mapping to connectionLost().\n        """'
newline|'\n'
name|'protocol'
op|'='
name|'MockProtocol'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'transport'
op|'='
name|'StubTransport'
op|'('
op|')'
newline|'\n'
name|'process_protocol'
op|'='
name|'session'
op|'.'
name|'wrapProcessProtocol'
op|'('
name|'protocol'
op|')'
newline|'\n'
name|'process_protocol'
op|'.'
name|'connectionMade'
op|'('
op|')'
newline|'\n'
name|'process_protocol'
op|'.'
name|'outReceived'
op|'('
string|"'data'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'protocol'
op|'.'
name|'transport'
op|'.'
name|'buf'
op|','
string|"'data~'"
op|')'
newline|'\n'
name|'process_protocol'
op|'.'
name|'processEnded'
op|'('
name|'failure'
op|'.'
name|'Failure'
op|'('
nl|'\n'
name|'error'
op|'.'
name|'ProcessTerminated'
op|'('
number|'0'
op|','
name|'None'
op|','
name|'None'
op|')'
op|')'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'reason'
op|'.'
name|'trap'
op|'('
name|'error'
op|'.'
name|'ProcessTerminated'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestHelpers
dedent|''
dedent|''
name|'class'
name|'TestHelpers'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for the 4 helper functions: parseRequest_* and packRequest_*.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_parseRequest_pty_req
name|'def'
name|'test_parseRequest_pty_req'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The payload of a pty-req message is::\n            string  terminal\n            uint32  columns\n            uint32  rows\n            uint32  x pixels\n            uint32  y pixels\n            string  modes\n\n        Modes are::\n            byte    mode number\n            uint32  mode value\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'session'
op|'.'
name|'parseRequest_pty_req'
op|'('
name|'common'
op|'.'
name|'NS'
op|'('
string|"'xterm'"
op|')'
op|'+'
nl|'\n'
name|'struct'
op|'.'
name|'pack'
op|'('
string|"'>4L'"
op|','
nl|'\n'
number|'1'
op|','
number|'2'
op|','
number|'3'
op|','
number|'4'
op|')'
nl|'\n'
op|'+'
name|'common'
op|'.'
name|'NS'
op|'('
nl|'\n'
name|'struct'
op|'.'
name|'pack'
op|'('
string|"'>BL'"
op|','
number|'5'
op|','
number|'6'
op|')'
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|"'xterm'"
op|','
op|'('
number|'2'
op|','
number|'1'
op|','
number|'3'
op|','
number|'4'
op|')'
op|','
op|'['
op|'('
number|'5'
op|','
number|'6'
op|')'
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_packRequest_pty_req_old
dedent|''
name|'def'
name|'test_packRequest_pty_req_old'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        See test_parseRequest_pty_req for the payload format.\n        """'
newline|'\n'
name|'packed'
op|'='
name|'session'
op|'.'
name|'packRequest_pty_req'
op|'('
string|"'xterm'"
op|','
op|'('
number|'2'
op|','
number|'1'
op|','
number|'3'
op|','
number|'4'
op|')'
op|','
nl|'\n'
string|"'\\x05\\x00\\x00\\x00\\x06'"
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'packed'
op|','
nl|'\n'
name|'common'
op|'.'
name|'NS'
op|'('
string|"'xterm'"
op|')'
op|'+'
name|'struct'
op|'.'
name|'pack'
op|'('
string|"'>4L'"
op|','
number|'1'
op|','
number|'2'
op|','
number|'3'
op|','
number|'4'
op|')'
op|'+'
nl|'\n'
name|'common'
op|'.'
name|'NS'
op|'('
name|'struct'
op|'.'
name|'pack'
op|'('
string|"'>BL'"
op|','
number|'5'
op|','
number|'6'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_packRequest_pty_req
dedent|''
name|'def'
name|'test_packRequest_pty_req'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        See test_parseRequest_pty_req for the payload format.\n        """'
newline|'\n'
name|'packed'
op|'='
name|'session'
op|'.'
name|'packRequest_pty_req'
op|'('
string|"'xterm'"
op|','
op|'('
number|'2'
op|','
number|'1'
op|','
number|'3'
op|','
number|'4'
op|')'
op|','
nl|'\n'
string|"'\\x05\\x00\\x00\\x00\\x06'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'packed'
op|','
nl|'\n'
name|'common'
op|'.'
name|'NS'
op|'('
string|"'xterm'"
op|')'
op|'+'
name|'struct'
op|'.'
name|'pack'
op|'('
string|"'>4L'"
op|','
number|'1'
op|','
number|'2'
op|','
number|'3'
op|','
number|'4'
op|')'
op|'+'
nl|'\n'
name|'common'
op|'.'
name|'NS'
op|'('
name|'struct'
op|'.'
name|'pack'
op|'('
string|"'>BL'"
op|','
number|'5'
op|','
number|'6'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_parseRequest_window_change
dedent|''
name|'def'
name|'test_parseRequest_window_change'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The payload of a window_change request is::\n            uint32  columns\n            uint32  rows\n            uint32  x pixels\n            uint32  y pixels\n\n        parseRequest_window_change() returns (rows, columns, x pixels,\n        y pixels).\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'session'
op|'.'
name|'parseRequest_window_change'
op|'('
nl|'\n'
name|'struct'
op|'.'
name|'pack'
op|'('
string|"'>4L'"
op|','
number|'1'
op|','
number|'2'
op|','
number|'3'
op|','
number|'4'
op|')'
op|')'
op|','
op|'('
number|'2'
op|','
number|'1'
op|','
number|'3'
op|','
number|'4'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_packRequest_window_change
dedent|''
name|'def'
name|'test_packRequest_window_change'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        See test_parseRequest_window_change for the payload format.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'session'
op|'.'
name|'packRequest_window_change'
op|'('
op|'('
number|'2'
op|','
number|'1'
op|','
number|'3'
op|','
number|'4'
op|')'
op|')'
op|','
nl|'\n'
name|'struct'
op|'.'
name|'pack'
op|'('
string|"'>4L'"
op|','
number|'1'
op|','
number|'2'
op|','
number|'3'
op|','
number|'4'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|SSHSessionProcessProtocolTestCase
dedent|''
dedent|''
name|'class'
name|'SSHSessionProcessProtocolTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{SSHSessionProcessProtocol}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'session'
op|'='
name|'session'
op|'.'
name|'SSHSession'
op|'('
nl|'\n'
name|'conn'
op|'='
name|'StubConnection'
op|'('
op|')'
op|','
name|'remoteWindow'
op|'='
number|'500'
op|','
name|'remoteMaxPacket'
op|'='
number|'100'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'='
name|'StubTransport'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'pp'
op|'='
name|'session'
op|'.'
name|'SSHSessionProcessProtocol'
op|'('
name|'self'
op|'.'
name|'session'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'pp'
op|'.'
name|'makeConnection'
op|'('
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|assertSessionClosed
dedent|''
name|'def'
name|'assertSessionClosed'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Assert that C{self.session} is closed.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'conn'
op|'.'
name|'closes'
op|'['
name|'self'
op|'.'
name|'session'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|assertRequestsEqual
dedent|''
name|'def'
name|'assertRequestsEqual'
op|'('
name|'self'
op|','
name|'expectedRequests'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Assert that C{self.session} has sent the C{expectedRequests}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'conn'
op|'.'
name|'requests'
op|'['
name|'self'
op|'.'
name|'session'
op|']'
op|','
nl|'\n'
name|'expectedRequests'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_init
dedent|''
name|'def'
name|'test_init'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        SSHSessionProcessProtocol should set self.session to the session passed\n        to the __init__ method.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'pp'
op|'.'
name|'session'
op|','
name|'self'
op|'.'
name|'session'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_connectionMade
dedent|''
name|'def'
name|'test_connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        SSHSessionProcessProtocol.connectionMade() should check if there\'s a\n        \'buf\' attribute on its session and write it to the transport if so.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'session'
op|'.'
name|'buf'
op|'='
string|"'buffer'"
newline|'\n'
name|'self'
op|'.'
name|'pp'
op|'.'
name|'connectionMade'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'buf'
op|','
string|"'buffer'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getSignalName
dedent|''
name|'def'
name|'test_getSignalName'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        _getSignalName should return the name of a signal when given the\n        signal number.\n        """'
newline|'\n'
name|'for'
name|'signalName'
name|'in'
name|'session'
op|'.'
name|'SUPPORTED_SIGNALS'
op|':'
newline|'\n'
indent|'            '
name|'signalName'
op|'='
string|"'SIG'"
op|'+'
name|'signalName'
newline|'\n'
name|'signalValue'
op|'='
name|'getattr'
op|'('
name|'signal'
op|','
name|'signalName'
op|')'
newline|'\n'
name|'sshName'
op|'='
name|'self'
op|'.'
name|'pp'
op|'.'
name|'_getSignalName'
op|'('
name|'signalValue'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'sshName'
op|','
name|'signalName'
op|','
nl|'\n'
string|'"%i: %s != %s"'
op|'%'
op|'('
name|'signalValue'
op|','
name|'sshName'
op|','
nl|'\n'
name|'signalName'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getSignalNameWithLocalSignal
dedent|''
dedent|''
name|'def'
name|'test_getSignalNameWithLocalSignal'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If there are signals in the signal module which aren\'t in the SSH RFC,\n        we map their name to [signal name]@[platform].\n        """'
newline|'\n'
name|'signal'
op|'.'
name|'SIGTwistedTest'
op|'='
name|'signal'
op|'.'
name|'NSIG'
op|'+'
number|'1'
comment|"# value can't exist normally"
newline|'\n'
comment|'# Force reinitialization of signals'
nl|'\n'
name|'self'
op|'.'
name|'pp'
op|'.'
name|'_signalValuesToNames'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'pp'
op|'.'
name|'_getSignalName'
op|'('
name|'signal'
op|'.'
name|'SIGTwistedTest'
op|')'
op|','
nl|'\n'
string|"'SIGTwistedTest@'"
op|'+'
name|'sys'
op|'.'
name|'platform'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
name|'if'
name|'getattr'
op|'('
name|'signal'
op|','
string|"'SIGALRM'"
op|','
name|'None'
op|')'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'test_getSignalName'
op|'.'
name|'skip'
op|'='
name|'test_getSignalNameWithLocalSignal'
op|'.'
name|'skip'
op|'='
string|'"Not all signals available"'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_outReceived
dedent|''
name|'def'
name|'test_outReceived'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When data is passed to the outReceived method, it should be sent to\n        the session\'s write method.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'pp'
op|'.'
name|'outReceived'
op|'('
string|"'test data'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'conn'
op|'.'
name|'data'
op|'['
name|'self'
op|'.'
name|'session'
op|']'
op|','
nl|'\n'
op|'['
string|"'test data'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_write
dedent|''
name|'def'
name|'test_write'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When data is passed to the write method, it should be sent to the\n        session channel\'s write method.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'pp'
op|'.'
name|'write'
op|'('
string|"'test data'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'conn'
op|'.'
name|'data'
op|'['
name|'self'
op|'.'
name|'session'
op|']'
op|','
nl|'\n'
op|'['
string|"'test data'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_writeSequence
dedent|''
name|'def'
name|'test_writeSequence'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When a sequence is passed to the writeSequence method, it should be\n        joined together and sent to the session channel\'s write method.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'pp'
op|'.'
name|'writeSequence'
op|'('
op|'['
string|"'test '"
op|','
string|"'data'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'conn'
op|'.'
name|'data'
op|'['
name|'self'
op|'.'
name|'session'
op|']'
op|','
nl|'\n'
op|'['
string|"'test data'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_errReceived
dedent|''
name|'def'
name|'test_errReceived'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When data is passed to the errReceived method, it should be sent to\n        the session\'s writeExtended method.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'pp'
op|'.'
name|'errReceived'
op|'('
string|"'test data'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'conn'
op|'.'
name|'extData'
op|'['
name|'self'
op|'.'
name|'session'
op|']'
op|','
nl|'\n'
op|'['
op|'('
number|'1'
op|','
string|"'test data'"
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_inConnectionLost
dedent|''
name|'def'
name|'test_inConnectionLost'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When inConnectionLost is called, it should send an EOF message,\n        """'
newline|'\n'
name|'self'
op|'.'
name|'pp'
op|'.'
name|'inConnectionLost'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'conn'
op|'.'
name|'eofs'
op|'['
name|'self'
op|'.'
name|'session'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_loseConnection
dedent|''
name|'def'
name|'test_loseConnection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When loseConnection() is called, it should call loseConnection\n        on the session channel.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'pp'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'session'
op|'.'
name|'conn'
op|'.'
name|'closes'
op|'['
name|'self'
op|'.'
name|'session'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_connectionLost
dedent|''
name|'def'
name|'test_connectionLost'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When connectionLost() is called, it should call loseConnection()\n        on the session channel.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'pp'
op|'.'
name|'connectionLost'
op|'('
name|'failure'
op|'.'
name|'Failure'
op|'('
nl|'\n'
name|'ProcessDone'
op|'('
number|'0'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_processEndedWithExitCode
dedent|''
name|'def'
name|'test_processEndedWithExitCode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When processEnded is called, if there is an exit code in the reason\n        it should be sent in an exit-status method.  The connection should be\n        closed.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'pp'
op|'.'
name|'processEnded'
op|'('
name|'Failure'
op|'('
name|'ProcessDone'
op|'('
name|'None'
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRequestsEqual'
op|'('
nl|'\n'
op|'['
op|'('
string|"'exit-status'"
op|','
name|'struct'
op|'.'
name|'pack'
op|'('
string|"'>I'"
op|','
number|'0'
op|')'
op|','
name|'False'
op|')'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertSessionClosed'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_processEndedWithExitSignalCoreDump
dedent|''
name|'def'
name|'test_processEndedWithExitSignalCoreDump'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When processEnded is called, if there is an exit signal in the reason\n        it should be sent in an exit-signal message.  The connection should be\n        closed.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'pp'
op|'.'
name|'processEnded'
op|'('
nl|'\n'
name|'Failure'
op|'('
name|'ProcessTerminated'
op|'('
number|'1'
op|','
nl|'\n'
name|'signal'
op|'.'
name|'SIGTERM'
op|','
number|'1'
op|'<<'
number|'7'
op|')'
op|')'
op|')'
comment|'# 7th bit means core dumped'
newline|'\n'
name|'self'
op|'.'
name|'assertRequestsEqual'
op|'('
nl|'\n'
op|'['
op|'('
string|"'exit-signal'"
op|','
nl|'\n'
name|'common'
op|'.'
name|'NS'
op|'('
string|"'TERM'"
op|')'
comment|'# signal name'
nl|'\n'
op|'+'
string|"'\\x01'"
comment|'# core dumped is true'
nl|'\n'
op|'+'
name|'common'
op|'.'
name|'NS'
op|'('
string|"''"
op|')'
comment|'# error message'
nl|'\n'
op|'+'
name|'common'
op|'.'
name|'NS'
op|'('
string|"''"
op|')'
op|','
comment|'# language tag'
nl|'\n'
name|'False'
op|')'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertSessionClosed'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_processEndedWithExitSignalNoCoreDump
dedent|''
name|'def'
name|'test_processEndedWithExitSignalNoCoreDump'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When processEnded is called, if there is an exit signal in the\n        reason it should be sent in an exit-signal message.  If no\n        core was dumped, don\'t set the core-dump bit.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'pp'
op|'.'
name|'processEnded'
op|'('
nl|'\n'
name|'Failure'
op|'('
name|'ProcessTerminated'
op|'('
number|'1'
op|','
name|'signal'
op|'.'
name|'SIGTERM'
op|','
number|'0'
op|')'
op|')'
op|')'
newline|'\n'
comment|'# see comments in test_processEndedWithExitSignalCoreDump for the'
nl|'\n'
comment|'# meaning of the parts in the request'
nl|'\n'
name|'self'
op|'.'
name|'assertRequestsEqual'
op|'('
nl|'\n'
op|'['
op|'('
string|"'exit-signal'"
op|','
name|'common'
op|'.'
name|'NS'
op|'('
string|"'TERM'"
op|')'
op|'+'
string|"'\\x00'"
op|'+'
name|'common'
op|'.'
name|'NS'
op|'('
string|"''"
op|')'
op|'+'
nl|'\n'
name|'common'
op|'.'
name|'NS'
op|'('
string|"''"
op|')'
op|','
name|'False'
op|')'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertSessionClosed'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
name|'if'
name|'getattr'
op|'('
name|'os'
op|','
string|"'WCOREDUMP'"
op|','
name|'None'
op|')'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'skipMsg'
op|'='
string|'"can\'t run this w/o os.WCOREDUMP"'
newline|'\n'
name|'test_processEndedWithExitSignalCoreDump'
op|'.'
name|'skip'
op|'='
name|'skipMsg'
newline|'\n'
name|'test_processEndedWithExitSignalNoCoreDump'
op|'.'
name|'skip'
op|'='
name|'skipMsg'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|SSHSessionClientTestCase
dedent|''
dedent|''
name|'class'
name|'SSHSessionClientTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    SSHSessionClient is an obsolete class used to connect standard IO to\n    an SSHSession.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_dataReceived
name|'def'
name|'test_dataReceived'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When data is received, it should be sent to the transport.\n        """'
newline|'\n'
name|'client'
op|'='
name|'session'
op|'.'
name|'SSHSessionClient'
op|'('
op|')'
newline|'\n'
name|'client'
op|'.'
name|'transport'
op|'='
name|'StubTransport'
op|'('
op|')'
newline|'\n'
name|'client'
op|'.'
name|'dataReceived'
op|'('
string|"'test data'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'client'
op|'.'
name|'transport'
op|'.'
name|'buf'
op|','
string|"'test data'"
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
