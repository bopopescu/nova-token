begin_unit
comment|'# -*- test-case-name: twisted.web.test.test_domhelpers -*-'
nl|'\n'
comment|'# Copyright (c) 2001-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nA library for performing interesting tasks with DOM objects.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'StringIO'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
name|'import'
name|'microdom'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
op|'.'
name|'microdom'
name|'import'
name|'getElementsByTagName'
op|','
name|'escape'
op|','
name|'unescape'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|NodeLookupError
name|'class'
name|'NodeLookupError'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|substitute
dedent|''
name|'def'
name|'substitute'
op|'('
name|'request'
op|','
name|'node'
op|','
name|'subs'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Look through the given node\'s children for strings, and\n    attempt to do string substitution with the given parameter.\n    """'
newline|'\n'
name|'for'
name|'child'
name|'in'
name|'node'
op|'.'
name|'childNodes'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'hasattr'
op|'('
name|'child'
op|','
string|"'nodeValue'"
op|')'
name|'and'
name|'child'
op|'.'
name|'nodeValue'
op|':'
newline|'\n'
indent|'            '
name|'child'
op|'.'
name|'replaceData'
op|'('
number|'0'
op|','
name|'len'
op|'('
name|'child'
op|'.'
name|'nodeValue'
op|')'
op|','
name|'child'
op|'.'
name|'nodeValue'
op|'%'
name|'subs'
op|')'
newline|'\n'
dedent|''
name|'substitute'
op|'('
name|'request'
op|','
name|'child'
op|','
name|'subs'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_get
dedent|''
dedent|''
name|'def'
name|'_get'
op|'('
name|'node'
op|','
name|'nodeId'
op|','
name|'nodeAttrs'
op|'='
op|'('
string|"'id'"
op|','
string|"'class'"
op|','
string|"'model'"
op|','
string|"'pattern'"
op|')'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    (internal) Get a node with the specified C{nodeId} as any of the C{class},\n    C{id} or C{pattern} attributes.\n    """'
newline|'\n'
nl|'\n'
name|'if'
name|'hasattr'
op|'('
name|'node'
op|','
string|"'hasAttributes'"
op|')'
name|'and'
name|'node'
op|'.'
name|'hasAttributes'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'nodeAttr'
name|'in'
name|'nodeAttrs'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
name|'str'
op|'('
name|'node'
op|'.'
name|'getAttribute'
op|'('
name|'nodeAttr'
op|')'
op|')'
op|'=='
name|'nodeId'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'node'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'node'
op|'.'
name|'hasChildNodes'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'hasattr'
op|'('
name|'node'
op|'.'
name|'childNodes'
op|','
string|"'length'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'length'
op|'='
name|'node'
op|'.'
name|'childNodes'
op|'.'
name|'length'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'length'
op|'='
name|'len'
op|'('
name|'node'
op|'.'
name|'childNodes'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'childNum'
name|'in'
name|'range'
op|'('
name|'length'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'='
name|'_get'
op|'('
name|'node'
op|'.'
name|'childNodes'
op|'['
name|'childNum'
op|']'
op|','
name|'nodeId'
op|')'
newline|'\n'
name|'if'
name|'result'
op|':'
name|'return'
name|'result'
newline|'\n'
nl|'\n'
DECL|function|get
dedent|''
dedent|''
dedent|''
name|'def'
name|'get'
op|'('
name|'node'
op|','
name|'nodeId'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Get a node with the specified C{nodeId} as any of the C{class},\n    C{id} or C{pattern} attributes. If there is no such node, raise\n    L{NodeLookupError}.\n    """'
newline|'\n'
name|'result'
op|'='
name|'_get'
op|'('
name|'node'
op|','
name|'nodeId'
op|')'
newline|'\n'
name|'if'
name|'result'
op|':'
name|'return'
name|'result'
newline|'\n'
name|'raise'
name|'NodeLookupError'
op|','
name|'nodeId'
newline|'\n'
nl|'\n'
DECL|function|getIfExists
dedent|''
name|'def'
name|'getIfExists'
op|'('
name|'node'
op|','
name|'nodeId'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Get a node with the specified C{nodeId} as any of the C{class},\n    C{id} or C{pattern} attributes.  If there is no such node, return\n    C{None}.\n    """'
newline|'\n'
name|'return'
name|'_get'
op|'('
name|'node'
op|','
name|'nodeId'
op|')'
newline|'\n'
nl|'\n'
DECL|function|getAndClear
dedent|''
name|'def'
name|'getAndClear'
op|'('
name|'node'
op|','
name|'nodeId'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Get a node with the specified C{nodeId} as any of the C{class},\n    C{id} or C{pattern} attributes. If there is no such node, raise\n    L{NodeLookupError}. Remove all child nodes before returning.\n    """'
newline|'\n'
name|'result'
op|'='
name|'get'
op|'('
name|'node'
op|','
name|'nodeId'
op|')'
newline|'\n'
name|'if'
name|'result'
op|':'
newline|'\n'
indent|'        '
name|'clearNode'
op|'('
name|'result'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
DECL|function|clearNode
dedent|''
name|'def'
name|'clearNode'
op|'('
name|'node'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Remove all children from the given node.\n    """'
newline|'\n'
name|'node'
op|'.'
name|'childNodes'
op|'['
op|':'
op|']'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|function|locateNodes
dedent|''
name|'def'
name|'locateNodes'
op|'('
name|'nodeList'
op|','
name|'key'
op|','
name|'value'
op|','
name|'noNesting'
op|'='
number|'1'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Find subnodes in the given node where the given attribute\n    has the given value.\n    """'
newline|'\n'
name|'returnList'
op|'='
op|'['
op|']'
newline|'\n'
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'nodeList'
op|','
name|'type'
op|'('
op|'['
op|']'
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'locateNodes'
op|'('
name|'nodeList'
op|'.'
name|'childNodes'
op|','
name|'key'
op|','
name|'value'
op|','
name|'noNesting'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'childNode'
name|'in'
name|'nodeList'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'hasattr'
op|'('
name|'childNode'
op|','
string|"'getAttribute'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
dedent|''
name|'if'
name|'str'
op|'('
name|'childNode'
op|'.'
name|'getAttribute'
op|'('
name|'key'
op|')'
op|')'
op|'=='
name|'value'
op|':'
newline|'\n'
indent|'            '
name|'returnList'
op|'.'
name|'append'
op|'('
name|'childNode'
op|')'
newline|'\n'
name|'if'
name|'noNesting'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
dedent|''
name|'returnList'
op|'.'
name|'extend'
op|'('
name|'locateNodes'
op|'('
name|'childNode'
op|','
name|'key'
op|','
name|'value'
op|','
name|'noNesting'
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'returnList'
newline|'\n'
nl|'\n'
DECL|function|superSetAttribute
dedent|''
name|'def'
name|'superSetAttribute'
op|'('
name|'node'
op|','
name|'key'
op|','
name|'value'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'not'
name|'hasattr'
op|'('
name|'node'
op|','
string|"'setAttribute'"
op|')'
op|':'
name|'return'
newline|'\n'
name|'node'
op|'.'
name|'setAttribute'
op|'('
name|'key'
op|','
name|'value'
op|')'
newline|'\n'
name|'if'
name|'node'
op|'.'
name|'hasChildNodes'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'child'
name|'in'
name|'node'
op|'.'
name|'childNodes'
op|':'
newline|'\n'
indent|'            '
name|'superSetAttribute'
op|'('
name|'child'
op|','
name|'key'
op|','
name|'value'
op|')'
newline|'\n'
nl|'\n'
DECL|function|superPrependAttribute
dedent|''
dedent|''
dedent|''
name|'def'
name|'superPrependAttribute'
op|'('
name|'node'
op|','
name|'key'
op|','
name|'value'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'not'
name|'hasattr'
op|'('
name|'node'
op|','
string|"'setAttribute'"
op|')'
op|':'
name|'return'
newline|'\n'
name|'old'
op|'='
name|'node'
op|'.'
name|'getAttribute'
op|'('
name|'key'
op|')'
newline|'\n'
name|'if'
name|'old'
op|':'
newline|'\n'
indent|'        '
name|'node'
op|'.'
name|'setAttribute'
op|'('
name|'key'
op|','
name|'value'
op|'+'
string|"'/'"
op|'+'
name|'old'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'node'
op|'.'
name|'setAttribute'
op|'('
name|'key'
op|','
name|'value'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'node'
op|'.'
name|'hasChildNodes'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'child'
name|'in'
name|'node'
op|'.'
name|'childNodes'
op|':'
newline|'\n'
indent|'            '
name|'superPrependAttribute'
op|'('
name|'child'
op|','
name|'key'
op|','
name|'value'
op|')'
newline|'\n'
nl|'\n'
DECL|function|superAppendAttribute
dedent|''
dedent|''
dedent|''
name|'def'
name|'superAppendAttribute'
op|'('
name|'node'
op|','
name|'key'
op|','
name|'value'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'not'
name|'hasattr'
op|'('
name|'node'
op|','
string|"'setAttribute'"
op|')'
op|':'
name|'return'
newline|'\n'
name|'old'
op|'='
name|'node'
op|'.'
name|'getAttribute'
op|'('
name|'key'
op|')'
newline|'\n'
name|'if'
name|'old'
op|':'
newline|'\n'
indent|'        '
name|'node'
op|'.'
name|'setAttribute'
op|'('
name|'key'
op|','
name|'old'
op|'+'
string|"'/'"
op|'+'
name|'value'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'node'
op|'.'
name|'setAttribute'
op|'('
name|'key'
op|','
name|'value'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'node'
op|'.'
name|'hasChildNodes'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'child'
name|'in'
name|'node'
op|'.'
name|'childNodes'
op|':'
newline|'\n'
indent|'            '
name|'superAppendAttribute'
op|'('
name|'child'
op|','
name|'key'
op|','
name|'value'
op|')'
newline|'\n'
nl|'\n'
DECL|function|gatherTextNodes
dedent|''
dedent|''
dedent|''
name|'def'
name|'gatherTextNodes'
op|'('
name|'iNode'
op|','
name|'dounescape'
op|'='
number|'0'
op|','
name|'joinWith'
op|'='
string|'""'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Visit each child node and collect its text data, if any, into a string.\nFor example::\n    >>> doc=microdom.parseString(\'<a>1<b>2<c>3</c>4</b></a>\')\n    >>> gatherTextNodes(doc.documentElement)\n    \'1234\'\nWith dounescape=1, also convert entities back into normal characters.\n@return: the gathered nodes as a single string\n@rtype: str\n"""'
newline|'\n'
name|'gathered'
op|'='
op|'['
op|']'
newline|'\n'
name|'gathered_append'
op|'='
name|'gathered'
op|'.'
name|'append'
newline|'\n'
name|'slice'
op|'='
op|'['
name|'iNode'
op|']'
newline|'\n'
name|'while'
name|'len'
op|'('
name|'slice'
op|')'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'c'
op|'='
name|'slice'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
newline|'\n'
name|'if'
name|'hasattr'
op|'('
name|'c'
op|','
string|"'nodeValue'"
op|')'
name|'and'
name|'c'
op|'.'
name|'nodeValue'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'dounescape'
op|':'
newline|'\n'
indent|'                '
name|'val'
op|'='
name|'unescape'
op|'('
name|'c'
op|'.'
name|'nodeValue'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'val'
op|'='
name|'c'
op|'.'
name|'nodeValue'
newline|'\n'
dedent|''
name|'gathered_append'
op|'('
name|'val'
op|')'
newline|'\n'
dedent|''
name|'slice'
op|'['
op|':'
number|'0'
op|']'
op|'='
name|'c'
op|'.'
name|'childNodes'
newline|'\n'
dedent|''
name|'return'
name|'joinWith'
op|'.'
name|'join'
op|'('
name|'gathered'
op|')'
newline|'\n'
nl|'\n'
DECL|class|RawText
dedent|''
name|'class'
name|'RawText'
op|'('
name|'microdom'
op|'.'
name|'Text'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""This is an evil and horrible speed hack. Basically, if you have a big\n    chunk of XML that you want to insert into the DOM, but you don\'t want to\n    incur the cost of parsing it, you can construct one of these and insert it\n    into the DOM. This will most certainly only work with microdom as the API\n    for converting nodes to xml is different in every DOM implementation.\n\n    This could be improved by making this class a Lazy parser, so if you\n    inserted this into the DOM and then later actually tried to mutate this\n    node, it would be parsed then.\n    """'
newline|'\n'
nl|'\n'
DECL|member|writexml
name|'def'
name|'writexml'
op|'('
name|'self'
op|','
name|'writer'
op|','
name|'indent'
op|'='
string|'""'
op|','
name|'addindent'
op|'='
string|'""'
op|','
name|'newl'
op|'='
string|'""'
op|','
name|'strip'
op|'='
number|'0'
op|','
name|'nsprefixes'
op|'='
name|'None'
op|','
name|'namespace'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'writer'
op|'.'
name|'write'
op|'('
string|'"%s%s%s"'
op|'%'
op|'('
name|'indent'
op|','
name|'self'
op|'.'
name|'data'
op|','
name|'newl'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|findNodes
dedent|''
dedent|''
name|'def'
name|'findNodes'
op|'('
name|'parent'
op|','
name|'matcher'
op|','
name|'accum'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'accum'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'accum'
op|'='
op|'['
op|']'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'parent'
op|'.'
name|'hasChildNodes'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'accum'
newline|'\n'
dedent|''
name|'for'
name|'child'
name|'in'
name|'parent'
op|'.'
name|'childNodes'
op|':'
newline|'\n'
comment|'# print child, child.nodeType, child.nodeName'
nl|'\n'
indent|'        '
name|'if'
name|'matcher'
op|'('
name|'child'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'accum'
op|'.'
name|'append'
op|'('
name|'child'
op|')'
newline|'\n'
dedent|''
name|'findNodes'
op|'('
name|'child'
op|','
name|'matcher'
op|','
name|'accum'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'accum'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|findNodesShallowOnMatch
dedent|''
name|'def'
name|'findNodesShallowOnMatch'
op|'('
name|'parent'
op|','
name|'matcher'
op|','
name|'recurseMatcher'
op|','
name|'accum'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'accum'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'accum'
op|'='
op|'['
op|']'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'parent'
op|'.'
name|'hasChildNodes'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'accum'
newline|'\n'
dedent|''
name|'for'
name|'child'
name|'in'
name|'parent'
op|'.'
name|'childNodes'
op|':'
newline|'\n'
comment|'# print child, child.nodeType, child.nodeName'
nl|'\n'
indent|'        '
name|'if'
name|'matcher'
op|'('
name|'child'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'accum'
op|'.'
name|'append'
op|'('
name|'child'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'recurseMatcher'
op|'('
name|'child'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'findNodesShallowOnMatch'
op|'('
name|'child'
op|','
name|'matcher'
op|','
name|'recurseMatcher'
op|','
name|'accum'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'accum'
newline|'\n'
nl|'\n'
DECL|function|findNodesShallow
dedent|''
name|'def'
name|'findNodesShallow'
op|'('
name|'parent'
op|','
name|'matcher'
op|','
name|'accum'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'accum'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'accum'
op|'='
op|'['
op|']'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'parent'
op|'.'
name|'hasChildNodes'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'accum'
newline|'\n'
dedent|''
name|'for'
name|'child'
name|'in'
name|'parent'
op|'.'
name|'childNodes'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'matcher'
op|'('
name|'child'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'accum'
op|'.'
name|'append'
op|'('
name|'child'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'findNodes'
op|'('
name|'child'
op|','
name|'matcher'
op|','
name|'accum'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'accum'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|findElementsWithAttributeShallow
dedent|''
name|'def'
name|'findElementsWithAttributeShallow'
op|'('
name|'parent'
op|','
name|'attribute'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Return an iterable of the elements which are direct children of C{parent}\n    and which have the C{attribute} attribute.\n    """'
newline|'\n'
name|'return'
name|'findNodesShallow'
op|'('
name|'parent'
op|','
nl|'\n'
name|'lambda'
name|'n'
op|':'
name|'getattr'
op|'('
name|'n'
op|','
string|"'tagName'"
op|','
name|'None'
op|')'
name|'is'
name|'not'
name|'None'
name|'and'
nl|'\n'
name|'n'
op|'.'
name|'hasAttribute'
op|'('
name|'attribute'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|findElements
dedent|''
name|'def'
name|'findElements'
op|'('
name|'parent'
op|','
name|'matcher'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Return an iterable of the elements which are children of C{parent} for\n    which the predicate C{matcher} returns true.\n    """'
newline|'\n'
name|'return'
name|'findNodes'
op|'('
nl|'\n'
name|'parent'
op|','
nl|'\n'
name|'lambda'
name|'n'
op|','
name|'matcher'
op|'='
name|'matcher'
op|':'
name|'getattr'
op|'('
name|'n'
op|','
string|"'tagName'"
op|','
name|'None'
op|')'
name|'is'
name|'not'
name|'None'
name|'and'
nl|'\n'
name|'matcher'
op|'('
name|'n'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|findElementsWithAttribute
dedent|''
name|'def'
name|'findElementsWithAttribute'
op|'('
name|'parent'
op|','
name|'attribute'
op|','
name|'value'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'value'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'findElements'
op|'('
nl|'\n'
name|'parent'
op|','
nl|'\n'
name|'lambda'
name|'n'
op|','
name|'attribute'
op|'='
name|'attribute'
op|','
name|'value'
op|'='
name|'value'
op|':'
nl|'\n'
name|'n'
op|'.'
name|'hasAttribute'
op|'('
name|'attribute'
op|')'
name|'and'
name|'n'
op|'.'
name|'getAttribute'
op|'('
name|'attribute'
op|')'
op|'=='
name|'value'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'findElements'
op|'('
nl|'\n'
name|'parent'
op|','
nl|'\n'
name|'lambda'
name|'n'
op|','
name|'attribute'
op|'='
name|'attribute'
op|':'
name|'n'
op|'.'
name|'hasAttribute'
op|'('
name|'attribute'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|findNodesNamed
dedent|''
dedent|''
name|'def'
name|'findNodesNamed'
op|'('
name|'parent'
op|','
name|'name'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'return'
name|'findNodes'
op|'('
name|'parent'
op|','
name|'lambda'
name|'n'
op|','
name|'name'
op|'='
name|'name'
op|':'
name|'n'
op|'.'
name|'nodeName'
op|'=='
name|'name'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|writeNodeData
dedent|''
name|'def'
name|'writeNodeData'
op|'('
name|'node'
op|','
name|'oldio'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'for'
name|'subnode'
name|'in'
name|'node'
op|'.'
name|'childNodes'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'hasattr'
op|'('
name|'subnode'
op|','
string|"'data'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'oldio'
op|'.'
name|'write'
op|'('
name|'subnode'
op|'.'
name|'data'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'writeNodeData'
op|'('
name|'subnode'
op|','
name|'oldio'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|getNodeText
dedent|''
dedent|''
dedent|''
name|'def'
name|'getNodeText'
op|'('
name|'node'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'oldio'
op|'='
name|'StringIO'
op|'.'
name|'StringIO'
op|'('
op|')'
newline|'\n'
name|'writeNodeData'
op|'('
name|'node'
op|','
name|'oldio'
op|')'
newline|'\n'
name|'return'
name|'oldio'
op|'.'
name|'getvalue'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|getParents
dedent|''
name|'def'
name|'getParents'
op|'('
name|'node'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'while'
name|'node'
op|':'
newline|'\n'
indent|'        '
name|'l'
op|'.'
name|'append'
op|'('
name|'node'
op|')'
newline|'\n'
name|'node'
op|'='
name|'node'
op|'.'
name|'parentNode'
newline|'\n'
dedent|''
name|'return'
name|'l'
newline|'\n'
nl|'\n'
DECL|function|namedChildren
dedent|''
name|'def'
name|'namedChildren'
op|'('
name|'parent'
op|','
name|'nodeName'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""namedChildren(parent, nodeName) -> children (not descendants) of parent\n    that have tagName == nodeName\n    """'
newline|'\n'
name|'return'
op|'['
name|'n'
name|'for'
name|'n'
name|'in'
name|'parent'
op|'.'
name|'childNodes'
name|'if'
name|'getattr'
op|'('
name|'n'
op|','
string|"'tagName'"
op|','
string|"''"
op|')'
op|'=='
name|'nodeName'
op|']'
newline|'\n'
dedent|''
endmarker|''
end_unit
