begin_unit
comment|'# -*- test-case-name: twisted.web.test.test_xml -*-'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Copyright (c) 2001-2004 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
nl|'\n'
string|'"""\n*S*mall, *U*ncomplicated *X*ML.\n\nThis is a very simple implementation of XML/HTML as a network\nprotocol.  It is not at all clever.  Its main features are that it\ndoes not:\n\n  - support namespaces\n  - mung mnemonic entity references\n  - validate\n  - perform *any* external actions (such as fetching URLs or writing files)\n    under *any* circumstances\n  - has lots and lots of horrible hacks for supporting broken HTML (as an\n    option, they\'re not on by default).\n"""'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'protocol'
name|'import'
name|'Protocol'
op|','
name|'FileWrapper'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'reflect'
name|'import'
name|'prefixedMethodNames'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
comment|'# Elements of the three-tuples in the state table.'
nl|'\n'
DECL|variable|BEGIN_HANDLER
name|'BEGIN_HANDLER'
op|'='
number|'0'
newline|'\n'
DECL|variable|DO_HANDLER
name|'DO_HANDLER'
op|'='
number|'1'
newline|'\n'
DECL|variable|END_HANDLER
name|'END_HANDLER'
op|'='
number|'2'
newline|'\n'
nl|'\n'
DECL|variable|identChars
name|'identChars'
op|'='
string|"'.-_:'"
newline|'\n'
DECL|variable|lenientIdentChars
name|'lenientIdentChars'
op|'='
name|'identChars'
op|'+'
string|"';+#/%~'"
newline|'\n'
nl|'\n'
DECL|function|nop
name|'def'
name|'nop'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"Do nothing."'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|unionlist
dedent|''
name|'def'
name|'unionlist'
op|'('
op|'*'
name|'args'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'x'
name|'in'
name|'args'
op|':'
newline|'\n'
indent|'        '
name|'l'
op|'.'
name|'extend'
op|'('
name|'x'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'='
name|'dict'
op|'('
op|'['
op|'('
name|'x'
op|','
number|'1'
op|')'
name|'for'
name|'x'
name|'in'
name|'l'
op|']'
op|')'
newline|'\n'
name|'return'
name|'d'
op|'.'
name|'keys'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|zipfndict
dedent|''
name|'def'
name|'zipfndict'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'default'
op|'='
name|'kw'
op|'.'
name|'get'
op|'('
string|"'default'"
op|','
name|'nop'
op|')'
newline|'\n'
name|'d'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'key'
name|'in'
name|'unionlist'
op|'('
op|'*'
op|'['
name|'fndict'
op|'.'
name|'keys'
op|'('
op|')'
name|'for'
name|'fndict'
name|'in'
name|'args'
op|']'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'d'
op|'['
name|'key'
op|']'
op|'='
name|'tuple'
op|'('
op|'['
name|'x'
op|'.'
name|'get'
op|'('
name|'key'
op|','
name|'default'
op|')'
name|'for'
name|'x'
name|'in'
name|'args'
op|']'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|prefixedMethodClassDict
dedent|''
name|'def'
name|'prefixedMethodClassDict'
op|'('
name|'clazz'
op|','
name|'prefix'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'return'
name|'dict'
op|'('
op|'['
op|'('
name|'name'
op|','
name|'getattr'
op|'('
name|'clazz'
op|','
name|'prefix'
op|'+'
name|'name'
op|')'
op|')'
name|'for'
name|'name'
name|'in'
name|'prefixedMethodNames'
op|'('
name|'clazz'
op|','
name|'prefix'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|prefixedMethodObjDict
dedent|''
name|'def'
name|'prefixedMethodObjDict'
op|'('
name|'obj'
op|','
name|'prefix'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'return'
name|'dict'
op|'('
op|'['
op|'('
name|'name'
op|','
name|'getattr'
op|'('
name|'obj'
op|','
name|'prefix'
op|'+'
name|'name'
op|')'
op|')'
name|'for'
name|'name'
name|'in'
name|'prefixedMethodNames'
op|'('
name|'obj'
op|'.'
name|'__class__'
op|','
name|'prefix'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ParseError
dedent|''
name|'class'
name|'ParseError'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'filename'
op|','
name|'line'
op|','
name|'col'
op|','
name|'message'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'filename'
op|'='
name|'filename'
newline|'\n'
name|'self'
op|'.'
name|'line'
op|'='
name|'line'
newline|'\n'
name|'self'
op|'.'
name|'col'
op|'='
name|'col'
newline|'\n'
name|'self'
op|'.'
name|'message'
op|'='
name|'message'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'       '
name|'return'
string|'"%s:%s:%s: %s"'
op|'%'
op|'('
name|'self'
op|'.'
name|'filename'
op|','
name|'self'
op|'.'
name|'line'
op|','
name|'self'
op|'.'
name|'col'
op|','
nl|'\n'
name|'self'
op|'.'
name|'message'
op|')'
newline|'\n'
nl|'\n'
DECL|class|XMLParser
dedent|''
dedent|''
name|'class'
name|'XMLParser'
op|'('
name|'Protocol'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|state
indent|'    '
name|'state'
op|'='
name|'None'
newline|'\n'
DECL|variable|encodings
name|'encodings'
op|'='
name|'None'
newline|'\n'
DECL|variable|filename
name|'filename'
op|'='
string|'"<xml />"'
newline|'\n'
DECL|variable|beExtremelyLenient
name|'beExtremelyLenient'
op|'='
number|'0'
newline|'\n'
DECL|variable|_prepend
name|'_prepend'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# _leadingBodyData will sometimes be set before switching to the'
nl|'\n'
comment|'# \'bodydata\' state, when we "accidentally" read a byte of bodydata'
nl|'\n'
comment|'# in a different state.'
nl|'\n'
DECL|variable|_leadingBodyData
name|'_leadingBodyData'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|connectionMade
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'lineno'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'colno'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'encodings'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|saveMark
dedent|''
name|'def'
name|'saveMark'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|"'''Get the line number and column of the last character parsed'''"
newline|'\n'
comment|'# This gets replaced during dataReceived, restored afterwards'
nl|'\n'
name|'return'
op|'('
name|'self'
op|'.'
name|'lineno'
op|','
name|'self'
op|'.'
name|'colno'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_parseError
dedent|''
name|'def'
name|'_parseError'
op|'('
name|'self'
op|','
name|'message'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'ParseError'
op|'('
op|'*'
op|'('
op|'('
name|'self'
op|'.'
name|'filename'
op|','
op|')'
op|'+'
name|'self'
op|'.'
name|'saveMark'
op|'('
op|')'
op|'+'
op|'('
name|'message'
op|','
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_buildStateTable
dedent|''
name|'def'
name|'_buildStateTable'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|"'''Return a dictionary of begin, do, end state function tuples'''"
newline|'\n'
comment|'# _buildStateTable leaves something to be desired but it does what it'
nl|'\n'
comment|"# does.. probably slowly, so I'm doing some evil caching so it doesn't"
nl|'\n'
comment|'# get called more than once per class.'
nl|'\n'
name|'stateTable'
op|'='
name|'getattr'
op|'('
name|'self'
op|'.'
name|'__class__'
op|','
string|"'__stateTable'"
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'stateTable'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'stateTable'
op|'='
name|'self'
op|'.'
name|'__class__'
op|'.'
name|'__stateTable'
op|'='
name|'zipfndict'
op|'('
nl|'\n'
op|'*'
op|'['
name|'prefixedMethodObjDict'
op|'('
name|'self'
op|','
name|'prefix'
op|')'
nl|'\n'
name|'for'
name|'prefix'
name|'in'
op|'('
string|"'begin_'"
op|','
string|"'do_'"
op|','
string|"'end_'"
op|')'
op|']'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'stateTable'
newline|'\n'
nl|'\n'
DECL|member|_decode
dedent|''
name|'def'
name|'_decode'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
string|"'UTF-16'"
name|'in'
name|'self'
op|'.'
name|'encodings'
name|'or'
string|"'UCS-2'"
name|'in'
name|'self'
op|'.'
name|'encodings'
op|':'
newline|'\n'
indent|'            '
name|'assert'
name|'not'
name|'len'
op|'('
name|'data'
op|')'
op|'&'
number|'1'
op|','
string|"'UTF-16 must come in pairs for now'"
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_prepend'
op|':'
newline|'\n'
indent|'            '
name|'data'
op|'='
name|'self'
op|'.'
name|'_prepend'
op|'+'
name|'data'
newline|'\n'
dedent|''
name|'for'
name|'encoding'
name|'in'
name|'self'
op|'.'
name|'encodings'
op|':'
newline|'\n'
indent|'            '
name|'data'
op|'='
name|'unicode'
op|'('
name|'data'
op|','
name|'encoding'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'data'
newline|'\n'
nl|'\n'
DECL|member|maybeBodyData
dedent|''
name|'def'
name|'maybeBodyData'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'endtag'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"'bodydata'"
newline|'\n'
nl|'\n'
comment|"# Get ready for fun! We're going to allow"
nl|'\n'
comment|'# <script>if (foo < bar)</script> to work!'
nl|'\n'
comment|'# We do this by making everything between <script> and'
nl|'\n'
comment|'# </script> a Text'
nl|'\n'
comment|'# BUT <script src="foo"> will be special-cased to do regular,'
nl|'\n'
comment|'# lenient behavior, because those may not have </script>'
nl|'\n'
comment|'# -radix'
nl|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'self'
op|'.'
name|'tagName'
op|'=='
string|"'script'"
nl|'\n'
name|'and'
name|'not'
name|'self'
op|'.'
name|'tagAttributes'
op|'.'
name|'has_key'
op|'('
string|"'src'"
op|')'
op|')'
op|':'
newline|'\n'
comment|'# we do this ourselves rather than having begin_waitforendscript'
nl|'\n'
comment|"# becuase that can get called multiple times and we don't want"
nl|'\n'
comment|'# bodydata to get reset other than the first time.'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'begin_bodydata'
op|'('
name|'None'
op|')'
newline|'\n'
name|'return'
string|"'waitforendscript'"
newline|'\n'
dedent|''
name|'return'
string|"'bodydata'"
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|member|dataReceived
dedent|''
name|'def'
name|'dataReceived'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'stateTable'
op|'='
name|'self'
op|'.'
name|'_buildStateTable'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'state'
op|':'
newline|'\n'
comment|'# all UTF-16 starts with this string'
nl|'\n'
indent|'            '
name|'if'
name|'data'
op|'.'
name|'startswith'
op|'('
string|"'\\xff\\xfe'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_prepend'
op|'='
string|"'\\xff\\xfe'"
newline|'\n'
name|'self'
op|'.'
name|'encodings'
op|'.'
name|'append'
op|'('
string|"'UTF-16'"
op|')'
newline|'\n'
name|'data'
op|'='
name|'data'
op|'['
number|'2'
op|':'
op|']'
newline|'\n'
dedent|''
name|'elif'
name|'data'
op|'.'
name|'startswith'
op|'('
string|"'\\xfe\\xff'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_prepend'
op|'='
string|"'\\xfe\\xff'"
newline|'\n'
name|'self'
op|'.'
name|'encodings'
op|'.'
name|'append'
op|'('
string|"'UTF-16'"
op|')'
newline|'\n'
name|'data'
op|'='
name|'data'
op|'['
number|'2'
op|':'
op|']'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'state'
op|'='
string|"'begin'"
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'encodings'
op|':'
newline|'\n'
indent|'            '
name|'data'
op|'='
name|'self'
op|'.'
name|'_decode'
op|'('
name|'data'
op|')'
newline|'\n'
comment|'# bring state, lineno, colno into local scope'
nl|'\n'
dedent|''
name|'lineno'
op|','
name|'colno'
op|'='
name|'self'
op|'.'
name|'lineno'
op|','
name|'self'
op|'.'
name|'colno'
newline|'\n'
name|'curState'
op|'='
name|'self'
op|'.'
name|'state'
newline|'\n'
comment|'# replace saveMark with a nested scope function'
nl|'\n'
name|'_saveMark'
op|'='
name|'self'
op|'.'
name|'saveMark'
newline|'\n'
DECL|function|saveMark
name|'def'
name|'saveMark'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'('
name|'lineno'
op|','
name|'colno'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'saveMark'
op|'='
name|'saveMark'
newline|'\n'
comment|'# fetch functions from the stateTable'
nl|'\n'
name|'beginFn'
op|','
name|'doFn'
op|','
name|'endFn'
op|'='
name|'stateTable'
op|'['
name|'curState'
op|']'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'byte'
name|'in'
name|'data'
op|':'
newline|'\n'
comment|'# do newline stuff'
nl|'\n'
indent|'                '
name|'if'
name|'byte'
op|'=='
string|"'\\n'"
op|':'
newline|'\n'
indent|'                    '
name|'lineno'
op|'+='
number|'1'
newline|'\n'
name|'colno'
op|'='
number|'0'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'colno'
op|'+='
number|'1'
newline|'\n'
dedent|''
name|'newState'
op|'='
name|'doFn'
op|'('
name|'byte'
op|')'
newline|'\n'
name|'if'
name|'newState'
name|'is'
name|'not'
name|'None'
name|'and'
name|'newState'
op|'!='
name|'curState'
op|':'
newline|'\n'
comment|'# this is the endFn from the previous state'
nl|'\n'
indent|'                    '
name|'endFn'
op|'('
op|')'
newline|'\n'
name|'curState'
op|'='
name|'newState'
newline|'\n'
name|'beginFn'
op|','
name|'doFn'
op|','
name|'endFn'
op|'='
name|'stateTable'
op|'['
name|'curState'
op|']'
newline|'\n'
name|'beginFn'
op|'('
name|'byte'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'saveMark'
op|'='
name|'_saveMark'
newline|'\n'
name|'self'
op|'.'
name|'lineno'
op|','
name|'self'
op|'.'
name|'colno'
op|'='
name|'lineno'
op|','
name|'colno'
newline|'\n'
comment|"# state doesn't make sense if there's an exception.."
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'state'
op|'='
name|'curState'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionLost
dedent|''
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        End the last state we were in.\n        """'
newline|'\n'
name|'stateTable'
op|'='
name|'self'
op|'.'
name|'_buildStateTable'
op|'('
op|')'
newline|'\n'
name|'stateTable'
op|'['
name|'self'
op|'.'
name|'state'
op|']'
op|'['
name|'END_HANDLER'
op|']'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# state methods'
nl|'\n'
nl|'\n'
DECL|member|do_begin
dedent|''
name|'def'
name|'do_begin'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'byte'
op|'.'
name|'isspace'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'if'
name|'byte'
op|'!='
string|"'<'"
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'beExtremelyLenient'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_leadingBodyData'
op|'='
name|'byte'
newline|'\n'
name|'return'
string|"'bodydata'"
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_parseError'
op|'('
string|'"First char of document [%r] wasn\'t <"'
op|'%'
op|'('
name|'byte'
op|','
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
string|"'tagstart'"
newline|'\n'
nl|'\n'
DECL|member|begin_comment
dedent|''
name|'def'
name|'begin_comment'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'commentbuf'
op|'='
string|"''"
newline|'\n'
nl|'\n'
DECL|member|do_comment
dedent|''
name|'def'
name|'do_comment'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'commentbuf'
op|'+='
name|'byte'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'commentbuf'
op|'.'
name|'endswith'
op|'('
string|"'-->'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'gotComment'
op|'('
name|'self'
op|'.'
name|'commentbuf'
op|'['
op|':'
op|'-'
number|'3'
op|']'
op|')'
newline|'\n'
name|'return'
string|"'bodydata'"
newline|'\n'
nl|'\n'
DECL|member|begin_tagstart
dedent|''
dedent|''
name|'def'
name|'begin_tagstart'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'tagName'
op|'='
string|"''"
comment|'# name of the tag'
newline|'\n'
name|'self'
op|'.'
name|'tagAttributes'
op|'='
op|'{'
op|'}'
comment|'# attributes of the tag'
newline|'\n'
name|'self'
op|'.'
name|'termtag'
op|'='
number|'0'
comment|'# is the tag self-terminating'
newline|'\n'
name|'self'
op|'.'
name|'endtag'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|member|do_tagstart
dedent|''
name|'def'
name|'do_tagstart'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'byte'
op|'.'
name|'isalnum'
op|'('
op|')'
name|'or'
name|'byte'
name|'in'
name|'identChars'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'tagName'
op|'+='
name|'byte'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'tagName'
op|'=='
string|"'!--'"
op|':'
newline|'\n'
indent|'                '
name|'return'
string|"'comment'"
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'byte'
op|'.'
name|'isspace'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'tagName'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'endtag'
op|':'
newline|'\n'
comment|'# properly strict thing to do here is probably to only'
nl|'\n'
comment|'# accept whitespace'
nl|'\n'
indent|'                    '
name|'return'
string|"'waitforgt'"
newline|'\n'
dedent|''
name|'return'
string|"'attrs'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_parseError'
op|'('
string|'"Whitespace before tag-name"'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'byte'
op|'=='
string|"'>'"
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'endtag'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'gotTagEnd'
op|'('
name|'self'
op|'.'
name|'tagName'
op|')'
newline|'\n'
name|'return'
string|"'bodydata'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'gotTagStart'
op|'('
name|'self'
op|'.'
name|'tagName'
op|','
op|'{'
op|'}'
op|')'
newline|'\n'
name|'return'
op|'('
name|'not'
name|'self'
op|'.'
name|'beExtremelyLenient'
op|')'
name|'and'
string|"'bodydata'"
name|'or'
name|'self'
op|'.'
name|'maybeBodyData'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'byte'
op|'=='
string|"'/'"
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'tagName'
op|':'
newline|'\n'
indent|'                '
name|'return'
string|"'afterslash'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'endtag'
op|'='
number|'1'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'byte'
name|'in'
string|"'!?'"
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'tagName'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'not'
name|'self'
op|'.'
name|'beExtremelyLenient'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_parseError'
op|'('
string|'"Invalid character in tag-name"'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'tagName'
op|'+='
name|'byte'
newline|'\n'
name|'self'
op|'.'
name|'termtag'
op|'='
number|'1'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'byte'
op|'=='
string|"'['"
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'tagName'
op|'=='
string|"'!'"
op|':'
newline|'\n'
indent|'                '
name|'return'
string|"'expectcdata'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_parseError'
op|'('
string|'"Invalid \'[\' in tag-name"'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'beExtremelyLenient'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'bodydata'
op|'='
string|"'<'"
newline|'\n'
name|'return'
string|"'unentity'"
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_parseError'
op|'('
string|"'Invalid tag character: %r'"
op|'%'
name|'byte'
op|')'
newline|'\n'
nl|'\n'
DECL|member|begin_unentity
dedent|''
dedent|''
name|'def'
name|'begin_unentity'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'bodydata'
op|'+='
name|'byte'
newline|'\n'
nl|'\n'
DECL|member|do_unentity
dedent|''
name|'def'
name|'do_unentity'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'bodydata'
op|'+='
name|'byte'
newline|'\n'
name|'return'
string|"'bodydata'"
newline|'\n'
nl|'\n'
DECL|member|end_unentity
dedent|''
name|'def'
name|'end_unentity'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'gotText'
op|'('
name|'self'
op|'.'
name|'bodydata'
op|')'
newline|'\n'
nl|'\n'
DECL|member|begin_expectcdata
dedent|''
name|'def'
name|'begin_expectcdata'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'cdatabuf'
op|'='
name|'byte'
newline|'\n'
nl|'\n'
DECL|member|do_expectcdata
dedent|''
name|'def'
name|'do_expectcdata'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'cdatabuf'
op|'+='
name|'byte'
newline|'\n'
name|'cdb'
op|'='
name|'self'
op|'.'
name|'cdatabuf'
newline|'\n'
name|'cd'
op|'='
string|"'[CDATA['"
newline|'\n'
name|'if'
name|'len'
op|'('
name|'cd'
op|')'
op|'>'
name|'len'
op|'('
name|'cdb'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'cd'
op|'.'
name|'startswith'
op|'('
name|'cdb'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'beExtremelyLenient'
op|':'
newline|'\n'
comment|'## WHAT THE CRAP!?  MSWord9 generates HTML that includes these'
nl|'\n'
comment|"## bizarre <![if !foo]> <![endif]> chunks, so I've gotta ignore"
nl|'\n'
comment|"## 'em as best I can.  this should really be a separate parse"
nl|'\n'
comment|"## state but I don't even have any idea what these _are_."
nl|'\n'
indent|'                '
name|'return'
string|"'waitforgt'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_parseError'
op|'('
string|'"Mal-formed CDATA header"'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'cd'
op|'=='
name|'cdb'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'cdatabuf'
op|'='
string|"''"
newline|'\n'
name|'return'
string|"'cdata'"
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_parseError'
op|'('
string|'"Mal-formed CDATA header"'
op|')'
newline|'\n'
nl|'\n'
DECL|member|do_cdata
dedent|''
name|'def'
name|'do_cdata'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'cdatabuf'
op|'+='
name|'byte'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'cdatabuf'
op|'.'
name|'endswith'
op|'('
string|'"]]>"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'cdatabuf'
op|'='
name|'self'
op|'.'
name|'cdatabuf'
op|'['
op|':'
op|'-'
number|'3'
op|']'
newline|'\n'
name|'return'
string|"'bodydata'"
newline|'\n'
nl|'\n'
DECL|member|end_cdata
dedent|''
dedent|''
name|'def'
name|'end_cdata'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'gotCData'
op|'('
name|'self'
op|'.'
name|'cdatabuf'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'cdatabuf'
op|'='
string|"''"
newline|'\n'
nl|'\n'
DECL|member|do_attrs
dedent|''
name|'def'
name|'do_attrs'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'byte'
op|'.'
name|'isalnum'
op|'('
op|')'
name|'or'
name|'byte'
name|'in'
name|'identChars'
op|':'
newline|'\n'
comment|'# XXX FIXME really handle !DOCTYPE at some point'
nl|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'tagName'
op|'=='
string|"'!DOCTYPE'"
op|':'
newline|'\n'
indent|'                '
name|'return'
string|"'doctype'"
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'tagName'
op|'['
number|'0'
op|']'
name|'in'
string|"'!?'"
op|':'
newline|'\n'
indent|'                '
name|'return'
string|"'waitforgt'"
newline|'\n'
dedent|''
name|'return'
string|"'attrname'"
newline|'\n'
dedent|''
name|'elif'
name|'byte'
op|'.'
name|'isspace'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'elif'
name|'byte'
op|'=='
string|"'>'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'gotTagStart'
op|'('
name|'self'
op|'.'
name|'tagName'
op|','
name|'self'
op|'.'
name|'tagAttributes'
op|')'
newline|'\n'
name|'return'
op|'('
name|'not'
name|'self'
op|'.'
name|'beExtremelyLenient'
op|')'
name|'and'
string|"'bodydata'"
name|'or'
name|'self'
op|'.'
name|'maybeBodyData'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'byte'
op|'=='
string|"'/'"
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"'afterslash'"
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'beExtremelyLenient'
op|':'
newline|'\n'
comment|"# discard and move on?  Only case I've seen of this so far was:"
nl|'\n'
comment|'# <foo bar="baz"">'
nl|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_parseError'
op|'('
string|'"Unexpected character: %r"'
op|'%'
name|'byte'
op|')'
newline|'\n'
nl|'\n'
DECL|member|begin_doctype
dedent|''
name|'def'
name|'begin_doctype'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'doctype'
op|'='
name|'byte'
newline|'\n'
nl|'\n'
DECL|member|do_doctype
dedent|''
name|'def'
name|'do_doctype'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'byte'
op|'=='
string|"'>'"
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"'bodydata'"
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'doctype'
op|'+='
name|'byte'
newline|'\n'
nl|'\n'
DECL|member|end_doctype
dedent|''
name|'def'
name|'end_doctype'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'gotDoctype'
op|'('
name|'self'
op|'.'
name|'doctype'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'doctype'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|do_waitforgt
dedent|''
name|'def'
name|'do_waitforgt'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'byte'
op|'=='
string|"'>'"
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'endtag'
name|'or'
name|'not'
name|'self'
op|'.'
name|'beExtremelyLenient'
op|':'
newline|'\n'
indent|'                '
name|'return'
string|"'bodydata'"
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'maybeBodyData'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|begin_attrname
dedent|''
dedent|''
name|'def'
name|'begin_attrname'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'attrname'
op|'='
name|'byte'
newline|'\n'
name|'self'
op|'.'
name|'_attrname_termtag'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|member|do_attrname
dedent|''
name|'def'
name|'do_attrname'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'byte'
op|'.'
name|'isalnum'
op|'('
op|')'
name|'or'
name|'byte'
name|'in'
name|'identChars'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'attrname'
op|'+='
name|'byte'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'elif'
name|'byte'
op|'=='
string|"'='"
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"'beforeattrval'"
newline|'\n'
dedent|''
name|'elif'
name|'byte'
op|'.'
name|'isspace'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"'beforeeq'"
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'beExtremelyLenient'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'byte'
name|'in'
string|'\'"\\\'\''
op|':'
newline|'\n'
indent|'                '
name|'return'
string|"'attrval'"
newline|'\n'
dedent|''
name|'if'
name|'byte'
name|'in'
name|'lenientIdentChars'
name|'or'
name|'byte'
op|'.'
name|'isalnum'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'attrname'
op|'+='
name|'byte'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'if'
name|'byte'
op|'=='
string|"'/'"
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_attrname_termtag'
op|'='
number|'1'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'if'
name|'byte'
op|'=='
string|"'>'"
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'attrval'
op|'='
string|"'True'"
newline|'\n'
name|'self'
op|'.'
name|'tagAttributes'
op|'['
name|'self'
op|'.'
name|'attrname'
op|']'
op|'='
name|'self'
op|'.'
name|'attrval'
newline|'\n'
name|'self'
op|'.'
name|'gotTagStart'
op|'('
name|'self'
op|'.'
name|'tagName'
op|','
name|'self'
op|'.'
name|'tagAttributes'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_attrname_termtag'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'gotTagEnd'
op|'('
name|'self'
op|'.'
name|'tagName'
op|')'
newline|'\n'
name|'return'
string|"'bodydata'"
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'maybeBodyData'
op|'('
op|')'
newline|'\n'
comment|"# something is really broken. let's leave this attribute where it"
nl|'\n'
comment|'# is and move on to the next thing'
nl|'\n'
dedent|''
name|'return'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_parseError'
op|'('
string|'"Invalid attribute name: %r %r"'
op|'%'
op|'('
name|'self'
op|'.'
name|'attrname'
op|','
name|'byte'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|do_beforeattrval
dedent|''
name|'def'
name|'do_beforeattrval'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'byte'
name|'in'
string|'\'"\\\'\''
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"'attrval'"
newline|'\n'
dedent|''
name|'elif'
name|'byte'
op|'.'
name|'isspace'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'beExtremelyLenient'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'byte'
name|'in'
name|'lenientIdentChars'
name|'or'
name|'byte'
op|'.'
name|'isalnum'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
string|"'messyattr'"
newline|'\n'
dedent|''
name|'if'
name|'byte'
op|'=='
string|"'>'"
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'attrval'
op|'='
string|"'True'"
newline|'\n'
name|'self'
op|'.'
name|'tagAttributes'
op|'['
name|'self'
op|'.'
name|'attrname'
op|']'
op|'='
name|'self'
op|'.'
name|'attrval'
newline|'\n'
name|'self'
op|'.'
name|'gotTagStart'
op|'('
name|'self'
op|'.'
name|'tagName'
op|','
name|'self'
op|'.'
name|'tagAttributes'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'maybeBodyData'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'byte'
op|'=='
string|"'\\\\'"
op|':'
newline|'\n'
comment|'# I saw this in actual HTML once:'
nl|'\n'
comment|'# <font size=\\"3\\"><sup>SM</sup></font>'
nl|'\n'
indent|'                '
name|'return'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_parseError'
op|'('
string|'"Invalid initial attribute value: %r; Attribute values must be quoted."'
op|'%'
name|'byte'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|attrname
dedent|''
name|'attrname'
op|'='
string|"''"
newline|'\n'
DECL|variable|attrval
name|'attrval'
op|'='
string|"''"
newline|'\n'
nl|'\n'
DECL|member|begin_beforeeq
name|'def'
name|'begin_beforeeq'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_beforeeq_termtag'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|member|do_beforeeq
dedent|''
name|'def'
name|'do_beforeeq'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'byte'
op|'=='
string|"'='"
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"'beforeattrval'"
newline|'\n'
dedent|''
name|'elif'
name|'byte'
op|'.'
name|'isspace'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'beExtremelyLenient'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'byte'
op|'.'
name|'isalnum'
op|'('
op|')'
name|'or'
name|'byte'
name|'in'
name|'identChars'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'attrval'
op|'='
string|"'True'"
newline|'\n'
name|'self'
op|'.'
name|'tagAttributes'
op|'['
name|'self'
op|'.'
name|'attrname'
op|']'
op|'='
name|'self'
op|'.'
name|'attrval'
newline|'\n'
name|'return'
string|"'attrname'"
newline|'\n'
dedent|''
name|'elif'
name|'byte'
op|'=='
string|"'>'"
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'attrval'
op|'='
string|"'True'"
newline|'\n'
name|'self'
op|'.'
name|'tagAttributes'
op|'['
name|'self'
op|'.'
name|'attrname'
op|']'
op|'='
name|'self'
op|'.'
name|'attrval'
newline|'\n'
name|'self'
op|'.'
name|'gotTagStart'
op|'('
name|'self'
op|'.'
name|'tagName'
op|','
name|'self'
op|'.'
name|'tagAttributes'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_beforeeq_termtag'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'gotTagEnd'
op|'('
name|'self'
op|'.'
name|'tagName'
op|')'
newline|'\n'
name|'return'
string|"'bodydata'"
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'maybeBodyData'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'byte'
op|'=='
string|"'/'"
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_beforeeq_termtag'
op|'='
number|'1'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_parseError'
op|'('
string|'"Invalid attribute"'
op|')'
newline|'\n'
nl|'\n'
DECL|member|begin_attrval
dedent|''
name|'def'
name|'begin_attrval'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'quotetype'
op|'='
name|'byte'
newline|'\n'
name|'self'
op|'.'
name|'attrval'
op|'='
string|"''"
newline|'\n'
nl|'\n'
DECL|member|do_attrval
dedent|''
name|'def'
name|'do_attrval'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'byte'
op|'=='
name|'self'
op|'.'
name|'quotetype'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"'attrs'"
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'attrval'
op|'+='
name|'byte'
newline|'\n'
nl|'\n'
DECL|member|end_attrval
dedent|''
name|'def'
name|'end_attrval'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'tagAttributes'
op|'['
name|'self'
op|'.'
name|'attrname'
op|']'
op|'='
name|'self'
op|'.'
name|'attrval'
newline|'\n'
name|'self'
op|'.'
name|'attrname'
op|'='
name|'self'
op|'.'
name|'attrval'
op|'='
string|"''"
newline|'\n'
nl|'\n'
DECL|member|begin_messyattr
dedent|''
name|'def'
name|'begin_messyattr'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'attrval'
op|'='
name|'byte'
newline|'\n'
nl|'\n'
DECL|member|do_messyattr
dedent|''
name|'def'
name|'do_messyattr'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'byte'
op|'.'
name|'isspace'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"'attrs'"
newline|'\n'
dedent|''
name|'elif'
name|'byte'
op|'=='
string|"'>'"
op|':'
newline|'\n'
indent|'            '
name|'endTag'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'attrval'
op|'.'
name|'endswith'
op|'('
string|"'/'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'endTag'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'attrval'
op|'='
name|'self'
op|'.'
name|'attrval'
op|'['
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'tagAttributes'
op|'['
name|'self'
op|'.'
name|'attrname'
op|']'
op|'='
name|'self'
op|'.'
name|'attrval'
newline|'\n'
name|'self'
op|'.'
name|'gotTagStart'
op|'('
name|'self'
op|'.'
name|'tagName'
op|','
name|'self'
op|'.'
name|'tagAttributes'
op|')'
newline|'\n'
name|'if'
name|'endTag'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'gotTagEnd'
op|'('
name|'self'
op|'.'
name|'tagName'
op|')'
newline|'\n'
name|'return'
string|"'bodydata'"
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'maybeBodyData'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'attrval'
op|'+='
name|'byte'
newline|'\n'
nl|'\n'
DECL|member|end_messyattr
dedent|''
dedent|''
name|'def'
name|'end_messyattr'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'attrval'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'tagAttributes'
op|'['
name|'self'
op|'.'
name|'attrname'
op|']'
op|'='
name|'self'
op|'.'
name|'attrval'
newline|'\n'
nl|'\n'
DECL|member|begin_afterslash
dedent|''
dedent|''
name|'def'
name|'begin_afterslash'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_after_slash_closed'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|member|do_afterslash
dedent|''
name|'def'
name|'do_afterslash'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
comment|'# this state is only after a self-terminating slash, e.g. <foo/>'
nl|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_after_slash_closed'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_parseError'
op|'('
string|'"Mal-formed"'
op|')'
comment|'#XXX When does this happen??'
newline|'\n'
dedent|''
name|'if'
name|'byte'
op|'!='
string|"'>'"
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'beExtremelyLenient'
op|':'
newline|'\n'
indent|'                '
name|'return'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_parseError'
op|'('
string|'"No data allowed after \'/\'"'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_after_slash_closed'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'gotTagStart'
op|'('
name|'self'
op|'.'
name|'tagName'
op|','
name|'self'
op|'.'
name|'tagAttributes'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'gotTagEnd'
op|'('
name|'self'
op|'.'
name|'tagName'
op|')'
newline|'\n'
comment|"# don't need maybeBodyData here because there better not be"
nl|'\n'
comment|"# any javascript code after a <script/>... we'll see :("
nl|'\n'
name|'return'
string|"'bodydata'"
newline|'\n'
nl|'\n'
DECL|member|begin_bodydata
dedent|''
name|'def'
name|'begin_bodydata'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_leadingBodyData'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'bodydata'
op|'='
name|'self'
op|'.'
name|'_leadingBodyData'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'_leadingBodyData'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'bodydata'
op|'='
string|"''"
newline|'\n'
nl|'\n'
DECL|member|do_bodydata
dedent|''
dedent|''
name|'def'
name|'do_bodydata'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'byte'
op|'=='
string|"'<'"
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"'tagstart'"
newline|'\n'
dedent|''
name|'if'
name|'byte'
op|'=='
string|"'&'"
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"'entityref'"
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'bodydata'
op|'+='
name|'byte'
newline|'\n'
nl|'\n'
DECL|member|end_bodydata
dedent|''
name|'def'
name|'end_bodydata'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'gotText'
op|'('
name|'self'
op|'.'
name|'bodydata'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'bodydata'
op|'='
string|"''"
newline|'\n'
nl|'\n'
DECL|member|do_waitforendscript
dedent|''
name|'def'
name|'do_waitforendscript'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'byte'
op|'=='
string|"'<'"
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"'waitscriptendtag'"
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'bodydata'
op|'+='
name|'byte'
newline|'\n'
nl|'\n'
DECL|member|begin_waitscriptendtag
dedent|''
name|'def'
name|'begin_waitscriptendtag'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'temptagdata'
op|'='
string|"''"
newline|'\n'
name|'self'
op|'.'
name|'tagName'
op|'='
string|"''"
newline|'\n'
name|'self'
op|'.'
name|'endtag'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|member|do_waitscriptendtag
dedent|''
name|'def'
name|'do_waitscriptendtag'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
comment|'# 1 enforce / as first byte read'
nl|'\n'
comment|'# 2 enforce following bytes to be subset of "script" until'
nl|'\n'
comment|'#   tagName == "script"'
nl|'\n'
comment|'#   2a when that happens, gotText(self.bodydata) and gotTagEnd(self.tagName)'
nl|'\n'
comment|"# 3 spaces can happen anywhere, they're ignored"
nl|'\n'
comment|'#   e.g. < / script >'
nl|'\n'
comment|"# 4 anything else causes all data I've read to be moved to the"
nl|'\n'
comment|'#   bodydata, and switch back to waitforendscript state'
nl|'\n'
nl|'\n'
comment|"# If it turns out this _isn't_ a </script>, we need to"
nl|'\n'
comment|"# remember all the data we've been through so we can append it"
nl|'\n'
comment|'# to bodydata'
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'temptagdata'
op|'+='
name|'byte'
newline|'\n'
nl|'\n'
comment|'# 1'
nl|'\n'
name|'if'
name|'byte'
op|'=='
string|"'/'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'endtag'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'elif'
name|'not'
name|'self'
op|'.'
name|'endtag'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'bodydata'
op|'+='
string|'"<"'
op|'+'
name|'self'
op|'.'
name|'temptagdata'
newline|'\n'
name|'return'
string|"'waitforendscript'"
newline|'\n'
comment|'# 2'
nl|'\n'
dedent|''
name|'elif'
name|'byte'
op|'.'
name|'isalnum'
op|'('
op|')'
name|'or'
name|'byte'
name|'in'
name|'identChars'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'tagName'
op|'+='
name|'byte'
newline|'\n'
name|'if'
name|'not'
string|"'script'"
op|'.'
name|'startswith'
op|'('
name|'self'
op|'.'
name|'tagName'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'bodydata'
op|'+='
string|'"<"'
op|'+'
name|'self'
op|'.'
name|'temptagdata'
newline|'\n'
name|'return'
string|"'waitforendscript'"
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'tagName'
op|'=='
string|"'script'"
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'gotText'
op|'('
name|'self'
op|'.'
name|'bodydata'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'gotTagEnd'
op|'('
name|'self'
op|'.'
name|'tagName'
op|')'
newline|'\n'
name|'return'
string|"'waitforgt'"
newline|'\n'
comment|'# 3'
nl|'\n'
dedent|''
dedent|''
name|'elif'
name|'byte'
op|'.'
name|'isspace'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"'waitscriptendtag'"
newline|'\n'
comment|'# 4'
nl|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'bodydata'
op|'+='
string|'"<"'
op|'+'
name|'self'
op|'.'
name|'temptagdata'
newline|'\n'
name|'return'
string|"'waitforendscript'"
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|begin_entityref
dedent|''
dedent|''
name|'def'
name|'begin_entityref'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'erefbuf'
op|'='
string|"''"
newline|'\n'
name|'self'
op|'.'
name|'erefextra'
op|'='
string|"''"
comment|'# extra bit for lenient mode'
newline|'\n'
nl|'\n'
DECL|member|do_entityref
dedent|''
name|'def'
name|'do_entityref'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'byte'
op|'.'
name|'isspace'
op|'('
op|')'
name|'or'
name|'byte'
op|'=='
string|'"<"'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'beExtremelyLenient'
op|':'
newline|'\n'
comment|"# '&foo' probably was '&amp;foo'"
nl|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'erefbuf'
name|'and'
name|'self'
op|'.'
name|'erefbuf'
op|'!='
string|'"amp"'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'erefextra'
op|'='
name|'self'
op|'.'
name|'erefbuf'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'erefbuf'
op|'='
string|'"amp"'
newline|'\n'
name|'if'
name|'byte'
op|'=='
string|'"<"'
op|':'
newline|'\n'
indent|'                    '
name|'return'
string|'"tagstart"'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'erefextra'
op|'+='
name|'byte'
newline|'\n'
name|'return'
string|"'spacebodydata'"
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_parseError'
op|'('
string|'"Bad entity reference"'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'byte'
op|'!='
string|"';'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'erefbuf'
op|'+='
name|'byte'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"'bodydata'"
newline|'\n'
nl|'\n'
DECL|member|end_entityref
dedent|''
dedent|''
name|'def'
name|'end_entityref'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'gotEntityReference'
op|'('
name|'self'
op|'.'
name|'erefbuf'
op|')'
newline|'\n'
nl|'\n'
comment|'# hacky support for space after & in entityref in beExtremelyLenient'
nl|'\n'
comment|'# state should only happen in that case'
nl|'\n'
DECL|member|begin_spacebodydata
dedent|''
name|'def'
name|'begin_spacebodydata'
op|'('
name|'self'
op|','
name|'byte'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'bodydata'
op|'='
name|'self'
op|'.'
name|'erefextra'
newline|'\n'
name|'self'
op|'.'
name|'erefextra'
op|'='
name|'None'
newline|'\n'
DECL|variable|do_spacebodydata
dedent|''
name|'do_spacebodydata'
op|'='
name|'do_bodydata'
newline|'\n'
DECL|variable|end_spacebodydata
name|'end_spacebodydata'
op|'='
name|'end_bodydata'
newline|'\n'
nl|'\n'
comment|'# Sorta SAX-ish API'
nl|'\n'
nl|'\n'
DECL|member|gotTagStart
name|'def'
name|'gotTagStart'
op|'('
name|'self'
op|','
name|'name'
op|','
name|'attributes'
op|')'
op|':'
newline|'\n'
indent|'        '
string|"'''Encountered an opening tag.\n\n        Default behaviour is to print.'''"
newline|'\n'
name|'print'
string|"'begin'"
op|','
name|'name'
op|','
name|'attributes'
newline|'\n'
nl|'\n'
DECL|member|gotText
dedent|''
name|'def'
name|'gotText'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|"'''Encountered text\n\n        Default behaviour is to print.'''"
newline|'\n'
name|'print'
string|"'text:'"
op|','
name|'repr'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
DECL|member|gotEntityReference
dedent|''
name|'def'
name|'gotEntityReference'
op|'('
name|'self'
op|','
name|'entityRef'
op|')'
op|':'
newline|'\n'
indent|'        '
string|"'''Encountered mnemonic entity reference\n\n        Default behaviour is to print.'''"
newline|'\n'
name|'print'
string|"'entityRef: &%s;'"
op|'%'
name|'entityRef'
newline|'\n'
nl|'\n'
DECL|member|gotComment
dedent|''
name|'def'
name|'gotComment'
op|'('
name|'self'
op|','
name|'comment'
op|')'
op|':'
newline|'\n'
indent|'        '
string|"'''Encountered comment.\n\n        Default behaviour is to ignore.'''"
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|gotCData
dedent|''
name|'def'
name|'gotCData'
op|'('
name|'self'
op|','
name|'cdata'
op|')'
op|':'
newline|'\n'
indent|'        '
string|"'''Encountered CDATA\n\n        Default behaviour is to call the gotText method'''"
newline|'\n'
name|'self'
op|'.'
name|'gotText'
op|'('
name|'cdata'
op|')'
newline|'\n'
nl|'\n'
DECL|member|gotDoctype
dedent|''
name|'def'
name|'gotDoctype'
op|'('
name|'self'
op|','
name|'doctype'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Encountered DOCTYPE\n\n        This is really grotty: it basically just gives you everything between\n        \'<!DOCTYPE\' and \'>\' as an argument.\n        """'
newline|'\n'
name|'print'
string|"'!DOCTYPE'"
op|','
name|'repr'
op|'('
name|'doctype'
op|')'
newline|'\n'
nl|'\n'
DECL|member|gotTagEnd
dedent|''
name|'def'
name|'gotTagEnd'
op|'('
name|'self'
op|','
name|'name'
op|')'
op|':'
newline|'\n'
indent|'        '
string|"'''Encountered closing tag\n\n        Default behaviour is to print.'''"
newline|'\n'
name|'print'
string|"'end'"
op|','
name|'name'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'__name__'
op|'=='
string|"'__main__'"
op|':'
newline|'\n'
indent|'    '
name|'from'
name|'cStringIO'
name|'import'
name|'StringIO'
newline|'\n'
name|'testDocument'
op|'='
string|'\'\'\'\n\n    <!DOCTYPE ignore all this shit, hah its malformed!!!!@$>\n    <?xml version="suck it"?>\n    <foo>\n    &#65;\n    <bar />\n    <baz boz="buz">boz &zop;</baz>\n    <![CDATA[ foo bar baz ]]>\n    </foo>\n    \'\'\''
newline|'\n'
DECL|variable|x
name|'x'
op|'='
name|'XMLParser'
op|'('
op|')'
newline|'\n'
name|'x'
op|'.'
name|'makeConnection'
op|'('
name|'FileWrapper'
op|'('
name|'StringIO'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
comment|'# fn = "/home/glyph/Projects/Twisted/doc/howto/ipc10paper.html"'
nl|'\n'
DECL|variable|fn
name|'fn'
op|'='
string|'"/home/glyph/gruesome.xml"'
newline|'\n'
comment|'# testDocument = open(fn).read()'
nl|'\n'
name|'x'
op|'.'
name|'dataReceived'
op|'('
name|'testDocument'
op|')'
newline|'\n'
dedent|''
endmarker|''
end_unit
