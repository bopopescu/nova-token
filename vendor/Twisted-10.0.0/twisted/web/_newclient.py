begin_unit
comment|'# -*- test-case-name: twisted.web.test.test_newclient -*-'
nl|'\n'
comment|'# Copyright (c) 2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nAn U{HTTP 1.1<http://www.w3.org/Protocols/rfc2616/rfc2616.html>} client.\n\nThe way to use the functionality provided by this module is to:\n\n  - Connect a L{HTTP11ClientProtocol} to an HTTP server\n  - Create a L{Request} with the appropriate data\n  - Pass the request to L{HTTP11ClientProtocol.request}\n  - The returned Deferred will fire with a L{Response} object\n  - Create a L{IProtocol} provider which can handle the response body\n  - Connect it to the response with L{Response.deliverBody}\n  - When the protocol\'s C{connectionLost} method is called, the response is\n    complete.  See L{Response.deliverBody} for details.\n\nVarious other classes in this module support this usage:\n\n  - HTTPParser is the basic HTTP parser.  It can handle the parts of HTTP which\n    are symmetric between requests and responses.\n\n  - HTTPClientParser extends HTTPParser to handle response-specific parts of\n    HTTP.  One instance is created for each request to parse the corresponding\n    response.\n"""'
newline|'\n'
nl|'\n'
DECL|variable|__metaclass__
name|'__metaclass__'
op|'='
name|'type'
newline|'\n'
nl|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'implements'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'log'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'reflect'
name|'import'
name|'fullyQualifiedName'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'failure'
name|'import'
name|'Failure'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'compat'
name|'import'
name|'set'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'interfaces'
name|'import'
name|'IConsumer'
op|','
name|'IPushProducer'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'error'
name|'import'
name|'ConnectionDone'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'defer'
name|'import'
name|'Deferred'
op|','
name|'succeed'
op|','
name|'fail'
op|','
name|'maybeDeferred'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'protocol'
name|'import'
name|'Protocol'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'protocols'
op|'.'
name|'basic'
name|'import'
name|'LineReceiver'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
op|'.'
name|'iweb'
name|'import'
name|'UNKNOWN_LENGTH'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
op|'.'
name|'http_headers'
name|'import'
name|'Headers'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
op|'.'
name|'http'
name|'import'
name|'NO_CONTENT'
op|','
name|'NOT_MODIFIED'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
op|'.'
name|'http'
name|'import'
name|'_DataLoss'
op|','
name|'PotentialDataLoss'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
op|'.'
name|'http'
name|'import'
name|'_IdentityTransferDecoder'
op|','
name|'_ChunkedTransferDecoder'
newline|'\n'
nl|'\n'
comment|'# States HTTPParser can be in'
nl|'\n'
DECL|variable|STATUS
name|'STATUS'
op|'='
string|"'STATUS'"
newline|'\n'
DECL|variable|HEADER
name|'HEADER'
op|'='
string|"'HEADER'"
newline|'\n'
DECL|variable|BODY
name|'BODY'
op|'='
string|"'BODY'"
newline|'\n'
DECL|variable|DONE
name|'DONE'
op|'='
string|"'DONE'"
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|BadHeaders
name|'class'
name|'BadHeaders'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Headers passed to L{Request} were in some way invalid.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ExcessWrite
dedent|''
name|'class'
name|'ExcessWrite'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    The body L{IBodyProducer} for a request tried to write data after\n    indicating it had finished writing data.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ParseError
dedent|''
name|'class'
name|'ParseError'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Some received data could not be parsed.\n\n    @ivar data: The string which could not be parsed.\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'reason'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'Exception'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'reason'
op|','
name|'data'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'data'
op|'='
name|'data'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|BadResponseVersion
dedent|''
dedent|''
name|'class'
name|'BadResponseVersion'
op|'('
name|'ParseError'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    The version string in a status line was unparsable.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|_WrapperException
dedent|''
name|'class'
name|'_WrapperException'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    L{_WrapperException} is the base exception type for exceptions which\n    include one or more other exceptions as the low-level causes.\n\n    @ivar reasons: A list of exceptions.  See subclass documentation for more\n        details.\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'reasons'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'Exception'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'reasons'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'reasons'
op|'='
name|'reasons'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|RequestGenerationFailed
dedent|''
dedent|''
name|'class'
name|'RequestGenerationFailed'
op|'('
name|'_WrapperException'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    There was an error while creating the bytes which make up a request.\n\n    @ivar reasons: A C{list} of one or more L{Failure} instances giving the\n        reasons the request generation was considered to have failed.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|RequestTransmissionFailed
dedent|''
name|'class'
name|'RequestTransmissionFailed'
op|'('
name|'_WrapperException'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    There was an error while sending the bytes which make up a request.\n\n    @ivar reasons: A C{list} of one or more L{Failure} instances giving the\n        reasons the request transmission was considered to have failed.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|WrongBodyLength
dedent|''
name|'class'
name|'WrongBodyLength'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    An L{IBodyProducer} declared the number of bytes it was going to\n    produce (via its C{length} attribute) and then produced a different number\n    of bytes.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ResponseDone
dedent|''
name|'class'
name|'ResponseDone'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    L{ResponseDone} may be passed to L{IProtocol.connectionLost} on the\n    protocol passed to L{Response.deliverBody} and indicates that the entire\n    response has been delivered.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ResponseFailed
dedent|''
name|'class'
name|'ResponseFailed'
op|'('
name|'_WrapperException'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    L{ResponseFailed} indicates that all of the response to a request was not\n    received for some reason.\n\n    @ivar reasons: A C{list} of one or more L{Failure} instances giving the\n        reasons the response was considered to have failed.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|RequestNotSent
dedent|''
name|'class'
name|'RequestNotSent'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    L{RequestNotSent} indicates that an attempt was made to issue a request but\n    for reasons unrelated to the details of the request itself, the request\n    could not be sent.  For example, this may indicate that an attempt was made\n    to send a request using a protocol which is no longer connected to a\n    server.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|_callAppFunction
dedent|''
name|'def'
name|'_callAppFunction'
op|'('
name|'function'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Call C{function}.  If it raises an exception, log it with a minimal\n    description of the source.\n\n    @return: C{None}\n    """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'function'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'        '
name|'log'
op|'.'
name|'err'
op|'('
name|'None'
op|','
string|'"Unexpected exception from %s"'
op|'%'
op|'('
nl|'\n'
name|'fullyQualifiedName'
op|'('
name|'function'
op|')'
op|','
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|HTTPParser
dedent|''
dedent|''
name|'class'
name|'HTTPParser'
op|'('
name|'LineReceiver'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    L{HTTPParser} handles the parsing side of HTTP processing. With a suitable\n    subclass, it can parse either the client side or the server side of the\n    connection.\n\n    @ivar headers: All of the non-connection control message headers yet\n        received.\n\n    @ivar state: State indicator for the response parsing state machine.  One\n        of C{STATUS}, C{HEADER}, C{BODY}, C{DONE}.\n\n    @ivar _partialHeader: C{None} or a C{list} of the lines of a multiline\n        header while that header is being received.\n    """'
newline|'\n'
nl|'\n'
comment|"# NOTE: According to HTTP spec, we're supposed to eat the"
nl|'\n'
comment|"# 'Proxy-Authenticate' and 'Proxy-Authorization' headers also, but that"
nl|'\n'
comment|"# doesn't sound like a good idea to me, because it makes it impossible to"
nl|'\n'
comment|'# have a non-authenticating transparent proxy in front of an authenticating'
nl|'\n'
comment|'# proxy. An authenticating proxy can eat them itself. -jknight'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Further, quoting'
nl|'\n'
comment|'# http://homepages.tesco.net/J.deBoynePollard/FGA/web-proxy-connection-header.html'
nl|'\n'
comment|"# regarding the 'Proxy-Connection' header:"
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    The Proxy-Connection: header is a mistake in how some web browsers'
nl|'\n'
comment|'#    use HTTP. Its name is the result of a false analogy. It is not a'
nl|'\n'
comment|'#    standard part of the protocol. There is a different standard'
nl|'\n'
comment|'#    protocol mechanism for doing what it does. And its existence'
nl|'\n'
comment|'#    imposes a requirement upon HTTP servers such that no proxy HTTP'
nl|'\n'
comment|'#    server can be standards-conforming in practice.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# -exarkun'
nl|'\n'
nl|'\n'
DECL|variable|CONNECTION_CONTROL_HEADERS
name|'CONNECTION_CONTROL_HEADERS'
op|'='
name|'set'
op|'('
op|'['
nl|'\n'
string|"'content-length'"
op|','
string|"'connection'"
op|','
string|"'keep-alive'"
op|','
string|"'te'"
op|','
string|"'trailers'"
op|','
nl|'\n'
string|"'transfer-encoding'"
op|','
string|"'upgrade'"
op|','
string|"'proxy-connection'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|connectionMade
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'headers'
op|'='
name|'Headers'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'connHeaders'
op|'='
name|'Headers'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'state'
op|'='
name|'STATUS'
newline|'\n'
name|'self'
op|'.'
name|'_partialHeader'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|switchToBodyMode
dedent|''
name|'def'
name|'switchToBodyMode'
op|'('
name|'self'
op|','
name|'decoder'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Switch to body parsing mode - interpret any more bytes delivered as\n        part of the message body and deliver them to the given decoder.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'state'
op|'=='
name|'BODY'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'RuntimeError'
op|'('
string|'"already in body mode"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'bodyDecoder'
op|'='
name|'decoder'
newline|'\n'
name|'self'
op|'.'
name|'state'
op|'='
name|'BODY'
newline|'\n'
name|'self'
op|'.'
name|'setRawMode'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|lineReceived
dedent|''
name|'def'
name|'lineReceived'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Handle one line from a response.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'state'
op|'=='
name|'STATUS'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'statusReceived'
op|'('
name|'line'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'state'
op|'='
name|'HEADER'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'state'
op|'=='
name|'HEADER'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'line'
name|'or'
name|'line'
op|'['
number|'0'
op|']'
name|'not'
name|'in'
string|"' \\t'"
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'_partialHeader'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'header'
op|'='
string|"''"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'_partialHeader'
op|')'
newline|'\n'
name|'name'
op|','
name|'value'
op|'='
name|'header'
op|'.'
name|'split'
op|'('
string|"':'"
op|','
number|'1'
op|')'
newline|'\n'
name|'value'
op|'='
name|'value'
op|'.'
name|'strip'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'headerReceived'
op|'('
name|'name'
op|','
name|'value'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'line'
op|':'
newline|'\n'
comment|'# Empty line means the header section is over.'
nl|'\n'
indent|'                    '
name|'self'
op|'.'
name|'allHeadersReceived'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Line not beginning with LWS is another header.'
nl|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_partialHeader'
op|'='
op|'['
name|'line'
op|']'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# A line beginning with LWS is a continuation of a header'
nl|'\n'
comment|'# begun on a previous line.'
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'_partialHeader'
op|'.'
name|'append'
op|'('
name|'line'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|rawDataReceived
dedent|''
dedent|''
dedent|''
name|'def'
name|'rawDataReceived'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Pass data from the message body to the body decoder object.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'bodyDecoder'
op|'.'
name|'dataReceived'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|isConnectionControlHeader
dedent|''
name|'def'
name|'isConnectionControlHeader'
op|'('
name|'self'
op|','
name|'name'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return C{True} if the given lower-cased name is the name of a\n        connection control header (rather than an entity header).\n\n        According to RFC 2616, section 14.10, the tokens in the Connection\n        header are probably relevant here.  However, I am not sure what the\n        practical consequences of either implementing or ignoring that are.\n        So I leave it unimplemented for the time being.\n        """'
newline|'\n'
name|'return'
name|'name'
name|'in'
name|'self'
op|'.'
name|'CONNECTION_CONTROL_HEADERS'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|statusReceived
dedent|''
name|'def'
name|'statusReceived'
op|'('
name|'self'
op|','
name|'status'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Callback invoked whenever the first line of a new message is received.\n        Override this.\n\n        @param status: The first line of an HTTP request or response message\n            without trailing I{CR LF}.\n        @type status: C{str}\n        """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|headerReceived
dedent|''
name|'def'
name|'headerReceived'
op|'('
name|'self'
op|','
name|'name'
op|','
name|'value'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Store the given header in C{self.headers}.\n        """'
newline|'\n'
name|'name'
op|'='
name|'name'
op|'.'
name|'lower'
op|'('
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'isConnectionControlHeader'
op|'('
name|'name'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'headers'
op|'='
name|'self'
op|'.'
name|'connHeaders'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'headers'
op|'='
name|'self'
op|'.'
name|'headers'
newline|'\n'
dedent|''
name|'headers'
op|'.'
name|'addRawHeader'
op|'('
name|'name'
op|','
name|'value'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|allHeadersReceived
dedent|''
name|'def'
name|'allHeadersReceived'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Callback invoked after the last header is passed to C{headerReceived}.\n        Override this to change to the C{BODY} or C{DONE} state.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'switchToBodyMode'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|HTTPClientParser
dedent|''
dedent|''
name|'class'
name|'HTTPClientParser'
op|'('
name|'HTTPParser'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    An HTTP parser which only handles HTTP responses.\n\n    @ivar request: The request with which the expected response is associated.\n    @type request: L{Request}\n\n    @ivar NO_BODY_CODES: A C{set} of response codes which B{MUST NOT} have a\n        body.\n\n    @ivar finisher: A callable to invoke when this response is fully parsed.\n\n    @ivar _responseDeferred: A L{Deferred} which will be called back with the\n        response when all headers in the response have been received.\n        Thereafter, C{None}.\n    """'
newline|'\n'
DECL|variable|NO_BODY_CODES
name|'NO_BODY_CODES'
op|'='
name|'set'
op|'('
op|'['
name|'NO_CONTENT'
op|','
name|'NOT_MODIFIED'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|_transferDecoders
name|'_transferDecoders'
op|'='
op|'{'
nl|'\n'
string|"'chunked'"
op|':'
name|'_ChunkedTransferDecoder'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
DECL|variable|bodyDecoder
name|'bodyDecoder'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'request'
op|','
name|'finisher'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'request'
op|'='
name|'request'
newline|'\n'
name|'self'
op|'.'
name|'finisher'
op|'='
name|'finisher'
newline|'\n'
name|'self'
op|'.'
name|'_responseDeferred'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|parseVersion
dedent|''
name|'def'
name|'parseVersion'
op|'('
name|'self'
op|','
name|'strversion'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Parse version strings of the form Protocol \'/\' Major \'.\' Minor. E.g.\n        \'HTTP/1.1\'.  Returns (protocol, major, minor).  Will raise ValueError\n        on bad syntax.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'proto'
op|','
name|'strnumber'
op|'='
name|'strversion'
op|'.'
name|'split'
op|'('
string|"'/'"
op|')'
newline|'\n'
name|'major'
op|','
name|'minor'
op|'='
name|'strnumber'
op|'.'
name|'split'
op|'('
string|"'.'"
op|')'
newline|'\n'
name|'major'
op|','
name|'minor'
op|'='
name|'int'
op|'('
name|'major'
op|')'
op|','
name|'int'
op|'('
name|'minor'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|','
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'BadResponseVersion'
op|'('
name|'str'
op|'('
name|'e'
op|')'
op|','
name|'strversion'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'major'
op|'<'
number|'0'
name|'or'
name|'minor'
op|'<'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'BadResponseVersion'
op|'('
string|'"version may not be negative"'
op|','
name|'strversion'
op|')'
newline|'\n'
dedent|''
name|'return'
op|'('
name|'proto'
op|','
name|'major'
op|','
name|'minor'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|statusReceived
dedent|''
name|'def'
name|'statusReceived'
op|'('
name|'self'
op|','
name|'status'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Parse the status line into its components and create a response object\n        to keep track of this response\'s state.\n        """'
newline|'\n'
name|'parts'
op|'='
name|'status'
op|'.'
name|'split'
op|'('
string|"' '"
op|','
number|'2'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'parts'
op|')'
op|'!='
number|'3'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ParseError'
op|'('
string|'"wrong number of parts"'
op|','
name|'status'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'statusCode'
op|'='
name|'int'
op|'('
name|'parts'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ParseError'
op|'('
string|'"non-integer status code"'
op|','
name|'status'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'response'
op|'='
name|'Response'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'parseVersion'
op|'('
name|'parts'
op|'['
number|'0'
op|']'
op|')'
op|','
nl|'\n'
name|'statusCode'
op|','
nl|'\n'
name|'parts'
op|'['
number|'2'
op|']'
op|','
nl|'\n'
name|'self'
op|'.'
name|'headers'
op|','
nl|'\n'
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_finished
dedent|''
name|'def'
name|'_finished'
op|'('
name|'self'
op|','
name|'rest'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called to indicate that an entire response has been received.  No more\n        bytes will be interpreted by this L{HTTPClientParser}.  Extra bytes are\n        passed up and the state of this L{HTTPClientParser} is set to I{DONE}.\n\n        @param rest: A C{str} giving any extra bytes delivered to this\n            L{HTTPClientParser} which are not part of the response being\n            parsed.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'state'
op|'='
name|'DONE'
newline|'\n'
name|'self'
op|'.'
name|'finisher'
op|'('
name|'rest'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|isConnectionControlHeader
dedent|''
name|'def'
name|'isConnectionControlHeader'
op|'('
name|'self'
op|','
name|'name'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Content-Length in the response to a HEAD request is an entity header,\n        not a connection control header.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'request'
op|'.'
name|'method'
op|'=='
string|"'HEAD'"
name|'and'
name|'name'
op|'=='
string|"'content-length'"
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'return'
name|'HTTPParser'
op|'.'
name|'isConnectionControlHeader'
op|'('
name|'self'
op|','
name|'name'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|allHeadersReceived
dedent|''
name|'def'
name|'allHeadersReceived'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Figure out how long the response body is going to be by examining\n        headers and stuff.\n        """'
newline|'\n'
name|'if'
op|'('
name|'self'
op|'.'
name|'response'
op|'.'
name|'code'
name|'in'
name|'self'
op|'.'
name|'NO_BODY_CODES'
nl|'\n'
name|'or'
name|'self'
op|'.'
name|'request'
op|'.'
name|'method'
op|'=='
string|"'HEAD'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'response'
op|'.'
name|'length'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_finished'
op|'('
name|'self'
op|'.'
name|'clearLineBuffer'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'transferEncodingHeaders'
op|'='
name|'self'
op|'.'
name|'connHeaders'
op|'.'
name|'getRawHeaders'
op|'('
nl|'\n'
string|"'transfer-encoding'"
op|')'
newline|'\n'
name|'if'
name|'transferEncodingHeaders'
op|':'
newline|'\n'
nl|'\n'
comment|'# This could be a KeyError.  However, that would mean we do not'
nl|'\n'
comment|'# know how to decode the response body, so failing the request'
nl|'\n'
comment|'# is as good a behavior as any.  Perhaps someday we will want'
nl|'\n'
comment|'# to normalize/document/test this specifically, but failing'
nl|'\n'
comment|'# seems fine to me for now.'
nl|'\n'
indent|'                '
name|'transferDecoder'
op|'='
name|'self'
op|'.'
name|'_transferDecoders'
op|'['
name|'transferEncodingHeaders'
op|'['
number|'0'
op|']'
op|'.'
name|'lower'
op|'('
op|')'
op|']'
newline|'\n'
nl|'\n'
comment|'# If anyone ever invents a transfer encoding other than'
nl|'\n'
comment|'# chunked (yea right), and that transfer encoding can predict'
nl|'\n'
comment|'# the length of the response body, it might be sensible to'
nl|'\n'
comment|"# allow the transfer decoder to set the response object's"
nl|'\n'
comment|'# length attribute.'
nl|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'contentLengthHeaders'
op|'='
name|'self'
op|'.'
name|'connHeaders'
op|'.'
name|'getRawHeaders'
op|'('
string|"'content-length'"
op|')'
newline|'\n'
name|'if'
name|'contentLengthHeaders'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'contentLength'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'elif'
name|'len'
op|'('
name|'contentLengthHeaders'
op|')'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'                    '
name|'contentLength'
op|'='
name|'int'
op|'('
name|'contentLengthHeaders'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'response'
op|'.'
name|'length'
op|'='
name|'contentLength'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# "HTTP Message Splitting" or "HTTP Response Smuggling"'
nl|'\n'
comment|"# potentially happening.  Or it's just a buggy server."
nl|'\n'
indent|'                    '
name|'raise'
name|'ValueError'
op|'('
nl|'\n'
string|'"Too many Content-Length headers; response is invalid"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'contentLength'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_finished'
op|'('
name|'self'
op|'.'
name|'clearLineBuffer'
op|'('
op|')'
op|')'
newline|'\n'
name|'transferDecoder'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'transferDecoder'
op|'='
name|'lambda'
name|'x'
op|','
name|'y'
op|':'
name|'_IdentityTransferDecoder'
op|'('
nl|'\n'
name|'contentLength'
op|','
name|'x'
op|','
name|'y'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'transferDecoder'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'response'
op|'.'
name|'_bodyDataFinished'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Make sure as little data as possible from the response body'
nl|'\n'
comment|'# gets delivered to the response object until the response'
nl|'\n'
comment|'# object actually indicates it is ready to handle bytes'
nl|'\n'
comment|'# (probably because an application gave it a way to interpret'
nl|'\n'
comment|'# them).'
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'pauseProducing'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'switchToBodyMode'
op|'('
name|'transferDecoder'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'response'
op|'.'
name|'_bodyDataReceived'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_finished'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# This must be last.  If it were first, then application code might'
nl|'\n'
comment|'# change some state (for example, registering a protocol to receive the'
nl|'\n'
comment|'# response body).  Then the pauseProducing above would be wrong since'
nl|'\n'
comment|'# the response is ready for bytes and nothing else would ever resume'
nl|'\n'
comment|'# the transport.'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_responseDeferred'
op|'.'
name|'callback'
op|'('
name|'self'
op|'.'
name|'response'
op|')'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'_responseDeferred'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionLost
dedent|''
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'bodyDecoder'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'bodyDecoder'
op|'.'
name|'noMoreData'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'PotentialDataLoss'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'response'
op|'.'
name|'_bodyDataFinished'
op|'('
name|'Failure'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'_DataLoss'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'response'
op|'.'
name|'_bodyDataFinished'
op|'('
nl|'\n'
name|'Failure'
op|'('
name|'ResponseFailed'
op|'('
op|'['
name|'reason'
op|','
name|'Failure'
op|'('
op|')'
op|']'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'response'
op|'.'
name|'_bodyDataFinished'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|':'
newline|'\n'
comment|'# Handle exceptions from both the except suites and the else'
nl|'\n'
comment|"# suite.  Those functions really shouldn't raise exceptions,"
nl|'\n'
comment|"# but maybe there's some buggy application code somewhere"
nl|'\n'
comment|'# making things difficult.'
nl|'\n'
indent|'                '
name|'log'
op|'.'
name|'err'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'self'
op|'.'
name|'state'
op|'!='
name|'DONE'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_responseDeferred'
op|'.'
name|'errback'
op|'('
name|'Failure'
op|'('
name|'ResponseFailed'
op|'('
op|'['
name|'reason'
op|']'
op|')'
op|')'
op|')'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'_responseDeferred'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|Request
dedent|''
dedent|''
dedent|''
name|'class'
name|'Request'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A L{Request} instance describes an HTTP request to be sent to an HTTP\n    server.\n\n    @ivar method: The HTTP method to for this request, ex: \'GET\', \'HEAD\',\n        \'POST\', etc.\n    @type method: C{str}\n\n    @ivar uri: The relative URI of the resource to request.  For example,\n        C{\'/foo/bar?baz=quux\'}.\n    @type uri: C{str}\n\n    @ivar headers: Headers to be sent to the server.  It is important to\n        note that this object does not create any implicit headers.  So it\n        is up to the HTTP Client to add required headers such as \'Host\'.\n    @type headers: L{twisted.web.http_headers.Headers}\n\n    @ivar bodyProducer: C{None} or an L{IBodyProducer} provider which\n        produces the content body to send to the remote HTTP server.\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'method'
op|','
name|'uri'
op|','
name|'headers'
op|','
name|'bodyProducer'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'method'
op|'='
name|'method'
newline|'\n'
name|'self'
op|'.'
name|'uri'
op|'='
name|'uri'
newline|'\n'
name|'self'
op|'.'
name|'headers'
op|'='
name|'headers'
newline|'\n'
name|'self'
op|'.'
name|'bodyProducer'
op|'='
name|'bodyProducer'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_writeHeaders
dedent|''
name|'def'
name|'_writeHeaders'
op|'('
name|'self'
op|','
name|'transport'
op|','
name|'TEorCL'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'hosts'
op|'='
name|'self'
op|'.'
name|'headers'
op|'.'
name|'getRawHeaders'
op|'('
string|"'host'"
op|','
op|'('
op|')'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'hosts'
op|')'
op|'!='
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'BadHeaders'
op|'('
string|'"Exactly one Host header required"'
op|')'
newline|'\n'
nl|'\n'
comment|'# In the future, having the protocol version be a parameter to this'
nl|'\n'
comment|'# method would probably be good.  It would be nice if this method'
nl|'\n'
comment|"# weren't limited to issueing HTTP/1.1 requests."
nl|'\n'
dedent|''
name|'requestLines'
op|'='
op|'['
op|']'
newline|'\n'
name|'requestLines'
op|'.'
name|'append'
op|'('
nl|'\n'
string|"'%s %s HTTP/1.1\\r\\n'"
op|'%'
op|'('
name|'self'
op|'.'
name|'method'
op|','
name|'self'
op|'.'
name|'uri'
op|')'
op|')'
newline|'\n'
name|'requestLines'
op|'.'
name|'append'
op|'('
string|"'Connection: close\\r\\n'"
op|')'
newline|'\n'
name|'if'
name|'TEorCL'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'requestLines'
op|'.'
name|'append'
op|'('
name|'TEorCL'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'name'
op|','
name|'values'
name|'in'
name|'self'
op|'.'
name|'headers'
op|'.'
name|'getAllRawHeaders'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'requestLines'
op|'.'
name|'extend'
op|'('
op|'['
string|"'%s: %s\\r\\n'"
op|'%'
op|'('
name|'name'
op|','
name|'v'
op|')'
name|'for'
name|'v'
name|'in'
name|'values'
op|']'
op|')'
newline|'\n'
dedent|''
name|'requestLines'
op|'.'
name|'append'
op|'('
string|"'\\r\\n'"
op|')'
newline|'\n'
name|'transport'
op|'.'
name|'writeSequence'
op|'('
name|'requestLines'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_writeToChunked
dedent|''
name|'def'
name|'_writeToChunked'
op|'('
name|'self'
op|','
name|'transport'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write this request to the given transport using chunked\n        transfer-encoding to frame the body.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_writeHeaders'
op|'('
name|'transport'
op|','
string|"'Transfer-Encoding: chunked\\r\\n'"
op|')'
newline|'\n'
name|'encoder'
op|'='
name|'ChunkedEncoder'
op|'('
name|'transport'
op|')'
newline|'\n'
name|'encoder'
op|'.'
name|'registerProducer'
op|'('
name|'self'
op|'.'
name|'bodyProducer'
op|','
name|'True'
op|')'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'bodyProducer'
op|'.'
name|'startProducing'
op|'('
name|'encoder'
op|')'
newline|'\n'
nl|'\n'
DECL|function|cbProduced
name|'def'
name|'cbProduced'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'encoder'
op|'.'
name|'unregisterProducer'
op|'('
op|')'
newline|'\n'
DECL|function|ebProduced
dedent|''
name|'def'
name|'ebProduced'
op|'('
name|'err'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'encoder'
op|'.'
name|'_allowNoMoreWrites'
op|'('
op|')'
newline|'\n'
comment|"# Don't call the encoder's unregisterProducer because it will write"
nl|'\n'
comment|'# a zero-length chunk.  This would indicate to the server that the'
nl|'\n'
comment|'# request body is complete.  There was an error, though, so we'
nl|'\n'
comment|"# don't want to do that."
nl|'\n'
name|'transport'
op|'.'
name|'unregisterProducer'
op|'('
op|')'
newline|'\n'
name|'return'
name|'err'
newline|'\n'
dedent|''
name|'d'
op|'.'
name|'addCallbacks'
op|'('
name|'cbProduced'
op|','
name|'ebProduced'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_writeToContentLength
dedent|''
name|'def'
name|'_writeToContentLength'
op|'('
name|'self'
op|','
name|'transport'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write this request to the given transport using content-length to frame\n        the body.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_writeHeaders'
op|'('
nl|'\n'
name|'transport'
op|','
nl|'\n'
string|"'Content-Length: %d\\r\\n'"
op|'%'
op|'('
name|'self'
op|'.'
name|'bodyProducer'
op|'.'
name|'length'
op|','
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# This Deferred is used to signal an error in the data written to the'
nl|'\n'
comment|'# encoder below.  It can only errback and it will only do so before too'
nl|'\n'
comment|'# many bytes have been written to the encoder and before the producer'
nl|'\n'
comment|'# Deferred fires.'
nl|'\n'
name|'finishedConsuming'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# This makes sure the producer writes the correct number of bytes for'
nl|'\n'
comment|'# the request body.'
nl|'\n'
name|'encoder'
op|'='
name|'LengthEnforcingConsumer'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'bodyProducer'
op|','
name|'transport'
op|','
name|'finishedConsuming'
op|')'
newline|'\n'
nl|'\n'
name|'transport'
op|'.'
name|'registerProducer'
op|'('
name|'self'
op|'.'
name|'bodyProducer'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
name|'finishedProducing'
op|'='
name|'self'
op|'.'
name|'bodyProducer'
op|'.'
name|'startProducing'
op|'('
name|'encoder'
op|')'
newline|'\n'
nl|'\n'
DECL|function|combine
name|'def'
name|'combine'
op|'('
name|'consuming'
op|','
name|'producing'
op|')'
op|':'
newline|'\n'
comment|'# This Deferred is returned and will be fired when the first of'
nl|'\n'
comment|'# consuming or producing fires.'
nl|'\n'
indent|'            '
name|'ultimate'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Keep track of what has happened so far.  This initially'
nl|'\n'
comment|'# contains None, then an integer uniquely identifying what'
nl|'\n'
comment|'# sequence of events happened.  See the callbacks and errbacks'
nl|'\n'
comment|'# defined below for the meaning of each value.'
nl|'\n'
name|'state'
op|'='
op|'['
name|'None'
op|']'
newline|'\n'
nl|'\n'
DECL|function|ebConsuming
name|'def'
name|'ebConsuming'
op|'('
name|'err'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'state'
op|'=='
op|'['
name|'None'
op|']'
op|':'
newline|'\n'
comment|'# The consuming Deferred failed first.  This means the'
nl|'\n'
comment|'# overall writeTo Deferred is going to errback now.  The'
nl|'\n'
comment|'# producing Deferred should not fire later (because the'
nl|'\n'
comment|'# consumer should have called stopProducing on the'
nl|'\n'
comment|'# producer), but if it does, a callback will be ignored'
nl|'\n'
comment|'# and an errback will be logged.'
nl|'\n'
indent|'                    '
name|'state'
op|'['
number|'0'
op|']'
op|'='
number|'1'
newline|'\n'
name|'ultimate'
op|'.'
name|'errback'
op|'('
name|'err'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# The consuming Deferred errbacked after the producing'
nl|'\n'
comment|"# Deferred fired.  This really shouldn't ever happen."
nl|'\n'
comment|'# If it does, I goofed.  Log the error anyway, just so'
nl|'\n'
comment|"# there's a chance someone might notice and complain."
nl|'\n'
indent|'                    '
name|'log'
op|'.'
name|'err'
op|'('
nl|'\n'
name|'err'
op|','
nl|'\n'
string|'"Buggy state machine in %r/[%d]: "'
nl|'\n'
string|'"ebConsuming called"'
op|'%'
op|'('
name|'self'
op|','
name|'state'
op|'['
number|'0'
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|cbProducing
dedent|''
dedent|''
name|'def'
name|'cbProducing'
op|'('
name|'result'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'state'
op|'=='
op|'['
name|'None'
op|']'
op|':'
newline|'\n'
comment|'# The producing Deferred succeeded first.  Nothing will'
nl|'\n'
comment|'# ever happen to the consuming Deferred.  Tell the'
nl|'\n'
comment|"# encoder we're done so it can check what the producer"
nl|'\n'
comment|'# wrote and make sure it was right.'
nl|'\n'
indent|'                    '
name|'state'
op|'['
number|'0'
op|']'
op|'='
number|'2'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                        '
name|'encoder'
op|'.'
name|'_noMoreWritesExpected'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
comment|'# Fail the overall writeTo Deferred - something the'
nl|'\n'
comment|'# producer did was wrong.'
nl|'\n'
indent|'                        '
name|'ultimate'
op|'.'
name|'errback'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Success - succeed the overall writeTo Deferred.'
nl|'\n'
indent|'                        '
name|'ultimate'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
comment|'# Otherwise, the consuming Deferred already errbacked.  The'
nl|'\n'
comment|"# producing Deferred wasn't supposed to fire, but it did"
nl|'\n'
comment|"# anyway.  It's buggy, but there's not really anything to be"
nl|'\n'
comment|'# done about it.  Just ignore this result.'
nl|'\n'
nl|'\n'
DECL|function|ebProducing
dedent|''
dedent|''
dedent|''
name|'def'
name|'ebProducing'
op|'('
name|'err'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'state'
op|'=='
op|'['
name|'None'
op|']'
op|':'
newline|'\n'
comment|'# The producing Deferred failed first.  This means the'
nl|'\n'
comment|'# overall writeTo Deferred is going to errback now.'
nl|'\n'
comment|"# Tell the encoder that we're done so it knows to reject"
nl|'\n'
comment|'# further writes from the producer (which should not'
nl|'\n'
comment|'# happen, but the producer may be buggy).'
nl|'\n'
indent|'                    '
name|'state'
op|'['
number|'0'
op|']'
op|'='
number|'3'
newline|'\n'
name|'encoder'
op|'.'
name|'_allowNoMoreWrites'
op|'('
op|')'
newline|'\n'
name|'ultimate'
op|'.'
name|'errback'
op|'('
name|'err'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# The producing Deferred failed after the consuming'
nl|'\n'
comment|"# Deferred failed.  It shouldn't have, so it's buggy."
nl|'\n'
comment|'# Log the exception in case anyone who can fix the code'
nl|'\n'
comment|'# is watching.'
nl|'\n'
indent|'                    '
name|'log'
op|'.'
name|'err'
op|'('
name|'err'
op|','
string|'"Producer is buggy"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'consuming'
op|'.'
name|'addErrback'
op|'('
name|'ebConsuming'
op|')'
newline|'\n'
name|'producing'
op|'.'
name|'addCallbacks'
op|'('
name|'cbProducing'
op|','
name|'ebProducing'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'ultimate'
newline|'\n'
nl|'\n'
dedent|''
name|'d'
op|'='
name|'combine'
op|'('
name|'finishedConsuming'
op|','
name|'finishedProducing'
op|')'
newline|'\n'
DECL|function|f
name|'def'
name|'f'
op|'('
name|'passthrough'
op|')'
op|':'
newline|'\n'
comment|'# Regardless of what happens with the overall Deferred, once it'
nl|'\n'
comment|'# fires, the producer registered way up above the definition of'
nl|'\n'
comment|'# combine should be unregistered.'
nl|'\n'
indent|'            '
name|'transport'
op|'.'
name|'unregisterProducer'
op|'('
op|')'
newline|'\n'
name|'return'
name|'passthrough'
newline|'\n'
dedent|''
name|'d'
op|'.'
name|'addBoth'
op|'('
name|'f'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|writeTo
dedent|''
name|'def'
name|'writeTo'
op|'('
name|'self'
op|','
name|'transport'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Format this L{Request} as an HTTP/1.1 request and write it to the given\n        transport.  If bodyProducer is not None, it will be associated with an\n        L{IConsumer}.\n\n        @return: A L{Deferred} which fires with C{None} when the request has\n            been completely written to the transport or with a L{Failure} if\n            there is any problem generating the request bytes.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'bodyProducer'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'bodyProducer'
op|'.'
name|'length'
name|'is'
name|'UNKNOWN_LENGTH'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'self'
op|'.'
name|'_writeToChunked'
op|'('
name|'transport'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'self'
op|'.'
name|'_writeToContentLength'
op|'('
name|'transport'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_writeHeaders'
op|'('
name|'transport'
op|','
name|'None'
op|')'
newline|'\n'
name|'return'
name|'succeed'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|stopWriting
dedent|''
dedent|''
name|'def'
name|'stopWriting'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Stop writing this request to the transport.  This can only be called\n        after C{writeTo} and before the L{Deferred} returned by C{writeTo}\n        fires.  It should cancel any asynchronous task started by C{writeTo}.\n        The L{Deferred} returned by C{writeTo} need not be fired if this method\n        is called.\n        """'
newline|'\n'
comment|'# If bodyProducer is None, then the Deferred returned by writeTo has'
nl|'\n'
comment|'# fired already and this method cannot be called.'
nl|'\n'
name|'_callAppFunction'
op|'('
name|'self'
op|'.'
name|'bodyProducer'
op|'.'
name|'stopProducing'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|LengthEnforcingConsumer
dedent|''
dedent|''
name|'class'
name|'LengthEnforcingConsumer'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    An L{IConsumer} proxy which enforces an exact length requirement on the\n    total data written to it.\n\n    @ivar _length: The number of bytes remaining to be written.\n\n    @ivar _producer: The L{IBodyProducer} which is writing to this\n        consumer.\n\n    @ivar _consumer: The consumer to which at most C{_length} bytes will be\n        forwarded.\n\n    @ivar _finished: A L{Deferred} which will be fired with a L{Failure} if too\n        many bytes are written to this consumer.\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'producer'
op|','
name|'consumer'
op|','
name|'finished'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_length'
op|'='
name|'producer'
op|'.'
name|'length'
newline|'\n'
name|'self'
op|'.'
name|'_producer'
op|'='
name|'producer'
newline|'\n'
name|'self'
op|'.'
name|'_consumer'
op|'='
name|'consumer'
newline|'\n'
name|'self'
op|'.'
name|'_finished'
op|'='
name|'finished'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_allowNoMoreWrites
dedent|''
name|'def'
name|'_allowNoMoreWrites'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Indicate that no additional writes are allowed.  Attempts to write\n        after calling this method will be met with an exception.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_finished'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|write
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'bytes'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write C{bytes} to the underlying consumer unless\n        C{_noMoreWritesExpected} has been called or there are/have been too\n        many bytes.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_finished'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|'# No writes are supposed to happen any more.  Try to convince the'
nl|'\n'
comment|'# calling code to stop calling this method by calling its'
nl|'\n'
comment|'# stopProducing method and then throwing an exception at it.  This'
nl|'\n'
comment|"# exception isn't documented as part of the API because you're"
nl|'\n'
comment|'# never supposed to expect it: only buggy code will ever receive'
nl|'\n'
comment|'# it.'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_producer'
op|'.'
name|'stopProducing'
op|'('
op|')'
newline|'\n'
name|'raise'
name|'ExcessWrite'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'len'
op|'('
name|'bytes'
op|')'
op|'<='
name|'self'
op|'.'
name|'_length'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_length'
op|'-='
name|'len'
op|'('
name|'bytes'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_consumer'
op|'.'
name|'write'
op|'('
name|'bytes'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# No synchronous exception is raised in *this* error path because'
nl|'\n'
comment|'# we still have _finished which we can use to report the error to a'
nl|'\n'
comment|'# better place than the direct caller of this method (some'
nl|'\n'
comment|'# arbitrary application code).'
nl|'\n'
indent|'            '
name|'_callAppFunction'
op|'('
name|'self'
op|'.'
name|'_producer'
op|'.'
name|'stopProducing'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_finished'
op|'.'
name|'errback'
op|'('
name|'WrongBodyLength'
op|'('
string|'"too many bytes written"'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_allowNoMoreWrites'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_noMoreWritesExpected
dedent|''
dedent|''
name|'def'
name|'_noMoreWritesExpected'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called to indicate no more bytes will be written to this consumer.\n        Check to see that the correct number have been written.\n\n        @raise WrongBodyLength: If not enough bytes have been written.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_finished'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_allowNoMoreWrites'
op|'('
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_length'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'WrongBodyLength'
op|'('
string|'"too few bytes written"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|makeStatefulDispatcher
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'makeStatefulDispatcher'
op|'('
name|'name'
op|','
name|'template'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Given a I{dispatch} name and a function, return a function which can be\n    used as a method and which, when called, will call another method defined\n    on the instance and return the result.  The other method which is called is\n    determined by the value of the C{_state} attribute of the instance.\n\n    @param name: A string which is used to construct the name of the subsidiary\n        method to invoke.  The subsidiary method is named like C{\'_%s_%s\' %\n        (name, _state)}.\n\n    @param template: A function object which is used to give the returned\n        function a docstring.\n\n    @return: The dispatcher function.\n    """'
newline|'\n'
DECL|function|dispatcher
name|'def'
name|'dispatcher'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'func'
op|'='
name|'getattr'
op|'('
name|'self'
op|','
string|"'_'"
op|'+'
name|'name'
op|'+'
string|"'_'"
op|'+'
name|'self'
op|'.'
name|'_state'
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'func'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'RuntimeError'
op|'('
nl|'\n'
string|'"%r has no %s method in state %s"'
op|'%'
op|'('
name|'self'
op|','
name|'name'
op|','
name|'self'
op|'.'
name|'_state'
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'func'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
dedent|''
name|'dispatcher'
op|'.'
name|'__doc__'
op|'='
name|'template'
op|'.'
name|'__doc__'
newline|'\n'
name|'return'
name|'dispatcher'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|Response
dedent|''
name|'class'
name|'Response'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A L{Response} instance describes an HTTP response received from an HTTP\n    server.\n\n    L{Response} should not be subclassed or instantiated.\n\n    @ivar version: A three-tuple describing the protocol and protocol version\n        of the response.  The first element is of type C{str}, the second and\n        third are of type C{int}.  For example, C{(\'HTTP\', 1, 1)}.\n    @type version: C{tuple}\n\n    @ivar code: The HTTP status code of this response.\n    @type code: C{int}\n\n    @ivar phrase: The HTTP reason phrase of this response.\n    @type phrase: C{str}\n\n    @ivar headers: The HTTP response headers of this response.\n    @type headers: L{Headers}\n\n    @ivar length: The number of bytes expected to be in the body of this\n        response or L{UNKNOWN_LENGTH} if the server did not indicate how many\n        bytes to expect.  For I{HEAD} responses, this will be 0; if the\n        response includes a I{Content-Length} header, it will be available in\n        C{headers}.\n    @type length: C{int} or something else\n\n    @ivar _transport: The transport which is delivering this response.\n\n    @ivar _bodyProtocol: The L{IProtocol} provider to which the body is\n        delivered.  C{None} before one has been registered with\n        C{deliverBody}.\n\n    @ivar _bodyBuffer: A C{list} of the strings passed to C{bodyDataReceived}\n        before C{deliverBody} is called.  C{None} afterwards.\n\n    @ivar _state: Indicates what state this L{Response} instance is in,\n        particularly with respect to delivering bytes from the response body\n        to an application-suppled protocol object.  This may be one of\n        C{\'INITIAL\'}, C{\'CONNECTED\'}, C{\'DEFERRED_CLOSE\'}, or C{\'FINISHED\'},\n        with the following meanings:\n\n          - INITIAL: This is the state L{Response} objects start in.  No\n            protocol has yet been provided and the underlying transport may\n            still have bytes to deliver to it.\n\n          - DEFERRED_CLOSE: If the underlying transport indicates all bytes\n            have been delivered but no application-provided protocol is yet\n            available, the L{Response} moves to this state.  Data is\n            buffered and waiting for a protocol to be delivered to.\n\n          - CONNECTED: If a protocol is provided when the state is INITIAL,\n            the L{Response} moves to this state.  Any buffered data is\n            delivered and any data which arrives from the transport\n            subsequently is given directly to the protocol.\n\n          - FINISHED: If a protocol is provided in the DEFERRED_CLOSE state,\n            the L{Response} moves to this state after delivering all\n            buffered data to the protocol.  Otherwise, if the L{Response} is\n            in the CONNECTED state, if the transport indicates there is no\n            more data, the L{Response} moves to this state.  Nothing else\n            can happen once the L{Response} is in this state.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|length
name|'length'
op|'='
name|'UNKNOWN_LENGTH'
newline|'\n'
nl|'\n'
DECL|variable|_bodyProtocol
name|'_bodyProtocol'
op|'='
name|'None'
newline|'\n'
DECL|variable|_bodyFinished
name|'_bodyFinished'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'version'
op|','
name|'code'
op|','
name|'phrase'
op|','
name|'headers'
op|','
name|'_transport'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'version'
op|'='
name|'version'
newline|'\n'
name|'self'
op|'.'
name|'code'
op|'='
name|'code'
newline|'\n'
name|'self'
op|'.'
name|'phrase'
op|'='
name|'phrase'
newline|'\n'
name|'self'
op|'.'
name|'headers'
op|'='
name|'headers'
newline|'\n'
name|'self'
op|'.'
name|'_transport'
op|'='
name|'_transport'
newline|'\n'
name|'self'
op|'.'
name|'_bodyBuffer'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_state'
op|'='
string|"'INITIAL'"
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|deliverBody
dedent|''
name|'def'
name|'deliverBody'
op|'('
name|'self'
op|','
name|'protocol'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Register an L{IProtocol} provider to receive the response body.\n\n        The protocol will be connected to a transport which provides\n        L{IPushProducer}.  The protocol\'s C{connectionLost} method will be\n        called with:\n\n            - ResponseDone, which indicates that all bytes from the response\n              have been successfully delivered.\n\n            - PotentialDataLoss, which indicates that it cannot be determined\n              if the entire response body has been delivered.  This only occurs\n              when making requests to HTTP servers which do not set\n              I{Content-Length} or a I{Transfer-Encoding} in the response.\n\n            - ResponseFailed, which indicates that some bytes from the response\n              were lost.  The C{reasons} attribute of the exception may provide\n              more specific indications as to why.\n        """'
newline|'\n'
DECL|variable|deliverBody
dedent|''
name|'deliverBody'
op|'='
name|'makeStatefulDispatcher'
op|'('
string|"'deliverBody'"
op|','
name|'deliverBody'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_deliverBody_INITIAL
name|'def'
name|'_deliverBody_INITIAL'
op|'('
name|'self'
op|','
name|'protocol'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Deliver any buffered data to C{protocol} and prepare to deliver any\n        future data to it.  Move to the C{\'CONNECTED\'} state.\n        """'
newline|'\n'
comment|"# Now that there's a protocol to consume the body, resume the"
nl|'\n'
comment|'# transport.  It was previously paused by HTTPClientParser to avoid'
nl|'\n'
comment|'# reading too much data before it could be handled.'
nl|'\n'
name|'self'
op|'.'
name|'_transport'
op|'.'
name|'resumeProducing'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'self'
op|'.'
name|'_transport'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_bodyProtocol'
op|'='
name|'protocol'
newline|'\n'
name|'for'
name|'data'
name|'in'
name|'self'
op|'.'
name|'_bodyBuffer'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_bodyProtocol'
op|'.'
name|'dataReceived'
op|'('
name|'data'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_bodyBuffer'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_state'
op|'='
string|"'CONNECTED'"
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_deliverBody_CONNECTED
dedent|''
name|'def'
name|'_deliverBody_CONNECTED'
op|'('
name|'self'
op|','
name|'protocol'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        It is invalid to attempt to deliver data to a protocol when it is\n        already being delivered to another protocol.\n        """'
newline|'\n'
name|'raise'
name|'RuntimeError'
op|'('
nl|'\n'
string|'"Response already has protocol %r, cannot deliverBody "'
nl|'\n'
string|'"again"'
op|'%'
op|'('
name|'self'
op|'.'
name|'_bodyProtocol'
op|','
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_deliverBody_DEFERRED_CLOSE
dedent|''
name|'def'
name|'_deliverBody_DEFERRED_CLOSE'
op|'('
name|'self'
op|','
name|'protocol'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Deliver any buffered data to C{protocol} and then disconnect the\n        protocol.  Move to the C{\'FINISHED\'} state.\n        """'
newline|'\n'
comment|'# Unlike _deliverBody_INITIAL, there is no need to resume the'
nl|'\n'
comment|'# transport here because all of the response data has been received'
nl|'\n'
comment|'# already.  Some higher level code may want to resume the transport if'
nl|'\n'
comment|'# that code expects further data to be received over it.'
nl|'\n'
nl|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'self'
op|'.'
name|'_transport'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'data'
name|'in'
name|'self'
op|'.'
name|'_bodyBuffer'
op|':'
newline|'\n'
indent|'            '
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
name|'data'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_bodyBuffer'
op|'='
name|'None'
newline|'\n'
name|'protocol'
op|'.'
name|'connectionLost'
op|'('
name|'self'
op|'.'
name|'_reason'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_state'
op|'='
string|"'FINISHED'"
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_deliverBody_FINISHED
dedent|''
name|'def'
name|'_deliverBody_FINISHED'
op|'('
name|'self'
op|','
name|'protocol'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        It is invalid to attempt to deliver data to a protocol after the\n        response body has been delivered to another protocol.\n        """'
newline|'\n'
name|'raise'
name|'RuntimeError'
op|'('
nl|'\n'
string|'"Response already finished, cannot deliverBody now."'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_bodyDataReceived
dedent|''
name|'def'
name|'_bodyDataReceived'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called by HTTPClientParser with chunks of data from the response body.\n        They will be buffered or delivered to the protocol passed to\n        deliverBody.\n        """'
newline|'\n'
DECL|variable|_bodyDataReceived
dedent|''
name|'_bodyDataReceived'
op|'='
name|'makeStatefulDispatcher'
op|'('
string|"'bodyDataReceived'"
op|','
nl|'\n'
name|'_bodyDataReceived'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_bodyDataReceived_INITIAL
name|'def'
name|'_bodyDataReceived_INITIAL'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Buffer any data received for later delivery to a protocol passed to\n        C{deliverBody}.\n\n        Little or no data should be buffered by this method, since the\n        transport has been paused and will not be resumed until a protocol\n        is supplied.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_bodyBuffer'
op|'.'
name|'append'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_bodyDataReceived_CONNECTED
dedent|''
name|'def'
name|'_bodyDataReceived_CONNECTED'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Deliver any data received to the protocol to which this L{Response}\n        is connected.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_bodyProtocol'
op|'.'
name|'dataReceived'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_bodyDataReceived_DEFERRED_CLOSE
dedent|''
name|'def'
name|'_bodyDataReceived_DEFERRED_CLOSE'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        It is invalid for data to be delivered after it has been indicated\n        that the response body has been completely delivered.\n        """'
newline|'\n'
name|'raise'
name|'RuntimeError'
op|'('
string|'"Cannot receive body data after _bodyDataFinished"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_bodyDataReceived_FINISHED
dedent|''
name|'def'
name|'_bodyDataReceived_FINISHED'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        It is invalid for data to be delivered after the response bofdy has\n        been delivered to a protocol.\n        """'
newline|'\n'
name|'raise'
name|'RuntimeError'
op|'('
string|'"Cannot receive body data after protocol disconnected"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_bodyDataFinished
dedent|''
name|'def'
name|'_bodyDataFinished'
op|'('
name|'self'
op|','
name|'reason'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called by HTTPClientParser when no more body data is available.  If the\n        optional reason is supplied, this indicates a problem or potential\n        problem receiving all of the response body.\n        """'
newline|'\n'
DECL|variable|_bodyDataFinished
dedent|''
name|'_bodyDataFinished'
op|'='
name|'makeStatefulDispatcher'
op|'('
string|"'bodyDataFinished'"
op|','
nl|'\n'
name|'_bodyDataFinished'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_bodyDataFinished_INITIAL
name|'def'
name|'_bodyDataFinished_INITIAL'
op|'('
name|'self'
op|','
name|'reason'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Move to the C{\'DEFERRED_CLOSE\'} state to wait for a protocol to\n        which to deliver the response body.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_state'
op|'='
string|"'DEFERRED_CLOSE'"
newline|'\n'
name|'if'
name|'reason'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
name|'Failure'
op|'('
name|'ResponseDone'
op|'('
string|'"Response body fully received"'
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_reason'
op|'='
name|'reason'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_bodyDataFinished_CONNECTED
dedent|''
name|'def'
name|'_bodyDataFinished_CONNECTED'
op|'('
name|'self'
op|','
name|'reason'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Disconnect the protocol and move to the C{\'FINISHED\'} state.\n        """'
newline|'\n'
name|'if'
name|'reason'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
name|'Failure'
op|'('
name|'ResponseDone'
op|'('
string|'"Response body fully received"'
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_bodyProtocol'
op|'.'
name|'connectionLost'
op|'('
name|'reason'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_bodyProtocol'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_state'
op|'='
string|"'FINISHED'"
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_bodyDataFinished_DEFERRED_CLOSE
dedent|''
name|'def'
name|'_bodyDataFinished_DEFERRED_CLOSE'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        It is invalid to attempt to notify the L{Response} of the end of the\n        response body data more than once.\n        """'
newline|'\n'
name|'raise'
name|'RuntimeError'
op|'('
string|'"Cannot finish body data more than once"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_bodyDataFinished_FINISHED
dedent|''
name|'def'
name|'_bodyDataFinished_FINISHED'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        It is invalid to attempt to notify the L{Response} of the end of the\n        response body data more than once.\n        """'
newline|'\n'
name|'raise'
name|'RuntimeError'
op|'('
string|'"Cannot finish body data after protocol disconnected"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ChunkedEncoder
dedent|''
dedent|''
name|'class'
name|'ChunkedEncoder'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Helper object which exposes L{IConsumer} on top of L{HTTP11ClientProtocol}\n    for streaming request bodies to the server.\n    """'
newline|'\n'
name|'implements'
op|'('
name|'IConsumer'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'transport'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'transport'
op|'='
name|'transport'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_allowNoMoreWrites
dedent|''
name|'def'
name|'_allowNoMoreWrites'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Indicate that no additional writes are allowed.  Attempts to write\n        after calling this method will be met with an exception.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|registerProducer
dedent|''
name|'def'
name|'registerProducer'
op|'('
name|'self'
op|','
name|'producer'
op|','
name|'streaming'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Register the given producer with C{self.transport}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'registerProducer'
op|'('
name|'producer'
op|','
name|'streaming'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|write
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write the given request body bytes to the transport using chunked\n        encoding.\n\n        @type data: C{str}\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'transport'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ExcessWrite'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'transport'
op|'.'
name|'writeSequence'
op|'('
op|'('
string|'"%x\\r\\n"'
op|'%'
name|'len'
op|'('
name|'data'
op|')'
op|','
name|'data'
op|','
string|'"\\r\\n"'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|unregisterProducer
dedent|''
name|'def'
name|'unregisterProducer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Indicate that the request body is complete and finish the request.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'write'
op|'('
string|"''"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'unregisterProducer'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_allowNoMoreWrites'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TransportProxyProducer
dedent|''
dedent|''
name|'class'
name|'TransportProxyProducer'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    An L{IPushProducer} implementation which wraps another such thing and\n    proxies calls to it until it is told to stop.\n\n    @ivar _producer: The wrapped L{IPushProducer} provider or C{None} after\n        this proxy has been stopped.\n    """'
newline|'\n'
name|'implements'
op|'('
name|'IPushProducer'
op|')'
newline|'\n'
nl|'\n'
comment|'# LineReceiver uses this undocumented attribute of transports to decide'
nl|'\n'
comment|'# when to stop calling lineReceived or rawDataReceived (if it finds it to'
nl|'\n'
comment|"# be true, it doesn't bother to deliver any more data).  Set disconnecting"
nl|'\n'
comment|'# to False here and never change it to true so that all data is always'
nl|'\n'
comment|"# delivered to us and so that LineReceiver doesn't fail with an"
nl|'\n'
comment|'# AttributeError.'
nl|'\n'
DECL|variable|disconnecting
name|'disconnecting'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'producer'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_producer'
op|'='
name|'producer'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_stopProxying
dedent|''
name|'def'
name|'_stopProxying'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Stop forwarding calls of L{IPushProducer} methods to the underlying\n        L{IPushProvider} provider.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_producer'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|stopProducing
dedent|''
name|'def'
name|'stopProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Proxy the stoppage to the underlying producer, unless this proxy has\n        been stopped.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_producer'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_producer'
op|'.'
name|'stopProducing'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|resumeProducing
dedent|''
dedent|''
name|'def'
name|'resumeProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Proxy the resumption to the underlying producer, unless this proxy has\n        been stopped.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_producer'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_producer'
op|'.'
name|'resumeProducing'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|pauseProducing
dedent|''
dedent|''
name|'def'
name|'pauseProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Proxy the pause to the underlying producer, unless this proxy has been\n        stopped.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_producer'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_producer'
op|'.'
name|'pauseProducing'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|HTTP11ClientProtocol
dedent|''
dedent|''
dedent|''
name|'class'
name|'HTTP11ClientProtocol'
op|'('
name|'Protocol'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    L{HTTP11ClientProtocol} is an implementation of the HTTP 1.1 client\n    protocol.  It supports as few features as possible.\n\n    @ivar _parser: After a request is issued, the L{HTTPClientParser} to\n        which received data making up the response to that request is\n        delivered.\n\n    @ivar _finishedRequest: After a request is issued, the L{Deferred} which\n        will fire when a L{Response} object corresponding to that request is\n        available.  This allows L{HTTP11ClientProtocol} to fail the request\n        if there is a connection or parsing problem.\n\n    @ivar _currentRequest: After a request is issued, the L{Request}\n        instance used to make that request.  This allows\n        L{HTTP11ClientProtocol} to stop request generation if necessary (for\n        example, if the connection is lost).\n\n    @ivar _transportProxy: After a request is issued, the\n        L{TransportProxyProducer} to which C{_parser} is connected.  This\n        allows C{_parser} to pause and resume the transport in a way which\n        L{HTTP11ClientProtocol} can exert some control over.\n\n    @ivar _responseDeferred: After a request is issued, the L{Deferred} from\n        C{_parser} which will fire with a L{Response} when one has been\n        received.  This is eventually chained with C{_finishedRequest}, but\n        only in certain cases to avoid double firing that Deferred.\n\n    @ivar _state: Indicates what state this L{HTTP11ClientProtocol} instance\n        is in with respect to transmission of a request and reception of a\n        response.  This may be one of C{\'QUIESCENT\'}, C{\'TRANSMITTING\'},\n        C{\'TRANSMITTING_AFTER_RECEIVING_RESPONSE\'}, C{\'GENERATION_FAILED\'},\n        C{\'WAITING\'}, or C{\'CONNECTION_LOST\'}, with the following meanings:\n\n          - QUIESCENT: This is the state L{HTTP11ClientProtocol} instances\n            start in.  Nothing is happening: no request is being sent and no\n            response is being received or expected.\n\n          - TRANSMITTING: When a request is made (via L{request}), the\n            instance moves to this state.  L{Request.writeTo} has been used\n            to start to send a request but it has not yet finished.\n\n          - TRANSMITTING_AFTER_RECEIVING_RESPONSE: The server has returned a\n            complete response but the request has not yet been fully sent\n            yet.  The instance will remain in this state until the request\n            is fully sent.\n\n          - GENERATION_FAILED: There was an error while the request.  The\n            request was not fully sent to the network.\n\n          - WAITING: The request was fully sent to the network.  The\n            instance is now waiting for the response to be fully received.\n\n          - CONNECTION_LOST: The connection has been lost.\n    """'
newline|'\n'
DECL|variable|_state
name|'_state'
op|'='
string|"'QUIESCENT'"
newline|'\n'
DECL|variable|_parser
name|'_parser'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|request
name|'def'
name|'request'
op|'('
name|'self'
op|','
name|'request'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Issue C{request} over C{self.transport} and return a L{Deferred} which\n        will fire with a L{Response} instance or an error.\n\n        @param request: The object defining the parameters of the request to\n           issue.\n        @type request: L{Request}\n\n        @rtype: L{Deferred}\n        @return: The deferred may errback with L{RequestGenerationFailed} if\n            the request was not fully written to the transport due to a local\n            error.  It may errback with L{RequestTransmissionFailed} if it was\n            not fully written to the transport due to a network error.  It may\n            errback with L{ResponseFailed} if the request was sent (not\n            necessarily received) but some or all of the response was lost.  It\n            may errback with L{RequestNotSent} if it is not possible to send\n            any more requests using this L{HTTP11ClientProtocol}.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_state'
op|'!='
string|"'QUIESCENT'"
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'fail'
op|'('
name|'RequestNotSent'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_state'
op|'='
string|"'TRANSMITTING'"
newline|'\n'
name|'_requestDeferred'
op|'='
name|'maybeDeferred'
op|'('
name|'request'
op|'.'
name|'writeTo'
op|','
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_finishedRequest'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Keep track of the Request object in case we need to call stopWriting'
nl|'\n'
comment|'# on it.'
nl|'\n'
name|'self'
op|'.'
name|'_currentRequest'
op|'='
name|'request'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_transportProxy'
op|'='
name|'TransportProxyProducer'
op|'('
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_parser'
op|'='
name|'HTTPClientParser'
op|'('
name|'request'
op|','
name|'self'
op|'.'
name|'_finishResponse'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_parser'
op|'.'
name|'makeConnection'
op|'('
name|'self'
op|'.'
name|'_transportProxy'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_responseDeferred'
op|'='
name|'self'
op|'.'
name|'_parser'
op|'.'
name|'_responseDeferred'
newline|'\n'
nl|'\n'
DECL|function|cbRequestWrotten
name|'def'
name|'cbRequestWrotten'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'_state'
op|'=='
string|"'TRANSMITTING'"
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_state'
op|'='
string|"'WAITING'"
newline|'\n'
comment|"# XXX We're stuck in WAITING until we lose the connection now."
nl|'\n'
comment|'# This will be wrong when persistent connections are supported.'
nl|'\n'
comment|'# See #3420 for persistent connections.'
nl|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_responseDeferred'
op|'.'
name|'chainDeferred'
op|'('
name|'self'
op|'.'
name|'_finishedRequest'
op|')'
newline|'\n'
nl|'\n'
DECL|function|ebRequestWriting
dedent|''
dedent|''
name|'def'
name|'ebRequestWriting'
op|'('
name|'err'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'_state'
op|'=='
string|"'TRANSMITTING'"
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_state'
op|'='
string|"'GENERATION_FAILED'"
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_finishedRequest'
op|'.'
name|'errback'
op|'('
nl|'\n'
name|'Failure'
op|'('
name|'RequestGenerationFailed'
op|'('
op|'['
name|'err'
op|']'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'log'
op|'.'
name|'err'
op|'('
name|'err'
op|','
string|'"foo"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'_requestDeferred'
op|'.'
name|'addCallbacks'
op|'('
name|'cbRequestWrotten'
op|','
name|'ebRequestWriting'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'_finishedRequest'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_finishResponse
dedent|''
name|'def'
name|'_finishResponse'
op|'('
name|'self'
op|','
name|'rest'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called by an L{HTTPClientParser} to indicate that it has parsed a\n        complete response.\n\n        @param rest: A C{str} giving any trailing bytes which were given to\n            the L{HTTPClientParser} which were not part of the response it\n            was parsing.\n        """'
newline|'\n'
comment|'# XXX this is because Connection: close is hard-coded above, probably'
nl|'\n'
comment|'# will want to change that at some point.  Either the client or the'
nl|'\n'
comment|'# server can control this.'
nl|'\n'
nl|'\n'
comment|"# XXX If the connection isn't being closed at this point, it's"
nl|'\n'
comment|"# important to make sure the transport isn't paused (after _giveUp,"
nl|'\n'
comment|'# or inside it, or something - after the parser can no longer touch'
nl|'\n'
comment|'# the transport)'
nl|'\n'
nl|'\n'
comment|'# For both of the above, see #3420 for persistent connections.'
nl|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_state'
op|'=='
string|"'TRANSMITTING'"
op|':'
newline|'\n'
comment|'# The server sent the entire response before we could send the'
nl|'\n'
comment|'# whole request.  That sucks.  Oh well.  Fire the request()'
nl|'\n'
comment|'# Deferred with the response.  But first, make sure that if the'
nl|'\n'
comment|"# request does ever finish being written that it won't try to fire"
nl|'\n'
comment|'# that Deferred.'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_state'
op|'='
string|"'TRANSMITTING_AFTER_RECEIVING_RESPONSE'"
newline|'\n'
name|'self'
op|'.'
name|'_responseDeferred'
op|'.'
name|'chainDeferred'
op|'('
name|'self'
op|'.'
name|'_finishedRequest'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_giveUp'
op|'('
name|'Failure'
op|'('
name|'ConnectionDone'
op|'('
string|'"synthetic!"'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_disconnectParser
dedent|''
name|'def'
name|'_disconnectParser'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If there is still a parser, call its C{connectionLost} method with the\n        given reason.  If there is not, do nothing.\n\n        @type reason: L{Failure}\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_parser'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'parser'
op|'='
name|'self'
op|'.'
name|'_parser'
newline|'\n'
name|'self'
op|'.'
name|'_parser'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# The parser is no longer allowed to do anything to the real'
nl|'\n'
comment|"# transport.  Stop proxying from the parser's transport to the real"
nl|'\n'
comment|"# transport before telling the parser it's done so that it can't do"
nl|'\n'
comment|'# anything.'
nl|'\n'
name|'self'
op|'.'
name|'_transportProxy'
op|'.'
name|'_stopProxying'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'parser'
op|'.'
name|'connectionLost'
op|'('
name|'reason'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_giveUp
dedent|''
dedent|''
name|'def'
name|'_giveUp'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Lose the underlying connection and disconnect the parser with the given\n        L{Failure}.\n\n        Use this method instead of calling the transport\'s loseConnection\n        method directly otherwise random things will break.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_disconnectParser'
op|'('
name|'reason'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|dataReceived
dedent|''
name|'def'
name|'dataReceived'
op|'('
name|'self'
op|','
name|'bytes'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Handle some stuff from some place.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_parser'
op|'.'
name|'dataReceived'
op|'('
name|'bytes'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_giveUp'
op|'('
name|'Failure'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionLost
dedent|''
dedent|''
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The underlying transport went away.  If appropriate, notify the parser\n        object.\n        """'
newline|'\n'
DECL|variable|connectionLost
dedent|''
name|'connectionLost'
op|'='
name|'makeStatefulDispatcher'
op|'('
string|"'connectionLost'"
op|','
name|'connectionLost'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_connectionLost_QUIESCENT
name|'def'
name|'_connectionLost_QUIESCENT'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Nothing is currently happening.  Move to the C{\'CONNECTION_LOST\'}\n        state but otherwise do nothing.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_state'
op|'='
string|"'CONNECTION_LOST'"
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_connectionLost_GENERATION_FAILED
dedent|''
name|'def'
name|'_connectionLost_GENERATION_FAILED'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The connection was in an inconsistent state.  Move to the\n        C{\'CONNECTION_LOST\'} state but otherwise do nothing.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_state'
op|'='
string|"'CONNECTION_LOST'"
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_connectionLost_TRANSMITTING
dedent|''
name|'def'
name|'_connectionLost_TRANSMITTING'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Fail the L{Deferred} for the current request, notify the request\n        object that it does not need to continue transmitting itself, and\n        move to the C{\'CONNECTION_LOST\'} state.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_state'
op|'='
string|"'CONNECTION_LOST'"
newline|'\n'
name|'self'
op|'.'
name|'_finishedRequest'
op|'.'
name|'errback'
op|'('
nl|'\n'
name|'Failure'
op|'('
name|'RequestTransmissionFailed'
op|'('
op|'['
name|'reason'
op|']'
op|')'
op|')'
op|')'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'_finishedRequest'
newline|'\n'
nl|'\n'
comment|'# Tell the request that it should stop bothering now.'
nl|'\n'
name|'self'
op|'.'
name|'_currentRequest'
op|'.'
name|'stopWriting'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_connectionLost_WAITING
dedent|''
name|'def'
name|'_connectionLost_WAITING'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Disconnect the response parser so that it can propagate the event as\n        necessary (for example, to call an application protocol\'s\n        C{connectionLost} method, or to fail a request L{Deferred}) and move\n        to the C{\'CONNECTION_LOST\'} state.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_disconnectParser'
op|'('
name|'reason'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_state'
op|'='
string|"'CONNECTION_LOST'"
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
