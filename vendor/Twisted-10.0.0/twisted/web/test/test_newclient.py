begin_unit
comment|'# Copyright (c) 2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTests for L{twisted.web._newclient}.\n"""'
newline|'\n'
nl|'\n'
DECL|variable|__metaclass__
name|'__metaclass__'
op|'='
name|'type'
newline|'\n'
nl|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'implements'
newline|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
op|'.'
name|'verify'
name|'import'
name|'verifyObject'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'failure'
name|'import'
name|'Failure'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'interfaces'
name|'import'
name|'IConsumer'
op|','
name|'IPushProducer'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'error'
name|'import'
name|'ConnectionDone'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'defer'
name|'import'
name|'Deferred'
op|','
name|'succeed'
op|','
name|'fail'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'protocol'
name|'import'
name|'Protocol'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
op|'.'
name|'unittest'
name|'import'
name|'TestCase'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'test'
op|'.'
name|'proto_helpers'
name|'import'
name|'StringTransport'
op|','
name|'AccumulatingProtocol'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
op|'.'
name|'_newclient'
name|'import'
name|'UNKNOWN_LENGTH'
op|','
name|'STATUS'
op|','
name|'HEADER'
op|','
name|'BODY'
op|','
name|'DONE'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
op|'.'
name|'_newclient'
name|'import'
name|'Request'
op|','
name|'Response'
op|','
name|'HTTPParser'
op|','
name|'HTTPClientParser'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
op|'.'
name|'_newclient'
name|'import'
name|'BadResponseVersion'
op|','
name|'ParseError'
op|','
name|'HTTP11ClientProtocol'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
op|'.'
name|'_newclient'
name|'import'
name|'ChunkedEncoder'
op|','
name|'RequestGenerationFailed'
op|','
name|'RequestTransmissionFailed'
op|','
name|'ResponseFailed'
op|','
name|'WrongBodyLength'
op|','
name|'RequestNotSent'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
op|'.'
name|'_newclient'
name|'import'
name|'BadHeaders'
op|','
name|'ResponseDone'
op|','
name|'PotentialDataLoss'
op|','
name|'ExcessWrite'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
op|'.'
name|'_newclient'
name|'import'
name|'TransportProxyProducer'
op|','
name|'LengthEnforcingConsumer'
op|','
name|'makeStatefulDispatcher'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
op|'.'
name|'http_headers'
name|'import'
name|'Headers'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
op|'.'
name|'http'
name|'import'
name|'_DataLoss'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
op|'.'
name|'iweb'
name|'import'
name|'IBodyProducer'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ArbitraryException
name|'class'
name|'ArbitraryException'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A unique, arbitrary exception type which L{twisted.web._newclient} knows\n    nothing about.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|AnotherArbitraryException
dedent|''
name|'class'
name|'AnotherArbitraryException'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Similar to L{ArbitraryException} but with a different identity.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
comment|"# A re-usable Headers instance for tests which don't really care what headers"
nl|'\n'
comment|"# they're sending."
nl|'\n'
DECL|variable|_boringHeaders
dedent|''
name|'_boringHeaders'
op|'='
name|'Headers'
op|'('
op|'{'
string|"'host'"
op|':'
op|'['
string|"'example.com'"
op|']'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|assertWrapperExceptionTypes
name|'def'
name|'assertWrapperExceptionTypes'
op|'('
name|'self'
op|','
name|'deferred'
op|','
name|'mainType'
op|','
name|'reasonTypes'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Assert that the given L{Deferred} fails with the exception given by\n    C{mainType} and that the exceptions wrapped by the instance of C{mainType}\n    it fails with match the list of exception types given by C{reasonTypes}.\n\n    This is a helper for testing failures of exceptions which subclass\n    L{_newclient._WrapperException}.\n\n    @param self: A L{TestCase} instance which will be used to make the\n        assertions.\n\n    @param deferred: The L{Deferred} which is expected to fail with\n        C{mainType}.\n\n    @param mainType: A L{_newclient._WrapperException} subclass which will be\n        trapped on C{deferred}.\n\n    @param reasonTypes: A sequence of exception types which will be trapped on\n        the resulting L{mainType} exception instance\'s C{reasons} sequence.\n\n    @return: A L{Deferred} which fires with the C{mainType} instance\n        C{deferred} fails with, or which fails somehow.\n    """'
newline|'\n'
DECL|function|cbFailed
name|'def'
name|'cbFailed'
op|'('
name|'err'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'reason'
op|','
name|'type'
name|'in'
name|'zip'
op|'('
name|'err'
op|'.'
name|'reasons'
op|','
name|'reasonTypes'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'.'
name|'trap'
op|'('
name|'type'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'len'
op|'('
name|'err'
op|'.'
name|'reasons'
op|')'
op|','
name|'len'
op|'('
name|'reasonTypes'
op|')'
op|')'
newline|'\n'
name|'return'
name|'err'
newline|'\n'
dedent|''
name|'d'
op|'='
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'deferred'
op|','
name|'mainType'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'cbFailed'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|assertResponseFailed
dedent|''
name|'def'
name|'assertResponseFailed'
op|'('
name|'self'
op|','
name|'deferred'
op|','
name|'reasonTypes'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A simple helper to invoke L{assertWrapperExceptionTypes} with a C{mainType}\n    of L{ResponseFailed}.\n    """'
newline|'\n'
name|'return'
name|'assertWrapperExceptionTypes'
op|'('
name|'self'
op|','
name|'deferred'
op|','
name|'ResponseFailed'
op|','
name|'reasonTypes'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|assertRequestGenerationFailed
dedent|''
name|'def'
name|'assertRequestGenerationFailed'
op|'('
name|'self'
op|','
name|'deferred'
op|','
name|'reasonTypes'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A simple helper to invoke L{assertWrapperExceptionTypes} with a C{mainType}\n    of L{RequestGenerationFailed}.\n    """'
newline|'\n'
name|'return'
name|'assertWrapperExceptionTypes'
op|'('
name|'self'
op|','
name|'deferred'
op|','
name|'RequestGenerationFailed'
op|','
name|'reasonTypes'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|assertRequestTransmissionFailed
dedent|''
name|'def'
name|'assertRequestTransmissionFailed'
op|'('
name|'self'
op|','
name|'deferred'
op|','
name|'reasonTypes'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A simple helper to invoke L{assertWrapperExceptionTypes} with a C{mainType}\n    of L{RequestTransmissionFailed}.\n    """'
newline|'\n'
name|'return'
name|'assertWrapperExceptionTypes'
op|'('
name|'self'
op|','
name|'deferred'
op|','
name|'RequestTransmissionFailed'
op|','
name|'reasonTypes'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|justTransportResponse
dedent|''
name|'def'
name|'justTransportResponse'
op|'('
name|'transport'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Helper function for creating a Response which uses the given transport.\n    All of the other parameters to L{Response.__init__} are filled with\n    arbitrary values.  Only use this method if you don\'t care about any of\n    them.\n    """'
newline|'\n'
name|'return'
name|'Response'
op|'('
op|'('
string|"'HTTP'"
op|','
number|'1'
op|','
number|'1'
op|')'
op|','
number|'200'
op|','
string|"'OK'"
op|','
name|'_boringHeaders'
op|','
name|'transport'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|MakeStatefulDispatcherTests
dedent|''
name|'class'
name|'MakeStatefulDispatcherTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{makeStatefulDispatcher}.\n    """'
newline|'\n'
DECL|member|test_functionCalledByState
name|'def'
name|'test_functionCalledByState'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A method defined with L{makeStatefulDispatcher} invokes a second\n        method based on the current state of the object.\n        """'
newline|'\n'
DECL|class|Foo
name|'class'
name|'Foo'
op|':'
newline|'\n'
DECL|variable|_state
indent|'            '
name|'_state'
op|'='
string|"'A'"
newline|'\n'
nl|'\n'
DECL|member|bar
name|'def'
name|'bar'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
DECL|variable|bar
dedent|''
name|'bar'
op|'='
name|'makeStatefulDispatcher'
op|'('
string|"'quux'"
op|','
name|'bar'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_quux_A
name|'def'
name|'_quux_A'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
string|"'a'"
newline|'\n'
nl|'\n'
DECL|member|_quux_B
dedent|''
name|'def'
name|'_quux_B'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
string|"'b'"
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'stateful'
op|'='
name|'Foo'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'stateful'
op|'.'
name|'bar'
op|'('
op|')'
op|','
string|"'a'"
op|')'
newline|'\n'
name|'stateful'
op|'.'
name|'_state'
op|'='
string|"'B'"
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'stateful'
op|'.'
name|'bar'
op|'('
op|')'
op|','
string|"'b'"
op|')'
newline|'\n'
name|'stateful'
op|'.'
name|'_state'
op|'='
string|"'C'"
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'RuntimeError'
op|','
name|'stateful'
op|'.'
name|'bar'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|HTTPParserTests
dedent|''
dedent|''
name|'class'
name|'HTTPParserTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{HTTPParser} which is responsible for the bulk of the task of\n    parsing HTTP bytes.\n    """'
newline|'\n'
DECL|member|test_statusCallback
name|'def'
name|'test_statusCallback'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{HTTPParser} calls its C{statusReceived} method when it receives a\n        status line.\n        """'
newline|'\n'
name|'status'
op|'='
op|'['
op|']'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPParser'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'statusReceived'
op|'='
name|'status'
op|'.'
name|'append'
newline|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'state'
op|','
name|'STATUS'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'HTTP/1.1 200 OK\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'status'
op|','
op|'['
string|"'HTTP/1.1 200 OK'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'state'
op|','
name|'HEADER'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_headerTestSetup
dedent|''
name|'def'
name|'_headerTestSetup'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'header'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPParser'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'headerReceived'
op|'='
name|'header'
op|'.'
name|'__setitem__'
newline|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'HTTP/1.1 200 OK\\r\\n'"
op|')'
newline|'\n'
name|'return'
name|'header'
op|','
name|'protocol'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_headerCallback
dedent|''
name|'def'
name|'test_headerCallback'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{HTTPParser} calls its C{headerReceived} method when it receives a\n        header.\n        """'
newline|'\n'
name|'header'
op|','
name|'protocol'
op|'='
name|'self'
op|'.'
name|'_headerTestSetup'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'X-Foo:bar\\r\\n'"
op|')'
newline|'\n'
comment|"# Cannot tell it's not a continue header until the next line arrives"
nl|'\n'
comment|'# and is not a continuation'
nl|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'header'
op|','
op|'{'
string|"'X-Foo'"
op|':'
string|"'bar'"
op|'}'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'state'
op|','
name|'BODY'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_continuedHeaderCallback
dedent|''
name|'def'
name|'test_continuedHeaderCallback'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a header is split over multiple lines, L{HTTPParser} calls\n        C{headerReceived} with the entire value once it is received.\n        """'
newline|'\n'
name|'header'
op|','
name|'protocol'
op|'='
name|'self'
op|'.'
name|'_headerTestSetup'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'X-Foo: bar\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"' baz\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'\\tquux\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'header'
op|','
op|'{'
string|"'X-Foo'"
op|':'
string|"'bar baz\\tquux'"
op|'}'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'state'
op|','
name|'BODY'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_fieldContentWhitespace
dedent|''
name|'def'
name|'test_fieldContentWhitespace'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Leading and trailing linear whitespace is stripped from the header\n        value passed to the C{headerReceived} callback.\n        """'
newline|'\n'
name|'header'
op|','
name|'protocol'
op|'='
name|'self'
op|'.'
name|'_headerTestSetup'
op|'('
op|')'
newline|'\n'
name|'value'
op|'='
string|"' \\t \\r\\n bar \\t\\r\\n \\t\\r\\n'"
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'X-Bar:'"
op|'+'
name|'value'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'X-Foo:'"
op|'+'
name|'value'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'header'
op|','
op|'{'
string|"'X-Foo'"
op|':'
string|"'bar'"
op|','
nl|'\n'
string|"'X-Bar'"
op|':'
string|"'bar'"
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_allHeadersCallback
dedent|''
name|'def'
name|'test_allHeadersCallback'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        After the last header is received, L{HTTPParser} calls\n        C{allHeadersReceived}.\n        """'
newline|'\n'
name|'called'
op|'='
op|'['
op|']'
newline|'\n'
name|'header'
op|','
name|'protocol'
op|'='
name|'self'
op|'.'
name|'_headerTestSetup'
op|'('
op|')'
newline|'\n'
DECL|function|allHeadersReceived
name|'def'
name|'allHeadersReceived'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'called'
op|'.'
name|'append'
op|'('
name|'protocol'
op|'.'
name|'state'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'state'
op|'='
name|'STATUS'
newline|'\n'
dedent|''
name|'protocol'
op|'.'
name|'allHeadersReceived'
op|'='
name|'allHeadersReceived'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'called'
op|','
op|'['
name|'HEADER'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'state'
op|','
name|'STATUS'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_noHeaderCallback
dedent|''
name|'def'
name|'test_noHeaderCallback'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If there are no headers in the message, L{HTTPParser} does not call\n        C{headerReceived}.\n        """'
newline|'\n'
name|'header'
op|','
name|'protocol'
op|'='
name|'self'
op|'.'
name|'_headerTestSetup'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'header'
op|','
op|'{'
op|'}'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'state'
op|','
name|'BODY'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_headersSavedOnResponse
dedent|''
name|'def'
name|'test_headersSavedOnResponse'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        All headers received by L{HTTPParser} are added to\n        L{HTTPParser.headers}.\n        """'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPParser'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'HTTP/1.1 200 OK\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'X-Foo: bar\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'X-Foo: baz\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'list'
op|'('
name|'protocol'
op|'.'
name|'headers'
op|'.'
name|'getAllRawHeaders'
op|'('
op|')'
op|')'
op|','
nl|'\n'
op|'['
op|'('
string|"'X-Foo'"
op|','
op|'['
string|"'bar'"
op|','
string|"'baz'"
op|']'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_connectionControlHeaders
dedent|''
name|'def'
name|'test_connectionControlHeaders'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{HTTPParser.isConnectionControlHeader} returns C{True} for headers\n        which are always connection control headers (similar to "hop-by-hop"\n        headers from RFC 2616 section 13.5.1) and C{False} for other headers.\n        """'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPParser'
op|'('
op|')'
newline|'\n'
name|'connHeaderNames'
op|'='
op|'['
nl|'\n'
string|"'content-length'"
op|','
string|"'connection'"
op|','
string|"'keep-alive'"
op|','
string|"'te'"
op|','
string|"'trailers'"
op|','
nl|'\n'
string|"'transfer-encoding'"
op|','
string|"'upgrade'"
op|','
string|"'proxy-connection'"
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'header'
name|'in'
name|'connHeaderNames'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertTrue'
op|'('
nl|'\n'
name|'protocol'
op|'.'
name|'isConnectionControlHeader'
op|'('
name|'header'
op|')'
op|','
nl|'\n'
string|'"Expecting %r to be a connection control header, but "'
nl|'\n'
string|'"wasn\'t"'
op|'%'
op|'('
name|'header'
op|','
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertFalse'
op|'('
nl|'\n'
name|'protocol'
op|'.'
name|'isConnectionControlHeader'
op|'('
string|'"date"'
op|')'
op|','
nl|'\n'
string|'"Expecting the arbitrarily selected \'date\' header to not be "'
nl|'\n'
string|'"a connection control header, but was."'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_switchToBodyMode
dedent|''
name|'def'
name|'test_switchToBodyMode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{HTTPParser.switchToBodyMode} raises L{RuntimeError} if called more\n        than once.\n        """'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPParser'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'switchToBodyMode'
op|'('
name|'object'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'RuntimeError'
op|','
name|'protocol'
op|'.'
name|'switchToBodyMode'
op|','
name|'object'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|HTTPClientParserTests
dedent|''
dedent|''
name|'class'
name|'HTTPClientParserTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{HTTPClientParser} which is responsible for parsing HTTP\n    response messages.\n    """'
newline|'\n'
DECL|member|test_parseVersion
name|'def'
name|'test_parseVersion'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{HTTPClientParser.parseVersion} parses a status line into its three\n        components.\n        """'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPClientParser'
op|'('
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'protocol'
op|'.'
name|'parseVersion'
op|'('
string|"'CANDY/7.2'"
op|')'
op|','
nl|'\n'
op|'('
string|"'CANDY'"
op|','
number|'7'
op|','
number|'2'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_parseBadVersion
dedent|''
name|'def'
name|'test_parseBadVersion'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{HTTPClientParser.parseVersion} raises L{ValueError} when passed an\n        unparsable version.\n        """'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPClientParser'
op|'('
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
name|'e'
op|'='
name|'BadResponseVersion'
newline|'\n'
name|'f'
op|'='
name|'protocol'
op|'.'
name|'parseVersion'
newline|'\n'
nl|'\n'
DECL|function|checkParsing
name|'def'
name|'checkParsing'
op|'('
name|'s'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'exc'
op|'='
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'e'
op|','
name|'f'
op|','
name|'s'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'exc'
op|'.'
name|'data'
op|','
name|'s'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'checkParsing'
op|'('
string|"'foo'"
op|')'
newline|'\n'
name|'checkParsing'
op|'('
string|"'foo/bar/baz'"
op|')'
newline|'\n'
nl|'\n'
name|'checkParsing'
op|'('
string|"'foo/'"
op|')'
newline|'\n'
name|'checkParsing'
op|'('
string|"'foo/..'"
op|')'
newline|'\n'
nl|'\n'
name|'checkParsing'
op|'('
string|"'foo/a.b'"
op|')'
newline|'\n'
name|'checkParsing'
op|'('
string|"'foo/-1.-1'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_responseStatusParsing
dedent|''
name|'def'
name|'test_responseStatusParsing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{HTTPClientParser.statusReceived} parses the version, code, and phrase\n        from the status line and stores them on the response object.\n        """'
newline|'\n'
name|'request'
op|'='
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPClientParser'
op|'('
name|'request'
op|','
name|'None'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'HTTP/1.1 200 OK\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'response'
op|'.'
name|'version'
op|','
op|'('
string|"'HTTP'"
op|','
number|'1'
op|','
number|'1'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'response'
op|'.'
name|'code'
op|','
number|'200'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'response'
op|'.'
name|'phrase'
op|','
string|"'OK'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_badResponseStatus
dedent|''
name|'def'
name|'test_badResponseStatus'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{HTTPClientParser.statusReceived} raises L{ParseError} if it is called\n        with a status line which cannot be parsed.\n        """'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPClientParser'
op|'('
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
DECL|function|checkParsing
name|'def'
name|'checkParsing'
op|'('
name|'s'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'exc'
op|'='
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'ParseError'
op|','
name|'protocol'
op|'.'
name|'statusReceived'
op|','
name|'s'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'exc'
op|'.'
name|'data'
op|','
name|'s'
op|')'
newline|'\n'
nl|'\n'
comment|'# If there are fewer than three whitespace-delimited parts to the'
nl|'\n'
comment|'# status line, it is not valid and cannot be parsed.'
nl|'\n'
dedent|''
name|'checkParsing'
op|'('
string|"'foo'"
op|')'
newline|'\n'
name|'checkParsing'
op|'('
string|"'HTTP/1.1 200'"
op|')'
newline|'\n'
nl|'\n'
comment|'# If the response code is not an integer, the status line is not valid'
nl|'\n'
comment|'# and cannot be parsed.'
nl|'\n'
name|'checkParsing'
op|'('
string|"'HTTP/1.1 bar OK'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_noBodyTest
dedent|''
name|'def'
name|'_noBodyTest'
op|'('
name|'self'
op|','
name|'request'
op|','
name|'response'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Assert that L{HTTPClientParser} parses the given C{response} to\n        C{request}, resulting in a response with no body and no extra bytes and\n        leaving the transport in the producing state.\n\n        @param request: A L{Request} instance which might have caused a server\n            to return the given response.\n        @param response: A string giving the response to be parsed.\n\n        @return: A C{dict} of headers from the response.\n        """'
newline|'\n'
name|'header'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'finished'
op|'='
op|'['
op|']'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPClientParser'
op|'('
name|'request'
op|','
name|'finished'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'headerReceived'
op|'='
name|'header'
op|'.'
name|'__setitem__'
newline|'\n'
name|'body'
op|'='
op|'['
op|']'
newline|'\n'
name|'protocol'
op|'.'
name|'_bodyDataReceived'
op|'='
name|'body'
op|'.'
name|'append'
newline|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'transport'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
name|'response'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'transport'
op|'.'
name|'producerState'
op|','
string|"'producing'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'state'
op|','
name|'DONE'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'body'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'finished'
op|','
op|'['
string|"''"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'response'
op|'.'
name|'length'
op|','
number|'0'
op|')'
newline|'\n'
name|'return'
name|'header'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_headResponse
dedent|''
name|'def'
name|'test_headResponse'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the response is to a HEAD request, no body is expected, the body\n        callback is not invoked, and the I{Content-Length} header is passed to\n        the header callback.\n        """'
newline|'\n'
name|'request'
op|'='
name|'Request'
op|'('
string|"'HEAD'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
newline|'\n'
name|'status'
op|'='
op|'('
nl|'\n'
string|"'HTTP/1.1 200 OK\\r\\n'"
nl|'\n'
string|"'Content-Length: 10\\r\\n'"
nl|'\n'
string|"'\\r\\n'"
op|')'
newline|'\n'
name|'header'
op|'='
name|'self'
op|'.'
name|'_noBodyTest'
op|'('
name|'request'
op|','
name|'status'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'header'
op|','
op|'{'
string|"'Content-Length'"
op|':'
string|"'10'"
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_noContentResponse
dedent|''
name|'def'
name|'test_noContentResponse'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the response code is I{NO CONTENT} (204), no body is expected and\n        the body callback is not invoked.\n        """'
newline|'\n'
name|'request'
op|'='
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
newline|'\n'
name|'status'
op|'='
op|'('
nl|'\n'
string|"'HTTP/1.1 204 NO CONTENT\\r\\n'"
nl|'\n'
string|"'\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_noBodyTest'
op|'('
name|'request'
op|','
name|'status'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_notModifiedResponse
dedent|''
name|'def'
name|'test_notModifiedResponse'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the response code is I{NOT MODIFIED} (304), no body is expected and\n        the body callback is not invoked.\n        """'
newline|'\n'
name|'request'
op|'='
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
newline|'\n'
name|'status'
op|'='
op|'('
nl|'\n'
string|"'HTTP/1.1 304 NOT MODIFIED\\r\\n'"
nl|'\n'
string|"'\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_noBodyTest'
op|'('
name|'request'
op|','
name|'status'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_responseHeaders
dedent|''
name|'def'
name|'test_responseHeaders'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The response headers are added to the response object\'s C{headers}\n        L{Headers} instance.\n        """'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPClientParser'
op|'('
nl|'\n'
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|','
nl|'\n'
name|'lambda'
name|'rest'
op|':'
name|'None'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'HTTP/1.1 200 OK\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'X-Foo: bar\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'protocol'
op|'.'
name|'connHeaders'
op|','
nl|'\n'
name|'Headers'
op|'('
op|'{'
op|'}'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'protocol'
op|'.'
name|'response'
op|'.'
name|'headers'
op|','
nl|'\n'
name|'Headers'
op|'('
op|'{'
string|"'x-foo'"
op|':'
op|'['
string|"'bar'"
op|']'
op|'}'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'protocol'
op|'.'
name|'response'
op|'.'
name|'length'
op|','
name|'UNKNOWN_LENGTH'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_connectionHeaders
dedent|''
name|'def'
name|'test_connectionHeaders'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The connection control headers are added to the parser\'s C{connHeaders}\n        L{Headers} instance.\n        """'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPClientParser'
op|'('
nl|'\n'
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|','
nl|'\n'
name|'lambda'
name|'rest'
op|':'
name|'None'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'HTTP/1.1 200 OK\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'Content-Length: 123\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'Connection: close\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'protocol'
op|'.'
name|'response'
op|'.'
name|'headers'
op|','
nl|'\n'
name|'Headers'
op|'('
op|'{'
op|'}'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'protocol'
op|'.'
name|'connHeaders'
op|','
nl|'\n'
name|'Headers'
op|'('
op|'{'
string|"'content-length'"
op|':'
op|'['
string|"'123'"
op|']'
op|','
nl|'\n'
string|"'connection'"
op|':'
op|'['
string|"'close'"
op|']'
op|'}'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'response'
op|'.'
name|'length'
op|','
number|'123'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_headResponseContentLengthEntityHeader
dedent|''
name|'def'
name|'test_headResponseContentLengthEntityHeader'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a HEAD request is made, the I{Content-Length} header in the response\n        is added to the response headers, not the connection control headers.\n        """'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPClientParser'
op|'('
nl|'\n'
name|'Request'
op|'('
string|"'HEAD'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|','
nl|'\n'
name|'lambda'
name|'rest'
op|':'
name|'None'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'HTTP/1.1 200 OK\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'Content-Length: 123\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'protocol'
op|'.'
name|'response'
op|'.'
name|'headers'
op|','
nl|'\n'
name|'Headers'
op|'('
op|'{'
string|"'content-length'"
op|':'
op|'['
string|"'123'"
op|']'
op|'}'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'protocol'
op|'.'
name|'connHeaders'
op|','
nl|'\n'
name|'Headers'
op|'('
op|'{'
op|'}'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'response'
op|'.'
name|'length'
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_contentLength
dedent|''
name|'def'
name|'test_contentLength'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a response includes a body with a length given by the\n        I{Content-Length} header, the bytes which make up the body are passed\n        to the C{_bodyDataReceived} callback on the L{HTTPParser}.\n        """'
newline|'\n'
name|'finished'
op|'='
op|'['
op|']'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPClientParser'
op|'('
nl|'\n'
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|','
nl|'\n'
name|'finished'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'transport'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'HTTP/1.1 200 OK\\r\\n'"
op|')'
newline|'\n'
name|'body'
op|'='
op|'['
op|']'
newline|'\n'
name|'protocol'
op|'.'
name|'response'
op|'.'
name|'_bodyDataReceived'
op|'='
name|'body'
op|'.'
name|'append'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'Content-Length: 10\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'\\r\\n'"
op|')'
newline|'\n'
nl|'\n'
comment|'# Incidentally, the transport should be paused now.  It is the response'
nl|'\n'
comment|"# object's responsibility to resume this when it is ready for bytes."
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'transport'
op|'.'
name|'producerState'
op|','
string|"'paused'"
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'state'
op|','
name|'BODY'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'x'"
op|'*'
number|'6'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'body'
op|','
op|'['
string|"'x'"
op|'*'
number|'6'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'state'
op|','
name|'BODY'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'y'"
op|'*'
number|'4'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'body'
op|','
op|'['
string|"'x'"
op|'*'
number|'6'
op|','
string|"'y'"
op|'*'
number|'4'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'state'
op|','
name|'DONE'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'finished'
op|','
op|'['
string|"''"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_zeroContentLength
dedent|''
name|'def'
name|'test_zeroContentLength'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a response includes a I{Content-Length} header indicating zero bytes\n        in the response, L{Response.length} is set accordingly and no data is\n        delivered to L{Response._bodyDataReceived}.\n        """'
newline|'\n'
name|'finished'
op|'='
op|'['
op|']'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPClientParser'
op|'('
nl|'\n'
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|','
nl|'\n'
name|'finished'
op|'.'
name|'append'
op|')'
newline|'\n'
nl|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'HTTP/1.1 200 OK\\r\\n'"
op|')'
newline|'\n'
nl|'\n'
name|'body'
op|'='
op|'['
op|']'
newline|'\n'
name|'protocol'
op|'.'
name|'response'
op|'.'
name|'_bodyDataReceived'
op|'='
name|'body'
op|'.'
name|'append'
newline|'\n'
nl|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'Content-Length: 0\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'\\r\\n'"
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'state'
op|','
name|'DONE'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'body'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'finished'
op|','
op|'['
string|"''"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'response'
op|'.'
name|'length'
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_multipleContentLengthHeaders
dedent|''
name|'def'
name|'test_multipleContentLengthHeaders'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a response includes multiple I{Content-Length} headers,\n        L{HTTPClientParser.dataReceived} raises L{ValueError} to indicate that\n        the response is invalid and the transport is now unusable.\n        """'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPClientParser'
op|'('
nl|'\n'
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|','
nl|'\n'
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
nl|'\n'
name|'ValueError'
op|','
nl|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|','
nl|'\n'
string|"'HTTP/1.1 200 OK\\r\\n'"
nl|'\n'
string|"'Content-Length: 1\\r\\n'"
nl|'\n'
string|"'Content-Length: 2\\r\\n'"
nl|'\n'
string|"'\\r\\n'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_extraBytesPassedBack
dedent|''
name|'def'
name|'test_extraBytesPassedBack'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If extra bytes are received past the end of a response, they are passed\n        to the finish callback.\n        """'
newline|'\n'
name|'finished'
op|'='
op|'['
op|']'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPClientParser'
op|'('
nl|'\n'
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|','
nl|'\n'
name|'finished'
op|'.'
name|'append'
op|')'
newline|'\n'
nl|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'HTTP/1.1 200 OK\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'Content-Length: 0\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'\\r\\nHere is another thing!'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'state'
op|','
name|'DONE'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'finished'
op|','
op|'['
string|"'Here is another thing!'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_extraBytesPassedBackHEAD
dedent|''
name|'def'
name|'test_extraBytesPassedBackHEAD'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If extra bytes are received past the end of the headers of a response\n        to a HEAD request, they are passed to the finish callback.\n        """'
newline|'\n'
name|'finished'
op|'='
op|'['
op|']'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPClientParser'
op|'('
nl|'\n'
name|'Request'
op|'('
string|"'HEAD'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|','
nl|'\n'
name|'finished'
op|'.'
name|'append'
op|')'
newline|'\n'
nl|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'HTTP/1.1 200 OK\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'Content-Length: 12\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'\\r\\nHere is another thing!'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'state'
op|','
name|'DONE'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'finished'
op|','
op|'['
string|"'Here is another thing!'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_chunkedResponseBody
dedent|''
name|'def'
name|'test_chunkedResponseBody'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the response headers indicate the response body is encoded with the\n        I{chunked} transfer encoding, the body is decoded according to that\n        transfer encoding before being passed to L{Response._bodyDataReceived}.\n        """'
newline|'\n'
name|'finished'
op|'='
op|'['
op|']'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPClientParser'
op|'('
nl|'\n'
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|','
nl|'\n'
name|'finished'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'HTTP/1.1 200 OK\\r\\n'"
op|')'
newline|'\n'
nl|'\n'
name|'body'
op|'='
op|'['
op|']'
newline|'\n'
name|'protocol'
op|'.'
name|'response'
op|'.'
name|'_bodyDataReceived'
op|'='
name|'body'
op|'.'
name|'append'
newline|'\n'
nl|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'Transfer-Encoding: chunked\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'\\r\\n'"
op|')'
newline|'\n'
nl|'\n'
comment|'# No data delivered yet'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'body'
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Cannot predict the length of a chunked encoded response body.'
nl|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'protocol'
op|'.'
name|'response'
op|'.'
name|'length'
op|','
name|'UNKNOWN_LENGTH'
op|')'
newline|'\n'
nl|'\n'
comment|'# Deliver some chunks and make sure the data arrives'
nl|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'3\\r\\na'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'body'
op|','
op|'['
string|"'a'"
op|']'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'bc\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'body'
op|','
op|'['
string|"'a'"
op|','
string|"'bc'"
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|"# The response's _bodyDataFinished method should be called when the last"
nl|'\n'
comment|'# chunk is received.  Extra data should be passed to the finished'
nl|'\n'
comment|'# callback.'
nl|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'0\\r\\n\\r\\nextra'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'finished'
op|','
op|'['
string|"'extra'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_unknownContentLength
dedent|''
name|'def'
name|'test_unknownContentLength'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a response does not include a I{Transfer-Encoding} or a\n        I{Content-Length}, the end of response body is indicated by the\n        connection being closed.\n        """'
newline|'\n'
name|'finished'
op|'='
op|'['
op|']'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPClientParser'
op|'('
nl|'\n'
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|','
name|'finished'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'transport'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'HTTP/1.1 200 OK\\r\\n'"
op|')'
newline|'\n'
nl|'\n'
name|'body'
op|'='
op|'['
op|']'
newline|'\n'
name|'protocol'
op|'.'
name|'response'
op|'.'
name|'_bodyDataReceived'
op|'='
name|'body'
op|'.'
name|'append'
newline|'\n'
nl|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'\\r\\n'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'foo'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'bar'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'body'
op|','
op|'['
string|"'foo'"
op|','
string|"'bar'"
op|']'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'connectionLost'
op|'('
name|'ConnectionDone'
op|'('
string|'"simulated end of connection"'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'finished'
op|','
op|'['
string|"''"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_contentLengthAndTransferEncoding
dedent|''
name|'def'
name|'test_contentLengthAndTransferEncoding'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        According to RFC 2616, section 4.4, point 3, if I{Content-Length} and\n        I{Transfer-Encoding: chunked} are present, I{Content-Length} MUST be\n        ignored\n        """'
newline|'\n'
name|'finished'
op|'='
op|'['
op|']'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPClientParser'
op|'('
nl|'\n'
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|','
name|'finished'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'transport'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'HTTP/1.1 200 OK\\r\\n'"
op|')'
newline|'\n'
nl|'\n'
name|'body'
op|'='
op|'['
op|']'
newline|'\n'
name|'protocol'
op|'.'
name|'response'
op|'.'
name|'_bodyDataReceived'
op|'='
name|'body'
op|'.'
name|'append'
newline|'\n'
nl|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
nl|'\n'
string|"'Content-Length: 102\\r\\n'"
nl|'\n'
string|"'Transfer-Encoding: chunked\\r\\n'"
nl|'\n'
string|"'\\r\\n'"
nl|'\n'
string|"'3\\r\\n'"
nl|'\n'
string|"'abc\\r\\n'"
nl|'\n'
string|"'0\\r\\n'"
nl|'\n'
string|"'\\r\\n'"
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'body'
op|','
op|'['
string|"'abc'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'finished'
op|','
op|'['
string|"''"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_connectionLostBeforeBody
dedent|''
name|'def'
name|'test_connectionLostBeforeBody'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If L{HTTPClientParser.connectionLost} is called before the headers are\n        finished, the C{_responseDeferred} is fired with the L{Failure} passed\n        to C{connectionLost}.\n        """'
newline|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPClientParser'
op|'('
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'transport'
op|')'
newline|'\n'
comment|'# Grab this here because connectionLost gets rid of the attribute'
nl|'\n'
name|'responseDeferred'
op|'='
name|'protocol'
op|'.'
name|'_responseDeferred'
newline|'\n'
name|'protocol'
op|'.'
name|'connectionLost'
op|'('
name|'Failure'
op|'('
name|'ArbitraryException'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'assertResponseFailed'
op|'('
nl|'\n'
name|'self'
op|','
name|'responseDeferred'
op|','
op|'['
name|'ArbitraryException'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_connectionLostWithError
dedent|''
name|'def'
name|'test_connectionLostWithError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If one of the L{Response} methods called by\n        L{HTTPClientParser.connectionLost} raises an exception, the exception\n        is logged and not re-raised.\n        """'
newline|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'='
name|'HTTPClientParser'
op|'('
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'transport'
op|')'
newline|'\n'
nl|'\n'
name|'response'
op|'='
op|'['
op|']'
newline|'\n'
name|'protocol'
op|'.'
name|'_responseDeferred'
op|'.'
name|'addCallback'
op|'('
name|'response'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
nl|'\n'
string|"'HTTP/1.1 200 OK\\r\\n'"
nl|'\n'
string|"'Content-Length: 1\\r\\n'"
nl|'\n'
string|"'\\r\\n'"
op|')'
newline|'\n'
name|'response'
op|'='
name|'response'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
comment|'# Arrange for an exception'
nl|'\n'
DECL|function|fakeBodyDataFinished
name|'def'
name|'fakeBodyDataFinished'
op|'('
name|'err'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ArbitraryException'
op|'('
op|')'
newline|'\n'
dedent|''
name|'response'
op|'.'
name|'_bodyDataFinished'
op|'='
name|'fakeBodyDataFinished'
newline|'\n'
nl|'\n'
name|'protocol'
op|'.'
name|'connectionLost'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'flushLoggedErrors'
op|'('
name|'ArbitraryException'
op|')'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|SlowRequest
dedent|''
dedent|''
name|'class'
name|'SlowRequest'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    L{SlowRequest} is a fake implementation of L{Request} which is easily\n    controlled externally (for example, by code in a test method).\n\n    @ivar stopped: A flag indicating whether C{stopWriting} has been called.\n\n    @ivar finished: After C{writeTo} is called, a L{Deferred} which was\n        returned by that method.  L{SlowRequest} will never fire this\n        L{Deferred}.\n    """'
newline|'\n'
DECL|variable|method
name|'method'
op|'='
string|"'GET'"
newline|'\n'
DECL|variable|stopped
name|'stopped'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|member|writeTo
name|'def'
name|'writeTo'
op|'('
name|'self'
op|','
name|'transport'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'finished'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'finished'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|stopWriting
dedent|''
name|'def'
name|'stopWriting'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'stopped'
op|'='
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|SimpleRequest
dedent|''
dedent|''
name|'class'
name|'SimpleRequest'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    L{SimpleRequest} is a fake implementation of L{Request} which writes a\n    short, fixed string to the transport passed to its C{writeTo} method and\n    returns a succeeded L{Deferred}.  This vaguely emulates the behavior of a\n    L{Request} with no body producer.\n    """'
newline|'\n'
DECL|member|writeTo
name|'def'
name|'writeTo'
op|'('
name|'self'
op|','
name|'transport'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'transport'
op|'.'
name|'write'
op|'('
string|"'SOME BYTES'"
op|')'
newline|'\n'
name|'return'
name|'succeed'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|HTTP11ClientProtocolTests
dedent|''
dedent|''
name|'class'
name|'HTTP11ClientProtocolTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for the HTTP 1.1 client protocol implementation,\n    L{HTTP11ClientProtocol}.\n    """'
newline|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create an L{HTTP11ClientProtocol} connected to a fake transport.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'protocol'
op|'='
name|'HTTP11ClientProtocol'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_request
dedent|''
name|'def'
name|'test_request'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{HTTP11ClientProtocol.request} accepts a L{Request} and calls its\n        C{writeTo} method with its own transport.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'request'
op|'('
name|'SimpleRequest'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|"'SOME BYTES'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_secondRequest
dedent|''
name|'def'
name|'test_secondRequest'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The second time L{HTTP11ClientProtocol.request} is called, it returns a\n        L{Deferred} which immediately fires with a L{Failure} wrapping a\n        L{RequestNotSent} exception.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'request'
op|'('
name|'SlowRequest'
op|'('
op|')'
op|')'
newline|'\n'
DECL|function|cbNotSent
name|'def'
name|'cbNotSent'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|"''"
op|')'
newline|'\n'
dedent|''
name|'d'
op|'='
name|'self'
op|'.'
name|'assertFailure'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'request'
op|'('
name|'SimpleRequest'
op|'('
op|')'
op|')'
op|','
name|'RequestNotSent'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'cbNotSent'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_requestAfterConnectionLost
dedent|''
name|'def'
name|'test_requestAfterConnectionLost'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{HTTP11ClientProtocol.request} returns a L{Deferred} which immediately\n        fires with a L{Failure} wrapping a L{RequestNotSent} if called after\n        the protocol has been disconnected.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'connectionLost'
op|'('
nl|'\n'
name|'Failure'
op|'('
name|'ConnectionDone'
op|'('
string|'"sad transport"'
op|')'
op|')'
op|')'
newline|'\n'
DECL|function|cbNotSent
name|'def'
name|'cbNotSent'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|"''"
op|')'
newline|'\n'
dedent|''
name|'d'
op|'='
name|'self'
op|'.'
name|'assertFailure'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'request'
op|'('
name|'SimpleRequest'
op|'('
op|')'
op|')'
op|','
name|'RequestNotSent'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'cbNotSent'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_failedWriteTo
dedent|''
name|'def'
name|'test_failedWriteTo'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the L{Deferred} returned by L{Request.writeTo} fires with a\n        L{Failure}, L{HTTP11ClientProtocol.request} disconnects its transport\n        and returns a L{Deferred} which fires with a L{Failure} of\n        L{RequestGenerationFailed} wrapping the underlying failure.\n        """'
newline|'\n'
DECL|class|BrokenRequest
name|'class'
name|'BrokenRequest'
op|':'
newline|'\n'
DECL|member|writeTo
indent|'            '
name|'def'
name|'writeTo'
op|'('
name|'self'
op|','
name|'transport'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'fail'
op|'('
name|'ArbitraryException'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'d'
op|'='
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'request'
op|'('
name|'BrokenRequest'
op|'('
op|')'
op|')'
newline|'\n'
DECL|function|cbFailed
name|'def'
name|'cbFailed'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'disconnecting'
op|')'
newline|'\n'
comment|'# Simulate what would happen if the protocol had a real transport'
nl|'\n'
comment|'# and make sure no exception is raised.'
nl|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'connectionLost'
op|'('
nl|'\n'
name|'Failure'
op|'('
name|'ConnectionDone'
op|'('
string|'"you asked for it"'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'='
name|'assertRequestGenerationFailed'
op|'('
name|'self'
op|','
name|'d'
op|','
op|'['
name|'ArbitraryException'
op|']'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'cbFailed'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_synchronousWriteToError
dedent|''
name|'def'
name|'test_synchronousWriteToError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If L{Request.writeTo} raises an exception,\n        L{HTTP11ClientProtocol.request} returns a L{Deferred} which fires with\n        a L{Failure} of L{RequestGenerationFailed} wrapping that exception.\n        """'
newline|'\n'
DECL|class|BrokenRequest
name|'class'
name|'BrokenRequest'
op|':'
newline|'\n'
DECL|member|writeTo
indent|'            '
name|'def'
name|'writeTo'
op|'('
name|'self'
op|','
name|'transport'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'ArbitraryException'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'d'
op|'='
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'request'
op|'('
name|'BrokenRequest'
op|'('
op|')'
op|')'
newline|'\n'
name|'return'
name|'assertRequestGenerationFailed'
op|'('
name|'self'
op|','
name|'d'
op|','
op|'['
name|'ArbitraryException'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_connectionLostDuringRequestGeneration
dedent|''
name|'def'
name|'test_connectionLostDuringRequestGeneration'
op|'('
name|'self'
op|','
name|'mode'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If L{HTTP11ClientProtocol}\'s transport is disconnected before the\n        L{Deferred} returned by L{Request.writeTo} fires, the L{Deferred}\n        returned by L{HTTP11ClientProtocol.request} fires with a L{Failure} of\n        L{RequestTransmissionFailed} wrapping the underlying failure.\n        """'
newline|'\n'
name|'request'
op|'='
name|'SlowRequest'
op|'('
op|')'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'request'
op|'('
name|'request'
op|')'
newline|'\n'
name|'d'
op|'='
name|'assertRequestTransmissionFailed'
op|'('
name|'self'
op|','
name|'d'
op|','
op|'['
name|'ArbitraryException'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|"# The connection hasn't been lost yet.  The request should still be"
nl|'\n'
comment|'# allowed to do its thing.'
nl|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'request'
op|'.'
name|'stopped'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'connectionLost'
op|'('
name|'Failure'
op|'('
name|'ArbitraryException'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Now the connection has been lost.  The request should have been told'
nl|'\n'
comment|'# to stop writing itself.'
nl|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'request'
op|'.'
name|'stopped'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'mode'
op|'=='
string|"'callback'"
op|':'
newline|'\n'
indent|'            '
name|'request'
op|'.'
name|'finished'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'mode'
op|'=='
string|"'errback'"
op|':'
newline|'\n'
indent|'            '
name|'request'
op|'.'
name|'finished'
op|'.'
name|'errback'
op|'('
name|'Failure'
op|'('
name|'AnotherArbitraryException'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
name|'errors'
op|'='
name|'self'
op|'.'
name|'flushLoggedErrors'
op|'('
name|'AnotherArbitraryException'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'len'
op|'('
name|'errors'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|"# Don't fire the writeTo Deferred at all."
nl|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_connectionLostBeforeGenerationFinished
dedent|''
name|'def'
name|'test_connectionLostBeforeGenerationFinished'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the request passed to L{HTTP11ClientProtocol} finishes generation\n        successfully after the L{HTTP11ClientProtocol}\'s connection has been\n        lost, nothing happens.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'test_connectionLostDuringRequestGeneration'
op|'('
string|"'callback'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_connectionLostBeforeGenerationFailed
dedent|''
name|'def'
name|'test_connectionLostBeforeGenerationFailed'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the request passed to L{HTTP11ClientProtocol} finished generation\n        with an error after the L{HTTP11ClientProtocol}\'s connection has been\n        lost, nothing happens.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'test_connectionLostDuringRequestGeneration'
op|'('
string|"'errback'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_receiveSimplestResponse
dedent|''
name|'def'
name|'test_receiveSimplestResponse'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When a response is delivered to L{HTTP11ClientProtocol}, the\n        L{Deferred} previously returned by the C{request} method is called back\n        with a L{Response} instance and the connection is closed.\n        """'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'request'
op|'('
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|')'
newline|'\n'
DECL|function|cbRequest
name|'def'
name|'cbRequest'
op|'('
name|'response'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'response'
op|'.'
name|'code'
op|','
number|'200'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'response'
op|'.'
name|'headers'
op|','
name|'Headers'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'disconnecting'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'cbRequest'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
nl|'\n'
string|'"HTTP/1.1 200 OK\\r\\n"'
nl|'\n'
string|'"Content-Length: 0\\r\\n"'
nl|'\n'
string|'"\\r\\n"'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_receiveResponseHeaders
dedent|''
name|'def'
name|'test_receiveResponseHeaders'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The headers included in a response delivered to L{HTTP11ClientProtocol}\n        are included on the L{Response} instance passed to the callback\n        returned by the C{request} method.\n        """'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'request'
op|'('
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|')'
newline|'\n'
DECL|function|cbRequest
name|'def'
name|'cbRequest'
op|'('
name|'response'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'expected'
op|'='
name|'Headers'
op|'('
op|'{'
string|"'x-foo'"
op|':'
op|'['
string|"'bar'"
op|','
string|"'baz'"
op|']'
op|'}'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'response'
op|'.'
name|'headers'
op|','
name|'expected'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'cbRequest'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
nl|'\n'
string|'"HTTP/1.1 200 OK\\r\\n"'
nl|'\n'
string|'"X-Foo: bar\\r\\n"'
nl|'\n'
string|'"X-Foo: baz\\r\\n"'
nl|'\n'
string|'"\\r\\n"'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_receiveResponseBeforeRequestGenerationDone
dedent|''
name|'def'
name|'test_receiveResponseBeforeRequestGenerationDone'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If response bytes are delivered to L{HTTP11ClientProtocol} before the\n        L{Deferred} returned by L{Request.writeTo} fires, those response bytes\n        are parsed as part of the response.\n        """'
newline|'\n'
name|'request'
op|'='
name|'SlowRequest'
op|'('
op|')'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'request'
op|'('
name|'request'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
nl|'\n'
string|'"HTTP/1.1 200 OK\\r\\n"'
nl|'\n'
string|'"X-Foo: bar\\r\\n"'
nl|'\n'
string|'"Content-Length: 6\\r\\n"'
nl|'\n'
string|'"\\r\\n"'
nl|'\n'
string|'"foobar"'
op|')'
newline|'\n'
DECL|function|cbResponse
name|'def'
name|'cbResponse'
op|'('
name|'response'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'p'
op|'='
name|'AccumulatingProtocol'
op|'('
op|')'
newline|'\n'
name|'whenFinished'
op|'='
name|'p'
op|'.'
name|'closedDeferred'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'response'
op|'.'
name|'deliverBody'
op|'('
name|'p'
op|')'
newline|'\n'
name|'return'
name|'whenFinished'
op|'.'
name|'addCallback'
op|'('
nl|'\n'
name|'lambda'
name|'ign'
op|':'
op|'('
name|'response'
op|','
name|'p'
op|'.'
name|'data'
op|')'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'cbResponse'
op|')'
newline|'\n'
DECL|function|cbAllResponse
name|'def'
name|'cbAllResponse'
op|'('
op|'('
name|'response'
op|','
name|'body'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'response'
op|'.'
name|'version'
op|','
op|'('
string|"'HTTP'"
op|','
number|'1'
op|','
number|'1'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'response'
op|'.'
name|'code'
op|','
number|'200'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'response'
op|'.'
name|'phrase'
op|','
string|"'OK'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'response'
op|'.'
name|'headers'
op|','
name|'Headers'
op|'('
op|'{'
string|"'x-foo'"
op|':'
op|'['
string|"'bar'"
op|']'
op|'}'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'body'
op|','
string|'"foobar"'
op|')'
newline|'\n'
nl|'\n'
comment|'# Also nothing bad should happen if the request does finally'
nl|'\n'
comment|'# finish, even though it is completely irrelevant.'
nl|'\n'
name|'request'
op|'.'
name|'finished'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'cbAllResponse'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_receiveResponseBody
dedent|''
name|'def'
name|'test_receiveResponseBody'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The C{deliverBody} method of the response object with which the\n        L{Deferred} returned by L{HTTP11ClientProtocol.request} fires can be\n        used to get the body of the response.\n        """'
newline|'\n'
name|'protocol'
op|'='
name|'AccumulatingProtocol'
op|'('
op|')'
newline|'\n'
name|'whenFinished'
op|'='
name|'protocol'
op|'.'
name|'closedDeferred'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'requestDeferred'
op|'='
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'request'
op|'('
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
nl|'\n'
string|'"HTTP/1.1 200 OK\\r\\n"'
nl|'\n'
string|'"Content-Length: 6\\r\\n"'
nl|'\n'
string|'"\\r"'
op|')'
newline|'\n'
nl|'\n'
comment|"# Here's what's going on: all the response headers have been delivered"
nl|'\n'
comment|'# by this point, so the request Deferred can fire with a Response'
nl|'\n'
comment|"# object.  The body is yet to come, but that's okay, because the"
nl|'\n'
comment|'# Response object is how you *get* the body.'
nl|'\n'
name|'result'
op|'='
op|'['
op|']'
newline|'\n'
name|'requestDeferred'
op|'.'
name|'addCallback'
op|'('
name|'result'
op|'.'
name|'append'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'result'
op|','
op|'['
op|']'
op|')'
newline|'\n'
comment|'# Deliver the very last byte of the response.  It is exactly at this'
nl|'\n'
comment|'# point which the Deferred returned by request should fire.'
nl|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|'"\\n"'
op|')'
newline|'\n'
name|'response'
op|'='
name|'result'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
name|'response'
op|'.'
name|'deliverBody'
op|'('
name|'protocol'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|'"bar"'
op|')'
newline|'\n'
nl|'\n'
DECL|function|cbAllResponse
name|'def'
name|'cbAllResponse'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'data'
op|','
string|'"foobar"'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'closedReason'
op|'.'
name|'trap'
op|'('
name|'ResponseDone'
op|')'
newline|'\n'
dedent|''
name|'whenFinished'
op|'.'
name|'addCallback'
op|'('
name|'cbAllResponse'
op|')'
newline|'\n'
name|'return'
name|'whenFinished'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_responseBodyFinishedWhenConnectionLostWhenContentLengthIsUnknown
dedent|''
name|'def'
name|'test_responseBodyFinishedWhenConnectionLostWhenContentLengthIsUnknown'
op|'('
nl|'\n'
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the length of the response body is unknown, the protocol passed to\n        the response\'s C{deliverBody} method has its C{connectionLost}\n        method called with a L{Failure} wrapping a L{PotentialDataLoss}\n        exception.\n        """'
newline|'\n'
name|'requestDeferred'
op|'='
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'request'
op|'('
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
nl|'\n'
string|'"HTTP/1.1 200 OK\\r\\n"'
nl|'\n'
string|'"\\r\\n"'
op|')'
newline|'\n'
nl|'\n'
name|'result'
op|'='
op|'['
op|']'
newline|'\n'
name|'requestDeferred'
op|'.'
name|'addCallback'
op|'('
name|'result'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'response'
op|'='
name|'result'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
name|'protocol'
op|'='
name|'AccumulatingProtocol'
op|'('
op|')'
newline|'\n'
name|'response'
op|'.'
name|'deliverBody'
op|'('
name|'protocol'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|'"bar"'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'data'
op|','
string|'"foobar"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'connectionLost'
op|'('
nl|'\n'
name|'Failure'
op|'('
name|'ConnectionDone'
op|'('
string|'"low-level transport disconnected"'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'protocol'
op|'.'
name|'closedReason'
op|'.'
name|'trap'
op|'('
name|'PotentialDataLoss'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_chunkedResponseBodyUnfinishedWhenConnectionLost
dedent|''
name|'def'
name|'test_chunkedResponseBodyUnfinishedWhenConnectionLost'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the final chunk has not been received when the connection is lost\n        (for any reason), the protocol passed to C{deliverBody} has its\n        C{connectionLost} method called with a L{Failure} wrapping the\n        exception for that reason.\n        """'
newline|'\n'
name|'requestDeferred'
op|'='
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'request'
op|'('
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
nl|'\n'
string|'"HTTP/1.1 200 OK\\r\\n"'
nl|'\n'
string|'"Transfer-Encoding: chunked\\r\\n"'
nl|'\n'
string|'"\\r\\n"'
op|')'
newline|'\n'
nl|'\n'
name|'result'
op|'='
op|'['
op|']'
newline|'\n'
name|'requestDeferred'
op|'.'
name|'addCallback'
op|'('
name|'result'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'response'
op|'='
name|'result'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
name|'protocol'
op|'='
name|'AccumulatingProtocol'
op|'('
op|')'
newline|'\n'
name|'response'
op|'.'
name|'deliverBody'
op|'('
name|'protocol'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|'"3\\r\\nfoo\\r\\n"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|'"3\\r\\nbar\\r\\n"'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'data'
op|','
string|'"foobar"'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'connectionLost'
op|'('
name|'Failure'
op|'('
name|'ArbitraryException'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'assertResponseFailed'
op|'('
nl|'\n'
name|'self'
op|','
name|'fail'
op|'('
name|'protocol'
op|'.'
name|'closedReason'
op|')'
op|','
op|'['
name|'ArbitraryException'
op|','
name|'_DataLoss'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_parserDataReceivedException
dedent|''
name|'def'
name|'test_parserDataReceivedException'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the parser L{HTTP11ClientProtocol} delivers bytes to in\n        C{dataReceived} raises an exception, the exception is wrapped in a\n        L{Failure} and passed to the parser\'s C{connectionLost} and then the\n        L{HTTP11ClientProtocol}\'s transport is disconnected.\n        """'
newline|'\n'
name|'requestDeferred'
op|'='
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'request'
op|'('
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'unparseable garbage goes here\\r\\n'"
op|')'
newline|'\n'
name|'d'
op|'='
name|'assertResponseFailed'
op|'('
name|'self'
op|','
name|'requestDeferred'
op|','
op|'['
name|'ParseError'
op|']'
op|')'
newline|'\n'
DECL|function|cbFailed
name|'def'
name|'cbFailed'
op|'('
name|'exc'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'disconnecting'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'exc'
op|'.'
name|'reasons'
op|'['
number|'0'
op|']'
op|'.'
name|'value'
op|'.'
name|'data'
op|','
string|"'unparseable garbage goes here'"
op|')'
newline|'\n'
nl|'\n'
comment|"# Now do what StringTransport doesn't do but a real transport would"
nl|'\n'
comment|'# have, call connectionLost on the HTTP11ClientProtocol.  Nothing'
nl|'\n'
comment|"# is asserted about this, but it's important for it to not raise an"
nl|'\n'
comment|'# exception.'
nl|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'connectionLost'
op|'('
name|'Failure'
op|'('
name|'ConnectionDone'
op|'('
string|'"it is done"'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'cbFailed'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_proxyStopped
dedent|''
name|'def'
name|'test_proxyStopped'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When the HTTP response parser is disconnected, the\n        L{TransportProxyProducer} which was connected to it as a transport is\n        stopped.\n        """'
newline|'\n'
name|'requestDeferred'
op|'='
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'request'
op|'('
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|')'
newline|'\n'
name|'transport'
op|'='
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'_parser'
op|'.'
name|'transport'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'transport'
op|'.'
name|'_producer'
op|','
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'_disconnectParser'
op|'('
name|'Failure'
op|'('
name|'ConnectionDone'
op|'('
string|'"connection done"'
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'transport'
op|'.'
name|'_producer'
op|','
name|'None'
op|')'
newline|'\n'
name|'return'
name|'assertResponseFailed'
op|'('
name|'self'
op|','
name|'requestDeferred'
op|','
op|'['
name|'ConnectionDone'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|StringProducer
dedent|''
dedent|''
name|'class'
name|'StringProducer'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    L{StringProducer} is a dummy body producer.\n\n    @ivar stopped: A flag which indicates whether or not C{stopProducing} has\n        been called.\n    @ivar consumer: After C{startProducing} is called, the value of the\n        C{consumer} argument to that method.\n    @ivar finished: After C{startProducing} is called, a L{Deferred} which was\n        returned by that method.  L{StringProducer} will never fire this\n        L{Deferred}.\n    """'
newline|'\n'
name|'implements'
op|'('
name|'IBodyProducer'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|stopped
name|'stopped'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'length'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'length'
op|'='
name|'length'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|startProducing
dedent|''
name|'def'
name|'startProducing'
op|'('
name|'self'
op|','
name|'consumer'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'consumer'
op|'='
name|'consumer'
newline|'\n'
name|'self'
op|'.'
name|'finished'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'finished'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|stopProducing
dedent|''
name|'def'
name|'stopProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'stopped'
op|'='
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|RequestTests
dedent|''
dedent|''
name|'class'
name|'RequestTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{Request}.\n    """'
newline|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_sendSimplestRequest
dedent|''
name|'def'
name|'test_sendSimplestRequest'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Request.writeTo} formats the request data and writes it to the given\n        transport.\n        """'
newline|'\n'
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'None'
op|')'
op|'.'
name|'writeTo'
op|'('
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
nl|'\n'
string|'"GET / HTTP/1.1\\r\\n"'
nl|'\n'
string|'"Connection: close\\r\\n"'
nl|'\n'
string|'"Host: example.com\\r\\n"'
nl|'\n'
string|'"\\r\\n"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_sendRequestHeaders
dedent|''
name|'def'
name|'test_sendRequestHeaders'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Request.writeTo} formats header data and writes it to the given\n        transport.\n        """'
newline|'\n'
name|'headers'
op|'='
name|'Headers'
op|'('
op|'{'
string|"'x-foo'"
op|':'
op|'['
string|"'bar'"
op|','
string|"'baz'"
op|']'
op|','
string|"'host'"
op|':'
op|'['
string|"'example.com'"
op|']'
op|'}'
op|')'
newline|'\n'
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/foo'"
op|','
name|'headers'
op|','
name|'None'
op|')'
op|'.'
name|'writeTo'
op|'('
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
name|'lines'
op|'='
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|'.'
name|'split'
op|'('
string|"'\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'lines'
op|'['
number|'0'
op|']'
op|','
string|'"GET /foo HTTP/1.1"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'lines'
op|'['
op|'-'
number|'2'
op|':'
op|']'
op|','
op|'['
string|'""'
op|','
string|'""'
op|']'
op|')'
newline|'\n'
name|'del'
name|'lines'
op|'['
number|'0'
op|']'
op|','
name|'lines'
op|'['
op|'-'
number|'2'
op|':'
op|']'
newline|'\n'
name|'lines'
op|'.'
name|'sort'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'lines'
op|','
nl|'\n'
op|'['
string|'"Connection: close"'
op|','
nl|'\n'
string|'"Host: example.com"'
op|','
nl|'\n'
string|'"X-Foo: bar"'
op|','
nl|'\n'
string|'"X-Foo: baz"'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_sendChunkedRequestBody
dedent|''
name|'def'
name|'test_sendChunkedRequestBody'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Request.writeTo} uses chunked encoding to write data from the request\n        body producer to the given transport.  It registers the request body\n        producer with the transport.\n        """'
newline|'\n'
name|'producer'
op|'='
name|'StringProducer'
op|'('
name|'UNKNOWN_LENGTH'
op|')'
newline|'\n'
name|'request'
op|'='
name|'Request'
op|'('
string|"'POST'"
op|','
string|"'/bar'"
op|','
name|'_boringHeaders'
op|','
name|'producer'
op|')'
newline|'\n'
name|'request'
op|'.'
name|'writeTo'
op|'('
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertNotIdentical'
op|'('
name|'producer'
op|'.'
name|'consumer'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'producer'
op|','
name|'producer'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'streaming'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
nl|'\n'
string|'"POST /bar HTTP/1.1\\r\\n"'
nl|'\n'
string|'"Connection: close\\r\\n"'
nl|'\n'
string|'"Transfer-Encoding: chunked\\r\\n"'
nl|'\n'
string|'"Host: example.com\\r\\n"'
nl|'\n'
string|'"\\r\\n"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'clear'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'producer'
op|'.'
name|'consumer'
op|'.'
name|'write'
op|'('
string|"'x'"
op|'*'
number|'3'
op|')'
newline|'\n'
name|'producer'
op|'.'
name|'consumer'
op|'.'
name|'write'
op|'('
string|"'y'"
op|'*'
number|'15'
op|')'
newline|'\n'
name|'producer'
op|'.'
name|'finished'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'producer'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
nl|'\n'
string|'"3\\r\\n"'
nl|'\n'
string|'"xxx\\r\\n"'
nl|'\n'
string|'"f\\r\\n"'
nl|'\n'
string|'"yyyyyyyyyyyyyyy\\r\\n"'
nl|'\n'
string|'"0\\r\\n"'
nl|'\n'
string|'"\\r\\n"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_sendChunkedRequestBodyWithError
dedent|''
name|'def'
name|'test_sendChunkedRequestBodyWithError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If L{Request} is created with a C{bodyProducer} without a known length\n        and the L{Deferred} returned from its C{startProducing} method fires\n        with a L{Failure}, the L{Deferred} returned by L{Request.writeTo} fires\n        with that L{Failure} and the body producer is unregistered from the\n        transport.  The final zero-length chunk is not written to the\n        transport.\n        """'
newline|'\n'
name|'producer'
op|'='
name|'StringProducer'
op|'('
name|'UNKNOWN_LENGTH'
op|')'
newline|'\n'
name|'request'
op|'='
name|'Request'
op|'('
string|"'POST'"
op|','
string|"'/bar'"
op|','
name|'_boringHeaders'
op|','
name|'producer'
op|')'
newline|'\n'
name|'writeDeferred'
op|'='
name|'request'
op|'.'
name|'writeTo'
op|'('
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'clear'
op|'('
op|')'
newline|'\n'
name|'producer'
op|'.'
name|'finished'
op|'.'
name|'errback'
op|'('
name|'ArbitraryException'
op|'('
op|')'
op|')'
newline|'\n'
DECL|function|cbFailed
name|'def'
name|'cbFailed'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|'""'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'producer'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'='
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'writeDeferred'
op|','
name|'ArbitraryException'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'cbFailed'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_sendRequestBodyWithLength
dedent|''
name|'def'
name|'test_sendRequestBodyWithLength'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If L{Request} is created with a C{bodyProducer} with a known length,\n        that length is sent as the value for the I{Content-Length} header and\n        chunked encoding is not used.\n        """'
newline|'\n'
name|'producer'
op|'='
name|'StringProducer'
op|'('
number|'3'
op|')'
newline|'\n'
name|'request'
op|'='
name|'Request'
op|'('
string|"'POST'"
op|','
string|"'/bar'"
op|','
name|'_boringHeaders'
op|','
name|'producer'
op|')'
newline|'\n'
name|'request'
op|'.'
name|'writeTo'
op|'('
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertNotIdentical'
op|'('
name|'producer'
op|'.'
name|'consumer'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'producer'
op|','
name|'producer'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'streaming'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
nl|'\n'
string|'"POST /bar HTTP/1.1\\r\\n"'
nl|'\n'
string|'"Connection: close\\r\\n"'
nl|'\n'
string|'"Content-Length: 3\\r\\n"'
nl|'\n'
string|'"Host: example.com\\r\\n"'
nl|'\n'
string|'"\\r\\n"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'clear'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'producer'
op|'.'
name|'consumer'
op|'.'
name|'write'
op|'('
string|"'abc'"
op|')'
newline|'\n'
name|'producer'
op|'.'
name|'finished'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'producer'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|'"abc"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_sendRequestBodyWithTooFewBytes
dedent|''
name|'def'
name|'test_sendRequestBodyWithTooFewBytes'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If L{Request} is created with a C{bodyProducer} with a known length and\n        the producer does not produce that many bytes, the L{Deferred} returned\n        by L{Request.writeTo} fires with a L{Failure} wrapping a\n        L{WrongBodyLength} exception.\n        """'
newline|'\n'
name|'producer'
op|'='
name|'StringProducer'
op|'('
number|'3'
op|')'
newline|'\n'
name|'request'
op|'='
name|'Request'
op|'('
string|"'POST'"
op|','
string|"'/bar'"
op|','
name|'_boringHeaders'
op|','
name|'producer'
op|')'
newline|'\n'
name|'writeDeferred'
op|'='
name|'request'
op|'.'
name|'writeTo'
op|'('
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
name|'producer'
op|'.'
name|'consumer'
op|'.'
name|'write'
op|'('
string|"'ab'"
op|')'
newline|'\n'
name|'producer'
op|'.'
name|'finished'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'producer'
op|','
name|'None'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'writeDeferred'
op|','
name|'WrongBodyLength'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_sendRequestBodyWithTooManyBytesTest
dedent|''
name|'def'
name|'_sendRequestBodyWithTooManyBytesTest'
op|'('
name|'self'
op|','
name|'finisher'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that when too many bytes have been written by a body producer\n        and then the body producer\'s C{startProducing} L{Deferred} fires that\n        the producer is unregistered from the transport and that the\n        L{Deferred} returned from L{Request.writeTo} is fired with a L{Failure}\n        wrapping a L{WrongBodyLength}.\n\n        @param finisher: A callable which will be invoked with the body\n            producer after too many bytes have been written to the transport.\n            It should fire the startProducing Deferred somehow.\n        """'
newline|'\n'
name|'producer'
op|'='
name|'StringProducer'
op|'('
number|'3'
op|')'
newline|'\n'
name|'request'
op|'='
name|'Request'
op|'('
string|"'POST'"
op|','
string|"'/bar'"
op|','
name|'_boringHeaders'
op|','
name|'producer'
op|')'
newline|'\n'
name|'writeDeferred'
op|'='
name|'request'
op|'.'
name|'writeTo'
op|'('
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
nl|'\n'
name|'producer'
op|'.'
name|'consumer'
op|'.'
name|'write'
op|'('
string|"'ab'"
op|')'
newline|'\n'
nl|'\n'
comment|"# The producer hasn't misbehaved yet, so it shouldn't have been"
nl|'\n'
comment|'# stopped.'
nl|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'producer'
op|'.'
name|'stopped'
op|')'
newline|'\n'
nl|'\n'
name|'producer'
op|'.'
name|'consumer'
op|'.'
name|'write'
op|'('
string|"'cd'"
op|')'
newline|'\n'
nl|'\n'
comment|'# Now the producer *has* misbehaved, so we should have tried to'
nl|'\n'
comment|'# make it stop.'
nl|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'producer'
op|'.'
name|'stopped'
op|')'
newline|'\n'
nl|'\n'
comment|'# The transport should have had the producer unregistered from it as'
nl|'\n'
comment|'# well.'
nl|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'producer'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
DECL|function|cbFailed
name|'def'
name|'cbFailed'
op|'('
name|'exc'
op|')'
op|':'
newline|'\n'
comment|'# The "cd" should not have been written to the transport because'
nl|'\n'
comment|'# the request can now locally be recognized to be invalid.  If we'
nl|'\n'
comment|'# had written the extra bytes, the server could have decided to'
nl|'\n'
comment|"# start processing the request, which would be bad since we're"
nl|'\n'
comment|'# going to indicate failure locally.'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
nl|'\n'
string|'"POST /bar HTTP/1.1\\r\\n"'
nl|'\n'
string|'"Connection: close\\r\\n"'
nl|'\n'
string|'"Content-Length: 3\\r\\n"'
nl|'\n'
string|'"Host: example.com\\r\\n"'
nl|'\n'
string|'"\\r\\n"'
nl|'\n'
string|'"ab"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'clear'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Subsequent writes should be ignored, as should firing the'
nl|'\n'
comment|'# Deferred returned from startProducing.'
nl|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'ExcessWrite'
op|','
name|'producer'
op|'.'
name|'consumer'
op|'.'
name|'write'
op|','
string|"'ef'"
op|')'
newline|'\n'
nl|'\n'
comment|'# Likewise, if the Deferred returned from startProducing fires,'
nl|'\n'
comment|'# this should more or less be ignored (aside from possibly logging'
nl|'\n'
comment|'# an error).'
nl|'\n'
name|'finisher'
op|'('
name|'producer'
op|')'
newline|'\n'
nl|'\n'
comment|'# There should have been nothing further written to the transport.'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|'""'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'d'
op|'='
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'writeDeferred'
op|','
name|'WrongBodyLength'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'cbFailed'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_sendRequestBodyWithTooManyBytes
dedent|''
name|'def'
name|'test_sendRequestBodyWithTooManyBytes'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If L{Request} is created with a C{bodyProducer} with a known length and\n        the producer tries to produce more than than many bytes, the\n        L{Deferred} returned by L{Request.writeTo} fires with a L{Failure}\n        wrapping a L{WrongBodyLength} exception.\n        """'
newline|'\n'
DECL|function|finisher
name|'def'
name|'finisher'
op|'('
name|'producer'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'producer'
op|'.'
name|'finished'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_sendRequestBodyWithTooManyBytesTest'
op|'('
name|'finisher'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_sendRequestBodyErrorWithTooManyBytes
dedent|''
name|'def'
name|'test_sendRequestBodyErrorWithTooManyBytes'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If L{Request} is created with a C{bodyProducer} with a known length and\n        the producer tries to produce more than than many bytes, the\n        L{Deferred} returned by L{Request.writeTo} fires with a L{Failure}\n        wrapping a L{WrongBodyLength} exception.\n        """'
newline|'\n'
DECL|function|finisher
name|'def'
name|'finisher'
op|'('
name|'producer'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'producer'
op|'.'
name|'finished'
op|'.'
name|'errback'
op|'('
name|'ArbitraryException'
op|'('
op|')'
op|')'
newline|'\n'
name|'errors'
op|'='
name|'self'
op|'.'
name|'flushLoggedErrors'
op|'('
name|'ArbitraryException'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'len'
op|'('
name|'errors'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_sendRequestBodyWithTooManyBytesTest'
op|'('
name|'finisher'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_sendRequestBodyErrorWithConsumerError
dedent|''
name|'def'
name|'test_sendRequestBodyErrorWithConsumerError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Though there should be no way for the internal C{finishedConsuming}\n        L{Deferred} in L{Request._writeToContentLength} to fire a L{Failure}\n        after the C{finishedProducing} L{Deferred} has fired, in case this does\n        happen, the error should be logged with a message about how there\'s\n        probably a bug in L{Request}.\n\n        This is a whitebox test.\n        """'
newline|'\n'
name|'producer'
op|'='
name|'StringProducer'
op|'('
number|'3'
op|')'
newline|'\n'
name|'request'
op|'='
name|'Request'
op|'('
string|"'POST'"
op|','
string|"'/bar'"
op|','
name|'_boringHeaders'
op|','
name|'producer'
op|')'
newline|'\n'
name|'writeDeferred'
op|'='
name|'request'
op|'.'
name|'writeTo'
op|'('
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
nl|'\n'
name|'finishedConsuming'
op|'='
name|'producer'
op|'.'
name|'consumer'
op|'.'
name|'_finished'
newline|'\n'
nl|'\n'
name|'producer'
op|'.'
name|'consumer'
op|'.'
name|'write'
op|'('
string|"'abc'"
op|')'
newline|'\n'
name|'producer'
op|'.'
name|'finished'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'finishedConsuming'
op|'.'
name|'errback'
op|'('
name|'ArbitraryException'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'flushLoggedErrors'
op|'('
name|'ArbitraryException'
op|')'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_sendRequestBodyFinishedEarlyThenTooManyBytes
dedent|''
name|'def'
name|'_sendRequestBodyFinishedEarlyThenTooManyBytes'
op|'('
name|'self'
op|','
name|'finisher'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that if the body producer fires its Deferred and then keeps\n        writing to the consumer that the extra writes are ignored and the\n        L{Deferred} returned by L{Request.writeTo} fires with a L{Failure}\n        wrapping the most appropriate exception type.\n        """'
newline|'\n'
name|'producer'
op|'='
name|'StringProducer'
op|'('
number|'3'
op|')'
newline|'\n'
name|'request'
op|'='
name|'Request'
op|'('
string|"'POST'"
op|','
string|"'/bar'"
op|','
name|'_boringHeaders'
op|','
name|'producer'
op|')'
newline|'\n'
name|'writeDeferred'
op|'='
name|'request'
op|'.'
name|'writeTo'
op|'('
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
nl|'\n'
name|'producer'
op|'.'
name|'consumer'
op|'.'
name|'write'
op|'('
string|"'ab'"
op|')'
newline|'\n'
name|'finisher'
op|'('
name|'producer'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'producer'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'clear'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'ExcessWrite'
op|','
name|'producer'
op|'.'
name|'consumer'
op|'.'
name|'write'
op|','
string|"'cd'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|'""'
op|')'
newline|'\n'
name|'return'
name|'writeDeferred'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_sendRequestBodyFinishedEarlyThenTooManyBytes
dedent|''
name|'def'
name|'test_sendRequestBodyFinishedEarlyThenTooManyBytes'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the request body producer indicates it is done by firing the\n        L{Deferred} returned from its C{startProducing} method but then goes on\n        to write too many bytes, the L{Deferred} returned by {Request.writeTo}\n        fires with a L{Failure} wrapping L{WrongBodyLength}.\n        """'
newline|'\n'
DECL|function|finisher
name|'def'
name|'finisher'
op|'('
name|'producer'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'producer'
op|'.'
name|'finished'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_sendRequestBodyFinishedEarlyThenTooManyBytes'
op|'('
name|'finisher'
op|')'
op|','
nl|'\n'
name|'WrongBodyLength'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_sendRequestBodyErroredEarlyThenTooManyBytes
dedent|''
name|'def'
name|'test_sendRequestBodyErroredEarlyThenTooManyBytes'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the request body producer indicates an error by firing the\n        L{Deferred} returned from its C{startProducing} method but then goes on\n        to write too many bytes, the L{Deferred} returned by {Request.writeTo}\n        fires with that L{Failure} and L{WrongBodyLength} is logged.\n        """'
newline|'\n'
DECL|function|finisher
name|'def'
name|'finisher'
op|'('
name|'producer'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'producer'
op|'.'
name|'finished'
op|'.'
name|'errback'
op|'('
name|'ArbitraryException'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_sendRequestBodyFinishedEarlyThenTooManyBytes'
op|'('
name|'finisher'
op|')'
op|','
nl|'\n'
name|'ArbitraryException'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_sendChunkedRequestBodyFinishedThenWriteMore
dedent|''
name|'def'
name|'test_sendChunkedRequestBodyFinishedThenWriteMore'
op|'('
name|'self'
op|','
name|'_with'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the request body producer with an unknown length tries to write\n        after firing the L{Deferred} returned by its C{startProducing} method,\n        the C{write} call raises an exception and does not write anything to\n        the underlying transport.\n        """'
newline|'\n'
name|'producer'
op|'='
name|'StringProducer'
op|'('
name|'UNKNOWN_LENGTH'
op|')'
newline|'\n'
name|'request'
op|'='
name|'Request'
op|'('
string|"'POST'"
op|','
string|"'/bar'"
op|','
name|'_boringHeaders'
op|','
name|'producer'
op|')'
newline|'\n'
name|'writeDeferred'
op|'='
name|'request'
op|'.'
name|'writeTo'
op|'('
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
name|'producer'
op|'.'
name|'finished'
op|'.'
name|'callback'
op|'('
name|'_with'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'clear'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'ExcessWrite'
op|','
name|'producer'
op|'.'
name|'consumer'
op|'.'
name|'write'
op|','
string|"'foo'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|'""'
op|')'
newline|'\n'
name|'return'
name|'writeDeferred'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_sendChunkedRequestBodyFinishedWithErrorThenWriteMore
dedent|''
name|'def'
name|'test_sendChunkedRequestBodyFinishedWithErrorThenWriteMore'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the request body producer with an unknown length tries to write\n        after firing the L{Deferred} returned by its C{startProducing} method\n        with a L{Failure}, the C{write} call raises an exception and does not\n        write anything to the underlying transport.\n        """'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'test_sendChunkedRequestBodyFinishedThenWriteMore'
op|'('
nl|'\n'
name|'Failure'
op|'('
name|'ArbitraryException'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'ArbitraryException'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_sendRequestBodyWithError
dedent|''
name|'def'
name|'test_sendRequestBodyWithError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the L{Deferred} returned from the C{startProducing} method of the\n        L{IBodyProducer} passed to L{Request} fires with a L{Failure}, the\n        L{Deferred} returned from L{Request.writeTo} fails with that\n        L{Failure}.\n        """'
newline|'\n'
name|'producer'
op|'='
name|'StringProducer'
op|'('
number|'5'
op|')'
newline|'\n'
name|'request'
op|'='
name|'Request'
op|'('
string|"'POST'"
op|','
string|"'/bar'"
op|','
name|'_boringHeaders'
op|','
name|'producer'
op|')'
newline|'\n'
name|'writeDeferred'
op|'='
name|'request'
op|'.'
name|'writeTo'
op|'('
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
nl|'\n'
comment|'# Sanity check - the producer should be registered with the underlying'
nl|'\n'
comment|'# transport.'
nl|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'producer'
op|','
name|'producer'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'streaming'
op|')'
newline|'\n'
nl|'\n'
name|'producer'
op|'.'
name|'consumer'
op|'.'
name|'write'
op|'('
string|"'ab'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
nl|'\n'
string|'"POST /bar HTTP/1.1\\r\\n"'
nl|'\n'
string|'"Connection: close\\r\\n"'
nl|'\n'
string|'"Content-Length: 5\\r\\n"'
nl|'\n'
string|'"Host: example.com\\r\\n"'
nl|'\n'
string|'"\\r\\n"'
nl|'\n'
string|'"ab"'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'disconnecting'
op|')'
newline|'\n'
name|'producer'
op|'.'
name|'finished'
op|'.'
name|'errback'
op|'('
name|'Failure'
op|'('
name|'ArbitraryException'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Disconnection is handled by a higher level.  Request should leave the'
nl|'\n'
comment|'# transport alone in this case.'
nl|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'disconnecting'
op|')'
newline|'\n'
nl|'\n'
comment|'# Oh.  Except it should unregister the producer that it registered.'
nl|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'producer'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'writeDeferred'
op|','
name|'ArbitraryException'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_hostHeaderRequired
dedent|''
name|'def'
name|'test_hostHeaderRequired'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Request.writeTo} raises L{BadHeaders} if there is not exactly one\n        I{Host} header and writes nothing to the given transport.\n        """'
newline|'\n'
name|'request'
op|'='
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'Headers'
op|'('
op|'{'
op|'}'
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'BadHeaders'
op|','
name|'request'
op|'.'
name|'writeTo'
op|','
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|"''"
op|')'
newline|'\n'
nl|'\n'
name|'request'
op|'='
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'Headers'
op|'('
op|'{'
string|"'Host'"
op|':'
op|'['
string|"'example.com'"
op|','
string|"'example.org'"
op|']'
op|'}'
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'BadHeaders'
op|','
name|'request'
op|'.'
name|'writeTo'
op|','
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|"''"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_stopWriting
dedent|''
name|'def'
name|'test_stopWriting'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Request.stopWriting} calls its body producer\'s C{stopProducing}\n        method.\n        """'
newline|'\n'
name|'producer'
op|'='
name|'StringProducer'
op|'('
number|'3'
op|')'
newline|'\n'
name|'request'
op|'='
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'producer'
op|')'
newline|'\n'
name|'d'
op|'='
name|'request'
op|'.'
name|'writeTo'
op|'('
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'producer'
op|'.'
name|'stopped'
op|')'
newline|'\n'
name|'request'
op|'.'
name|'stopWriting'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'producer'
op|'.'
name|'stopped'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_brokenStopProducing
dedent|''
name|'def'
name|'test_brokenStopProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the body producer\'s C{stopProducing} method raises an exception,\n        L{Request.stopWriting} logs it and does not re-raise it.\n        """'
newline|'\n'
name|'producer'
op|'='
name|'StringProducer'
op|'('
number|'3'
op|')'
newline|'\n'
DECL|function|brokenStopProducing
name|'def'
name|'brokenStopProducing'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ArbitraryException'
op|'('
string|'"stopProducing is busted"'
op|')'
newline|'\n'
dedent|''
name|'producer'
op|'.'
name|'stopProducing'
op|'='
name|'brokenStopProducing'
newline|'\n'
nl|'\n'
name|'request'
op|'='
name|'Request'
op|'('
string|"'GET'"
op|','
string|"'/'"
op|','
name|'_boringHeaders'
op|','
name|'producer'
op|')'
newline|'\n'
name|'d'
op|'='
name|'request'
op|'.'
name|'writeTo'
op|'('
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
name|'request'
op|'.'
name|'stopWriting'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'len'
op|'('
name|'self'
op|'.'
name|'flushLoggedErrors'
op|'('
name|'ArbitraryException'
op|')'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|LengthEnforcingConsumerTests
dedent|''
dedent|''
name|'class'
name|'LengthEnforcingConsumerTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{LengthEnforcingConsumer}.\n    """'
newline|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'result'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'producer'
op|'='
name|'StringProducer'
op|'('
number|'10'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enforcer'
op|'='
name|'LengthEnforcingConsumer'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'producer'
op|','
name|'self'
op|'.'
name|'transport'
op|','
name|'self'
op|'.'
name|'result'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_write
dedent|''
name|'def'
name|'test_write'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{LengthEnforcingConsumer.write} calls the wrapped consumer\'s C{write}\n        method with the bytes it is passed as long as there are fewer of them\n        than the C{length} attribute indicates remain to be received.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'enforcer'
op|'.'
name|'write'
op|'('
string|"'abc'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|"'abc'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'clear'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enforcer'
op|'.'
name|'write'
op|'('
string|"'def'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|"'def'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_finishedEarly
dedent|''
name|'def'
name|'test_finishedEarly'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{LengthEnforcingConsumer._noMoreWritesExpected} raises\n        L{WrongBodyLength} if it is called before the indicated number of bytes\n        have been written.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'enforcer'
op|'.'
name|'write'
op|'('
string|"'x'"
op|'*'
number|'9'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'WrongBodyLength'
op|','
name|'self'
op|'.'
name|'enforcer'
op|'.'
name|'_noMoreWritesExpected'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_writeTooMany
dedent|''
name|'def'
name|'test_writeTooMany'
op|'('
name|'self'
op|','
name|'_unregisterAfter'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If it is called with a total number of bytes exceeding the indicated\n        limit passed to L{LengthEnforcingConsumer.__init__},\n        L{LengthEnforcingConsumer.write} fires the L{Deferred} with a\n        L{Failure} wrapping a L{WrongBodyLength} and also calls the\n        C{stopProducing} method of the producer.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'enforcer'
op|'.'
name|'write'
op|'('
string|"'x'"
op|'*'
number|'10'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'self'
op|'.'
name|'producer'
op|'.'
name|'stopped'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enforcer'
op|'.'
name|'write'
op|'('
string|"'x'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'producer'
op|'.'
name|'stopped'
op|')'
newline|'\n'
name|'if'
name|'_unregisterAfter'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'enforcer'
op|'.'
name|'_noMoreWritesExpected'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'self'
op|'.'
name|'result'
op|','
name|'WrongBodyLength'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_writeAfterNoMoreExpected
dedent|''
name|'def'
name|'test_writeAfterNoMoreExpected'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If L{LengthEnforcingConsumer.write} is called after\n        L{LengthEnforcingConsumer._noMoreWritesExpected}, it calls the\n        producer\'s C{stopProducing} method and raises L{ExcessWrite}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'enforcer'
op|'.'
name|'write'
op|'('
string|"'x'"
op|'*'
number|'10'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enforcer'
op|'.'
name|'_noMoreWritesExpected'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'self'
op|'.'
name|'producer'
op|'.'
name|'stopped'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'ExcessWrite'
op|','
name|'self'
op|'.'
name|'enforcer'
op|'.'
name|'write'
op|','
string|"'x'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'producer'
op|'.'
name|'stopped'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_finishedLate
dedent|''
name|'def'
name|'test_finishedLate'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{LengthEnforcingConsumer._noMoreWritesExpected} does nothing (in\n        particular, it does not raise any exception) if called after too many\n        bytes have been passed to C{write}.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'test_writeTooMany'
op|'('
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_finished
dedent|''
name|'def'
name|'test_finished'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If L{LengthEnforcingConsumer._noMoreWritesExpected} is called after\n        the correct number of bytes have been written it returns C{None}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'enforcer'
op|'.'
name|'write'
op|'('
string|"'x'"
op|'*'
number|'10'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'self'
op|'.'
name|'enforcer'
op|'.'
name|'_noMoreWritesExpected'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_stopProducingRaises
dedent|''
name|'def'
name|'test_stopProducingRaises'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If L{LengthEnforcingConsumer.write} calls the producer\'s\n        C{stopProducing} because too many bytes were written and the\n        C{stopProducing} method raises an exception, the exception is logged\n        and the L{LengthEnforcingConsumer} still errbacks the finished\n        L{Deferred}.\n        """'
newline|'\n'
DECL|function|brokenStopProducing
name|'def'
name|'brokenStopProducing'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'StringProducer'
op|'.'
name|'stopProducing'
op|'('
name|'self'
op|'.'
name|'producer'
op|')'
newline|'\n'
name|'raise'
name|'ArbitraryException'
op|'('
string|'"stopProducing is busted"'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'producer'
op|'.'
name|'stopProducing'
op|'='
name|'brokenStopProducing'
newline|'\n'
nl|'\n'
DECL|function|cbFinished
name|'def'
name|'cbFinished'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'len'
op|'('
name|'self'
op|'.'
name|'flushLoggedErrors'
op|'('
name|'ArbitraryException'
op|')'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'='
name|'self'
op|'.'
name|'test_writeTooMany'
op|'('
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'cbFinished'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|RequestBodyConsumerTests
dedent|''
dedent|''
name|'class'
name|'RequestBodyConsumerTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{ChunkedEncoder} which sits between an L{ITransport} and a\n    request/response body producer and chunked encodes everything written to\n    it.\n    """'
newline|'\n'
DECL|member|test_interface
name|'def'
name|'test_interface'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{ChunkedEncoder} instances provide L{IConsumer}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
nl|'\n'
name|'verifyObject'
op|'('
name|'IConsumer'
op|','
name|'ChunkedEncoder'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_write
dedent|''
name|'def'
name|'test_write'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{ChunkedEncoder.write} writes to the transport the chunked encoded\n        form of the bytes passed to it.\n        """'
newline|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'encoder'
op|'='
name|'ChunkedEncoder'
op|'('
name|'transport'
op|')'
newline|'\n'
name|'encoder'
op|'.'
name|'write'
op|'('
string|"'foo'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|"'3\\r\\nfoo\\r\\n'"
op|')'
newline|'\n'
name|'transport'
op|'.'
name|'clear'
op|'('
op|')'
newline|'\n'
name|'encoder'
op|'.'
name|'write'
op|'('
string|"'x'"
op|'*'
number|'16'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|"'10\\r\\n'"
op|'+'
string|"'x'"
op|'*'
number|'16'
op|'+'
string|"'\\r\\n'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_producerRegistration
dedent|''
name|'def'
name|'test_producerRegistration'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{ChunkedEncoder.registerProducer} registers the given streaming\n        producer with its transport and L{ChunkedEncoder.unregisterProducer}\n        writes a zero-length chunk to its transport and unregisters the\n        transport\'s producer.\n        """'
newline|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'producer'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
name|'encoder'
op|'='
name|'ChunkedEncoder'
op|'('
name|'transport'
op|')'
newline|'\n'
name|'encoder'
op|'.'
name|'registerProducer'
op|'('
name|'producer'
op|','
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'transport'
op|'.'
name|'producer'
op|','
name|'producer'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'transport'
op|'.'
name|'streaming'
op|')'
newline|'\n'
name|'encoder'
op|'.'
name|'unregisterProducer'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'transport'
op|'.'
name|'producer'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|"'0\\r\\n\\r\\n'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TransportProxyProducerTests
dedent|''
dedent|''
name|'class'
name|'TransportProxyProducerTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{TransportProxyProducer} which proxies the L{IPushProducer}\n    interface of a transport.\n    """'
newline|'\n'
DECL|member|test_interface
name|'def'
name|'test_interface'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{TransportProxyProducer} instances provide L{IPushProducer}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
nl|'\n'
name|'verifyObject'
op|'('
name|'IPushProducer'
op|','
name|'TransportProxyProducer'
op|'('
name|'None'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_stopProxyingUnreferencesProducer
dedent|''
name|'def'
name|'test_stopProxyingUnreferencesProducer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{TransportProxyProducer._stopProxying} drops the reference to the\n        wrapped L{IPushProducer} provider.\n        """'
newline|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'proxy'
op|'='
name|'TransportProxyProducer'
op|'('
name|'transport'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'proxy'
op|'.'
name|'_producer'
op|','
name|'transport'
op|')'
newline|'\n'
name|'proxy'
op|'.'
name|'_stopProxying'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'proxy'
op|'.'
name|'_producer'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_resumeProducing
dedent|''
name|'def'
name|'test_resumeProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{TransportProxyProducer.resumeProducing} calls the wrapped\n        transport\'s C{resumeProducing} method unless told to stop proxying.\n        """'
newline|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'transport'
op|'.'
name|'pauseProducing'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'proxy'
op|'='
name|'TransportProxyProducer'
op|'('
name|'transport'
op|')'
newline|'\n'
comment|'# The transport should still be paused.'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'transport'
op|'.'
name|'producerState'
op|','
string|"'paused'"
op|')'
newline|'\n'
name|'proxy'
op|'.'
name|'resumeProducing'
op|'('
op|')'
newline|'\n'
comment|'# The transport should now be resumed.'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'transport'
op|'.'
name|'producerState'
op|','
string|"'producing'"
op|')'
newline|'\n'
nl|'\n'
name|'transport'
op|'.'
name|'pauseProducing'
op|'('
op|')'
newline|'\n'
name|'proxy'
op|'.'
name|'_stopProxying'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# The proxy should no longer do anything to the transport.'
nl|'\n'
name|'proxy'
op|'.'
name|'resumeProducing'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'transport'
op|'.'
name|'producerState'
op|','
string|"'paused'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_pauseProducing
dedent|''
name|'def'
name|'test_pauseProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{TransportProxyProducer.pauseProducing} calls the wrapped transport\'s\n        C{pauseProducing} method unless told to stop proxying.\n        """'
newline|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'proxy'
op|'='
name|'TransportProxyProducer'
op|'('
name|'transport'
op|')'
newline|'\n'
comment|'# The transport should still be producing.'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'transport'
op|'.'
name|'producerState'
op|','
string|"'producing'"
op|')'
newline|'\n'
name|'proxy'
op|'.'
name|'pauseProducing'
op|'('
op|')'
newline|'\n'
comment|'# The transport should now be paused.'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'transport'
op|'.'
name|'producerState'
op|','
string|"'paused'"
op|')'
newline|'\n'
nl|'\n'
name|'transport'
op|'.'
name|'resumeProducing'
op|'('
op|')'
newline|'\n'
name|'proxy'
op|'.'
name|'_stopProxying'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# The proxy should no longer do anything to the transport.'
nl|'\n'
name|'proxy'
op|'.'
name|'pauseProducing'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'transport'
op|'.'
name|'producerState'
op|','
string|"'producing'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_stopProducing
dedent|''
name|'def'
name|'test_stopProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{TransportProxyProducer.stopProducing} calls the wrapped transport\'s\n        C{stopProducing} method unless told to stop proxying.\n        """'
newline|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'proxy'
op|'='
name|'TransportProxyProducer'
op|'('
name|'transport'
op|')'
newline|'\n'
comment|'# The transport should still be producing.'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'transport'
op|'.'
name|'producerState'
op|','
string|"'producing'"
op|')'
newline|'\n'
name|'proxy'
op|'.'
name|'stopProducing'
op|'('
op|')'
newline|'\n'
comment|'# The transport should now be stopped.'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'transport'
op|'.'
name|'producerState'
op|','
string|"'stopped'"
op|')'
newline|'\n'
nl|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'proxy'
op|'='
name|'TransportProxyProducer'
op|'('
name|'transport'
op|')'
newline|'\n'
name|'proxy'
op|'.'
name|'_stopProxying'
op|'('
op|')'
newline|'\n'
name|'proxy'
op|'.'
name|'stopProducing'
op|'('
op|')'
newline|'\n'
comment|'# The transport should not have been stopped.'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'transport'
op|'.'
name|'producerState'
op|','
string|"'producing'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ResponseTests
dedent|''
dedent|''
name|'class'
name|'ResponseTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{Response}.\n    """'
newline|'\n'
DECL|member|test_makeConnection
name|'def'
name|'test_makeConnection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The L{IProtocol} provider passed to L{Response.deliverBody} has its\n        C{makeConnection} method called with an L{IPushProducer} provider\n        hooked up to the response as an argument.\n        """'
newline|'\n'
name|'producers'
op|'='
op|'['
op|']'
newline|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
DECL|class|SomeProtocol
name|'class'
name|'SomeProtocol'
op|'('
name|'Protocol'
op|')'
op|':'
newline|'\n'
DECL|member|makeConnection
indent|'            '
name|'def'
name|'makeConnection'
op|'('
name|'self'
op|','
name|'producer'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'producers'
op|'.'
name|'append'
op|'('
name|'producer'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'consumer'
op|'='
name|'SomeProtocol'
op|'('
op|')'
newline|'\n'
name|'response'
op|'='
name|'justTransportResponse'
op|'('
name|'transport'
op|')'
newline|'\n'
name|'response'
op|'.'
name|'deliverBody'
op|'('
name|'consumer'
op|')'
newline|'\n'
op|'['
name|'theProducer'
op|']'
op|'='
name|'producers'
newline|'\n'
name|'theProducer'
op|'.'
name|'pauseProducing'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'transport'
op|'.'
name|'producerState'
op|','
string|"'paused'"
op|')'
newline|'\n'
name|'theProducer'
op|'.'
name|'resumeProducing'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'transport'
op|'.'
name|'producerState'
op|','
string|"'producing'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_dataReceived
dedent|''
name|'def'
name|'test_dataReceived'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The L{IProtocol} provider passed to L{Response.deliverBody} has its\n        C{dataReceived} method called with bytes received as part of the\n        response body.\n        """'
newline|'\n'
name|'bytes'
op|'='
op|'['
op|']'
newline|'\n'
DECL|class|ListConsumer
name|'class'
name|'ListConsumer'
op|'('
name|'Protocol'
op|')'
op|':'
newline|'\n'
DECL|member|dataReceived
indent|'            '
name|'def'
name|'dataReceived'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'bytes'
op|'.'
name|'append'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'consumer'
op|'='
name|'ListConsumer'
op|'('
op|')'
newline|'\n'
name|'response'
op|'='
name|'justTransportResponse'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'response'
op|'.'
name|'deliverBody'
op|'('
name|'consumer'
op|')'
newline|'\n'
nl|'\n'
name|'response'
op|'.'
name|'_bodyDataReceived'
op|'('
string|"'foo'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'bytes'
op|','
op|'['
string|"'foo'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_connectionLost
dedent|''
name|'def'
name|'test_connectionLost'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The L{IProtocol} provider passed to L{Response.deliverBody} has its\n        C{connectionLost} method called with a L{Failure} wrapping\n        L{ResponseDone} when the response\'s C{_bodyDataFinished} method is\n        called.\n        """'
newline|'\n'
name|'lost'
op|'='
op|'['
op|']'
newline|'\n'
DECL|class|ListConsumer
name|'class'
name|'ListConsumer'
op|'('
name|'Protocol'
op|')'
op|':'
newline|'\n'
DECL|member|connectionLost
indent|'            '
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'lost'
op|'.'
name|'append'
op|'('
name|'reason'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'consumer'
op|'='
name|'ListConsumer'
op|'('
op|')'
newline|'\n'
name|'response'
op|'='
name|'justTransportResponse'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'response'
op|'.'
name|'deliverBody'
op|'('
name|'consumer'
op|')'
newline|'\n'
nl|'\n'
name|'response'
op|'.'
name|'_bodyDataFinished'
op|'('
op|')'
newline|'\n'
name|'lost'
op|'['
number|'0'
op|']'
op|'.'
name|'trap'
op|'('
name|'ResponseDone'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'len'
op|'('
name|'lost'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
comment|'# The protocol reference should be dropped, too, to facilitate GC or'
nl|'\n'
comment|'# whatever.'
nl|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'response'
op|'.'
name|'_bodyProtocol'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_bufferEarlyData
dedent|''
name|'def'
name|'test_bufferEarlyData'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If data is delivered to the L{Response} before a protocol is registered\n        with C{deliverBody}, that data is buffered until the protocol is\n        registered and then is delivered.\n        """'
newline|'\n'
name|'bytes'
op|'='
op|'['
op|']'
newline|'\n'
DECL|class|ListConsumer
name|'class'
name|'ListConsumer'
op|'('
name|'Protocol'
op|')'
op|':'
newline|'\n'
DECL|member|dataReceived
indent|'            '
name|'def'
name|'dataReceived'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'bytes'
op|'.'
name|'append'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'protocol'
op|'='
name|'ListConsumer'
op|'('
op|')'
newline|'\n'
name|'response'
op|'='
name|'justTransportResponse'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'response'
op|'.'
name|'_bodyDataReceived'
op|'('
string|"'foo'"
op|')'
newline|'\n'
name|'response'
op|'.'
name|'_bodyDataReceived'
op|'('
string|"'bar'"
op|')'
newline|'\n'
name|'response'
op|'.'
name|'deliverBody'
op|'('
name|'protocol'
op|')'
newline|'\n'
name|'response'
op|'.'
name|'_bodyDataReceived'
op|'('
string|"'baz'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'bytes'
op|','
op|'['
string|"'foo'"
op|','
string|"'bar'"
op|','
string|"'baz'"
op|']'
op|')'
newline|'\n'
comment|'# Make sure the implementation-detail-byte-buffer is cleared because'
nl|'\n'
comment|'# not clearing it wastes memory.'
nl|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'response'
op|'.'
name|'_bodyBuffer'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_multipleStartProducingFails
dedent|''
name|'def'
name|'test_multipleStartProducingFails'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Response.deliverBody} raises L{RuntimeError} if called more than\n        once.\n        """'
newline|'\n'
name|'response'
op|'='
name|'justTransportResponse'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'response'
op|'.'
name|'deliverBody'
op|'('
name|'Protocol'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'RuntimeError'
op|','
name|'response'
op|'.'
name|'deliverBody'
op|','
name|'Protocol'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_startProducingAfterFinishedFails
dedent|''
name|'def'
name|'test_startProducingAfterFinishedFails'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Response.deliverBody} raises L{RuntimeError} if called after\n        L{Response._bodyDataFinished}.\n        """'
newline|'\n'
name|'response'
op|'='
name|'justTransportResponse'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'response'
op|'.'
name|'deliverBody'
op|'('
name|'Protocol'
op|'('
op|')'
op|')'
newline|'\n'
name|'response'
op|'.'
name|'_bodyDataFinished'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'RuntimeError'
op|','
name|'response'
op|'.'
name|'deliverBody'
op|','
name|'Protocol'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_bodyDataReceivedAfterFinishedFails
dedent|''
name|'def'
name|'test_bodyDataReceivedAfterFinishedFails'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Response._bodyDataReceived} raises L{RuntimeError} if called after\n        L{Response._bodyDataFinished} but before L{Response.deliverBody}.\n        """'
newline|'\n'
name|'response'
op|'='
name|'justTransportResponse'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'response'
op|'.'
name|'_bodyDataFinished'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'RuntimeError'
op|','
name|'response'
op|'.'
name|'_bodyDataReceived'
op|','
string|"'foo'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_bodyDataReceivedAfterDeliveryFails
dedent|''
name|'def'
name|'test_bodyDataReceivedAfterDeliveryFails'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Response._bodyDataReceived} raises L{RuntimeError} if called after\n        L{Response._bodyDataFinished} and after L{Response.deliverBody}.\n        """'
newline|'\n'
name|'response'
op|'='
name|'justTransportResponse'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'response'
op|'.'
name|'_bodyDataFinished'
op|'('
op|')'
newline|'\n'
name|'response'
op|'.'
name|'deliverBody'
op|'('
name|'Protocol'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'RuntimeError'
op|','
name|'response'
op|'.'
name|'_bodyDataReceived'
op|','
string|"'foo'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_bodyDataFinishedAfterFinishedFails
dedent|''
name|'def'
name|'test_bodyDataFinishedAfterFinishedFails'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Response._bodyDataFinished} raises L{RuntimeError} if called more\n        than once.\n        """'
newline|'\n'
name|'response'
op|'='
name|'justTransportResponse'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'response'
op|'.'
name|'_bodyDataFinished'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'RuntimeError'
op|','
name|'response'
op|'.'
name|'_bodyDataFinished'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_bodyDataFinishedAfterDeliveryFails
dedent|''
name|'def'
name|'test_bodyDataFinishedAfterDeliveryFails'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Response._bodyDataFinished} raises L{RuntimeError} if called after\n        the body has been delivered.\n        """'
newline|'\n'
name|'response'
op|'='
name|'justTransportResponse'
op|'('
name|'StringTransport'
op|'('
op|')'
op|')'
newline|'\n'
name|'response'
op|'.'
name|'_bodyDataFinished'
op|'('
op|')'
newline|'\n'
name|'response'
op|'.'
name|'deliverBody'
op|'('
name|'Protocol'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'RuntimeError'
op|','
name|'response'
op|'.'
name|'_bodyDataFinished'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_transportResumed
dedent|''
name|'def'
name|'test_transportResumed'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Response.deliverBody} resumes the HTTP connection\'s transport\n        before passing it to the transport\'s C{makeConnection} method.\n        """'
newline|'\n'
name|'transportState'
op|'='
op|'['
op|']'
newline|'\n'
DECL|class|ListConsumer
name|'class'
name|'ListConsumer'
op|'('
name|'Protocol'
op|')'
op|':'
newline|'\n'
DECL|member|makeConnection
indent|'            '
name|'def'
name|'makeConnection'
op|'('
name|'self'
op|','
name|'transport'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'transportState'
op|'.'
name|'append'
op|'('
name|'transport'
op|'.'
name|'producerState'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'transport'
op|'.'
name|'pauseProducing'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'='
name|'ListConsumer'
op|'('
op|')'
newline|'\n'
name|'response'
op|'='
name|'justTransportResponse'
op|'('
name|'transport'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'transport'
op|'.'
name|'producerState'
op|','
string|"'paused'"
op|')'
newline|'\n'
name|'response'
op|'.'
name|'deliverBody'
op|'('
name|'protocol'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'transportState'
op|','
op|'['
string|"'producing'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_bodyDataFinishedBeforeStartProducing
dedent|''
name|'def'
name|'test_bodyDataFinishedBeforeStartProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the entire body is delivered to the L{Response} before the\n        response\'s C{deliverBody} method is called, the protocol passed to\n        C{deliverBody} is immediately given the body data and then\n        disconnected.\n        """'
newline|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'response'
op|'='
name|'justTransportResponse'
op|'('
name|'transport'
op|')'
newline|'\n'
name|'response'
op|'.'
name|'_bodyDataReceived'
op|'('
string|"'foo'"
op|')'
newline|'\n'
name|'response'
op|'.'
name|'_bodyDataReceived'
op|'('
string|"'bar'"
op|')'
newline|'\n'
name|'response'
op|'.'
name|'_bodyDataFinished'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'protocol'
op|'='
name|'AccumulatingProtocol'
op|'('
op|')'
newline|'\n'
name|'response'
op|'.'
name|'deliverBody'
op|'('
name|'protocol'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'data'
op|','
string|"'foobar'"
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'closedReason'
op|'.'
name|'trap'
op|'('
name|'ResponseDone'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_finishedWithErrorWhenConnected
dedent|''
name|'def'
name|'test_finishedWithErrorWhenConnected'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The L{Failure} passed to L{Response._bodyDataFinished} when the response\n        is in the I{connected} state is passed to the C{connectionLost} method\n        of the L{IProtocol} provider passed to the L{Response}\'s\n        C{deliverBody} method.\n        """'
newline|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'response'
op|'='
name|'justTransportResponse'
op|'('
name|'transport'
op|')'
newline|'\n'
nl|'\n'
name|'protocol'
op|'='
name|'AccumulatingProtocol'
op|'('
op|')'
newline|'\n'
name|'response'
op|'.'
name|'deliverBody'
op|'('
name|'protocol'
op|')'
newline|'\n'
nl|'\n'
comment|'# Sanity check - this test is for the connected state'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'response'
op|'.'
name|'_state'
op|','
string|"'CONNECTED'"
op|')'
newline|'\n'
name|'response'
op|'.'
name|'_bodyDataFinished'
op|'('
name|'Failure'
op|'('
name|'ArbitraryException'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'protocol'
op|'.'
name|'closedReason'
op|'.'
name|'trap'
op|'('
name|'ArbitraryException'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_finishedWithErrorWhenInitial
dedent|''
name|'def'
name|'test_finishedWithErrorWhenInitial'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The L{Failure} passed to L{Response._bodyDataFinished} when the response\n        is in the I{initial} state is passed to the C{connectionLost} method of\n        the L{IProtocol} provider passed to the L{Response}\'s C{deliverBody}\n        method.\n        """'
newline|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'response'
op|'='
name|'justTransportResponse'
op|'('
name|'transport'
op|')'
newline|'\n'
nl|'\n'
comment|'# Sanity check - this test is for the initial state'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'response'
op|'.'
name|'_state'
op|','
string|"'INITIAL'"
op|')'
newline|'\n'
name|'response'
op|'.'
name|'_bodyDataFinished'
op|'('
name|'Failure'
op|'('
name|'ArbitraryException'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'protocol'
op|'='
name|'AccumulatingProtocol'
op|'('
op|')'
newline|'\n'
name|'response'
op|'.'
name|'deliverBody'
op|'('
name|'protocol'
op|')'
newline|'\n'
nl|'\n'
name|'protocol'
op|'.'
name|'closedReason'
op|'.'
name|'trap'
op|'('
name|'ArbitraryException'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
