begin_unit
comment|'# Copyright (c) 2001-2010 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTest HTTP support.\n"""'
newline|'\n'
nl|'\n'
name|'from'
name|'urlparse'
name|'import'
name|'urlparse'
op|','
name|'urlunsplit'
op|','
name|'clear_cache'
newline|'\n'
name|'import'
name|'random'
op|','
name|'urllib'
op|','
name|'cgi'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'compat'
name|'import'
name|'set'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'failure'
name|'import'
name|'Failure'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
op|'.'
name|'unittest'
name|'import'
name|'TestCase'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
name|'import'
name|'http'
op|','
name|'http_headers'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
op|'.'
name|'http'
name|'import'
name|'PotentialDataLoss'
op|','
name|'_DataLoss'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
op|'.'
name|'http'
name|'import'
name|'_IdentityTransferDecoder'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'protocols'
name|'import'
name|'loopback'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'task'
name|'import'
name|'Clock'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'error'
name|'import'
name|'ConnectionLost'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'test'
op|'.'
name|'proto_helpers'
name|'import'
name|'StringTransport'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'test'
op|'.'
name|'test_internet'
name|'import'
name|'DummyProducer'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
op|'.'
name|'test'
op|'.'
name|'test_web'
name|'import'
name|'DummyChannel'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DateTimeTest
name|'class'
name|'DateTimeTest'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Test date parsing functions."""'
newline|'\n'
nl|'\n'
DECL|member|testRoundtrip
name|'def'
name|'testRoundtrip'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
number|'10000'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'time'
op|'='
name|'random'
op|'.'
name|'randint'
op|'('
number|'0'
op|','
number|'2000000000'
op|')'
newline|'\n'
name|'timestr'
op|'='
name|'http'
op|'.'
name|'datetimeToString'
op|'('
name|'time'
op|')'
newline|'\n'
name|'time2'
op|'='
name|'http'
op|'.'
name|'stringToDatetime'
op|'('
name|'timestr'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'time'
op|','
name|'time2'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DummyHTTPHandler
dedent|''
dedent|''
dedent|''
name|'class'
name|'DummyHTTPHandler'
op|'('
name|'http'
op|'.'
name|'Request'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|process
indent|'    '
name|'def'
name|'process'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'content'
op|'.'
name|'seek'
op|'('
number|'0'
op|','
number|'0'
op|')'
newline|'\n'
name|'data'
op|'='
name|'self'
op|'.'
name|'content'
op|'.'
name|'read'
op|'('
op|')'
newline|'\n'
name|'length'
op|'='
name|'self'
op|'.'
name|'getHeader'
op|'('
string|"'content-length'"
op|')'
newline|'\n'
name|'request'
op|'='
string|'"\'\'\'\\n"'
op|'+'
name|'str'
op|'('
name|'length'
op|')'
op|'+'
string|'"\\n"'
op|'+'
name|'data'
op|'+'
string|'"\'\'\'\\n"'
newline|'\n'
name|'self'
op|'.'
name|'setResponseCode'
op|'('
number|'200'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'setHeader'
op|'('
string|'"Request"'
op|','
name|'self'
op|'.'
name|'uri'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'setHeader'
op|'('
string|'"Command"'
op|','
name|'self'
op|'.'
name|'method'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'setHeader'
op|'('
string|'"Version"'
op|','
name|'self'
op|'.'
name|'clientproto'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'setHeader'
op|'('
string|'"Content-Length"'
op|','
name|'len'
op|'('
name|'request'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'write'
op|'('
name|'request'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'finish'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|LoopbackHTTPClient
dedent|''
dedent|''
name|'class'
name|'LoopbackHTTPClient'
op|'('
name|'http'
op|'.'
name|'HTTPClient'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|connectionMade
indent|'    '
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'sendCommand'
op|'('
string|'"GET"'
op|','
string|'"/foo/bar"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'sendHeader'
op|'('
string|'"Content-Length"'
op|','
number|'10'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'endHeaders'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
string|'"0123456789"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ResponseTestMixin
dedent|''
dedent|''
name|'class'
name|'ResponseTestMixin'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A mixin that provides a simple means of comparing an actual response string\n    to an expected response string by performing the minimal parsing.\n    """'
newline|'\n'
nl|'\n'
DECL|member|assertResponseEquals
name|'def'
name|'assertResponseEquals'
op|'('
name|'self'
op|','
name|'responses'
op|','
name|'expected'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Assert that the C{responses} matches the C{expected} responses.\n\n        @type responses: C{str}\n        @param responses: The bytes sent in response to one or more requests.\n\n        @type expected: C{list} of C{tuple} of C{str}\n        @param expected: The expected values for the responses.  Each tuple\n            element of the list represents one response.  Each string element\n            of the tuple is a full header line without delimiter, except for\n            the last element which gives the full response body.\n        """'
newline|'\n'
name|'for'
name|'response'
name|'in'
name|'expected'
op|':'
newline|'\n'
indent|'            '
name|'expectedHeaders'
op|','
name|'expectedContent'
op|'='
name|'response'
op|'['
op|':'
op|'-'
number|'1'
op|']'
op|','
name|'response'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
name|'headers'
op|','
name|'rest'
op|'='
name|'responses'
op|'.'
name|'split'
op|'('
string|"'\\r\\n\\r\\n'"
op|','
number|'1'
op|')'
newline|'\n'
name|'headers'
op|'='
name|'headers'
op|'.'
name|'splitlines'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'set'
op|'('
name|'headers'
op|')'
op|','
name|'set'
op|'('
name|'expectedHeaders'
op|')'
op|')'
newline|'\n'
name|'content'
op|'='
name|'rest'
op|'['
op|':'
name|'len'
op|'('
name|'expectedContent'
op|')'
op|']'
newline|'\n'
name|'responses'
op|'='
name|'rest'
op|'['
name|'len'
op|'('
name|'expectedContent'
op|')'
op|':'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'content'
op|','
name|'expectedContent'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|HTTP1_0TestCase
dedent|''
dedent|''
dedent|''
name|'class'
name|'HTTP1_0TestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|','
name|'ResponseTestMixin'
op|')'
op|':'
newline|'\n'
DECL|variable|requests
indent|'    '
name|'requests'
op|'='
op|'('
nl|'\n'
string|'"GET / HTTP/1.0\\r\\n"'
nl|'\n'
string|'"\\r\\n"'
nl|'\n'
string|'"GET / HTTP/1.1\\r\\n"'
nl|'\n'
string|'"Accept: text/html\\r\\n"'
nl|'\n'
string|'"\\r\\n"'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|expected_response
name|'expected_response'
op|'='
op|'['
nl|'\n'
op|'('
string|'"HTTP/1.0 200 OK"'
op|','
nl|'\n'
string|'"Request: /"'
op|','
nl|'\n'
string|'"Command: GET"'
op|','
nl|'\n'
string|'"Version: HTTP/1.0"'
op|','
nl|'\n'
string|'"Content-Length: 13"'
op|','
nl|'\n'
string|'"\'\'\'\\nNone\\n\'\'\'\\n"'
op|')'
op|']'
newline|'\n'
nl|'\n'
DECL|member|test_buffer
name|'def'
name|'test_buffer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send requests over a channel and check responses match what is expected.\n        """'
newline|'\n'
name|'b'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'a'
op|'='
name|'http'
op|'.'
name|'HTTPChannel'
op|'('
op|')'
newline|'\n'
name|'a'
op|'.'
name|'requestFactory'
op|'='
name|'DummyHTTPHandler'
newline|'\n'
name|'a'
op|'.'
name|'makeConnection'
op|'('
name|'b'
op|')'
newline|'\n'
comment|'# one byte at a time, to stress it.'
nl|'\n'
name|'for'
name|'byte'
name|'in'
name|'self'
op|'.'
name|'requests'
op|':'
newline|'\n'
indent|'            '
name|'a'
op|'.'
name|'dataReceived'
op|'('
name|'byte'
op|')'
newline|'\n'
dedent|''
name|'a'
op|'.'
name|'connectionLost'
op|'('
name|'IOError'
op|'('
string|'"all one"'
op|')'
op|')'
newline|'\n'
name|'value'
op|'='
name|'b'
op|'.'
name|'value'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertResponseEquals'
op|'('
name|'value'
op|','
name|'self'
op|'.'
name|'expected_response'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_requestBodyTimeout
dedent|''
name|'def'
name|'test_requestBodyTimeout'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{HTTPChannel} resets its timeout whenever data from a request body is\n        delivered to it.\n        """'
newline|'\n'
name|'clock'
op|'='
name|'Clock'
op|'('
op|')'
newline|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'='
name|'http'
op|'.'
name|'HTTPChannel'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'timeOut'
op|'='
number|'100'
newline|'\n'
name|'protocol'
op|'.'
name|'callLater'
op|'='
name|'clock'
op|'.'
name|'callLater'
newline|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'transport'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'POST / HTTP/1.0\\r\\nContent-Length: 2\\r\\n\\r\\n'"
op|')'
newline|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
number|'99'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'transport'
op|'.'
name|'disconnecting'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'x'"
op|')'
newline|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
number|'99'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'transport'
op|'.'
name|'disconnecting'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'x'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'len'
op|'('
name|'protocol'
op|'.'
name|'requests'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|HTTP1_1TestCase
dedent|''
dedent|''
name|'class'
name|'HTTP1_1TestCase'
op|'('
name|'HTTP1_0TestCase'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|requests
indent|'    '
name|'requests'
op|'='
op|'('
nl|'\n'
string|'"GET / HTTP/1.1\\r\\n"'
nl|'\n'
string|'"Accept: text/html\\r\\n"'
nl|'\n'
string|'"\\r\\n"'
nl|'\n'
string|'"POST / HTTP/1.1\\r\\n"'
nl|'\n'
string|'"Content-Length: 10\\r\\n"'
nl|'\n'
string|'"\\r\\n"'
nl|'\n'
string|'"0123456789POST / HTTP/1.1\\r\\n"'
nl|'\n'
string|'"Content-Length: 10\\r\\n"'
nl|'\n'
string|'"\\r\\n"'
nl|'\n'
string|'"0123456789HEAD / HTTP/1.1\\r\\n"'
nl|'\n'
string|'"\\r\\n"'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|expected_response
name|'expected_response'
op|'='
op|'['
nl|'\n'
op|'('
string|'"HTTP/1.1 200 OK"'
op|','
nl|'\n'
string|'"Request: /"'
op|','
nl|'\n'
string|'"Command: GET"'
op|','
nl|'\n'
string|'"Version: HTTP/1.1"'
op|','
nl|'\n'
string|'"Content-Length: 13"'
op|','
nl|'\n'
string|'"\'\'\'\\nNone\\n\'\'\'\\n"'
op|')'
op|','
nl|'\n'
op|'('
string|'"HTTP/1.1 200 OK"'
op|','
nl|'\n'
string|'"Request: /"'
op|','
nl|'\n'
string|'"Command: POST"'
op|','
nl|'\n'
string|'"Version: HTTP/1.1"'
op|','
nl|'\n'
string|'"Content-Length: 21"'
op|','
nl|'\n'
string|'"\'\'\'\\n10\\n0123456789\'\'\'\\n"'
op|')'
op|','
nl|'\n'
op|'('
string|'"HTTP/1.1 200 OK"'
op|','
nl|'\n'
string|'"Request: /"'
op|','
nl|'\n'
string|'"Command: POST"'
op|','
nl|'\n'
string|'"Version: HTTP/1.1"'
op|','
nl|'\n'
string|'"Content-Length: 21"'
op|','
nl|'\n'
string|'"\'\'\'\\n10\\n0123456789\'\'\'\\n"'
op|')'
op|','
nl|'\n'
op|'('
string|'"HTTP/1.1 200 OK"'
op|','
nl|'\n'
string|'"Request: /"'
op|','
nl|'\n'
string|'"Command: HEAD"'
op|','
nl|'\n'
string|'"Version: HTTP/1.1"'
op|','
nl|'\n'
string|'"Content-Length: 13"'
op|','
nl|'\n'
string|'""'
op|')'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|HTTP1_1_close_TestCase
dedent|''
name|'class'
name|'HTTP1_1_close_TestCase'
op|'('
name|'HTTP1_0TestCase'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|requests
indent|'    '
name|'requests'
op|'='
op|'('
nl|'\n'
string|'"GET / HTTP/1.1\\r\\n"'
nl|'\n'
string|'"Accept: text/html\\r\\n"'
nl|'\n'
string|'"Connection: close\\r\\n"'
nl|'\n'
string|'"\\r\\n"'
nl|'\n'
string|'"GET / HTTP/1.0\\r\\n"'
nl|'\n'
string|'"\\r\\n"'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|expected_response
name|'expected_response'
op|'='
op|'['
nl|'\n'
op|'('
string|'"HTTP/1.1 200 OK"'
op|','
nl|'\n'
string|'"Connection: close"'
op|','
nl|'\n'
string|'"Request: /"'
op|','
nl|'\n'
string|'"Command: GET"'
op|','
nl|'\n'
string|'"Version: HTTP/1.1"'
op|','
nl|'\n'
string|'"Content-Length: 13"'
op|','
nl|'\n'
string|'"\'\'\'\\nNone\\n\'\'\'\\n"'
op|')'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|HTTP0_9TestCase
dedent|''
name|'class'
name|'HTTP0_9TestCase'
op|'('
name|'HTTP1_0TestCase'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|requests
indent|'    '
name|'requests'
op|'='
op|'('
nl|'\n'
string|'"GET /\\r\\n"'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|expected_response
name|'expected_response'
op|'='
string|'"HTTP/1.1 400 Bad Request\\r\\n\\r\\n"'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|assertResponseEquals
name|'def'
name|'assertResponseEquals'
op|'('
name|'self'
op|','
name|'response'
op|','
name|'expectedResponse'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'response'
op|','
name|'expectedResponse'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|HTTPLoopbackTestCase
dedent|''
dedent|''
name|'class'
name|'HTTPLoopbackTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|expectedHeaders
indent|'    '
name|'expectedHeaders'
op|'='
op|'{'
string|"'request'"
op|':'
string|"'/foo/bar'"
op|','
nl|'\n'
string|"'command'"
op|':'
string|"'GET'"
op|','
nl|'\n'
string|"'version'"
op|':'
string|"'HTTP/1.0'"
op|','
nl|'\n'
string|"'content-length'"
op|':'
string|"'21'"
op|'}'
newline|'\n'
DECL|variable|numHeaders
name|'numHeaders'
op|'='
number|'0'
newline|'\n'
DECL|variable|gotStatus
name|'gotStatus'
op|'='
number|'0'
newline|'\n'
DECL|variable|gotResponse
name|'gotResponse'
op|'='
number|'0'
newline|'\n'
DECL|variable|gotEndHeaders
name|'gotEndHeaders'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|member|_handleStatus
name|'def'
name|'_handleStatus'
op|'('
name|'self'
op|','
name|'version'
op|','
name|'status'
op|','
name|'message'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'gotStatus'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'version'
op|','
string|'"HTTP/1.0"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'status'
op|','
string|'"200"'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_handleResponse
dedent|''
name|'def'
name|'_handleResponse'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'gotResponse'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'data'
op|','
string|'"\'\'\'\\n10\\n0123456789\'\'\'\\n"'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_handleHeader
dedent|''
name|'def'
name|'_handleHeader'
op|'('
name|'self'
op|','
name|'key'
op|','
name|'value'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'numHeaders'
op|'='
name|'self'
op|'.'
name|'numHeaders'
op|'+'
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'expectedHeaders'
op|'['
name|'key'
op|'.'
name|'lower'
op|'('
op|')'
op|']'
op|','
name|'value'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_handleEndHeaders
dedent|''
name|'def'
name|'_handleEndHeaders'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'gotEndHeaders'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'numHeaders'
op|','
number|'4'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testLoopback
dedent|''
name|'def'
name|'testLoopback'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'server'
op|'='
name|'http'
op|'.'
name|'HTTPChannel'
op|'('
op|')'
newline|'\n'
name|'server'
op|'.'
name|'requestFactory'
op|'='
name|'DummyHTTPHandler'
newline|'\n'
name|'client'
op|'='
name|'LoopbackHTTPClient'
op|'('
op|')'
newline|'\n'
name|'client'
op|'.'
name|'handleResponse'
op|'='
name|'self'
op|'.'
name|'_handleResponse'
newline|'\n'
name|'client'
op|'.'
name|'handleHeader'
op|'='
name|'self'
op|'.'
name|'_handleHeader'
newline|'\n'
name|'client'
op|'.'
name|'handleEndHeaders'
op|'='
name|'self'
op|'.'
name|'_handleEndHeaders'
newline|'\n'
name|'client'
op|'.'
name|'handleStatus'
op|'='
name|'self'
op|'.'
name|'_handleStatus'
newline|'\n'
name|'d'
op|'='
name|'loopback'
op|'.'
name|'loopbackAsync'
op|'('
name|'server'
op|','
name|'client'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'_cbTestLoopback'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
DECL|member|_cbTestLoopback
dedent|''
name|'def'
name|'_cbTestLoopback'
op|'('
name|'self'
op|','
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
op|'('
name|'self'
op|'.'
name|'gotStatus'
name|'and'
name|'self'
op|'.'
name|'gotResponse'
name|'and'
name|'self'
op|'.'
name|'gotEndHeaders'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'RuntimeError'
op|'('
nl|'\n'
string|'"didn\'t got all callbacks %s"'
nl|'\n'
op|'%'
op|'['
name|'self'
op|'.'
name|'gotStatus'
op|','
name|'self'
op|'.'
name|'gotResponse'
op|','
name|'self'
op|'.'
name|'gotEndHeaders'
op|']'
op|')'
newline|'\n'
dedent|''
name|'del'
name|'self'
op|'.'
name|'gotEndHeaders'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'gotResponse'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'gotStatus'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'numHeaders'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|_prequest
dedent|''
dedent|''
name|'def'
name|'_prequest'
op|'('
op|'**'
name|'headers'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Make a request with the given request headers for the persistence tests.\n    """'
newline|'\n'
name|'request'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'for'
name|'k'
op|','
name|'v'
name|'in'
name|'headers'
op|'.'
name|'iteritems'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'request'
op|'.'
name|'requestHeaders'
op|'.'
name|'setRawHeaders'
op|'('
name|'k'
op|','
name|'v'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'request'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|PersistenceTestCase
dedent|''
name|'class'
name|'PersistenceTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for persistent HTTP connections.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|ptests
name|'ptests'
op|'='
op|'['
comment|'#(PRequest(connection="Keep-Alive"), "HTTP/1.0", 1, {\'connection\' : \'Keep-Alive\'}),'
nl|'\n'
op|'('
name|'_prequest'
op|'('
op|')'
op|','
string|'"HTTP/1.0"'
op|','
number|'0'
op|','
op|'{'
string|"'connection'"
op|':'
name|'None'
op|'}'
op|')'
op|','
nl|'\n'
op|'('
name|'_prequest'
op|'('
name|'connection'
op|'='
op|'['
string|'"close"'
op|']'
op|')'
op|','
string|'"HTTP/1.1"'
op|','
number|'0'
op|','
op|'{'
string|"'connection'"
op|':'
op|'['
string|"'close'"
op|']'
op|'}'
op|')'
op|','
nl|'\n'
op|'('
name|'_prequest'
op|'('
op|')'
op|','
string|'"HTTP/1.1"'
op|','
number|'1'
op|','
op|'{'
string|"'connection'"
op|':'
name|'None'
op|'}'
op|')'
op|','
nl|'\n'
op|'('
name|'_prequest'
op|'('
op|')'
op|','
string|'"HTTP/0.9"'
op|','
number|'0'
op|','
op|'{'
string|"'connection'"
op|':'
name|'None'
op|'}'
op|')'
op|','
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testAlgorithm
name|'def'
name|'testAlgorithm'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'c'
op|'='
name|'http'
op|'.'
name|'HTTPChannel'
op|'('
op|')'
newline|'\n'
name|'for'
name|'req'
op|','
name|'version'
op|','
name|'correctResult'
op|','
name|'resultHeaders'
name|'in'
name|'self'
op|'.'
name|'ptests'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'='
name|'c'
op|'.'
name|'checkPersistence'
op|'('
name|'req'
op|','
name|'version'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'result'
op|','
name|'correctResult'
op|')'
newline|'\n'
name|'for'
name|'header'
name|'in'
name|'resultHeaders'
op|'.'
name|'keys'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'req'
op|'.'
name|'responseHeaders'
op|'.'
name|'getRawHeaders'
op|'('
name|'header'
op|','
name|'None'
op|')'
op|','
name|'resultHeaders'
op|'['
name|'header'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|IdentityTransferEncodingTests
dedent|''
dedent|''
dedent|''
dedent|''
name|'class'
name|'IdentityTransferEncodingTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{_IdentityTransferDecoder}.\n    """'
newline|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create an L{_IdentityTransferDecoder} with callbacks hooked up so that\n        calls to them can be inspected.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'data'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'finish'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'contentLength'
op|'='
number|'10'
newline|'\n'
name|'self'
op|'.'
name|'decoder'
op|'='
name|'_IdentityTransferDecoder'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'contentLength'
op|','
name|'self'
op|'.'
name|'data'
op|'.'
name|'append'
op|','
name|'self'
op|'.'
name|'finish'
op|'.'
name|'append'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_exactAmountReceived
dedent|''
name|'def'
name|'test_exactAmountReceived'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If L{_IdentityTransferDecoder.dataReceived} is called with a string\n        with length equal to the content length passed to\n        L{_IdentityTransferDecoder}\'s initializer, the data callback is invoked\n        with that string and the finish callback is invoked with a zero-length\n        string.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'decoder'
op|'.'
name|'dataReceived'
op|'('
string|"'x'"
op|'*'
name|'self'
op|'.'
name|'contentLength'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'data'
op|','
op|'['
string|"'x'"
op|'*'
name|'self'
op|'.'
name|'contentLength'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'finish'
op|','
op|'['
string|"''"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_shortStrings
dedent|''
name|'def'
name|'test_shortStrings'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If L{_IdentityTransferDecoder.dataReceived} is called multiple times\n        with strings which, when concatenated, are as long as the content\n        length provided, the data callback is invoked with each string and the\n        finish callback is invoked only after the second call.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'decoder'
op|'.'
name|'dataReceived'
op|'('
string|"'x'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'data'
op|','
op|'['
string|"'x'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'finish'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'decoder'
op|'.'
name|'dataReceived'
op|'('
string|"'y'"
op|'*'
op|'('
name|'self'
op|'.'
name|'contentLength'
op|'-'
number|'1'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'data'
op|','
op|'['
string|"'x'"
op|','
string|"'y'"
op|'*'
op|'('
name|'self'
op|'.'
name|'contentLength'
op|'-'
number|'1'
op|')'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'finish'
op|','
op|'['
string|"''"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_longString
dedent|''
name|'def'
name|'test_longString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If L{_IdentityTransferDecoder.dataReceived} is called with a string\n        with length greater than the provided content length, only the prefix\n        of that string up to the content length is passed to the data callback\n        and the remainder is passed to the finish callback.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'decoder'
op|'.'
name|'dataReceived'
op|'('
string|"'x'"
op|'*'
name|'self'
op|'.'
name|'contentLength'
op|'+'
string|"'y'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'data'
op|','
op|'['
string|"'x'"
op|'*'
name|'self'
op|'.'
name|'contentLength'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'finish'
op|','
op|'['
string|"'y'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_rejectDataAfterFinished
dedent|''
name|'def'
name|'test_rejectDataAfterFinished'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If data is passed to L{_IdentityTransferDecoder.dataReceived} after the\n        finish callback has been invoked, L{RuntimeError} is raised.\n        """'
newline|'\n'
name|'failures'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|finish
name|'def'
name|'finish'
op|'('
name|'bytes'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'decoder'
op|'.'
name|'dataReceived'
op|'('
string|"'foo'"
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'                '
name|'failures'
op|'.'
name|'append'
op|'('
name|'Failure'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'decoder'
op|'='
name|'_IdentityTransferDecoder'
op|'('
number|'5'
op|','
name|'self'
op|'.'
name|'data'
op|'.'
name|'append'
op|','
name|'finish'
op|')'
newline|'\n'
name|'decoder'
op|'.'
name|'dataReceived'
op|'('
string|"'x'"
op|'*'
number|'4'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'failures'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'decoder'
op|'.'
name|'dataReceived'
op|'('
string|"'y'"
op|')'
newline|'\n'
name|'failures'
op|'['
number|'0'
op|']'
op|'.'
name|'trap'
op|'('
name|'RuntimeError'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'str'
op|'('
name|'failures'
op|'['
number|'0'
op|']'
op|'.'
name|'value'
op|')'
op|','
nl|'\n'
string|'"_IdentityTransferDecoder cannot decode data after finishing"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_unknownContentLength
dedent|''
name|'def'
name|'test_unknownContentLength'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If L{_IdentityTransferDecoder} is constructed with C{None} for the\n        content length, it passes all data delivered to it through to the data\n        callback.\n        """'
newline|'\n'
name|'data'
op|'='
op|'['
op|']'
newline|'\n'
name|'finish'
op|'='
op|'['
op|']'
newline|'\n'
name|'decoder'
op|'='
name|'_IdentityTransferDecoder'
op|'('
name|'None'
op|','
name|'data'
op|'.'
name|'append'
op|','
name|'finish'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'decoder'
op|'.'
name|'dataReceived'
op|'('
string|"'x'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'data'
op|','
op|'['
string|"'x'"
op|']'
op|')'
newline|'\n'
name|'decoder'
op|'.'
name|'dataReceived'
op|'('
string|"'y'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'data'
op|','
op|'['
string|"'x'"
op|','
string|"'y'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'finish'
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_verifyCallbacksUnreferenced
dedent|''
name|'def'
name|'_verifyCallbacksUnreferenced'
op|'('
name|'self'
op|','
name|'decoder'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check the decoder\'s data and finish callbacks and make sure they are\n        None in order to help avoid references cycles.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'decoder'
op|'.'
name|'dataCallback'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'decoder'
op|'.'
name|'finishCallback'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_earlyConnectionLose
dedent|''
name|'def'
name|'test_earlyConnectionLose'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_IdentityTransferDecoder.noMoreData} raises L{_DataLoss} if it is\n        called and the content length is known but not enough bytes have been\n        delivered.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'decoder'
op|'.'
name|'dataReceived'
op|'('
string|"'x'"
op|'*'
op|'('
name|'self'
op|'.'
name|'contentLength'
op|'-'
number|'1'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'_DataLoss'
op|','
name|'self'
op|'.'
name|'decoder'
op|'.'
name|'noMoreData'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_verifyCallbacksUnreferenced'
op|'('
name|'self'
op|'.'
name|'decoder'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_unknownContentLengthConnectionLose
dedent|''
name|'def'
name|'test_unknownContentLengthConnectionLose'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_IdentityTransferDecoder.noMoreData} calls the finish callback and\n        raises L{PotentialDataLoss} if it is called and the content length is\n        unknown.\n        """'
newline|'\n'
name|'body'
op|'='
op|'['
op|']'
newline|'\n'
name|'finished'
op|'='
op|'['
op|']'
newline|'\n'
name|'decoder'
op|'='
name|'_IdentityTransferDecoder'
op|'('
name|'None'
op|','
name|'body'
op|'.'
name|'append'
op|','
name|'finished'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'PotentialDataLoss'
op|','
name|'decoder'
op|'.'
name|'noMoreData'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'body'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'finished'
op|','
op|'['
string|"''"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_verifyCallbacksUnreferenced'
op|'('
name|'decoder'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_finishedConnectionLose
dedent|''
name|'def'
name|'test_finishedConnectionLose'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_IdentityTransferDecoder.noMoreData} does not raise any exception if\n        it is called when the content length is known and that many bytes have\n        been delivered.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'decoder'
op|'.'
name|'dataReceived'
op|'('
string|"'x'"
op|'*'
name|'self'
op|'.'
name|'contentLength'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'decoder'
op|'.'
name|'noMoreData'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_verifyCallbacksUnreferenced'
op|'('
name|'self'
op|'.'
name|'decoder'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ChunkedTransferEncodingTests
dedent|''
dedent|''
name|'class'
name|'ChunkedTransferEncodingTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{_ChunkedTransferDecoder}, which turns a byte stream encoded\n    using HTTP I{chunked} C{Transfer-Encoding} back into the original byte\n    stream.\n    """'
newline|'\n'
DECL|member|test_decoding
name|'def'
name|'test_decoding'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ChunkedTransferDecoder.dataReceived} decodes chunked-encoded data\n        and passes the result to the specified callback.\n        """'
newline|'\n'
name|'L'
op|'='
op|'['
op|']'
newline|'\n'
name|'p'
op|'='
name|'http'
op|'.'
name|'_ChunkedTransferDecoder'
op|'('
name|'L'
op|'.'
name|'append'
op|','
name|'None'
op|')'
newline|'\n'
name|'p'
op|'.'
name|'dataReceived'
op|'('
string|"'3\\r\\nabc\\r\\n5\\r\\n12345\\r\\n'"
op|')'
newline|'\n'
name|'p'
op|'.'
name|'dataReceived'
op|'('
string|"'a\\r\\n0123456789\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'L'
op|','
op|'['
string|"'abc'"
op|','
string|"'12345'"
op|','
string|"'0123456789'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_short
dedent|''
name|'def'
name|'test_short'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ChunkedTransferDecoder.dataReceived} decodes chunks broken up and\n        delivered in multiple calls.\n        """'
newline|'\n'
name|'L'
op|'='
op|'['
op|']'
newline|'\n'
name|'finished'
op|'='
op|'['
op|']'
newline|'\n'
name|'p'
op|'='
name|'http'
op|'.'
name|'_ChunkedTransferDecoder'
op|'('
name|'L'
op|'.'
name|'append'
op|','
name|'finished'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'for'
name|'s'
name|'in'
string|"'3\\r\\nabc\\r\\n5\\r\\n12345\\r\\n0\\r\\n\\r\\n'"
op|':'
newline|'\n'
indent|'            '
name|'p'
op|'.'
name|'dataReceived'
op|'('
name|'s'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'L'
op|','
op|'['
string|"'a'"
op|','
string|"'b'"
op|','
string|"'c'"
op|','
string|"'1'"
op|','
string|"'2'"
op|','
string|"'3'"
op|','
string|"'4'"
op|','
string|"'5'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'finished'
op|','
op|'['
string|"''"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_newlines
dedent|''
name|'def'
name|'test_newlines'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ChunkedTransferDecoder.dataReceived} doesn\'t treat CR LF pairs\n        embedded in chunk bodies specially.\n        """'
newline|'\n'
name|'L'
op|'='
op|'['
op|']'
newline|'\n'
name|'p'
op|'='
name|'http'
op|'.'
name|'_ChunkedTransferDecoder'
op|'('
name|'L'
op|'.'
name|'append'
op|','
name|'None'
op|')'
newline|'\n'
name|'p'
op|'.'
name|'dataReceived'
op|'('
string|"'2\\r\\n\\r\\n\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'L'
op|','
op|'['
string|"'\\r\\n'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_extensions
dedent|''
name|'def'
name|'test_extensions'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ChunkedTransferDecoder.dataReceived} disregards chunk-extension\n        fields.\n        """'
newline|'\n'
name|'L'
op|'='
op|'['
op|']'
newline|'\n'
name|'p'
op|'='
name|'http'
op|'.'
name|'_ChunkedTransferDecoder'
op|'('
name|'L'
op|'.'
name|'append'
op|','
name|'None'
op|')'
newline|'\n'
name|'p'
op|'.'
name|'dataReceived'
op|'('
string|"'3; x-foo=bar\\r\\nabc\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'L'
op|','
op|'['
string|"'abc'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_finish
dedent|''
name|'def'
name|'test_finish'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ChunkedTransferDecoder.dataReceived} interprets a zero-length\n        chunk as the end of the chunked data stream and calls the completion\n        callback.\n        """'
newline|'\n'
name|'finished'
op|'='
op|'['
op|']'
newline|'\n'
name|'p'
op|'='
name|'http'
op|'.'
name|'_ChunkedTransferDecoder'
op|'('
name|'None'
op|','
name|'finished'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'p'
op|'.'
name|'dataReceived'
op|'('
string|"'0\\r\\n\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'finished'
op|','
op|'['
string|"''"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_extra
dedent|''
name|'def'
name|'test_extra'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ChunkedTransferDecoder.dataReceived} passes any bytes which come\n        after the terminating zero-length chunk to the completion callback.\n        """'
newline|'\n'
name|'finished'
op|'='
op|'['
op|']'
newline|'\n'
name|'p'
op|'='
name|'http'
op|'.'
name|'_ChunkedTransferDecoder'
op|'('
name|'None'
op|','
name|'finished'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'p'
op|'.'
name|'dataReceived'
op|'('
string|"'0\\r\\n\\r\\nhello'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'finished'
op|','
op|'['
string|"'hello'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_afterFinished
dedent|''
name|'def'
name|'test_afterFinished'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ChunkedTransferDecoder.dataReceived} raises L{RuntimeError} if it\n        is called after it has seen the last chunk.\n        """'
newline|'\n'
name|'p'
op|'='
name|'http'
op|'.'
name|'_ChunkedTransferDecoder'
op|'('
name|'None'
op|','
name|'lambda'
name|'bytes'
op|':'
name|'None'
op|')'
newline|'\n'
name|'p'
op|'.'
name|'dataReceived'
op|'('
string|"'0\\r\\n\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'RuntimeError'
op|','
name|'p'
op|'.'
name|'dataReceived'
op|','
string|"'hello'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_earlyConnectionLose
dedent|''
name|'def'
name|'test_earlyConnectionLose'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ChunkedTransferDecoder.noMoreData} raises L{_DataLoss} if it is\n        called and the end of the last trailer has not yet been received.\n        """'
newline|'\n'
name|'parser'
op|'='
name|'http'
op|'.'
name|'_ChunkedTransferDecoder'
op|'('
name|'None'
op|','
name|'lambda'
name|'bytes'
op|':'
name|'None'
op|')'
newline|'\n'
name|'parser'
op|'.'
name|'dataReceived'
op|'('
string|"'0\\r\\n\\r'"
op|')'
newline|'\n'
name|'exc'
op|'='
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'_DataLoss'
op|','
name|'parser'
op|'.'
name|'noMoreData'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'str'
op|'('
name|'exc'
op|')'
op|','
nl|'\n'
string|'"Chunked decoder in \'trailer\' state, still expecting more data "'
nl|'\n'
string|'"to get to finished state."'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_finishedConnectionLose
dedent|''
name|'def'
name|'test_finishedConnectionLose'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ChunkedTransferDecoder.noMoreData} does not raise any exception if\n        it is called after the terminal zero length chunk is received.\n        """'
newline|'\n'
name|'parser'
op|'='
name|'http'
op|'.'
name|'_ChunkedTransferDecoder'
op|'('
name|'None'
op|','
name|'lambda'
name|'bytes'
op|':'
name|'None'
op|')'
newline|'\n'
name|'parser'
op|'.'
name|'dataReceived'
op|'('
string|"'0\\r\\n\\r\\n'"
op|')'
newline|'\n'
name|'parser'
op|'.'
name|'noMoreData'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_reentrantFinishedNoMoreData
dedent|''
name|'def'
name|'test_reentrantFinishedNoMoreData'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ChunkedTransferDecoder.noMoreData} can be called from the finished\n        callback without raising an exception.\n        """'
newline|'\n'
name|'errors'
op|'='
op|'['
op|']'
newline|'\n'
name|'successes'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|finished
name|'def'
name|'finished'
op|'('
name|'extra'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'parser'
op|'.'
name|'noMoreData'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'                '
name|'errors'
op|'.'
name|'append'
op|'('
name|'Failure'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'successes'
op|'.'
name|'append'
op|'('
name|'True'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'parser'
op|'='
name|'http'
op|'.'
name|'_ChunkedTransferDecoder'
op|'('
name|'None'
op|','
name|'finished'
op|')'
newline|'\n'
name|'parser'
op|'.'
name|'dataReceived'
op|'('
string|"'0\\r\\n\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'errors'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'successes'
op|','
op|'['
name|'True'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ChunkingTestCase
dedent|''
dedent|''
name|'class'
name|'ChunkingTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|strings
indent|'    '
name|'strings'
op|'='
op|'['
string|'"abcv"'
op|','
string|'""'
op|','
string|'"fdfsd423"'
op|','
string|'"Ffasfas\\r\\n"'
op|','
nl|'\n'
string|'"523523\\n\\rfsdf"'
op|','
string|'"4234"'
op|']'
newline|'\n'
nl|'\n'
DECL|member|testChunks
name|'def'
name|'testChunks'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'s'
name|'in'
name|'self'
op|'.'
name|'strings'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
op|'('
name|'s'
op|','
string|"''"
op|')'
op|','
name|'http'
op|'.'
name|'fromChunk'
op|'('
string|"''"
op|'.'
name|'join'
op|'('
name|'http'
op|'.'
name|'toChunk'
op|'('
name|'s'
op|')'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'ValueError'
op|','
name|'http'
op|'.'
name|'fromChunk'
op|','
string|"'-5\\r\\nmalformed!\\r\\n'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|testConcatenatedChunks
dedent|''
name|'def'
name|'testConcatenatedChunks'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'chunked'
op|'='
string|"''"
op|'.'
name|'join'
op|'('
op|'['
string|"''"
op|'.'
name|'join'
op|'('
name|'http'
op|'.'
name|'toChunk'
op|'('
name|'t'
op|')'
op|')'
name|'for'
name|'t'
name|'in'
name|'self'
op|'.'
name|'strings'
op|']'
op|')'
newline|'\n'
name|'result'
op|'='
op|'['
op|']'
newline|'\n'
name|'buffer'
op|'='
string|'""'
newline|'\n'
name|'for'
name|'c'
name|'in'
name|'chunked'
op|':'
newline|'\n'
indent|'            '
name|'buffer'
op|'='
name|'buffer'
op|'+'
name|'c'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'data'
op|','
name|'buffer'
op|'='
name|'http'
op|'.'
name|'fromChunk'
op|'('
name|'buffer'
op|')'
newline|'\n'
name|'result'
op|'.'
name|'append'
op|'('
name|'data'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'result'
op|','
name|'self'
op|'.'
name|'strings'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ParsingTestCase
dedent|''
dedent|''
name|'class'
name|'ParsingTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for protocol parsing in L{HTTPChannel}.\n    """'
newline|'\n'
DECL|member|runRequest
name|'def'
name|'runRequest'
op|'('
name|'self'
op|','
name|'httpRequest'
op|','
name|'requestClass'
op|','
name|'success'
op|'='
number|'1'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'httpRequest'
op|'='
name|'httpRequest'
op|'.'
name|'replace'
op|'('
string|'"\\n"'
op|','
string|'"\\r\\n"'
op|')'
newline|'\n'
name|'b'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'a'
op|'='
name|'http'
op|'.'
name|'HTTPChannel'
op|'('
op|')'
newline|'\n'
name|'a'
op|'.'
name|'requestFactory'
op|'='
name|'requestClass'
newline|'\n'
name|'a'
op|'.'
name|'makeConnection'
op|'('
name|'b'
op|')'
newline|'\n'
comment|'# one byte at a time, to stress it.'
nl|'\n'
name|'for'
name|'byte'
name|'in'
name|'httpRequest'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'a'
op|'.'
name|'transport'
op|'.'
name|'disconnecting'
op|':'
newline|'\n'
indent|'                '
name|'break'
newline|'\n'
dedent|''
name|'a'
op|'.'
name|'dataReceived'
op|'('
name|'byte'
op|')'
newline|'\n'
dedent|''
name|'a'
op|'.'
name|'connectionLost'
op|'('
name|'IOError'
op|'('
string|'"all done"'
op|')'
op|')'
newline|'\n'
name|'if'
name|'success'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'didRequest'
op|','
number|'1'
op|')'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'didRequest'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assert_'
op|'('
name|'not'
name|'hasattr'
op|'('
name|'self'
op|','
string|'"didRequest"'
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'a'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_basicAuth
dedent|''
name|'def'
name|'test_basicAuth'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{HTTPChannel} provides username and password information supplied in\n        an I{Authorization} header to the L{Request} which makes it available\n        via its C{getUser} and C{getPassword} methods.\n        """'
newline|'\n'
name|'testcase'
op|'='
name|'self'
newline|'\n'
DECL|class|Request
name|'class'
name|'Request'
op|'('
name|'http'
op|'.'
name|'Request'
op|')'
op|':'
newline|'\n'
DECL|variable|l
indent|'            '
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
DECL|member|process
name|'def'
name|'process'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'testcase'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'getUser'
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'l'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'getPassword'
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'l'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'for'
name|'u'
op|','
name|'p'
name|'in'
op|'['
op|'('
string|'"foo"'
op|','
string|'"bar"'
op|')'
op|','
op|'('
string|'"hello"'
op|','
string|'"there:z"'
op|')'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'Request'
op|'.'
name|'l'
op|'['
op|':'
op|']'
op|'='
op|'['
name|'u'
op|','
name|'p'
op|']'
newline|'\n'
DECL|variable|s
name|'s'
op|'='
string|'"%s:%s"'
op|'%'
op|'('
name|'u'
op|','
name|'p'
op|')'
newline|'\n'
DECL|variable|f
name|'f'
op|'='
string|'"GET / HTTP/1.0\\nAuthorization: Basic %s\\n\\n"'
op|'%'
op|'('
name|'s'
op|'.'
name|'encode'
op|'('
string|'"base64"'
op|')'
op|'.'
name|'strip'
op|'('
op|')'
op|','
op|')'
newline|'\n'
name|'self'
op|'.'
name|'runRequest'
op|'('
name|'f'
op|','
name|'Request'
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_headers
dedent|''
dedent|''
name|'def'
name|'test_headers'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Headers received by L{HTTPChannel} in a request are made available to\n        the L{Request}.\n        """'
newline|'\n'
name|'processed'
op|'='
op|'['
op|']'
newline|'\n'
DECL|class|MyRequest
name|'class'
name|'MyRequest'
op|'('
name|'http'
op|'.'
name|'Request'
op|')'
op|':'
newline|'\n'
DECL|member|process
indent|'            '
name|'def'
name|'process'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'processed'
op|'.'
name|'append'
op|'('
name|'self'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'finish'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'requestLines'
op|'='
op|'['
nl|'\n'
string|'"GET / HTTP/1.0"'
op|','
nl|'\n'
string|'"Foo: bar"'
op|','
nl|'\n'
string|'"baz: Quux"'
op|','
nl|'\n'
string|'"baz: quux"'
op|','
nl|'\n'
string|'""'
op|','
nl|'\n'
string|'""'
op|']'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'runRequest'
op|'('
string|"'\\n'"
op|'.'
name|'join'
op|'('
name|'requestLines'
op|')'
op|','
name|'MyRequest'
op|','
number|'0'
op|')'
newline|'\n'
op|'['
name|'request'
op|']'
op|'='
name|'processed'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'request'
op|'.'
name|'requestHeaders'
op|'.'
name|'getRawHeaders'
op|'('
string|"'foo'"
op|')'
op|','
op|'['
string|"'bar'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'request'
op|'.'
name|'requestHeaders'
op|'.'
name|'getRawHeaders'
op|'('
string|"'bAz'"
op|')'
op|','
op|'['
string|"'Quux'"
op|','
string|"'quux'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_tooManyHeaders
dedent|''
name|'def'
name|'test_tooManyHeaders'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{HTTPChannel} enforces a limit of C{HTTPChannel.maxHeaders} on the\n        number of headers received per request.\n        """'
newline|'\n'
name|'processed'
op|'='
op|'['
op|']'
newline|'\n'
DECL|class|MyRequest
name|'class'
name|'MyRequest'
op|'('
name|'http'
op|'.'
name|'Request'
op|')'
op|':'
newline|'\n'
DECL|member|process
indent|'            '
name|'def'
name|'process'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'processed'
op|'.'
name|'append'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'requestLines'
op|'='
op|'['
string|'"GET / HTTP/1.0"'
op|']'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'http'
op|'.'
name|'HTTPChannel'
op|'.'
name|'maxHeaders'
op|'+'
number|'2'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'requestLines'
op|'.'
name|'append'
op|'('
string|'"%s: foo"'
op|'%'
op|'('
name|'i'
op|','
op|')'
op|')'
newline|'\n'
dedent|''
name|'requestLines'
op|'.'
name|'extend'
op|'('
op|'['
string|'""'
op|','
string|'""'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'channel'
op|'='
name|'self'
op|'.'
name|'runRequest'
op|'('
string|'"\\n"'
op|'.'
name|'join'
op|'('
name|'requestLines'
op|')'
op|','
name|'MyRequest'
op|','
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'processed'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'channel'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
nl|'\n'
string|'"HTTP/1.1 400 Bad Request\\r\\n\\r\\n"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_headerLimitPerRequest
dedent|''
name|'def'
name|'test_headerLimitPerRequest'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{HTTPChannel} enforces the limit of C{HTTPChannel.maxHeaders} per\n        request so that headers received in an earlier request do not count\n        towards the limit when processing a later request.\n        """'
newline|'\n'
name|'processed'
op|'='
op|'['
op|']'
newline|'\n'
DECL|class|MyRequest
name|'class'
name|'MyRequest'
op|'('
name|'http'
op|'.'
name|'Request'
op|')'
op|':'
newline|'\n'
DECL|member|process
indent|'            '
name|'def'
name|'process'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'processed'
op|'.'
name|'append'
op|'('
name|'self'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'finish'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'patch'
op|'('
name|'http'
op|'.'
name|'HTTPChannel'
op|','
string|"'maxHeaders'"
op|','
number|'1'
op|')'
newline|'\n'
name|'requestLines'
op|'='
op|'['
nl|'\n'
string|'"GET / HTTP/1.1"'
op|','
nl|'\n'
string|'"Foo: bar"'
op|','
nl|'\n'
string|'""'
op|','
nl|'\n'
string|'""'
op|','
nl|'\n'
string|'"GET / HTTP/1.1"'
op|','
nl|'\n'
string|'"Bar: baz"'
op|','
nl|'\n'
string|'""'
op|','
nl|'\n'
string|'""'
op|']'
newline|'\n'
nl|'\n'
name|'channel'
op|'='
name|'self'
op|'.'
name|'runRequest'
op|'('
string|'"\\n"'
op|'.'
name|'join'
op|'('
name|'requestLines'
op|')'
op|','
name|'MyRequest'
op|','
number|'0'
op|')'
newline|'\n'
op|'['
name|'first'
op|','
name|'second'
op|']'
op|'='
name|'processed'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'first'
op|'.'
name|'getHeader'
op|'('
string|"'foo'"
op|')'
op|','
string|"'bar'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'second'
op|'.'
name|'getHeader'
op|'('
string|"'bar'"
op|')'
op|','
string|"'baz'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'channel'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
nl|'\n'
string|"'HTTP/1.1 200 OK\\r\\n'"
nl|'\n'
string|"'Transfer-Encoding: chunked\\r\\n'"
nl|'\n'
string|"'\\r\\n'"
nl|'\n'
string|"'0\\r\\n'"
nl|'\n'
string|"'\\r\\n'"
nl|'\n'
string|"'HTTP/1.1 200 OK\\r\\n'"
nl|'\n'
string|"'Transfer-Encoding: chunked\\r\\n'"
nl|'\n'
string|"'\\r\\n'"
nl|'\n'
string|"'0\\r\\n'"
nl|'\n'
string|"'\\r\\n'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testCookies
dedent|''
name|'def'
name|'testCookies'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test cookies parsing and reading.\n        """'
newline|'\n'
name|'httpRequest'
op|'='
string|'\'\'\'\\\nGET / HTTP/1.0\nCookie: rabbit="eat carrot"; ninja=secret; spam="hey 1=1!"\n\n\'\'\''
newline|'\n'
name|'testcase'
op|'='
name|'self'
newline|'\n'
nl|'\n'
DECL|class|MyRequest
name|'class'
name|'MyRequest'
op|'('
name|'http'
op|'.'
name|'Request'
op|')'
op|':'
newline|'\n'
DECL|member|process
indent|'            '
name|'def'
name|'process'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'testcase'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'getCookie'
op|'('
string|"'rabbit'"
op|')'
op|','
string|'\'"eat carrot"\''
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'getCookie'
op|'('
string|"'ninja'"
op|')'
op|','
string|"'secret'"
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'getCookie'
op|'('
string|"'spam'"
op|')'
op|','
string|'\'"hey 1=1!"\''
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'didRequest'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'finish'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'runRequest'
op|'('
name|'httpRequest'
op|','
name|'MyRequest'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testGET
dedent|''
name|'def'
name|'testGET'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'httpRequest'
op|'='
string|"'''\\\nGET /?key=value&multiple=two+words&multiple=more%20words&empty= HTTP/1.0\n\n'''"
newline|'\n'
name|'testcase'
op|'='
name|'self'
newline|'\n'
DECL|class|MyRequest
name|'class'
name|'MyRequest'
op|'('
name|'http'
op|'.'
name|'Request'
op|')'
op|':'
newline|'\n'
DECL|member|process
indent|'            '
name|'def'
name|'process'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'testcase'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'method'
op|','
string|'"GET"'
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'args'
op|'['
string|'"key"'
op|']'
op|','
op|'['
string|'"value"'
op|']'
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'args'
op|'['
string|'"empty"'
op|']'
op|','
op|'['
string|'""'
op|']'
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'args'
op|'['
string|'"multiple"'
op|']'
op|','
op|'['
string|'"two words"'
op|','
string|'"more words"'
op|']'
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'didRequest'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'finish'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'runRequest'
op|'('
name|'httpRequest'
op|','
name|'MyRequest'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|test_extraQuestionMark
dedent|''
name|'def'
name|'test_extraQuestionMark'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        While only a single \'?\' is allowed in an URL, several other servers\n        allow several and pass all after the first through as part of the\n        query arguments.  Test that we emulate this behavior.\n        """'
newline|'\n'
name|'httpRequest'
op|'='
string|"'GET /foo?bar=?&baz=quux HTTP/1.0\\n\\n'"
newline|'\n'
nl|'\n'
name|'testcase'
op|'='
name|'self'
newline|'\n'
DECL|class|MyRequest
name|'class'
name|'MyRequest'
op|'('
name|'http'
op|'.'
name|'Request'
op|')'
op|':'
newline|'\n'
DECL|member|process
indent|'            '
name|'def'
name|'process'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'testcase'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'method'
op|','
string|"'GET'"
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'path'
op|','
string|"'/foo'"
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'args'
op|'['
string|"'bar'"
op|']'
op|','
op|'['
string|"'?'"
op|']'
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'args'
op|'['
string|"'baz'"
op|']'
op|','
op|'['
string|"'quux'"
op|']'
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'didRequest'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'finish'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'runRequest'
op|'('
name|'httpRequest'
op|','
name|'MyRequest'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|test_formPOSTRequest
dedent|''
name|'def'
name|'test_formPOSTRequest'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The request body of a I{POST} request with a I{Content-Type} header\n        of I{application/x-www-form-urlencoded} is parsed according to that\n        content type and made available in the C{args} attribute of the\n        request object.  The original bytes of the request may still be read\n        from the C{content} attribute.\n        """'
newline|'\n'
name|'query'
op|'='
string|"'key=value&multiple=two+words&multiple=more%20words&empty='"
newline|'\n'
name|'httpRequest'
op|'='
string|"'''\\\nPOST / HTTP/1.0\nContent-Length: %d\nContent-Type: application/x-www-form-urlencoded\n\n%s'''"
op|'%'
op|'('
name|'len'
op|'('
name|'query'
op|')'
op|','
name|'query'
op|')'
newline|'\n'
nl|'\n'
name|'testcase'
op|'='
name|'self'
newline|'\n'
DECL|class|MyRequest
name|'class'
name|'MyRequest'
op|'('
name|'http'
op|'.'
name|'Request'
op|')'
op|':'
newline|'\n'
DECL|member|process
indent|'            '
name|'def'
name|'process'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'testcase'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'method'
op|','
string|'"POST"'
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'args'
op|'['
string|'"key"'
op|']'
op|','
op|'['
string|'"value"'
op|']'
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'args'
op|'['
string|'"empty"'
op|']'
op|','
op|'['
string|'""'
op|']'
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'args'
op|'['
string|'"multiple"'
op|']'
op|','
op|'['
string|'"two words"'
op|','
string|'"more words"'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Reading from the content file-like must produce the entire'
nl|'\n'
comment|'# request body.'
nl|'\n'
name|'testcase'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'content'
op|'.'
name|'read'
op|'('
op|')'
op|','
name|'query'
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'didRequest'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'finish'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'runRequest'
op|'('
name|'httpRequest'
op|','
name|'MyRequest'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testMissingContentDisposition
dedent|''
name|'def'
name|'testMissingContentDisposition'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'req'
op|'='
string|"'''\\\nPOST / HTTP/1.0\nContent-Type: multipart/form-data; boundary=AaB03x\nContent-Length: 103\n\n--AaB03x\nContent-Type: text/plain\nContent-Transfer-Encoding: quoted-printable\n\nabasdfg\n--AaB03x--\n'''"
newline|'\n'
name|'self'
op|'.'
name|'runRequest'
op|'('
name|'req'
op|','
name|'http'
op|'.'
name|'Request'
op|','
name|'success'
op|'='
name|'False'
op|')'
newline|'\n'
nl|'\n'
DECL|function|test_chunkedEncoding
dedent|''
name|'def'
name|'test_chunkedEncoding'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a request uses the I{chunked} transfer encoding, the request body is\n        decoded accordingly before it is made available on the request.\n        """'
newline|'\n'
name|'httpRequest'
op|'='
string|"'''\\\nGET / HTTP/1.0\nContent-Type: text/plain\nTransfer-Encoding: chunked\n\n6\nHello,\n14\n spam,eggs spam spam\n0\n\n'''"
newline|'\n'
name|'testcase'
op|'='
name|'self'
newline|'\n'
DECL|class|MyRequest
name|'class'
name|'MyRequest'
op|'('
name|'http'
op|'.'
name|'Request'
op|')'
op|':'
newline|'\n'
DECL|member|process
indent|'            '
name|'def'
name|'process'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# The tempfile API used to create content returns an'
nl|'\n'
comment|'# instance of a different type depending on what platform'
nl|'\n'
comment|"# we're running on.  The point here is to verify that the"
nl|'\n'
comment|"# request body is in a file that's on the filesystem. "
nl|'\n'
comment|'# Having a fileno method that returns an int is a somewhat'
nl|'\n'
comment|'# close approximation of this. -exarkun'
nl|'\n'
indent|'                '
name|'testcase'
op|'.'
name|'assertIsInstance'
op|'('
name|'self'
op|'.'
name|'content'
op|'.'
name|'fileno'
op|'('
op|')'
op|','
name|'int'
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'method'
op|','
string|"'GET'"
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'path'
op|','
string|"'/'"
op|')'
newline|'\n'
name|'content'
op|'='
name|'self'
op|'.'
name|'content'
op|'.'
name|'read'
op|'('
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'assertEqual'
op|'('
name|'content'
op|','
string|"'Hello, spam,eggs spam spam'"
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'assertIdentical'
op|'('
name|'self'
op|'.'
name|'channel'
op|'.'
name|'_transferDecoder'
op|','
name|'None'
op|')'
newline|'\n'
name|'testcase'
op|'.'
name|'didRequest'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'finish'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'runRequest'
op|'('
name|'httpRequest'
op|','
name|'MyRequest'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|QueryArgumentsTestCase
dedent|''
dedent|''
name|'class'
name|'QueryArgumentsTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|testUnquote
indent|'    '
name|'def'
name|'testUnquote'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'from'
name|'twisted'
op|'.'
name|'protocols'
name|'import'
name|'_c_urlarg'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'unittest'
op|'.'
name|'SkipTest'
op|'('
string|'"_c_urlarg module is not available"'
op|')'
newline|'\n'
comment|'# work exactly like urllib.unquote, including stupid things'
nl|'\n'
comment|'# % followed by a non-hexdigit in the middle and in the end'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'urllib'
op|'.'
name|'unquote'
op|'('
string|'"%notreally%n"'
op|')'
op|','
nl|'\n'
name|'_c_urlarg'
op|'.'
name|'unquote'
op|'('
string|'"%notreally%n"'
op|')'
op|')'
newline|'\n'
comment|'# % followed by hexdigit, followed by non-hexdigit'
nl|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'urllib'
op|'.'
name|'unquote'
op|'('
string|'"%1quite%1"'
op|')'
op|','
nl|'\n'
name|'_c_urlarg'
op|'.'
name|'unquote'
op|'('
string|'"%1quite%1"'
op|')'
op|')'
newline|'\n'
comment|'# unquoted text, followed by some quoted chars, ends in a trailing %'
nl|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'urllib'
op|'.'
name|'unquote'
op|'('
string|'"blah%21%40%23blah%"'
op|')'
op|','
nl|'\n'
name|'_c_urlarg'
op|'.'
name|'unquote'
op|'('
string|'"blah%21%40%23blah%"'
op|')'
op|')'
newline|'\n'
comment|'# Empty string'
nl|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'urllib'
op|'.'
name|'unquote'
op|'('
string|'""'
op|')'
op|','
name|'_c_urlarg'
op|'.'
name|'unquote'
op|'('
string|'""'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testParseqs
dedent|''
name|'def'
name|'testParseqs'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'cgi'
op|'.'
name|'parse_qs'
op|'('
string|'"a=b&d=c;+=f"'
op|')'
op|','
nl|'\n'
name|'http'
op|'.'
name|'parse_qs'
op|'('
string|'"a=b&d=c;+=f"'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessRaises'
op|'('
name|'ValueError'
op|','
name|'http'
op|'.'
name|'parse_qs'
op|','
string|'"blah"'
op|','
nl|'\n'
name|'strict_parsing'
op|'='
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'cgi'
op|'.'
name|'parse_qs'
op|'('
string|'"a=&b=c"'
op|','
name|'keep_blank_values'
op|'='
number|'1'
op|')'
op|','
nl|'\n'
name|'http'
op|'.'
name|'parse_qs'
op|'('
string|'"a=&b=c"'
op|','
name|'keep_blank_values'
op|'='
number|'1'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'cgi'
op|'.'
name|'parse_qs'
op|'('
string|'"a=&b=c"'
op|')'
op|','
nl|'\n'
name|'http'
op|'.'
name|'parse_qs'
op|'('
string|'"a=&b=c"'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_urlparse
dedent|''
name|'def'
name|'test_urlparse'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        For a given URL, L{http.urlparse} should behave the same as\n        L{urlparse}, except it should always return C{str}, never C{unicode}.\n        """'
newline|'\n'
DECL|function|urls
name|'def'
name|'urls'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'scheme'
name|'in'
op|'('
string|"'http'"
op|','
string|"'https'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'host'
name|'in'
op|'('
string|"'example.com'"
op|','
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'for'
name|'port'
name|'in'
op|'('
name|'None'
op|','
number|'100'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'for'
name|'path'
name|'in'
op|'('
string|"''"
op|','
string|"'path'"
op|')'
op|':'
newline|'\n'
indent|'                            '
name|'if'
name|'port'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                                '
name|'host'
op|'='
name|'host'
op|'+'
string|"':'"
op|'+'
name|'str'
op|'('
name|'port'
op|')'
newline|'\n'
name|'yield'
name|'urlunsplit'
op|'('
op|'('
name|'scheme'
op|','
name|'host'
op|','
name|'path'
op|','
string|"''"
op|','
string|"''"
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|assertSameParsing
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'assertSameParsing'
op|'('
name|'url'
op|','
name|'decode'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""\n            Verify that C{url} is parsed into the same objects by both\n            L{http.urlparse} and L{urlparse}.\n            """'
newline|'\n'
name|'urlToStandardImplementation'
op|'='
name|'url'
newline|'\n'
name|'if'
name|'decode'
op|':'
newline|'\n'
indent|'                '
name|'urlToStandardImplementation'
op|'='
name|'url'
op|'.'
name|'decode'
op|'('
string|"'ascii'"
op|')'
newline|'\n'
dedent|''
name|'standardResult'
op|'='
name|'urlparse'
op|'('
name|'urlToStandardImplementation'
op|')'
newline|'\n'
name|'scheme'
op|','
name|'netloc'
op|','
name|'path'
op|','
name|'params'
op|','
name|'query'
op|','
name|'fragment'
op|'='
name|'http'
op|'.'
name|'urlparse'
op|'('
name|'url'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
op|'('
name|'scheme'
op|','
name|'netloc'
op|','
name|'path'
op|','
name|'params'
op|','
name|'query'
op|','
name|'fragment'
op|')'
op|','
nl|'\n'
name|'standardResult'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'isinstance'
op|'('
name|'scheme'
op|','
name|'str'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'isinstance'
op|'('
name|'netloc'
op|','
name|'str'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'isinstance'
op|'('
name|'path'
op|','
name|'str'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'isinstance'
op|'('
name|'params'
op|','
name|'str'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'isinstance'
op|'('
name|'query'
op|','
name|'str'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'isinstance'
op|'('
name|'fragment'
op|','
name|'str'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# With caching, unicode then str'
nl|'\n'
dedent|''
name|'clear_cache'
op|'('
op|')'
newline|'\n'
name|'for'
name|'url'
name|'in'
name|'urls'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'assertSameParsing'
op|'('
name|'url'
op|','
name|'True'
op|')'
newline|'\n'
name|'assertSameParsing'
op|'('
name|'url'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
comment|'# With caching, str then unicode'
nl|'\n'
dedent|''
name|'clear_cache'
op|'('
op|')'
newline|'\n'
name|'for'
name|'url'
name|'in'
name|'urls'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'assertSameParsing'
op|'('
name|'url'
op|','
name|'False'
op|')'
newline|'\n'
name|'assertSameParsing'
op|'('
name|'url'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
comment|'# Without caching'
nl|'\n'
dedent|''
name|'for'
name|'url'
name|'in'
name|'urls'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'clear_cache'
op|'('
op|')'
newline|'\n'
name|'assertSameParsing'
op|'('
name|'url'
op|','
name|'True'
op|')'
newline|'\n'
name|'clear_cache'
op|'('
op|')'
newline|'\n'
name|'assertSameParsing'
op|'('
name|'url'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_urlparseRejectsUnicode
dedent|''
dedent|''
name|'def'
name|'test_urlparseRejectsUnicode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{http.urlparse} should reject unicode input early.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'TypeError'
op|','
name|'http'
op|'.'
name|'urlparse'
op|','
string|"u'http://example.org/path'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testEscchar
dedent|''
name|'def'
name|'testEscchar'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'from'
name|'twisted'
op|'.'
name|'protocols'
name|'import'
name|'_c_urlarg'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'unittest'
op|'.'
name|'SkipTest'
op|'('
string|'"_c_urlarg module is not available"'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
string|'"!@#+b"'
op|','
nl|'\n'
name|'_c_urlarg'
op|'.'
name|'unquote'
op|'('
string|'"+21+40+23+b"'
op|','
string|'"+"'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|class|ClientDriver
dedent|''
dedent|''
name|'class'
name|'ClientDriver'
op|'('
name|'http'
op|'.'
name|'HTTPClient'
op|')'
op|':'
newline|'\n'
DECL|member|handleStatus
indent|'    '
name|'def'
name|'handleStatus'
op|'('
name|'self'
op|','
name|'version'
op|','
name|'status'
op|','
name|'message'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'version'
op|'='
name|'version'
newline|'\n'
name|'self'
op|'.'
name|'status'
op|'='
name|'status'
newline|'\n'
name|'self'
op|'.'
name|'message'
op|'='
name|'message'
newline|'\n'
nl|'\n'
DECL|class|ClientStatusParsing
dedent|''
dedent|''
name|'class'
name|'ClientStatusParsing'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|testBaseline
indent|'    '
name|'def'
name|'testBaseline'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'c'
op|'='
name|'ClientDriver'
op|'('
op|')'
newline|'\n'
name|'c'
op|'.'
name|'lineReceived'
op|'('
string|"'HTTP/1.0 201 foo'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'c'
op|'.'
name|'version'
op|','
string|"'HTTP/1.0'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'c'
op|'.'
name|'status'
op|','
string|"'201'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'c'
op|'.'
name|'message'
op|','
string|"'foo'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|testNoMessage
dedent|''
name|'def'
name|'testNoMessage'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'c'
op|'='
name|'ClientDriver'
op|'('
op|')'
newline|'\n'
name|'c'
op|'.'
name|'lineReceived'
op|'('
string|"'HTTP/1.0 201'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'c'
op|'.'
name|'version'
op|','
string|"'HTTP/1.0'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'c'
op|'.'
name|'status'
op|','
string|"'201'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'c'
op|'.'
name|'message'
op|','
string|"''"
op|')'
newline|'\n'
nl|'\n'
DECL|member|testNoMessage_trailingSpace
dedent|''
name|'def'
name|'testNoMessage_trailingSpace'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'c'
op|'='
name|'ClientDriver'
op|'('
op|')'
newline|'\n'
name|'c'
op|'.'
name|'lineReceived'
op|'('
string|"'HTTP/1.0 201 '"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'c'
op|'.'
name|'version'
op|','
string|"'HTTP/1.0'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'c'
op|'.'
name|'status'
op|','
string|"'201'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'c'
op|'.'
name|'message'
op|','
string|"''"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|RequestTests
dedent|''
dedent|''
name|'class'
name|'RequestTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|','
name|'ResponseTestMixin'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{http.Request}\n    """'
newline|'\n'
DECL|member|_compatHeadersTest
name|'def'
name|'_compatHeadersTest'
op|'('
name|'self'
op|','
name|'oldName'
op|','
name|'newName'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that each of two different attributes which are associated with\n        the same state properly reflect changes made through the other.\n\n        This is used to test that the C{headers}/C{responseHeaders} and\n        C{received_headers}/C{requestHeaders} pairs interact properly.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'getattr'
op|'('
name|'req'
op|','
name|'newName'
op|')'
op|'.'
name|'setRawHeaders'
op|'('
string|'"test"'
op|','
op|'['
string|'"lemur"'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'getattr'
op|'('
name|'req'
op|','
name|'oldName'
op|')'
op|'['
string|'"test"'
op|']'
op|','
string|'"lemur"'
op|')'
newline|'\n'
name|'setattr'
op|'('
name|'req'
op|','
name|'oldName'
op|','
op|'{'
string|'"foo"'
op|':'
string|'"bar"'
op|'}'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'list'
op|'('
name|'getattr'
op|'('
name|'req'
op|','
name|'newName'
op|')'
op|'.'
name|'getAllRawHeaders'
op|'('
op|')'
op|')'
op|','
nl|'\n'
op|'['
op|'('
string|'"Foo"'
op|','
op|'['
string|'"bar"'
op|']'
op|')'
op|']'
op|')'
newline|'\n'
name|'setattr'
op|'('
name|'req'
op|','
name|'newName'
op|','
name|'http_headers'
op|'.'
name|'Headers'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'getattr'
op|'('
name|'req'
op|','
name|'oldName'
op|')'
op|','
op|'{'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_received_headers
dedent|''
name|'def'
name|'test_received_headers'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Request.received_headers} is a backwards compatible API which\n        accesses and allows mutation of the state at L{Request.requestHeaders}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_compatHeadersTest'
op|'('
string|"'received_headers'"
op|','
string|"'requestHeaders'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_headers
dedent|''
name|'def'
name|'test_headers'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Request.headers} is a backwards compatible API which accesses and\n        allows mutation of the state at L{Request.responseHeaders}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_compatHeadersTest'
op|'('
string|"'headers'"
op|','
string|"'responseHeaders'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getHeader
dedent|''
name|'def'
name|'test_getHeader'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{http.Request.getHeader} returns the value of the named request\n        header.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'requestHeaders'
op|'.'
name|'setRawHeaders'
op|'('
string|'"test"'
op|','
op|'['
string|'"lemur"'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'req'
op|'.'
name|'getHeader'
op|'('
string|'"test"'
op|')'
op|','
string|'"lemur"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getHeaderReceivedMultiples
dedent|''
name|'def'
name|'test_getHeaderReceivedMultiples'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When there are multiple values for a single request header,\n        L{http.Request.getHeader} returns the last value.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'requestHeaders'
op|'.'
name|'setRawHeaders'
op|'('
string|'"test"'
op|','
op|'['
string|'"lemur"'
op|','
string|'"panda"'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'req'
op|'.'
name|'getHeader'
op|'('
string|'"test"'
op|')'
op|','
string|'"panda"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getHeaderNotFound
dedent|''
name|'def'
name|'test_getHeaderNotFound'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{http.Request.getHeader} returns C{None} when asked for the value of a\n        request header which is not present.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'req'
op|'.'
name|'getHeader'
op|'('
string|'"test"'
op|')'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getAllHeaders
dedent|''
name|'def'
name|'test_getAllHeaders'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{http.Request.getAllheaders} returns a C{dict} mapping all request\n        header names to their corresponding values.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'requestHeaders'
op|'.'
name|'setRawHeaders'
op|'('
string|'"test"'
op|','
op|'['
string|'"lemur"'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'req'
op|'.'
name|'getAllHeaders'
op|'('
op|')'
op|','
op|'{'
string|'"test"'
op|':'
string|'"lemur"'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getAllHeadersNoHeaders
dedent|''
name|'def'
name|'test_getAllHeadersNoHeaders'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{http.Request.getAllHeaders} returns an empty C{dict} if there are no\n        request headers.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'req'
op|'.'
name|'getAllHeaders'
op|'('
op|')'
op|','
op|'{'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getAllHeadersMultipleHeaders
dedent|''
name|'def'
name|'test_getAllHeadersMultipleHeaders'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When there are multiple values for a single request header,\n        L{http.Request.getAllHeaders} returns only the last value.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'requestHeaders'
op|'.'
name|'setRawHeaders'
op|'('
string|'"test"'
op|','
op|'['
string|'"lemur"'
op|','
string|'"panda"'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'req'
op|'.'
name|'getAllHeaders'
op|'('
op|')'
op|','
op|'{'
string|'"test"'
op|':'
string|'"panda"'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_setResponseCode
dedent|''
name|'def'
name|'test_setResponseCode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{http.Request.setResponseCode} takes a status code and causes it to be\n        used as the response status.\n        """'
newline|'\n'
name|'channel'
op|'='
name|'DummyChannel'
op|'('
op|')'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'channel'
op|','
name|'None'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'setResponseCode'
op|'('
number|'201'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'write'
op|'('
string|"''"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'channel'
op|'.'
name|'transport'
op|'.'
name|'written'
op|'.'
name|'getvalue'
op|'('
op|')'
op|'.'
name|'splitlines'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|','
nl|'\n'
string|"'%s 201 Created'"
op|'%'
op|'('
name|'req'
op|'.'
name|'clientproto'
op|','
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_setResponseCodeAndMessage
dedent|''
name|'def'
name|'test_setResponseCodeAndMessage'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{http.Request.setResponseCode} takes a status code and a message and\n        causes them to be used as the response status.\n        """'
newline|'\n'
name|'channel'
op|'='
name|'DummyChannel'
op|'('
op|')'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'channel'
op|','
name|'None'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'setResponseCode'
op|'('
number|'202'
op|','
string|'"happily accepted"'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'write'
op|'('
string|"''"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'channel'
op|'.'
name|'transport'
op|'.'
name|'written'
op|'.'
name|'getvalue'
op|'('
op|')'
op|'.'
name|'splitlines'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|','
nl|'\n'
string|"'%s 202 happily accepted'"
op|'%'
op|'('
name|'req'
op|'.'
name|'clientproto'
op|','
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_setResponseCodeAcceptsIntegers
dedent|''
name|'def'
name|'test_setResponseCodeAcceptsIntegers'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{http.Request.setResponseCode} accepts C{int} or C{long} for the code\n        parameter and raises L{TypeError} if passed anything else.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'setResponseCode'
op|'('
number|'1'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'setResponseCode'
op|'('
number|'1L'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'TypeError'
op|','
name|'req'
op|'.'
name|'setResponseCode'
op|','
string|'"1"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_setHost
dedent|''
name|'def'
name|'test_setHost'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{http.Request.setHost} sets the value of the host request header.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'setHost'
op|'('
string|'"example.com"'
op|','
number|'443'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'req'
op|'.'
name|'requestHeaders'
op|'.'
name|'getRawHeaders'
op|'('
string|'"host"'
op|')'
op|','
op|'['
string|'"example.com"'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_setHeader
dedent|''
name|'def'
name|'test_setHeader'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{http.Request.setHeader} sets the value of the given response header.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'setHeader'
op|'('
string|'"test"'
op|','
string|'"lemur"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'req'
op|'.'
name|'responseHeaders'
op|'.'
name|'getRawHeaders'
op|'('
string|'"test"'
op|')'
op|','
op|'['
string|'"lemur"'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_firstWrite
dedent|''
name|'def'
name|'test_firstWrite'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        For an HTTP 1.0 request, L{http.Request.write} sends an HTTP 1.0\n        Response-Line and whatever response headers are set.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'trans'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'req'
op|'.'
name|'transport'
op|'='
name|'trans'
newline|'\n'
nl|'\n'
name|'req'
op|'.'
name|'setResponseCode'
op|'('
number|'200'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'clientproto'
op|'='
string|'"HTTP/1.0"'
newline|'\n'
name|'req'
op|'.'
name|'responseHeaders'
op|'.'
name|'setRawHeaders'
op|'('
string|'"test"'
op|','
op|'['
string|'"lemur"'
op|']'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'write'
op|'('
string|"'Hello'"
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertResponseEquals'
op|'('
nl|'\n'
name|'trans'
op|'.'
name|'value'
op|'('
op|')'
op|','
nl|'\n'
op|'['
op|'('
string|'"HTTP/1.0 200 OK"'
op|','
nl|'\n'
string|'"Test: lemur"'
op|','
nl|'\n'
string|'"Hello"'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_firstWriteHTTP11Chunked
dedent|''
name|'def'
name|'test_firstWriteHTTP11Chunked'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        For an HTTP 1.1 request, L{http.Request.write} sends an HTTP 1.1\n        Response-Line, whatever response headers are set, and uses chunked\n        encoding for the response body.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'trans'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'req'
op|'.'
name|'transport'
op|'='
name|'trans'
newline|'\n'
nl|'\n'
name|'req'
op|'.'
name|'setResponseCode'
op|'('
number|'200'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'clientproto'
op|'='
string|'"HTTP/1.1"'
newline|'\n'
name|'req'
op|'.'
name|'responseHeaders'
op|'.'
name|'setRawHeaders'
op|'('
string|'"test"'
op|','
op|'['
string|'"lemur"'
op|']'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'write'
op|'('
string|"'Hello'"
op|')'
newline|'\n'
name|'req'
op|'.'
name|'write'
op|'('
string|"'World!'"
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertResponseEquals'
op|'('
nl|'\n'
name|'trans'
op|'.'
name|'value'
op|'('
op|')'
op|','
nl|'\n'
op|'['
op|'('
string|'"HTTP/1.1 200 OK"'
op|','
nl|'\n'
string|'"Test: lemur"'
op|','
nl|'\n'
string|'"Transfer-Encoding: chunked"'
op|','
nl|'\n'
string|'"5\\r\\nHello\\r\\n6\\r\\nWorld!\\r\\n"'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_firstWriteLastModified
dedent|''
name|'def'
name|'test_firstWriteLastModified'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        For an HTTP 1.0 request for a resource with a known last modified time,\n        L{http.Request.write} sends an HTTP Response-Line, whatever response\n        headers are set, and a last-modified header with that time.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'trans'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'req'
op|'.'
name|'transport'
op|'='
name|'trans'
newline|'\n'
nl|'\n'
name|'req'
op|'.'
name|'setResponseCode'
op|'('
number|'200'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'clientproto'
op|'='
string|'"HTTP/1.0"'
newline|'\n'
name|'req'
op|'.'
name|'lastModified'
op|'='
number|'0'
newline|'\n'
name|'req'
op|'.'
name|'responseHeaders'
op|'.'
name|'setRawHeaders'
op|'('
string|'"test"'
op|','
op|'['
string|'"lemur"'
op|']'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'write'
op|'('
string|"'Hello'"
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertResponseEquals'
op|'('
nl|'\n'
name|'trans'
op|'.'
name|'value'
op|'('
op|')'
op|','
nl|'\n'
op|'['
op|'('
string|'"HTTP/1.0 200 OK"'
op|','
nl|'\n'
string|'"Test: lemur"'
op|','
nl|'\n'
string|'"Last-Modified: Thu, 01 Jan 1970 00:00:00 GMT"'
op|','
nl|'\n'
string|'"Hello"'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_parseCookies
dedent|''
name|'def'
name|'test_parseCookies'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{http.Request.parseCookies} extracts cookies from C{requestHeaders}\n        and adds them to C{received_cookies}.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'requestHeaders'
op|'.'
name|'setRawHeaders'
op|'('
nl|'\n'
string|'"cookie"'
op|','
op|'['
string|'\'test="lemur"; test2="panda"\''
op|']'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'parseCookies'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'req'
op|'.'
name|'received_cookies'
op|','
op|'{'
string|'"test"'
op|':'
string|'\'"lemur"\''
op|','
nl|'\n'
string|'"test2"'
op|':'
string|'\'"panda"\''
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_parseCookiesMultipleHeaders
dedent|''
name|'def'
name|'test_parseCookiesMultipleHeaders'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{http.Request.parseCookies} can extract cookies from multiple Cookie\n        headers.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'requestHeaders'
op|'.'
name|'setRawHeaders'
op|'('
nl|'\n'
string|'"cookie"'
op|','
op|'['
string|'\'test="lemur"\''
op|','
string|'\'test2="panda"\''
op|']'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'parseCookies'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'req'
op|'.'
name|'received_cookies'
op|','
op|'{'
string|'"test"'
op|':'
string|'\'"lemur"\''
op|','
nl|'\n'
string|'"test2"'
op|':'
string|'\'"panda"\''
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_connectionLost
dedent|''
name|'def'
name|'test_connectionLost'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{http.Request.connectionLost} closes L{Request.content} and drops the\n        reference to the L{HTTPChannel} to assist with garbage collection.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
comment|'# Cause Request.content to be created at all.'
nl|'\n'
name|'req'
op|'.'
name|'gotLength'
op|'('
number|'10'
op|')'
newline|'\n'
nl|'\n'
comment|'# Grab a reference to content in case the Request drops it later on.'
nl|'\n'
name|'content'
op|'='
name|'req'
op|'.'
name|'content'
newline|'\n'
nl|'\n'
comment|'# Put some bytes into it'
nl|'\n'
name|'req'
op|'.'
name|'handleContentChunk'
op|'('
string|'"hello"'
op|')'
newline|'\n'
nl|'\n'
comment|'# Then something goes wrong and content should get closed.'
nl|'\n'
name|'req'
op|'.'
name|'connectionLost'
op|'('
name|'Failure'
op|'('
name|'ConnectionLost'
op|'('
string|'"Finished"'
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'content'
op|'.'
name|'closed'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'req'
op|'.'
name|'channel'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_registerProducerTwiceFails
dedent|''
name|'def'
name|'test_registerProducerTwiceFails'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Calling L{Request.registerProducer} when a producer is already\n        registered raises ValueError.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'registerProducer'
op|'('
name|'DummyProducer'
op|'('
op|')'
op|','
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
nl|'\n'
name|'ValueError'
op|','
name|'req'
op|'.'
name|'registerProducer'
op|','
name|'DummyProducer'
op|'('
op|')'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_registerProducerWhenQueuedPausesPushProducer
dedent|''
name|'def'
name|'test_registerProducerWhenQueuedPausesPushProducer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Calling L{Request.registerProducer} with an IPushProducer when the\n        request is queued pauses the producer.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'True'
op|')'
newline|'\n'
name|'producer'
op|'='
name|'DummyProducer'
op|'('
op|')'
newline|'\n'
name|'req'
op|'.'
name|'registerProducer'
op|'('
name|'producer'
op|','
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
op|'['
string|"'pause'"
op|']'
op|','
name|'producer'
op|'.'
name|'events'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_registerProducerWhenQueuedDoesntPausePullProducer
dedent|''
name|'def'
name|'test_registerProducerWhenQueuedDoesntPausePullProducer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Calling L{Request.registerProducer} with an IPullProducer when the\n        request is queued does not pause the producer, because it doesn\'t make\n        sense to pause a pull producer.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'True'
op|')'
newline|'\n'
name|'producer'
op|'='
name|'DummyProducer'
op|'('
op|')'
newline|'\n'
name|'req'
op|'.'
name|'registerProducer'
op|'('
name|'producer'
op|','
name|'False'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
op|'['
op|']'
op|','
name|'producer'
op|'.'
name|'events'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_registerProducerWhenQueuedDoesntRegisterPushProducer
dedent|''
name|'def'
name|'test_registerProducerWhenQueuedDoesntRegisterPushProducer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Calling L{Request.registerProducer} with an IPushProducer when the\n        request is queued does not register the producer on the request\'s\n        transport.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
nl|'\n'
name|'None'
op|','
name|'getattr'
op|'('
name|'http'
op|'.'
name|'StringTransport'
op|','
string|"'registerProducer'"
op|','
name|'None'
op|')'
op|','
nl|'\n'
string|'"StringTransport cannot implement registerProducer for this test "'
nl|'\n'
string|'"to be valid."'
op|')'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'True'
op|')'
newline|'\n'
name|'producer'
op|'='
name|'DummyProducer'
op|'('
op|')'
newline|'\n'
name|'req'
op|'.'
name|'registerProducer'
op|'('
name|'producer'
op|','
name|'True'
op|')'
newline|'\n'
comment|"# This is a roundabout assertion: http.StringTransport doesn't"
nl|'\n'
comment|"# implement registerProducer, so Request.registerProducer can't have"
nl|'\n'
comment|'# tried to call registerProducer on the transport.'
nl|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'req'
op|'.'
name|'transport'
op|','
name|'http'
op|'.'
name|'StringTransport'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_registerProducerWhenQueuedDoesntRegisterPullProducer
dedent|''
name|'def'
name|'test_registerProducerWhenQueuedDoesntRegisterPullProducer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Calling L{Request.registerProducer} with an IPullProducer when the\n        request is queued does not register the producer on the request\'s\n        transport.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
nl|'\n'
name|'None'
op|','
name|'getattr'
op|'('
name|'http'
op|'.'
name|'StringTransport'
op|','
string|"'registerProducer'"
op|','
name|'None'
op|')'
op|','
nl|'\n'
string|'"StringTransport cannot implement registerProducer for this test "'
nl|'\n'
string|'"to be valid."'
op|')'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'True'
op|')'
newline|'\n'
name|'producer'
op|'='
name|'DummyProducer'
op|'('
op|')'
newline|'\n'
name|'req'
op|'.'
name|'registerProducer'
op|'('
name|'producer'
op|','
name|'False'
op|')'
newline|'\n'
comment|"# This is a roundabout assertion: http.StringTransport doesn't"
nl|'\n'
comment|"# implement registerProducer, so Request.registerProducer can't have"
nl|'\n'
comment|'# tried to call registerProducer on the transport.'
nl|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'req'
op|'.'
name|'transport'
op|','
name|'http'
op|'.'
name|'StringTransport'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_registerProducerWhenNotQueuedRegistersPushProducer
dedent|''
name|'def'
name|'test_registerProducerWhenNotQueuedRegistersPushProducer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Calling L{Request.registerProducer} with an IPushProducer when the\n        request is not queued registers the producer as a push producer on the\n        request\'s transport.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'False'
op|')'
newline|'\n'
name|'producer'
op|'='
name|'DummyProducer'
op|'('
op|')'
newline|'\n'
name|'req'
op|'.'
name|'registerProducer'
op|'('
name|'producer'
op|','
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
op|'['
op|'('
name|'producer'
op|','
name|'True'
op|')'
op|']'
op|','
name|'req'
op|'.'
name|'transport'
op|'.'
name|'producers'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_registerProducerWhenNotQueuedRegistersPullProducer
dedent|''
name|'def'
name|'test_registerProducerWhenNotQueuedRegistersPullProducer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Calling L{Request.registerProducer} with an IPullProducer when the\n        request is not queued registers the producer as a pull producer on the\n        request\'s transport.\n        """'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'False'
op|')'
newline|'\n'
name|'producer'
op|'='
name|'DummyProducer'
op|'('
op|')'
newline|'\n'
name|'req'
op|'.'
name|'registerProducer'
op|'('
name|'producer'
op|','
name|'False'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
op|'['
op|'('
name|'producer'
op|','
name|'False'
op|')'
op|']'
op|','
name|'req'
op|'.'
name|'transport'
op|'.'
name|'producers'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_connectionLostNotification
dedent|''
name|'def'
name|'test_connectionLostNotification'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Request.connectionLost} triggers all finish notification Deferreds\n        and cleans up per-request state.\n        """'
newline|'\n'
name|'d'
op|'='
name|'DummyChannel'
op|'('
op|')'
newline|'\n'
name|'request'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'d'
op|','
name|'True'
op|')'
newline|'\n'
name|'finished'
op|'='
name|'request'
op|'.'
name|'notifyFinish'
op|'('
op|')'
newline|'\n'
name|'request'
op|'.'
name|'connectionLost'
op|'('
name|'Failure'
op|'('
name|'ConnectionLost'
op|'('
string|'"Connection done"'
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'request'
op|'.'
name|'channel'
op|','
name|'None'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'finished'
op|','
name|'ConnectionLost'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_finishNotification
dedent|''
name|'def'
name|'test_finishNotification'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Request.finish} triggers all finish notification Deferreds.\n        """'
newline|'\n'
name|'request'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'DummyChannel'
op|'('
op|')'
op|','
name|'False'
op|')'
newline|'\n'
name|'finished'
op|'='
name|'request'
op|'.'
name|'notifyFinish'
op|'('
op|')'
newline|'\n'
comment|'# Force the request to have a non-None content attribute.  This is'
nl|'\n'
comment|'# probably a bug in Request.'
nl|'\n'
name|'request'
op|'.'
name|'gotLength'
op|'('
number|'1'
op|')'
newline|'\n'
name|'request'
op|'.'
name|'finish'
op|'('
op|')'
newline|'\n'
name|'return'
name|'finished'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_finishAfterConnectionLost
dedent|''
name|'def'
name|'test_finishAfterConnectionLost'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Calling L{Request.finish} after L{Request.connectionLost} has been\n        called results in a L{RuntimeError} being raised.\n        """'
newline|'\n'
name|'channel'
op|'='
name|'DummyChannel'
op|'('
op|')'
newline|'\n'
name|'transport'
op|'='
name|'channel'
op|'.'
name|'transport'
newline|'\n'
name|'req'
op|'='
name|'http'
op|'.'
name|'Request'
op|'('
name|'channel'
op|','
name|'False'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'connectionLost'
op|'('
name|'Failure'
op|'('
name|'ConnectionLost'
op|'('
string|'"The end."'
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'RuntimeError'
op|','
name|'req'
op|'.'
name|'finish'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|MultilineHeadersTestCase
dedent|''
dedent|''
name|'class'
name|'MultilineHeadersTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests to exercise handling of multiline headers by L{HTTPClient}.  RFCs 1945\n    (HTTP 1.0) and 2616 (HTTP 1.1) state that HTTP message header fields can\n    span multiple lines if each extra line is preceded by at least one space or\n    horizontal tab.\n    """'
newline|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Initialize variables used to verify that the header-processing functions\n        are getting called.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'handleHeaderCalled'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'handleEndHeadersCalled'
op|'='
name|'False'
newline|'\n'
nl|'\n'
comment|'# Dictionary of sample complete HTTP header key/value pairs, including'
nl|'\n'
comment|'# multiline headers.'
nl|'\n'
DECL|variable|expectedHeaders
dedent|''
name|'expectedHeaders'
op|'='
op|'{'
string|"'Content-Length'"
op|':'
string|"'10'"
op|','
nl|'\n'
string|"'X-Multiline'"
op|':'
string|"'line-0\\tline-1'"
op|','
nl|'\n'
string|"'X-Multiline2'"
op|':'
string|"'line-2 line-3'"
op|'}'
newline|'\n'
nl|'\n'
DECL|member|ourHandleHeader
name|'def'
name|'ourHandleHeader'
op|'('
name|'self'
op|','
name|'key'
op|','
name|'val'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Dummy implementation of L{HTTPClient.handleHeader}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'handleHeaderCalled'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'val'
op|','
name|'self'
op|'.'
name|'expectedHeaders'
op|'['
name|'key'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|ourHandleEndHeaders
dedent|''
name|'def'
name|'ourHandleEndHeaders'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Dummy implementation of L{HTTPClient.handleEndHeaders}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'handleEndHeadersCalled'
op|'='
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_extractHeader
dedent|''
name|'def'
name|'test_extractHeader'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A header isn\'t processed by L{HTTPClient.extractHeader} until it is\n        confirmed in L{HTTPClient.lineReceived} that the header has been\n        received completely.\n        """'
newline|'\n'
name|'c'
op|'='
name|'ClientDriver'
op|'('
op|')'
newline|'\n'
name|'c'
op|'.'
name|'handleHeader'
op|'='
name|'self'
op|'.'
name|'ourHandleHeader'
newline|'\n'
name|'c'
op|'.'
name|'handleEndHeaders'
op|'='
name|'self'
op|'.'
name|'ourHandleEndHeaders'
newline|'\n'
nl|'\n'
name|'c'
op|'.'
name|'lineReceived'
op|'('
string|"'HTTP/1.0 201'"
op|')'
newline|'\n'
name|'c'
op|'.'
name|'lineReceived'
op|'('
string|"'Content-Length: 10'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'c'
op|'.'
name|'length'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'self'
op|'.'
name|'handleHeaderCalled'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'self'
op|'.'
name|'handleEndHeadersCalled'
op|')'
newline|'\n'
nl|'\n'
comment|'# Signal end of headers.'
nl|'\n'
name|'c'
op|'.'
name|'lineReceived'
op|'('
string|"''"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'handleHeaderCalled'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'handleEndHeadersCalled'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'c'
op|'.'
name|'length'
op|','
number|'10'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_noHeaders
dedent|''
name|'def'
name|'test_noHeaders'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        An HTTP request with no headers will not cause any calls to\n        L{handleHeader} but will cause L{handleEndHeaders} to be called on\n        L{HTTPClient} subclasses.\n        """'
newline|'\n'
name|'c'
op|'='
name|'ClientDriver'
op|'('
op|')'
newline|'\n'
name|'c'
op|'.'
name|'handleHeader'
op|'='
name|'self'
op|'.'
name|'ourHandleHeader'
newline|'\n'
name|'c'
op|'.'
name|'handleEndHeaders'
op|'='
name|'self'
op|'.'
name|'ourHandleEndHeaders'
newline|'\n'
name|'c'
op|'.'
name|'lineReceived'
op|'('
string|"'HTTP/1.0 201'"
op|')'
newline|'\n'
nl|'\n'
comment|'# Signal end of headers.'
nl|'\n'
name|'c'
op|'.'
name|'lineReceived'
op|'('
string|"''"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'self'
op|'.'
name|'handleHeaderCalled'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'handleEndHeadersCalled'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'c'
op|'.'
name|'version'
op|','
string|"'HTTP/1.0'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'c'
op|'.'
name|'status'
op|','
string|"'201'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_multilineHeaders
dedent|''
name|'def'
name|'test_multilineHeaders'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{HTTPClient} parses multiline headers by buffering header lines until\n        an empty line or a line that does not start with whitespace hits\n        lineReceived, confirming that the header has been received completely.\n        """'
newline|'\n'
name|'c'
op|'='
name|'ClientDriver'
op|'('
op|')'
newline|'\n'
name|'c'
op|'.'
name|'handleHeader'
op|'='
name|'self'
op|'.'
name|'ourHandleHeader'
newline|'\n'
name|'c'
op|'.'
name|'handleEndHeaders'
op|'='
name|'self'
op|'.'
name|'ourHandleEndHeaders'
newline|'\n'
nl|'\n'
name|'c'
op|'.'
name|'lineReceived'
op|'('
string|"'HTTP/1.0 201'"
op|')'
newline|'\n'
name|'c'
op|'.'
name|'lineReceived'
op|'('
string|"'X-Multiline: line-0'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'self'
op|'.'
name|'handleHeaderCalled'
op|')'
newline|'\n'
comment|'# Start continuing line with a tab.'
nl|'\n'
name|'c'
op|'.'
name|'lineReceived'
op|'('
string|"'\\tline-1'"
op|')'
newline|'\n'
name|'c'
op|'.'
name|'lineReceived'
op|'('
string|"'X-Multiline2: line-2'"
op|')'
newline|'\n'
comment|'# The previous header must be complete, so now it can be processed.'
nl|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'handleHeaderCalled'
op|')'
newline|'\n'
comment|'# Start continuing line with a space.'
nl|'\n'
name|'c'
op|'.'
name|'lineReceived'
op|'('
string|"' line-3'"
op|')'
newline|'\n'
name|'c'
op|'.'
name|'lineReceived'
op|'('
string|"'Content-Length: 10'"
op|')'
newline|'\n'
nl|'\n'
comment|'# Signal end of headers.'
nl|'\n'
name|'c'
op|'.'
name|'lineReceived'
op|'('
string|"''"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'handleEndHeadersCalled'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'c'
op|'.'
name|'version'
op|','
string|"'HTTP/1.0'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'c'
op|'.'
name|'status'
op|','
string|"'201'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'c'
op|'.'
name|'length'
op|','
number|'10'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
