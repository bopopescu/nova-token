begin_unit
comment|'# -*- test-case-name: twisted.web.test.test_xml -*-'
nl|'\n'
comment|'# Copyright (c) 2001-2008 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nSome fairly inadequate testcases for Twisted XML support.\n"""'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
op|'.'
name|'unittest'
name|'import'
name|'TestCase'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
name|'import'
name|'sux'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
name|'import'
name|'microdom'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'web'
name|'import'
name|'domhelpers'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Sux0r
name|'class'
name|'Sux0r'
op|'('
name|'sux'
op|'.'
name|'XMLParser'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'tokens'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|getTagStarts
dedent|''
name|'def'
name|'getTagStarts'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'['
name|'token'
name|'for'
name|'token'
name|'in'
name|'self'
op|'.'
name|'tokens'
name|'if'
name|'token'
op|'['
number|'0'
op|']'
op|'=='
string|"'start'"
op|']'
newline|'\n'
nl|'\n'
DECL|member|gotTagStart
dedent|''
name|'def'
name|'gotTagStart'
op|'('
name|'self'
op|','
name|'name'
op|','
name|'attrs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'tokens'
op|'.'
name|'append'
op|'('
op|'('
string|'"start"'
op|','
name|'name'
op|','
name|'attrs'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|gotText
dedent|''
name|'def'
name|'gotText'
op|'('
name|'self'
op|','
name|'text'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'tokens'
op|'.'
name|'append'
op|'('
op|'('
string|'"text"'
op|','
name|'text'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|class|SUXTest
dedent|''
dedent|''
name|'class'
name|'SUXTest'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|testBork
indent|'    '
name|'def'
name|'testBork'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|'"<bork><bork><bork>"'
newline|'\n'
name|'ms'
op|'='
name|'Sux0r'
op|'('
op|')'
newline|'\n'
name|'ms'
op|'.'
name|'connectionMade'
op|'('
op|')'
newline|'\n'
name|'ms'
op|'.'
name|'dataReceived'
op|'('
name|'s'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'len'
op|'('
name|'ms'
op|'.'
name|'getTagStarts'
op|'('
op|')'
op|')'
op|','
number|'3'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|MicroDOMTest
dedent|''
dedent|''
name|'class'
name|'MicroDOMTest'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|test_leadingTextDropping
indent|'    '
name|'def'
name|'test_leadingTextDropping'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Make sure that if there\'s no top-level node lenient-mode won\'t\n        drop leading text that\'s outside of any elements.\n        """'
newline|'\n'
name|'s'
op|'='
string|'"Hi orders! <br>Well. <br>"'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'beExtremelyLenient'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'firstChild'
op|'('
op|')'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
nl|'\n'
string|"'<html>Hi orders! <br />Well. <br /></html>'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_trailingTextDropping
dedent|''
name|'def'
name|'test_trailingTextDropping'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Ensure that no *trailing* text in a mal-formed\n        no-top-level-element document(s) will not be dropped.\n        """'
newline|'\n'
name|'s'
op|'='
string|'"<br>Hi orders!"'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'beExtremelyLenient'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'firstChild'
op|'('
op|')'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
nl|'\n'
string|"'<html><br />Hi orders!</html>'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_noTags
dedent|''
name|'def'
name|'test_noTags'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A string with nothing that looks like a tag at all should just\n        be parsed as body text.\n        """'
newline|'\n'
name|'s'
op|'='
string|'"Hi orders!"'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'beExtremelyLenient'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'firstChild'
op|'('
op|')'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
nl|'\n'
string|'"<html>Hi orders!</html>"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_surroundingCrap
dedent|''
name|'def'
name|'test_surroundingCrap'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a document is surrounded by non-xml text, the text should\n        be remain in the XML.\n        """'
newline|'\n'
name|'s'
op|'='
string|'"Hi<br> orders!"'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'beExtremelyLenient'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'firstChild'
op|'('
op|')'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
nl|'\n'
string|'"<html>Hi<br /> orders!</html>"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testCaseSensitiveSoonCloser
dedent|''
name|'def'
name|'testCaseSensitiveSoonCloser'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|'"""\n              <HTML><BODY>\n              <P ALIGN="CENTER">\n                <A HREF="http://www.apache.org/"><IMG SRC="/icons/apache_pb.gif"></A>\n              </P>\n\n              <P>\n                This is an insane set of text nodes that should NOT be gathered under\n                the A tag above.\n              </P>\n              </BODY></HTML>\n            """'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'beExtremelyLenient'
op|'='
number|'1'
op|')'
newline|'\n'
name|'l'
op|'='
name|'domhelpers'
op|'.'
name|'findNodesNamed'
op|'('
name|'d'
op|'.'
name|'documentElement'
op|','
string|"'a'"
op|')'
newline|'\n'
name|'n'
op|'='
name|'domhelpers'
op|'.'
name|'gatherTextNodes'
op|'('
name|'l'
op|'['
number|'0'
op|']'
op|','
number|'1'
op|')'
op|'.'
name|'replace'
op|'('
string|"'&nbsp;'"
op|','
string|"' '"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'n'
op|'.'
name|'find'
op|'('
string|"'insane'"
op|')'
op|','
op|'-'
number|'1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_lenientParenting
dedent|''
name|'def'
name|'test_lenientParenting'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that C{parentNode} attributes are set to meaningful values when\n        we are parsing HTML that lacks a root node.\n        """'
newline|'\n'
comment|'# Spare the rod, ruin the child.'
nl|'\n'
name|'s'
op|'='
string|'"<br/><br/>"'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'beExtremelyLenient'
op|'='
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'d'
op|'.'
name|'documentElement'
op|','
nl|'\n'
name|'d'
op|'.'
name|'documentElement'
op|'.'
name|'firstChild'
op|'('
op|')'
op|'.'
name|'parentNode'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_lenientParentSingle
dedent|''
name|'def'
name|'test_lenientParentSingle'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that the C{parentNode} attribute is set to a meaningful value\n        when we parse an HTML document that has a non-Element root node.\n        """'
newline|'\n'
name|'s'
op|'='
string|'"Hello"'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'beExtremelyLenient'
op|'='
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'d'
op|'.'
name|'documentElement'
op|','
nl|'\n'
name|'d'
op|'.'
name|'documentElement'
op|'.'
name|'firstChild'
op|'('
op|')'
op|'.'
name|'parentNode'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testUnEntities
dedent|''
name|'def'
name|'testUnEntities'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|'"""\n                <HTML>\n                    This HTML goes between Stupid <=CrAzY!=> Dumb.\n                </HTML>\n            """'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'beExtremelyLenient'
op|'='
number|'1'
op|')'
newline|'\n'
name|'n'
op|'='
name|'domhelpers'
op|'.'
name|'gatherTextNodes'
op|'('
name|'d'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertNotEquals'
op|'('
name|'n'
op|'.'
name|'find'
op|'('
string|"'>'"
op|')'
op|','
op|'-'
number|'1'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testEmptyError
dedent|''
name|'def'
name|'testEmptyError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'sux'
op|'.'
name|'ParseError'
op|','
name|'microdom'
op|'.'
name|'parseString'
op|','
string|'""'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testTameDocument
dedent|''
name|'def'
name|'testTameDocument'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|'"""\n        <test>\n         <it>\n          <is>\n           <a>\n            test\n           </a>\n          </is>\n         </it>\n        </test>\n        """'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'domhelpers'
op|'.'
name|'gatherTextNodes'
op|'('
name|'d'
op|'.'
name|'documentElement'
op|')'
op|'.'
name|'strip'
op|'('
op|')'
op|','
string|"'test'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|testAwfulTagSoup
dedent|''
name|'def'
name|'testAwfulTagSoup'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|'"""\n        <html>\n        <head><title> I send you this message to have your advice!!!!</titl e\n        </headd>\n\n        <body bgcolor alink hlink vlink>\n\n        <h1><BLINK>SALE</blINK> TWENTY MILLION EMAILS & FUR COAT NOW\n        FREE WITH `ENLARGER\'</h1>\n\n        YES THIS WONDERFUL AWFER IS NOW HERER!!!\n\n        <script LANGUAGE="javascript">\nfunction give_answers() {\nif (score < 70) {\nalert("I hate you");\n}}\n        </script><a href=/foo.com/lalal name=foo>lalal</a>\n        </body>\n        </HTML>\n        """'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'beExtremelyLenient'
op|'='
number|'1'
op|')'
newline|'\n'
name|'l'
op|'='
name|'domhelpers'
op|'.'
name|'findNodesNamed'
op|'('
name|'d'
op|'.'
name|'documentElement'
op|','
string|"'blink'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'l'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testScriptLeniency
dedent|''
name|'def'
name|'testScriptLeniency'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|'"""\n        <script>(foo < bar) and (bar > foo)</script>\n        <script language="javascript">foo </scrip bar </script>\n        <script src="foo">\n        <script src="foo">baz</script>\n        <script /><script></script>\n        """'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'beExtremelyLenient'
op|'='
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'firstChild'
op|'('
op|')'
op|'.'
name|'firstChild'
op|'('
op|')'
op|'.'
name|'firstChild'
op|'('
op|')'
op|'.'
name|'data'
op|','
nl|'\n'
string|'"(foo < bar) and (bar > foo)"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'d'
op|'.'
name|'firstChild'
op|'('
op|')'
op|'.'
name|'getElementsByTagName'
op|'('
string|'"script"'
op|')'
op|'['
number|'1'
op|']'
op|'.'
name|'firstChild'
op|'('
op|')'
op|'.'
name|'data'
op|','
nl|'\n'
string|'"foo </scrip bar "'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testScriptLeniencyIntelligence
dedent|''
name|'def'
name|'testScriptLeniencyIntelligence'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# if there is comment or CDATA in script, the autoquoting in bEL mode'
nl|'\n'
comment|'# should not happen'
nl|'\n'
indent|'        '
name|'s'
op|'='
string|'"""<script><!-- lalal --></script>"""'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'beExtremelyLenient'
op|'='
number|'1'
op|')'
op|'.'
name|'firstChild'
op|'('
op|')'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
name|'s'
op|')'
newline|'\n'
name|'s'
op|'='
string|'"""<script><![CDATA[lalal]]></script>"""'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'beExtremelyLenient'
op|'='
number|'1'
op|')'
op|'.'
name|'firstChild'
op|'('
op|')'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
name|'s'
op|')'
newline|'\n'
name|'s'
op|'='
string|'"""<script> // <![CDATA[\n        lalal\n        //]]></script>"""'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'beExtremelyLenient'
op|'='
number|'1'
op|')'
op|'.'
name|'firstChild'
op|'('
op|')'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
name|'s'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testPreserveCase
dedent|''
name|'def'
name|'testPreserveCase'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|"'<eNcApSuLaTe><sUxor></sUxor><bOrk><w00T>TeXt</W00t></BoRk></EnCaPsUlAtE>'"
newline|'\n'
name|'s2'
op|'='
name|'s'
op|'.'
name|'lower'
op|'('
op|')'
op|'.'
name|'replace'
op|'('
string|"'text'"
op|','
string|"'TeXt'"
op|')'
newline|'\n'
comment|'# these are the only two option permutations that *can* parse the above'
nl|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'caseInsensitive'
op|'='
number|'1'
op|','
name|'preserveCase'
op|'='
number|'1'
op|')'
newline|'\n'
name|'d2'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'caseInsensitive'
op|'='
number|'1'
op|','
name|'preserveCase'
op|'='
number|'0'
op|')'
newline|'\n'
comment|"# caseInsensitive=0 preserveCase=0 is not valid, it's converted to"
nl|'\n'
comment|'# caseInsensitive=0 preserveCase=1'
nl|'\n'
name|'d3'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s2'
op|','
name|'caseInsensitive'
op|'='
number|'0'
op|','
name|'preserveCase'
op|'='
number|'1'
op|')'
newline|'\n'
name|'d4'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s2'
op|','
name|'caseInsensitive'
op|'='
number|'1'
op|','
name|'preserveCase'
op|'='
number|'0'
op|')'
newline|'\n'
name|'d5'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s2'
op|','
name|'caseInsensitive'
op|'='
number|'1'
op|','
name|'preserveCase'
op|'='
number|'1'
op|')'
newline|'\n'
comment|"# this is slightly contrived, toxml() doesn't need to be identical"
nl|'\n'
comment|'# for the documents to be equivalent (i.e. <b></b> to <b/>),'
nl|'\n'
comment|'# however this assertion tests preserving case for start and'
nl|'\n'
comment|'# end tags while still matching stuff like <bOrk></BoRk>'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'documentElement'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
name|'s'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'d'
op|'.'
name|'isEqualToDocument'
op|'('
name|'d2'
op|')'
op|','
string|'"%r != %r"'
op|'%'
op|'('
name|'d'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
name|'d2'
op|'.'
name|'toxml'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'d2'
op|'.'
name|'isEqualToDocument'
op|'('
name|'d3'
op|')'
op|','
string|'"%r != %r"'
op|'%'
op|'('
name|'d2'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
name|'d3'
op|'.'
name|'toxml'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
comment|'# caseInsensitive=0 on the left, NOT perserveCase=1 on the right'
nl|'\n'
comment|'## XXX THIS TEST IS TURNED OFF UNTIL SOMEONE WHO CARES ABOUT FIXING IT DOES'
nl|'\n'
comment|'#self.failIf(d3.isEqualToDocument(d2), "%r == %r" % (d3.toxml(), d2.toxml()))'
nl|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'d3'
op|'.'
name|'isEqualToDocument'
op|'('
name|'d4'
op|')'
op|','
string|'"%r != %r"'
op|'%'
op|'('
name|'d3'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
name|'d4'
op|'.'
name|'toxml'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'d4'
op|'.'
name|'isEqualToDocument'
op|'('
name|'d5'
op|')'
op|','
string|'"%r != %r"'
op|'%'
op|'('
name|'d4'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
name|'d5'
op|'.'
name|'toxml'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testDifferentQuotes
dedent|''
name|'def'
name|'testDifferentQuotes'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|'\'<test a="a" b=\\\'b\\\' />\''
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|')'
newline|'\n'
name|'e'
op|'='
name|'d'
op|'.'
name|'documentElement'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'e'
op|'.'
name|'getAttribute'
op|'('
string|"'a'"
op|')'
op|','
string|"'a'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'e'
op|'.'
name|'getAttribute'
op|'('
string|"'b'"
op|')'
op|','
string|"'b'"
op|')'
newline|'\n'
nl|'\n'
DECL|function|testLinebreaks
dedent|''
name|'def'
name|'testLinebreaks'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|'\'<test \\na="a"\\n\\tb="#b" />\''
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|')'
newline|'\n'
name|'e'
op|'='
name|'d'
op|'.'
name|'documentElement'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'e'
op|'.'
name|'getAttribute'
op|'('
string|"'a'"
op|')'
op|','
string|"'a'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'e'
op|'.'
name|'getAttribute'
op|'('
string|"'b'"
op|')'
op|','
string|"'#b'"
op|')'
newline|'\n'
nl|'\n'
DECL|function|testMismatchedTags
dedent|''
name|'def'
name|'testMismatchedTags'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'s'
name|'in'
string|"'<test>'"
op|','
string|"'<test> </tset>'"
op|','
string|"'</test>'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'microdom'
op|'.'
name|'MismatchedTags'
op|','
name|'microdom'
op|'.'
name|'parseString'
op|','
name|'s'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testComment
dedent|''
dedent|''
name|'def'
name|'testComment'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|'"<bar><!--<foo />--></bar>"'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|')'
newline|'\n'
name|'e'
op|'='
name|'d'
op|'.'
name|'documentElement'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'e'
op|'.'
name|'nodeName'
op|','
string|'"bar"'
op|')'
newline|'\n'
name|'c'
op|'='
name|'e'
op|'.'
name|'childNodes'
op|'['
number|'0'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'isinstance'
op|'('
name|'c'
op|','
name|'microdom'
op|'.'
name|'Comment'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'c'
op|'.'
name|'value'
op|','
string|'"<foo />"'
op|')'
newline|'\n'
name|'c2'
op|'='
name|'c'
op|'.'
name|'cloneNode'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'c'
name|'is'
name|'not'
name|'c2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'c2'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
string|'"<!--<foo />-->"'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testText
dedent|''
name|'def'
name|'testText'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
string|'"<bar>xxxx</bar>"'
op|')'
op|'.'
name|'documentElement'
newline|'\n'
name|'text'
op|'='
name|'d'
op|'.'
name|'childNodes'
op|'['
number|'0'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'isinstance'
op|'('
name|'text'
op|','
name|'microdom'
op|'.'
name|'Text'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'text'
op|'.'
name|'value'
op|','
string|'"xxxx"'
op|')'
newline|'\n'
name|'clone'
op|'='
name|'text'
op|'.'
name|'cloneNode'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'clone'
name|'is'
name|'not'
name|'text'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'clone'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
string|'"xxxx"'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testEntities
dedent|''
name|'def'
name|'testEntities'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'nodes'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
string|'"<b>&amp;&#12AB;</b>"'
op|')'
op|'.'
name|'documentElement'
op|'.'
name|'childNodes'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'nodes'
op|')'
op|','
number|'2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'nodes'
op|'['
number|'0'
op|']'
op|'.'
name|'data'
op|','
string|'"&amp;"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'nodes'
op|'['
number|'1'
op|']'
op|'.'
name|'data'
op|','
string|'"&#12AB;"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'nodes'
op|'['
number|'0'
op|']'
op|'.'
name|'cloneNode'
op|'('
op|')'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
string|'"&amp;"'
op|')'
newline|'\n'
name|'for'
name|'n'
name|'in'
name|'nodes'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assert_'
op|'('
name|'isinstance'
op|'('
name|'n'
op|','
name|'microdom'
op|'.'
name|'EntityReference'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testCData
dedent|''
dedent|''
name|'def'
name|'testCData'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|"'<x><![CDATA[</x>\\r\\n & foo]]></x>'"
newline|'\n'
name|'cdata'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|')'
op|'.'
name|'documentElement'
op|'.'
name|'childNodes'
op|'['
number|'0'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'isinstance'
op|'('
name|'cdata'
op|','
name|'microdom'
op|'.'
name|'CDATASection'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'cdata'
op|'.'
name|'data'
op|','
string|'"</x>\\r\\n & foo"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'cdata'
op|'.'
name|'cloneNode'
op|'('
op|')'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
string|'"<![CDATA[</x>\\r\\n & foo]]>"'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testSingletons
dedent|''
name|'def'
name|'testSingletons'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|'"<foo><b/><b /><b\\n/></foo>"'
newline|'\n'
name|'s2'
op|'='
string|'"<foo><b/><b/><b/></foo>"'
newline|'\n'
name|'nodes'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|')'
op|'.'
name|'documentElement'
op|'.'
name|'childNodes'
newline|'\n'
name|'nodes2'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s2'
op|')'
op|'.'
name|'documentElement'
op|'.'
name|'childNodes'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'nodes'
op|')'
op|','
number|'3'
op|')'
newline|'\n'
name|'for'
op|'('
name|'n'
op|','
name|'n2'
op|')'
name|'in'
name|'zip'
op|'('
name|'nodes'
op|','
name|'nodes2'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assert_'
op|'('
name|'isinstance'
op|'('
name|'n'
op|','
name|'microdom'
op|'.'
name|'Element'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'n'
op|'.'
name|'nodeName'
op|','
string|'"b"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'n'
op|'.'
name|'isEqualToNode'
op|'('
name|'n2'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testAttributes
dedent|''
dedent|''
name|'def'
name|'testAttributes'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|'\'<foo a="b" />\''
newline|'\n'
name|'node'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|')'
op|'.'
name|'documentElement'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'node'
op|'.'
name|'getAttribute'
op|'('
string|'"a"'
op|')'
op|','
string|'"b"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'node'
op|'.'
name|'getAttribute'
op|'('
string|'"c"'
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'node'
op|'.'
name|'hasAttribute'
op|'('
string|'"a"'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'not'
name|'node'
op|'.'
name|'hasAttribute'
op|'('
string|'"c"'
op|')'
op|')'
newline|'\n'
name|'a'
op|'='
name|'node'
op|'.'
name|'getAttributeNode'
op|'('
string|'"a"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'a'
op|'.'
name|'value'
op|','
string|'"b"'
op|')'
newline|'\n'
nl|'\n'
name|'node'
op|'.'
name|'setAttribute'
op|'('
string|'"foo"'
op|','
string|'"bar"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'node'
op|'.'
name|'getAttribute'
op|'('
string|'"foo"'
op|')'
op|','
string|'"bar"'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testChildren
dedent|''
name|'def'
name|'testChildren'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|'"<foo><bar /><baz /><bax>foo</bax></foo>"'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|')'
op|'.'
name|'documentElement'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
op|'['
name|'n'
op|'.'
name|'nodeName'
name|'for'
name|'n'
name|'in'
name|'d'
op|'.'
name|'childNodes'
op|']'
op|','
op|'['
string|'"bar"'
op|','
string|'"baz"'
op|','
string|'"bax"'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'lastChild'
op|'('
op|')'
op|'.'
name|'nodeName'
op|','
string|'"bax"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'firstChild'
op|'('
op|')'
op|'.'
name|'nodeName'
op|','
string|'"bar"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'d'
op|'.'
name|'hasChildNodes'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'not'
name|'d'
op|'.'
name|'firstChild'
op|'('
op|')'
op|'.'
name|'hasChildNodes'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testMutate
dedent|''
name|'def'
name|'testMutate'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|'"<foo />"'
newline|'\n'
name|'s1'
op|'='
string|'\'<foo a="b"><bar/><foo/></foo>\''
newline|'\n'
name|'s2'
op|'='
string|'\'<foo a="b">foo</foo>\''
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|')'
op|'.'
name|'documentElement'
newline|'\n'
name|'d1'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s1'
op|')'
op|'.'
name|'documentElement'
newline|'\n'
name|'d2'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s2'
op|')'
op|'.'
name|'documentElement'
newline|'\n'
nl|'\n'
name|'d'
op|'.'
name|'appendChild'
op|'('
name|'d'
op|'.'
name|'cloneNode'
op|'('
op|')'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'setAttribute'
op|'('
string|'"a"'
op|','
string|'"b"'
op|')'
newline|'\n'
name|'child'
op|'='
name|'d'
op|'.'
name|'childNodes'
op|'['
number|'0'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'child'
op|'.'
name|'getAttribute'
op|'('
string|'"a"'
op|')'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'child'
op|'.'
name|'nodeName'
op|','
string|'"foo"'
op|')'
newline|'\n'
nl|'\n'
name|'d'
op|'.'
name|'insertBefore'
op|'('
name|'microdom'
op|'.'
name|'Element'
op|'('
string|'"bar"'
op|')'
op|','
name|'child'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'childNodes'
op|'['
number|'0'
op|']'
op|'.'
name|'nodeName'
op|','
string|'"bar"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'childNodes'
op|'['
number|'1'
op|']'
op|','
name|'child'
op|')'
newline|'\n'
name|'for'
name|'n'
name|'in'
name|'d'
op|'.'
name|'childNodes'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'n'
op|'.'
name|'parentNode'
op|','
name|'d'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assert_'
op|'('
name|'d'
op|'.'
name|'isEqualToNode'
op|'('
name|'d1'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'d'
op|'.'
name|'removeChild'
op|'('
name|'child'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'d'
op|'.'
name|'childNodes'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'childNodes'
op|'['
number|'0'
op|']'
op|'.'
name|'nodeName'
op|','
string|'"bar"'
op|')'
newline|'\n'
nl|'\n'
name|'t'
op|'='
name|'microdom'
op|'.'
name|'Text'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'replaceChild'
op|'('
name|'t'
op|','
name|'d'
op|'.'
name|'firstChild'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'firstChild'
op|'('
op|')'
op|','
name|'t'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'d'
op|'.'
name|'isEqualToNode'
op|'('
name|'d2'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|test_replaceNonChild
dedent|''
name|'def'
name|'test_replaceNonChild'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Node.replaceChild} raises L{ValueError} if the node given to be\n        replaced is not a child of the node C{replaceChild} is called on.\n        """'
newline|'\n'
name|'parent'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
string|"'<foo />'"
op|')'
newline|'\n'
name|'orphan'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
string|"'<bar />'"
op|')'
newline|'\n'
name|'replacement'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
string|"'<baz />'"
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
nl|'\n'
name|'ValueError'
op|','
name|'parent'
op|'.'
name|'replaceChild'
op|','
name|'replacement'
op|','
name|'orphan'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|testSearch
dedent|''
name|'def'
name|'testSearch'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|'"<foo><bar id=\'me\' /><baz><foo /></baz></foo>"'
newline|'\n'
name|'s2'
op|'='
string|'"<fOo><bAr id=\'me\' /><bAz><fOO /></bAz></fOo>"'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|')'
newline|'\n'
name|'d2'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s2'
op|','
name|'caseInsensitive'
op|'='
number|'0'
op|','
name|'preserveCase'
op|'='
number|'1'
op|')'
newline|'\n'
name|'d3'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s2'
op|','
name|'caseInsensitive'
op|'='
number|'1'
op|','
name|'preserveCase'
op|'='
number|'1'
op|')'
newline|'\n'
nl|'\n'
name|'root'
op|'='
name|'d'
op|'.'
name|'documentElement'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'root'
op|'.'
name|'firstChild'
op|'('
op|')'
op|','
name|'d'
op|'.'
name|'getElementById'
op|'('
string|"'me'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'getElementsByTagName'
op|'('
string|'"foo"'
op|')'
op|','
nl|'\n'
op|'['
name|'root'
op|','
name|'root'
op|'.'
name|'lastChild'
op|'('
op|')'
op|'.'
name|'firstChild'
op|'('
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'root'
op|'='
name|'d2'
op|'.'
name|'documentElement'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'root'
op|'.'
name|'firstChild'
op|'('
op|')'
op|','
name|'d2'
op|'.'
name|'getElementById'
op|'('
string|"'me'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d2'
op|'.'
name|'getElementsByTagName'
op|'('
string|"'fOo'"
op|')'
op|','
op|'['
name|'root'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d2'
op|'.'
name|'getElementsByTagName'
op|'('
string|"'fOO'"
op|')'
op|','
nl|'\n'
op|'['
name|'root'
op|'.'
name|'lastChild'
op|'('
op|')'
op|'.'
name|'firstChild'
op|'('
op|')'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d2'
op|'.'
name|'getElementsByTagName'
op|'('
string|"'foo'"
op|')'
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'root'
op|'='
name|'d3'
op|'.'
name|'documentElement'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'root'
op|'.'
name|'firstChild'
op|'('
op|')'
op|','
name|'d3'
op|'.'
name|'getElementById'
op|'('
string|"'me'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d3'
op|'.'
name|'getElementsByTagName'
op|'('
string|"'FOO'"
op|')'
op|','
nl|'\n'
op|'['
name|'root'
op|','
name|'root'
op|'.'
name|'lastChild'
op|'('
op|')'
op|'.'
name|'firstChild'
op|'('
op|')'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d3'
op|'.'
name|'getElementsByTagName'
op|'('
string|"'fOo'"
op|')'
op|','
nl|'\n'
op|'['
name|'root'
op|','
name|'root'
op|'.'
name|'lastChild'
op|'('
op|')'
op|'.'
name|'firstChild'
op|'('
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testDoctype
dedent|''
name|'def'
name|'testDoctype'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
op|'('
string|'\'<?xml version="1.0"?>\''
nl|'\n'
string|'\'<!DOCTYPE foo PUBLIC "baz" "http://www.example.com/example.dtd">\''
nl|'\n'
string|"'<foo></foo>'"
op|')'
newline|'\n'
name|'s2'
op|'='
string|"'<foo/>'"
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|')'
newline|'\n'
name|'d2'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'doctype'
op|','
nl|'\n'
string|'\'foo PUBLIC "baz" "http://www.example.com/example.dtd"\''
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
name|'s'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'d'
op|'.'
name|'isEqualToDocument'
op|'('
name|'d2'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'d'
op|'.'
name|'documentElement'
op|'.'
name|'isEqualToNode'
op|'('
name|'d2'
op|'.'
name|'documentElement'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|samples
dedent|''
name|'samples'
op|'='
op|'['
op|'('
string|'"<img/>"'
op|','
string|'"<img />"'
op|')'
op|','
nl|'\n'
op|'('
string|'"<foo A=\'b\'>x</foo>"'
op|','
string|'\'<foo A="b">x</foo>\''
op|')'
op|','
nl|'\n'
op|'('
string|'"<foo><BAR /></foo>"'
op|','
string|'"<foo><BAR></BAR></foo>"'
op|')'
op|','
nl|'\n'
op|'('
string|'"<foo>hello there &amp; yoyoy</foo>"'
op|','
nl|'\n'
string|'"<foo>hello there &amp; yoyoy</foo>"'
op|')'
op|','
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
DECL|function|testOutput
name|'def'
name|'testOutput'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'s'
op|','
name|'out'
name|'in'
name|'self'
op|'.'
name|'samples'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'caseInsensitive'
op|'='
number|'0'
op|')'
newline|'\n'
name|'d2'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'out'
op|','
name|'caseInsensitive'
op|'='
number|'0'
op|')'
newline|'\n'
name|'testOut'
op|'='
name|'d'
op|'.'
name|'documentElement'
op|'.'
name|'toxml'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'out'
op|','
name|'testOut'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'d'
op|'.'
name|'isEqualToDocument'
op|'('
name|'d2'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testErrors
dedent|''
dedent|''
name|'def'
name|'testErrors'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'s'
name|'in'
op|'['
string|'"<foo>&am</foo>"'
op|','
string|'"<foo"'
op|','
string|'"<f>&</f>"'
op|','
string|'"<() />"'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'Exception'
op|','
name|'microdom'
op|'.'
name|'parseString'
op|','
name|'s'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testCaseInsensitive
dedent|''
dedent|''
name|'def'
name|'testCaseInsensitive'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|'"<foo a=\'b\'><BAx>x</bax></FOO>"'
newline|'\n'
name|'s2'
op|'='
string|'\'<foo a="b"><bax>x</bax></foo>\''
newline|'\n'
name|'s3'
op|'='
string|'"<FOO a=\'b\'><BAx>x</BAx></FOO>"'
newline|'\n'
name|'s4'
op|'='
string|'"<foo A=\'b\'>x</foo>"'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|')'
newline|'\n'
name|'d2'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s2'
op|')'
newline|'\n'
name|'d3'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s3'
op|','
name|'caseInsensitive'
op|'='
number|'1'
op|')'
newline|'\n'
name|'d4'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s4'
op|','
name|'caseInsensitive'
op|'='
number|'1'
op|','
name|'preserveCase'
op|'='
number|'1'
op|')'
newline|'\n'
name|'d5'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s4'
op|','
name|'caseInsensitive'
op|'='
number|'1'
op|','
name|'preserveCase'
op|'='
number|'0'
op|')'
newline|'\n'
name|'d6'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s4'
op|','
name|'caseInsensitive'
op|'='
number|'0'
op|','
name|'preserveCase'
op|'='
number|'0'
op|')'
newline|'\n'
name|'out'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|')'
op|'.'
name|'documentElement'
op|'.'
name|'toxml'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'microdom'
op|'.'
name|'MismatchedTags'
op|','
name|'microdom'
op|'.'
name|'parseString'
op|','
nl|'\n'
name|'s'
op|','
name|'caseInsensitive'
op|'='
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'out'
op|','
name|'s2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'d'
op|'.'
name|'isEqualToDocument'
op|'('
name|'d2'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'d'
op|'.'
name|'isEqualToDocument'
op|'('
name|'d3'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'d4'
op|'.'
name|'documentElement'
op|'.'
name|'hasAttribute'
op|'('
string|"'a'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'d6'
op|'.'
name|'documentElement'
op|'.'
name|'hasAttribute'
op|'('
string|"'a'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d4'
op|'.'
name|'documentElement'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
string|'\'<foo A="b">x</foo>\''
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d5'
op|'.'
name|'documentElement'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
string|'\'<foo a="b">x</foo>\''
op|')'
newline|'\n'
DECL|function|testEatingWhitespace
dedent|''
name|'def'
name|'testEatingWhitespace'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|'"""<hello>\n        </hello>"""'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'not'
name|'d'
op|'.'
name|'documentElement'
op|'.'
name|'hasChildNodes'
op|'('
op|')'
op|','
nl|'\n'
name|'d'
op|'.'
name|'documentElement'
op|'.'
name|'childNodes'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'d'
op|'.'
name|'isEqualToDocument'
op|'('
name|'microdom'
op|'.'
name|'parseString'
op|'('
string|"'<hello></hello>'"
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testLenientAmpersand
dedent|''
name|'def'
name|'testLenientAmpersand'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'prefix'
op|'='
string|'"<?xml version=\'1.0\'?>"'
newline|'\n'
comment|'# we use <pre> so space will be preserved'
nl|'\n'
name|'for'
name|'i'
op|','
name|'o'
name|'in'
op|'['
op|'('
string|'"&"'
op|','
string|'"&amp;"'
op|')'
op|','
nl|'\n'
op|'('
string|'"& "'
op|','
string|'"&amp; "'
op|')'
op|','
nl|'\n'
op|'('
string|'"&amp;"'
op|','
string|'"&amp;"'
op|')'
op|','
nl|'\n'
op|'('
string|'"&hello monkey"'
op|','
string|'"&amp;hello monkey"'
op|')'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
string|'"%s<pre>%s</pre>"'
nl|'\n'
op|'%'
op|'('
name|'prefix'
op|','
name|'i'
op|')'
op|','
name|'beExtremelyLenient'
op|'='
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'documentElement'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
string|'"<pre>%s</pre>"'
op|'%'
name|'o'
op|')'
newline|'\n'
comment|'# non-space preserving'
nl|'\n'
dedent|''
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
string|'"<t>hello & there</t>"'
op|','
name|'beExtremelyLenient'
op|'='
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'documentElement'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
string|'"<t>hello &amp; there</t>"'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testInsensitiveLenient
dedent|''
name|'def'
name|'testInsensitiveLenient'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# testing issue #537'
nl|'\n'
indent|'        '
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
nl|'\n'
string|'"<?xml version=\'1.0\'?><bar><xA><y>c</Xa> <foo></bar>"'
op|','
nl|'\n'
name|'beExtremelyLenient'
op|'='
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'documentElement'
op|'.'
name|'firstChild'
op|'('
op|')'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
string|'"<xa><y>c</y></xa>"'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testLaterCloserSimple
dedent|''
name|'def'
name|'testLaterCloserSimple'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|'"<ul><li>foo<li>bar<li>baz</ul>"'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'beExtremelyLenient'
op|'='
number|'1'
op|')'
newline|'\n'
name|'expected'
op|'='
string|'"<ul><li>foo</li><li>bar</li><li>baz</li></ul>"'
newline|'\n'
name|'actual'
op|'='
name|'d'
op|'.'
name|'documentElement'
op|'.'
name|'toxml'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'expected'
op|','
name|'actual'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testLaterCloserCaseInsensitive
dedent|''
name|'def'
name|'testLaterCloserCaseInsensitive'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|'"<DL><p><DT>foo<DD>bar</DL>"'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'beExtremelyLenient'
op|'='
number|'1'
op|')'
newline|'\n'
name|'expected'
op|'='
string|'"<dl><p></p><dt>foo</dt><dd>bar</dd></dl>"'
newline|'\n'
name|'actual'
op|'='
name|'d'
op|'.'
name|'documentElement'
op|'.'
name|'toxml'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'expected'
op|','
name|'actual'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testLaterCloserTable
dedent|''
name|'def'
name|'testLaterCloserTable'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
op|'('
string|'"<table>"'
nl|'\n'
string|'"<tr><th>name<th>value<th>comment"'
nl|'\n'
string|'"<tr><th>this<td>tag<td>soup"'
nl|'\n'
string|'"<tr><th>must<td>be<td>handled"'
nl|'\n'
string|'"</table>"'
op|')'
newline|'\n'
name|'expected'
op|'='
op|'('
string|'"<table>"'
nl|'\n'
string|'"<tr><th>name</th><th>value</th><th>comment</th></tr>"'
nl|'\n'
string|'"<tr><th>this</th><td>tag</td><td>soup</td></tr>"'
nl|'\n'
string|'"<tr><th>must</th><td>be</td><td>handled</td></tr>"'
nl|'\n'
string|'"</table>"'
op|')'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'beExtremelyLenient'
op|'='
number|'1'
op|')'
newline|'\n'
name|'actual'
op|'='
name|'d'
op|'.'
name|'documentElement'
op|'.'
name|'toxml'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'expected'
op|','
name|'actual'
op|')'
newline|'\n'
dedent|''
name|'testLaterCloserTable'
op|'.'
name|'todo'
op|'='
string|'"Table parsing needs to be fixed."'
newline|'\n'
nl|'\n'
DECL|function|testLaterCloserDL
name|'def'
name|'testLaterCloserDL'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
op|'('
string|'"<dl>"'
nl|'\n'
string|'"<dt>word<dd>definition"'
nl|'\n'
string|'"<dt>word<dt>word<dd>definition<dd>definition"'
nl|'\n'
string|'"</dl>"'
op|')'
newline|'\n'
name|'expected'
op|'='
op|'('
string|'"<dl>"'
nl|'\n'
string|'"<dt>word</dt><dd>definition</dd>"'
nl|'\n'
string|'"<dt>word</dt><dt>word</dt><dd>definition</dd><dd>definition</dd>"'
nl|'\n'
string|'"</dl>"'
op|')'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'beExtremelyLenient'
op|'='
number|'1'
op|')'
newline|'\n'
name|'actual'
op|'='
name|'d'
op|'.'
name|'documentElement'
op|'.'
name|'toxml'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'expected'
op|','
name|'actual'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testLaterCloserDL2
dedent|''
name|'def'
name|'testLaterCloserDL2'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
op|'('
string|'"<dl>"'
nl|'\n'
string|'"<dt>word<dd>definition<p>more definition"'
nl|'\n'
string|'"<dt>word"'
nl|'\n'
string|'"</dl>"'
op|')'
newline|'\n'
name|'expected'
op|'='
op|'('
string|'"<dl>"'
nl|'\n'
string|'"<dt>word</dt><dd>definition<p>more definition</p></dd>"'
nl|'\n'
string|'"<dt>word</dt>"'
nl|'\n'
string|'"</dl>"'
op|')'
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|','
name|'beExtremelyLenient'
op|'='
number|'1'
op|')'
newline|'\n'
name|'actual'
op|'='
name|'d'
op|'.'
name|'documentElement'
op|'.'
name|'toxml'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'expected'
op|','
name|'actual'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'testLaterCloserDL2'
op|'.'
name|'todo'
op|'='
string|'"unclosed <p> messes it up."'
newline|'\n'
nl|'\n'
DECL|function|testUnicodeTolerance
name|'def'
name|'testUnicodeTolerance'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'import'
name|'struct'
newline|'\n'
name|'s'
op|'='
string|"'<foo><bar><baz /></bar></foo>'"
newline|'\n'
name|'j'
op|'='
op|'('
string|'u\'<?xml version="1.0" encoding="UCS-2" ?>\\r\\n<JAPANESE>\\r\\n\''
nl|'\n'
string|"u'<TITLE>\\u5c02\\u9580\\u5bb6\\u30ea\\u30b9\\u30c8 </TITLE></JAPANESE>'"
op|')'
newline|'\n'
name|'j2'
op|'='
op|'('
string|"'\\xff\\xfe<\\x00?\\x00x\\x00m\\x00l\\x00 \\x00v\\x00e\\x00r\\x00s\\x00i\\x00o'"
nl|'\n'
string|'\'\\x00n\\x00=\\x00"\\x001\\x00.\\x000\\x00"\\x00 \\x00e\\x00n\\x00c\\x00o\\x00d\''
nl|'\n'
string|'\'\\x00i\\x00n\\x00g\\x00=\\x00"\\x00U\\x00C\\x00S\\x00-\\x002\\x00"\\x00 \\x00?\''
nl|'\n'
string|"'\\x00>\\x00\\r\\x00\\n\\x00<\\x00J\\x00A\\x00P\\x00A\\x00N\\x00E\\x00S\\x00E'"
nl|'\n'
string|"'\\x00>\\x00\\r\\x00\\n\\x00<\\x00T\\x00I\\x00T\\x00L\\x00E\\x00>\\x00\\x02\\\\'"
nl|'\n'
string|"'\\x80\\x95\\xb6[\\xea0\\xb90\\xc80 \\x00<\\x00/\\x00T\\x00I\\x00T\\x00L\\x00E'"
nl|'\n'
string|"'\\x00>\\x00<\\x00/\\x00J\\x00A\\x00P\\x00A\\x00N\\x00E\\x00S\\x00E\\x00>\\x00'"
op|')'
newline|'\n'
DECL|function|reverseBytes
name|'def'
name|'reverseBytes'
op|'('
name|'s'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'fmt'
op|'='
name|'str'
op|'('
name|'len'
op|'('
name|'s'
op|')'
op|'/'
number|'2'
op|')'
op|'+'
string|"'H'"
newline|'\n'
name|'return'
name|'struct'
op|'.'
name|'pack'
op|'('
string|"'<'"
op|'+'
name|'fmt'
op|','
op|'*'
name|'struct'
op|'.'
name|'unpack'
op|'('
string|"'>'"
op|'+'
name|'fmt'
op|','
name|'s'
op|')'
op|')'
newline|'\n'
dedent|''
name|'urd'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'reverseBytes'
op|'('
name|'s'
op|'.'
name|'encode'
op|'('
string|"'UTF-16'"
op|')'
op|')'
op|')'
newline|'\n'
name|'ud'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|'.'
name|'encode'
op|'('
string|"'UTF-16'"
op|')'
op|')'
newline|'\n'
name|'sd'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'ud'
op|'.'
name|'isEqualToDocument'
op|'('
name|'sd'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'ud'
op|'.'
name|'isEqualToDocument'
op|'('
name|'urd'
op|')'
op|')'
newline|'\n'
name|'ud'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'j'
op|')'
newline|'\n'
name|'urd'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'reverseBytes'
op|'('
name|'j2'
op|')'
op|')'
newline|'\n'
name|'sd'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'j2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'ud'
op|'.'
name|'isEqualToDocument'
op|'('
name|'sd'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'ud'
op|'.'
name|'isEqualToDocument'
op|'('
name|'urd'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# test that raw text still gets encoded'
nl|'\n'
comment|'# test that comments get encoded'
nl|'\n'
name|'j3'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
string|"u'<foo/>'"
op|')'
newline|'\n'
name|'hdr'
op|'='
string|'\'<?xml version="1.0"?>\''
newline|'\n'
name|'div'
op|'='
name|'microdom'
op|'.'
name|'lmx'
op|'('
op|')'
op|'.'
name|'text'
op|'('
string|"u'\\u221a'"
op|','
name|'raw'
op|'='
number|'1'
op|')'
op|'.'
name|'node'
newline|'\n'
name|'de'
op|'='
name|'j3'
op|'.'
name|'documentElement'
newline|'\n'
name|'de'
op|'.'
name|'appendChild'
op|'('
name|'div'
op|')'
newline|'\n'
name|'de'
op|'.'
name|'appendChild'
op|'('
name|'j3'
op|'.'
name|'createComment'
op|'('
string|"u'\\u221a'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'j3'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
name|'hdr'
op|'+'
nl|'\n'
string|"u'<foo><div>\\u221a</div><!--\\u221a--></foo>'"
op|'.'
name|'encode'
op|'('
string|"'utf8'"
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testNamedChildren
dedent|''
name|'def'
name|'testNamedChildren'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'tests'
op|'='
op|'{'
string|'"<foo><bar /><bar unf=\'1\' /><bar>asdfadsf</bar>"'
nl|'\n'
string|'"<bam/></foo>"'
op|':'
number|'3'
op|','
nl|'\n'
string|"'<foo>asdf</foo>'"
op|':'
number|'0'
op|','
nl|'\n'
string|"'<foo><bar><bar></bar></bar></foo>'"
op|':'
number|'1'
op|','
nl|'\n'
op|'}'
newline|'\n'
name|'for'
name|'t'
name|'in'
name|'tests'
op|'.'
name|'keys'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'node'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'t'
op|')'
op|'.'
name|'documentElement'
newline|'\n'
name|'result'
op|'='
name|'domhelpers'
op|'.'
name|'namedChildren'
op|'('
name|'node'
op|','
string|"'bar'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'result'
op|')'
op|','
name|'tests'
op|'['
name|'t'
op|']'
op|')'
newline|'\n'
name|'if'
name|'result'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'assert_'
op|'('
name|'hasattr'
op|'('
name|'result'
op|'['
number|'0'
op|']'
op|','
string|"'tagName'"
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testCloneNode
dedent|''
dedent|''
dedent|''
name|'def'
name|'testCloneNode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|'\'<foo a="b"><bax>x</bax></foo>\''
newline|'\n'
name|'node'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|')'
op|'.'
name|'documentElement'
newline|'\n'
name|'clone'
op|'='
name|'node'
op|'.'
name|'cloneNode'
op|'('
name|'deep'
op|'='
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIfEquals'
op|'('
name|'node'
op|','
name|'clone'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'node'
op|'.'
name|'childNodes'
op|')'
op|','
name|'len'
op|'('
name|'clone'
op|'.'
name|'childNodes'
op|')'
op|')'
newline|'\n'
name|'c1'
op|','
name|'c2'
op|'='
name|'node'
op|'.'
name|'firstChild'
op|'('
op|')'
op|','
name|'clone'
op|'.'
name|'firstChild'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIfEquals'
op|'('
name|'c1'
op|','
name|'c2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'c1'
op|'.'
name|'childNodes'
op|')'
op|','
name|'len'
op|'('
name|'c2'
op|'.'
name|'childNodes'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIfEquals'
op|'('
name|'c1'
op|'.'
name|'firstChild'
op|'('
op|')'
op|','
name|'c2'
op|'.'
name|'firstChild'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'s'
op|','
name|'clone'
op|'.'
name|'toxml'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'node'
op|'.'
name|'namespace'
op|','
name|'clone'
op|'.'
name|'namespace'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testCloneDocument
dedent|''
name|'def'
name|'testCloneDocument'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
op|'('
string|'\'<?xml version="1.0"?>\''
nl|'\n'
string|'\'<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"\''
nl|'\n'
string|'\'"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><foo></foo>\''
op|')'
newline|'\n'
nl|'\n'
name|'node'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|')'
newline|'\n'
name|'clone'
op|'='
name|'node'
op|'.'
name|'cloneNode'
op|'('
name|'deep'
op|'='
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIfEquals'
op|'('
name|'node'
op|','
name|'clone'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'node'
op|'.'
name|'childNodes'
op|')'
op|','
name|'len'
op|'('
name|'clone'
op|'.'
name|'childNodes'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'s'
op|','
name|'clone'
op|'.'
name|'toxml'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'clone'
op|'.'
name|'isEqualToDocument'
op|'('
name|'node'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'node'
op|'.'
name|'isEqualToDocument'
op|'('
name|'clone'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|testLMX
dedent|''
name|'def'
name|'testLMX'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'n'
op|'='
name|'microdom'
op|'.'
name|'Element'
op|'('
string|'"p"'
op|')'
newline|'\n'
name|'lmx'
op|'='
name|'microdom'
op|'.'
name|'lmx'
op|'('
name|'n'
op|')'
newline|'\n'
name|'lmx'
op|'.'
name|'text'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'b'
op|'='
name|'lmx'
op|'.'
name|'b'
op|'('
name|'a'
op|'='
string|'"c"'
op|')'
newline|'\n'
name|'b'
op|'.'
name|'foo'
op|'('
op|')'
op|'['
string|'"z"'
op|']'
op|'='
string|'"foo"'
newline|'\n'
name|'b'
op|'.'
name|'foo'
op|'('
op|')'
newline|'\n'
name|'b'
op|'.'
name|'add'
op|'('
string|'"bar"'
op|','
name|'c'
op|'='
string|'"y"'
op|')'
newline|'\n'
nl|'\n'
name|'s'
op|'='
string|'\'<p>foo<b a="c"><foo z="foo"></foo><foo></foo><bar c="y"></bar></b></p>\''
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'s'
op|','
name|'n'
op|'.'
name|'toxml'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testDict
dedent|''
name|'def'
name|'testDict'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'n'
op|'='
name|'microdom'
op|'.'
name|'Element'
op|'('
string|'"p"'
op|')'
newline|'\n'
name|'d'
op|'='
op|'{'
name|'n'
op|':'
number|'1'
op|'}'
comment|'# will fail if Element is unhashable'
newline|'\n'
nl|'\n'
DECL|function|testEscaping
dedent|''
name|'def'
name|'testEscaping'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# issue 590'
nl|'\n'
indent|'        '
name|'raw'
op|'='
string|'"&\'some \\"stuff\\"\', <what up?>"'
newline|'\n'
name|'cooked'
op|'='
string|'"&amp;\'some &quot;stuff&quot;\', &lt;what up?&gt;"'
newline|'\n'
name|'esc1'
op|'='
name|'microdom'
op|'.'
name|'escape'
op|'('
name|'raw'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'esc1'
op|','
name|'cooked'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'microdom'
op|'.'
name|'unescape'
op|'('
name|'esc1'
op|')'
op|','
name|'raw'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testNamespaces
dedent|''
name|'def'
name|'testNamespaces'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|'\'\'\'\n        <x xmlns="base">\n        <y />\n        <y q="1" x:q="2" y:q="3" />\n        <y:y xml:space="1">here is    some space </y:y>\n        <y:y />\n        <x:y />\n        </x>\n        \'\'\''
newline|'\n'
name|'d'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s'
op|')'
newline|'\n'
comment|"# at least make sure it doesn't traceback"
nl|'\n'
name|'s2'
op|'='
name|'d'
op|'.'
name|'toprettyxml'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'documentElement'
op|'.'
name|'namespace'
op|','
nl|'\n'
string|'"base"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'documentElement'
op|'.'
name|'getElementsByTagName'
op|'('
string|'"y"'
op|')'
op|'['
number|'0'
op|']'
op|'.'
name|'namespace'
op|','
nl|'\n'
string|'"base"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'d'
op|'.'
name|'documentElement'
op|'.'
name|'getElementsByTagName'
op|'('
string|'"y"'
op|')'
op|'['
number|'1'
op|']'
op|'.'
name|'getAttributeNS'
op|'('
string|"'base'"
op|','
string|"'q'"
op|')'
op|','
nl|'\n'
string|"'1'"
op|')'
newline|'\n'
nl|'\n'
name|'d2'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d2'
op|'.'
name|'documentElement'
op|'.'
name|'namespace'
op|','
nl|'\n'
string|'"base"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d2'
op|'.'
name|'documentElement'
op|'.'
name|'getElementsByTagName'
op|'('
string|'"y"'
op|')'
op|'['
number|'0'
op|']'
op|'.'
name|'namespace'
op|','
nl|'\n'
string|'"base"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'d2'
op|'.'
name|'documentElement'
op|'.'
name|'getElementsByTagName'
op|'('
string|'"y"'
op|')'
op|'['
number|'1'
op|']'
op|'.'
name|'getAttributeNS'
op|'('
string|"'base'"
op|','
string|"'q'"
op|')'
op|','
nl|'\n'
string|"'1'"
op|')'
newline|'\n'
nl|'\n'
DECL|function|testNamespaceDelete
dedent|''
name|'def'
name|'testNamespaceDelete'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that C{toxml} can support xml structures that remove namespaces.\n        """'
newline|'\n'
name|'s1'
op|'='
op|'('
string|'\'<?xml version="1.0"?><html xmlns="http://www.w3.org/TR/REC-html40">\''
nl|'\n'
string|'\'<body xmlns=""></body></html>\''
op|')'
newline|'\n'
name|'s2'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'s1'
op|')'
op|'.'
name|'toxml'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'s1'
op|','
name|'s2'
op|')'
newline|'\n'
nl|'\n'
DECL|function|testNamespaceInheritance
dedent|''
name|'def'
name|'testNamespaceInheritance'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that unspecified namespace is a thing separate from undefined\n        namespace. This test added after discovering some weirdness in Lore.\n        """'
newline|'\n'
comment|'# will only work if childNodes is mutated. not sure why.'
nl|'\n'
name|'child'
op|'='
name|'microdom'
op|'.'
name|'Element'
op|'('
string|"'ol'"
op|')'
newline|'\n'
name|'parent'
op|'='
name|'microdom'
op|'.'
name|'Element'
op|'('
string|"'div'"
op|','
name|'namespace'
op|'='
string|"'http://www.w3.org/1999/xhtml'"
op|')'
newline|'\n'
name|'parent'
op|'.'
name|'childNodes'
op|'='
op|'['
name|'child'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'parent'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
nl|'\n'
string|'\'<div xmlns="http://www.w3.org/1999/xhtml"><ol></ol></div>\''
op|')'
newline|'\n'
nl|'\n'
DECL|function|test_prefixedTags
dedent|''
name|'def'
name|'test_prefixedTags'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        XML elements with a prefixed name as per upper level tag definition\n        have a start-tag of C{"<prefix:tag>"} and an end-tag of\n        C{"</prefix:tag>"}.\n\n        Refer to U{http://www.w3.org/TR/xml-names/#ns-using} for details.\n        """'
newline|'\n'
name|'outerNamespace'
op|'='
string|'"http://example.com/outer"'
newline|'\n'
name|'innerNamespace'
op|'='
string|'"http://example.com/inner"'
newline|'\n'
nl|'\n'
name|'document'
op|'='
name|'microdom'
op|'.'
name|'Document'
op|'('
op|')'
newline|'\n'
comment|'# Create the root in one namespace.  Microdom will probably make this'
nl|'\n'
comment|'# the default namespace.'
nl|'\n'
name|'root'
op|'='
name|'document'
op|'.'
name|'createElement'
op|'('
string|'"root"'
op|','
name|'namespace'
op|'='
name|'outerNamespace'
op|')'
newline|'\n'
nl|'\n'
comment|'# Give the root some prefixes to use.'
nl|'\n'
name|'root'
op|'.'
name|'addPrefixes'
op|'('
op|'{'
name|'innerNamespace'
op|':'
string|'"inner"'
op|'}'
op|')'
newline|'\n'
nl|'\n'
comment|'# Append a child to the root from the namespace that prefix is bound'
nl|'\n'
comment|'# to.'
nl|'\n'
name|'tag'
op|'='
name|'document'
op|'.'
name|'createElement'
op|'('
string|'"tag"'
op|','
name|'namespace'
op|'='
name|'innerNamespace'
op|')'
newline|'\n'
nl|'\n'
comment|'# Give that tag a child too.  This way we test rendering of tags with'
nl|'\n'
comment|'# children and without children.'
nl|'\n'
name|'child'
op|'='
name|'document'
op|'.'
name|'createElement'
op|'('
string|'"child"'
op|','
name|'namespace'
op|'='
name|'innerNamespace'
op|')'
newline|'\n'
nl|'\n'
name|'tag'
op|'.'
name|'appendChild'
op|'('
name|'child'
op|')'
newline|'\n'
name|'root'
op|'.'
name|'appendChild'
op|'('
name|'tag'
op|')'
newline|'\n'
name|'document'
op|'.'
name|'appendChild'
op|'('
name|'root'
op|')'
newline|'\n'
nl|'\n'
comment|'# ok, the xml should appear like this'
nl|'\n'
name|'xmlOk'
op|'='
op|'('
nl|'\n'
string|'\'<?xml version="1.0"?>\''
nl|'\n'
string|'\'<root xmlns="http://example.com/outer" \''
nl|'\n'
string|'\'xmlns:inner="http://example.com/inner">\''
nl|'\n'
string|"'<inner:tag><inner:child></inner:child></inner:tag>'"
nl|'\n'
string|"'</root>'"
op|')'
newline|'\n'
nl|'\n'
name|'xmlOut'
op|'='
name|'document'
op|'.'
name|'toxml'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'xmlOut'
op|','
name|'xmlOk'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|test_prefixPropagation
dedent|''
name|'def'
name|'test_prefixPropagation'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Children of prefixed tags respect the default namespace at the point\n        where they are rendered.  Specifically, they are not influenced by the\n        prefix of their parent as that prefix has no bearing on them.\n\n        See U{http://www.w3.org/TR/xml-names/#scoping} for details.\n\n        To further clarify the matter, the following::\n\n            <root xmlns="http://example.com/ns/test">\n                <mytag xmlns="http://example.com/ns/mytags">\n                    <mysubtag xmlns="http://example.com/ns/mytags">\n                        <element xmlns="http://example.com/ns/test"></element>\n                    </mysubtag>\n                </mytag>\n            </root>\n\n        Should become this after all the namespace declarations have been\n        I{moved up}::\n\n            <root xmlns="http://example.com/ns/test"\n                  xmlns:mytags="http://example.com/ns/mytags">\n                <mytags:mytag>\n                    <mytags:mysubtag>\n                        <element></element>\n                    </mytags:mysubtag>\n                </mytags:mytag>\n            </root>\n        """'
newline|'\n'
name|'outerNamespace'
op|'='
string|'"http://example.com/outer"'
newline|'\n'
name|'innerNamespace'
op|'='
string|'"http://example.com/inner"'
newline|'\n'
nl|'\n'
name|'document'
op|'='
name|'microdom'
op|'.'
name|'Document'
op|'('
op|')'
newline|'\n'
comment|'# creates a root element'
nl|'\n'
name|'root'
op|'='
name|'document'
op|'.'
name|'createElement'
op|'('
string|'"root"'
op|','
name|'namespace'
op|'='
name|'outerNamespace'
op|')'
newline|'\n'
name|'document'
op|'.'
name|'appendChild'
op|'('
name|'root'
op|')'
newline|'\n'
nl|'\n'
comment|'# Create a child with a specific namespace with a prefix bound to it.'
nl|'\n'
name|'root'
op|'.'
name|'addPrefixes'
op|'('
op|'{'
name|'innerNamespace'
op|':'
string|'"inner"'
op|'}'
op|')'
newline|'\n'
name|'mytag'
op|'='
name|'document'
op|'.'
name|'createElement'
op|'('
string|'"mytag"'
op|','
name|'namespace'
op|'='
name|'innerNamespace'
op|')'
newline|'\n'
name|'root'
op|'.'
name|'appendChild'
op|'('
name|'mytag'
op|')'
newline|'\n'
nl|'\n'
comment|'# Create a child of that which has the outer namespace.'
nl|'\n'
name|'mysubtag'
op|'='
name|'document'
op|'.'
name|'createElement'
op|'('
string|'"mysubtag"'
op|','
name|'namespace'
op|'='
name|'outerNamespace'
op|')'
newline|'\n'
name|'mytag'
op|'.'
name|'appendChild'
op|'('
name|'mysubtag'
op|')'
newline|'\n'
nl|'\n'
name|'xmlOk'
op|'='
op|'('
nl|'\n'
string|'\'<?xml version="1.0"?>\''
nl|'\n'
string|'\'<root xmlns="http://example.com/outer" \''
nl|'\n'
string|'\'xmlns:inner="http://example.com/inner">\''
nl|'\n'
string|"'<inner:mytag>'"
nl|'\n'
string|"'<mysubtag></mysubtag>'"
nl|'\n'
string|"'</inner:mytag>'"
nl|'\n'
string|"'</root>'"
nl|'\n'
op|')'
newline|'\n'
name|'xmlOut'
op|'='
name|'document'
op|'.'
name|'toxml'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'xmlOut'
op|','
name|'xmlOk'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestBrokenHTML
dedent|''
dedent|''
name|'class'
name|'TestBrokenHTML'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for when microdom encounters very bad HTML and C{beExtremelyLenient}\n    is enabled. These tests are inspired by some HTML generated in by a mailer,\n    which breaks up very long lines by splitting them with \'!\\n \'. The expected\n    behaviour is loosely modelled on the way Firefox treats very bad HTML.\n    """'
newline|'\n'
nl|'\n'
DECL|member|checkParsed
name|'def'
name|'checkParsed'
op|'('
name|'self'
op|','
name|'input'
op|','
name|'expected'
op|','
name|'beExtremelyLenient'
op|'='
number|'1'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that C{input}, when parsed, produces a DOM where the XML\n        of the document element is equal to C{expected}.\n        """'
newline|'\n'
name|'output'
op|'='
name|'microdom'
op|'.'
name|'parseString'
op|'('
name|'input'
op|','
nl|'\n'
name|'beExtremelyLenient'
op|'='
name|'beExtremelyLenient'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'output'
op|'.'
name|'documentElement'
op|'.'
name|'toxml'
op|'('
op|')'
op|','
name|'expected'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_brokenAttributeName
dedent|''
name|'def'
name|'test_brokenAttributeName'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that microdom does its best to handle broken attribute names.\n        The important thing is that it doesn\'t raise an exception.\n        """'
newline|'\n'
name|'input'
op|'='
string|'\'<body><h1><div al!\\n ign="center">Foo</div></h1></body>\''
newline|'\n'
name|'expected'
op|'='
op|'('
string|'\'<body><h1><div ign="center" al="True">\''
nl|'\n'
string|"'Foo</div></h1></body>'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'checkParsed'
op|'('
name|'input'
op|','
name|'expected'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_brokenAttributeValue
dedent|''
name|'def'
name|'test_brokenAttributeValue'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that microdom encompasses broken attribute values.\n        """'
newline|'\n'
name|'input'
op|'='
string|'\'<body><h1><div align="cen!\\n ter">Foo</div></h1></body>\''
newline|'\n'
name|'expected'
op|'='
string|'\'<body><h1><div align="cen!\\n ter">Foo</div></h1></body>\''
newline|'\n'
name|'self'
op|'.'
name|'checkParsed'
op|'('
name|'input'
op|','
name|'expected'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_brokenOpeningTag
dedent|''
name|'def'
name|'test_brokenOpeningTag'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that microdom does its best to handle broken opening tags.\n        The important thing is that it doesn\'t raise an exception.\n        """'
newline|'\n'
name|'input'
op|'='
string|"'<body><h1><sp!\\n an>Hello World!</span></h1></body>'"
newline|'\n'
name|'expected'
op|'='
string|'\'<body><h1><sp an="True">Hello World!</sp></h1></body>\''
newline|'\n'
name|'self'
op|'.'
name|'checkParsed'
op|'('
name|'input'
op|','
name|'expected'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_brokenSelfClosingTag
dedent|''
name|'def'
name|'test_brokenSelfClosingTag'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that microdom does its best to handle broken self-closing tags\n        The important thing is that it doesn\'t raise an exception.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'checkParsed'
op|'('
string|"'<body><span /!\\n></body>'"
op|','
nl|'\n'
string|"'<body><span></span></body>'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'checkParsed'
op|'('
string|"'<span!\\n />'"
op|','
string|"'<span></span>'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_brokenClosingTag
dedent|''
name|'def'
name|'test_brokenClosingTag'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that microdom does its best to handle broken closing tags.\n        The important thing is that it doesn\'t raise an exception.\n        """'
newline|'\n'
name|'input'
op|'='
string|"'<body><h1><span>Hello World!</sp!\\nan></h1></body>'"
newline|'\n'
name|'expected'
op|'='
string|"'<body><h1><span>Hello World!</span></h1></body>'"
newline|'\n'
name|'self'
op|'.'
name|'checkParsed'
op|'('
name|'input'
op|','
name|'expected'
op|')'
newline|'\n'
name|'input'
op|'='
string|"'<body><h1><span>Hello World!</!\\nspan></h1></body>'"
newline|'\n'
name|'self'
op|'.'
name|'checkParsed'
op|'('
name|'input'
op|','
name|'expected'
op|')'
newline|'\n'
name|'input'
op|'='
string|"'<body><h1><span>Hello World!</span!\\n></h1></body>'"
newline|'\n'
name|'self'
op|'.'
name|'checkParsed'
op|'('
name|'input'
op|','
name|'expected'
op|')'
newline|'\n'
name|'input'
op|'='
string|"'<body><h1><span>Hello World!<!\\n/span></h1></body>'"
newline|'\n'
name|'expected'
op|'='
string|"'<body><h1><span>Hello World!<!></!></span></h1></body>'"
newline|'\n'
name|'self'
op|'.'
name|'checkParsed'
op|'('
name|'input'
op|','
name|'expected'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|NodeTests
dedent|''
dedent|''
name|'class'
name|'NodeTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{Node}.\n    """'
newline|'\n'
DECL|member|test_isNodeEqualTo
name|'def'
name|'test_isNodeEqualTo'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Node.isEqualToNode} returns C{True} if and only if passed a L{Node}\n        with the same children.\n        """'
newline|'\n'
comment|'# A node is equal to itself'
nl|'\n'
name|'node'
op|'='
name|'microdom'
op|'.'
name|'Node'
op|'('
name|'object'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'node'
op|'.'
name|'isEqualToNode'
op|'('
name|'node'
op|')'
op|')'
newline|'\n'
name|'another'
op|'='
name|'microdom'
op|'.'
name|'Node'
op|'('
name|'object'
op|'('
op|')'
op|')'
newline|'\n'
comment|'# Two nodes with no children are equal'
nl|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'node'
op|'.'
name|'isEqualToNode'
op|'('
name|'another'
op|')'
op|')'
newline|'\n'
name|'node'
op|'.'
name|'appendChild'
op|'('
name|'microdom'
op|'.'
name|'Node'
op|'('
name|'object'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
comment|'# A node with no children is not equal to a node with a child'
nl|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'node'
op|'.'
name|'isEqualToNode'
op|'('
name|'another'
op|')'
op|')'
newline|'\n'
name|'another'
op|'.'
name|'appendChild'
op|'('
name|'microdom'
op|'.'
name|'Node'
op|'('
name|'object'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
comment|'# A node with a child and no grandchildren is equal to another node'
nl|'\n'
comment|'# with a child and no grandchildren.'
nl|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'node'
op|'.'
name|'isEqualToNode'
op|'('
name|'another'
op|')'
op|')'
newline|'\n'
comment|'# A node with a child and a grandchild is not equal to another node'
nl|'\n'
comment|'# with a child and no grandchildren.'
nl|'\n'
name|'node'
op|'.'
name|'firstChild'
op|'('
op|')'
op|'.'
name|'appendChild'
op|'('
name|'microdom'
op|'.'
name|'Node'
op|'('
name|'object'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'node'
op|'.'
name|'isEqualToNode'
op|'('
name|'another'
op|')'
op|')'
newline|'\n'
comment|'# A node with a child and a grandchild is equal to another node with a'
nl|'\n'
comment|'# child and a grandchild.'
nl|'\n'
name|'another'
op|'.'
name|'firstChild'
op|'('
op|')'
op|'.'
name|'appendChild'
op|'('
name|'microdom'
op|'.'
name|'Node'
op|'('
name|'object'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'node'
op|'.'
name|'isEqualToNode'
op|'('
name|'another'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_validChildInstance
dedent|''
name|'def'
name|'test_validChildInstance'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Children of L{Node} instances must also be L{Node} instances.\n        """'
newline|'\n'
name|'node'
op|'='
name|'microdom'
op|'.'
name|'Node'
op|'('
op|')'
newline|'\n'
name|'child'
op|'='
name|'microdom'
op|'.'
name|'Node'
op|'('
op|')'
newline|'\n'
comment|'# Node.appendChild() only accepts Node instances.'
nl|'\n'
name|'node'
op|'.'
name|'appendChild'
op|'('
name|'child'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'TypeError'
op|','
name|'node'
op|'.'
name|'appendChild'
op|','
name|'None'
op|')'
newline|'\n'
comment|'# Node.insertBefore() only accepts Node instances.'
nl|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'TypeError'
op|','
name|'node'
op|'.'
name|'insertBefore'
op|','
name|'child'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'TypeError'
op|','
name|'node'
op|'.'
name|'insertBefore'
op|','
name|'None'
op|','
name|'child'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'TypeError'
op|','
name|'node'
op|'.'
name|'insertBefore'
op|','
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
comment|'# Node.removeChild() only accepts Node instances.'
nl|'\n'
name|'node'
op|'.'
name|'removeChild'
op|'('
name|'child'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'TypeError'
op|','
name|'node'
op|'.'
name|'removeChild'
op|','
name|'None'
op|')'
newline|'\n'
comment|'# Node.replaceChild() only accepts Node instances.'
nl|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'TypeError'
op|','
name|'node'
op|'.'
name|'replaceChild'
op|','
name|'child'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'TypeError'
op|','
name|'node'
op|'.'
name|'replaceChild'
op|','
name|'None'
op|','
name|'child'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'TypeError'
op|','
name|'node'
op|'.'
name|'replaceChild'
op|','
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DocumentTests
dedent|''
dedent|''
name|'class'
name|'DocumentTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{Document}.\n    """'
newline|'\n'
DECL|variable|doctype
name|'doctype'
op|'='
string|'\'foo PUBLIC "baz" "http://www.example.com/example.dtd"\''
newline|'\n'
nl|'\n'
DECL|member|test_isEqualToNode
name|'def'
name|'test_isEqualToNode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Document.isEqualToNode} returns C{True} if and only if passed a\n        L{Document} with the same C{doctype} and C{documentElement}.\n        """'
newline|'\n'
comment|'# A document is equal to itself'
nl|'\n'
name|'document'
op|'='
name|'microdom'
op|'.'
name|'Document'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'document'
op|'.'
name|'isEqualToNode'
op|'('
name|'document'
op|')'
op|')'
newline|'\n'
comment|'# A document without a doctype or documentElement is equal to another'
nl|'\n'
comment|'# document without a doctype or documentElement.'
nl|'\n'
name|'another'
op|'='
name|'microdom'
op|'.'
name|'Document'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'document'
op|'.'
name|'isEqualToNode'
op|'('
name|'another'
op|')'
op|')'
newline|'\n'
comment|'# A document with a doctype is not equal to a document without a'
nl|'\n'
comment|'# doctype.'
nl|'\n'
name|'document'
op|'.'
name|'doctype'
op|'='
name|'self'
op|'.'
name|'doctype'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'document'
op|'.'
name|'isEqualToNode'
op|'('
name|'another'
op|')'
op|')'
newline|'\n'
comment|'# Two documents with the same doctype are equal'
nl|'\n'
name|'another'
op|'.'
name|'doctype'
op|'='
name|'self'
op|'.'
name|'doctype'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'document'
op|'.'
name|'isEqualToNode'
op|'('
name|'another'
op|')'
op|')'
newline|'\n'
comment|'# A document with a documentElement is not equal to a document without'
nl|'\n'
comment|'# a documentElement'
nl|'\n'
name|'document'
op|'.'
name|'appendChild'
op|'('
name|'microdom'
op|'.'
name|'Node'
op|'('
name|'object'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'document'
op|'.'
name|'isEqualToNode'
op|'('
name|'another'
op|')'
op|')'
newline|'\n'
comment|'# Two documents with equal documentElements are equal.'
nl|'\n'
name|'another'
op|'.'
name|'appendChild'
op|'('
name|'microdom'
op|'.'
name|'Node'
op|'('
name|'object'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'document'
op|'.'
name|'isEqualToNode'
op|'('
name|'another'
op|')'
op|')'
newline|'\n'
comment|'# Two documents with documentElements which are not equal are not'
nl|'\n'
comment|'# equal.'
nl|'\n'
name|'document'
op|'.'
name|'documentElement'
op|'.'
name|'appendChild'
op|'('
name|'microdom'
op|'.'
name|'Node'
op|'('
name|'object'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'document'
op|'.'
name|'isEqualToNode'
op|'('
name|'another'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_childRestriction
dedent|''
name|'def'
name|'test_childRestriction'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Document.appendChild} raises L{ValueError} if the document already\n        has a child.\n        """'
newline|'\n'
name|'document'
op|'='
name|'microdom'
op|'.'
name|'Document'
op|'('
op|')'
newline|'\n'
name|'child'
op|'='
name|'microdom'
op|'.'
name|'Node'
op|'('
op|')'
newline|'\n'
name|'another'
op|'='
name|'microdom'
op|'.'
name|'Node'
op|'('
op|')'
newline|'\n'
name|'document'
op|'.'
name|'appendChild'
op|'('
name|'child'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'ValueError'
op|','
name|'document'
op|'.'
name|'appendChild'
op|','
name|'another'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|EntityReferenceTests
dedent|''
dedent|''
name|'class'
name|'EntityReferenceTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{EntityReference}.\n    """'
newline|'\n'
DECL|member|test_isEqualToNode
name|'def'
name|'test_isEqualToNode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{EntityReference.isEqualToNode} returns C{True} if and only if passed\n        a L{EntityReference} with the same C{eref}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'EntityReference'
op|'('
string|"'quot'"
op|')'
op|'.'
name|'isEqualToNode'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'EntityReference'
op|'('
string|"'quot'"
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'EntityReference'
op|'('
string|"'quot'"
op|')'
op|'.'
name|'isEqualToNode'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'EntityReference'
op|'('
string|"'apos'"
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|CharacterDataTests
dedent|''
dedent|''
name|'class'
name|'CharacterDataTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{CharacterData}.\n    """'
newline|'\n'
DECL|member|test_isEqualToNode
name|'def'
name|'test_isEqualToNode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{CharacterData.isEqualToNode} returns C{True} if and only if passed a\n        L{CharacterData} with the same value.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'CharacterData'
op|'('
string|"'foo'"
op|')'
op|'.'
name|'isEqualToNode'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'CharacterData'
op|'('
string|"'foo'"
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'CharacterData'
op|'('
string|"'foo'"
op|')'
op|'.'
name|'isEqualToNode'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'CharacterData'
op|'('
string|"'bar'"
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|CommentTests
dedent|''
dedent|''
name|'class'
name|'CommentTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{Comment}.\n    """'
newline|'\n'
DECL|member|test_isEqualToNode
name|'def'
name|'test_isEqualToNode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Comment.isEqualToNode} returns C{True} if and only if passed a\n        L{Comment} with the same value.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'Comment'
op|'('
string|"'foo'"
op|')'
op|'.'
name|'isEqualToNode'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'Comment'
op|'('
string|"'foo'"
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'Comment'
op|'('
string|"'foo'"
op|')'
op|'.'
name|'isEqualToNode'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'Comment'
op|'('
string|"'bar'"
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TextTests
dedent|''
dedent|''
name|'class'
name|'TextTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{Text}.\n    """'
newline|'\n'
DECL|member|test_isEqualToNode
name|'def'
name|'test_isEqualToNode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Text.isEqualToNode} returns C{True} if and only if passed a L{Text}\n        which represents the same data.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'Text'
op|'('
string|"'foo'"
op|','
name|'raw'
op|'='
name|'True'
op|')'
op|'.'
name|'isEqualToNode'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'Text'
op|'('
string|"'foo'"
op|','
name|'raw'
op|'='
name|'True'
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'Text'
op|'('
string|"'foo'"
op|','
name|'raw'
op|'='
name|'True'
op|')'
op|'.'
name|'isEqualToNode'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'Text'
op|'('
string|"'foo'"
op|','
name|'raw'
op|'='
name|'False'
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'Text'
op|'('
string|"'foo'"
op|','
name|'raw'
op|'='
name|'True'
op|')'
op|'.'
name|'isEqualToNode'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'Text'
op|'('
string|"'bar'"
op|','
name|'raw'
op|'='
name|'True'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|CDATASectionTests
dedent|''
dedent|''
name|'class'
name|'CDATASectionTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{CDATASection}.\n    """'
newline|'\n'
DECL|member|test_isEqualToNode
name|'def'
name|'test_isEqualToNode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{CDATASection.isEqualToNode} returns C{True} if and only if passed a\n        L{CDATASection} which represents the same data.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'CDATASection'
op|'('
string|"'foo'"
op|')'
op|'.'
name|'isEqualToNode'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'CDATASection'
op|'('
string|"'foo'"
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'CDATASection'
op|'('
string|"'foo'"
op|')'
op|'.'
name|'isEqualToNode'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'CDATASection'
op|'('
string|"'bar'"
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ElementTests
dedent|''
dedent|''
name|'class'
name|'ElementTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{Element}.\n    """'
newline|'\n'
DECL|member|test_isEqualToNode
name|'def'
name|'test_isEqualToNode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Element.isEqualToNode} returns C{True} if and only if passed a\n        L{Element} with the same C{nodeName}, C{namespace}, C{childNodes}, and\n        C{attributes}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'Element'
op|'('
nl|'\n'
string|"'foo'"
op|','
op|'{'
string|"'a'"
op|':'
string|"'b'"
op|'}'
op|','
name|'object'
op|'('
op|')'
op|','
name|'namespace'
op|'='
string|"'bar'"
op|')'
op|'.'
name|'isEqualToNode'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'Element'
op|'('
nl|'\n'
string|"'foo'"
op|','
op|'{'
string|"'a'"
op|':'
string|"'b'"
op|'}'
op|','
name|'object'
op|'('
op|')'
op|','
name|'namespace'
op|'='
string|"'bar'"
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Elements with different nodeName values do not compare equal.'
nl|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'Element'
op|'('
nl|'\n'
string|"'foo'"
op|','
op|'{'
string|"'a'"
op|':'
string|"'b'"
op|'}'
op|','
name|'object'
op|'('
op|')'
op|','
name|'namespace'
op|'='
string|"'bar'"
op|')'
op|'.'
name|'isEqualToNode'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'Element'
op|'('
nl|'\n'
string|"'bar'"
op|','
op|'{'
string|"'a'"
op|':'
string|"'b'"
op|'}'
op|','
name|'object'
op|'('
op|')'
op|','
name|'namespace'
op|'='
string|"'bar'"
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Elements with different namespaces do not compare equal.'
nl|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'Element'
op|'('
nl|'\n'
string|"'foo'"
op|','
op|'{'
string|"'a'"
op|':'
string|"'b'"
op|'}'
op|','
name|'object'
op|'('
op|')'
op|','
name|'namespace'
op|'='
string|"'bar'"
op|')'
op|'.'
name|'isEqualToNode'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'Element'
op|'('
nl|'\n'
string|"'foo'"
op|','
op|'{'
string|"'a'"
op|':'
string|"'b'"
op|'}'
op|','
name|'object'
op|'('
op|')'
op|','
name|'namespace'
op|'='
string|"'baz'"
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Elements with different childNodes do not compare equal.'
nl|'\n'
name|'one'
op|'='
name|'microdom'
op|'.'
name|'Element'
op|'('
string|"'foo'"
op|','
op|'{'
string|"'a'"
op|':'
string|"'b'"
op|'}'
op|','
name|'object'
op|'('
op|')'
op|','
name|'namespace'
op|'='
string|"'bar'"
op|')'
newline|'\n'
name|'two'
op|'='
name|'microdom'
op|'.'
name|'Element'
op|'('
string|"'foo'"
op|','
op|'{'
string|"'a'"
op|':'
string|"'b'"
op|'}'
op|','
name|'object'
op|'('
op|')'
op|','
name|'namespace'
op|'='
string|"'bar'"
op|')'
newline|'\n'
name|'two'
op|'.'
name|'appendChild'
op|'('
name|'microdom'
op|'.'
name|'Node'
op|'('
name|'object'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'one'
op|'.'
name|'isEqualToNode'
op|'('
name|'two'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Elements with different attributes do not compare equal.'
nl|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'Element'
op|'('
nl|'\n'
string|"'foo'"
op|','
op|'{'
string|"'a'"
op|':'
string|"'b'"
op|'}'
op|','
name|'object'
op|'('
op|')'
op|','
name|'namespace'
op|'='
string|"'bar'"
op|')'
op|'.'
name|'isEqualToNode'
op|'('
nl|'\n'
name|'microdom'
op|'.'
name|'Element'
op|'('
nl|'\n'
string|"'foo'"
op|','
op|'{'
string|"'a'"
op|':'
string|"'c'"
op|'}'
op|','
name|'object'
op|'('
op|')'
op|','
name|'namespace'
op|'='
string|"'bar'"
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
