begin_unit
comment|'# -*- test-case-name: twisted.test.test_process -*-'
nl|'\n'
comment|'# Copyright (c) 2001-2010 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nUNIX Process management.\n\nDo NOT use this module directly - use reactor.spawnProcess() instead.\n\nMaintainer: Itamar Shtull-Trauring\n"""'
newline|'\n'
nl|'\n'
comment|'# System Imports'
nl|'\n'
name|'import'
name|'gc'
op|','
name|'os'
op|','
name|'sys'
op|','
name|'traceback'
op|','
name|'select'
op|','
name|'signal'
op|','
name|'errno'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'import'
name|'pty'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
DECL|variable|pty
indent|'    '
name|'pty'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'import'
name|'fcntl'
op|','
name|'termios'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
DECL|variable|fcntl
indent|'    '
name|'fcntl'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'log'
op|','
name|'failure'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'util'
name|'import'
name|'switchUID'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'fdesc'
op|','
name|'abstract'
op|','
name|'error'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'main'
name|'import'
name|'CONNECTION_LOST'
op|','
name|'CONNECTION_DONE'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'_baseprocess'
name|'import'
name|'BaseProcess'
newline|'\n'
nl|'\n'
comment|'# Some people were importing this, which is incorrect, just keeping it'
nl|'\n'
comment|'# here for backwards compatibility:'
nl|'\n'
DECL|variable|ProcessExitedAlready
name|'ProcessExitedAlready'
op|'='
name|'error'
op|'.'
name|'ProcessExitedAlready'
newline|'\n'
nl|'\n'
DECL|variable|reapProcessHandlers
name|'reapProcessHandlers'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
DECL|function|reapAllProcesses
name|'def'
name|'reapAllProcesses'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Reap all registered processes.\n    """'
newline|'\n'
name|'for'
name|'process'
name|'in'
name|'reapProcessHandlers'
op|'.'
name|'values'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'process'
op|'.'
name|'reapProcess'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|registerReapProcessHandler
dedent|''
dedent|''
name|'def'
name|'registerReapProcessHandler'
op|'('
name|'pid'
op|','
name|'process'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Register a process handler for the given pid, in case L{reapAllProcesses}\n    is called.\n\n    @param pid: the pid of the process.\n    @param process: a process handler.\n    """'
newline|'\n'
name|'if'
name|'pid'
name|'in'
name|'reapProcessHandlers'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'RuntimeError'
op|'('
string|'"Try to register an already registered process."'
op|')'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'auxPID'
op|','
name|'status'
op|'='
name|'os'
op|'.'
name|'waitpid'
op|'('
name|'pid'
op|','
name|'os'
op|'.'
name|'WNOHANG'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'        '
name|'log'
op|'.'
name|'msg'
op|'('
string|"'Failed to reap %d:'"
op|'%'
name|'pid'
op|')'
newline|'\n'
name|'log'
op|'.'
name|'err'
op|'('
op|')'
newline|'\n'
name|'auxPID'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'if'
name|'auxPID'
op|':'
newline|'\n'
indent|'        '
name|'process'
op|'.'
name|'processEnded'
op|'('
name|'status'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# if auxPID is 0, there are children but none have exited'
nl|'\n'
indent|'        '
name|'reapProcessHandlers'
op|'['
name|'pid'
op|']'
op|'='
name|'process'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|unregisterReapProcessHandler
dedent|''
dedent|''
name|'def'
name|'unregisterReapProcessHandler'
op|'('
name|'pid'
op|','
name|'process'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Unregister a process handler previously registered with\n    L{registerReapProcessHandler}.\n    """'
newline|'\n'
name|'if'
name|'not'
op|'('
name|'pid'
name|'in'
name|'reapProcessHandlers'
nl|'\n'
name|'and'
name|'reapProcessHandlers'
op|'['
name|'pid'
op|']'
op|'=='
name|'process'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'RuntimeError'
op|'('
string|'"Try to unregister a process not registered."'
op|')'
newline|'\n'
dedent|''
name|'del'
name|'reapProcessHandlers'
op|'['
name|'pid'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|detectLinuxBrokenPipeBehavior
dedent|''
name|'def'
name|'detectLinuxBrokenPipeBehavior'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    On some Linux version, write-only pipe are detected as readable. This\n    function is here to check if this bug is present or not.\n\n    See L{ProcessWriter.doRead} for a more detailed explanation.\n    """'
newline|'\n'
name|'global'
name|'brokenLinuxPipeBehavior'
newline|'\n'
name|'r'
op|','
name|'w'
op|'='
name|'os'
op|'.'
name|'pipe'
op|'('
op|')'
newline|'\n'
name|'os'
op|'.'
name|'write'
op|'('
name|'w'
op|','
string|"'a'"
op|')'
newline|'\n'
name|'reads'
op|','
name|'writes'
op|','
name|'exes'
op|'='
name|'select'
op|'.'
name|'select'
op|'('
op|'['
name|'w'
op|']'
op|','
op|'['
op|']'
op|','
op|'['
op|']'
op|','
number|'0'
op|')'
newline|'\n'
name|'if'
name|'reads'
op|':'
newline|'\n'
comment|'# Linux < 2.6.11 says a write-only pipe is readable.'
nl|'\n'
indent|'        '
name|'brokenLinuxPipeBehavior'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'brokenLinuxPipeBehavior'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'os'
op|'.'
name|'close'
op|'('
name|'r'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'w'
op|')'
newline|'\n'
nl|'\n'
comment|'# Call at import time'
nl|'\n'
dedent|''
name|'detectLinuxBrokenPipeBehavior'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ProcessWriter
name|'class'
name|'ProcessWriter'
op|'('
name|'abstract'
op|'.'
name|'FileDescriptor'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    (Internal) Helper class to write into a Process\'s input pipe.\n\n    I am a helper which describes a selectable asynchronous writer to a\n    process\'s input pipe, including stdin.\n    """'
newline|'\n'
DECL|variable|connected
name|'connected'
op|'='
number|'1'
newline|'\n'
DECL|variable|ic
name|'ic'
op|'='
number|'0'
newline|'\n'
DECL|variable|enableReadHack
name|'enableReadHack'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'reactor'
op|','
name|'proc'
op|','
name|'name'
op|','
name|'fileno'
op|','
name|'forceReadHack'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Initialize, specifying a Process instance to connect to.\n        """'
newline|'\n'
name|'abstract'
op|'.'
name|'FileDescriptor'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'reactor'
op|')'
newline|'\n'
name|'fdesc'
op|'.'
name|'setNonBlocking'
op|'('
name|'fileno'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proc'
op|'='
name|'proc'
newline|'\n'
name|'self'
op|'.'
name|'name'
op|'='
name|'name'
newline|'\n'
name|'self'
op|'.'
name|'fd'
op|'='
name|'fileno'
newline|'\n'
nl|'\n'
name|'if'
name|'forceReadHack'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'enableReadHack'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|"# Detect if this fd is actually a write-only fd. If it's"
nl|'\n'
comment|"# valid to read, don't try to detect closing via read."
nl|'\n'
comment|"# This really only means that we cannot detect a TTY's write"
nl|'\n'
comment|'# pipe being closed.'
nl|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'read'
op|'('
name|'self'
op|'.'
name|'fileno'
op|'('
op|')'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
comment|"# It's a write-only pipe end, enable hack"
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'enableReadHack'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'self'
op|'.'
name|'enableReadHack'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'startReading'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|fileno
dedent|''
dedent|''
name|'def'
name|'fileno'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the fileno() of my process\'s stdin.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'fd'
newline|'\n'
nl|'\n'
DECL|member|writeSomeData
dedent|''
name|'def'
name|'writeSomeData'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write some data to the open process.\n        """'
newline|'\n'
name|'rv'
op|'='
name|'fdesc'
op|'.'
name|'writeToFD'
op|'('
name|'self'
op|'.'
name|'fd'
op|','
name|'data'
op|')'
newline|'\n'
name|'if'
name|'rv'
op|'=='
name|'len'
op|'('
name|'data'
op|')'
name|'and'
name|'self'
op|'.'
name|'enableReadHack'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'startReading'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'rv'
newline|'\n'
nl|'\n'
DECL|member|write
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'stopReading'
op|'('
op|')'
newline|'\n'
name|'abstract'
op|'.'
name|'FileDescriptor'
op|'.'
name|'write'
op|'('
name|'self'
op|','
name|'data'
op|')'
newline|'\n'
nl|'\n'
DECL|member|doRead
dedent|''
name|'def'
name|'doRead'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The only way a write pipe can become "readable" is at EOF, because the\n        child has closed it, and we\'re using a reactor which doesn\'t\n        distinguish between readable and closed (such as the select reactor).\n\n        Except that\'s not true on linux < 2.6.11. It has the following\n        characteristics: write pipe is completely empty => POLLOUT (writable in\n        select), write pipe is not completely empty => POLLIN (readable in\n        select), write pipe\'s reader closed => POLLIN|POLLERR (readable and\n        writable in select)\n\n        That\'s what this funky code is for. If linux was not broken, this\n        function could be simply "return CONNECTION_LOST".\n\n        BUG: We call select no matter what the reactor.\n        If the reactor is pollreactor, and the fd is > 1024, this will fail.\n        (only occurs on broken versions of linux, though).\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'enableReadHack'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'brokenLinuxPipeBehavior'
op|':'
newline|'\n'
indent|'                '
name|'fd'
op|'='
name|'self'
op|'.'
name|'fd'
newline|'\n'
name|'r'
op|','
name|'w'
op|','
name|'x'
op|'='
name|'select'
op|'.'
name|'select'
op|'('
op|'['
name|'fd'
op|']'
op|','
op|'['
name|'fd'
op|']'
op|','
op|'['
op|']'
op|','
number|'0'
op|')'
newline|'\n'
name|'if'
name|'r'
name|'and'
name|'w'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'CONNECTION_LOST'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'CONNECTION_LOST'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'stopReading'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|connectionLost
dedent|''
dedent|''
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        See abstract.FileDescriptor.connectionLost.\n        """'
newline|'\n'
comment|'# At least on OS X 10.4, exiting while stdout is non-blocking can'
nl|'\n'
comment|'# result in data loss.  For some reason putting the file descriptor'
nl|'\n'
comment|'# back into blocking mode seems to resolve this issue.'
nl|'\n'
name|'fdesc'
op|'.'
name|'setBlocking'
op|'('
name|'self'
op|'.'
name|'fd'
op|')'
newline|'\n'
nl|'\n'
name|'abstract'
op|'.'
name|'FileDescriptor'
op|'.'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proc'
op|'.'
name|'childConnectionLost'
op|'('
name|'self'
op|'.'
name|'name'
op|','
name|'reason'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ProcessReader
dedent|''
dedent|''
name|'class'
name|'ProcessReader'
op|'('
name|'abstract'
op|'.'
name|'FileDescriptor'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    ProcessReader\n\n    I am a selectable representation of a process\'s output pipe, such as\n    stdout and stderr.\n    """'
newline|'\n'
DECL|variable|connected
name|'connected'
op|'='
number|'1'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'reactor'
op|','
name|'proc'
op|','
name|'name'
op|','
name|'fileno'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Initialize, specifying a process to connect to.\n        """'
newline|'\n'
name|'abstract'
op|'.'
name|'FileDescriptor'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'reactor'
op|')'
newline|'\n'
name|'fdesc'
op|'.'
name|'setNonBlocking'
op|'('
name|'fileno'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proc'
op|'='
name|'proc'
newline|'\n'
name|'self'
op|'.'
name|'name'
op|'='
name|'name'
newline|'\n'
name|'self'
op|'.'
name|'fd'
op|'='
name|'fileno'
newline|'\n'
name|'self'
op|'.'
name|'startReading'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|fileno
dedent|''
name|'def'
name|'fileno'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the fileno() of my process\'s stderr.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'fd'
newline|'\n'
nl|'\n'
DECL|member|writeSomeData
dedent|''
name|'def'
name|'writeSomeData'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
comment|'# the only time this is actually called is after .loseConnection Any'
nl|'\n'
comment|'# actual write attempt would fail, so we must avoid that. This hack'
nl|'\n'
comment|'# allows us to use .loseConnection on both readers and writers.'
nl|'\n'
indent|'        '
name|'assert'
name|'data'
op|'=='
string|'""'
newline|'\n'
name|'return'
name|'CONNECTION_LOST'
newline|'\n'
nl|'\n'
DECL|member|doRead
dedent|''
name|'def'
name|'doRead'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        This is called when the pipe becomes readable.\n        """'
newline|'\n'
name|'return'
name|'fdesc'
op|'.'
name|'readFromFD'
op|'('
name|'self'
op|'.'
name|'fd'
op|','
name|'self'
op|'.'
name|'dataReceived'
op|')'
newline|'\n'
nl|'\n'
DECL|member|dataReceived
dedent|''
name|'def'
name|'dataReceived'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'proc'
op|'.'
name|'childDataReceived'
op|'('
name|'self'
op|'.'
name|'name'
op|','
name|'data'
op|')'
newline|'\n'
nl|'\n'
DECL|member|loseConnection
dedent|''
name|'def'
name|'loseConnection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'connected'
name|'and'
name|'not'
name|'self'
op|'.'
name|'disconnecting'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'disconnecting'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'stopReading'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'self'
op|'.'
name|'connectionLost'
op|','
nl|'\n'
name|'failure'
op|'.'
name|'Failure'
op|'('
name|'CONNECTION_DONE'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|connectionLost
dedent|''
dedent|''
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Close my end of the pipe, signal the Process (which signals the\n        ProcessProtocol).\n        """'
newline|'\n'
name|'abstract'
op|'.'
name|'FileDescriptor'
op|'.'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proc'
op|'.'
name|'childConnectionLost'
op|'('
name|'self'
op|'.'
name|'name'
op|','
name|'reason'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|_BaseProcess
dedent|''
dedent|''
name|'class'
name|'_BaseProcess'
op|'('
name|'BaseProcess'
op|','
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Base class for Process and PTYProcess.\n    """'
newline|'\n'
DECL|variable|status
name|'status'
op|'='
name|'None'
newline|'\n'
DECL|variable|pid
name|'pid'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|reapProcess
name|'def'
name|'reapProcess'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Try to reap a process (without blocking) via waitpid.\n\n        This is called when sigchild is caught or a Process object loses its\n        "connection" (stdout is closed) This ought to result in reaping all\n        zombie processes, since it will be called twice as often as it needs\n        to be.\n\n        (Unfortunately, this is a slightly experimental approach, since\n        UNIX has no way to be really sure that your process is going to\n        go away w/o blocking.  I don\'t want to block.)\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'pid'
op|','
name|'status'
op|'='
name|'os'
op|'.'
name|'waitpid'
op|'('
name|'self'
op|'.'
name|'pid'
op|','
name|'os'
op|'.'
name|'WNOHANG'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|','
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'ECHILD'
op|':'
newline|'\n'
comment|'# no child process'
nl|'\n'
indent|'                    '
name|'pid'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'log'
op|'.'
name|'msg'
op|'('
string|"'Failed to reap %d:'"
op|'%'
name|'self'
op|'.'
name|'pid'
op|')'
newline|'\n'
name|'log'
op|'.'
name|'err'
op|'('
op|')'
newline|'\n'
name|'pid'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'if'
name|'pid'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'processEnded'
op|'('
name|'status'
op|')'
newline|'\n'
name|'unregisterReapProcessHandler'
op|'('
name|'pid'
op|','
name|'self'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_getReason
dedent|''
dedent|''
name|'def'
name|'_getReason'
op|'('
name|'self'
op|','
name|'status'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'exitCode'
op|'='
name|'sig'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'WIFEXITED'
op|'('
name|'status'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'exitCode'
op|'='
name|'os'
op|'.'
name|'WEXITSTATUS'
op|'('
name|'status'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'sig'
op|'='
name|'os'
op|'.'
name|'WTERMSIG'
op|'('
name|'status'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'exitCode'
name|'or'
name|'sig'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'error'
op|'.'
name|'ProcessTerminated'
op|'('
name|'exitCode'
op|','
name|'sig'
op|','
name|'status'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'error'
op|'.'
name|'ProcessDone'
op|'('
name|'status'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|signalProcess
dedent|''
name|'def'
name|'signalProcess'
op|'('
name|'self'
op|','
name|'signalID'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send the given signal C{signalID} to the process. It\'ll translate a\n        few signals (\'HUP\', \'STOP\', \'INT\', \'KILL\', \'TERM\') from a string\n        representation to its int value, otherwise it\'ll pass directly the\n        value provided\n\n        @type signalID: C{str} or C{int}\n        """'
newline|'\n'
name|'if'
name|'signalID'
name|'in'
op|'('
string|"'HUP'"
op|','
string|"'STOP'"
op|','
string|"'INT'"
op|','
string|"'KILL'"
op|','
string|"'TERM'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'signalID'
op|'='
name|'getattr'
op|'('
name|'signal'
op|','
string|"'SIG%s'"
op|'%'
op|'('
name|'signalID'
op|','
op|')'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'pid'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ProcessExitedAlready'
op|'('
op|')'
newline|'\n'
dedent|''
name|'os'
op|'.'
name|'kill'
op|'('
name|'self'
op|'.'
name|'pid'
op|','
name|'signalID'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_resetSignalDisposition
dedent|''
name|'def'
name|'_resetSignalDisposition'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# The Python interpreter ignores some signals, and our child'
nl|'\n'
comment|'# process will inherit that behaviour. To have a child process'
nl|'\n'
comment|'# that responds to signals normally, we need to reset our'
nl|'\n'
comment|"# child process's signal handling (just) after we fork and"
nl|'\n'
comment|'# before we execvpe.'
nl|'\n'
indent|'        '
name|'for'
name|'signalnum'
name|'in'
name|'range'
op|'('
number|'1'
op|','
name|'signal'
op|'.'
name|'NSIG'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'signal'
op|'.'
name|'getsignal'
op|'('
name|'signalnum'
op|')'
op|'=='
name|'signal'
op|'.'
name|'SIG_IGN'
op|':'
newline|'\n'
comment|'# Reset signal handling to the default'
nl|'\n'
indent|'                '
name|'signal'
op|'.'
name|'signal'
op|'('
name|'signalnum'
op|','
name|'signal'
op|'.'
name|'SIG_DFL'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_fork
dedent|''
dedent|''
dedent|''
name|'def'
name|'_fork'
op|'('
name|'self'
op|','
name|'path'
op|','
name|'uid'
op|','
name|'gid'
op|','
name|'executable'
op|','
name|'args'
op|','
name|'environment'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Fork and then exec sub-process.\n\n        @param path: the path where to run the new process.\n        @type path: C{str}\n        @param uid: if defined, the uid used to run the new process.\n        @type uid: C{int}\n        @param gid: if defined, the gid used to run the new process.\n        @type gid: C{int}\n        @param executable: the executable to run in a new process.\n        @type executable: C{str}\n        @param args: arguments used to create the new process.\n        @type args: C{list}.\n        @param environment: environment used for the new process.\n        @type environment: C{dict}.\n        @param kwargs: keyword arguments to L{_setupChild} method.\n        """'
newline|'\n'
name|'settingUID'
op|'='
op|'('
name|'uid'
name|'is'
name|'not'
name|'None'
op|')'
name|'or'
op|'('
name|'gid'
name|'is'
name|'not'
name|'None'
op|')'
newline|'\n'
name|'if'
name|'settingUID'
op|':'
newline|'\n'
indent|'            '
name|'curegid'
op|'='
name|'os'
op|'.'
name|'getegid'
op|'('
op|')'
newline|'\n'
name|'currgid'
op|'='
name|'os'
op|'.'
name|'getgid'
op|'('
op|')'
newline|'\n'
name|'cureuid'
op|'='
name|'os'
op|'.'
name|'geteuid'
op|'('
op|')'
newline|'\n'
name|'curruid'
op|'='
name|'os'
op|'.'
name|'getuid'
op|'('
op|')'
newline|'\n'
name|'if'
name|'uid'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'uid'
op|'='
name|'cureuid'
newline|'\n'
dedent|''
name|'if'
name|'gid'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'gid'
op|'='
name|'curegid'
newline|'\n'
comment|'# prepare to change UID in subprocess'
nl|'\n'
dedent|''
name|'os'
op|'.'
name|'setuid'
op|'('
number|'0'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'setgid'
op|'('
number|'0'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'collectorEnabled'
op|'='
name|'gc'
op|'.'
name|'isenabled'
op|'('
op|')'
newline|'\n'
name|'gc'
op|'.'
name|'disable'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'pid'
op|'='
name|'os'
op|'.'
name|'fork'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
comment|'# Still in the parent process'
nl|'\n'
indent|'            '
name|'if'
name|'settingUID'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'setregid'
op|'('
name|'currgid'
op|','
name|'curegid'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'setreuid'
op|'('
name|'curruid'
op|','
name|'cureuid'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'collectorEnabled'
op|':'
newline|'\n'
indent|'                '
name|'gc'
op|'.'
name|'enable'
op|'('
op|')'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'pid'
op|'=='
number|'0'
op|':'
comment|'# pid is 0 in the child process'
newline|'\n'
comment|'# do not put *ANY* code outside the try block. The child process'
nl|'\n'
comment|'# must either exec or _exit. If it gets outside this block (due'
nl|'\n'
comment|'# to an exception that is not handled here, but which might be'
nl|'\n'
comment|'# handled higher up), there will be two copies of the parent'
nl|'\n'
comment|'# running in parallel, doing all kinds of damage.'
nl|'\n'
nl|'\n'
comment|'# After each change to this code, review it to make sure there'
nl|'\n'
comment|'# are no exit paths.'
nl|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
comment|"# Stop debugging. If I am, I don't care anymore."
nl|'\n'
indent|'                    '
name|'sys'
op|'.'
name|'settrace'
op|'('
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_setupChild'
op|'('
op|'**'
name|'kwargs'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_execChild'
op|'('
name|'path'
op|','
name|'settingUID'
op|','
name|'uid'
op|','
name|'gid'
op|','
nl|'\n'
name|'executable'
op|','
name|'args'
op|','
name|'environment'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
comment|'# If there are errors, bail and try to write something'
nl|'\n'
comment|'# descriptive to stderr.'
nl|'\n'
comment|"# XXX: The parent's stderr isn't necessarily fd 2 anymore, or"
nl|'\n'
comment|'#      even still available'
nl|'\n'
comment|'# XXXX: however even libc assumes write(2, err) is a useful'
nl|'\n'
comment|'#       thing to attempt'
nl|'\n'
indent|'                    '
name|'try'
op|':'
newline|'\n'
indent|'                        '
name|'stderr'
op|'='
name|'os'
op|'.'
name|'fdopen'
op|'('
number|'2'
op|','
string|"'w'"
op|')'
newline|'\n'
name|'stderr'
op|'.'
name|'write'
op|'('
string|'"Upon execvpe %s %s in environment %s\\n:"'
op|'%'
nl|'\n'
op|'('
name|'executable'
op|','
name|'str'
op|'('
name|'args'
op|')'
op|','
nl|'\n'
string|'"id %s"'
op|'%'
name|'id'
op|'('
name|'environment'
op|')'
op|')'
op|')'
newline|'\n'
name|'traceback'
op|'.'
name|'print_exc'
op|'('
name|'file'
op|'='
name|'stderr'
op|')'
newline|'\n'
name|'stderr'
op|'.'
name|'flush'
op|'('
op|')'
newline|'\n'
name|'for'
name|'fd'
name|'in'
name|'range'
op|'('
number|'3'
op|')'
op|':'
newline|'\n'
indent|'                            '
name|'os'
op|'.'
name|'close'
op|'('
name|'fd'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'                        '
name|'pass'
comment|'# make *sure* the child terminates'
newline|'\n'
comment|'# Did you read the comment about not adding code here?'
nl|'\n'
dedent|''
dedent|''
name|'os'
op|'.'
name|'_exit'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
comment|'# we are now in parent process'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'settingUID'
op|':'
newline|'\n'
indent|'            '
name|'os'
op|'.'
name|'setregid'
op|'('
name|'currgid'
op|','
name|'curegid'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'setreuid'
op|'('
name|'curruid'
op|','
name|'cureuid'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'collectorEnabled'
op|':'
newline|'\n'
indent|'            '
name|'gc'
op|'.'
name|'enable'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'status'
op|'='
op|'-'
number|'1'
comment|'# this records the exit status of the child'
newline|'\n'
nl|'\n'
DECL|member|_setupChild
dedent|''
name|'def'
name|'_setupChild'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Setup the child process. Override in subclasses.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_execChild
dedent|''
name|'def'
name|'_execChild'
op|'('
name|'self'
op|','
name|'path'
op|','
name|'settingUID'
op|','
name|'uid'
op|','
name|'gid'
op|','
nl|'\n'
name|'executable'
op|','
name|'args'
op|','
name|'environment'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The exec() which is done in the forked child.\n        """'
newline|'\n'
name|'if'
name|'path'
op|':'
newline|'\n'
indent|'            '
name|'os'
op|'.'
name|'chdir'
op|'('
name|'path'
op|')'
newline|'\n'
comment|'# set the UID before I actually exec the process'
nl|'\n'
dedent|''
name|'if'
name|'settingUID'
op|':'
newline|'\n'
indent|'            '
name|'switchUID'
op|'('
name|'uid'
op|','
name|'gid'
op|')'
newline|'\n'
dedent|''
name|'os'
op|'.'
name|'execvpe'
op|'('
name|'executable'
op|','
name|'args'
op|','
name|'environment'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        String representation of a process.\n        """'
newline|'\n'
name|'return'
string|'"<%s pid=%s status=%s>"'
op|'%'
op|'('
name|'self'
op|'.'
name|'__class__'
op|'.'
name|'__name__'
op|','
nl|'\n'
name|'self'
op|'.'
name|'pid'
op|','
name|'self'
op|'.'
name|'status'
op|')'
newline|'\n'
nl|'\n'
DECL|class|Process
dedent|''
dedent|''
name|'class'
name|'Process'
op|'('
name|'_BaseProcess'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    An operating-system Process.\n\n    This represents an operating-system process with arbitrary input/output\n    pipes connected to it. Those pipes may represent standard input,\n    standard output, and standard error, or any other file descriptor.\n\n    On UNIX, this is implemented using fork(), exec(), pipe()\n    and fcntl(). These calls may not exist elsewhere so this\n    code is not cross-platform. (also, windows can only select\n    on sockets...)\n    """'
newline|'\n'
nl|'\n'
DECL|variable|debug
name|'debug'
op|'='
name|'False'
newline|'\n'
DECL|variable|debug_child
name|'debug_child'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|variable|status
name|'status'
op|'='
op|'-'
number|'1'
newline|'\n'
DECL|variable|pid
name|'pid'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|variable|processWriterFactory
name|'processWriterFactory'
op|'='
name|'ProcessWriter'
newline|'\n'
DECL|variable|processReaderFactory
name|'processReaderFactory'
op|'='
name|'ProcessReader'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
nl|'\n'
name|'reactor'
op|','
name|'executable'
op|','
name|'args'
op|','
name|'environment'
op|','
name|'path'
op|','
name|'proto'
op|','
nl|'\n'
name|'uid'
op|'='
name|'None'
op|','
name|'gid'
op|'='
name|'None'
op|','
name|'childFDs'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Spawn an operating-system process.\n\n        This is where the hard work of disconnecting all currently open\n        files / forking / executing the new process happens.  (This is\n        executed automatically when a Process is instantiated.)\n\n        This will also run the subprocess as a given user ID and group ID, if\n        specified.  (Implementation Note: this doesn\'t support all the arcane\n        nuances of setXXuid on UNIX: it will assume that either your effective\n        or real UID is 0.)\n        """'
newline|'\n'
name|'if'
name|'not'
name|'proto'
op|':'
newline|'\n'
indent|'            '
name|'assert'
string|"'r'"
name|'not'
name|'in'
name|'childFDs'
op|'.'
name|'values'
op|'('
op|')'
newline|'\n'
name|'assert'
string|"'w'"
name|'not'
name|'in'
name|'childFDs'
op|'.'
name|'values'
op|'('
op|')'
newline|'\n'
dedent|''
name|'_BaseProcess'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'proto'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'pipes'
op|'='
op|'{'
op|'}'
newline|'\n'
comment|'# keys are childFDs, we can sense them closing'
nl|'\n'
comment|'# values are ProcessReader/ProcessWriters'
nl|'\n'
nl|'\n'
name|'helpers'
op|'='
op|'{'
op|'}'
newline|'\n'
comment|'# keys are childFDs'
nl|'\n'
comment|'# values are parentFDs'
nl|'\n'
nl|'\n'
name|'if'
name|'childFDs'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'childFDs'
op|'='
op|'{'
number|'0'
op|':'
string|'"w"'
op|','
comment|"# we write to the child's stdin"
nl|'\n'
number|'1'
op|':'
string|'"r"'
op|','
comment|'# we read from their stdout'
nl|'\n'
number|'2'
op|':'
string|'"r"'
op|','
comment|'# and we read from their stderr'
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
dedent|''
name|'debug'
op|'='
name|'self'
op|'.'
name|'debug'
newline|'\n'
name|'if'
name|'debug'
op|':'
name|'print'
string|'"childFDs"'
op|','
name|'childFDs'
newline|'\n'
nl|'\n'
name|'_openedPipes'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|pipe
name|'def'
name|'pipe'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'r'
op|','
name|'w'
op|'='
name|'os'
op|'.'
name|'pipe'
op|'('
op|')'
newline|'\n'
name|'_openedPipes'
op|'.'
name|'extend'
op|'('
op|'['
name|'r'
op|','
name|'w'
op|']'
op|')'
newline|'\n'
name|'return'
name|'r'
op|','
name|'w'
newline|'\n'
nl|'\n'
comment|'# fdmap.keys() are filenos of pipes that are used by the child.'
nl|'\n'
dedent|''
name|'fdmap'
op|'='
op|'{'
op|'}'
comment|'# maps childFD to parentFD'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'childFD'
op|','
name|'target'
name|'in'
name|'childFDs'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'debug'
op|':'
name|'print'
string|'"[%d]"'
op|'%'
name|'childFD'
op|','
name|'target'
newline|'\n'
name|'if'
name|'target'
op|'=='
string|'"r"'
op|':'
newline|'\n'
comment|'# we need a pipe that the parent can read from'
nl|'\n'
indent|'                    '
name|'readFD'
op|','
name|'writeFD'
op|'='
name|'pipe'
op|'('
op|')'
newline|'\n'
name|'if'
name|'debug'
op|':'
name|'print'
string|'"readFD=%d, writeFD=%d"'
op|'%'
op|'('
name|'readFD'
op|','
name|'writeFD'
op|')'
newline|'\n'
name|'fdmap'
op|'['
name|'childFD'
op|']'
op|'='
name|'writeFD'
comment|'# child writes to this'
newline|'\n'
name|'helpers'
op|'['
name|'childFD'
op|']'
op|'='
name|'readFD'
comment|'# parent reads from this'
newline|'\n'
dedent|''
name|'elif'
name|'target'
op|'=='
string|'"w"'
op|':'
newline|'\n'
comment|'# we need a pipe that the parent can write to'
nl|'\n'
indent|'                    '
name|'readFD'
op|','
name|'writeFD'
op|'='
name|'pipe'
op|'('
op|')'
newline|'\n'
name|'if'
name|'debug'
op|':'
name|'print'
string|'"readFD=%d, writeFD=%d"'
op|'%'
op|'('
name|'readFD'
op|','
name|'writeFD'
op|')'
newline|'\n'
name|'fdmap'
op|'['
name|'childFD'
op|']'
op|'='
name|'readFD'
comment|'# child reads from this'
newline|'\n'
name|'helpers'
op|'['
name|'childFD'
op|']'
op|'='
name|'writeFD'
comment|'# parent writes to this'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'assert'
name|'type'
op|'('
name|'target'
op|')'
op|'=='
name|'int'
op|','
string|"'%r should be an int'"
op|'%'
op|'('
name|'target'
op|','
op|')'
newline|'\n'
name|'fdmap'
op|'['
name|'childFD'
op|']'
op|'='
name|'target'
comment|'# parent ignores this'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'debug'
op|':'
name|'print'
string|'"fdmap"'
op|','
name|'fdmap'
newline|'\n'
name|'if'
name|'debug'
op|':'
name|'print'
string|'"helpers"'
op|','
name|'helpers'
newline|'\n'
comment|'# the child only cares about fdmap.values()'
nl|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_fork'
op|'('
name|'path'
op|','
name|'uid'
op|','
name|'gid'
op|','
name|'executable'
op|','
name|'args'
op|','
name|'environment'
op|','
name|'fdmap'
op|'='
name|'fdmap'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'map'
op|'('
name|'os'
op|'.'
name|'close'
op|','
name|'_openedPipes'
op|')'
newline|'\n'
name|'raise'
newline|'\n'
nl|'\n'
comment|'# we are the parent process:'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'proto'
op|'='
name|'proto'
newline|'\n'
nl|'\n'
comment|'# arrange for the parent-side pipes to be read and written'
nl|'\n'
name|'for'
name|'childFD'
op|','
name|'parentFD'
name|'in'
name|'helpers'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'os'
op|'.'
name|'close'
op|'('
name|'fdmap'
op|'['
name|'childFD'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'childFDs'
op|'['
name|'childFD'
op|']'
op|'=='
string|'"r"'
op|':'
newline|'\n'
indent|'                '
name|'reader'
op|'='
name|'self'
op|'.'
name|'processReaderFactory'
op|'('
name|'reactor'
op|','
name|'self'
op|','
name|'childFD'
op|','
nl|'\n'
name|'parentFD'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'pipes'
op|'['
name|'childFD'
op|']'
op|'='
name|'reader'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'childFDs'
op|'['
name|'childFD'
op|']'
op|'=='
string|'"w"'
op|':'
newline|'\n'
indent|'                '
name|'writer'
op|'='
name|'self'
op|'.'
name|'processWriterFactory'
op|'('
name|'reactor'
op|','
name|'self'
op|','
name|'childFD'
op|','
nl|'\n'
name|'parentFD'
op|','
name|'forceReadHack'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'pipes'
op|'['
name|'childFD'
op|']'
op|'='
name|'writer'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
comment|"# the 'transport' is used for some compatibility methods"
nl|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'proto'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'proto'
op|'.'
name|'makeConnection'
op|'('
name|'self'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'log'
op|'.'
name|'err'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# The reactor might not be running yet.  This might call back into'
nl|'\n'
comment|'# processEnded synchronously, triggering an application-visible'
nl|'\n'
comment|"# callback.  That's probably not ideal.  The replacement API for"
nl|'\n'
comment|'# spawnProcess should improve upon this situation.'
nl|'\n'
dedent|''
name|'registerReapProcessHandler'
op|'('
name|'self'
op|'.'
name|'pid'
op|','
name|'self'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_setupChild
dedent|''
name|'def'
name|'_setupChild'
op|'('
name|'self'
op|','
name|'fdmap'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        fdmap[childFD] = parentFD\n\n        The child wants to end up with \'childFD\' attached to what used to be\n        the parent\'s parentFD. As an example, a bash command run like\n        \'command 2>&1\' would correspond to an fdmap of {0:0, 1:1, 2:1}.\n        \'command >foo.txt\' would be {0:0, 1:os.open(\'foo.txt\'), 2:2}.\n\n        This is accomplished in two steps::\n\n            1. close all file descriptors that aren\'t values of fdmap.  This\n               means 0 .. maxfds.\n\n            2. for each childFD::\n\n                 - if fdmap[childFD] == childFD, the descriptor is already in\n                   place.  Make sure the CLOEXEC flag is not set, then delete\n                   the entry from fdmap.\n\n                 - if childFD is in fdmap.values(), then the target descriptor\n                   is busy. Use os.dup() to move it elsewhere, update all\n                   fdmap[childFD] items that point to it, then close the\n                   original. Then fall through to the next case.\n\n                 - now fdmap[childFD] is not in fdmap.values(), and is free.\n                   Use os.dup2() to move it to the right place, then close the\n                   original.\n        """'
newline|'\n'
nl|'\n'
name|'debug'
op|'='
name|'self'
op|'.'
name|'debug_child'
newline|'\n'
name|'if'
name|'debug'
op|':'
newline|'\n'
indent|'            '
name|'errfd'
op|'='
name|'sys'
op|'.'
name|'stderr'
newline|'\n'
name|'errfd'
op|'.'
name|'write'
op|'('
string|'"starting _setupChild\\n"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'destList'
op|'='
name|'fdmap'
op|'.'
name|'values'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'import'
name|'resource'
newline|'\n'
name|'maxfds'
op|'='
name|'resource'
op|'.'
name|'getrlimit'
op|'('
name|'resource'
op|'.'
name|'RLIMIT_NOFILE'
op|')'
op|'['
number|'1'
op|']'
op|'+'
number|'1'
newline|'\n'
comment|"# OS-X reports 9223372036854775808. That's a lot of fds to close"
nl|'\n'
name|'if'
name|'maxfds'
op|'>'
number|'1024'
op|':'
newline|'\n'
indent|'                '
name|'maxfds'
op|'='
number|'1024'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'maxfds'
op|'='
number|'256'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'fd'
name|'in'
name|'xrange'
op|'('
name|'maxfds'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'fd'
name|'in'
name|'destList'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'if'
name|'debug'
name|'and'
name|'fd'
op|'=='
name|'errfd'
op|'.'
name|'fileno'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'close'
op|'('
name|'fd'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
comment|'# at this point, the only fds still open are the ones that need to'
nl|'\n'
comment|'# be moved to their appropriate positions in the child (the targets'
nl|'\n'
comment|'# of fdmap, i.e. fdmap.values() )'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'debug'
op|':'
name|'print'
op|'>>'
name|'errfd'
op|','
string|'"fdmap"'
op|','
name|'fdmap'
newline|'\n'
name|'childlist'
op|'='
name|'fdmap'
op|'.'
name|'keys'
op|'('
op|')'
newline|'\n'
name|'childlist'
op|'.'
name|'sort'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'child'
name|'in'
name|'childlist'
op|':'
newline|'\n'
indent|'            '
name|'target'
op|'='
name|'fdmap'
op|'['
name|'child'
op|']'
newline|'\n'
name|'if'
name|'target'
op|'=='
name|'child'
op|':'
newline|'\n'
comment|'# fd is already in place'
nl|'\n'
indent|'                '
name|'if'
name|'debug'
op|':'
name|'print'
op|'>>'
name|'errfd'
op|','
string|'"%d already in place"'
op|'%'
name|'target'
newline|'\n'
name|'fdesc'
op|'.'
name|'_unsetCloseOnExec'
op|'('
name|'child'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'child'
name|'in'
name|'fdmap'
op|'.'
name|'values'
op|'('
op|')'
op|':'
newline|'\n'
comment|"# we can't replace child-fd yet, as some other mapping"
nl|'\n'
comment|'# still needs the fd it wants to target. We must preserve'
nl|'\n'
comment|'# that old fd by duping it to a new home.'
nl|'\n'
indent|'                    '
name|'newtarget'
op|'='
name|'os'
op|'.'
name|'dup'
op|'('
name|'child'
op|')'
comment|'# give it a safe home'
newline|'\n'
name|'if'
name|'debug'
op|':'
name|'print'
op|'>>'
name|'errfd'
op|','
string|'"os.dup(%d) -> %d"'
op|'%'
op|'('
name|'child'
op|','
nl|'\n'
name|'newtarget'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'child'
op|')'
comment|'# close the original'
newline|'\n'
name|'for'
name|'c'
op|','
name|'p'
name|'in'
name|'fdmap'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'p'
op|'=='
name|'child'
op|':'
newline|'\n'
indent|'                            '
name|'fdmap'
op|'['
name|'c'
op|']'
op|'='
name|'newtarget'
comment|'# update all pointers'
newline|'\n'
comment|'# now it should be available'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'debug'
op|':'
name|'print'
op|'>>'
name|'errfd'
op|','
string|'"os.dup2(%d,%d)"'
op|'%'
op|'('
name|'target'
op|','
name|'child'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'dup2'
op|'('
name|'target'
op|','
name|'child'
op|')'
newline|'\n'
nl|'\n'
comment|'# At this point, the child has everything it needs. We want to close'
nl|'\n'
comment|"# everything that isn't going to be used by the child, i.e."
nl|'\n'
comment|'# everything not in fdmap.keys(). The only remaining fds open are'
nl|'\n'
comment|'# those in fdmap.values().'
nl|'\n'
nl|'\n'
comment|'# Any given fd may appear in fdmap.values() multiple times, so we'
nl|'\n'
comment|'# need to remove duplicates first.'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'old'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'fd'
name|'in'
name|'fdmap'
op|'.'
name|'values'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'fd'
name|'in'
name|'old'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'not'
name|'fd'
name|'in'
name|'fdmap'
op|'.'
name|'keys'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'old'
op|'.'
name|'append'
op|'('
name|'fd'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'debug'
op|':'
name|'print'
op|'>>'
name|'errfd'
op|','
string|'"old"'
op|','
name|'old'
newline|'\n'
name|'for'
name|'fd'
name|'in'
name|'old'
op|':'
newline|'\n'
indent|'            '
name|'os'
op|'.'
name|'close'
op|'('
name|'fd'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_resetSignalDisposition'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|writeToChild
dedent|''
name|'def'
name|'writeToChild'
op|'('
name|'self'
op|','
name|'childFD'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'pipes'
op|'['
name|'childFD'
op|']'
op|'.'
name|'write'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
DECL|member|closeChildFD
dedent|''
name|'def'
name|'closeChildFD'
op|'('
name|'self'
op|','
name|'childFD'
op|')'
op|':'
newline|'\n'
comment|'# for writer pipes, loseConnection tries to write the remaining data'
nl|'\n'
comment|'# out to the pipe before closing it'
nl|'\n'
comment|'# if childFD is not in the list of pipes, assume that it is already'
nl|'\n'
comment|'# closed'
nl|'\n'
indent|'        '
name|'if'
name|'childFD'
name|'in'
name|'self'
op|'.'
name|'pipes'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'pipes'
op|'['
name|'childFD'
op|']'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|pauseProducing
dedent|''
dedent|''
name|'def'
name|'pauseProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'p'
name|'in'
name|'self'
op|'.'
name|'pipes'
op|'.'
name|'itervalues'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'isinstance'
op|'('
name|'p'
op|','
name|'ProcessReader'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'p'
op|'.'
name|'stopReading'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|resumeProducing
dedent|''
dedent|''
dedent|''
name|'def'
name|'resumeProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'p'
name|'in'
name|'self'
op|'.'
name|'pipes'
op|'.'
name|'itervalues'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'isinstance'
op|'('
name|'p'
op|','
name|'ProcessReader'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'p'
op|'.'
name|'startReading'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# compatibility'
nl|'\n'
DECL|member|closeStdin
dedent|''
dedent|''
dedent|''
name|'def'
name|'closeStdin'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Call this to close standard input on this process.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'closeChildFD'
op|'('
number|'0'
op|')'
newline|'\n'
nl|'\n'
DECL|member|closeStdout
dedent|''
name|'def'
name|'closeStdout'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'closeChildFD'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
DECL|member|closeStderr
dedent|''
name|'def'
name|'closeStderr'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'closeChildFD'
op|'('
number|'2'
op|')'
newline|'\n'
nl|'\n'
DECL|member|loseConnection
dedent|''
name|'def'
name|'loseConnection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'closeStdin'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'closeStderr'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'closeStdout'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|write
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Call this to write to standard input on this process.\n\n        NOTE: This will silently lose data if there is no standard input.\n        """'
newline|'\n'
name|'if'
number|'0'
name|'in'
name|'self'
op|'.'
name|'pipes'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'pipes'
op|'['
number|'0'
op|']'
op|'.'
name|'write'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
DECL|member|registerProducer
dedent|''
dedent|''
name|'def'
name|'registerProducer'
op|'('
name|'self'
op|','
name|'producer'
op|','
name|'streaming'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Call this to register producer for standard input.\n\n        If there is no standard input producer.stopProducing() will\n        be called immediately.\n        """'
newline|'\n'
name|'if'
number|'0'
name|'in'
name|'self'
op|'.'
name|'pipes'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'pipes'
op|'['
number|'0'
op|']'
op|'.'
name|'registerProducer'
op|'('
name|'producer'
op|','
name|'streaming'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'producer'
op|'.'
name|'stopProducing'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|unregisterProducer
dedent|''
dedent|''
name|'def'
name|'unregisterProducer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Call this to unregister producer for standard input."""'
newline|'\n'
name|'if'
number|'0'
name|'in'
name|'self'
op|'.'
name|'pipes'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'pipes'
op|'['
number|'0'
op|']'
op|'.'
name|'unregisterProducer'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|writeSequence
dedent|''
dedent|''
name|'def'
name|'writeSequence'
op|'('
name|'self'
op|','
name|'seq'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Call this to write to standard input on this process.\n\n        NOTE: This will silently lose data if there is no standard input.\n        """'
newline|'\n'
name|'if'
number|'0'
name|'in'
name|'self'
op|'.'
name|'pipes'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'pipes'
op|'['
number|'0'
op|']'
op|'.'
name|'writeSequence'
op|'('
name|'seq'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|childDataReceived
dedent|''
dedent|''
name|'def'
name|'childDataReceived'
op|'('
name|'self'
op|','
name|'name'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'proto'
op|'.'
name|'childDataReceived'
op|'('
name|'name'
op|','
name|'data'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|childConnectionLost
dedent|''
name|'def'
name|'childConnectionLost'
op|'('
name|'self'
op|','
name|'childFD'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
comment|'# this is called when one of the helpers (ProcessReader or'
nl|'\n'
comment|'# ProcessWriter) notices their pipe has been closed'
nl|'\n'
indent|'        '
name|'os'
op|'.'
name|'close'
op|'('
name|'self'
op|'.'
name|'pipes'
op|'['
name|'childFD'
op|']'
op|'.'
name|'fileno'
op|'('
op|')'
op|')'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'pipes'
op|'['
name|'childFD'
op|']'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'proto'
op|'.'
name|'childConnectionLost'
op|'('
name|'childFD'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'log'
op|'.'
name|'err'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'maybeCallProcessEnded'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|maybeCallProcessEnded
dedent|''
name|'def'
name|'maybeCallProcessEnded'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|"# we don't call ProcessProtocol.processEnded until:"
nl|'\n'
comment|'#  the child has terminated, AND'
nl|'\n'
comment|'#  all writers have indicated an error status, AND'
nl|'\n'
comment|'#  all readers have indicated EOF'
nl|'\n'
comment|"# This insures that we've gathered all output from the process."
nl|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'pipes'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'lostProcess'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'reapProcess'
op|'('
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'_BaseProcess'
op|'.'
name|'maybeCallProcessEnded'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|PTYProcess
dedent|''
dedent|''
name|'class'
name|'PTYProcess'
op|'('
name|'abstract'
op|'.'
name|'FileDescriptor'
op|','
name|'_BaseProcess'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    An operating-system Process that uses PTY support.\n    """'
newline|'\n'
DECL|variable|status
name|'status'
op|'='
op|'-'
number|'1'
newline|'\n'
DECL|variable|pid
name|'pid'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'reactor'
op|','
name|'executable'
op|','
name|'args'
op|','
name|'environment'
op|','
name|'path'
op|','
name|'proto'
op|','
nl|'\n'
name|'uid'
op|'='
name|'None'
op|','
name|'gid'
op|'='
name|'None'
op|','
name|'usePTY'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Spawn an operating-system process.\n\n        This is where the hard work of disconnecting all currently open\n        files / forking / executing the new process happens.  (This is\n        executed automatically when a Process is instantiated.)\n\n        This will also run the subprocess as a given user ID and group ID, if\n        specified.  (Implementation Note: this doesn\'t support all the arcane\n        nuances of setXXuid on UNIX: it will assume that either your effective\n        or real UID is 0.)\n        """'
newline|'\n'
name|'if'
name|'pty'
name|'is'
name|'None'
name|'and'
name|'not'
name|'isinstance'
op|'('
name|'usePTY'
op|','
op|'('
name|'tuple'
op|','
name|'list'
op|')'
op|')'
op|':'
newline|'\n'
comment|"# no pty module and we didn't get a pty to use"
nl|'\n'
indent|'            '
name|'raise'
name|'NotImplementedError'
op|'('
nl|'\n'
string|'"cannot use PTYProcess on platforms without the pty module."'
op|')'
newline|'\n'
dedent|''
name|'abstract'
op|'.'
name|'FileDescriptor'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'reactor'
op|')'
newline|'\n'
name|'_BaseProcess'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'proto'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'isinstance'
op|'('
name|'usePTY'
op|','
op|'('
name|'tuple'
op|','
name|'list'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'masterfd'
op|','
name|'slavefd'
op|','
name|'ttyname'
op|'='
name|'usePTY'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'masterfd'
op|','
name|'slavefd'
op|'='
name|'pty'
op|'.'
name|'openpty'
op|'('
op|')'
newline|'\n'
name|'ttyname'
op|'='
name|'os'
op|'.'
name|'ttyname'
op|'('
name|'slavefd'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_fork'
op|'('
name|'path'
op|','
name|'uid'
op|','
name|'gid'
op|','
name|'executable'
op|','
name|'args'
op|','
name|'environment'
op|','
nl|'\n'
name|'masterfd'
op|'='
name|'masterfd'
op|','
name|'slavefd'
op|'='
name|'slavefd'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'usePTY'
op|','
op|'('
name|'tuple'
op|','
name|'list'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'close'
op|'('
name|'masterfd'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'slavefd'
op|')'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
nl|'\n'
comment|'# we are now in parent process:'
nl|'\n'
dedent|''
name|'os'
op|'.'
name|'close'
op|'('
name|'slavefd'
op|')'
newline|'\n'
name|'fdesc'
op|'.'
name|'setNonBlocking'
op|'('
name|'masterfd'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'fd'
op|'='
name|'masterfd'
newline|'\n'
name|'self'
op|'.'
name|'startReading'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'connected'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'status'
op|'='
op|'-'
number|'1'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'proto'
op|'.'
name|'makeConnection'
op|'('
name|'self'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'log'
op|'.'
name|'err'
op|'('
op|')'
newline|'\n'
dedent|''
name|'registerReapProcessHandler'
op|'('
name|'self'
op|'.'
name|'pid'
op|','
name|'self'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_setupChild
dedent|''
name|'def'
name|'_setupChild'
op|'('
name|'self'
op|','
name|'masterfd'
op|','
name|'slavefd'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Setup child process after fork() but before exec().\n        """'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'masterfd'
op|')'
newline|'\n'
name|'if'
name|'hasattr'
op|'('
name|'termios'
op|','
string|"'TIOCNOTTY'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'fd'
op|'='
name|'os'
op|'.'
name|'open'
op|'('
string|'"/dev/tty"'
op|','
name|'os'
op|'.'
name|'O_RDWR'
op|'|'
name|'os'
op|'.'
name|'O_NOCTTY'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'fcntl'
op|'.'
name|'ioctl'
op|'('
name|'fd'
op|','
name|'termios'
op|'.'
name|'TIOCNOTTY'
op|','
string|"''"
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'                    '
name|'pass'
newline|'\n'
dedent|''
name|'os'
op|'.'
name|'close'
op|'('
name|'fd'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'os'
op|'.'
name|'setsid'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'hasattr'
op|'('
name|'termios'
op|','
string|"'TIOCSCTTY'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'fcntl'
op|'.'
name|'ioctl'
op|'('
name|'slavefd'
op|','
name|'termios'
op|'.'
name|'TIOCSCTTY'
op|','
string|"''"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'fd'
name|'in'
name|'range'
op|'('
number|'3'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'fd'
op|'!='
name|'slavefd'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'close'
op|'('
name|'fd'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'os'
op|'.'
name|'dup2'
op|'('
name|'slavefd'
op|','
number|'0'
op|')'
comment|'# stdin'
newline|'\n'
name|'os'
op|'.'
name|'dup2'
op|'('
name|'slavefd'
op|','
number|'1'
op|')'
comment|'# stdout'
newline|'\n'
name|'os'
op|'.'
name|'dup2'
op|'('
name|'slavefd'
op|','
number|'2'
op|')'
comment|'# stderr'
newline|'\n'
nl|'\n'
name|'for'
name|'fd'
name|'in'
name|'xrange'
op|'('
number|'3'
op|','
number|'256'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'close'
op|'('
name|'fd'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_resetSignalDisposition'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# PTYs do not have stdin/stdout/stderr. They only have in and out, just'
nl|'\n'
comment|'# like sockets. You cannot close one without closing off the entire PTY.'
nl|'\n'
DECL|member|closeStdin
dedent|''
name|'def'
name|'closeStdin'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|closeStdout
dedent|''
name|'def'
name|'closeStdout'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|closeStderr
dedent|''
name|'def'
name|'closeStderr'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|doRead
dedent|''
name|'def'
name|'doRead'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when my standard output stream is ready for reading.\n        """'
newline|'\n'
name|'return'
name|'fdesc'
op|'.'
name|'readFromFD'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'fd'
op|','
nl|'\n'
name|'lambda'
name|'data'
op|':'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'childDataReceived'
op|'('
number|'1'
op|','
name|'data'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|fileno
dedent|''
name|'def'
name|'fileno'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        This returns the file number of standard output on this process.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'fd'
newline|'\n'
nl|'\n'
DECL|member|maybeCallProcessEnded
dedent|''
name|'def'
name|'maybeCallProcessEnded'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|"# two things must happen before we call the ProcessProtocol's"
nl|'\n'
comment|'# processEnded method. 1: the child process must die and be reaped'
nl|'\n'
comment|'# (which calls our own processEnded method). 2: the child must close'
nl|'\n'
comment|'# their stdin/stdout/stderr fds, causing the pty to close, causing'
nl|'\n'
comment|'# our connectionLost method to be called. #2 can also be triggered'
nl|'\n'
comment|'# by calling .loseConnection().'
nl|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'lostProcess'
op|'=='
number|'2'
op|':'
newline|'\n'
indent|'            '
name|'_BaseProcess'
op|'.'
name|'maybeCallProcessEnded'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
DECL|member|connectionLost
dedent|''
dedent|''
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        I call this to clean up when one or all of my connections has died.\n        """'
newline|'\n'
name|'abstract'
op|'.'
name|'FileDescriptor'
op|'.'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'self'
op|'.'
name|'fd'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'lostProcess'
op|'+='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'maybeCallProcessEnded'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|writeSomeData
dedent|''
name|'def'
name|'writeSomeData'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write some data to the open process.\n        """'
newline|'\n'
name|'return'
name|'fdesc'
op|'.'
name|'writeToFD'
op|'('
name|'self'
op|'.'
name|'fd'
op|','
name|'data'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
