begin_unit
comment|'# -*- test-case-name: twisted.test.test_defer,twisted.test.test_defgen,twisted.internet.test.test_inlinecb -*-'
nl|'\n'
comment|'# Copyright (c) 2001-2010 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nSupport for results that aren\'t immediately available.\n\nMaintainer: Glyph Lefkowitz\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'traceback'
newline|'\n'
name|'import'
name|'warnings'
newline|'\n'
name|'from'
name|'sys'
name|'import'
name|'exc_info'
newline|'\n'
nl|'\n'
comment|'# Twisted imports'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'log'
op|','
name|'failure'
op|','
name|'lockfile'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'util'
name|'import'
name|'unsignedID'
op|','
name|'mergeFunctionMetadata'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|AlreadyCalledError
name|'class'
name|'AlreadyCalledError'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TimeoutError
dedent|''
name|'class'
name|'TimeoutError'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|logError
dedent|''
name|'def'
name|'logError'
op|'('
name|'err'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'log'
op|'.'
name|'err'
op|'('
name|'err'
op|')'
newline|'\n'
name|'return'
name|'err'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|succeed
dedent|''
name|'def'
name|'succeed'
op|'('
name|'result'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Return a L{Deferred} that has already had C{.callback(result)} called.\n\n    This is useful when you\'re writing synchronous code to an\n    asynchronous interface: i.e., some code is calling you expecting a\n    L{Deferred} result, but you don\'t actually need to do anything\n    asynchronous. Just return C{defer.succeed(theResult)}.\n\n    See L{fail} for a version of this function that uses a failing\n    L{Deferred} rather than a successful one.\n\n    @param result: The result to give to the Deferred\'s \'callback\'\n           method.\n\n    @rtype: L{Deferred}\n    """'
newline|'\n'
name|'d'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'d'
op|'.'
name|'callback'
op|'('
name|'result'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|fail
dedent|''
name|'def'
name|'fail'
op|'('
name|'result'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Return a L{Deferred} that has already had C{.errback(result)} called.\n\n    See L{succeed}\'s docstring for rationale.\n\n    @param result: The same argument that L{Deferred.errback} takes.\n\n    @raise NoCurrentExceptionError: If C{result} is C{None} but there is no\n        current exception state.\n\n    @rtype: L{Deferred}\n    """'
newline|'\n'
name|'d'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'d'
op|'.'
name|'errback'
op|'('
name|'result'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|execute
dedent|''
name|'def'
name|'execute'
op|'('
name|'callable'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Create a L{Deferred} from a callable and arguments.\n\n    Call the given function with the given arguments.  Return a L{Deferred}\n    which has been fired with its callback as the result of that invocation\n    or its C{errback} with a L{Failure} for the exception thrown.\n    """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'result'
op|'='
name|'callable'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'fail'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'succeed'
op|'('
name|'result'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|maybeDeferred
dedent|''
dedent|''
name|'def'
name|'maybeDeferred'
op|'('
name|'f'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Invoke a function that may or may not return a L{Deferred}.\n\n    Call the given function with the given arguments.  If the returned\n    object is a L{Deferred}, return it.  If the returned object is a L{Failure},\n    wrap it with L{fail} and return it.  Otherwise, wrap it in L{succeed} and\n    return it.  If an exception is raised, convert it to a L{Failure}, wrap it\n    in L{fail}, and then return it.\n\n    @type f: Any callable\n    @param f: The callable to invoke\n\n    @param args: The arguments to pass to C{f}\n    @param kw: The keyword arguments to pass to C{f}\n\n    @rtype: L{Deferred}\n    @return: The result of the function call, wrapped in a L{Deferred} if\n    necessary.\n    """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'result'
op|'='
name|'f'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'fail'
op|'('
name|'failure'
op|'.'
name|'Failure'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'isinstance'
op|'('
name|'result'
op|','
name|'Deferred'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'result'
newline|'\n'
dedent|''
name|'elif'
name|'isinstance'
op|'('
name|'result'
op|','
name|'failure'
op|'.'
name|'Failure'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'fail'
op|'('
name|'result'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'succeed'
op|'('
name|'result'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|timeout
dedent|''
dedent|''
name|'def'
name|'timeout'
op|'('
name|'deferred'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'deferred'
op|'.'
name|'errback'
op|'('
name|'failure'
op|'.'
name|'Failure'
op|'('
name|'TimeoutError'
op|'('
string|'"Callback timed out"'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|passthru
dedent|''
name|'def'
name|'passthru'
op|'('
name|'arg'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'return'
name|'arg'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|setDebugging
dedent|''
name|'def'
name|'setDebugging'
op|'('
name|'on'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Enable or disable L{Deferred} debugging.\n\n    When debugging is on, the call stacks from creation and invocation are\n    recorded, and added to any L{AlreadyCalledErrors} we raise.\n    """'
newline|'\n'
name|'Deferred'
op|'.'
name|'debug'
op|'='
name|'bool'
op|'('
name|'on'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|getDebugging
dedent|''
name|'def'
name|'getDebugging'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Determine whether L{Deferred} debugging is enabled.\n    """'
newline|'\n'
name|'return'
name|'Deferred'
op|'.'
name|'debug'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|Deferred
dedent|''
name|'class'
name|'Deferred'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    This is a callback which will be put off until later.\n\n    Why do we want this? Well, in cases where a function in a threaded\n    program would block until it gets a result, for Twisted it should\n    not block. Instead, it should return a L{Deferred}.\n\n    This can be implemented for protocols that run over the network by\n    writing an asynchronous protocol for L{twisted.internet}. For methods\n    that come from outside packages that are not under our control, we use\n    threads (see for example L{twisted.enterprise.adbapi}).\n\n    For more information about Deferreds, see doc/howto/defer.html or\n    U{http://twistedmatrix.com/projects/core/documentation/howto/defer.html}\n    """'
newline|'\n'
nl|'\n'
DECL|variable|called
name|'called'
op|'='
number|'0'
newline|'\n'
DECL|variable|paused
name|'paused'
op|'='
number|'0'
newline|'\n'
DECL|variable|timeoutCall
name|'timeoutCall'
op|'='
name|'None'
newline|'\n'
DECL|variable|_debugInfo
name|'_debugInfo'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# Are we currently running a user-installed callback?  Meant to prevent'
nl|'\n'
comment|'# recursive running of callbacks when a reentrant call to add a callback is'
nl|'\n'
comment|'# used.'
nl|'\n'
DECL|variable|_runningCallbacks
name|'_runningCallbacks'
op|'='
name|'False'
newline|'\n'
nl|'\n'
comment|'# Keep this class attribute for now, for compatibility with code that'
nl|'\n'
comment|'# sets it directly.'
nl|'\n'
DECL|variable|debug
name|'debug'
op|'='
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'callbacks'
op|'='
op|'['
op|']'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'debug'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_debugInfo'
op|'='
name|'DebugInfo'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_debugInfo'
op|'.'
name|'creator'
op|'='
name|'traceback'
op|'.'
name|'format_stack'
op|'('
op|')'
op|'['
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|addCallbacks
dedent|''
dedent|''
name|'def'
name|'addCallbacks'
op|'('
name|'self'
op|','
name|'callback'
op|','
name|'errback'
op|'='
name|'None'
op|','
nl|'\n'
name|'callbackArgs'
op|'='
name|'None'
op|','
name|'callbackKeywords'
op|'='
name|'None'
op|','
nl|'\n'
name|'errbackArgs'
op|'='
name|'None'
op|','
name|'errbackKeywords'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Add a pair of callbacks (success and error) to this L{Deferred}.\n\n        These will be executed when the \'master\' callback is run.\n        """'
newline|'\n'
name|'assert'
name|'callable'
op|'('
name|'callback'
op|')'
newline|'\n'
name|'assert'
name|'errback'
op|'=='
name|'None'
name|'or'
name|'callable'
op|'('
name|'errback'
op|')'
newline|'\n'
name|'cbs'
op|'='
op|'('
op|'('
name|'callback'
op|','
name|'callbackArgs'
op|','
name|'callbackKeywords'
op|')'
op|','
nl|'\n'
op|'('
name|'errback'
name|'or'
op|'('
name|'passthru'
op|')'
op|','
name|'errbackArgs'
op|','
name|'errbackKeywords'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'callbacks'
op|'.'
name|'append'
op|'('
name|'cbs'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'called'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_runCallbacks'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|addCallback
dedent|''
name|'def'
name|'addCallback'
op|'('
name|'self'
op|','
name|'callback'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Convenience method for adding just a callback.\n\n        See L{addCallbacks}.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'addCallbacks'
op|'('
name|'callback'
op|','
name|'callbackArgs'
op|'='
name|'args'
op|','
nl|'\n'
name|'callbackKeywords'
op|'='
name|'kw'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|addErrback
dedent|''
name|'def'
name|'addErrback'
op|'('
name|'self'
op|','
name|'errback'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Convenience method for adding just an errback.\n\n        See L{addCallbacks}.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'addCallbacks'
op|'('
name|'passthru'
op|','
name|'errback'
op|','
nl|'\n'
name|'errbackArgs'
op|'='
name|'args'
op|','
nl|'\n'
name|'errbackKeywords'
op|'='
name|'kw'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|addBoth
dedent|''
name|'def'
name|'addBoth'
op|'('
name|'self'
op|','
name|'callback'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Convenience method for adding a single callable as both a callback\n        and an errback.\n\n        See L{addCallbacks}.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'addCallbacks'
op|'('
name|'callback'
op|','
name|'callback'
op|','
nl|'\n'
name|'callbackArgs'
op|'='
name|'args'
op|','
name|'errbackArgs'
op|'='
name|'args'
op|','
nl|'\n'
name|'callbackKeywords'
op|'='
name|'kw'
op|','
name|'errbackKeywords'
op|'='
name|'kw'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|chainDeferred
dedent|''
name|'def'
name|'chainDeferred'
op|'('
name|'self'
op|','
name|'d'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Chain another L{Deferred} to this L{Deferred}.\n\n        This method adds callbacks to this L{Deferred} to call C{d}\'s callback\n        or errback, as appropriate. It is merely a shorthand way of performing\n        the following::\n\n            self.addCallbacks(d.callback, d.errback)\n\n        When you chain a deferred d2 to another deferred d1 with\n        d1.chainDeferred(d2), you are making d2 participate in the callback\n        chain of d1. Thus any event that fires d1 will also fire d2.\n        However, the converse is B{not} true; if d2 is fired d1 will not be\n        affected.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'addCallbacks'
op|'('
name|'d'
op|'.'
name|'callback'
op|','
name|'d'
op|'.'
name|'errback'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|callback
dedent|''
name|'def'
name|'callback'
op|'('
name|'self'
op|','
name|'result'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Run all success callbacks that have been added to this L{Deferred}.\n\n        Each callback will have its result passed as the first\n        argument to the next; this way, the callbacks act as a\n        \'processing chain\'. Also, if the success-callback returns a L{Failure}\n        or raises an L{Exception}, processing will continue on the *error*-\n        callback chain.\n        """'
newline|'\n'
name|'assert'
name|'not'
name|'isinstance'
op|'('
name|'result'
op|','
name|'Deferred'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_startRunCallbacks'
op|'('
name|'result'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|errback
dedent|''
name|'def'
name|'errback'
op|'('
name|'self'
op|','
name|'fail'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Run all error callbacks that have been added to this L{Deferred}.\n\n        Each callback will have its result passed as the first\n        argument to the next; this way, the callbacks act as a\n        \'processing chain\'. Also, if the error-callback returns a non-Failure\n        or doesn\'t raise an L{Exception}, processing will continue on the\n        *success*-callback chain.\n\n        If the argument that\'s passed to me is not a L{failure.Failure} instance,\n        it will be embedded in one. If no argument is passed, a\n        L{failure.Failure} instance will be created based on the current\n        traceback stack.\n\n        Passing a string as `fail\' is deprecated, and will be punished with\n        a warning message.\n\n        @raise NoCurrentExceptionError: If C{fail} is C{None} but there is\n            no current exception state.\n        """'
newline|'\n'
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'fail'
op|','
name|'failure'
op|'.'
name|'Failure'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'fail'
op|'='
name|'failure'
op|'.'
name|'Failure'
op|'('
name|'fail'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_startRunCallbacks'
op|'('
name|'fail'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|pause
dedent|''
name|'def'
name|'pause'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Stop processing on a L{Deferred} until L{unpause}() is called.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'paused'
op|'='
name|'self'
op|'.'
name|'paused'
op|'+'
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|unpause
dedent|''
name|'def'
name|'unpause'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Process all callbacks made since L{pause}() was called.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'paused'
op|'='
name|'self'
op|'.'
name|'paused'
op|'-'
number|'1'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'paused'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'called'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_runCallbacks'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_continue
dedent|''
dedent|''
name|'def'
name|'_continue'
op|'('
name|'self'
op|','
name|'result'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'result'
op|'='
name|'result'
newline|'\n'
name|'self'
op|'.'
name|'unpause'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_startRunCallbacks
dedent|''
name|'def'
name|'_startRunCallbacks'
op|'('
name|'self'
op|','
name|'result'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'called'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'debug'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'_debugInfo'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_debugInfo'
op|'='
name|'DebugInfo'
op|'('
op|')'
newline|'\n'
dedent|''
name|'extra'
op|'='
string|'"\\n"'
op|'+'
name|'self'
op|'.'
name|'_debugInfo'
op|'.'
name|'_getDebugTracebacks'
op|'('
op|')'
newline|'\n'
name|'raise'
name|'AlreadyCalledError'
op|'('
name|'extra'
op|')'
newline|'\n'
dedent|''
name|'raise'
name|'AlreadyCalledError'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'debug'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'_debugInfo'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_debugInfo'
op|'='
name|'DebugInfo'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_debugInfo'
op|'.'
name|'invoker'
op|'='
name|'traceback'
op|'.'
name|'format_stack'
op|'('
op|')'
op|'['
op|':'
op|'-'
number|'2'
op|']'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'called'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'result'
op|'='
name|'result'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'timeoutCall'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'timeoutCall'
op|'.'
name|'cancel'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
dedent|''
name|'del'
name|'self'
op|'.'
name|'timeoutCall'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_runCallbacks'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_runCallbacks
dedent|''
name|'def'
name|'_runCallbacks'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_runningCallbacks'
op|':'
newline|'\n'
comment|"# Don't recursively run callbacks"
nl|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'paused'
op|':'
newline|'\n'
indent|'            '
name|'while'
name|'self'
op|'.'
name|'callbacks'
op|':'
newline|'\n'
indent|'                '
name|'item'
op|'='
name|'self'
op|'.'
name|'callbacks'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
newline|'\n'
name|'callback'
op|','
name|'args'
op|','
name|'kw'
op|'='
name|'item'
op|'['
nl|'\n'
name|'isinstance'
op|'('
name|'self'
op|'.'
name|'result'
op|','
name|'failure'
op|'.'
name|'Failure'
op|')'
op|']'
newline|'\n'
name|'args'
op|'='
name|'args'
name|'or'
op|'('
op|')'
newline|'\n'
name|'kw'
op|'='
name|'kw'
name|'or'
op|'{'
op|'}'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_runningCallbacks'
op|'='
name|'True'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'result'
op|'='
name|'callback'
op|'('
name|'self'
op|'.'
name|'result'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'_runningCallbacks'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'if'
name|'isinstance'
op|'('
name|'self'
op|'.'
name|'result'
op|','
name|'Deferred'
op|')'
op|':'
newline|'\n'
comment|'# note: this will cause _runCallbacks to be called'
nl|'\n'
comment|'# recursively if self.result already has a result.'
nl|'\n'
comment|"# This shouldn't cause any problems, since there is no"
nl|'\n'
comment|'# relevant state in this stack frame at this point.'
nl|'\n'
comment|'# The recursive call will continue to process'
nl|'\n'
comment|'# self.callbacks until it is empty, then return here,'
nl|'\n'
comment|'# where there is no more work to be done, so this call'
nl|'\n'
comment|'# will return as well.'
nl|'\n'
indent|'                        '
name|'self'
op|'.'
name|'pause'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'result'
op|'.'
name|'addBoth'
op|'('
name|'self'
op|'.'
name|'_continue'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'result'
op|'='
name|'failure'
op|'.'
name|'Failure'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'isinstance'
op|'('
name|'self'
op|'.'
name|'result'
op|','
name|'failure'
op|'.'
name|'Failure'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'result'
op|'.'
name|'cleanFailure'
op|'('
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_debugInfo'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_debugInfo'
op|'='
name|'DebugInfo'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_debugInfo'
op|'.'
name|'failResult'
op|'='
name|'self'
op|'.'
name|'result'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'_debugInfo'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_debugInfo'
op|'.'
name|'failResult'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|setTimeout
dedent|''
dedent|''
dedent|''
name|'def'
name|'setTimeout'
op|'('
name|'self'
op|','
name|'seconds'
op|','
name|'timeoutFunc'
op|'='
name|'timeout'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Set a timeout function to be triggered if I am not called.\n\n        @param seconds: How long to wait (from now) before firing the\n        C{timeoutFunc}.\n\n        @param timeoutFunc: will receive the L{Deferred} and *args, **kw as its\n        arguments.  The default C{timeoutFunc} will call the errback with a\n        L{TimeoutError}.\n        """'
newline|'\n'
name|'warnings'
op|'.'
name|'warn'
op|'('
nl|'\n'
string|'"Deferred.setTimeout is deprecated.  Look for timeout "'
nl|'\n'
string|'"support specific to the API you are using instead."'
op|','
nl|'\n'
name|'DeprecationWarning'
op|','
name|'stacklevel'
op|'='
number|'2'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'called'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'assert'
name|'not'
name|'self'
op|'.'
name|'timeoutCall'
op|','
string|'"Don\'t call setTimeout twice on the same Deferred."'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'reactor'
newline|'\n'
name|'self'
op|'.'
name|'timeoutCall'
op|'='
name|'reactor'
op|'.'
name|'callLater'
op|'('
nl|'\n'
name|'seconds'
op|','
nl|'\n'
name|'lambda'
op|':'
name|'self'
op|'.'
name|'called'
name|'or'
name|'timeoutFunc'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'timeoutCall'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'cname'
op|'='
name|'self'
op|'.'
name|'__class__'
op|'.'
name|'__name__'
newline|'\n'
name|'if'
name|'hasattr'
op|'('
name|'self'
op|','
string|"'result'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|'"<%s at %s  current result: %r>"'
op|'%'
op|'('
name|'cname'
op|','
name|'hex'
op|'('
name|'unsignedID'
op|'('
name|'self'
op|')'
op|')'
op|','
nl|'\n'
name|'self'
op|'.'
name|'result'
op|')'
newline|'\n'
dedent|''
name|'return'
string|'"<%s at %s>"'
op|'%'
op|'('
name|'cname'
op|','
name|'hex'
op|'('
name|'unsignedID'
op|'('
name|'self'
op|')'
op|')'
op|')'
newline|'\n'
DECL|variable|__repr__
dedent|''
name|'__repr__'
op|'='
name|'__str__'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DebugInfo
dedent|''
name|'class'
name|'DebugInfo'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Deferred debug helper.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|failResult
name|'failResult'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_getDebugTracebacks
name|'def'
name|'_getDebugTracebacks'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'info'
op|'='
string|"''"
newline|'\n'
name|'if'
name|'hasattr'
op|'('
name|'self'
op|','
string|'"creator"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'info'
op|'+='
string|'" C: Deferred was created:\\n C:"'
newline|'\n'
name|'info'
op|'+='
string|'""'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'creator'
op|')'
op|'.'
name|'rstrip'
op|'('
op|')'
op|'.'
name|'replace'
op|'('
string|'"\\n"'
op|','
string|'"\\n C:"'
op|')'
newline|'\n'
name|'info'
op|'+='
string|'"\\n"'
newline|'\n'
dedent|''
name|'if'
name|'hasattr'
op|'('
name|'self'
op|','
string|'"invoker"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'info'
op|'+='
string|'" I: First Invoker was:\\n I:"'
newline|'\n'
name|'info'
op|'+='
string|'""'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'invoker'
op|')'
op|'.'
name|'rstrip'
op|'('
op|')'
op|'.'
name|'replace'
op|'('
string|'"\\n"'
op|','
string|'"\\n I:"'
op|')'
newline|'\n'
name|'info'
op|'+='
string|'"\\n"'
newline|'\n'
dedent|''
name|'return'
name|'info'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__del__
dedent|''
name|'def'
name|'__del__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Print tracebacks and die.\n\n        If the *last* (and I do mean *last*) callback leaves me in an error\n        state, print a traceback (if said errback is a L{Failure}).\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'failResult'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'log'
op|'.'
name|'msg'
op|'('
string|'"Unhandled error in Deferred:"'
op|','
name|'isError'
op|'='
name|'True'
op|')'
newline|'\n'
name|'debugInfo'
op|'='
name|'self'
op|'.'
name|'_getDebugTracebacks'
op|'('
op|')'
newline|'\n'
name|'if'
name|'debugInfo'
op|'!='
string|"''"
op|':'
newline|'\n'
indent|'                '
name|'log'
op|'.'
name|'msg'
op|'('
string|'"(debug: "'
op|'+'
name|'debugInfo'
op|'+'
string|'")"'
op|','
name|'isError'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
name|'log'
op|'.'
name|'err'
op|'('
name|'self'
op|'.'
name|'failResult'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|FirstError
dedent|''
dedent|''
dedent|''
name|'class'
name|'FirstError'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    First error to occur in a L{DeferredList} if C{fireOnOneErrback} is set.\n\n    @ivar subFailure: The L{Failure} that occurred.\n    @type subFailure: L{Failure}\n\n    @ivar index: The index of the L{Deferred} in the L{DeferredList} where\n        it happened.\n    @type index: C{int}\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'failure'
op|','
name|'index'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'Exception'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'failure'
op|','
name|'index'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'subFailure'
op|'='
name|'failure'
newline|'\n'
name|'self'
op|'.'
name|'index'
op|'='
name|'index'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The I{repr} of L{FirstError} instances includes the repr of the\n        wrapped failure\'s exception and the index of the L{FirstError}.\n        """'
newline|'\n'
name|'return'
string|"'FirstError[#%d, %r]'"
op|'%'
op|'('
name|'self'
op|'.'
name|'index'
op|','
name|'self'
op|'.'
name|'subFailure'
op|'.'
name|'value'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The I{str} of L{FirstError} instances includes the I{str} of the\n        entire wrapped failure (including its traceback and exception) and\n        the index of the L{FirstError}.\n        """'
newline|'\n'
name|'return'
string|"'FirstError[#%d, %s]'"
op|'%'
op|'('
name|'self'
op|'.'
name|'index'
op|','
name|'self'
op|'.'
name|'subFailure'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__cmp__
dedent|''
name|'def'
name|'__cmp__'
op|'('
name|'self'
op|','
name|'other'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Comparison between L{FirstError} and other L{FirstError} instances\n        is defined as the comparison of the index and sub-failure of each\n        instance.  L{FirstError} instances don\'t compare equal to anything\n        that isn\'t a L{FirstError} instance.\n\n        @since: 8.2\n        """'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'other'
op|','
name|'FirstError'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'cmp'
op|'('
nl|'\n'
op|'('
name|'self'
op|'.'
name|'index'
op|','
name|'self'
op|'.'
name|'subFailure'
op|')'
op|','
nl|'\n'
op|'('
name|'other'
op|'.'
name|'index'
op|','
name|'other'
op|'.'
name|'subFailure'
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
op|'-'
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DeferredList
dedent|''
dedent|''
name|'class'
name|'DeferredList'
op|'('
name|'Deferred'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    I combine a group of deferreds into one callback.\n\n    I track a list of L{Deferred}s for their callbacks, and make a single\n    callback when they have all completed, a list of (success, result)\n    tuples, \'success\' being a boolean.\n\n    Note that you can still use a L{Deferred} after putting it in a\n    DeferredList.  For example, you can suppress \'Unhandled error in Deferred\'\n    messages by adding errbacks to the Deferreds *after* putting them in the\n    DeferredList, as a DeferredList won\'t swallow the errors.  (Although a more\n    convenient way to do this is simply to set the consumeErrors flag)\n    """'
newline|'\n'
nl|'\n'
DECL|variable|fireOnOneCallback
name|'fireOnOneCallback'
op|'='
number|'0'
newline|'\n'
DECL|variable|fireOnOneErrback
name|'fireOnOneErrback'
op|'='
number|'0'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'deferredList'
op|','
name|'fireOnOneCallback'
op|'='
number|'0'
op|','
name|'fireOnOneErrback'
op|'='
number|'0'
op|','
nl|'\n'
name|'consumeErrors'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Initialize a DeferredList.\n\n        @type deferredList:  C{list} of L{Deferred}s\n        @param deferredList: The list of deferreds to track.\n        @param fireOnOneCallback: (keyword param) a flag indicating that\n                             only one callback needs to be fired for me to call\n                             my callback\n        @param fireOnOneErrback: (keyword param) a flag indicating that\n                            only one errback needs to be fired for me to call\n                            my errback\n        @param consumeErrors: (keyword param) a flag indicating that any errors\n                            raised in the original deferreds should be\n                            consumed by this DeferredList.  This is useful to\n                            prevent spurious warnings being logged.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'resultList'
op|'='
op|'['
name|'None'
op|']'
op|'*'
name|'len'
op|'('
name|'deferredList'
op|')'
newline|'\n'
name|'Deferred'
op|'.'
name|'__init__'
op|'('
name|'self'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'deferredList'
op|')'
op|'=='
number|'0'
name|'and'
name|'not'
name|'fireOnOneCallback'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'callback'
op|'('
name|'self'
op|'.'
name|'resultList'
op|')'
newline|'\n'
nl|'\n'
comment|'# These flags need to be set *before* attaching callbacks to the'
nl|'\n'
comment|'# deferreds, because the callbacks use these flags, and will run'
nl|'\n'
comment|'# synchronously if any of the deferreds are already fired.'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'fireOnOneCallback'
op|'='
name|'fireOnOneCallback'
newline|'\n'
name|'self'
op|'.'
name|'fireOnOneErrback'
op|'='
name|'fireOnOneErrback'
newline|'\n'
name|'self'
op|'.'
name|'consumeErrors'
op|'='
name|'consumeErrors'
newline|'\n'
name|'self'
op|'.'
name|'finishedCount'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'index'
op|'='
number|'0'
newline|'\n'
name|'for'
name|'deferred'
name|'in'
name|'deferredList'
op|':'
newline|'\n'
indent|'            '
name|'deferred'
op|'.'
name|'addCallbacks'
op|'('
name|'self'
op|'.'
name|'_cbDeferred'
op|','
name|'self'
op|'.'
name|'_cbDeferred'
op|','
nl|'\n'
name|'callbackArgs'
op|'='
op|'('
name|'index'
op|','
name|'SUCCESS'
op|')'
op|','
nl|'\n'
name|'errbackArgs'
op|'='
op|'('
name|'index'
op|','
name|'FAILURE'
op|')'
op|')'
newline|'\n'
name|'index'
op|'='
name|'index'
op|'+'
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_cbDeferred
dedent|''
dedent|''
name|'def'
name|'_cbDeferred'
op|'('
name|'self'
op|','
name|'result'
op|','
name|'index'
op|','
name|'succeeded'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        (internal) Callback for when one of my deferreds fires.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'resultList'
op|'['
name|'index'
op|']'
op|'='
op|'('
name|'succeeded'
op|','
name|'result'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'finishedCount'
op|'+='
number|'1'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'called'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'succeeded'
op|'=='
name|'SUCCESS'
name|'and'
name|'self'
op|'.'
name|'fireOnOneCallback'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'callback'
op|'('
op|'('
name|'result'
op|','
name|'index'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'succeeded'
op|'=='
name|'FAILURE'
name|'and'
name|'self'
op|'.'
name|'fireOnOneErrback'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'errback'
op|'('
name|'failure'
op|'.'
name|'Failure'
op|'('
name|'FirstError'
op|'('
name|'result'
op|','
name|'index'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'finishedCount'
op|'=='
name|'len'
op|'('
name|'self'
op|'.'
name|'resultList'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'callback'
op|'('
name|'self'
op|'.'
name|'resultList'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'succeeded'
op|'=='
name|'FAILURE'
name|'and'
name|'self'
op|'.'
name|'consumeErrors'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|_parseDListResult
dedent|''
dedent|''
name|'def'
name|'_parseDListResult'
op|'('
name|'l'
op|','
name|'fireOnOneErrback'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'__debug__'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'success'
op|','
name|'value'
name|'in'
name|'l'
op|':'
newline|'\n'
indent|'            '
name|'assert'
name|'success'
newline|'\n'
dedent|''
dedent|''
name|'return'
op|'['
name|'x'
op|'['
number|'1'
op|']'
name|'for'
name|'x'
name|'in'
name|'l'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|gatherResults
dedent|''
name|'def'
name|'gatherResults'
op|'('
name|'deferredList'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Returns list with result of given L{Deferred}s.\n\n    This builds on L{DeferredList} but is useful since you don\'t\n    need to parse the result for success/failure.\n\n    @type deferredList:  C{list} of L{Deferred}s\n    """'
newline|'\n'
name|'d'
op|'='
name|'DeferredList'
op|'('
name|'deferredList'
op|','
name|'fireOnOneErrback'
op|'='
number|'1'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'_parseDListResult'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
comment|'# Constants for use with DeferredList'
nl|'\n'
nl|'\n'
DECL|variable|SUCCESS
dedent|''
name|'SUCCESS'
op|'='
name|'True'
newline|'\n'
DECL|variable|FAILURE
name|'FAILURE'
op|'='
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
comment|'## deferredGenerator'
nl|'\n'
nl|'\n'
DECL|class|waitForDeferred
name|'class'
name|'waitForDeferred'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    See L{deferredGenerator}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'d'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'d'
op|','
name|'Deferred'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'TypeError'
op|'('
string|'"You must give waitForDeferred a Deferred. You gave it %r."'
op|'%'
op|'('
name|'d'
op|','
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'d'
op|'='
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getResult
dedent|''
name|'def'
name|'getResult'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'isinstance'
op|'('
name|'self'
op|'.'
name|'result'
op|','
name|'failure'
op|'.'
name|'Failure'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'result'
op|'.'
name|'raiseException'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'result'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|_deferGenerator
dedent|''
dedent|''
name|'def'
name|'_deferGenerator'
op|'('
name|'g'
op|','
name|'deferred'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    See L{deferredGenerator}.\n    """'
newline|'\n'
name|'result'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# This function is complicated by the need to prevent unbounded recursion'
nl|'\n'
comment|'# arising from repeatedly yielding immediately ready deferreds.  This while'
nl|'\n'
comment|'# loop and the waiting variable solve that by manually unfolding the'
nl|'\n'
comment|'# recursion.'
nl|'\n'
nl|'\n'
name|'waiting'
op|'='
op|'['
name|'True'
op|','
comment|'# defgen is waiting for result?'
nl|'\n'
name|'None'
op|']'
comment|'# result'
newline|'\n'
nl|'\n'
name|'while'
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'='
name|'g'
op|'.'
name|'next'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'StopIteration'
op|':'
newline|'\n'
indent|'            '
name|'deferred'
op|'.'
name|'callback'
op|'('
name|'result'
op|')'
newline|'\n'
name|'return'
name|'deferred'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'deferred'
op|'.'
name|'errback'
op|'('
op|')'
newline|'\n'
name|'return'
name|'deferred'
newline|'\n'
nl|'\n'
comment|'# Deferred.callback(Deferred) raises an error; we catch this case'
nl|'\n'
comment|'# early here and give a nicer error message to the user in case'
nl|'\n'
comment|'# they yield a Deferred.'
nl|'\n'
dedent|''
name|'if'
name|'isinstance'
op|'('
name|'result'
op|','
name|'Deferred'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'fail'
op|'('
name|'TypeError'
op|'('
string|'"Yield waitForDeferred(d), not d!"'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'isinstance'
op|'('
name|'result'
op|','
name|'waitForDeferred'
op|')'
op|':'
newline|'\n'
comment|'# a waitForDeferred was yielded, get the result.'
nl|'\n'
comment|"# Pass result in so it don't get changed going around the loop"
nl|'\n'
comment|"# This isn't a problem for waiting, as it's only reused if"
nl|'\n'
comment|'# gotResult has already been executed.'
nl|'\n'
DECL|function|gotResult
indent|'            '
name|'def'
name|'gotResult'
op|'('
name|'r'
op|','
name|'result'
op|'='
name|'result'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'result'
op|'.'
name|'result'
op|'='
name|'r'
newline|'\n'
name|'if'
name|'waiting'
op|'['
number|'0'
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'waiting'
op|'['
number|'0'
op|']'
op|'='
name|'False'
newline|'\n'
name|'waiting'
op|'['
number|'1'
op|']'
op|'='
name|'r'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'_deferGenerator'
op|'('
name|'g'
op|','
name|'deferred'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'result'
op|'.'
name|'d'
op|'.'
name|'addBoth'
op|'('
name|'gotResult'
op|')'
newline|'\n'
name|'if'
name|'waiting'
op|'['
number|'0'
op|']'
op|':'
newline|'\n'
comment|"# Haven't called back yet, set flag so that we get reinvoked"
nl|'\n'
comment|'# and return from the loop'
nl|'\n'
indent|'                '
name|'waiting'
op|'['
number|'0'
op|']'
op|'='
name|'False'
newline|'\n'
name|'return'
name|'deferred'
newline|'\n'
comment|'# Reset waiting to initial values for next loop'
nl|'\n'
dedent|''
name|'waiting'
op|'['
number|'0'
op|']'
op|'='
name|'True'
newline|'\n'
name|'waiting'
op|'['
number|'1'
op|']'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'result'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|deferredGenerator
dedent|''
dedent|''
dedent|''
name|'def'
name|'deferredGenerator'
op|'('
name|'f'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    deferredGenerator and waitForDeferred help you write L{Deferred}-using code\n    that looks like a regular sequential function. If your code has a minimum\n    requirement of Python 2.5, consider the use of L{inlineCallbacks} instead,\n    which can accomplish the same thing in a more concise manner.\n\n    There are two important functions involved: L{waitForDeferred}, and\n    L{deferredGenerator}.  They are used together, like this::\n\n        def thingummy():\n            thing = waitForDeferred(makeSomeRequestResultingInDeferred())\n            yield thing\n            thing = thing.getResult()\n            print thing #the result! hoorj!\n        thingummy = deferredGenerator(thingummy)\n\n    L{waitForDeferred} returns something that you should immediately yield; when\n    your generator is resumed, calling C{thing.getResult()} will either give you\n    the result of the L{Deferred} if it was a success, or raise an exception if it\n    was a failure.  Calling C{getResult} is B{absolutely mandatory}.  If you do\n    not call it, I{your program will not work}.\n\n    L{deferredGenerator} takes one of these waitForDeferred-using generator\n    functions and converts it into a function that returns a L{Deferred}. The\n    result of the L{Deferred} will be the last value that your generator yielded\n    unless the last value is a L{waitForDeferred} instance, in which case the\n    result will be C{None}.  If the function raises an unhandled exception, the\n    L{Deferred} will errback instead.  Remember that C{return result} won\'t work;\n    use C{yield result; return} in place of that.\n\n    Note that not yielding anything from your generator will make the L{Deferred}\n    result in C{None}. Yielding a L{Deferred} from your generator is also an error\n    condition; always yield C{waitForDeferred(d)} instead.\n\n    The L{Deferred} returned from your deferred generator may also errback if your\n    generator raised an exception.  For example::\n\n        def thingummy():\n            thing = waitForDeferred(makeSomeRequestResultingInDeferred())\n            yield thing\n            thing = thing.getResult()\n            if thing == \'I love Twisted\':\n                # will become the result of the Deferred\n                yield \'TWISTED IS GREAT!\'\n                return\n            else:\n                # will trigger an errback\n                raise Exception(\'DESTROY ALL LIFE\')\n        thingummy = deferredGenerator(thingummy)\n\n    Put succinctly, these functions connect deferred-using code with this \'fake\n    blocking\' style in both directions: L{waitForDeferred} converts from a\n    L{Deferred} to the \'blocking\' style, and L{deferredGenerator} converts from the\n    \'blocking\' style to a L{Deferred}.\n    """'
newline|'\n'
nl|'\n'
DECL|function|unwindGenerator
name|'def'
name|'unwindGenerator'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'_deferGenerator'
op|'('
name|'f'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|','
name|'Deferred'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'mergeFunctionMetadata'
op|'('
name|'f'
op|','
name|'unwindGenerator'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'## inlineCallbacks'
nl|'\n'
nl|'\n'
comment|'# BaseException is only in Py 2.5.'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'BaseException'
newline|'\n'
dedent|''
name|'except'
name|'NameError'
op|':'
newline|'\n'
DECL|variable|BaseException
indent|'    '
name|'BaseException'
op|'='
name|'Exception'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|_DefGen_Return
dedent|''
name|'class'
name|'_DefGen_Return'
op|'('
name|'BaseException'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'value'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'value'
op|'='
name|'value'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|returnValue
dedent|''
dedent|''
name|'def'
name|'returnValue'
op|'('
name|'val'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Return val from a L{inlineCallbacks} generator.\n\n    Note: this is currently implemented by raising an exception\n    derived from L{BaseException}.  You might want to change any\n    \'except:\' clauses to an \'except Exception:\' clause so as not to\n    catch this exception.\n\n    Also: while this function currently will work when called from\n    within arbitrary functions called from within the generator, do\n    not rely upon this behavior.\n    """'
newline|'\n'
name|'raise'
name|'_DefGen_Return'
op|'('
name|'val'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|_inlineCallbacks
dedent|''
name|'def'
name|'_inlineCallbacks'
op|'('
name|'result'
op|','
name|'g'
op|','
name|'deferred'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    See L{inlineCallbacks}.\n    """'
newline|'\n'
comment|'# This function is complicated by the need to prevent unbounded recursion'
nl|'\n'
comment|'# arising from repeatedly yielding immediately ready deferreds.  This while'
nl|'\n'
comment|'# loop and the waiting variable solve that by manually unfolding the'
nl|'\n'
comment|'# recursion.'
nl|'\n'
nl|'\n'
name|'waiting'
op|'='
op|'['
name|'True'
op|','
comment|'# waiting for result?'
nl|'\n'
name|'None'
op|']'
comment|'# result'
newline|'\n'
nl|'\n'
name|'while'
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
comment|'# Send the last result back as the result of the yield expression.'
nl|'\n'
indent|'            '
name|'isFailure'
op|'='
name|'isinstance'
op|'('
name|'result'
op|','
name|'failure'
op|'.'
name|'Failure'
op|')'
newline|'\n'
name|'if'
name|'isFailure'
op|':'
newline|'\n'
indent|'                '
name|'result'
op|'='
name|'result'
op|'.'
name|'throwExceptionIntoGenerator'
op|'('
name|'g'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'result'
op|'='
name|'g'
op|'.'
name|'send'
op|'('
name|'result'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'StopIteration'
op|':'
newline|'\n'
comment|'# fell off the end, or "return" statement'
nl|'\n'
indent|'            '
name|'deferred'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
name|'return'
name|'deferred'
newline|'\n'
dedent|''
name|'except'
name|'_DefGen_Return'
op|','
name|'e'
op|':'
newline|'\n'
comment|'# returnValue() was called; time to give a result to the original'
nl|'\n'
comment|"# Deferred.  First though, let's try to identify the potentially"
nl|'\n'
comment|'# confusing situation which results when returnValue() is'
nl|'\n'
comment|"# accidentally invoked from a different function, one that wasn't"
nl|'\n'
comment|'# decorated with @inlineCallbacks.'
nl|'\n'
nl|'\n'
comment|'# The traceback starts in this frame (the one for'
nl|'\n'
comment|'# _inlineCallbacks); the next one down should be the application'
nl|'\n'
comment|'# code.'
nl|'\n'
indent|'            '
name|'appCodeTrace'
op|'='
name|'exc_info'
op|'('
op|')'
op|'['
number|'2'
op|']'
op|'.'
name|'tb_next'
newline|'\n'
name|'if'
name|'isFailure'
op|':'
newline|'\n'
comment|'# If we invoked this generator frame by throwing an exception'
nl|'\n'
comment|'# into it, then throwExceptionIntoGenerator will consume an'
nl|'\n'
comment|'# additional stack frame itself, so we need to skip that too.'
nl|'\n'
indent|'                '
name|'appCodeTrace'
op|'='
name|'appCodeTrace'
op|'.'
name|'tb_next'
newline|'\n'
comment|"# Now that we've identified the frame being exited by the"
nl|'\n'
comment|"# exception, let's figure out if returnValue was called from it"
nl|'\n'
comment|'# directly.  returnValue itself consumes a stack frame, so the'
nl|'\n'
comment|'# application code will have a tb_next, but it will *not* have a'
nl|'\n'
comment|'# second tb_next.'
nl|'\n'
dedent|''
name|'if'
name|'appCodeTrace'
op|'.'
name|'tb_next'
op|'.'
name|'tb_next'
op|':'
newline|'\n'
comment|'# If returnValue was invoked non-local to the frame which it is'
nl|'\n'
comment|'# exiting, identify the frame that ultimately invoked'
nl|'\n'
comment|'# returnValue so that we can warn the user, as this behavior is'
nl|'\n'
comment|'# confusing.'
nl|'\n'
indent|'                '
name|'ultimateTrace'
op|'='
name|'appCodeTrace'
newline|'\n'
name|'while'
name|'ultimateTrace'
op|'.'
name|'tb_next'
op|'.'
name|'tb_next'
op|':'
newline|'\n'
indent|'                    '
name|'ultimateTrace'
op|'='
name|'ultimateTrace'
op|'.'
name|'tb_next'
newline|'\n'
dedent|''
name|'filename'
op|'='
name|'ultimateTrace'
op|'.'
name|'tb_frame'
op|'.'
name|'f_code'
op|'.'
name|'co_filename'
newline|'\n'
name|'lineno'
op|'='
name|'ultimateTrace'
op|'.'
name|'tb_lineno'
newline|'\n'
name|'warnings'
op|'.'
name|'warn_explicit'
op|'('
nl|'\n'
string|'"returnValue() in %r causing %r to exit: "'
nl|'\n'
string|'"returnValue should only be invoked by functions decorated "'
nl|'\n'
string|'"with inlineCallbacks"'
op|'%'
op|'('
nl|'\n'
name|'ultimateTrace'
op|'.'
name|'tb_frame'
op|'.'
name|'f_code'
op|'.'
name|'co_name'
op|','
nl|'\n'
name|'appCodeTrace'
op|'.'
name|'tb_frame'
op|'.'
name|'f_code'
op|'.'
name|'co_name'
op|')'
op|','
nl|'\n'
name|'DeprecationWarning'
op|','
name|'filename'
op|','
name|'lineno'
op|')'
newline|'\n'
dedent|''
name|'deferred'
op|'.'
name|'callback'
op|'('
name|'e'
op|'.'
name|'value'
op|')'
newline|'\n'
name|'return'
name|'deferred'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'deferred'
op|'.'
name|'errback'
op|'('
op|')'
newline|'\n'
name|'return'
name|'deferred'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'isinstance'
op|'('
name|'result'
op|','
name|'Deferred'
op|')'
op|':'
newline|'\n'
comment|'# a deferred was yielded, get the result.'
nl|'\n'
DECL|function|gotResult
indent|'            '
name|'def'
name|'gotResult'
op|'('
name|'r'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'waiting'
op|'['
number|'0'
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'waiting'
op|'['
number|'0'
op|']'
op|'='
name|'False'
newline|'\n'
name|'waiting'
op|'['
number|'1'
op|']'
op|'='
name|'r'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'_inlineCallbacks'
op|'('
name|'r'
op|','
name|'g'
op|','
name|'deferred'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'result'
op|'.'
name|'addBoth'
op|'('
name|'gotResult'
op|')'
newline|'\n'
name|'if'
name|'waiting'
op|'['
number|'0'
op|']'
op|':'
newline|'\n'
comment|"# Haven't called back yet, set flag so that we get reinvoked"
nl|'\n'
comment|'# and return from the loop'
nl|'\n'
indent|'                '
name|'waiting'
op|'['
number|'0'
op|']'
op|'='
name|'False'
newline|'\n'
name|'return'
name|'deferred'
newline|'\n'
nl|'\n'
dedent|''
name|'result'
op|'='
name|'waiting'
op|'['
number|'1'
op|']'
newline|'\n'
comment|'# Reset waiting to initial values for next loop.  gotResult uses'
nl|'\n'
comment|"# waiting, but this isn't a problem because gotResult is only"
nl|'\n'
comment|"# executed once, and if it hasn't been executed yet, the return"
nl|'\n'
comment|'# branch above would have been taken.'
nl|'\n'
nl|'\n'
nl|'\n'
name|'waiting'
op|'['
number|'0'
op|']'
op|'='
name|'True'
newline|'\n'
name|'waiting'
op|'['
number|'1'
op|']'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'deferred'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|inlineCallbacks
dedent|''
name|'def'
name|'inlineCallbacks'
op|'('
name|'f'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    WARNING: this function will not work in Python 2.4 and earlier!\n\n    inlineCallbacks helps you write Deferred-using code that looks like a\n    regular sequential function. This function uses features of Python 2.5\n    generators.  If you need to be compatible with Python 2.4 or before, use\n    the L{deferredGenerator} function instead, which accomplishes the same\n    thing, but with somewhat more boilerplate.  For example::\n\n        def thingummy():\n            thing = yield makeSomeRequestResultingInDeferred()\n            print thing #the result! hoorj!\n        thingummy = inlineCallbacks(thingummy)\n\n    When you call anything that results in a L{Deferred}, you can simply yield it;\n    your generator will automatically be resumed when the Deferred\'s result is\n    available. The generator will be sent the result of the L{Deferred} with the\n    \'send\' method on generators, or if the result was a failure, \'throw\'.\n\n    Your inlineCallbacks-enabled generator will return a L{Deferred} object, which\n    will result in the return value of the generator (or will fail with a\n    failure object if your generator raises an unhandled exception). Note that\n    you can\'t use C{return result} to return a value; use C{returnValue(result)}\n    instead. Falling off the end of the generator, or simply using C{return}\n    will cause the L{Deferred} to have a result of C{None}.\n\n    The L{Deferred} returned from your deferred generator may errback if your\n    generator raised an exception::\n\n        def thingummy():\n            thing = yield makeSomeRequestResultingInDeferred()\n            if thing == \'I love Twisted\':\n                # will become the result of the Deferred\n                returnValue(\'TWISTED IS GREAT!\')\n            else:\n                # will trigger an errback\n                raise Exception(\'DESTROY ALL LIFE\')\n        thingummy = inlineCallbacks(thingummy)\n    """'
newline|'\n'
DECL|function|unwindGenerator
name|'def'
name|'unwindGenerator'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'_inlineCallbacks'
op|'('
name|'None'
op|','
name|'f'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|','
name|'Deferred'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'mergeFunctionMetadata'
op|'('
name|'f'
op|','
name|'unwindGenerator'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'## DeferredLock/DeferredQueue'
nl|'\n'
nl|'\n'
DECL|class|_ConcurrencyPrimitive
dedent|''
name|'class'
name|'_ConcurrencyPrimitive'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'waiting'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_releaseAndReturn
dedent|''
name|'def'
name|'_releaseAndReturn'
op|'('
name|'self'
op|','
name|'r'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'release'
op|'('
op|')'
newline|'\n'
name|'return'
name|'r'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|run
dedent|''
name|'def'
name|'run'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Acquire, run, release.\n\n        This function takes a callable as its first argument and any\n        number of other positional and keyword arguments.  When the\n        lock or semaphore is acquired, the callable will be invoked\n        with those arguments.\n\n        The callable may return a L{Deferred}; if it does, the lock or\n        semaphore won\'t be released until that L{Deferred} fires.\n\n        @return: L{Deferred} of function result.\n        """'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'args'
op|')'
op|'<'
number|'2'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'args'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'TypeError'
op|'('
string|'"run() takes at least 2 arguments, none given."'
op|')'
newline|'\n'
dedent|''
name|'raise'
name|'TypeError'
op|'('
string|'"%s.run() takes at least 2 arguments, 1 given"'
op|'%'
op|'('
nl|'\n'
name|'args'
op|'['
number|'0'
op|']'
op|'.'
name|'__class__'
op|'.'
name|'__name__'
op|','
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|','
name|'f'
op|'='
name|'args'
op|'['
op|':'
number|'2'
op|']'
newline|'\n'
name|'args'
op|'='
name|'args'
op|'['
number|'2'
op|':'
op|']'
newline|'\n'
nl|'\n'
DECL|function|execute
name|'def'
name|'execute'
op|'('
name|'ignoredResult'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'='
name|'maybeDeferred'
op|'('
name|'f'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addBoth'
op|'('
name|'self'
op|'.'
name|'_releaseAndReturn'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
dedent|''
name|'d'
op|'='
name|'self'
op|'.'
name|'acquire'
op|'('
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'execute'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DeferredLock
dedent|''
dedent|''
name|'class'
name|'DeferredLock'
op|'('
name|'_ConcurrencyPrimitive'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A lock for event driven systems.\n\n    @ivar locked: C{True} when this Lock has been acquired, false at all\n    other times.  Do not change this value, but it is useful to\n    examine for the equivalent of a "non-blocking" acquisition.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|locked
name|'locked'
op|'='
number|'0'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|acquire
name|'def'
name|'acquire'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Attempt to acquire the lock.  Returns a L{Deferred} that fires on\n        lock acquisition with the L{DeferredLock} as the value.  If the lock\n        is locked, then the Deferred is placed at the end of a waiting list.\n\n        @return: a L{Deferred} which fires on lock acquisition.\n        @rtype: a L{Deferred}\n        """'
newline|'\n'
name|'d'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'locked'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'waiting'
op|'.'
name|'append'
op|'('
name|'d'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'locked'
op|'='
number|'1'
newline|'\n'
name|'d'
op|'.'
name|'callback'
op|'('
name|'self'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|release
dedent|''
name|'def'
name|'release'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Release the lock.  If there is a waiting list, then the first\n        L{Deferred} in that waiting list will be called back.\n\n        Should be called by whomever did the L{acquire}() when the shared\n        resource is free.\n        """'
newline|'\n'
name|'assert'
name|'self'
op|'.'
name|'locked'
op|','
string|'"Tried to release an unlocked lock"'
newline|'\n'
name|'self'
op|'.'
name|'locked'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'waiting'
op|':'
newline|'\n'
comment|'# someone is waiting to acquire lock'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'locked'
op|'='
number|'1'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'waiting'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'callback'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DeferredSemaphore
dedent|''
dedent|''
dedent|''
name|'class'
name|'DeferredSemaphore'
op|'('
name|'_ConcurrencyPrimitive'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A semaphore for event driven systems.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'tokens'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'_ConcurrencyPrimitive'
op|'.'
name|'__init__'
op|'('
name|'self'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'tokens'
op|'='
name|'tokens'
newline|'\n'
name|'self'
op|'.'
name|'limit'
op|'='
name|'tokens'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|acquire
dedent|''
name|'def'
name|'acquire'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Attempt to acquire the token.\n\n        @return: a L{Deferred} which fires on token acquisition.\n        """'
newline|'\n'
name|'assert'
name|'self'
op|'.'
name|'tokens'
op|'>='
number|'0'
op|','
string|'"Internal inconsistency??  tokens should never be negative"'
newline|'\n'
name|'d'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'tokens'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'waiting'
op|'.'
name|'append'
op|'('
name|'d'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'tokens'
op|'='
name|'self'
op|'.'
name|'tokens'
op|'-'
number|'1'
newline|'\n'
name|'d'
op|'.'
name|'callback'
op|'('
name|'self'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|release
dedent|''
name|'def'
name|'release'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Release the token.\n\n        Should be called by whoever did the L{acquire}() when the shared\n        resource is free.\n        """'
newline|'\n'
name|'assert'
name|'self'
op|'.'
name|'tokens'
op|'<'
name|'self'
op|'.'
name|'limit'
op|','
string|'"Someone released me too many times: too many tokens!"'
newline|'\n'
name|'self'
op|'.'
name|'tokens'
op|'='
name|'self'
op|'.'
name|'tokens'
op|'+'
number|'1'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'waiting'
op|':'
newline|'\n'
comment|'# someone is waiting to acquire token'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'tokens'
op|'='
name|'self'
op|'.'
name|'tokens'
op|'-'
number|'1'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'waiting'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'callback'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|QueueOverflow
dedent|''
dedent|''
dedent|''
name|'class'
name|'QueueOverflow'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|QueueUnderflow
dedent|''
name|'class'
name|'QueueUnderflow'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DeferredQueue
dedent|''
name|'class'
name|'DeferredQueue'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    An event driven queue.\n\n    Objects may be added as usual to this queue.  When an attempt is\n    made to retrieve an object when the queue is empty, a L{Deferred} is\n    returned which will fire when an object becomes available.\n\n    @ivar size: The maximum number of objects to allow into the queue\n    at a time.  When an attempt to add a new object would exceed this\n    limit, L{QueueOverflow} is raised synchronously.  C{None} for no limit.\n\n    @ivar backlog: The maximum number of L{Deferred} gets to allow at\n    one time.  When an attempt is made to get an object which would\n    exceed this limit, L{QueueUnderflow} is raised synchronously.  C{None}\n    for no limit.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'size'
op|'='
name|'None'
op|','
name|'backlog'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'waiting'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'pending'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'size'
op|'='
name|'size'
newline|'\n'
name|'self'
op|'.'
name|'backlog'
op|'='
name|'backlog'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|put
dedent|''
name|'def'
name|'put'
op|'('
name|'self'
op|','
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Add an object to this queue.\n\n        @raise QueueOverflow: Too many objects are in this queue.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'waiting'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'waiting'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
op|'.'
name|'callback'
op|'('
name|'obj'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'size'
name|'is'
name|'None'
name|'or'
name|'len'
op|'('
name|'self'
op|'.'
name|'pending'
op|')'
op|'<'
name|'self'
op|'.'
name|'size'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'pending'
op|'.'
name|'append'
op|'('
name|'obj'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'QueueOverflow'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|get
dedent|''
dedent|''
name|'def'
name|'get'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Attempt to retrieve and remove an object from the queue.\n\n        @return: a L{Deferred} which fires with the next object available in\n        the queue.\n\n        @raise QueueUnderflow: Too many (more than C{backlog})\n        L{Deferred}s are already waiting for an object from this queue.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'pending'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'succeed'
op|'('
name|'self'
op|'.'
name|'pending'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'backlog'
name|'is'
name|'None'
name|'or'
name|'len'
op|'('
name|'self'
op|'.'
name|'waiting'
op|')'
op|'<'
name|'self'
op|'.'
name|'backlog'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'waiting'
op|'.'
name|'append'
op|'('
name|'d'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'QueueUnderflow'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|AlreadyTryingToLockError
dedent|''
dedent|''
dedent|''
name|'class'
name|'AlreadyTryingToLockError'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Raised when L{DeferredFilesystemLock.deferUntilLocked} is called twice on a\n    single L{DeferredFilesystemLock}.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DeferredFilesystemLock
dedent|''
name|'class'
name|'DeferredFilesystemLock'
op|'('
name|'lockfile'
op|'.'
name|'FilesystemLock'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A L{FilesystemLock} that allows for a L{Deferred} to be fired when the lock is\n    acquired.\n\n    @ivar _scheduler: The object in charge of scheduling retries. In this\n        implementation this is parameterized for testing.\n\n    @ivar _interval: The retry interval for an L{IReactorTime} based scheduler.\n\n    @ivar _tryLockCall: A L{DelayedCall} based on C{_interval} that will manage\n        the next retry for aquiring the lock.\n\n    @ivar _timeoutCall: A L{DelayedCall} based on C{deferUntilLocked}\'s timeout\n        argument.  This is in charge of timing out our attempt to acquire the\n        lock.\n    """'
newline|'\n'
DECL|variable|_interval
name|'_interval'
op|'='
number|'1'
newline|'\n'
DECL|variable|_tryLockCall
name|'_tryLockCall'
op|'='
name|'None'
newline|'\n'
DECL|variable|_timeoutCall
name|'_timeoutCall'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'name'
op|','
name|'scheduler'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @param name: The name of the lock to acquire\n        @param scheduler: An object which provides L{IReactorTime}\n        """'
newline|'\n'
name|'lockfile'
op|'.'
name|'FilesystemLock'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'name'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'scheduler'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'reactor'
newline|'\n'
name|'scheduler'
op|'='
name|'reactor'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_scheduler'
op|'='
name|'scheduler'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|deferUntilLocked
dedent|''
name|'def'
name|'deferUntilLocked'
op|'('
name|'self'
op|','
name|'timeout'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Wait until we acquire this lock.  This method is not safe for\n        concurrent use.\n\n        @type timeout: C{float} or C{int}\n        @param timeout: the number of seconds after which to time out if the\n            lock has not been acquired.\n\n        @return: a L{Deferred} which will callback when the lock is acquired, or\n            errback with a L{TimeoutError} after timing out or an\n            L{AlreadyTryingToLockError} if the L{deferUntilLocked} has already\n            been called and not successfully locked the file.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_tryLockCall'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'fail'
op|'('
nl|'\n'
name|'AlreadyTryingToLockError'
op|'('
nl|'\n'
string|'"deferUntilLocked isn\'t safe for concurrent use."'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'d'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|_cancelLock
name|'def'
name|'_cancelLock'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_tryLockCall'
op|'.'
name|'cancel'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_tryLockCall'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_timeoutCall'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'lock'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'d'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'d'
op|'.'
name|'errback'
op|'('
name|'failure'
op|'.'
name|'Failure'
op|'('
nl|'\n'
name|'TimeoutError'
op|'('
string|'"Timed out aquiring lock: %s after %fs"'
op|'%'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'name'
op|','
nl|'\n'
name|'timeout'
op|')'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_tryLock
dedent|''
dedent|''
name|'def'
name|'_tryLock'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'lock'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'_timeoutCall'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_timeoutCall'
op|'.'
name|'cancel'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_timeoutCall'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_tryLockCall'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'d'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'timeout'
name|'is'
name|'not'
name|'None'
name|'and'
name|'self'
op|'.'
name|'_timeoutCall'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_timeoutCall'
op|'='
name|'self'
op|'.'
name|'_scheduler'
op|'.'
name|'callLater'
op|'('
nl|'\n'
name|'timeout'
op|','
name|'_cancelLock'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_tryLockCall'
op|'='
name|'self'
op|'.'
name|'_scheduler'
op|'.'
name|'callLater'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_interval'
op|','
name|'_tryLock'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'_tryLock'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|variable|__all__
dedent|''
dedent|''
name|'__all__'
op|'='
op|'['
string|'"Deferred"'
op|','
string|'"DeferredList"'
op|','
string|'"succeed"'
op|','
string|'"fail"'
op|','
string|'"FAILURE"'
op|','
string|'"SUCCESS"'
op|','
nl|'\n'
string|'"AlreadyCalledError"'
op|','
string|'"TimeoutError"'
op|','
string|'"gatherResults"'
op|','
nl|'\n'
string|'"maybeDeferred"'
op|','
nl|'\n'
string|'"waitForDeferred"'
op|','
string|'"deferredGenerator"'
op|','
string|'"inlineCallbacks"'
op|','
nl|'\n'
string|'"returnValue"'
op|','
nl|'\n'
string|'"DeferredLock"'
op|','
string|'"DeferredSemaphore"'
op|','
string|'"DeferredQueue"'
op|','
nl|'\n'
string|'"DeferredFilesystemLock"'
op|','
string|'"AlreadyTryingToLockError"'
op|','
nl|'\n'
op|']'
newline|'\n'
endmarker|''
end_unit
