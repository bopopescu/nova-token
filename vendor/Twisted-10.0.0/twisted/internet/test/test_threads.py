begin_unit
comment|'# Copyright (c) 2008 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTests for implementations of L{IReactorThreads}.\n"""'
newline|'\n'
nl|'\n'
DECL|variable|__metaclass__
name|'__metaclass__'
op|'='
name|'type'
newline|'\n'
nl|'\n'
name|'from'
name|'weakref'
name|'import'
name|'ref'
newline|'\n'
name|'import'
name|'gc'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'test'
op|'.'
name|'reactormixins'
name|'import'
name|'ReactorBuilder'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'threadpool'
name|'import'
name|'ThreadPool'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ThreadTestsBuilder
name|'class'
name|'ThreadTestsBuilder'
op|'('
name|'ReactorBuilder'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Builder for defining tests relating to L{IReactorThreads}.\n    """'
newline|'\n'
DECL|member|test_getThreadPool
name|'def'
name|'test_getThreadPool'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{reactor.getThreadPool()} returns an instance of L{ThreadPool} which\n        starts when C{reactor.run()} is called and stops before it returns.\n        """'
newline|'\n'
name|'state'
op|'='
op|'['
op|']'
newline|'\n'
name|'reactor'
op|'='
name|'self'
op|'.'
name|'buildReactor'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'pool'
op|'='
name|'reactor'
op|'.'
name|'getThreadPool'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'pool'
op|','
name|'ThreadPool'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
nl|'\n'
name|'pool'
op|'.'
name|'started'
op|','
string|'"Pool should not start before reactor.run"'
op|')'
newline|'\n'
nl|'\n'
DECL|function|f
name|'def'
name|'f'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# Record the state for later assertions'
nl|'\n'
indent|'            '
name|'state'
op|'.'
name|'append'
op|'('
name|'pool'
op|'.'
name|'started'
op|')'
newline|'\n'
name|'state'
op|'.'
name|'append'
op|'('
name|'pool'
op|'.'
name|'joined'
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'reactor'
op|'.'
name|'callWhenRunning'
op|'('
name|'f'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'runReactor'
op|'('
name|'reactor'
op|','
number|'2'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
nl|'\n'
name|'state'
op|'['
number|'0'
op|']'
op|','
string|'"Pool should start after reactor.run"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
nl|'\n'
name|'state'
op|'['
number|'1'
op|']'
op|','
string|'"Pool should not be joined before reactor.stop"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
nl|'\n'
name|'pool'
op|'.'
name|'joined'
op|','
nl|'\n'
string|'"Pool should be stopped after reactor.run returns"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_suggestThreadPoolSize
dedent|''
name|'def'
name|'test_suggestThreadPoolSize'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{reactor.suggestThreadPoolSize()} sets the maximum size of the reactor\n        threadpool.\n        """'
newline|'\n'
name|'reactor'
op|'='
name|'self'
op|'.'
name|'buildReactor'
op|'('
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'suggestThreadPoolSize'
op|'('
number|'17'
op|')'
newline|'\n'
name|'pool'
op|'='
name|'reactor'
op|'.'
name|'getThreadPool'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'pool'
op|'.'
name|'max'
op|','
number|'17'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_delayedCallFromThread
dedent|''
name|'def'
name|'test_delayedCallFromThread'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A function scheduled with L{IReactorThreads.callFromThread} invoked\n        from a delayed call is run immediately in the next reactor iteration.\n\n        When invoked from the reactor thread, previous implementations of\n        L{IReactorThreads.callFromThread} would skip the pipe/socket based wake\n        up step, assuming the reactor would wake up on its own.  However, this\n        resulted in the reactor not noticing a insert into the thread queue at\n        the right time (in this case, after the thread queue has been processed\n        for that reactor iteration).\n        """'
newline|'\n'
name|'reactor'
op|'='
name|'self'
op|'.'
name|'buildReactor'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|threadCall
name|'def'
name|'threadCall'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'reactor'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Set up the use of callFromThread being tested.'
nl|'\n'
dedent|''
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'reactor'
op|'.'
name|'callFromThread'
op|','
name|'threadCall'
op|')'
newline|'\n'
nl|'\n'
name|'before'
op|'='
name|'reactor'
op|'.'
name|'seconds'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'runReactor'
op|'('
name|'reactor'
op|','
number|'60'
op|')'
newline|'\n'
name|'after'
op|'='
name|'reactor'
op|'.'
name|'seconds'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# We specified a timeout of 60 seconds.  The timeout code in runReactor'
nl|'\n'
comment|"# probably won't actually work, though.  If the reactor comes out of"
nl|'\n'
comment|'# the event notification API just a little bit early, say after 59.9999'
nl|'\n'
comment|'# seconds instead of after 60 seconds, then the queued thread call will'
nl|'\n'
comment|"# get processed but the timeout delayed call runReactor sets up won't!"
nl|'\n'
comment|'# Then the reactor will stop and runReactor will return without the'
nl|'\n'
comment|'# timeout firing.  As it turns out, select() and poll() are quite'
nl|'\n'
comment|'# likely to return *slightly* earlier than we ask them to, so the'
nl|'\n'
comment|'# timeout will rarely happen, even if callFromThread is broken.  So,'
nl|'\n'
comment|"# instead we'll measure the elapsed time and make sure it's something"
nl|'\n'
comment|'# less than about half of the timeout we specified.  This is heuristic.'
nl|'\n'
comment|"# It assumes that select() won't ever return after 30 seconds when we"
nl|'\n'
comment|'# asked it to timeout after 60 seconds.  And of course like all'
nl|'\n'
comment|"# time-based tests, it's slightly non-deterministic.  If the OS doesn't"
nl|'\n'
comment|'# schedule this process for 30 seconds, then the test might fail even'
nl|'\n'
comment|'# if callFromThread is working.'
nl|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'after'
op|'-'
name|'before'
op|'<'
number|'30'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_stopThreadPool
dedent|''
name|'def'
name|'test_stopThreadPool'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When the reactor stops, L{ReactorBase._stopThreadPool} drops the\n        reactor\'s direct reference to its internal threadpool and removes\n        the associated startup and shutdown triggers.\n\n        This is the case of the thread pool being created before the reactor\n        is run.\n        """'
newline|'\n'
name|'reactor'
op|'='
name|'self'
op|'.'
name|'buildReactor'
op|'('
op|')'
newline|'\n'
name|'threadpool'
op|'='
name|'ref'
op|'('
name|'reactor'
op|'.'
name|'getThreadPool'
op|'('
op|')'
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'callWhenRunning'
op|'('
name|'reactor'
op|'.'
name|'stop'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'runReactor'
op|'('
name|'reactor'
op|')'
newline|'\n'
name|'gc'
op|'.'
name|'collect'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'threadpool'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_stopThreadPoolWhenStartedAfterReactorRan
dedent|''
name|'def'
name|'test_stopThreadPoolWhenStartedAfterReactorRan'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        We must handle the case of shutting down the thread pool when it was\n        started after the reactor was run in a special way.\n\n        Some implementation background: The thread pool is started with\n        callWhenRunning, which only returns a system trigger ID when it is\n        invoked before the reactor is started.\n\n        This is the case of the thread pool being created after the reactor\n        is started.\n        """'
newline|'\n'
name|'reactor'
op|'='
name|'self'
op|'.'
name|'buildReactor'
op|'('
op|')'
newline|'\n'
name|'threadPoolRefs'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|acquireThreadPool
name|'def'
name|'acquireThreadPool'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'threadPoolRefs'
op|'.'
name|'append'
op|'('
name|'ref'
op|'('
name|'reactor'
op|'.'
name|'getThreadPool'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
dedent|''
name|'reactor'
op|'.'
name|'callWhenRunning'
op|'('
name|'acquireThreadPool'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'runReactor'
op|'('
name|'reactor'
op|')'
newline|'\n'
name|'gc'
op|'.'
name|'collect'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'threadPoolRefs'
op|'['
number|'0'
op|']'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_cleanUpThreadPoolEvenBeforeReactorIsRun
dedent|''
name|'def'
name|'test_cleanUpThreadPoolEvenBeforeReactorIsRun'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When the reactor has its shutdown event fired before it is run, the\n        thread pool is completely destroyed.\n\n        For what it\'s worth, the reason we support this behavior at all is\n        because Trial does this.\n\n        This is the case of the thread pool being created without the reactor\n        being started at al.\n        """'
newline|'\n'
name|'reactor'
op|'='
name|'self'
op|'.'
name|'buildReactor'
op|'('
op|')'
newline|'\n'
name|'threadPoolRef'
op|'='
name|'ref'
op|'('
name|'reactor'
op|'.'
name|'getThreadPool'
op|'('
op|')'
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'fireSystemEvent'
op|'('
string|'"shutdown"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'threadPoolRef'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'globals'
op|'('
op|')'
op|'.'
name|'update'
op|'('
name|'ThreadTestsBuilder'
op|'.'
name|'makeTestCaseClasses'
op|'('
op|')'
op|')'
newline|'\n'
endmarker|''
end_unit
