begin_unit
comment|'# Copyright (c) 2008-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTests for implementations of L{IReactorProcess}.\n"""'
newline|'\n'
nl|'\n'
DECL|variable|__metaclass__
name|'__metaclass__'
op|'='
name|'type'
newline|'\n'
nl|'\n'
name|'import'
name|'os'
op|','
name|'sys'
op|','
name|'signal'
op|','
name|'threading'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
op|'.'
name|'unittest'
name|'import'
name|'TestCase'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'test'
op|'.'
name|'reactormixins'
name|'import'
name|'ReactorBuilder'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'compat'
name|'import'
name|'set'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'log'
name|'import'
name|'msg'
op|','
name|'err'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'runtime'
name|'import'
name|'platform'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'filepath'
name|'import'
name|'FilePath'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'utils'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'interfaces'
name|'import'
name|'IReactorProcess'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'defer'
name|'import'
name|'Deferred'
op|','
name|'succeed'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'protocol'
name|'import'
name|'ProcessProtocol'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'error'
name|'import'
name|'ProcessDone'
op|','
name|'ProcessTerminated'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|_ShutdownCallbackProcessProtocol
name|'class'
name|'_ShutdownCallbackProcessProtocol'
op|'('
name|'ProcessProtocol'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    An L{IProcessProtocol} which fires a Deferred when the process it is\n    associated with ends.\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'whenFinished'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'whenFinished'
op|'='
name|'whenFinished'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|processEnded
dedent|''
name|'def'
name|'processEnded'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'whenFinished'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ProcessTestsBuilderBase
dedent|''
dedent|''
name|'class'
name|'ProcessTestsBuilderBase'
op|'('
name|'ReactorBuilder'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Base class for L{IReactorProcess} tests which defines some tests which\n    can be applied to PTY or non-PTY uses of C{spawnProcess}.\n\n    Subclasses are expected to set the C{usePTY} attribute to C{True} or\n    C{False}.\n    """'
newline|'\n'
DECL|variable|requiredInterfaces
name|'requiredInterfaces'
op|'='
op|'['
name|'IReactorProcess'
op|']'
newline|'\n'
nl|'\n'
DECL|member|test_spawnProcessEarlyIsReaped
name|'def'
name|'test_spawnProcessEarlyIsReaped'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If, before the reactor is started with L{IReactorCore.run}, a\n        process is started with L{IReactorProcess.spawnProcess} and\n        terminates, the process is reaped once the reactor is started.\n        """'
newline|'\n'
name|'reactor'
op|'='
name|'self'
op|'.'
name|'buildReactor'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Create the process with no shared file descriptors, so that there'
nl|'\n'
comment|'# are no other events for the reactor to notice and "cheat" with.'
nl|'\n'
comment|"# We want to be sure it's really dealing with the process exiting,"
nl|'\n'
comment|'# not some associated event.'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'usePTY'
op|':'
newline|'\n'
indent|'            '
name|'childFDs'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'childFDs'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
comment|'# Arrange to notice the SIGCHLD.'
nl|'\n'
dedent|''
name|'signaled'
op|'='
name|'threading'
op|'.'
name|'Event'
op|'('
op|')'
newline|'\n'
DECL|function|handler
name|'def'
name|'handler'
op|'('
op|'*'
name|'args'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'signaled'
op|'.'
name|'set'
op|'('
op|')'
newline|'\n'
dedent|''
name|'signal'
op|'.'
name|'signal'
op|'('
name|'signal'
op|'.'
name|'SIGCHLD'
op|','
name|'handler'
op|')'
newline|'\n'
nl|'\n'
comment|'# Start a process - before starting the reactor!'
nl|'\n'
name|'ended'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'spawnProcess'
op|'('
nl|'\n'
name|'_ShutdownCallbackProcessProtocol'
op|'('
name|'ended'
op|')'
op|','
name|'sys'
op|'.'
name|'executable'
op|','
nl|'\n'
op|'['
name|'sys'
op|'.'
name|'executable'
op|','
string|'"-c"'
op|','
string|'""'
op|']'
op|','
name|'usePTY'
op|'='
name|'self'
op|'.'
name|'usePTY'
op|','
name|'childFDs'
op|'='
name|'childFDs'
op|')'
newline|'\n'
nl|'\n'
comment|'# Wait for the SIGCHLD (which might have been delivered before we got'
nl|'\n'
comment|"# here, but that's okay because the signal handler was installed above,"
nl|'\n'
comment|'# before we could have gotten it).'
nl|'\n'
name|'signaled'
op|'.'
name|'wait'
op|'('
number|'120'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'signaled'
op|'.'
name|'isSet'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'fail'
op|'('
string|'"Timed out waiting for child process to exit."'
op|')'
newline|'\n'
nl|'\n'
comment|'# Capture the processEnded callback.'
nl|'\n'
dedent|''
name|'result'
op|'='
op|'['
op|']'
newline|'\n'
name|'ended'
op|'.'
name|'addCallback'
op|'('
name|'result'
op|'.'
name|'append'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'result'
op|':'
newline|'\n'
comment|'# The synchronous path through spawnProcess / Process.__init__ /'
nl|'\n'
comment|"# registerReapProcessHandler was encountered.  There's no reason to"
nl|'\n'
comment|'# start the reactor, because everything is done already.'
nl|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
comment|'# Otherwise, though, start the reactor so it can tell us the process'
nl|'\n'
comment|'# exited.'
nl|'\n'
dedent|''
name|'ended'
op|'.'
name|'addCallback'
op|'('
name|'lambda'
name|'ignored'
op|':'
name|'reactor'
op|'.'
name|'stop'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'runReactor'
op|'('
name|'reactor'
op|')'
newline|'\n'
nl|'\n'
comment|'# Make sure the reactor stopped because the Deferred fired.'
nl|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'result'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'getattr'
op|'('
name|'signal'
op|','
string|"'SIGCHLD'"
op|','
name|'None'
op|')'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'test_spawnProcessEarlyIsReaped'
op|'.'
name|'skip'
op|'='
op|'('
nl|'\n'
string|'"Platform lacks SIGCHLD, early-spawnProcess test can\'t work."'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_processExitedWithSignal
dedent|''
name|'def'
name|'test_processExitedWithSignal'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The C{reason} argument passed to L{IProcessProtocol.processExited} is a\n        L{ProcessTerminated} instance if the child process exits with a signal.\n        """'
newline|'\n'
name|'sigName'
op|'='
string|"'TERM'"
newline|'\n'
name|'sigNum'
op|'='
name|'getattr'
op|'('
name|'signal'
op|','
string|"'SIG'"
op|'+'
name|'sigName'
op|')'
newline|'\n'
name|'exited'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'source'
op|'='
op|'('
nl|'\n'
string|'"import sys\\n"'
nl|'\n'
comment|'# Talk so the parent process knows the process is running.  This is'
nl|'\n'
comment|'# necessary because ProcessProtocol.makeConnection may be called'
nl|'\n'
comment|"# before this process is exec'd.  It would be unfortunate if we"
nl|'\n'
comment|"# SIGTERM'd the Twisted process while it was on its way to doing"
nl|'\n'
comment|'# the exec.'
nl|'\n'
string|'"sys.stdout.write(\'x\')\\n"'
nl|'\n'
string|'"sys.stdout.flush()\\n"'
nl|'\n'
string|'"sys.stdin.read()\\n"'
op|')'
newline|'\n'
nl|'\n'
DECL|class|Exiter
name|'class'
name|'Exiter'
op|'('
name|'ProcessProtocol'
op|')'
op|':'
newline|'\n'
DECL|member|childDataReceived
indent|'            '
name|'def'
name|'childDataReceived'
op|'('
name|'self'
op|','
name|'fd'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'('
string|"'childDataReceived(%d, %r)'"
op|'%'
op|'('
name|'fd'
op|','
name|'data'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'signalProcess'
op|'('
name|'sigName'
op|')'
newline|'\n'
nl|'\n'
DECL|member|childConnectionLost
dedent|''
name|'def'
name|'childConnectionLost'
op|'('
name|'self'
op|','
name|'fd'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'('
string|"'childConnectionLost(%d)'"
op|'%'
op|'('
name|'fd'
op|','
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|processExited
dedent|''
name|'def'
name|'processExited'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'('
string|"'processExited(%r)'"
op|'%'
op|'('
name|'reason'
op|','
op|')'
op|')'
newline|'\n'
comment|'# Protect the Deferred from the failure so that it follows'
nl|'\n'
comment|"# the callback chain.  This doesn't use the errback chain"
nl|'\n'
comment|'# because it wants to make sure reason is a Failure.  An'
nl|'\n'
comment|'# Exception would also make an errback-based test pass, and'
nl|'\n'
comment|'# that would be wrong.'
nl|'\n'
name|'exited'
op|'.'
name|'callback'
op|'('
op|'['
name|'reason'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|processEnded
dedent|''
name|'def'
name|'processEnded'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'('
string|"'processEnded(%r)'"
op|'%'
op|'('
name|'reason'
op|','
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'reactor'
op|'='
name|'self'
op|'.'
name|'buildReactor'
op|'('
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'callWhenRunning'
op|'('
nl|'\n'
name|'reactor'
op|'.'
name|'spawnProcess'
op|','
name|'Exiter'
op|'('
op|')'
op|','
name|'sys'
op|'.'
name|'executable'
op|','
nl|'\n'
op|'['
name|'sys'
op|'.'
name|'executable'
op|','
string|'"-c"'
op|','
name|'source'
op|']'
op|','
name|'usePTY'
op|'='
name|'self'
op|'.'
name|'usePTY'
op|')'
newline|'\n'
nl|'\n'
DECL|function|cbExited
name|'def'
name|'cbExited'
op|'('
op|'('
name|'failure'
op|','
op|')'
op|')'
op|':'
newline|'\n'
comment|"# Trapping implicitly verifies that it's a Failure (rather than"
nl|'\n'
comment|"# an exception) and explicitly makes sure it's the right type."
nl|'\n'
indent|'            '
name|'failure'
op|'.'
name|'trap'
op|'('
name|'ProcessTerminated'
op|')'
newline|'\n'
name|'err'
op|'='
name|'failure'
op|'.'
name|'value'
newline|'\n'
name|'if'
name|'platform'
op|'.'
name|'isWindows'
op|'('
op|')'
op|':'
newline|'\n'
comment|"# Windows can't really /have/ signals, so it certainly can't"
nl|'\n'
comment|"# report them as the reason for termination.  Maybe there's"
nl|'\n'
comment|'# something better we could be doing here, anyway?  Hard to'
nl|'\n'
comment|'# say.  Anyway, this inconsistency between different platforms'
nl|'\n'
comment|'# is extremely unfortunate and I would remove it if I'
nl|'\n'
comment|'# could. -exarkun'
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'err'
op|'.'
name|'signal'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'err'
op|'.'
name|'exitCode'
op|','
number|'1'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'err'
op|'.'
name|'signal'
op|','
name|'sigNum'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'err'
op|'.'
name|'exitCode'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'exited'
op|'.'
name|'addCallback'
op|'('
name|'cbExited'
op|')'
newline|'\n'
name|'exited'
op|'.'
name|'addErrback'
op|'('
name|'err'
op|')'
newline|'\n'
name|'exited'
op|'.'
name|'addCallback'
op|'('
name|'lambda'
name|'ign'
op|':'
name|'reactor'
op|'.'
name|'stop'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'runReactor'
op|'('
name|'reactor'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ProcessTestsBuilder
dedent|''
dedent|''
name|'class'
name|'ProcessTestsBuilder'
op|'('
name|'ProcessTestsBuilderBase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Builder defining tests relating to L{IReactorProcess} for child processes\n    which do not have a PTY.\n    """'
newline|'\n'
DECL|variable|usePTY
name|'usePTY'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|variable|keepStdioOpenProgram
name|'keepStdioOpenProgram'
op|'='
name|'FilePath'
op|'('
name|'__file__'
op|')'
op|'.'
name|'sibling'
op|'('
string|"'process_helper.py'"
op|')'
op|'.'
name|'path'
newline|'\n'
name|'if'
name|'platform'
op|'.'
name|'isWindows'
op|'('
op|')'
op|':'
newline|'\n'
DECL|variable|keepStdioOpenArg
indent|'        '
name|'keepStdioOpenArg'
op|'='
string|'"windows"'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Just a value that doesn\'t equal "windows"'
nl|'\n'
DECL|variable|keepStdioOpenArg
indent|'        '
name|'keepStdioOpenArg'
op|'='
string|'""'
newline|'\n'
nl|'\n'
comment|'# Define this test here because PTY-using processes only have stdin and'
nl|'\n'
comment|'# stdout and the test would need to be different for that to work.'
nl|'\n'
DECL|member|test_childConnectionLost
dedent|''
name|'def'
name|'test_childConnectionLost'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{IProcessProtocol.childConnectionLost} is called each time a file\n        descriptor associated with a child process is closed.\n        """'
newline|'\n'
name|'connected'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'lost'
op|'='
op|'{'
number|'0'
op|':'
name|'Deferred'
op|'('
op|')'
op|','
number|'1'
op|':'
name|'Deferred'
op|'('
op|')'
op|','
number|'2'
op|':'
name|'Deferred'
op|'('
op|')'
op|'}'
newline|'\n'
nl|'\n'
DECL|class|Closer
name|'class'
name|'Closer'
op|'('
name|'ProcessProtocol'
op|')'
op|':'
newline|'\n'
DECL|member|makeConnection
indent|'            '
name|'def'
name|'makeConnection'
op|'('
name|'self'
op|','
name|'transport'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'connected'
op|'.'
name|'callback'
op|'('
name|'transport'
op|')'
newline|'\n'
nl|'\n'
DECL|member|childConnectionLost
dedent|''
name|'def'
name|'childConnectionLost'
op|'('
name|'self'
op|','
name|'childFD'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'lost'
op|'['
name|'childFD'
op|']'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'source'
op|'='
op|'('
nl|'\n'
string|'"import os, sys\\n"'
nl|'\n'
string|'"while 1:\\n"'
nl|'\n'
string|'"    line = sys.stdin.readline().strip()\\n"'
nl|'\n'
string|'"    if not line:\\n"'
nl|'\n'
string|'"        break\\n"'
nl|'\n'
string|'"    os.close(int(line))\\n"'
op|')'
newline|'\n'
nl|'\n'
name|'reactor'
op|'='
name|'self'
op|'.'
name|'buildReactor'
op|'('
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'callWhenRunning'
op|'('
nl|'\n'
name|'reactor'
op|'.'
name|'spawnProcess'
op|','
name|'Closer'
op|'('
op|')'
op|','
name|'sys'
op|'.'
name|'executable'
op|','
nl|'\n'
op|'['
name|'sys'
op|'.'
name|'executable'
op|','
string|'"-c"'
op|','
name|'source'
op|']'
op|','
name|'usePTY'
op|'='
name|'self'
op|'.'
name|'usePTY'
op|')'
newline|'\n'
nl|'\n'
DECL|function|cbConnected
name|'def'
name|'cbConnected'
op|'('
name|'transport'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'transport'
op|'.'
name|'write'
op|'('
string|"'2\\n'"
op|')'
newline|'\n'
name|'return'
name|'lost'
op|'['
number|'2'
op|']'
op|'.'
name|'addCallback'
op|'('
name|'lambda'
name|'ign'
op|':'
name|'transport'
op|')'
newline|'\n'
dedent|''
name|'connected'
op|'.'
name|'addCallback'
op|'('
name|'cbConnected'
op|')'
newline|'\n'
nl|'\n'
DECL|function|lostSecond
name|'def'
name|'lostSecond'
op|'('
name|'transport'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'transport'
op|'.'
name|'write'
op|'('
string|"'1\\n'"
op|')'
newline|'\n'
name|'return'
name|'lost'
op|'['
number|'1'
op|']'
op|'.'
name|'addCallback'
op|'('
name|'lambda'
name|'ign'
op|':'
name|'transport'
op|')'
newline|'\n'
dedent|''
name|'connected'
op|'.'
name|'addCallback'
op|'('
name|'lostSecond'
op|')'
newline|'\n'
nl|'\n'
DECL|function|lostFirst
name|'def'
name|'lostFirst'
op|'('
name|'transport'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'transport'
op|'.'
name|'write'
op|'('
string|"'\\n'"
op|')'
newline|'\n'
dedent|''
name|'connected'
op|'.'
name|'addCallback'
op|'('
name|'lostFirst'
op|')'
newline|'\n'
name|'connected'
op|'.'
name|'addErrback'
op|'('
name|'err'
op|')'
newline|'\n'
nl|'\n'
DECL|function|cbEnded
name|'def'
name|'cbEnded'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'reactor'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
dedent|''
name|'connected'
op|'.'
name|'addCallback'
op|'('
name|'cbEnded'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'runReactor'
op|'('
name|'reactor'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# This test is here because PTYProcess never delivers childConnectionLost.'
nl|'\n'
DECL|member|test_processEnded
dedent|''
name|'def'
name|'test_processEnded'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{IProcessProtocol.processEnded} is called after the child process\n        exits and L{IProcessProtocol.childConnectionLost} is called for each of\n        its file descriptors.\n        """'
newline|'\n'
name|'ended'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'lost'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|class|Ender
name|'class'
name|'Ender'
op|'('
name|'ProcessProtocol'
op|')'
op|':'
newline|'\n'
DECL|member|childDataReceived
indent|'            '
name|'def'
name|'childDataReceived'
op|'('
name|'self'
op|','
name|'fd'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'('
string|"'childDataReceived(%d, %r)'"
op|'%'
op|'('
name|'fd'
op|','
name|'data'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|childConnectionLost
dedent|''
name|'def'
name|'childConnectionLost'
op|'('
name|'self'
op|','
name|'childFD'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'('
string|"'childConnectionLost(%d)'"
op|'%'
op|'('
name|'childFD'
op|','
op|')'
op|')'
newline|'\n'
name|'lost'
op|'.'
name|'append'
op|'('
name|'childFD'
op|')'
newline|'\n'
nl|'\n'
DECL|member|processExited
dedent|''
name|'def'
name|'processExited'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'('
string|"'processExited(%r)'"
op|'%'
op|'('
name|'reason'
op|','
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|processEnded
dedent|''
name|'def'
name|'processEnded'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'('
string|"'processEnded(%r)'"
op|'%'
op|'('
name|'reason'
op|','
op|')'
op|')'
newline|'\n'
name|'ended'
op|'.'
name|'callback'
op|'('
op|'['
name|'reason'
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'reactor'
op|'='
name|'self'
op|'.'
name|'buildReactor'
op|'('
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'callWhenRunning'
op|'('
nl|'\n'
name|'reactor'
op|'.'
name|'spawnProcess'
op|','
name|'Ender'
op|'('
op|')'
op|','
name|'sys'
op|'.'
name|'executable'
op|','
nl|'\n'
op|'['
name|'sys'
op|'.'
name|'executable'
op|','
name|'self'
op|'.'
name|'keepStdioOpenProgram'
op|','
string|'"child"'
op|','
nl|'\n'
name|'self'
op|'.'
name|'keepStdioOpenArg'
op|']'
op|','
nl|'\n'
DECL|variable|usePTY
name|'usePTY'
op|'='
name|'self'
op|'.'
name|'usePTY'
op|')'
newline|'\n'
nl|'\n'
DECL|function|cbEnded
name|'def'
name|'cbEnded'
op|'('
op|'('
name|'failure'
op|','
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'failure'
op|'.'
name|'trap'
op|'('
name|'ProcessDone'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'set'
op|'('
name|'lost'
op|')'
op|','
name|'set'
op|'('
op|'['
number|'0'
op|','
number|'1'
op|','
number|'2'
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'ended'
op|'.'
name|'addCallback'
op|'('
name|'cbEnded'
op|')'
newline|'\n'
nl|'\n'
name|'ended'
op|'.'
name|'addErrback'
op|'('
name|'err'
op|')'
newline|'\n'
name|'ended'
op|'.'
name|'addCallback'
op|'('
name|'lambda'
name|'ign'
op|':'
name|'reactor'
op|'.'
name|'stop'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'runReactor'
op|'('
name|'reactor'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# This test is here because PTYProcess.loseConnection does not actually'
nl|'\n'
comment|'# close the file descriptors to the child process.  This test needs to be'
nl|'\n'
comment|'# written fairly differently for PTYProcess.'
nl|'\n'
DECL|member|test_processExited
dedent|''
name|'def'
name|'test_processExited'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{IProcessProtocol.processExited} is called when the child process\n        exits, even if file descriptors associated with the child are still\n        open.\n        """'
newline|'\n'
name|'exited'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'allLost'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'lost'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|class|Waiter
name|'class'
name|'Waiter'
op|'('
name|'ProcessProtocol'
op|')'
op|':'
newline|'\n'
DECL|member|childDataReceived
indent|'            '
name|'def'
name|'childDataReceived'
op|'('
name|'self'
op|','
name|'fd'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'('
string|"'childDataReceived(%d, %r)'"
op|'%'
op|'('
name|'fd'
op|','
name|'data'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|childConnectionLost
dedent|''
name|'def'
name|'childConnectionLost'
op|'('
name|'self'
op|','
name|'childFD'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'('
string|"'childConnectionLost(%d)'"
op|'%'
op|'('
name|'childFD'
op|','
op|')'
op|')'
newline|'\n'
name|'lost'
op|'.'
name|'append'
op|'('
name|'childFD'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'lost'
op|')'
op|'=='
number|'3'
op|':'
newline|'\n'
indent|'                    '
name|'allLost'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
DECL|member|processExited
dedent|''
dedent|''
name|'def'
name|'processExited'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'('
string|"'processExited(%r)'"
op|'%'
op|'('
name|'reason'
op|','
op|')'
op|')'
newline|'\n'
comment|'# See test_processExitedWithSignal'
nl|'\n'
name|'exited'
op|'.'
name|'callback'
op|'('
op|'['
name|'reason'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'reactor'
op|'='
name|'self'
op|'.'
name|'buildReactor'
op|'('
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'callWhenRunning'
op|'('
nl|'\n'
name|'reactor'
op|'.'
name|'spawnProcess'
op|','
name|'Waiter'
op|'('
op|')'
op|','
name|'sys'
op|'.'
name|'executable'
op|','
nl|'\n'
op|'['
name|'sys'
op|'.'
name|'executable'
op|','
name|'self'
op|'.'
name|'keepStdioOpenProgram'
op|','
string|'"child"'
op|','
nl|'\n'
name|'self'
op|'.'
name|'keepStdioOpenArg'
op|']'
op|','
nl|'\n'
DECL|variable|usePTY
name|'usePTY'
op|'='
name|'self'
op|'.'
name|'usePTY'
op|')'
newline|'\n'
nl|'\n'
DECL|function|cbExited
name|'def'
name|'cbExited'
op|'('
op|'('
name|'failure'
op|','
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'failure'
op|'.'
name|'trap'
op|'('
name|'ProcessDone'
op|')'
newline|'\n'
name|'msg'
op|'('
string|"'cbExited; lost = %s'"
op|'%'
op|'('
name|'lost'
op|','
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'lost'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'return'
name|'allLost'
newline|'\n'
dedent|''
name|'exited'
op|'.'
name|'addCallback'
op|'('
name|'cbExited'
op|')'
newline|'\n'
nl|'\n'
DECL|function|cbAllLost
name|'def'
name|'cbAllLost'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'set'
op|'('
name|'lost'
op|')'
op|','
name|'set'
op|'('
op|'['
number|'0'
op|','
number|'1'
op|','
number|'2'
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'exited'
op|'.'
name|'addCallback'
op|'('
name|'cbAllLost'
op|')'
newline|'\n'
nl|'\n'
name|'exited'
op|'.'
name|'addErrback'
op|'('
name|'err'
op|')'
newline|'\n'
name|'exited'
op|'.'
name|'addCallback'
op|'('
name|'lambda'
name|'ign'
op|':'
name|'reactor'
op|'.'
name|'stop'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'runReactor'
op|'('
name|'reactor'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|makeSourceFile
dedent|''
name|'def'
name|'makeSourceFile'
op|'('
name|'self'
op|','
name|'sourceLines'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write the given list of lines to a text file and return the absolute\n        path to it.\n        """'
newline|'\n'
name|'script'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'scriptFile'
op|'='
name|'file'
op|'('
name|'script'
op|','
string|"'wt'"
op|')'
newline|'\n'
name|'scriptFile'
op|'.'
name|'write'
op|'('
name|'os'
op|'.'
name|'linesep'
op|'.'
name|'join'
op|'('
name|'sourceLines'
op|')'
op|'+'
name|'os'
op|'.'
name|'linesep'
op|')'
newline|'\n'
name|'scriptFile'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'abspath'
op|'('
name|'script'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_shebang
dedent|''
name|'def'
name|'test_shebang'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Spawning a process with an executable which is a script starting\n        with an interpreter definition line (#!) uses that interpreter to\n        evaluate the script.\n        """'
newline|'\n'
name|'SHEBANG_OUTPUT'
op|'='
string|"'this is the shebang output'"
newline|'\n'
nl|'\n'
name|'scriptFile'
op|'='
name|'self'
op|'.'
name|'makeSourceFile'
op|'('
op|'['
nl|'\n'
string|'"#!%s"'
op|'%'
op|'('
name|'sys'
op|'.'
name|'executable'
op|','
op|')'
op|','
nl|'\n'
string|'"import sys"'
op|','
nl|'\n'
string|'"sys.stdout.write(\'%s\')"'
op|'%'
op|'('
name|'SHEBANG_OUTPUT'
op|','
op|')'
op|','
nl|'\n'
string|'"sys.stdout.flush()"'
op|']'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'chmod'
op|'('
name|'scriptFile'
op|','
number|'0700'
op|')'
newline|'\n'
nl|'\n'
name|'reactor'
op|'='
name|'self'
op|'.'
name|'buildReactor'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|cbProcessExited
name|'def'
name|'cbProcessExited'
op|'('
op|'('
name|'out'
op|','
name|'err'
op|','
name|'code'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'('
string|'"cbProcessExited((%r, %r, %d))"'
op|'%'
op|'('
name|'out'
op|','
name|'err'
op|','
name|'code'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'out'
op|','
name|'SHEBANG_OUTPUT'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'err'
op|','
string|'""'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'code'
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
DECL|function|shutdown
dedent|''
name|'def'
name|'shutdown'
op|'('
name|'passthrough'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'reactor'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
name|'return'
name|'passthrough'
newline|'\n'
nl|'\n'
DECL|function|start
dedent|''
name|'def'
name|'start'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'='
name|'utils'
op|'.'
name|'getProcessOutputAndValue'
op|'('
name|'scriptFile'
op|','
name|'reactor'
op|'='
name|'reactor'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addBoth'
op|'('
name|'shutdown'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'cbProcessExited'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addErrback'
op|'('
name|'err'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'reactor'
op|'.'
name|'callWhenRunning'
op|'('
name|'start'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'runReactor'
op|'('
name|'reactor'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_processCommandLineArguments
dedent|''
name|'def'
name|'test_processCommandLineArguments'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Arguments given to spawnProcess are passed to the child process as\n        originally intended.\n        """'
newline|'\n'
name|'source'
op|'='
op|'('
nl|'\n'
comment|'# On Windows, stdout is not opened in binary mode by default,'
nl|'\n'
comment|'# so newline characters are munged on writing, interfering with'
nl|'\n'
comment|'# the tests.'
nl|'\n'
string|"'import sys, os\\n'"
nl|'\n'
string|"'try:\\n'"
nl|'\n'
string|"'  import msvcrt\\n'"
nl|'\n'
string|"'  msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)\\n'"
nl|'\n'
string|"'except ImportError:\\n'"
nl|'\n'
string|"'  pass\\n'"
nl|'\n'
string|"'for arg in sys.argv[1:]:\\n'"
nl|'\n'
string|"'  sys.stdout.write(arg + chr(0))\\n'"
nl|'\n'
string|"'  sys.stdout.flush()'"
op|')'
newline|'\n'
nl|'\n'
name|'args'
op|'='
op|'['
string|"'hello'"
op|','
string|'\'"\''
op|','
string|"' \\t|<>^&'"
op|','
string|'r\'"\\\\"hello\\\\"\''
op|','
string|'r\'"foo\\ bar baz\\""\''
op|']'
newline|'\n'
comment|'# Ensure that all non-NUL characters can be passed too.'
nl|'\n'
name|'args'
op|'.'
name|'append'
op|'('
string|"''"
op|'.'
name|'join'
op|'('
name|'map'
op|'('
name|'chr'
op|','
name|'xrange'
op|'('
number|'1'
op|','
number|'256'
op|')'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'reactor'
op|'='
name|'self'
op|'.'
name|'buildReactor'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|processFinished
name|'def'
name|'processFinished'
op|'('
name|'output'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'output'
op|'='
name|'output'
op|'.'
name|'split'
op|'('
string|"'\\0'"
op|')'
newline|'\n'
comment|'# Drop the trailing \\0.'
nl|'\n'
name|'output'
op|'.'
name|'pop'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'args'
op|','
name|'output'
op|')'
newline|'\n'
nl|'\n'
DECL|function|shutdown
dedent|''
name|'def'
name|'shutdown'
op|'('
name|'result'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'reactor'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
name|'return'
name|'result'
newline|'\n'
nl|'\n'
DECL|function|spawnChild
dedent|''
name|'def'
name|'spawnChild'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'='
name|'succeed'
op|'('
name|'None'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'lambda'
name|'dummy'
op|':'
name|'utils'
op|'.'
name|'getProcessOutput'
op|'('
nl|'\n'
name|'sys'
op|'.'
name|'executable'
op|','
op|'['
string|"'-c'"
op|','
name|'source'
op|']'
op|'+'
name|'args'
op|','
name|'reactor'
op|'='
name|'reactor'
op|')'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'processFinished'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addBoth'
op|'('
name|'shutdown'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'reactor'
op|'.'
name|'callWhenRunning'
op|'('
name|'spawnChild'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'runReactor'
op|'('
name|'reactor'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'globals'
op|'('
op|')'
op|'.'
name|'update'
op|'('
name|'ProcessTestsBuilder'
op|'.'
name|'makeTestCaseClasses'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|PTYProcessTestsBuilder
name|'class'
name|'PTYProcessTestsBuilder'
op|'('
name|'ProcessTestsBuilderBase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Builder defining tests relating to L{IReactorProcess} for child processes\n    which have a PTY.\n    """'
newline|'\n'
DECL|variable|usePTY
name|'usePTY'
op|'='
name|'True'
newline|'\n'
nl|'\n'
name|'if'
name|'platform'
op|'.'
name|'isWindows'
op|'('
op|')'
op|':'
newline|'\n'
DECL|variable|skip
indent|'        '
name|'skip'
op|'='
string|'"PTYs are not supported on Windows."'
newline|'\n'
dedent|''
name|'elif'
name|'platform'
op|'.'
name|'isMacOSX'
op|'('
op|')'
op|':'
newline|'\n'
DECL|variable|skippedReactors
indent|'        '
name|'skippedReactors'
op|'='
op|'{'
nl|'\n'
string|'"twisted.internet.pollreactor.PollReactor"'
op|':'
nl|'\n'
string|'"OS X\'s poll() does not support PTYs"'
op|'}'
newline|'\n'
dedent|''
dedent|''
name|'globals'
op|'('
op|')'
op|'.'
name|'update'
op|'('
name|'PTYProcessTestsBuilder'
op|'.'
name|'makeTestCaseClasses'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|PotentialZombieWarningTests
name|'class'
name|'PotentialZombieWarningTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{twisted.internet.error.PotentialZombieWarning}.\n    """'
newline|'\n'
DECL|member|test_deprecated
name|'def'
name|'test_deprecated'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Accessing L{PotentialZombieWarning} via the\n        I{PotentialZombieWarning} attribute of L{twisted.internet.error}\n        results in a deprecation warning being emitted.\n        """'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'error'
newline|'\n'
name|'error'
op|'.'
name|'PotentialZombieWarning'
newline|'\n'
nl|'\n'
name|'warnings'
op|'='
name|'self'
op|'.'
name|'flushWarnings'
op|'('
op|'['
name|'self'
op|'.'
name|'test_deprecated'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'warnings'
op|'['
number|'0'
op|']'
op|'['
string|"'category'"
op|']'
op|','
name|'DeprecationWarning'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'warnings'
op|'['
number|'0'
op|']'
op|'['
string|"'message'"
op|']'
op|','
nl|'\n'
string|'"twisted.internet.error.PotentialZombieWarning was deprecated in "'
nl|'\n'
string|'"Twisted 10.0.0: There is no longer any potential for zombie "'
nl|'\n'
string|'"process."'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'warnings'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
