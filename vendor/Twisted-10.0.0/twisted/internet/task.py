begin_unit
comment|'# -*- test-case-name: twisted.test.test_task,twisted.test.test_cooperator -*-'
nl|'\n'
comment|'# Copyright (c) 2001-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nScheduling utility methods and classes.\n\n@author: Jp Calderone\n"""'
newline|'\n'
nl|'\n'
DECL|variable|__metaclass__
name|'__metaclass__'
op|'='
name|'type'
newline|'\n'
nl|'\n'
name|'import'
name|'time'
newline|'\n'
nl|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'implements'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'reflect'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'failure'
name|'import'
name|'Failure'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'base'
op|','
name|'defer'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'interfaces'
name|'import'
name|'IReactorTime'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|LoopingCall
name|'class'
name|'LoopingCall'
op|':'
newline|'\n'
indent|'    '
string|'"""Call a function repeatedly.\n\n    If C{f} returns a deferred, rescheduling will not take place until the\n    deferred has fired. The result value is ignored.\n\n    @ivar f: The function to call.\n    @ivar a: A tuple of arguments to pass the function.\n    @ivar kw: A dictionary of keyword arguments to pass to the function.\n    @ivar clock: A provider of\n        L{twisted.internet.interfaces.IReactorTime}.  The default is\n        L{twisted.internet.reactor}. Feel free to set this to\n        something else, but it probably ought to be set *before*\n        calling L{start}.\n\n    @type _expectNextCallAt: C{float}\n    @ivar _expectNextCallAt: The time at which this instance most recently\n        scheduled itself to run.\n\n    @type _realLastTime: C{float}\n    @ivar _realLastTime: When counting skips, the time at which the skip counter\n        was last invoked.\n\n    @type _runAtStart: C{bool}\n    @ivar _runAtStart: A flag indicating whether the \'now\' argument was passed\n        to L{LoopingCall.start}.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|call
name|'call'
op|'='
name|'None'
newline|'\n'
DECL|variable|running
name|'running'
op|'='
name|'False'
newline|'\n'
DECL|variable|deferred
name|'deferred'
op|'='
name|'None'
newline|'\n'
DECL|variable|interval
name|'interval'
op|'='
name|'None'
newline|'\n'
DECL|variable|_expectNextCallAt
name|'_expectNextCallAt'
op|'='
number|'0.0'
newline|'\n'
DECL|variable|_runAtStart
name|'_runAtStart'
op|'='
name|'False'
newline|'\n'
DECL|variable|starttime
name|'starttime'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'f'
op|','
op|'*'
name|'a'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'f'
op|'='
name|'f'
newline|'\n'
name|'self'
op|'.'
name|'a'
op|'='
name|'a'
newline|'\n'
name|'self'
op|'.'
name|'kw'
op|'='
name|'kw'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'reactor'
newline|'\n'
name|'self'
op|'.'
name|'clock'
op|'='
name|'reactor'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|withCount
dedent|''
name|'def'
name|'withCount'
op|'('
name|'cls'
op|','
name|'countCallable'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        An alternate constructor for L{LoopingCall} that makes available the\n        number of calls which should have occurred since it was last invoked.\n\n        Note that this number is an C{int} value; It represents the discrete\n        number of calls that should have been made.  For example, if you are\n        using a looping call to display an animation with discrete frames, this\n        number would be the number of frames to advance.\n\n        The count is normally 1, but can be higher. For example, if the reactor\n        is blocked and takes too long to invoke the L{LoopingCall}, a Deferred\n        returned from a previous call is not fired before an interval has\n        elapsed, or if the callable itself blocks for longer than an interval,\n        preventing I{itself} from being called.\n\n        @param countCallable: A callable that will be invoked each time the\n            resulting LoopingCall is run, with an integer specifying the number\n            of calls that should have been invoked.\n\n        @type countCallable: 1-argument callable which takes an C{int}\n\n        @return: An instance of L{LoopingCall} with call counting enabled,\n            which provides the count as the first positional argument.\n\n        @rtype: L{LoopingCall}\n\n        @since: 9.0\n        """'
newline|'\n'
nl|'\n'
DECL|function|counter
name|'def'
name|'counter'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'now'
op|'='
name|'self'
op|'.'
name|'clock'
op|'.'
name|'seconds'
op|'('
op|')'
newline|'\n'
name|'lastTime'
op|'='
name|'self'
op|'.'
name|'_realLastTime'
newline|'\n'
name|'if'
name|'lastTime'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'lastTime'
op|'='
name|'self'
op|'.'
name|'starttime'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_runAtStart'
op|':'
newline|'\n'
indent|'                    '
name|'lastTime'
op|'-='
name|'self'
op|'.'
name|'interval'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_realLastTime'
op|'='
name|'now'
newline|'\n'
name|'lastInterval'
op|'='
name|'self'
op|'.'
name|'_intervalOf'
op|'('
name|'lastTime'
op|')'
newline|'\n'
name|'thisInterval'
op|'='
name|'self'
op|'.'
name|'_intervalOf'
op|'('
name|'now'
op|')'
newline|'\n'
name|'count'
op|'='
name|'thisInterval'
op|'-'
name|'lastInterval'
newline|'\n'
name|'return'
name|'countCallable'
op|'('
name|'count'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'='
name|'cls'
op|'('
name|'counter'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_realLastTime'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
newline|'\n'
nl|'\n'
DECL|variable|withCount
dedent|''
name|'withCount'
op|'='
name|'classmethod'
op|'('
name|'withCount'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_intervalOf
name|'def'
name|'_intervalOf'
op|'('
name|'self'
op|','
name|'t'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Determine the number of intervals passed as of the given point in\n        time.\n\n        @param t: The specified time (from the start of the L{LoopingCall}) to\n            be measured in intervals\n\n        @return: The C{int} number of intervals which have passed as of the\n            given point in time.\n        """'
newline|'\n'
name|'elapsedTime'
op|'='
name|'t'
op|'-'
name|'self'
op|'.'
name|'starttime'
newline|'\n'
name|'intervalNum'
op|'='
name|'int'
op|'('
name|'elapsedTime'
op|'/'
name|'self'
op|'.'
name|'interval'
op|')'
newline|'\n'
name|'return'
name|'intervalNum'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|start
dedent|''
name|'def'
name|'start'
op|'('
name|'self'
op|','
name|'interval'
op|','
name|'now'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Start running function every interval seconds.\n\n        @param interval: The number of seconds between calls.  May be\n        less than one.  Precision will depend on the underlying\n        platform, the available hardware, and the load on the system.\n\n        @param now: If True, run this call right now.  Otherwise, wait\n        until the interval has elapsed before beginning.\n\n        @return: A Deferred whose callback will be invoked with\n        C{self} when C{self.stop} is called, or whose errback will be\n        invoked when the function raises an exception or returned a\n        deferred that has its errback invoked.\n        """'
newline|'\n'
name|'assert'
name|'not'
name|'self'
op|'.'
name|'running'
op|','
op|'('
string|'"Tried to start an already running "'
nl|'\n'
string|'"LoopingCall."'
op|')'
newline|'\n'
name|'if'
name|'interval'
op|'<'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|','
string|'"interval must be >= 0"'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'running'
op|'='
name|'True'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'deferred'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'starttime'
op|'='
name|'self'
op|'.'
name|'clock'
op|'.'
name|'seconds'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_expectNextCallAt'
op|'='
name|'self'
op|'.'
name|'starttime'
newline|'\n'
name|'self'
op|'.'
name|'interval'
op|'='
name|'interval'
newline|'\n'
name|'self'
op|'.'
name|'_runAtStart'
op|'='
name|'now'
newline|'\n'
name|'if'
name|'now'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_reschedule'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'d'
newline|'\n'
nl|'\n'
DECL|member|stop
dedent|''
name|'def'
name|'stop'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Stop running function.\n        """'
newline|'\n'
name|'assert'
name|'self'
op|'.'
name|'running'
op|','
op|'('
string|'"Tried to stop a LoopingCall that was "'
nl|'\n'
string|'"not running."'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'running'
op|'='
name|'False'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'call'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'call'
op|'.'
name|'cancel'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'call'
op|'='
name|'None'
newline|'\n'
name|'d'
op|','
name|'self'
op|'.'
name|'deferred'
op|'='
name|'self'
op|'.'
name|'deferred'
op|','
name|'None'
newline|'\n'
name|'d'
op|'.'
name|'callback'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__call__
dedent|''
dedent|''
name|'def'
name|'__call__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
DECL|function|cb
indent|'        '
name|'def'
name|'cb'
op|'('
name|'result'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'running'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_reschedule'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'d'
op|','
name|'self'
op|'.'
name|'deferred'
op|'='
name|'self'
op|'.'
name|'deferred'
op|','
name|'None'
newline|'\n'
name|'d'
op|'.'
name|'callback'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
DECL|function|eb
dedent|''
dedent|''
name|'def'
name|'eb'
op|'('
name|'failure'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'running'
op|'='
name|'False'
newline|'\n'
name|'d'
op|','
name|'self'
op|'.'
name|'deferred'
op|'='
name|'self'
op|'.'
name|'deferred'
op|','
name|'None'
newline|'\n'
name|'d'
op|'.'
name|'errback'
op|'('
name|'failure'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'call'
op|'='
name|'None'
newline|'\n'
name|'d'
op|'='
name|'defer'
op|'.'
name|'maybeDeferred'
op|'('
name|'self'
op|'.'
name|'f'
op|','
op|'*'
name|'self'
op|'.'
name|'a'
op|','
op|'**'
name|'self'
op|'.'
name|'kw'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'cb'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addErrback'
op|'('
name|'eb'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_reschedule
dedent|''
name|'def'
name|'_reschedule'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Schedule the next iteration of this looping call.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'interval'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'call'
op|'='
name|'self'
op|'.'
name|'clock'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'self'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'currentTime'
op|'='
name|'self'
op|'.'
name|'clock'
op|'.'
name|'seconds'
op|'('
op|')'
newline|'\n'
comment|'# Find how long is left until the interval comes around again.'
nl|'\n'
name|'untilNextTime'
op|'='
op|'('
name|'self'
op|'.'
name|'_expectNextCallAt'
op|'-'
name|'currentTime'
op|')'
op|'%'
name|'self'
op|'.'
name|'interval'
newline|'\n'
comment|'# Make sure it is in the future, in case more than one interval worth'
nl|'\n'
comment|'# of time passed since the previous call was made.'
nl|'\n'
name|'nextTime'
op|'='
name|'max'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_expectNextCallAt'
op|'+'
name|'self'
op|'.'
name|'interval'
op|','
name|'currentTime'
op|'+'
name|'untilNextTime'
op|')'
newline|'\n'
comment|'# If the interval falls on the current time exactly, skip it and'
nl|'\n'
comment|'# schedule the call for the next interval.'
nl|'\n'
name|'if'
name|'nextTime'
op|'=='
name|'currentTime'
op|':'
newline|'\n'
indent|'            '
name|'nextTime'
op|'+='
name|'self'
op|'.'
name|'interval'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_expectNextCallAt'
op|'='
name|'nextTime'
newline|'\n'
name|'self'
op|'.'
name|'call'
op|'='
name|'self'
op|'.'
name|'clock'
op|'.'
name|'callLater'
op|'('
name|'nextTime'
op|'-'
name|'currentTime'
op|','
name|'self'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'hasattr'
op|'('
name|'self'
op|'.'
name|'f'
op|','
string|"'func_name'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'func'
op|'='
name|'self'
op|'.'
name|'f'
op|'.'
name|'func_name'
newline|'\n'
name|'if'
name|'hasattr'
op|'('
name|'self'
op|'.'
name|'f'
op|','
string|"'im_class'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'func'
op|'='
name|'self'
op|'.'
name|'f'
op|'.'
name|'im_class'
op|'.'
name|'__name__'
op|'+'
string|"'.'"
op|'+'
name|'func'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'func'
op|'='
name|'reflect'
op|'.'
name|'safe_repr'
op|'('
name|'self'
op|'.'
name|'f'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
string|"'LoopingCall<%r>(%s, *%s, **%s)'"
op|'%'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'interval'
op|','
name|'func'
op|','
name|'reflect'
op|'.'
name|'safe_repr'
op|'('
name|'self'
op|'.'
name|'a'
op|')'
op|','
nl|'\n'
name|'reflect'
op|'.'
name|'safe_repr'
op|'('
name|'self'
op|'.'
name|'kw'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|SchedulerError
dedent|''
dedent|''
name|'class'
name|'SchedulerError'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    The operation could not be completed because the scheduler or one of its\n    tasks was in an invalid state.  This exception should not be raised\n    directly, but is a superclass of various scheduler-state-related\n    exceptions.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|SchedulerStopped
dedent|''
name|'class'
name|'SchedulerStopped'
op|'('
name|'SchedulerError'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    The operation could not complete because the scheduler was stopped in\n    progress or was already stopped.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TaskFinished
dedent|''
name|'class'
name|'TaskFinished'
op|'('
name|'SchedulerError'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    The operation could not complete because the task was already completed,\n    stopped, encountered an error or otherwise permanently stopped running.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TaskDone
dedent|''
name|'class'
name|'TaskDone'
op|'('
name|'TaskFinished'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    The operation could not complete because the task was already completed.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TaskStopped
dedent|''
name|'class'
name|'TaskStopped'
op|'('
name|'TaskFinished'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    The operation could not complete because the task was stopped.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TaskFailed
dedent|''
name|'class'
name|'TaskFailed'
op|'('
name|'TaskFinished'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    The operation could not complete because the task died with an unhandled\n    error.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|NotPaused
dedent|''
name|'class'
name|'NotPaused'
op|'('
name|'SchedulerError'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    This exception is raised when a task is resumed which was not previously\n    paused.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|_Timer
dedent|''
name|'class'
name|'_Timer'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
DECL|variable|MAX_SLICE
indent|'    '
name|'MAX_SLICE'
op|'='
number|'0.01'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'end'
op|'='
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|'+'
name|'self'
op|'.'
name|'MAX_SLICE'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__call__
dedent|''
name|'def'
name|'__call__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|'>='
name|'self'
op|'.'
name|'end'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|variable|_EPSILON
dedent|''
dedent|''
name|'_EPSILON'
op|'='
number|'0.00000001'
newline|'\n'
DECL|function|_defaultScheduler
name|'def'
name|'_defaultScheduler'
op|'('
name|'x'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'reactor'
newline|'\n'
name|'return'
name|'reactor'
op|'.'
name|'callLater'
op|'('
name|'_EPSILON'
op|','
name|'x'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|CooperativeTask
dedent|''
name|'class'
name|'CooperativeTask'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A L{CooperativeTask} is a task object inside a L{Cooperator}, which can be\n    paused, resumed, and stopped.  It can also have its completion (or\n    termination) monitored.\n\n    @see: L{CooperativeTask.cooperate}\n\n    @ivar _iterator: the iterator to iterate when this L{CooperativeTask} is\n        asked to do work.\n\n    @ivar _cooperator: the L{Cooperator} that this L{CooperativeTask}\n        participates in, which is used to re-insert it upon resume.\n\n    @ivar _deferreds: the list of L{defer.Deferred}s to fire when this task\n        completes, fails, or finishes.\n\n    @type _deferreds: L{list}\n\n    @type _cooperator: L{Cooperator}\n\n    @ivar _pauseCount: the number of times that this L{CooperativeTask} has\n        been paused; if 0, it is running.\n\n    @type _pauseCount: L{int}\n\n    @ivar _completionState: The completion-state of this L{CooperativeTask}.\n        C{None} if the task is not yet completed, an instance of L{TaskStopped}\n        if C{stop} was called to stop this task early, of L{TaskFailed} if the\n        application code in the iterator raised an exception which caused it to\n        terminate, and of L{TaskDone} if it terminated normally via raising\n        L{StopIteration}.\n\n    @type _completionState: L{TaskFinished}\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'iterator'
op|','
name|'cooperator'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A private constructor: to create a new L{CooperativeTask}, see\n        L{Cooperator.cooperate}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_iterator'
op|'='
name|'iterator'
newline|'\n'
name|'self'
op|'.'
name|'_cooperator'
op|'='
name|'cooperator'
newline|'\n'
name|'self'
op|'.'
name|'_deferreds'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_pauseCount'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_completionState'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_completionResult'
op|'='
name|'None'
newline|'\n'
name|'cooperator'
op|'.'
name|'_addTask'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|whenDone
dedent|''
name|'def'
name|'whenDone'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Get a L{defer.Deferred} notification of when this task is complete.\n\n        @return: a L{defer.Deferred} that fires with the C{iterator} that this\n            L{CooperativeTask} was created with when the iterator has been\n            exhausted (i.e. its C{next} method has raised L{StopIteration}), or\n            fails with the exception raised by C{next} if it raises some other\n            exception.\n\n        @rtype: L{defer.Deferred}\n        """'
newline|'\n'
name|'d'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_completionState'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_deferreds'
op|'.'
name|'append'
op|'('
name|'d'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'.'
name|'callback'
op|'('
name|'self'
op|'.'
name|'_completionResult'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|pause
dedent|''
name|'def'
name|'pause'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Pause this L{CooperativeTask}.  Stop doing work until\n        L{CooperativeTask.resume} is called.  If C{pause} is called more than\n        once, C{resume} must be called an equal number of times to resume this\n        task.\n\n        @raise TaskFinished: if this task has already finished or completed.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_checkFinish'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_pauseCount'
op|'+='
number|'1'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_pauseCount'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_cooperator'
op|'.'
name|'_removeTask'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|resume
dedent|''
dedent|''
name|'def'
name|'resume'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Resume processing of a paused L{CooperativeTask}.\n\n        @raise NotPaused: if this L{CooperativeTask} is not paused.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_pauseCount'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'NotPaused'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_pauseCount'
op|'-='
number|'1'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_pauseCount'
op|'=='
number|'0'
name|'and'
name|'self'
op|'.'
name|'_completionState'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_cooperator'
op|'.'
name|'_addTask'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_completeWith
dedent|''
dedent|''
name|'def'
name|'_completeWith'
op|'('
name|'self'
op|','
name|'completionState'
op|','
name|'deferredResult'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @param completionState: a L{TaskFinished} exception or a subclass\n            thereof, indicating what exception should be raised when subsequent\n            operations are performed.\n\n        @param deferredResult: the result to fire all the deferreds with.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_completionState'
op|'='
name|'completionState'
newline|'\n'
name|'self'
op|'.'
name|'_completionResult'
op|'='
name|'deferredResult'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_pauseCount'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_cooperator'
op|'.'
name|'_removeTask'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
comment|'# The Deferreds need to be invoked after all this is completed, because'
nl|'\n'
comment|'# a Deferred may want to manipulate other tasks in a Cooperator.  For'
nl|'\n'
comment|'# example, if you call "stop()" on a cooperator in a callback on a'
nl|'\n'
comment|'# Deferred returned from whenDone(), this CooperativeTask must be gone'
nl|'\n'
comment|'# from the Cooperator by that point so that _completeWith is not'
nl|'\n'
comment|'# invoked reentrantly; that would cause these Deferreds to blow up with'
nl|'\n'
comment|'# an AlreadyCalledError, or the _removeTask to fail with a ValueError.'
nl|'\n'
dedent|''
name|'for'
name|'d'
name|'in'
name|'self'
op|'.'
name|'_deferreds'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'.'
name|'callback'
op|'('
name|'deferredResult'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|stop
dedent|''
dedent|''
name|'def'
name|'stop'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Stop further processing of this task.\n\n        @raise TaskFinished: if this L{CooperativeTask} has previously\n            completed, via C{stop}, completion, or failure.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_checkFinish'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_completeWith'
op|'('
name|'TaskStopped'
op|'('
op|')'
op|','
name|'Failure'
op|'('
name|'TaskStopped'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_checkFinish
dedent|''
name|'def'
name|'_checkFinish'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If this task has been stopped, raise the appropriate subclass of\n        L{TaskFinished}.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_completionState'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_completionState'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_oneWorkUnit
dedent|''
dedent|''
name|'def'
name|'_oneWorkUnit'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Perform one unit of work for this task, retrieving one item from its\n        iterator, stopping if there are no further items in the iterator, and\n        pausing if the result was a L{defer.Deferred}.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'='
name|'self'
op|'.'
name|'_iterator'
op|'.'
name|'next'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'StopIteration'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_completeWith'
op|'('
name|'TaskDone'
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'_iterator'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_completeWith'
op|'('
name|'TaskFailed'
op|'('
op|')'
op|','
name|'Failure'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'isinstance'
op|'('
name|'result'
op|','
name|'defer'
op|'.'
name|'Deferred'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'pause'
op|'('
op|')'
newline|'\n'
DECL|function|failLater
name|'def'
name|'failLater'
op|'('
name|'f'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_completeWith'
op|'('
name|'TaskFailed'
op|'('
op|')'
op|','
name|'f'
op|')'
newline|'\n'
dedent|''
name|'result'
op|'.'
name|'addCallbacks'
op|'('
name|'lambda'
name|'result'
op|':'
name|'self'
op|'.'
name|'resume'
op|'('
op|')'
op|','
nl|'\n'
name|'failLater'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|Cooperator
dedent|''
dedent|''
dedent|''
dedent|''
name|'class'
name|'Cooperator'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Cooperative task scheduler.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
nl|'\n'
name|'terminationPredicateFactory'
op|'='
name|'_Timer'
op|','
nl|'\n'
name|'scheduler'
op|'='
name|'_defaultScheduler'
op|','
nl|'\n'
name|'started'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a scheduler-like object to which iterators may be added.\n\n        @param terminationPredicateFactory: A no-argument callable which will\n        be invoked at the beginning of each step and should return a\n        no-argument callable which will return False when the step should be\n        terminated.  The default factory is time-based and allows iterators to\n        run for 1/100th of a second at a time.\n\n        @param scheduler: A one-argument callable which takes a no-argument\n        callable and should invoke it at some future point.  This will be used\n        to schedule each step of this Cooperator.\n\n        @param started: A boolean which indicates whether iterators should be\n        stepped as soon as they are added, or if they will be queued up until\n        L{Cooperator.start} is called.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_tasks'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_metarator'
op|'='
name|'iter'
op|'('
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_terminationPredicateFactory'
op|'='
name|'terminationPredicateFactory'
newline|'\n'
name|'self'
op|'.'
name|'_scheduler'
op|'='
name|'scheduler'
newline|'\n'
name|'self'
op|'.'
name|'_delayedCall'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_stopped'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_started'
op|'='
name|'started'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|coiterate
dedent|''
name|'def'
name|'coiterate'
op|'('
name|'self'
op|','
name|'iterator'
op|','
name|'doneDeferred'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Add an iterator to the list of iterators this L{Cooperator} is\n        currently running.\n\n        @param doneDeferred: If specified, this will be the Deferred used as\n            the completion deferred.  It is suggested that you use the default,\n            which creates a new Deferred for you.\n\n        @return: a Deferred that will fire when the iterator finishes.\n        """'
newline|'\n'
name|'if'
name|'doneDeferred'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'doneDeferred'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
dedent|''
name|'CooperativeTask'
op|'('
name|'iterator'
op|','
name|'self'
op|')'
op|'.'
name|'whenDone'
op|'('
op|')'
op|'.'
name|'chainDeferred'
op|'('
name|'doneDeferred'
op|')'
newline|'\n'
name|'return'
name|'doneDeferred'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|cooperate
dedent|''
name|'def'
name|'cooperate'
op|'('
name|'self'
op|','
name|'iterator'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Start running the given iterator as a long-running cooperative task, by\n        calling next() on it as a periodic timed event.\n\n        @param iterator: the iterator to invoke.\n\n        @return: a L{CooperativeTask} object representing this task.\n        """'
newline|'\n'
name|'return'
name|'CooperativeTask'
op|'('
name|'iterator'
op|','
name|'self'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_addTask
dedent|''
name|'def'
name|'_addTask'
op|'('
name|'self'
op|','
name|'task'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Add a L{CooperativeTask} object to this L{Cooperator}.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_stopped'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_tasks'
op|'.'
name|'append'
op|'('
name|'task'
op|')'
comment|'# XXX silly, I know, but _completeWith'
newline|'\n'
comment|'# does the inverse'
nl|'\n'
name|'task'
op|'.'
name|'_completeWith'
op|'('
name|'SchedulerStopped'
op|'('
op|')'
op|','
name|'Failure'
op|'('
name|'SchedulerStopped'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_tasks'
op|'.'
name|'append'
op|'('
name|'task'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_reschedule'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_removeTask
dedent|''
dedent|''
name|'def'
name|'_removeTask'
op|'('
name|'self'
op|','
name|'task'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Remove a L{CooperativeTask} from this L{Cooperator}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_tasks'
op|'.'
name|'remove'
op|'('
name|'task'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_tasksWhileNotStopped
dedent|''
name|'def'
name|'_tasksWhileNotStopped'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Yield all L{CooperativeTask} objects in a loop as long as this\n        L{Cooperator}\'s termination condition has not been met.\n        """'
newline|'\n'
name|'terminator'
op|'='
name|'self'
op|'.'
name|'_terminationPredicateFactory'
op|'('
op|')'
newline|'\n'
name|'while'
name|'self'
op|'.'
name|'_tasks'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'t'
name|'in'
name|'self'
op|'.'
name|'_metarator'
op|':'
newline|'\n'
indent|'                '
name|'yield'
name|'t'
newline|'\n'
name|'if'
name|'terminator'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'return'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_metarator'
op|'='
name|'iter'
op|'('
name|'self'
op|'.'
name|'_tasks'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_tick
dedent|''
dedent|''
name|'def'
name|'_tick'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Run one scheduler tick.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_delayedCall'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'taskObj'
name|'in'
name|'self'
op|'.'
name|'_tasksWhileNotStopped'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'taskObj'
op|'.'
name|'_oneWorkUnit'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_reschedule'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|_mustScheduleOnStart
dedent|''
name|'_mustScheduleOnStart'
op|'='
name|'False'
newline|'\n'
DECL|member|_reschedule
name|'def'
name|'_reschedule'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'self'
op|'.'
name|'_started'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_mustScheduleOnStart'
op|'='
name|'True'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_delayedCall'
name|'is'
name|'None'
name|'and'
name|'self'
op|'.'
name|'_tasks'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_delayedCall'
op|'='
name|'self'
op|'.'
name|'_scheduler'
op|'('
name|'self'
op|'.'
name|'_tick'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|start
dedent|''
dedent|''
name|'def'
name|'start'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Begin scheduling steps.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_stopped'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_started'
op|'='
name|'True'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_mustScheduleOnStart'
op|':'
newline|'\n'
indent|'            '
name|'del'
name|'self'
op|'.'
name|'_mustScheduleOnStart'
newline|'\n'
name|'self'
op|'.'
name|'_reschedule'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|stop
dedent|''
dedent|''
name|'def'
name|'stop'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Stop scheduling steps.  Errback the completion Deferreds of all\n        iterators which have been added and forget about them.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_stopped'
op|'='
name|'True'
newline|'\n'
name|'for'
name|'taskObj'
name|'in'
name|'self'
op|'.'
name|'_tasks'
op|':'
newline|'\n'
indent|'            '
name|'taskObj'
op|'.'
name|'_completeWith'
op|'('
name|'SchedulerStopped'
op|'('
op|')'
op|','
nl|'\n'
name|'Failure'
op|'('
name|'SchedulerStopped'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_tasks'
op|'='
op|'['
op|']'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_delayedCall'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_delayedCall'
op|'.'
name|'cancel'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_delayedCall'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|variable|_theCooperator
dedent|''
dedent|''
dedent|''
name|'_theCooperator'
op|'='
name|'Cooperator'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|coiterate
name|'def'
name|'coiterate'
op|'('
name|'iterator'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Cooperatively iterate over the given iterator, dividing runtime between it\n    and all other iterators which have been passed to this function and not yet\n    exhausted.\n    """'
newline|'\n'
name|'return'
name|'_theCooperator'
op|'.'
name|'coiterate'
op|'('
name|'iterator'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|cooperate
dedent|''
name|'def'
name|'cooperate'
op|'('
name|'iterator'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Start running the given iterator as a long-running cooperative task, by\n    calling next() on it as a periodic timed event.\n\n    @param iterator: the iterator to invoke.\n\n    @return: a L{CooperativeTask} object representing this task.\n    """'
newline|'\n'
name|'return'
name|'_theCooperator'
op|'.'
name|'cooperate'
op|'('
name|'iterator'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|Clock
dedent|''
name|'class'
name|'Clock'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Provide a deterministic, easily-controlled implementation of\n    L{IReactorTime.callLater}.  This is commonly useful for writing\n    deterministic unit tests for code which schedules events using this API.\n    """'
newline|'\n'
name|'implements'
op|'('
name|'IReactorTime'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|rightNow
name|'rightNow'
op|'='
number|'0.0'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'calls'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|seconds
dedent|''
name|'def'
name|'seconds'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Pretend to be time.time().  This is used internally when an operation\n        such as L{IDelayedCall.reset} needs to determine a a time value\n        relative to the current time.\n\n        @rtype: C{float}\n        @return: The time which should be considered the current time.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'rightNow'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|callLater
dedent|''
name|'def'
name|'callLater'
op|'('
name|'self'
op|','
name|'when'
op|','
name|'what'
op|','
op|'*'
name|'a'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        See L{twisted.internet.interfaces.IReactorTime.callLater}.\n        """'
newline|'\n'
name|'dc'
op|'='
name|'base'
op|'.'
name|'DelayedCall'
op|'('
name|'self'
op|'.'
name|'seconds'
op|'('
op|')'
op|'+'
name|'when'
op|','
nl|'\n'
name|'what'
op|','
name|'a'
op|','
name|'kw'
op|','
nl|'\n'
name|'self'
op|'.'
name|'calls'
op|'.'
name|'remove'
op|','
nl|'\n'
name|'lambda'
name|'c'
op|':'
name|'None'
op|','
nl|'\n'
name|'self'
op|'.'
name|'seconds'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'calls'
op|'.'
name|'append'
op|'('
name|'dc'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'calls'
op|'.'
name|'sort'
op|'('
name|'lambda'
name|'a'
op|','
name|'b'
op|':'
name|'cmp'
op|'('
name|'a'
op|'.'
name|'getTime'
op|'('
op|')'
op|','
name|'b'
op|'.'
name|'getTime'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
name|'return'
name|'dc'
newline|'\n'
nl|'\n'
DECL|member|getDelayedCalls
dedent|''
name|'def'
name|'getDelayedCalls'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        See L{twisted.internet.interfaces.IReactorTime.getDelayedCalls}\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'calls'
newline|'\n'
nl|'\n'
DECL|member|advance
dedent|''
name|'def'
name|'advance'
op|'('
name|'self'
op|','
name|'amount'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Move time on this clock forward by the given amount and run whatever\n        pending calls should be run.\n\n        @type amount: C{float}\n        @param amount: The number of seconds which to advance this clock\'s\n        time.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'rightNow'
op|'+='
name|'amount'
newline|'\n'
name|'while'
name|'self'
op|'.'
name|'calls'
name|'and'
name|'self'
op|'.'
name|'calls'
op|'['
number|'0'
op|']'
op|'.'
name|'getTime'
op|'('
op|')'
op|'<='
name|'self'
op|'.'
name|'seconds'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'call'
op|'='
name|'self'
op|'.'
name|'calls'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
newline|'\n'
name|'call'
op|'.'
name|'called'
op|'='
number|'1'
newline|'\n'
name|'call'
op|'.'
name|'func'
op|'('
op|'*'
name|'call'
op|'.'
name|'args'
op|','
op|'**'
name|'call'
op|'.'
name|'kw'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|pump
dedent|''
dedent|''
name|'def'
name|'pump'
op|'('
name|'self'
op|','
name|'timings'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Advance incrementally by the given set of times.\n\n        @type timings: iterable of C{float}\n        """'
newline|'\n'
name|'for'
name|'amount'
name|'in'
name|'timings'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'advance'
op|'('
name|'amount'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|deferLater
dedent|''
dedent|''
dedent|''
name|'def'
name|'deferLater'
op|'('
name|'clock'
op|','
name|'delay'
op|','
name|'callable'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Call the given function after a certain period of time has passed.\n\n    @type clock: L{IReactorTime} provider\n    @param clock: The object which will be used to schedule the delayed\n        call.\n\n    @type delay: C{float} or C{int}\n    @param delay: The number of seconds to wait before calling the function.\n\n    @param callable: The object to call after the delay.\n\n    @param *args: The positional arguments to pass to C{callable}.\n\n    @param **kw: The keyword arguments to pass to C{callable}.\n\n    @rtype: L{defer.Deferred}\n\n    @return: A deferred that fires with the result of the callable when the\n        specified time has elapsed.\n    """'
newline|'\n'
name|'d'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'lambda'
name|'ignored'
op|':'
name|'callable'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
op|')'
newline|'\n'
name|'clock'
op|'.'
name|'callLater'
op|'('
name|'delay'
op|','
name|'d'
op|'.'
name|'callback'
op|','
name|'None'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|variable|__all__
dedent|''
name|'__all__'
op|'='
op|'['
nl|'\n'
string|"'LoopingCall'"
op|','
nl|'\n'
nl|'\n'
string|"'Clock'"
op|','
nl|'\n'
nl|'\n'
string|"'SchedulerStopped'"
op|','
string|"'Cooperator'"
op|','
string|"'coiterate'"
op|','
nl|'\n'
nl|'\n'
string|"'deferLater'"
op|','
nl|'\n'
op|']'
newline|'\n'
endmarker|''
end_unit
