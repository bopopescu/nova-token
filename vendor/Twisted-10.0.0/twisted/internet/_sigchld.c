begin_unit
begin_comment
comment|/*  * Copyright (c) 2010 Twisted Matrix Laboratories.  * See LICENSE for details.  */
end_comment
begin_include
include|#
directive|include
file|<signal.h>
end_include
begin_include
include|#
directive|include
file|<errno.h>
end_include
begin_include
include|#
directive|include
file|"Python.h"
end_include
begin_decl_stmt
DECL|variable|sigchld_pipe_fd
specifier|static
name|int
name|sigchld_pipe_fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|got_signal
specifier|static
name|void
name|got_signal
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
name|int
name|ignored_result
decl_stmt|;
comment|/* write() errors are unhandled.  If the buffer is full, we don't      * care.  What about other errors? */
name|ignored_result
operator|=
name|write
argument_list|(
name|sigchld_pipe_fd
argument_list|,
literal|"x"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
block|}
end_function
begin_expr_stmt
name|PyDoc_STRVAR
argument_list|(
name|install_sigchld_handler_doc
argument_list|,
literal|"\ install_sigchld_handler(fd)\n\ \n\ Installs a SIGCHLD handler which will write a byte to the given fd\n\ whenever a SIGCHLD occurs. This is done in C code because the python\n\ signal handling system is not reliable, and additionally cannot\n\ specify SA_RESTART.\n\ \n\ Please ensure fd is in non-blocking mode.\n\ "
argument_list|)
expr_stmt|;
end_expr_stmt
begin_function
specifier|static
name|PyObject
modifier|*
DECL|function|install_sigchld_handler
name|install_sigchld_handler
parameter_list|(
name|PyObject
modifier|*
name|self
parameter_list|,
name|PyObject
modifier|*
name|args
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|old_fd
decl_stmt|;
name|struct
name|sigaction
name|sa
decl_stmt|;
if|if
condition|(
operator|!
name|PyArg_ParseTuple
argument_list|(
name|args
argument_list|,
literal|"i:install_sigchld_handler"
argument_list|,
operator|&
name|fd
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|old_fd
operator|=
name|sigchld_pipe_fd
expr_stmt|;
name|sigchld_pipe_fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|sa
operator|.
name|sa_handler
operator|=
name|SIG_DFL
expr_stmt|;
block|}
else|else
block|{
name|sa
operator|.
name|sa_handler
operator|=
name|got_signal
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
name|SA_RESTART
expr_stmt|;
comment|/* mask all signals so I don't worry about EINTR from the write. */
name|sigfillset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|sa
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sigchld_pipe_fd
operator|=
name|old_fd
expr_stmt|;
return|return
name|PyErr_SetFromErrno
argument_list|(
name|PyExc_OSError
argument_list|)
return|;
block|}
return|return
name|PyLong_FromLong
argument_list|(
name|old_fd
argument_list|)
return|;
block|}
end_function
begin_expr_stmt
name|PyDoc_STRVAR
argument_list|(
name|is_default_handler_doc
argument_list|,
literal|"\ Return 1 if the SIGCHLD handler is SIG_DFL, 0 otherwise.\n\ "
argument_list|)
expr_stmt|;
end_expr_stmt
begin_function
specifier|static
name|PyObject
modifier|*
DECL|function|is_default_handler
name|is_default_handler
parameter_list|(
name|PyObject
modifier|*
name|self
parameter_list|,
name|PyObject
modifier|*
name|args
parameter_list|)
block|{
comment|/*      * This implementation is necessary since the install_sigchld_handler      * function above bypasses the Python signal handler installation API, so      * CPython doesn't notice that the handler has changed and signal.getsignal      * won't return an accurate result.      */
name|struct
name|sigaction
name|sa
decl_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
name|NULL
argument_list|,
operator|&
name|sa
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|PyErr_SetFromErrno
argument_list|(
name|PyExc_OSError
argument_list|)
return|;
block|}
return|return
name|PyLong_FromLong
argument_list|(
name|sa
operator|.
name|sa_handler
operator|==
name|SIG_DFL
argument_list|)
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|sigchld_methods
specifier|static
name|PyMethodDef
name|sigchld_methods
index|[]
init|=
block|{
block|{
literal|"installHandler"
block|,
name|install_sigchld_handler
block|,
name|METH_VARARGS
block|,
name|install_sigchld_handler_doc
block|}
block|,
block|{
literal|"isDefaultHandler"
block|,
name|is_default_handler
block|,
name|METH_NOARGS
block|,
name|is_default_handler_doc
block|}
block|,
comment|/* sentinel */
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|_sigchld_doc
specifier|static
specifier|const
name|char
name|_sigchld_doc
index|[]
init|=
literal|"\n\ This module contains an API for receiving SIGCHLD via a file descriptor.\n\ "
decl_stmt|;
end_decl_stmt
begin_function
name|PyMODINIT_FUNC
DECL|function|init_sigchld
name|init_sigchld
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Create the module and add the functions */
name|Py_InitModule3
argument_list|(
literal|"twisted.internet._sigchld"
argument_list|,
name|sigchld_methods
argument_list|,
name|_sigchld_doc
argument_list|)
expr_stmt|;
block|}
end_function
end_unit
