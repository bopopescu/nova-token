begin_unit
comment|'# -*- test-case-name: twisted.test.test_abstract -*-'
nl|'\n'
comment|'# Copyright (c) 2001-2007 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
nl|'\n'
string|'"""\nSupport for generic select()able objects.\n\nMaintainer: Itamar Shtull-Trauring\n"""'
newline|'\n'
nl|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'implements'
newline|'\n'
nl|'\n'
comment|'# Twisted Imports'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'log'
op|','
name|'reflect'
op|','
name|'failure'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'persisted'
name|'import'
name|'styles'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'interfaces'
op|','
name|'main'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|FileDescriptor
name|'class'
name|'FileDescriptor'
op|'('
name|'log'
op|'.'
name|'Logger'
op|','
name|'styles'
op|'.'
name|'Ephemeral'
op|','
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""An object which can be operated on by select().\n\n    This is an abstract superclass of all objects which may be notified when\n    they are readable or writable; e.g. they have a file-descriptor that is\n    valid to be passed to select(2).\n    """'
newline|'\n'
DECL|variable|connected
name|'connected'
op|'='
number|'0'
newline|'\n'
DECL|variable|producerPaused
name|'producerPaused'
op|'='
number|'0'
newline|'\n'
DECL|variable|streamingProducer
name|'streamingProducer'
op|'='
number|'0'
newline|'\n'
DECL|variable|producer
name|'producer'
op|'='
name|'None'
newline|'\n'
DECL|variable|disconnected
name|'disconnected'
op|'='
number|'0'
newline|'\n'
DECL|variable|disconnecting
name|'disconnecting'
op|'='
number|'0'
newline|'\n'
DECL|variable|_writeDisconnecting
name|'_writeDisconnecting'
op|'='
name|'False'
newline|'\n'
DECL|variable|_writeDisconnected
name|'_writeDisconnected'
op|'='
name|'False'
newline|'\n'
DECL|variable|dataBuffer
name|'dataBuffer'
op|'='
string|'""'
newline|'\n'
DECL|variable|offset
name|'offset'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|variable|SEND_LIMIT
name|'SEND_LIMIT'
op|'='
number|'128'
op|'*'
number|'1024'
newline|'\n'
nl|'\n'
name|'implements'
op|'('
name|'interfaces'
op|'.'
name|'IProducer'
op|','
name|'interfaces'
op|'.'
name|'IReadWriteDescriptor'
op|','
nl|'\n'
name|'interfaces'
op|'.'
name|'IConsumer'
op|','
name|'interfaces'
op|'.'
name|'ITransport'
op|','
name|'interfaces'
op|'.'
name|'IHalfCloseableDescriptor'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'reactor'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'reactor'
op|':'
newline|'\n'
indent|'            '
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'reactor'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'reactor'
op|'='
name|'reactor'
newline|'\n'
name|'self'
op|'.'
name|'_tempDataBuffer'
op|'='
op|'['
op|']'
comment|'# will be added to dataBuffer in doWrite'
newline|'\n'
name|'self'
op|'.'
name|'_tempDataLen'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|member|connectionLost
dedent|''
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""The connection was lost.\n\n        This is called when the connection on a selectable object has been\n        lost.  It will be called whether the connection was closed explicitly,\n        an exception occurred in an event handler, or the other end of the\n        connection closed it first.\n\n        Clean up state here, but make sure to call back up to FileDescriptor.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'disconnected'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'connected'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'producer'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'producer'
op|'.'
name|'stopProducing'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'producer'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'stopReading'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'stopWriting'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|writeSomeData
dedent|''
name|'def'
name|'writeSomeData'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write as much as possible of the given data, immediately.\n\n        This is called to invoke the lower-level writing functionality, such\n        as a socket\'s send() method, or a file\'s write(); this method\n        returns an integer or an exception.  If an integer, it is the number\n        of bytes written (possibly zero); if an exception, it indicates the\n        connection was lost.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
string|'"%s does not implement writeSomeData"'
op|'%'
nl|'\n'
name|'reflect'
op|'.'
name|'qual'
op|'('
name|'self'
op|'.'
name|'__class__'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|doRead
dedent|''
name|'def'
name|'doRead'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Called when data is avaliable for reading.\n\n        Subclasses must override this method. The result will be interpreted\n        in the same way as a result of doWrite().\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
string|'"%s does not implement doRead"'
op|'%'
nl|'\n'
name|'reflect'
op|'.'
name|'qual'
op|'('
name|'self'
op|'.'
name|'__class__'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|doWrite
dedent|''
name|'def'
name|'doWrite'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when data can be written.\n\n        A result that is true (which will be a negative number or an\n        exception instance) indicates that the connection was lost. A false\n        result implies the connection is still there; a result of 0\n        indicates no write was done, and a result of None indicates that a\n        write was done.\n        """'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'self'
op|'.'
name|'dataBuffer'
op|')'
op|'-'
name|'self'
op|'.'
name|'offset'
op|'<'
name|'self'
op|'.'
name|'SEND_LIMIT'
op|':'
newline|'\n'
comment|'# If there is currently less than SEND_LIMIT bytes left to send'
nl|'\n'
comment|'# in the string, extend it with the array data.'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'dataBuffer'
op|'='
name|'buffer'
op|'('
name|'self'
op|'.'
name|'dataBuffer'
op|','
name|'self'
op|'.'
name|'offset'
op|')'
op|'+'
string|'""'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'_tempDataBuffer'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'offset'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_tempDataBuffer'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_tempDataLen'
op|'='
number|'0'
newline|'\n'
nl|'\n'
comment|'# Send as much data as you can.'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'offset'
op|':'
newline|'\n'
indent|'            '
name|'l'
op|'='
name|'self'
op|'.'
name|'writeSomeData'
op|'('
name|'buffer'
op|'('
name|'self'
op|'.'
name|'dataBuffer'
op|','
name|'self'
op|'.'
name|'offset'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'l'
op|'='
name|'self'
op|'.'
name|'writeSomeData'
op|'('
name|'self'
op|'.'
name|'dataBuffer'
op|')'
newline|'\n'
nl|'\n'
comment|'# There is no writeSomeData implementation in Twisted which returns'
nl|'\n'
comment|'# 0, but the documentation for writeSomeData used to claim negative'
nl|'\n'
comment|'# integers meant connection lost.  Keep supporting this here,'
nl|'\n'
comment|'# although it may be worth deprecating and removing at some point.'
nl|'\n'
dedent|''
name|'if'
name|'l'
op|'<'
number|'0'
name|'or'
name|'isinstance'
op|'('
name|'l'
op|','
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'l'
newline|'\n'
dedent|''
name|'if'
name|'l'
op|'=='
number|'0'
name|'and'
name|'self'
op|'.'
name|'dataBuffer'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'='
number|'0'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'offset'
op|'+='
name|'l'
newline|'\n'
comment|'# If there is nothing left to send,'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'offset'
op|'=='
name|'len'
op|'('
name|'self'
op|'.'
name|'dataBuffer'
op|')'
name|'and'
name|'not'
name|'self'
op|'.'
name|'_tempDataLen'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'dataBuffer'
op|'='
string|'""'
newline|'\n'
name|'self'
op|'.'
name|'offset'
op|'='
number|'0'
newline|'\n'
comment|'# stop writing.'
nl|'\n'
name|'self'
op|'.'
name|'stopWriting'
op|'('
op|')'
newline|'\n'
comment|"# If I've got a producer who is supposed to supply me with data,"
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'producer'
name|'is'
name|'not'
name|'None'
name|'and'
op|'('
op|'('
name|'not'
name|'self'
op|'.'
name|'streamingProducer'
op|')'
nl|'\n'
name|'or'
name|'self'
op|'.'
name|'producerPaused'
op|')'
op|':'
newline|'\n'
comment|'# tell them to supply some more.'
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'producerPaused'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'producer'
op|'.'
name|'resumeProducing'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'disconnecting'
op|':'
newline|'\n'
comment|'# But if I was previously asked to let the connection die, do'
nl|'\n'
comment|'# so.'
nl|'\n'
indent|'                '
name|'return'
name|'self'
op|'.'
name|'_postLoseConnection'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_writeDisconnecting'
op|':'
newline|'\n'
comment|'# I was previously asked to to half-close the connection.'
nl|'\n'
indent|'                '
name|'result'
op|'='
name|'self'
op|'.'
name|'_closeWriteConnection'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_writeDisconnected'
op|'='
name|'True'
newline|'\n'
name|'return'
name|'result'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
DECL|member|_postLoseConnection
dedent|''
name|'def'
name|'_postLoseConnection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Called after a loseConnection(), when all data has been written.\n\n        Whatever this returns is then returned by doWrite.\n        """'
newline|'\n'
comment|"# default implementation, telling reactor we're finished"
nl|'\n'
name|'return'
name|'main'
op|'.'
name|'CONNECTION_DONE'
newline|'\n'
nl|'\n'
DECL|member|_closeWriteConnection
dedent|''
name|'def'
name|'_closeWriteConnection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# override in subclasses'
nl|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|writeConnectionLost
dedent|''
name|'def'
name|'writeConnectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
comment|'# in current code should never be called'
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'connectionLost'
op|'('
name|'reason'
op|')'
newline|'\n'
nl|'\n'
DECL|member|readConnectionLost
dedent|''
name|'def'
name|'readConnectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
comment|'# override in subclasses'
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'connectionLost'
op|'('
name|'reason'
op|')'
newline|'\n'
nl|'\n'
DECL|member|write
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Reliably write some data.\n\n        The data is buffered until the underlying file descriptor is ready\n        for writing. If there is more than C{self.bufferSize} data in the\n        buffer and this descriptor has a registered streaming producer, its\n        C{pauseProducing()} method will be called.\n        """'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'data'
op|','
name|'unicode'
op|')'
op|':'
comment|'# no, really, I mean it'
newline|'\n'
indent|'            '
name|'raise'
name|'TypeError'
op|'('
string|'"Data must not be unicode"'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'connected'
name|'or'
name|'self'
op|'.'
name|'_writeDisconnected'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'if'
name|'data'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_tempDataBuffer'
op|'.'
name|'append'
op|'('
name|'data'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_tempDataLen'
op|'+='
name|'len'
op|'('
name|'data'
op|')'
newline|'\n'
comment|'# If we are responsible for pausing our producer,'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'producer'
name|'is'
name|'not'
name|'None'
name|'and'
name|'self'
op|'.'
name|'streamingProducer'
op|':'
newline|'\n'
comment|'# and our buffer is full,'
nl|'\n'
indent|'                '
name|'if'
name|'len'
op|'('
name|'self'
op|'.'
name|'dataBuffer'
op|')'
op|'+'
name|'self'
op|'.'
name|'_tempDataLen'
op|'>'
name|'self'
op|'.'
name|'bufferSize'
op|':'
newline|'\n'
comment|'# pause it.'
nl|'\n'
indent|'                    '
name|'self'
op|'.'
name|'producerPaused'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'producer'
op|'.'
name|'pauseProducing'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'startWriting'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|writeSequence
dedent|''
dedent|''
name|'def'
name|'writeSequence'
op|'('
name|'self'
op|','
name|'iovec'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Reliably write a sequence of data.\n\n        Currently, this is a convenience method roughly equivalent to::\n\n            for chunk in iovec:\n                fd.write(chunk)\n\n        It may have a more efficient implementation at a later time or in a\n        different reactor.\n\n        As with the C{write()} method, if a buffer size limit is reached and a\n        streaming producer is registered, it will be paused until the buffered\n        data is written to the underlying file descriptor.\n        """'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'connected'
name|'or'
name|'not'
name|'iovec'
name|'or'
name|'self'
op|'.'
name|'_writeDisconnected'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_tempDataBuffer'
op|'.'
name|'extend'
op|'('
name|'iovec'
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'iovec'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_tempDataLen'
op|'+='
name|'len'
op|'('
name|'i'
op|')'
newline|'\n'
comment|'# If we are responsible for pausing our producer,'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'producer'
name|'is'
name|'not'
name|'None'
name|'and'
name|'self'
op|'.'
name|'streamingProducer'
op|':'
newline|'\n'
comment|'# and our buffer is full,'
nl|'\n'
indent|'            '
name|'if'
name|'len'
op|'('
name|'self'
op|'.'
name|'dataBuffer'
op|')'
op|'+'
name|'self'
op|'.'
name|'_tempDataLen'
op|'>'
name|'self'
op|'.'
name|'bufferSize'
op|':'
newline|'\n'
comment|'# pause it.'
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'producerPaused'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'producer'
op|'.'
name|'pauseProducing'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'startWriting'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|loseConnection
dedent|''
name|'def'
name|'loseConnection'
op|'('
name|'self'
op|','
name|'_connDone'
op|'='
name|'failure'
op|'.'
name|'Failure'
op|'('
name|'main'
op|'.'
name|'CONNECTION_DONE'
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Close the connection at the next available opportunity.\n\n        Call this to cause this FileDescriptor to lose its connection.  It will\n        first write any data that it has buffered.\n\n        If there is data buffered yet to be written, this method will cause the\n        transport to lose its connection as soon as it\'s done flushing its\n        write buffer.  If you have a producer registered, the connection won\'t\n        be closed until the producer is finished. Therefore, make sure you\n        unregister your producer when it\'s finished, or the connection will\n        never close.\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'connected'
name|'and'
name|'not'
name|'self'
op|'.'
name|'disconnecting'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'_writeDisconnected'
op|':'
newline|'\n'
comment|"# doWrite won't trigger the connection close anymore"
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'stopReading'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'stopWriting'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'connectionLost'
op|'('
name|'_connDone'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'stopReading'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'startWriting'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'disconnecting'
op|'='
number|'1'
newline|'\n'
nl|'\n'
DECL|member|loseWriteConnection
dedent|''
dedent|''
dedent|''
name|'def'
name|'loseWriteConnection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_writeDisconnecting'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'startWriting'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|stopReading
dedent|''
name|'def'
name|'stopReading'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Stop waiting for read availability.\n\n        Call this to remove this selectable from being notified when it is\n        ready for reading.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'reactor'
op|'.'
name|'removeReader'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
DECL|member|stopWriting
dedent|''
name|'def'
name|'stopWriting'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Stop waiting for write availability.\n\n        Call this to remove this selectable from being notified when it is ready\n        for writing.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'reactor'
op|'.'
name|'removeWriter'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
DECL|member|startReading
dedent|''
name|'def'
name|'startReading'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Start waiting for read availability.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'reactor'
op|'.'
name|'addReader'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
DECL|member|startWriting
dedent|''
name|'def'
name|'startWriting'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Start waiting for write availability.\n\n        Call this to have this FileDescriptor be notified whenever it is ready for\n        writing.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'reactor'
op|'.'
name|'addWriter'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
comment|'# Producer/consumer implementation'
nl|'\n'
nl|'\n'
comment|'# first, the consumer stuff.  This requires no additional work, as'
nl|'\n'
comment|'# any object you can write to can be a consumer, really.'
nl|'\n'
nl|'\n'
DECL|variable|producer
dedent|''
name|'producer'
op|'='
name|'None'
newline|'\n'
DECL|variable|bufferSize
name|'bufferSize'
op|'='
number|'2'
op|'**'
number|'2'
op|'**'
number|'2'
op|'**'
number|'2'
newline|'\n'
nl|'\n'
DECL|member|registerProducer
name|'def'
name|'registerProducer'
op|'('
name|'self'
op|','
name|'producer'
op|','
name|'streaming'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Register to receive data from a producer.\n\n        This sets this selectable to be a consumer for a producer.  When this\n        selectable runs out of data on a write() call, it will ask the producer\n        to resumeProducing(). When the FileDescriptor\'s internal data buffer is\n        filled, it will ask the producer to pauseProducing(). If the connection\n        is lost, FileDescriptor calls producer\'s stopProducing() method.\n\n        If streaming is true, the producer should provide the IPushProducer\n        interface. Otherwise, it is assumed that producer provides the\n        IPullProducer interface. In this case, the producer won\'t be asked\n        to pauseProducing(), but it has to be careful to write() data only\n        when its resumeProducing() method is called.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'producer'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'RuntimeError'
op|'('
string|'"Cannot register producer %s, because producer %s was never unregistered."'
op|'%'
op|'('
name|'producer'
op|','
name|'self'
op|'.'
name|'producer'
op|')'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'disconnected'
op|':'
newline|'\n'
indent|'            '
name|'producer'
op|'.'
name|'stopProducing'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'producer'
op|'='
name|'producer'
newline|'\n'
name|'self'
op|'.'
name|'streamingProducer'
op|'='
name|'streaming'
newline|'\n'
name|'if'
name|'not'
name|'streaming'
op|':'
newline|'\n'
indent|'                '
name|'producer'
op|'.'
name|'resumeProducing'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|unregisterProducer
dedent|''
dedent|''
dedent|''
name|'def'
name|'unregisterProducer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Stop consuming data from a producer, without disconnecting.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'producer'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|stopConsuming
dedent|''
name|'def'
name|'stopConsuming'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Stop consuming data.\n\n        This is called when a producer has lost its connection, to tell the\n        consumer to go lose its connection (and break potential circular\n        references).\n        """'
newline|'\n'
name|'self'
op|'.'
name|'unregisterProducer'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# producer interface implementation'
nl|'\n'
nl|'\n'
DECL|member|resumeProducing
dedent|''
name|'def'
name|'resumeProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'assert'
name|'self'
op|'.'
name|'connected'
name|'and'
name|'not'
name|'self'
op|'.'
name|'disconnecting'
newline|'\n'
name|'self'
op|'.'
name|'startReading'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|pauseProducing
dedent|''
name|'def'
name|'pauseProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'stopReading'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|stopProducing
dedent|''
name|'def'
name|'stopProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|fileno
dedent|''
name|'def'
name|'fileno'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""File Descriptor number for select().\n\n        This method must be overridden or assigned in subclasses to\n        indicate a valid file descriptor for the operating system.\n        """'
newline|'\n'
name|'return'
op|'-'
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|isIPAddress
dedent|''
dedent|''
name|'def'
name|'isIPAddress'
op|'('
name|'addr'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Determine whether the given string represents an IPv4 address.\n\n    @type addr: C{str}\n    @param addr: A string which may or may not be the decimal dotted\n    representation of an IPv4 address.\n\n    @rtype: C{bool}\n    @return: C{True} if C{addr} represents an IPv4 address, C{False}\n    otherwise.\n    """'
newline|'\n'
name|'dottedParts'
op|'='
name|'addr'
op|'.'
name|'split'
op|'('
string|"'.'"
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'dottedParts'
op|')'
op|'=='
number|'4'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'octet'
name|'in'
name|'dottedParts'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'value'
op|'='
name|'int'
op|'('
name|'octet'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'value'
op|'<'
number|'0'
name|'or'
name|'value'
op|'>'
number|'255'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'False'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|__all__
dedent|''
name|'__all__'
op|'='
op|'['
string|'"FileDescriptor"'
op|']'
newline|'\n'
endmarker|''
end_unit
