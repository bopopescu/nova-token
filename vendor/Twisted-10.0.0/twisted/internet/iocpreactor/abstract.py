begin_unit
comment|'# Copyright (c) 2008 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
nl|'\n'
string|'"""\nAbstract file handle class\n"""'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'main'
op|','
name|'error'
op|','
name|'interfaces'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'log'
op|','
name|'failure'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'persisted'
name|'import'
name|'styles'
newline|'\n'
nl|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'implements'
newline|'\n'
name|'import'
name|'errno'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'iocpreactor'
op|'.'
name|'const'
name|'import'
name|'ERROR_HANDLE_EOF'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'iocpreactor'
op|'.'
name|'const'
name|'import'
name|'ERROR_IO_PENDING'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'iocpreactor'
name|'import'
name|'iocpsupport'
name|'as'
name|'_iocp'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|FileHandle
name|'class'
name|'FileHandle'
op|'('
name|'log'
op|'.'
name|'Logger'
op|','
name|'styles'
op|'.'
name|'Ephemeral'
op|','
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    File handle that can read and write asynchronously\n    """'
newline|'\n'
name|'implements'
op|'('
name|'interfaces'
op|'.'
name|'IProducer'
op|','
name|'interfaces'
op|'.'
name|'IConsumer'
op|','
nl|'\n'
name|'interfaces'
op|'.'
name|'ITransport'
op|','
name|'interfaces'
op|'.'
name|'IHalfCloseableDescriptor'
op|')'
newline|'\n'
comment|'# read stuff'
nl|'\n'
DECL|variable|maxReadBuffers
name|'maxReadBuffers'
op|'='
number|'16'
newline|'\n'
DECL|variable|readBufferSize
name|'readBufferSize'
op|'='
number|'4096'
newline|'\n'
DECL|variable|reading
name|'reading'
op|'='
name|'False'
newline|'\n'
DECL|variable|dynamicReadBuffers
name|'dynamicReadBuffers'
op|'='
name|'True'
comment|"# set this to false if subclass doesn't do iovecs"
newline|'\n'
DECL|variable|_readNextBuffer
name|'_readNextBuffer'
op|'='
number|'0'
newline|'\n'
DECL|variable|_readSize
name|'_readSize'
op|'='
number|'0'
comment|'# how much data we have in the read buffer'
newline|'\n'
DECL|variable|_readScheduled
name|'_readScheduled'
op|'='
name|'None'
newline|'\n'
DECL|variable|_readScheduledInOS
name|'_readScheduledInOS'
op|'='
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|startReading
name|'def'
name|'startReading'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'reactor'
op|'.'
name|'addActiveHandle'
op|'('
name|'self'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_readScheduled'
name|'and'
name|'not'
name|'self'
op|'.'
name|'reading'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'reading'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'_readScheduled'
op|'='
name|'self'
op|'.'
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_resumeReading'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|stopReading
dedent|''
dedent|''
name|'def'
name|'stopReading'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_readScheduled'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_readScheduled'
op|'.'
name|'cancel'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_readScheduled'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'reading'
op|'='
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_resumeReading
dedent|''
name|'def'
name|'_resumeReading'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_readScheduled'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_dispatchData'
op|'('
op|')'
name|'and'
name|'not'
name|'self'
op|'.'
name|'_readScheduledInOS'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'doRead'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_dispatchData
dedent|''
dedent|''
name|'def'
name|'_dispatchData'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Dispatch previously read data. Return True if self.reading and we don\'t\n        have any more data\n        """'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_readSize'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'reading'
newline|'\n'
dedent|''
name|'size'
op|'='
name|'self'
op|'.'
name|'_readSize'
newline|'\n'
name|'full_buffers'
op|'='
name|'size'
op|'//'
name|'self'
op|'.'
name|'readBufferSize'
newline|'\n'
name|'while'
name|'self'
op|'.'
name|'_readNextBuffer'
op|'<'
name|'full_buffers'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'dataReceived'
op|'('
name|'self'
op|'.'
name|'_readBuffers'
op|'['
name|'self'
op|'.'
name|'_readNextBuffer'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_readNextBuffer'
op|'+='
number|'1'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'reading'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'False'
newline|'\n'
dedent|''
dedent|''
name|'remainder'
op|'='
name|'size'
op|'%'
name|'self'
op|'.'
name|'readBufferSize'
newline|'\n'
name|'if'
name|'remainder'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'dataReceived'
op|'('
name|'buffer'
op|'('
name|'self'
op|'.'
name|'_readBuffers'
op|'['
name|'full_buffers'
op|']'
op|','
nl|'\n'
number|'0'
op|','
name|'remainder'
op|')'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'dynamicReadBuffers'
op|':'
newline|'\n'
indent|'            '
name|'total_buffer_size'
op|'='
name|'self'
op|'.'
name|'readBufferSize'
op|'*'
name|'len'
op|'('
name|'self'
op|'.'
name|'_readBuffers'
op|')'
newline|'\n'
comment|'# we have one buffer too many'
nl|'\n'
name|'if'
name|'size'
op|'<'
name|'total_buffer_size'
op|'-'
name|'self'
op|'.'
name|'readBufferSize'
op|':'
newline|'\n'
indent|'                '
name|'del'
name|'self'
op|'.'
name|'_readBuffers'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
comment|'# we filled all buffers, so allocate one more'
nl|'\n'
dedent|''
name|'elif'
op|'('
name|'size'
op|'=='
name|'total_buffer_size'
name|'and'
nl|'\n'
name|'len'
op|'('
name|'self'
op|'.'
name|'_readBuffers'
op|')'
op|'<'
name|'self'
op|'.'
name|'maxReadBuffers'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_readBuffers'
op|'.'
name|'append'
op|'('
name|'_iocp'
op|'.'
name|'AllocateReadBuffer'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'readBufferSize'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_readNextBuffer'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_readSize'
op|'='
number|'0'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'reading'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_cbRead
dedent|''
name|'def'
name|'_cbRead'
op|'('
name|'self'
op|','
name|'rc'
op|','
name|'bytes'
op|','
name|'evt'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_readScheduledInOS'
op|'='
name|'False'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_handleRead'
op|'('
name|'rc'
op|','
name|'bytes'
op|','
name|'evt'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'doRead'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_handleRead
dedent|''
dedent|''
name|'def'
name|'_handleRead'
op|'('
name|'self'
op|','
name|'rc'
op|','
name|'bytes'
op|','
name|'evt'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns False if we should stop reading for now\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'disconnected'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
comment|'# graceful disconnection'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'not'
op|'('
name|'rc'
name|'or'
name|'bytes'
op|')'
op|')'
name|'or'
name|'rc'
name|'in'
op|'('
name|'errno'
op|'.'
name|'WSAEDISCON'
op|','
name|'ERROR_HANDLE_EOF'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'reactor'
op|'.'
name|'removeActiveHandle'
op|'('
name|'self'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'readConnectionLost'
op|'('
name|'failure'
op|'.'
name|'Failure'
op|'('
name|'main'
op|'.'
name|'CONNECTION_DONE'
op|')'
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
comment|'# XXX: not handling WSAEWOULDBLOCK'
nl|'\n'
comment|'# ("too many outstanding overlapped I/O requests")'
nl|'\n'
dedent|''
name|'elif'
name|'rc'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'connectionLost'
op|'('
name|'failure'
op|'.'
name|'Failure'
op|'('
nl|'\n'
name|'error'
op|'.'
name|'ConnectionLost'
op|'('
string|'"read error -- %s (%s)"'
op|'%'
nl|'\n'
op|'('
name|'errno'
op|'.'
name|'errorcode'
op|'.'
name|'get'
op|'('
name|'rc'
op|','
string|"'unknown'"
op|')'
op|','
name|'rc'
op|')'
op|')'
op|')'
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'assert'
name|'self'
op|'.'
name|'_readSize'
op|'=='
number|'0'
newline|'\n'
name|'assert'
name|'self'
op|'.'
name|'_readNextBuffer'
op|'=='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_readSize'
op|'='
name|'bytes'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_dispatchData'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|doRead
dedent|''
dedent|''
name|'def'
name|'doRead'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'numReads'
op|'='
number|'0'
newline|'\n'
name|'while'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'evt'
op|'='
name|'_iocp'
op|'.'
name|'Event'
op|'('
name|'self'
op|'.'
name|'_cbRead'
op|','
name|'self'
op|')'
newline|'\n'
nl|'\n'
name|'evt'
op|'.'
name|'buff'
op|'='
name|'buff'
op|'='
name|'self'
op|'.'
name|'_readBuffers'
newline|'\n'
name|'rc'
op|','
name|'bytes'
op|'='
name|'self'
op|'.'
name|'readFromHandle'
op|'('
name|'buff'
op|','
name|'evt'
op|')'
newline|'\n'
nl|'\n'
name|'if'
op|'('
name|'rc'
op|'=='
name|'ERROR_IO_PENDING'
nl|'\n'
name|'or'
op|'('
name|'not'
name|'rc'
name|'and'
name|'numReads'
op|'>='
name|'self'
op|'.'
name|'maxReads'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_readScheduledInOS'
op|'='
name|'True'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'evt'
op|'.'
name|'ignore'
op|'='
name|'True'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_handleRead'
op|'('
name|'rc'
op|','
name|'bytes'
op|','
name|'evt'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'numReads'
op|'+='
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|readFromHandle
dedent|''
dedent|''
name|'def'
name|'readFromHandle'
op|'('
name|'self'
op|','
name|'bufflist'
op|','
name|'evt'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
comment|'# TODO: this should default to ReadFile'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|dataReceived
dedent|''
name|'def'
name|'dataReceived'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'NotImplementedError'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|readConnectionLost
dedent|''
name|'def'
name|'readConnectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'connectionLost'
op|'('
name|'reason'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# write stuff'
nl|'\n'
DECL|variable|dataBuffer
dedent|''
name|'dataBuffer'
op|'='
string|"''"
newline|'\n'
DECL|variable|offset
name|'offset'
op|'='
number|'0'
newline|'\n'
DECL|variable|writing
name|'writing'
op|'='
name|'False'
newline|'\n'
DECL|variable|_writeScheduled
name|'_writeScheduled'
op|'='
name|'None'
newline|'\n'
DECL|variable|_writeDisconnecting
name|'_writeDisconnecting'
op|'='
name|'False'
newline|'\n'
DECL|variable|_writeDisconnected
name|'_writeDisconnected'
op|'='
name|'False'
newline|'\n'
DECL|variable|writeBufferSize
name|'writeBufferSize'
op|'='
number|'2'
op|'**'
number|'2'
op|'**'
number|'2'
op|'**'
number|'2'
newline|'\n'
DECL|variable|maxWrites
name|'maxWrites'
op|'='
number|'5'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|loseWriteConnection
name|'def'
name|'loseWriteConnection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_writeDisconnecting'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'startWriting'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_closeWriteConnection
dedent|''
name|'def'
name|'_closeWriteConnection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# override in subclasses'
nl|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|writeConnectionLost
dedent|''
name|'def'
name|'writeConnectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
comment|'# in current code should never be called'
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'connectionLost'
op|'('
name|'reason'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|startWriting
dedent|''
name|'def'
name|'startWriting'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'reactor'
op|'.'
name|'addActiveHandle'
op|'('
name|'self'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'writing'
op|'='
name|'True'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_writeScheduled'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_writeScheduled'
op|'='
name|'self'
op|'.'
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_resumeWriting'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|stopWriting
dedent|''
dedent|''
name|'def'
name|'stopWriting'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_writeScheduled'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_writeScheduled'
op|'.'
name|'cancel'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_writeScheduled'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'writing'
op|'='
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_resumeWriting
dedent|''
name|'def'
name|'_resumeWriting'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_writeScheduled'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'doWrite'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_cbWrite
dedent|''
name|'def'
name|'_cbWrite'
op|'('
name|'self'
op|','
name|'rc'
op|','
name|'bytes'
op|','
name|'evt'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_handleWrite'
op|'('
name|'rc'
op|','
name|'bytes'
op|','
name|'evt'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'doWrite'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_handleWrite
dedent|''
dedent|''
name|'def'
name|'_handleWrite'
op|'('
name|'self'
op|','
name|'rc'
op|','
name|'bytes'
op|','
name|'evt'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns false if we should stop writing for now\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'disconnected'
name|'or'
name|'self'
op|'.'
name|'_writeDisconnected'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
comment|'# XXX: not handling WSAEWOULDBLOCK'
nl|'\n'
comment|'# ("too many outstanding overlapped I/O requests")'
nl|'\n'
dedent|''
name|'if'
name|'rc'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'connectionLost'
op|'('
name|'failure'
op|'.'
name|'Failure'
op|'('
nl|'\n'
name|'error'
op|'.'
name|'ConnectionLost'
op|'('
string|'"write error -- %s (%s)"'
op|'%'
nl|'\n'
op|'('
name|'errno'
op|'.'
name|'errorcode'
op|'.'
name|'get'
op|'('
name|'rc'
op|','
string|"'unknown'"
op|')'
op|','
name|'rc'
op|')'
op|')'
op|')'
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'offset'
op|'+='
name|'bytes'
newline|'\n'
comment|'# If there is nothing left to send,'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'offset'
op|'=='
name|'len'
op|'('
name|'self'
op|'.'
name|'dataBuffer'
op|')'
name|'and'
name|'not'
name|'self'
op|'.'
name|'_tempDataLen'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'dataBuffer'
op|'='
string|'""'
newline|'\n'
name|'self'
op|'.'
name|'offset'
op|'='
number|'0'
newline|'\n'
comment|'# stop writing'
nl|'\n'
name|'self'
op|'.'
name|'stopWriting'
op|'('
op|')'
newline|'\n'
comment|"# If I've got a producer who is supposed to supply me with data"
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'producer'
name|'is'
name|'not'
name|'None'
name|'and'
op|'('
op|'('
name|'not'
name|'self'
op|'.'
name|'streamingProducer'
op|')'
nl|'\n'
name|'or'
name|'self'
op|'.'
name|'producerPaused'
op|')'
op|':'
newline|'\n'
comment|'# tell them to supply some more.'
nl|'\n'
indent|'                    '
name|'self'
op|'.'
name|'producerPaused'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'producer'
op|'.'
name|'resumeProducing'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'disconnecting'
op|':'
newline|'\n'
comment|'# But if I was previously asked to let the connection die,'
nl|'\n'
comment|'# do so.'
nl|'\n'
indent|'                    '
name|'self'
op|'.'
name|'connectionLost'
op|'('
name|'failure'
op|'.'
name|'Failure'
op|'('
name|'main'
op|'.'
name|'CONNECTION_DONE'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_writeDisconnecting'
op|':'
newline|'\n'
comment|'# I was previously asked to to half-close the connection.'
nl|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_closeWriteConnection'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_writeDisconnected'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|doWrite
dedent|''
dedent|''
dedent|''
name|'def'
name|'doWrite'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'numWrites'
op|'='
number|'0'
newline|'\n'
name|'while'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'len'
op|'('
name|'self'
op|'.'
name|'dataBuffer'
op|')'
op|'-'
name|'self'
op|'.'
name|'offset'
op|'<'
name|'self'
op|'.'
name|'SEND_LIMIT'
op|':'
newline|'\n'
comment|'# If there is currently less than SEND_LIMIT bytes left to send'
nl|'\n'
comment|'# in the string, extend it with the array data.'
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'dataBuffer'
op|'='
op|'('
name|'buffer'
op|'('
name|'self'
op|'.'
name|'dataBuffer'
op|','
name|'self'
op|'.'
name|'offset'
op|')'
op|'+'
nl|'\n'
string|'""'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'_tempDataBuffer'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'offset'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_tempDataBuffer'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_tempDataLen'
op|'='
number|'0'
newline|'\n'
nl|'\n'
dedent|''
name|'evt'
op|'='
name|'_iocp'
op|'.'
name|'Event'
op|'('
name|'self'
op|'.'
name|'_cbWrite'
op|','
name|'self'
op|')'
newline|'\n'
nl|'\n'
comment|'# Send as much data as you can.'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'offset'
op|':'
newline|'\n'
indent|'                '
name|'evt'
op|'.'
name|'buff'
op|'='
name|'buff'
op|'='
name|'buffer'
op|'('
name|'self'
op|'.'
name|'dataBuffer'
op|','
name|'self'
op|'.'
name|'offset'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'evt'
op|'.'
name|'buff'
op|'='
name|'buff'
op|'='
name|'self'
op|'.'
name|'dataBuffer'
newline|'\n'
dedent|''
name|'rc'
op|','
name|'bytes'
op|'='
name|'self'
op|'.'
name|'writeToHandle'
op|'('
name|'buff'
op|','
name|'evt'
op|')'
newline|'\n'
name|'if'
op|'('
name|'rc'
op|'=='
name|'ERROR_IO_PENDING'
nl|'\n'
name|'or'
op|'('
name|'not'
name|'rc'
name|'and'
name|'numWrites'
op|'>='
name|'self'
op|'.'
name|'maxWrites'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'break'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'evt'
op|'.'
name|'ignore'
op|'='
name|'True'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_handleWrite'
op|'('
name|'rc'
op|','
name|'bytes'
op|','
name|'evt'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'numWrites'
op|'+='
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|writeToHandle
dedent|''
dedent|''
name|'def'
name|'writeToHandle'
op|'('
name|'self'
op|','
name|'buff'
op|','
name|'evt'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
comment|'# TODO: this should default to WriteFile'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|write
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Reliably write some data.\n\n        The data is buffered until his file descriptor is ready for writing.\n        """'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'data'
op|','
name|'unicode'
op|')'
op|':'
comment|'# no, really, I mean it'
newline|'\n'
indent|'            '
name|'raise'
name|'TypeError'
op|'('
string|'"Data must not be unicode"'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'connected'
name|'or'
name|'self'
op|'.'
name|'_writeDisconnected'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'if'
name|'data'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_tempDataBuffer'
op|'.'
name|'append'
op|'('
name|'data'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_tempDataLen'
op|'+='
name|'len'
op|'('
name|'data'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'producer'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'if'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'dataBuffer'
op|')'
op|'+'
name|'self'
op|'.'
name|'_tempDataLen'
nl|'\n'
op|'>'
name|'self'
op|'.'
name|'writeBufferSize'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'producerPaused'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'producer'
op|'.'
name|'pauseProducing'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'startWriting'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|writeSequence
dedent|''
dedent|''
name|'def'
name|'writeSequence'
op|'('
name|'self'
op|','
name|'iovec'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'self'
op|'.'
name|'connected'
name|'or'
name|'not'
name|'iovec'
name|'or'
name|'self'
op|'.'
name|'_writeDisconnected'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_tempDataBuffer'
op|'.'
name|'extend'
op|'('
name|'iovec'
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'iovec'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_tempDataLen'
op|'+='
name|'len'
op|'('
name|'i'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'producer'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'len'
op|'('
name|'self'
op|'.'
name|'dataBuffer'
op|')'
op|'+'
name|'self'
op|'.'
name|'_tempDataLen'
op|'>'
name|'self'
op|'.'
name|'writeBufferSize'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'producerPaused'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'producer'
op|'.'
name|'pauseProducing'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'startWriting'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# general stuff'
nl|'\n'
DECL|variable|connected
dedent|''
name|'connected'
op|'='
name|'False'
newline|'\n'
DECL|variable|disconnected
name|'disconnected'
op|'='
name|'False'
newline|'\n'
DECL|variable|disconnecting
name|'disconnecting'
op|'='
name|'False'
newline|'\n'
DECL|variable|logstr
name|'logstr'
op|'='
string|'"Uninitialized"'
newline|'\n'
nl|'\n'
DECL|variable|SEND_LIMIT
name|'SEND_LIMIT'
op|'='
number|'128'
op|'*'
number|'1024'
newline|'\n'
nl|'\n'
DECL|variable|maxReads
name|'maxReads'
op|'='
number|'5'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'reactor'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'reactor'
op|':'
newline|'\n'
indent|'            '
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'reactor'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'reactor'
op|'='
name|'reactor'
newline|'\n'
name|'self'
op|'.'
name|'_tempDataBuffer'
op|'='
op|'['
op|']'
comment|'# will be added to dataBuffer in doWrite'
newline|'\n'
name|'self'
op|'.'
name|'_tempDataLen'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_readBuffers'
op|'='
op|'['
name|'_iocp'
op|'.'
name|'AllocateReadBuffer'
op|'('
name|'self'
op|'.'
name|'readBufferSize'
op|')'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionLost
dedent|''
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The connection was lost.\n\n        This is called when the connection on a selectable object has been\n        lost.  It will be called whether the connection was closed explicitly,\n        an exception occurred in an event handler, or the other end of the\n        connection closed it first.\n\n        Clean up state here, but make sure to call back up to FileDescriptor.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'disconnected'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'connected'
op|'='
name|'False'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'producer'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'producer'
op|'.'
name|'stopProducing'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'producer'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'stopReading'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'stopWriting'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'reactor'
op|'.'
name|'removeActiveHandle'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getFileHandle
dedent|''
name|'def'
name|'getFileHandle'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'-'
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|loseConnection
dedent|''
name|'def'
name|'loseConnection'
op|'('
name|'self'
op|','
name|'_connDone'
op|'='
name|'failure'
op|'.'
name|'Failure'
op|'('
name|'main'
op|'.'
name|'CONNECTION_DONE'
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Close the connection at the next available opportunity.\n\n        Call this to cause this FileDescriptor to lose its connection.  It will\n        first write any data that it has buffered.\n\n        If there is data buffered yet to be written, this method will cause the\n        transport to lose its connection as soon as it\'s done flushing its\n        write buffer.  If you have a producer registered, the connection won\'t\n        be closed until the producer is finished. Therefore, make sure you\n        unregister your producer when it\'s finished, or the connection will\n        never close.\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'connected'
name|'and'
name|'not'
name|'self'
op|'.'
name|'disconnecting'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'_writeDisconnected'
op|':'
newline|'\n'
comment|"# doWrite won't trigger the connection close anymore"
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'stopReading'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'stopWriting'
newline|'\n'
name|'self'
op|'.'
name|'connectionLost'
op|'('
name|'_connDone'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'stopReading'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'startWriting'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'disconnecting'
op|'='
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# Producer/consumer implementation'
nl|'\n'
nl|'\n'
DECL|variable|producerPaused
dedent|''
dedent|''
dedent|''
name|'producerPaused'
op|'='
name|'False'
newline|'\n'
DECL|variable|streamingProducer
name|'streamingProducer'
op|'='
name|'False'
newline|'\n'
nl|'\n'
comment|'# first, the consumer stuff.  This requires no additional work, as'
nl|'\n'
comment|'# any object you can write to can be a consumer, really.'
nl|'\n'
nl|'\n'
DECL|variable|producer
name|'producer'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|registerProducer
name|'def'
name|'registerProducer'
op|'('
name|'self'
op|','
name|'producer'
op|','
name|'streaming'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Register to receive data from a producer.\n\n        This sets this selectable to be a consumer for a producer.  When this\n        selectable runs out of data on a write() call, it will ask the producer\n        to resumeProducing(). A producer should implement the IProducer\n        interface.\n\n        FileDescriptor provides some infrastructure for producer methods.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'producer'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'RuntimeError'
op|'('
nl|'\n'
string|'"Cannot register producer %s, because producer "'
nl|'\n'
string|'"%s was never unregistered."'
op|'%'
op|'('
name|'producer'
op|','
name|'self'
op|'.'
name|'producer'
op|')'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'disconnected'
op|':'
newline|'\n'
indent|'            '
name|'producer'
op|'.'
name|'stopProducing'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'producer'
op|'='
name|'producer'
newline|'\n'
name|'self'
op|'.'
name|'streamingProducer'
op|'='
name|'streaming'
newline|'\n'
name|'if'
name|'not'
name|'streaming'
op|':'
newline|'\n'
indent|'                '
name|'producer'
op|'.'
name|'resumeProducing'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|unregisterProducer
dedent|''
dedent|''
dedent|''
name|'def'
name|'unregisterProducer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Stop consuming data from a producer, without disconnecting.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'producer'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|stopConsuming
dedent|''
name|'def'
name|'stopConsuming'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Stop consuming data.\n\n        This is called when a producer has lost its connection, to tell the\n        consumer to go lose its connection (and break potential circular\n        references).\n        """'
newline|'\n'
name|'self'
op|'.'
name|'unregisterProducer'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# producer interface implementation'
nl|'\n'
nl|'\n'
DECL|member|resumeProducing
dedent|''
name|'def'
name|'resumeProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'assert'
name|'self'
op|'.'
name|'connected'
name|'and'
name|'not'
name|'self'
op|'.'
name|'disconnecting'
newline|'\n'
name|'self'
op|'.'
name|'startReading'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|pauseProducing
dedent|''
name|'def'
name|'pauseProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'stopReading'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|stopProducing
dedent|''
name|'def'
name|'stopProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|__all__
dedent|''
dedent|''
name|'__all__'
op|'='
op|'['
string|"'FileHandle'"
op|']'
newline|'\n'
nl|'\n'
endmarker|''
end_unit
