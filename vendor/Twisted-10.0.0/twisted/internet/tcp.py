begin_unit
comment|'# -*- test-case-name: twisted.test.test_tcp -*-'
nl|'\n'
comment|'# Copyright (c) 2001-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nVarious asynchronous TCP/IP classes.\n\nEnd users shouldn\'t use this module directly - use the reactor APIs instead.\n\nMaintainer: Itamar Shtull-Trauring\n"""'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# System Imports'
nl|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'types'
newline|'\n'
name|'import'
name|'socket'
newline|'\n'
name|'import'
name|'sys'
newline|'\n'
name|'import'
name|'operator'
newline|'\n'
nl|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'implements'
op|','
name|'classImplements'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'from'
name|'OpenSSL'
name|'import'
name|'SSL'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
DECL|variable|SSL
indent|'    '
name|'SSL'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'runtime'
name|'import'
name|'platformType'
newline|'\n'
nl|'\n'
nl|'\n'
name|'if'
name|'platformType'
op|'=='
string|"'win32'"
op|':'
newline|'\n'
comment|'# no such thing as WSAEPERM or error code 10001 according to winsock.h or MSDN'
nl|'\n'
DECL|variable|EPERM
indent|'    '
name|'EPERM'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'WSAEINVAL'
name|'as'
name|'EINVAL'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'WSAEWOULDBLOCK'
name|'as'
name|'EWOULDBLOCK'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'WSAEINPROGRESS'
name|'as'
name|'EINPROGRESS'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'WSAEALREADY'
name|'as'
name|'EALREADY'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'WSAECONNRESET'
name|'as'
name|'ECONNRESET'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'WSAEISCONN'
name|'as'
name|'EISCONN'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'WSAENOTCONN'
name|'as'
name|'ENOTCONN'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'WSAEINTR'
name|'as'
name|'EINTR'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'WSAENOBUFS'
name|'as'
name|'ENOBUFS'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'WSAEMFILE'
name|'as'
name|'EMFILE'
newline|'\n'
comment|'# No such thing as WSAENFILE, either.'
nl|'\n'
DECL|variable|ENFILE
name|'ENFILE'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
comment|'# Nor ENOMEM'
nl|'\n'
DECL|variable|ENOMEM
name|'ENOMEM'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
DECL|variable|EAGAIN
name|'EAGAIN'
op|'='
name|'EWOULDBLOCK'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'WSAECONNRESET'
name|'as'
name|'ECONNABORTED'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'win32'
name|'import'
name|'formatError'
name|'as'
name|'strerror'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'    '
name|'from'
name|'errno'
name|'import'
name|'EPERM'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'EINVAL'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'EWOULDBLOCK'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'EINPROGRESS'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'EALREADY'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'ECONNRESET'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'EISCONN'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'ENOTCONN'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'EINTR'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'ENOBUFS'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'EMFILE'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'ENFILE'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'ENOMEM'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'EAGAIN'
newline|'\n'
name|'from'
name|'errno'
name|'import'
name|'ECONNABORTED'
newline|'\n'
nl|'\n'
name|'from'
name|'os'
name|'import'
name|'strerror'
newline|'\n'
nl|'\n'
dedent|''
name|'from'
name|'errno'
name|'import'
name|'errorcode'
newline|'\n'
nl|'\n'
comment|'# Twisted Imports'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'defer'
op|','
name|'base'
op|','
name|'address'
op|','
name|'fdesc'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'task'
name|'import'
name|'deferLater'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'log'
op|','
name|'failure'
op|','
name|'reflect'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'util'
name|'import'
name|'unsignedID'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'error'
name|'import'
name|'CannotListenError'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'abstract'
op|','
name|'main'
op|','
name|'interfaces'
op|','
name|'error'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|_SocketCloser
name|'class'
name|'_SocketCloser'
op|':'
newline|'\n'
DECL|variable|_socketShutdownMethod
indent|'    '
name|'_socketShutdownMethod'
op|'='
string|"'shutdown'"
newline|'\n'
nl|'\n'
DECL|member|_closeSocket
name|'def'
name|'_closeSocket'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|"# socket.close() doesn't *really* close if there's another reference"
nl|'\n'
comment|'# to it in the TCP/IP stack, e.g. if it was was inherited by a'
nl|'\n'
comment|'# subprocess. And we really do want to close the connection. So we'
nl|'\n'
comment|'# use shutdown() instead, and then close() in order to release the'
nl|'\n'
comment|'# filedescriptor.'
nl|'\n'
indent|'        '
name|'skt'
op|'='
name|'self'
op|'.'
name|'socket'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'getattr'
op|'('
name|'skt'
op|','
name|'self'
op|'.'
name|'_socketShutdownMethod'
op|')'
op|'('
number|'2'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'socket'
op|'.'
name|'error'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'skt'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'socket'
op|'.'
name|'error'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|_TLSMixin
dedent|''
dedent|''
dedent|''
name|'class'
name|'_TLSMixin'
op|':'
newline|'\n'
DECL|variable|_socketShutdownMethod
indent|'    '
name|'_socketShutdownMethod'
op|'='
string|"'sock_shutdown'"
newline|'\n'
nl|'\n'
DECL|variable|writeBlockedOnRead
name|'writeBlockedOnRead'
op|'='
number|'0'
newline|'\n'
DECL|variable|readBlockedOnWrite
name|'readBlockedOnWrite'
op|'='
number|'0'
newline|'\n'
name|'_userWantRead'
op|'='
name|'_userWantWrite'
op|'='
name|'True'
newline|'\n'
nl|'\n'
DECL|member|getPeerCertificate
name|'def'
name|'getPeerCertificate'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'socket'
op|'.'
name|'get_peer_certificate'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|doRead
dedent|''
name|'def'
name|'doRead'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'disconnected'
op|':'
newline|'\n'
comment|'# See the comment in the similar check in doWrite below.'
nl|'\n'
comment|'# Additionally, in order for anything other than returning'
nl|'\n'
comment|'# CONNECTION_DONE here to make sense, it will probably be necessary'
nl|'\n'
comment|'# to implement a way to switch back to TCP from TLS (actually, if'
nl|'\n'
comment|'# we did something other than return CONNECTION_DONE, that would be'
nl|'\n'
comment|'# a big part of implementing that feature).  In other words, the'
nl|'\n'
comment|'# expectation is that doRead will be called when self.disconnected'
nl|'\n'
comment|"# is True only when the connection has been lost.  It's possible"
nl|'\n'
comment|'# that the other end could stop speaking TLS and then send us some'
nl|'\n'
comment|"# non-TLS data.  We'll end up ignoring that data and dropping the"
nl|'\n'
comment|"# connection.  There's no unit tests for this check in the cases"
nl|'\n'
comment|'# where it makes a difference.  The test suite only hits this'
nl|'\n'
comment|'# codepath when it would have otherwise hit the SSL.ZeroReturnError'
nl|'\n'
comment|'# exception handler below, which has exactly the same behavior as'
nl|'\n'
comment|"# this conditional.  Maybe that's the only case that can ever be"
nl|'\n'
comment|"# triggered, I'm not sure.  -exarkun"
nl|'\n'
indent|'            '
name|'return'
name|'main'
op|'.'
name|'CONNECTION_DONE'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'writeBlockedOnRead'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'writeBlockedOnRead'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_resetReadWrite'
op|'('
op|')'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'Connection'
op|'.'
name|'doRead'
op|'('
name|'self'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'SSL'
op|'.'
name|'ZeroReturnError'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'main'
op|'.'
name|'CONNECTION_DONE'
newline|'\n'
dedent|''
name|'except'
name|'SSL'
op|'.'
name|'WantReadError'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'except'
name|'SSL'
op|'.'
name|'WantWriteError'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'readBlockedOnWrite'
op|'='
number|'1'
newline|'\n'
name|'Connection'
op|'.'
name|'startWriting'
op|'('
name|'self'
op|')'
newline|'\n'
name|'Connection'
op|'.'
name|'stopReading'
op|'('
name|'self'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'except'
name|'SSL'
op|'.'
name|'SysCallError'
op|','
op|'('
name|'retval'
op|','
name|'desc'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
op|'('
name|'retval'
op|'=='
op|'-'
number|'1'
name|'and'
name|'desc'
op|'=='
string|"'Unexpected EOF'"
op|')'
nl|'\n'
name|'or'
name|'retval'
op|'>'
number|'0'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'main'
op|'.'
name|'CONNECTION_LOST'
newline|'\n'
dedent|''
name|'log'
op|'.'
name|'err'
op|'('
op|')'
newline|'\n'
name|'return'
name|'main'
op|'.'
name|'CONNECTION_LOST'
newline|'\n'
dedent|''
name|'except'
name|'SSL'
op|'.'
name|'Error'
op|','
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'e'
newline|'\n'
nl|'\n'
DECL|member|doWrite
dedent|''
dedent|''
name|'def'
name|'doWrite'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# Retry disconnecting'
nl|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'disconnected'
op|':'
newline|'\n'
comment|'# This case is triggered when "disconnected" is set to True by a'
nl|'\n'
comment|'# call to _postLoseConnection from FileDescriptor.doWrite (to which'
nl|'\n'
comment|'# we upcall at the end of this overridden version of that API).  It'
nl|'\n'
comment|'# means that while, as far as any protocol connected to this'
nl|'\n'
comment|'# transport is concerned, the connection no longer exists, the'
nl|'\n'
comment|'# connection *does* actually still exist.  Instead of closing the'
nl|'\n'
comment|'# connection in the overridden _postLoseConnection, we probably'
nl|'\n'
comment|'# tried (and failed) to send a TLS close alert.  The TCP connection'
nl|'\n'
comment|"# is still up and we're waiting for the socket to become writeable"
nl|'\n'
comment|'# enough for the TLS close alert to actually be sendable.  Only'
nl|'\n'
comment|'# then will the connection actually be torn down. -exarkun'
nl|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'_postLoseConnection'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_writeDisconnected'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'_closeWriteConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'readBlockedOnWrite'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'readBlockedOnWrite'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'_resetReadWrite'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'Connection'
op|'.'
name|'doWrite'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
DECL|member|writeSomeData
dedent|''
name|'def'
name|'writeSomeData'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'Connection'
op|'.'
name|'writeSomeData'
op|'('
name|'self'
op|','
name|'data'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'SSL'
op|'.'
name|'WantWriteError'
op|':'
newline|'\n'
indent|'            '
name|'return'
number|'0'
newline|'\n'
dedent|''
name|'except'
name|'SSL'
op|'.'
name|'WantReadError'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'writeBlockedOnRead'
op|'='
number|'1'
newline|'\n'
name|'Connection'
op|'.'
name|'stopWriting'
op|'('
name|'self'
op|')'
newline|'\n'
name|'Connection'
op|'.'
name|'startReading'
op|'('
name|'self'
op|')'
newline|'\n'
name|'return'
number|'0'
newline|'\n'
dedent|''
name|'except'
name|'SSL'
op|'.'
name|'ZeroReturnError'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'main'
op|'.'
name|'CONNECTION_LOST'
newline|'\n'
dedent|''
name|'except'
name|'SSL'
op|'.'
name|'SysCallError'
op|','
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'e'
op|'['
number|'0'
op|']'
op|'=='
op|'-'
number|'1'
name|'and'
name|'data'
op|'=='
string|'""'
op|':'
newline|'\n'
comment|'# errors when writing empty strings are expected'
nl|'\n'
comment|'# and can be ignored'
nl|'\n'
indent|'                '
name|'return'
number|'0'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'main'
op|'.'
name|'CONNECTION_LOST'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'SSL'
op|'.'
name|'Error'
op|','
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'e'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_postLoseConnection
dedent|''
dedent|''
name|'def'
name|'_postLoseConnection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Gets called after loseConnection(), after buffered data is sent.\n\n        We try to send an SSL shutdown alert, but if it doesn\'t work, retry\n        when the socket is writable.\n        """'
newline|'\n'
comment|'# Here, set "disconnected" to True to trick higher levels into thinking'
nl|'\n'
comment|"# the connection is really gone.  It's not, and we're not going to"
nl|'\n'
comment|"# close it yet.  Instead, we'll try to send a TLS close alert to shut"
nl|'\n'
comment|'# down the TLS connection cleanly.  Only after we actually get the'
nl|'\n'
comment|'# close alert into the socket will we disconnect the underlying TCP'
nl|'\n'
comment|'# connection.'
nl|'\n'
name|'self'
op|'.'
name|'disconnected'
op|'='
name|'True'
newline|'\n'
name|'if'
name|'hasattr'
op|'('
name|'self'
op|'.'
name|'socket'
op|','
string|"'set_shutdown'"
op|')'
op|':'
newline|'\n'
comment|'# If possible, mark the state of the TLS connection as having'
nl|'\n'
comment|'# already received a TLS close alert from the peer.  Why do'
nl|'\n'
comment|'# this???'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'socket'
op|'.'
name|'set_shutdown'
op|'('
name|'SSL'
op|'.'
name|'RECEIVED_SHUTDOWN'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_sendCloseAlert'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_sendCloseAlert
dedent|''
name|'def'
name|'_sendCloseAlert'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# Okay, *THIS* is a bit complicated.'
nl|'\n'
nl|'\n'
comment|'# Basically, the issue is, OpenSSL seems to not actually return'
nl|'\n'
comment|'# errors from SSL_shutdown. Therefore, the only way to'
nl|'\n'
comment|'# determine if the close notification has been sent is by'
nl|'\n'
comment|'# SSL_shutdown returning "done". However, it will not claim it\'s'
nl|'\n'
comment|"# done until it's both sent *and* received a shutdown notification."
nl|'\n'
nl|'\n'
comment|"# I don't actually want to wait for a received shutdown"
nl|'\n'
comment|'# notification, though, so, I have to set RECEIVED_SHUTDOWN'
nl|'\n'
comment|"# before calling shutdown. Then, it'll return True once it's"
nl|'\n'
comment|'# *SENT* the shutdown.'
nl|'\n'
nl|'\n'
comment|"# However, RECEIVED_SHUTDOWN can't be left set, because then"
nl|'\n'
comment|'# reads will fail, breaking half close.'
nl|'\n'
nl|'\n'
comment|"# Also, since shutdown doesn't report errors, an empty write call is"
nl|'\n'
comment|'# done first, to try to detect if the connection has gone away.'
nl|'\n'
comment|"# (*NOT* an SSL_write call, because that fails once you've called"
nl|'\n'
comment|'# shutdown)'
nl|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'os'
op|'.'
name|'write'
op|'('
name|'self'
op|'.'
name|'socket'
op|'.'
name|'fileno'
op|'('
op|')'
op|','
string|"''"
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|','
name|'se'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'se'
op|'.'
name|'args'
op|'['
number|'0'
op|']'
name|'in'
op|'('
name|'EINTR'
op|','
name|'EWOULDBLOCK'
op|','
name|'ENOBUFS'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
number|'0'
newline|'\n'
comment|'# Write error, socket gone'
nl|'\n'
dedent|''
name|'return'
name|'main'
op|'.'
name|'CONNECTION_LOST'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'hasattr'
op|'('
name|'self'
op|'.'
name|'socket'
op|','
string|"'set_shutdown'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'laststate'
op|'='
name|'self'
op|'.'
name|'socket'
op|'.'
name|'get_shutdown'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'socket'
op|'.'
name|'set_shutdown'
op|'('
name|'laststate'
op|'|'
name|'SSL'
op|'.'
name|'RECEIVED_SHUTDOWN'
op|')'
newline|'\n'
name|'done'
op|'='
name|'self'
op|'.'
name|'socket'
op|'.'
name|'shutdown'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
op|'('
name|'laststate'
op|'&'
name|'SSL'
op|'.'
name|'RECEIVED_SHUTDOWN'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'socket'
op|'.'
name|'set_shutdown'
op|'('
name|'SSL'
op|'.'
name|'SENT_SHUTDOWN'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'#warnings.warn("SSL connection shutdown possibly unreliable, "'
nl|'\n'
comment|'#              "please upgrade to ver 0.XX", category=UserWarning)'
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'socket'
op|'.'
name|'shutdown'
op|'('
op|')'
newline|'\n'
name|'done'
op|'='
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'SSL'
op|'.'
name|'Error'
op|','
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'e'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'done'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'stopWriting'
op|'('
op|')'
newline|'\n'
comment|'# Note that this is tested for by identity below.'
nl|'\n'
name|'return'
name|'main'
op|'.'
name|'CONNECTION_DONE'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|"# For some reason, the close alert wasn't sent.  Start writing"
nl|'\n'
comment|"# again so that we'll get another chance to send it."
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'startWriting'
op|'('
op|')'
newline|'\n'
comment|'# On Linux, select will sometimes not report a closed file'
nl|'\n'
comment|'# descriptor in the write set (in particular, it seems that if a'
nl|'\n'
comment|'# send() fails with EPIPE, the socket will not appear in the write'
nl|'\n'
comment|'# set).  The shutdown call above (which calls down to SSL_shutdown)'
nl|'\n'
comment|'# may have swallowed a write error.  Therefore, also start reading'
nl|'\n'
comment|"# so that if the socket is closed we will notice.  This doesn't"
nl|'\n'
comment|'# seem to be a problem for poll (because poll reports errors'
nl|'\n'
comment|'# separately) or with select on BSD (presumably because, unlike'
nl|'\n'
comment|"# Linux, it doesn't implement select in terms of poll and then map"
nl|'\n'
comment|"# POLLHUP to select's in fd_set)."
nl|'\n'
name|'self'
op|'.'
name|'startReading'
op|'('
op|')'
newline|'\n'
name|'return'
name|'None'
newline|'\n'
nl|'\n'
DECL|member|_closeWriteConnection
dedent|''
dedent|''
name|'def'
name|'_closeWriteConnection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'result'
op|'='
name|'self'
op|'.'
name|'_sendCloseAlert'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'result'
name|'is'
name|'main'
op|'.'
name|'CONNECTION_DONE'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'Connection'
op|'.'
name|'_closeWriteConnection'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
DECL|member|startReading
dedent|''
name|'def'
name|'startReading'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_userWantRead'
op|'='
name|'True'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'readBlockedOnWrite'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'Connection'
op|'.'
name|'startReading'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
DECL|member|stopReading
dedent|''
dedent|''
name|'def'
name|'stopReading'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_userWantRead'
op|'='
name|'False'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'writeBlockedOnRead'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'Connection'
op|'.'
name|'stopReading'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
DECL|member|startWriting
dedent|''
dedent|''
name|'def'
name|'startWriting'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_userWantWrite'
op|'='
name|'True'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'writeBlockedOnRead'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'Connection'
op|'.'
name|'startWriting'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
DECL|member|stopWriting
dedent|''
dedent|''
name|'def'
name|'stopWriting'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_userWantWrite'
op|'='
name|'False'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'readBlockedOnWrite'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'Connection'
op|'.'
name|'stopWriting'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_resetReadWrite
dedent|''
dedent|''
name|'def'
name|'_resetReadWrite'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# After changing readBlockedOnWrite or writeBlockedOnRead,'
nl|'\n'
comment|'# call this to reset the state to what the user requested.'
nl|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_userWantWrite'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'startWriting'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'stopWriting'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_userWantRead'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'startReading'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'stopReading'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|_TLSDelayed
dedent|''
dedent|''
dedent|''
name|'class'
name|'_TLSDelayed'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    State tracking record for TLS startup parameters.  Used to remember how\n    TLS should be started when starting it is delayed to wait for the output\n    buffer to be flushed.\n\n    @ivar bufferedData: A C{list} which contains all the data which was\n        written to the transport after an attempt to start TLS was made but\n        before the buffers outstanding at that time could be flushed and TLS\n        could really be started.  This is appended to by the transport\'s\n        write and writeSequence methods until it is possible to actually\n        start TLS, then it is written to the TLS-enabled transport.\n\n    @ivar context: An SSL context factory object to use to start TLS.\n\n    @ivar extra: An extra argument to pass to the transport\'s C{startTLS}\n        method.\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'bufferedData'
op|','
name|'context'
op|','
name|'extra'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'bufferedData'
op|'='
name|'bufferedData'
newline|'\n'
name|'self'
op|'.'
name|'context'
op|'='
name|'context'
newline|'\n'
name|'self'
op|'.'
name|'extra'
op|'='
name|'extra'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|_getTLSClass
dedent|''
dedent|''
name|'def'
name|'_getTLSClass'
op|'('
name|'klass'
op|','
name|'_existing'
op|'='
op|'{'
op|'}'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'klass'
name|'not'
name|'in'
name|'_existing'
op|':'
newline|'\n'
DECL|class|TLSConnection
indent|'        '
name|'class'
name|'TLSConnection'
op|'('
name|'_TLSMixin'
op|','
name|'klass'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'implements'
op|'('
name|'interfaces'
op|'.'
name|'ISSLTransport'
op|')'
newline|'\n'
dedent|''
name|'_existing'
op|'['
name|'klass'
op|']'
op|'='
name|'TLSConnection'
newline|'\n'
dedent|''
name|'return'
name|'_existing'
op|'['
name|'klass'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|Connection
dedent|''
name|'class'
name|'Connection'
op|'('
name|'abstract'
op|'.'
name|'FileDescriptor'
op|','
name|'_SocketCloser'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Superclass of all socket-based FileDescriptors.\n\n    This is an abstract superclass of all objects which represent a TCP/IP\n    connection based socket.\n\n    @ivar logstr: prefix used when logging events related to this connection.\n    @type logstr: C{str}\n    """'
newline|'\n'
nl|'\n'
name|'implements'
op|'('
name|'interfaces'
op|'.'
name|'ITCPTransport'
op|','
name|'interfaces'
op|'.'
name|'ISystemHandle'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|TLS
name|'TLS'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'skt'
op|','
name|'protocol'
op|','
name|'reactor'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'abstract'
op|'.'
name|'FileDescriptor'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'reactor'
op|'='
name|'reactor'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'socket'
op|'='
name|'skt'
newline|'\n'
name|'self'
op|'.'
name|'socket'
op|'.'
name|'setblocking'
op|'('
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'fileno'
op|'='
name|'skt'
op|'.'
name|'fileno'
newline|'\n'
name|'self'
op|'.'
name|'protocol'
op|'='
name|'protocol'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'SSL'
op|':'
newline|'\n'
indent|'        '
name|'_tlsWaiting'
op|'='
name|'None'
newline|'\n'
DECL|function|startTLS
name|'def'
name|'startTLS'
op|'('
name|'self'
op|','
name|'ctx'
op|','
name|'extra'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'assert'
name|'not'
name|'self'
op|'.'
name|'TLS'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'dataBuffer'
name|'or'
name|'self'
op|'.'
name|'_tempDataBuffer'
op|':'
newline|'\n'
comment|'# pre-TLS bytes are still being written.  Starting TLS now'
nl|'\n'
comment|"# will do the wrong thing.  Instead, mark that we're trying"
nl|'\n'
comment|'# to go into the TLS state.'
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'_tlsWaiting'
op|'='
name|'_TLSDelayed'
op|'('
op|'['
op|']'
op|','
name|'ctx'
op|','
name|'extra'
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'stopReading'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'stopWriting'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_startTLS'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'socket'
op|'='
name|'SSL'
op|'.'
name|'Connection'
op|'('
name|'ctx'
op|'.'
name|'getContext'
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'socket'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'fileno'
op|'='
name|'self'
op|'.'
name|'socket'
op|'.'
name|'fileno'
newline|'\n'
name|'self'
op|'.'
name|'startReading'
op|'('
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_startTLS
dedent|''
name|'def'
name|'_startTLS'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'TLS'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'__class__'
op|'='
name|'_getTLSClass'
op|'('
name|'self'
op|'.'
name|'__class__'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|write
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'bytes'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'_tlsWaiting'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_tlsWaiting'
op|'.'
name|'bufferedData'
op|'.'
name|'append'
op|'('
name|'bytes'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'abstract'
op|'.'
name|'FileDescriptor'
op|'.'
name|'write'
op|'('
name|'self'
op|','
name|'bytes'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|writeSequence
dedent|''
dedent|''
name|'def'
name|'writeSequence'
op|'('
name|'self'
op|','
name|'iovec'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'_tlsWaiting'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_tlsWaiting'
op|'.'
name|'bufferedData'
op|'.'
name|'extend'
op|'('
name|'iovec'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'abstract'
op|'.'
name|'FileDescriptor'
op|'.'
name|'writeSequence'
op|'('
name|'self'
op|','
name|'iovec'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|doWrite
dedent|''
dedent|''
name|'def'
name|'doWrite'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'='
name|'abstract'
op|'.'
name|'FileDescriptor'
op|'.'
name|'doWrite'
op|'('
name|'self'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_tlsWaiting'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'not'
name|'self'
op|'.'
name|'dataBuffer'
name|'and'
name|'not'
name|'self'
op|'.'
name|'_tempDataBuffer'
op|':'
newline|'\n'
indent|'                    '
name|'waiting'
op|'='
name|'self'
op|'.'
name|'_tlsWaiting'
newline|'\n'
name|'self'
op|'.'
name|'_tlsWaiting'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'startTLS'
op|'('
name|'waiting'
op|'.'
name|'context'
op|','
name|'waiting'
op|'.'
name|'extra'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'writeSequence'
op|'('
name|'waiting'
op|'.'
name|'bufferedData'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getHandle
dedent|''
dedent|''
name|'def'
name|'getHandle'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the socket for this connection."""'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'socket'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|doRead
dedent|''
name|'def'
name|'doRead'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Calls self.protocol.dataReceived with all available data.\n\n        This reads up to self.bufferSize bytes of data from its socket, then\n        calls self.dataReceived(data) to process it.  If the connection is not\n        lost through an error in the physical recv(), this function will return\n        the result of the dataReceived call.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'data'
op|'='
name|'self'
op|'.'
name|'socket'
op|'.'
name|'recv'
op|'('
name|'self'
op|'.'
name|'bufferSize'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'socket'
op|'.'
name|'error'
op|','
name|'se'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'se'
op|'.'
name|'args'
op|'['
number|'0'
op|']'
op|'=='
name|'EWOULDBLOCK'
op|':'
newline|'\n'
indent|'                '
name|'return'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'main'
op|'.'
name|'CONNECTION_LOST'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'data'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'main'
op|'.'
name|'CONNECTION_DONE'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|writeSomeData
dedent|''
name|'def'
name|'writeSomeData'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write as much as possible of the given data to this TCP connection.\n\n        This sends up to C{self.SEND_LIMIT} bytes from C{data}.  If the\n        connection is lost, an exception is returned.  Otherwise, the number\n        of bytes successfully written is returned.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# Limit length of buffer to try to send, because some OSes are too'
nl|'\n'
comment|'# stupid to do so themselves (ahem windows)'
nl|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'socket'
op|'.'
name|'send'
op|'('
name|'buffer'
op|'('
name|'data'
op|','
number|'0'
op|','
name|'self'
op|'.'
name|'SEND_LIMIT'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'socket'
op|'.'
name|'error'
op|','
name|'se'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'se'
op|'.'
name|'args'
op|'['
number|'0'
op|']'
op|'=='
name|'EINTR'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'self'
op|'.'
name|'writeSomeData'
op|'('
name|'data'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'se'
op|'.'
name|'args'
op|'['
number|'0'
op|']'
name|'in'
op|'('
name|'EWOULDBLOCK'
op|','
name|'ENOBUFS'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
number|'0'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'main'
op|'.'
name|'CONNECTION_LOST'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_closeWriteConnection
dedent|''
dedent|''
dedent|''
name|'def'
name|'_closeWriteConnection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'getattr'
op|'('
name|'self'
op|'.'
name|'socket'
op|','
name|'self'
op|'.'
name|'_socketShutdownMethod'
op|')'
op|'('
number|'1'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'socket'
op|'.'
name|'error'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'p'
op|'='
name|'interfaces'
op|'.'
name|'IHalfCloseableProtocol'
op|'('
name|'self'
op|'.'
name|'protocol'
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'p'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'p'
op|'.'
name|'writeConnectionLost'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'                '
name|'f'
op|'='
name|'failure'
op|'.'
name|'Failure'
op|'('
op|')'
newline|'\n'
name|'log'
op|'.'
name|'err'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'connectionLost'
op|'('
name|'f'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|readConnectionLost
dedent|''
dedent|''
dedent|''
name|'def'
name|'readConnectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'p'
op|'='
name|'interfaces'
op|'.'
name|'IHalfCloseableProtocol'
op|'('
name|'self'
op|'.'
name|'protocol'
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'p'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'p'
op|'.'
name|'readConnectionLost'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'                '
name|'log'
op|'.'
name|'err'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'connectionLost'
op|'('
name|'failure'
op|'.'
name|'Failure'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'connectionLost'
op|'('
name|'reason'
op|')'
newline|'\n'
nl|'\n'
DECL|member|connectionLost
dedent|''
dedent|''
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""See abstract.FileDescriptor.connectionLost().\n        """'
newline|'\n'
name|'abstract'
op|'.'
name|'FileDescriptor'
op|'.'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_closeSocket'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'='
name|'self'
op|'.'
name|'protocol'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'protocol'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'socket'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'fileno'
newline|'\n'
name|'protocol'
op|'.'
name|'connectionLost'
op|'('
name|'reason'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|logstr
dedent|''
name|'logstr'
op|'='
string|'"Uninitialized"'
newline|'\n'
nl|'\n'
DECL|member|logPrefix
name|'def'
name|'logPrefix'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the prefix to log with when I own the logging thread.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'logstr'
newline|'\n'
nl|'\n'
DECL|member|getTcpNoDelay
dedent|''
name|'def'
name|'getTcpNoDelay'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'operator'
op|'.'
name|'truth'
op|'('
name|'self'
op|'.'
name|'socket'
op|'.'
name|'getsockopt'
op|'('
name|'socket'
op|'.'
name|'IPPROTO_TCP'
op|','
name|'socket'
op|'.'
name|'TCP_NODELAY'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|setTcpNoDelay
dedent|''
name|'def'
name|'setTcpNoDelay'
op|'('
name|'self'
op|','
name|'enabled'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'socket'
op|'.'
name|'setsockopt'
op|'('
name|'socket'
op|'.'
name|'IPPROTO_TCP'
op|','
name|'socket'
op|'.'
name|'TCP_NODELAY'
op|','
name|'enabled'
op|')'
newline|'\n'
nl|'\n'
DECL|member|getTcpKeepAlive
dedent|''
name|'def'
name|'getTcpKeepAlive'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'operator'
op|'.'
name|'truth'
op|'('
name|'self'
op|'.'
name|'socket'
op|'.'
name|'getsockopt'
op|'('
name|'socket'
op|'.'
name|'SOL_SOCKET'
op|','
nl|'\n'
name|'socket'
op|'.'
name|'SO_KEEPALIVE'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|setTcpKeepAlive
dedent|''
name|'def'
name|'setTcpKeepAlive'
op|'('
name|'self'
op|','
name|'enabled'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'socket'
op|'.'
name|'setsockopt'
op|'('
name|'socket'
op|'.'
name|'SOL_SOCKET'
op|','
name|'socket'
op|'.'
name|'SO_KEEPALIVE'
op|','
name|'enabled'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'SSL'
op|':'
newline|'\n'
indent|'    '
name|'classImplements'
op|'('
name|'Connection'
op|','
name|'interfaces'
op|'.'
name|'ITLSTransport'
op|')'
newline|'\n'
nl|'\n'
DECL|class|BaseClient
dedent|''
name|'class'
name|'BaseClient'
op|'('
name|'Connection'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""A base class for client TCP (and similiar) sockets.\n    """'
newline|'\n'
DECL|variable|addressFamily
name|'addressFamily'
op|'='
name|'socket'
op|'.'
name|'AF_INET'
newline|'\n'
DECL|variable|socketType
name|'socketType'
op|'='
name|'socket'
op|'.'
name|'SOCK_STREAM'
newline|'\n'
nl|'\n'
DECL|member|_finishInit
name|'def'
name|'_finishInit'
op|'('
name|'self'
op|','
name|'whenDone'
op|','
name|'skt'
op|','
name|'error'
op|','
name|'reactor'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Called by base classes to continue to next stage of initialization."""'
newline|'\n'
name|'if'
name|'whenDone'
op|':'
newline|'\n'
indent|'            '
name|'Connection'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'skt'
op|','
name|'None'
op|','
name|'reactor'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'doWrite'
op|'='
name|'self'
op|'.'
name|'doConnect'
newline|'\n'
name|'self'
op|'.'
name|'doRead'
op|'='
name|'self'
op|'.'
name|'doConnect'
newline|'\n'
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'whenDone'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'self'
op|'.'
name|'failIfNotConnected'
op|','
name|'error'
op|')'
newline|'\n'
nl|'\n'
DECL|member|startTLS
dedent|''
dedent|''
name|'def'
name|'startTLS'
op|'('
name|'self'
op|','
name|'ctx'
op|','
name|'client'
op|'='
number|'1'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'Connection'
op|'.'
name|'startTLS'
op|'('
name|'self'
op|','
name|'ctx'
op|','
name|'client'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'client'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'socket'
op|'.'
name|'set_connect_state'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'socket'
op|'.'
name|'set_accept_state'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|stopConnecting
dedent|''
dedent|''
dedent|''
name|'def'
name|'stopConnecting'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Stop attempt to connect."""'
newline|'\n'
name|'self'
op|'.'
name|'failIfNotConnected'
op|'('
name|'error'
op|'.'
name|'UserError'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|failIfNotConnected
dedent|''
name|'def'
name|'failIfNotConnected'
op|'('
name|'self'
op|','
name|'err'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Generic method called when the attemps to connect failed. It basically\n        cleans everything it can: call connectionFailed, stop read and write,\n        delete socket related members.\n        """'
newline|'\n'
name|'if'
op|'('
name|'self'
op|'.'
name|'connected'
name|'or'
name|'self'
op|'.'
name|'disconnected'
name|'or'
nl|'\n'
name|'not'
name|'hasattr'
op|'('
name|'self'
op|','
string|'"connector"'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'connector'
op|'.'
name|'connectionFailed'
op|'('
name|'failure'
op|'.'
name|'Failure'
op|'('
name|'err'
op|')'
op|')'
newline|'\n'
name|'if'
name|'hasattr'
op|'('
name|'self'
op|','
string|'"reactor"'
op|')'
op|':'
newline|'\n'
comment|"# this doesn't happen if we failed in __init__"
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'stopReading'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'stopWriting'
op|'('
op|')'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'connector'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_closeSocket'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'del'
name|'self'
op|'.'
name|'socket'
op|','
name|'self'
op|'.'
name|'fileno'
newline|'\n'
nl|'\n'
DECL|member|createInternetSocket
dedent|''
dedent|''
name|'def'
name|'createInternetSocket'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""(internal) Create a non-blocking socket using\n        self.addressFamily, self.socketType.\n        """'
newline|'\n'
name|'s'
op|'='
name|'socket'
op|'.'
name|'socket'
op|'('
name|'self'
op|'.'
name|'addressFamily'
op|','
name|'self'
op|'.'
name|'socketType'
op|')'
newline|'\n'
name|'s'
op|'.'
name|'setblocking'
op|'('
number|'0'
op|')'
newline|'\n'
name|'fdesc'
op|'.'
name|'_setCloseOnExec'
op|'('
name|'s'
op|'.'
name|'fileno'
op|'('
op|')'
op|')'
newline|'\n'
name|'return'
name|'s'
newline|'\n'
nl|'\n'
DECL|member|resolveAddress
dedent|''
name|'def'
name|'resolveAddress'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'abstract'
op|'.'
name|'isIPAddress'
op|'('
name|'self'
op|'.'
name|'addr'
op|'['
number|'0'
op|']'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_setRealAddress'
op|'('
name|'self'
op|'.'
name|'addr'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'='
name|'self'
op|'.'
name|'reactor'
op|'.'
name|'resolve'
op|'('
name|'self'
op|'.'
name|'addr'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallbacks'
op|'('
name|'self'
op|'.'
name|'_setRealAddress'
op|','
name|'self'
op|'.'
name|'failIfNotConnected'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_setRealAddress
dedent|''
dedent|''
name|'def'
name|'_setRealAddress'
op|'('
name|'self'
op|','
name|'address'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'realAddress'
op|'='
op|'('
name|'address'
op|','
name|'self'
op|'.'
name|'addr'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'doConnect'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|doConnect
dedent|''
name|'def'
name|'doConnect'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""I connect the socket.\n\n        Then, call the protocol\'s makeConnection, and start waiting for data.\n        """'
newline|'\n'
name|'if'
name|'not'
name|'hasattr'
op|'('
name|'self'
op|','
string|'"connector"'
op|')'
op|':'
newline|'\n'
comment|'# this happens when connection failed but doConnect'
nl|'\n'
comment|'# was scheduled via a callLater in self._finishInit'
nl|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'err'
op|'='
name|'self'
op|'.'
name|'socket'
op|'.'
name|'getsockopt'
op|'('
name|'socket'
op|'.'
name|'SOL_SOCKET'
op|','
name|'socket'
op|'.'
name|'SO_ERROR'
op|')'
newline|'\n'
name|'if'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'failIfNotConnected'
op|'('
name|'error'
op|'.'
name|'getConnectError'
op|'('
op|'('
name|'err'
op|','
name|'strerror'
op|'('
name|'err'
op|')'
op|')'
op|')'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# doConnect gets called twice.  The first time we actually need to'
nl|'\n'
comment|"# start the connection attempt.  The second time we don't really"
nl|'\n'
comment|'# want to (SO_ERROR above will have taken care of any errors, and if'
nl|'\n'
comment|'# it reported none, the mere fact that doConnect was called again is'
nl|'\n'
comment|'# sufficient to indicate that the connection has succeeded), but it'
nl|'\n'
comment|'# is not /particularly/ detrimental to do so.  This should get'
nl|'\n'
comment|'# cleaned up some day, though.'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'connectResult'
op|'='
name|'self'
op|'.'
name|'socket'
op|'.'
name|'connect_ex'
op|'('
name|'self'
op|'.'
name|'realAddress'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'socket'
op|'.'
name|'error'
op|','
name|'se'
op|':'
newline|'\n'
indent|'            '
name|'connectResult'
op|'='
name|'se'
op|'.'
name|'args'
op|'['
number|'0'
op|']'
newline|'\n'
dedent|''
name|'if'
name|'connectResult'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'connectResult'
op|'=='
name|'EISCONN'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
comment|'# on Windows EINVAL means sometimes that we should keep trying:'
nl|'\n'
comment|'# http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winsock/winsock/connect_2.asp'
nl|'\n'
dedent|''
name|'elif'
op|'('
op|'('
name|'connectResult'
name|'in'
op|'('
name|'EWOULDBLOCK'
op|','
name|'EINPROGRESS'
op|','
name|'EALREADY'
op|')'
op|')'
name|'or'
nl|'\n'
op|'('
name|'connectResult'
op|'=='
name|'EINVAL'
name|'and'
name|'platformType'
op|'=='
string|'"win32"'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'startReading'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'startWriting'
op|'('
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'failIfNotConnected'
op|'('
name|'error'
op|'.'
name|'getConnectError'
op|'('
op|'('
name|'connectResult'
op|','
name|'strerror'
op|'('
name|'connectResult'
op|')'
op|')'
op|')'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
comment|'# If I have reached this point without raising or returning, that means'
nl|'\n'
comment|'# that the socket is connected.'
nl|'\n'
dedent|''
dedent|''
name|'del'
name|'self'
op|'.'
name|'doWrite'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'doRead'
newline|'\n'
comment|'# we first stop and then start, to reset any references to the old doRead'
nl|'\n'
name|'self'
op|'.'
name|'stopReading'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'stopWriting'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_connectDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_connectDone
dedent|''
name|'def'
name|'_connectDone'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'protocol'
op|'='
name|'self'
op|'.'
name|'connector'
op|'.'
name|'buildProtocol'
op|'('
name|'self'
op|'.'
name|'getPeer'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'connected'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'logstr'
op|'='
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'__class__'
op|'.'
name|'__name__'
op|'+'
string|'",client"'
newline|'\n'
name|'self'
op|'.'
name|'startReading'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
DECL|member|connectionLost
dedent|''
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'self'
op|'.'
name|'connected'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'failIfNotConnected'
op|'('
name|'error'
op|'.'
name|'ConnectError'
op|'('
name|'string'
op|'='
name|'reason'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'Connection'
op|'.'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'connector'
op|'.'
name|'connectionLost'
op|'('
name|'reason'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Client
dedent|''
dedent|''
dedent|''
name|'class'
name|'Client'
op|'('
name|'BaseClient'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""A TCP client."""'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'host'
op|','
name|'port'
op|','
name|'bindAddress'
op|','
name|'connector'
op|','
name|'reactor'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
comment|'# BaseClient.__init__ is invoked later'
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'connector'
op|'='
name|'connector'
newline|'\n'
name|'self'
op|'.'
name|'addr'
op|'='
op|'('
name|'host'
op|','
name|'port'
op|')'
newline|'\n'
nl|'\n'
name|'whenDone'
op|'='
name|'self'
op|'.'
name|'resolveAddress'
newline|'\n'
name|'err'
op|'='
name|'None'
newline|'\n'
name|'skt'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'skt'
op|'='
name|'self'
op|'.'
name|'createInternetSocket'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'socket'
op|'.'
name|'error'
op|','
name|'se'
op|':'
newline|'\n'
indent|'            '
name|'err'
op|'='
name|'error'
op|'.'
name|'ConnectBindError'
op|'('
name|'se'
op|'['
number|'0'
op|']'
op|','
name|'se'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
name|'whenDone'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'if'
name|'whenDone'
name|'and'
name|'bindAddress'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'skt'
op|'.'
name|'bind'
op|'('
name|'bindAddress'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'socket'
op|'.'
name|'error'
op|','
name|'se'
op|':'
newline|'\n'
indent|'                '
name|'err'
op|'='
name|'error'
op|'.'
name|'ConnectBindError'
op|'('
name|'se'
op|'['
number|'0'
op|']'
op|','
name|'se'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
name|'whenDone'
op|'='
name|'None'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_finishInit'
op|'('
name|'whenDone'
op|','
name|'skt'
op|','
name|'err'
op|','
name|'reactor'
op|')'
newline|'\n'
nl|'\n'
DECL|member|getHost
dedent|''
name|'def'
name|'getHost'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns an IPv4Address.\n\n        This indicates the address from which I am connecting.\n        """'
newline|'\n'
name|'return'
name|'address'
op|'.'
name|'IPv4Address'
op|'('
string|"'TCP'"
op|','
op|'*'
op|'('
name|'self'
op|'.'
name|'socket'
op|'.'
name|'getsockname'
op|'('
op|')'
op|'+'
op|'('
string|"'INET'"
op|','
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|getPeer
dedent|''
name|'def'
name|'getPeer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns an IPv4Address.\n\n        This indicates the address that I am connected to.\n        """'
newline|'\n'
name|'return'
name|'address'
op|'.'
name|'IPv4Address'
op|'('
string|"'TCP'"
op|','
op|'*'
op|'('
name|'self'
op|'.'
name|'realAddress'
op|'+'
op|'('
string|"'INET'"
op|','
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
string|"'<%s to %s at %x>'"
op|'%'
op|'('
name|'self'
op|'.'
name|'__class__'
op|','
name|'self'
op|'.'
name|'addr'
op|','
name|'unsignedID'
op|'('
name|'self'
op|')'
op|')'
newline|'\n'
name|'return'
name|'s'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Server
dedent|''
dedent|''
name|'class'
name|'Server'
op|'('
name|'Connection'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Serverside socket-stream connection class.\n\n    This is a serverside network connection transport; a socket which came from\n    an accept() on a server.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'sock'
op|','
name|'protocol'
op|','
name|'client'
op|','
name|'server'
op|','
name|'sessionno'
op|','
name|'reactor'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Server(sock, protocol, client, server, sessionno)\n\n        Initialize it with a socket, a protocol, a descriptor for my peer (a\n        tuple of host, port describing the other end of the connection), an\n        instance of Port, and a session number.\n        """'
newline|'\n'
name|'Connection'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'sock'
op|','
name|'protocol'
op|','
name|'reactor'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'server'
op|'='
name|'server'
newline|'\n'
name|'self'
op|'.'
name|'client'
op|'='
name|'client'
newline|'\n'
name|'self'
op|'.'
name|'sessionno'
op|'='
name|'sessionno'
newline|'\n'
name|'self'
op|'.'
name|'hostname'
op|'='
name|'client'
op|'['
number|'0'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'logstr'
op|'='
string|'"%s,%s,%s"'
op|'%'
op|'('
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'__class__'
op|'.'
name|'__name__'
op|','
nl|'\n'
name|'sessionno'
op|','
nl|'\n'
name|'self'
op|'.'
name|'hostname'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'repstr'
op|'='
string|'"<%s #%s on %s>"'
op|'%'
op|'('
name|'self'
op|'.'
name|'protocol'
op|'.'
name|'__class__'
op|'.'
name|'__name__'
op|','
nl|'\n'
name|'self'
op|'.'
name|'sessionno'
op|','
nl|'\n'
name|'self'
op|'.'
name|'server'
op|'.'
name|'_realPortNumber'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'startReading'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'connected'
op|'='
number|'1'
newline|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""A string representation of this connection.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'repstr'
newline|'\n'
nl|'\n'
DECL|member|startTLS
dedent|''
name|'def'
name|'startTLS'
op|'('
name|'self'
op|','
name|'ctx'
op|','
name|'server'
op|'='
number|'1'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'Connection'
op|'.'
name|'startTLS'
op|'('
name|'self'
op|','
name|'ctx'
op|','
name|'server'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'server'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'socket'
op|'.'
name|'set_accept_state'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'socket'
op|'.'
name|'set_connect_state'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getHost
dedent|''
dedent|''
dedent|''
name|'def'
name|'getHost'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns an IPv4Address.\n\n        This indicates the server\'s address.\n        """'
newline|'\n'
name|'return'
name|'address'
op|'.'
name|'IPv4Address'
op|'('
string|"'TCP'"
op|','
op|'*'
op|'('
name|'self'
op|'.'
name|'socket'
op|'.'
name|'getsockname'
op|'('
op|')'
op|'+'
op|'('
string|"'INET'"
op|','
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|getPeer
dedent|''
name|'def'
name|'getPeer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns an IPv4Address.\n\n        This indicates the client\'s address.\n        """'
newline|'\n'
name|'return'
name|'address'
op|'.'
name|'IPv4Address'
op|'('
string|"'TCP'"
op|','
op|'*'
op|'('
name|'self'
op|'.'
name|'client'
op|'+'
op|'('
string|"'INET'"
op|','
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|class|Port
dedent|''
dedent|''
name|'class'
name|'Port'
op|'('
name|'base'
op|'.'
name|'BasePort'
op|','
name|'_SocketCloser'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A TCP server port, listening for connections.\n\n    When a connection is accepted, this will call a factory\'s buildProtocol\n    with the incoming address as an argument, according to the specification\n    described in L{twisted.internet.interfaces.IProtocolFactory}.\n\n    If you wish to change the sort of transport that will be used, the\n    C{transport} attribute will be called with the signature expected for\n    C{Server.__init__}, so it can be replaced.\n\n    @ivar deferred: a deferred created when L{stopListening} is called, and\n        that will fire when connection is lost. This is not to be used it\n        directly: prefer the deferred returned by L{stopListening} instead.\n    @type deferred: L{defer.Deferred}\n\n    @ivar disconnecting: flag indicating that the L{stopListening} method has\n        been called and that no connections should be accepted anymore.\n    @type disconnecting: C{bool}\n\n    @ivar connected: flag set once the listen has successfully been called on\n        the socket.\n    @type connected: C{bool}\n    """'
newline|'\n'
nl|'\n'
name|'implements'
op|'('
name|'interfaces'
op|'.'
name|'IListeningPort'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|addressFamily
name|'addressFamily'
op|'='
name|'socket'
op|'.'
name|'AF_INET'
newline|'\n'
DECL|variable|socketType
name|'socketType'
op|'='
name|'socket'
op|'.'
name|'SOCK_STREAM'
newline|'\n'
nl|'\n'
DECL|variable|transport
name|'transport'
op|'='
name|'Server'
newline|'\n'
DECL|variable|sessionno
name|'sessionno'
op|'='
number|'0'
newline|'\n'
DECL|variable|interface
name|'interface'
op|'='
string|"''"
newline|'\n'
DECL|variable|backlog
name|'backlog'
op|'='
number|'50'
newline|'\n'
nl|'\n'
comment|'# Actual port number being listened on, only set to a non-None'
nl|'\n'
comment|'# value when we are actually listening.'
nl|'\n'
DECL|variable|_realPortNumber
name|'_realPortNumber'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'port'
op|','
name|'factory'
op|','
name|'backlog'
op|'='
number|'50'
op|','
name|'interface'
op|'='
string|"''"
op|','
name|'reactor'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Initialize with a numeric port to listen on.\n        """'
newline|'\n'
name|'base'
op|'.'
name|'BasePort'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'reactor'
op|'='
name|'reactor'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'port'
op|'='
name|'port'
newline|'\n'
name|'self'
op|'.'
name|'factory'
op|'='
name|'factory'
newline|'\n'
name|'self'
op|'.'
name|'backlog'
op|'='
name|'backlog'
newline|'\n'
name|'self'
op|'.'
name|'interface'
op|'='
name|'interface'
newline|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_realPortNumber'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|'"<%s of %s on %s>"'
op|'%'
op|'('
name|'self'
op|'.'
name|'__class__'
op|','
name|'self'
op|'.'
name|'factory'
op|'.'
name|'__class__'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_realPortNumber'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|'"<%s of %s (not listening)>"'
op|'%'
op|'('
name|'self'
op|'.'
name|'__class__'
op|','
name|'self'
op|'.'
name|'factory'
op|'.'
name|'__class__'
op|')'
newline|'\n'
nl|'\n'
DECL|member|createInternetSocket
dedent|''
dedent|''
name|'def'
name|'createInternetSocket'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
name|'base'
op|'.'
name|'BasePort'
op|'.'
name|'createInternetSocket'
op|'('
name|'self'
op|')'
newline|'\n'
name|'if'
name|'platformType'
op|'=='
string|'"posix"'
name|'and'
name|'sys'
op|'.'
name|'platform'
op|'!='
string|'"cygwin"'
op|':'
newline|'\n'
indent|'            '
name|'s'
op|'.'
name|'setsockopt'
op|'('
name|'socket'
op|'.'
name|'SOL_SOCKET'
op|','
name|'socket'
op|'.'
name|'SO_REUSEADDR'
op|','
number|'1'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'s'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|startListening
dedent|''
name|'def'
name|'startListening'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create and bind my socket, and begin listening on it.\n\n        This is called on unserialization, and must be called after creating a\n        server to begin listening on the specified port.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'skt'
op|'='
name|'self'
op|'.'
name|'createInternetSocket'
op|'('
op|')'
newline|'\n'
name|'skt'
op|'.'
name|'bind'
op|'('
op|'('
name|'self'
op|'.'
name|'interface'
op|','
name|'self'
op|'.'
name|'port'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'socket'
op|'.'
name|'error'
op|','
name|'le'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'CannotListenError'
op|','
op|'('
name|'self'
op|'.'
name|'interface'
op|','
name|'self'
op|'.'
name|'port'
op|','
name|'le'
op|')'
newline|'\n'
nl|'\n'
comment|'# Make sure that if we listened on port 0, we update that to'
nl|'\n'
comment|'# reflect what the OS actually assigned us.'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_realPortNumber'
op|'='
name|'skt'
op|'.'
name|'getsockname'
op|'('
op|')'
op|'['
number|'1'
op|']'
newline|'\n'
nl|'\n'
name|'log'
op|'.'
name|'msg'
op|'('
string|'"%s starting on %s"'
op|'%'
op|'('
name|'self'
op|'.'
name|'factory'
op|'.'
name|'__class__'
op|','
name|'self'
op|'.'
name|'_realPortNumber'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# The order of the next 6 lines is kind of bizarre.  If no one'
nl|'\n'
comment|'# can explain it, perhaps we should re-arrange them.'
nl|'\n'
name|'self'
op|'.'
name|'factory'
op|'.'
name|'doStart'
op|'('
op|')'
newline|'\n'
name|'skt'
op|'.'
name|'listen'
op|'('
name|'self'
op|'.'
name|'backlog'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'connected'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'socket'
op|'='
name|'skt'
newline|'\n'
name|'self'
op|'.'
name|'fileno'
op|'='
name|'self'
op|'.'
name|'socket'
op|'.'
name|'fileno'
newline|'\n'
name|'self'
op|'.'
name|'numberAccepts'
op|'='
number|'100'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'startReading'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_buildAddr
dedent|''
name|'def'
name|'_buildAddr'
op|'('
name|'self'
op|','
op|'('
name|'host'
op|','
name|'port'
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'address'
op|'.'
name|'_ServerFactoryIPv4Address'
op|'('
string|"'TCP'"
op|','
name|'host'
op|','
name|'port'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|doRead
dedent|''
name|'def'
name|'doRead'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Called when my socket is ready for reading.\n\n        This accepts a connection and calls self.protocol() to handle the\n        wire-level protocol.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'platformType'
op|'=='
string|'"posix"'
op|':'
newline|'\n'
indent|'                '
name|'numAccepts'
op|'='
name|'self'
op|'.'
name|'numberAccepts'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# win32 event loop breaks if we do more than one accept()'
nl|'\n'
comment|'# in an iteration of the event loop.'
nl|'\n'
indent|'                '
name|'numAccepts'
op|'='
number|'1'
newline|'\n'
dedent|''
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'numAccepts'
op|')'
op|':'
newline|'\n'
comment|"# we need this so we can deal with a factory's buildProtocol"
nl|'\n'
comment|'# calling our loseConnection'
nl|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'disconnecting'
op|':'
newline|'\n'
indent|'                    '
name|'return'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'skt'
op|','
name|'addr'
op|'='
name|'self'
op|'.'
name|'socket'
op|'.'
name|'accept'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'socket'
op|'.'
name|'error'
op|','
name|'e'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'e'
op|'.'
name|'args'
op|'['
number|'0'
op|']'
name|'in'
op|'('
name|'EWOULDBLOCK'
op|','
name|'EAGAIN'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'numberAccepts'
op|'='
name|'i'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'elif'
name|'e'
op|'.'
name|'args'
op|'['
number|'0'
op|']'
op|'=='
name|'EPERM'
op|':'
newline|'\n'
comment|'# Netfilter on Linux may have rejected the'
nl|'\n'
comment|'# connection, but we get told to try to accept()'
nl|'\n'
comment|'# anyway.'
nl|'\n'
indent|'                        '
name|'continue'
newline|'\n'
dedent|''
name|'elif'
name|'e'
op|'.'
name|'args'
op|'['
number|'0'
op|']'
name|'in'
op|'('
name|'EMFILE'
op|','
name|'ENOBUFS'
op|','
name|'ENFILE'
op|','
name|'ENOMEM'
op|','
name|'ECONNABORTED'
op|')'
op|':'
newline|'\n'
nl|'\n'
comment|'# Linux gives EMFILE when a process is not allowed'
nl|'\n'
comment|'# to allocate any more file descriptors.  *BSD and'
nl|'\n'
comment|'# Win32 give (WSA)ENOBUFS.  Linux can also give'
nl|'\n'
comment|'# ENFILE if the system is out of inodes, or ENOMEM'
nl|'\n'
comment|'# if there is insufficient memory to allocate a new'
nl|'\n'
comment|'# dentry.  ECONNABORTED is documented as possible on'
nl|'\n'
comment|'# both Linux and Windows, but it is not clear'
nl|'\n'
comment|'# whether there are actually any circumstances under'
nl|'\n'
comment|'# which it can happen (one might expect it to be'
nl|'\n'
comment|'# possible if a client sends a FIN or RST after the'
nl|'\n'
comment|'# server sends a SYN|ACK but before application code'
nl|'\n'
comment|'# calls accept(2), however at least on Linux this'
nl|'\n'
comment|'# _seems_ to be short-circuited by syncookies.'
nl|'\n'
nl|'\n'
indent|'                        '
name|'log'
op|'.'
name|'msg'
op|'('
string|'"Could not accept new connection (%s)"'
op|'%'
op|'('
nl|'\n'
name|'errorcode'
op|'['
name|'e'
op|'.'
name|'args'
op|'['
number|'0'
op|']'
op|']'
op|','
op|')'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
name|'fdesc'
op|'.'
name|'_setCloseOnExec'
op|'('
name|'skt'
op|'.'
name|'fileno'
op|'('
op|')'
op|')'
newline|'\n'
name|'protocol'
op|'='
name|'self'
op|'.'
name|'factory'
op|'.'
name|'buildProtocol'
op|'('
name|'self'
op|'.'
name|'_buildAddr'
op|'('
name|'addr'
op|')'
op|')'
newline|'\n'
name|'if'
name|'protocol'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'skt'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'s'
op|'='
name|'self'
op|'.'
name|'sessionno'
newline|'\n'
name|'self'
op|'.'
name|'sessionno'
op|'='
name|'s'
op|'+'
number|'1'
newline|'\n'
name|'transport'
op|'='
name|'self'
op|'.'
name|'transport'
op|'('
name|'skt'
op|','
name|'protocol'
op|','
name|'addr'
op|','
name|'self'
op|','
name|'s'
op|','
name|'self'
op|'.'
name|'reactor'
op|')'
newline|'\n'
name|'transport'
op|'='
name|'self'
op|'.'
name|'_preMakeConnection'
op|'('
name|'transport'
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'makeConnection'
op|'('
name|'transport'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'numberAccepts'
op|'='
name|'self'
op|'.'
name|'numberAccepts'
op|'+'
number|'20'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|':'
newline|'\n'
comment|'# Note that in TLS mode, this will possibly catch SSL.Errors'
nl|'\n'
comment|'# raised by self.socket.accept()'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# There is no "except SSL.Error:" above because SSL may be'
nl|'\n'
comment|'# None if there is no SSL support.  In any case, all the'
nl|'\n'
comment|'# "except SSL.Error:" suite would probably do is log.deferr()'
nl|'\n'
comment|'# and return, so handling it here works just as well.'
nl|'\n'
indent|'            '
name|'log'
op|'.'
name|'deferr'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_preMakeConnection
dedent|''
dedent|''
name|'def'
name|'_preMakeConnection'
op|'('
name|'self'
op|','
name|'transport'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'transport'
newline|'\n'
nl|'\n'
DECL|member|loseConnection
dedent|''
name|'def'
name|'loseConnection'
op|'('
name|'self'
op|','
name|'connDone'
op|'='
name|'failure'
op|'.'
name|'Failure'
op|'('
name|'main'
op|'.'
name|'CONNECTION_DONE'
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Stop accepting connections on this port.\n\n        This will shut down the socket and call self.connectionLost().  It\n        returns a deferred which will fire successfully when the port is\n        actually closed, or with a failure if an error occurs shutting down.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'disconnecting'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'stopReading'
op|'('
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'connected'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'deferred'
op|'='
name|'deferLater'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'reactor'
op|','
number|'0'
op|','
name|'self'
op|'.'
name|'connectionLost'
op|','
name|'connDone'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'deferred'
newline|'\n'
nl|'\n'
DECL|variable|stopListening
dedent|''
dedent|''
name|'stopListening'
op|'='
name|'loseConnection'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionLost
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Cleans up the socket.\n        """'
newline|'\n'
name|'log'
op|'.'
name|'msg'
op|'('
string|"'(Port %s Closed)'"
op|'%'
name|'self'
op|'.'
name|'_realPortNumber'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_realPortNumber'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'base'
op|'.'
name|'BasePort'
op|'.'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'connected'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_closeSocket'
op|'('
op|')'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'socket'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'fileno'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'factory'
op|'.'
name|'doStop'
op|'('
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'disconnecting'
op|'='
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|logPrefix
dedent|''
dedent|''
name|'def'
name|'logPrefix'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns the name of my class, to prefix log entries with.\n        """'
newline|'\n'
name|'return'
name|'reflect'
op|'.'
name|'qual'
op|'('
name|'self'
op|'.'
name|'factory'
op|'.'
name|'__class__'
op|')'
newline|'\n'
nl|'\n'
DECL|member|getHost
dedent|''
name|'def'
name|'getHost'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns an IPv4Address.\n\n        This indicates the server\'s address.\n        """'
newline|'\n'
name|'return'
name|'address'
op|'.'
name|'IPv4Address'
op|'('
string|"'TCP'"
op|','
op|'*'
op|'('
name|'self'
op|'.'
name|'socket'
op|'.'
name|'getsockname'
op|'('
op|')'
op|'+'
op|'('
string|"'INET'"
op|','
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|class|Connector
dedent|''
dedent|''
name|'class'
name|'Connector'
op|'('
name|'base'
op|'.'
name|'BaseConnector'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'host'
op|','
name|'port'
op|','
name|'factory'
op|','
name|'timeout'
op|','
name|'bindAddress'
op|','
name|'reactor'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'host'
op|'='
name|'host'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'port'
op|','
name|'types'
op|'.'
name|'StringTypes'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'port'
op|'='
name|'socket'
op|'.'
name|'getservbyname'
op|'('
name|'port'
op|','
string|"'tcp'"
op|')'
newline|'\n'
dedent|''
name|'except'
name|'socket'
op|'.'
name|'error'
op|','
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'error'
op|'.'
name|'ServiceNameUnknownError'
op|'('
name|'string'
op|'='
string|'"%s (%r)"'
op|'%'
op|'('
name|'e'
op|','
name|'port'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'port'
op|'='
name|'port'
newline|'\n'
name|'self'
op|'.'
name|'bindAddress'
op|'='
name|'bindAddress'
newline|'\n'
name|'base'
op|'.'
name|'BaseConnector'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'factory'
op|','
name|'timeout'
op|','
name|'reactor'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_makeTransport
dedent|''
name|'def'
name|'_makeTransport'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'Client'
op|'('
name|'self'
op|'.'
name|'host'
op|','
name|'self'
op|'.'
name|'port'
op|','
name|'self'
op|'.'
name|'bindAddress'
op|','
name|'self'
op|','
name|'self'
op|'.'
name|'reactor'
op|')'
newline|'\n'
nl|'\n'
DECL|member|getDestination
dedent|''
name|'def'
name|'getDestination'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'address'
op|'.'
name|'IPv4Address'
op|'('
string|"'TCP'"
op|','
name|'self'
op|'.'
name|'host'
op|','
name|'self'
op|'.'
name|'port'
op|','
string|"'INET'"
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
