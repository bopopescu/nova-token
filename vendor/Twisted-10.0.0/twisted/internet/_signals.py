begin_unit
comment|'# -*- test-case-name: twisted.test.test_process,twisted.internet.test.test_process -*-'
nl|'\n'
comment|'# Copyright (c) 2010 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nThis module provides a uniform interface to the several mechanisms which are\npossibly available for dealing with signals.\n\nThis module is used to integrate child process termination into a\nreactor event loop.  This is a challenging feature to provide because\nmost platforms indicate process termination via SIGCHLD and do not\nprovide a way to wait for that signal and arbitrary I/O events at the\nsame time.  The naive implementation involves installing a Python\nSIGCHLD handler; unfortunately this leads to other syscalls being\ninterrupted (whenever SIGCHLD is received) and failing with EINTR\n(which almost no one is prepared to handle).  This interruption can be\ndisabled via siginterrupt(2) (or one of the equivalent mechanisms);\nhowever, if the SIGCHLD is delivered by the platform to a non-main\nthread (not a common occurrence, but difficult to prove impossible),\nthe main thread (waiting on select() or another event notification\nAPI) may not wake up leading to an arbitrary delay before the child\ntermination is noticed.\n\nThe basic solution to all these issues involves enabling SA_RESTART\n(ie, disabling system call interruption) and registering a C signal\nhandler which writes a byte to a pipe.  The other end of the pipe is\nregistered with the event loop, allowing it to wake up shortly after\nSIGCHLD is received.  See L{twisted.internet.posixbase._SIGCHLDWaker}\nfor the implementation of the event loop side of this solution.  The\nuse of a pipe this way is known as the U{self-pipe\ntrick<http://cr.yp.to/docs/selfpipe.html>}.\n\nThe actual solution implemented in this module depends on the version\nof Python.  From version 2.6, C{signal.siginterrupt} and\nC{signal.set_wakeup_fd} allow the necessary C signal handler which\nwrites to the pipe to be registered with C{SA_RESTART}.  Prior to 2.6,\nthe L{twisted.internet._sigchld} extension module provides similar\nfunctionality.\n\nIf neither of these is available, a Python signal handler is used\ninstead.  This is essentially the naive solution mentioned above and\nhas the problems described there.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'os'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'from'
name|'signal'
name|'import'
name|'set_wakeup_fd'
op|','
name|'siginterrupt'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
indent|'    '
name|'set_wakeup_fd'
op|'='
name|'siginterrupt'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'import'
name|'signal'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
DECL|variable|signal
indent|'    '
name|'signal'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'log'
name|'import'
name|'msg'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'_sigchld'
name|'import'
name|'installHandler'
name|'as'
name|'_extInstallHandler'
op|','
name|'isDefaultHandler'
name|'as'
name|'_extIsDefaultHandler'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
indent|'    '
name|'_extInstallHandler'
op|'='
name|'_extIsDefaultHandler'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|_Handler
dedent|''
name|'class'
name|'_Handler'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    L{_Handler} is a signal handler which writes a byte to a file descriptor\n    whenever it is invoked.\n\n    @ivar fd: The file descriptor to which to write.  If this is C{None},\n        nothing will be written.\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'fd'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'fd'
op|'='
name|'fd'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__call__
dedent|''
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_Handler.__call__} is the signal handler.  It will write a byte to\n        the wrapped file descriptor, if there is one.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'fd'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'write'
op|'('
name|'self'
op|'.'
name|'fd'
op|','
string|"'\\0'"
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|_installHandlerUsingSignal
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_installHandlerUsingSignal'
op|'('
name|'fd'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Install a signal handler which will write a byte to C{fd} when\n    I{SIGCHLD} is received.\n\n    This is implemented by creating an instance of L{_Handler} with C{fd}\n    and installing it as the signal handler.\n\n    @param fd: The file descriptor to which to write when I{SIGCHLD} is\n        received.\n    @type fd: C{int}\n    """'
newline|'\n'
name|'if'
name|'fd'
op|'=='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'previous'
op|'='
name|'signal'
op|'.'
name|'signal'
op|'('
name|'signal'
op|'.'
name|'SIGCHLD'
op|','
name|'signal'
op|'.'
name|'SIG_DFL'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'previous'
op|'='
name|'signal'
op|'.'
name|'signal'
op|'('
name|'signal'
op|'.'
name|'SIGCHLD'
op|','
name|'_Handler'
op|'('
name|'fd'
op|')'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'isinstance'
op|'('
name|'previous'
op|','
name|'_Handler'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'previous'
op|'.'
name|'fd'
newline|'\n'
dedent|''
name|'return'
op|'-'
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|_installHandlerUsingSetWakeup
dedent|''
name|'def'
name|'_installHandlerUsingSetWakeup'
op|'('
name|'fd'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Install a signal handler which will write a byte to C{fd} when\n    I{SIGCHLD} is received.\n\n    This is implemented by installing an instance of L{_Handler} wrapped\n    around C{None}, setting the I{SIGCHLD} handler as not allowed to\n    interrupt system calls, and using L{signal.set_wakeup_fd} to do the\n    actual writing.\n\n    @param fd: The file descriptor to which to write when I{SIGCHLD} is\n        received.\n    @type fd: C{int}\n    """'
newline|'\n'
name|'if'
name|'fd'
op|'=='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'signal'
op|'.'
name|'signal'
op|'('
name|'signal'
op|'.'
name|'SIGCHLD'
op|','
name|'signal'
op|'.'
name|'SIG_DFL'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'signal'
op|'.'
name|'signal'
op|'('
name|'signal'
op|'.'
name|'SIGCHLD'
op|','
name|'_Handler'
op|'('
name|'None'
op|')'
op|')'
newline|'\n'
name|'siginterrupt'
op|'('
name|'signal'
op|'.'
name|'SIGCHLD'
op|','
name|'False'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'set_wakeup_fd'
op|'('
name|'fd'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|_isDefaultHandler
dedent|''
name|'def'
name|'_isDefaultHandler'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Determine whether the I{SIGCHLD} handler is the default or not.\n    """'
newline|'\n'
name|'return'
name|'signal'
op|'.'
name|'getsignal'
op|'('
name|'signal'
op|'.'
name|'SIGCHLD'
op|')'
op|'=='
name|'signal'
op|'.'
name|'SIG_DFL'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|_cannotInstallHandler
dedent|''
name|'def'
name|'_cannotInstallHandler'
op|'('
name|'fd'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Fail to install a signal handler for I{SIGCHLD}.\n\n    This implementation is used when the supporting code for the other\n    implementations is unavailable (on Python versions 2.5 and older where\n    neither the L{twisted.internet._sigchld} extension nor the standard\n    L{signal} module is available).\n\n    @param fd: Ignored; only for compatibility with the other\n        implementations of this interface.\n\n    @raise RuntimeError: Always raised to indicate no I{SIGCHLD} handler can\n        be installed.\n    """'
newline|'\n'
name|'raise'
name|'RuntimeError'
op|'('
string|'"Cannot install a SIGCHLD handler"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|_cannotDetermineDefault
dedent|''
name|'def'
name|'_cannotDetermineDefault'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
name|'raise'
name|'RuntimeError'
op|'('
string|'"No usable signal API available"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
dedent|''
name|'if'
name|'set_wakeup_fd'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'    '
name|'msg'
op|'('
string|"'using set_wakeup_fd'"
op|')'
newline|'\n'
name|'installHandler'
op|'='
name|'_installHandlerUsingSetWakeup'
newline|'\n'
name|'isDefaultHandler'
op|'='
name|'_isDefaultHandler'
newline|'\n'
dedent|''
name|'elif'
name|'_extInstallHandler'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'    '
name|'msg'
op|'('
string|"'using _sigchld'"
op|')'
newline|'\n'
DECL|variable|installHandler
name|'installHandler'
op|'='
name|'_extInstallHandler'
newline|'\n'
DECL|variable|isDefaultHandler
name|'isDefaultHandler'
op|'='
name|'_extIsDefaultHandler'
newline|'\n'
dedent|''
name|'elif'
name|'signal'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'    '
name|'msg'
op|'('
string|"'using signal module'"
op|')'
newline|'\n'
DECL|variable|installHandler
name|'installHandler'
op|'='
name|'_installHandlerUsingSignal'
newline|'\n'
DECL|variable|isDefaultHandler
name|'isDefaultHandler'
op|'='
name|'_isDefaultHandler'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'    '
name|'msg'
op|'('
string|"'nothing unavailable'"
op|')'
newline|'\n'
DECL|variable|installHandler
name|'installHandler'
op|'='
name|'_cannotInstallHandler'
newline|'\n'
DECL|variable|isDefaultHandler
name|'isDefaultHandler'
op|'='
name|'_cannotDetermineDefault'
newline|'\n'
nl|'\n'
dedent|''
endmarker|''
end_unit
