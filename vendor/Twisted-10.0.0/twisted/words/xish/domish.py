begin_unit
comment|'# -*- test-case-name: twisted.words.test.test_domish -*-'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Copyright (c) 2001-2007 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nDOM-like XML processing support.\n\nThis module provides support for parsing XML into DOM-like object structures\nand serializing such structures to an XML string representation, optimized\nfor use in streaming XML applications.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'types'
newline|'\n'
nl|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'implements'
op|','
name|'Interface'
op|','
name|'Attribute'
newline|'\n'
nl|'\n'
DECL|function|_splitPrefix
name|'def'
name|'_splitPrefix'
op|'('
name|'name'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Internal method for splitting a prefixed Element name into its\n        respective parts """'
newline|'\n'
name|'ntok'
op|'='
name|'name'
op|'.'
name|'split'
op|'('
string|'":"'
op|','
number|'1'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'ntok'
op|')'
op|'=='
number|'2'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'ntok'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
name|'None'
op|','
name|'ntok'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Global map of prefixes that always get injected'
nl|'\n'
comment|"# into the serializers prefix map (note, that doesn't"
nl|'\n'
comment|"# mean they're always _USED_)"
nl|'\n'
DECL|variable|G_PREFIXES
dedent|''
dedent|''
name|'G_PREFIXES'
op|'='
op|'{'
string|'"http://www.w3.org/XML/1998/namespace"'
op|':'
string|'"xml"'
op|'}'
newline|'\n'
nl|'\n'
DECL|class|_ListSerializer
name|'class'
name|'_ListSerializer'
op|':'
newline|'\n'
indent|'    '
string|'""" Internal class which serializes an Element tree into a buffer """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'prefixes'
op|'='
name|'None'
op|','
name|'prefixesInScope'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'writelist'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'prefixes'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'if'
name|'prefixes'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'prefixes'
op|'.'
name|'update'
op|'('
name|'prefixes'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'prefixes'
op|'.'
name|'update'
op|'('
name|'G_PREFIXES'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'prefixStack'
op|'='
op|'['
name|'G_PREFIXES'
op|'.'
name|'values'
op|'('
op|')'
op|']'
op|'+'
op|'('
name|'prefixesInScope'
name|'or'
op|'['
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'prefixCounter'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|member|getValue
dedent|''
name|'def'
name|'getValue'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|'u""'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'writelist'
op|')'
newline|'\n'
nl|'\n'
DECL|member|getPrefix
dedent|''
name|'def'
name|'getPrefix'
op|'('
name|'self'
op|','
name|'uri'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'self'
op|'.'
name|'prefixes'
op|'.'
name|'has_key'
op|'('
name|'uri'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'prefixes'
op|'['
name|'uri'
op|']'
op|'='
string|'"xn%d"'
op|'%'
op|'('
name|'self'
op|'.'
name|'prefixCounter'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'prefixCounter'
op|'='
name|'self'
op|'.'
name|'prefixCounter'
op|'+'
number|'1'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'prefixes'
op|'['
name|'uri'
op|']'
newline|'\n'
nl|'\n'
DECL|member|prefixInScope
dedent|''
name|'def'
name|'prefixInScope'
op|'('
name|'self'
op|','
name|'prefix'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'stack'
op|'='
name|'self'
op|'.'
name|'prefixStack'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
op|'-'
number|'1'
op|','
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'prefixStack'
op|')'
op|'+'
number|'1'
op|')'
op|'*'
op|'-'
number|'1'
op|','
op|'-'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'prefix'
name|'in'
name|'stack'
op|'['
name|'i'
op|']'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|serialize
dedent|''
name|'def'
name|'serialize'
op|'('
name|'self'
op|','
name|'elem'
op|','
name|'closeElement'
op|'='
number|'1'
op|','
name|'defaultUri'
op|'='
string|"''"
op|')'
op|':'
newline|'\n'
comment|'# Optimization shortcuts'
nl|'\n'
indent|'        '
name|'write'
op|'='
name|'self'
op|'.'
name|'writelist'
op|'.'
name|'append'
newline|'\n'
nl|'\n'
comment|"# Shortcut, check to see if elem is actually a chunk o' serialized XML"
nl|'\n'
name|'if'
name|'isinstance'
op|'('
name|'elem'
op|','
name|'SerializedXML'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'write'
op|'('
name|'elem'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
comment|'# Shortcut, check to see if elem is actually a string (aka Cdata)'
nl|'\n'
dedent|''
name|'if'
name|'isinstance'
op|'('
name|'elem'
op|','
name|'types'
op|'.'
name|'StringTypes'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'write'
op|'('
name|'escapeToXml'
op|'('
name|'elem'
op|')'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
comment|'# Further optimizations'
nl|'\n'
dedent|''
name|'parent'
op|'='
name|'elem'
op|'.'
name|'parent'
newline|'\n'
name|'name'
op|'='
name|'elem'
op|'.'
name|'name'
newline|'\n'
name|'uri'
op|'='
name|'elem'
op|'.'
name|'uri'
newline|'\n'
name|'defaultUri'
op|','
name|'currentDefaultUri'
op|'='
name|'elem'
op|'.'
name|'defaultUri'
op|','
name|'defaultUri'
newline|'\n'
nl|'\n'
name|'for'
name|'p'
op|','
name|'u'
name|'in'
name|'elem'
op|'.'
name|'localPrefixes'
op|'.'
name|'iteritems'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'prefixes'
op|'['
name|'u'
op|']'
op|'='
name|'p'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'prefixStack'
op|'.'
name|'append'
op|'('
name|'elem'
op|'.'
name|'localPrefixes'
op|'.'
name|'keys'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Inherit the default namespace'
nl|'\n'
name|'if'
name|'defaultUri'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'defaultUri'
op|'='
name|'currentDefaultUri'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'uri'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'uri'
op|'='
name|'defaultUri'
newline|'\n'
nl|'\n'
dedent|''
name|'prefix'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'uri'
op|'!='
name|'defaultUri'
name|'or'
name|'uri'
name|'in'
name|'self'
op|'.'
name|'prefixes'
op|':'
newline|'\n'
indent|'            '
name|'prefix'
op|'='
name|'self'
op|'.'
name|'getPrefix'
op|'('
name|'uri'
op|')'
newline|'\n'
name|'inScope'
op|'='
name|'self'
op|'.'
name|'prefixInScope'
op|'('
name|'prefix'
op|')'
newline|'\n'
nl|'\n'
comment|'# Create the starttag'
nl|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'prefix'
op|':'
newline|'\n'
indent|'            '
name|'write'
op|'('
string|'"<%s"'
op|'%'
op|'('
name|'name'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'write'
op|'('
string|'"<%s:%s"'
op|'%'
op|'('
name|'prefix'
op|','
name|'name'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'inScope'
op|':'
newline|'\n'
indent|'                '
name|'write'
op|'('
string|'" xmlns:%s=\'%s\'"'
op|'%'
op|'('
name|'prefix'
op|','
name|'uri'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'prefixStack'
op|'['
op|'-'
number|'1'
op|']'
op|'.'
name|'append'
op|'('
name|'prefix'
op|')'
newline|'\n'
name|'inScope'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'defaultUri'
op|'!='
name|'currentDefaultUri'
name|'and'
op|'('
name|'uri'
op|'!='
name|'defaultUri'
name|'or'
name|'not'
name|'prefix'
name|'or'
name|'not'
name|'inScope'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'write'
op|'('
string|'" xmlns=\'%s\'"'
op|'%'
op|'('
name|'defaultUri'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'p'
op|','
name|'u'
name|'in'
name|'elem'
op|'.'
name|'localPrefixes'
op|'.'
name|'iteritems'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'write'
op|'('
string|'" xmlns:%s=\'%s\'"'
op|'%'
op|'('
name|'p'
op|','
name|'u'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Serialize attributes'
nl|'\n'
dedent|''
name|'for'
name|'k'
op|','
name|'v'
name|'in'
name|'elem'
op|'.'
name|'attributes'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
comment|"# If the attribute name is a tuple, it's a qualified attribute"
nl|'\n'
indent|'            '
name|'if'
name|'isinstance'
op|'('
name|'k'
op|','
name|'types'
op|'.'
name|'TupleType'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'attr_uri'
op|','
name|'attr_name'
op|'='
name|'k'
newline|'\n'
name|'attr_prefix'
op|'='
name|'self'
op|'.'
name|'getPrefix'
op|'('
name|'attr_uri'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'prefixInScope'
op|'('
name|'attr_prefix'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'write'
op|'('
string|'" xmlns:%s=\'%s\'"'
op|'%'
op|'('
name|'attr_prefix'
op|','
name|'attr_uri'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'prefixStack'
op|'['
op|'-'
number|'1'
op|']'
op|'.'
name|'append'
op|'('
name|'attr_prefix'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'write'
op|'('
string|'" %s:%s=\'%s\'"'
op|'%'
op|'('
name|'attr_prefix'
op|','
name|'attr_name'
op|','
nl|'\n'
name|'escapeToXml'
op|'('
name|'v'
op|','
number|'1'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'write'
op|'('
op|'('
string|'" %s=\'%s\'"'
op|'%'
op|'('
name|'k'
op|','
name|'escapeToXml'
op|'('
name|'v'
op|','
number|'1'
op|')'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Shortcut out if this is only going to return'
nl|'\n'
comment|'# the element (i.e. no children)'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'closeElement'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'write'
op|'('
string|'">"'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
comment|'# Serialize children'
nl|'\n'
dedent|''
name|'if'
name|'len'
op|'('
name|'elem'
op|'.'
name|'children'
op|')'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'write'
op|'('
string|'">"'
op|')'
newline|'\n'
name|'for'
name|'c'
name|'in'
name|'elem'
op|'.'
name|'children'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'serialize'
op|'('
name|'c'
op|','
name|'defaultUri'
op|'='
name|'defaultUri'
op|')'
newline|'\n'
comment|'# Add closing tag'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'prefix'
op|':'
newline|'\n'
indent|'                '
name|'write'
op|'('
string|'"</%s>"'
op|'%'
op|'('
name|'name'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'write'
op|'('
string|'"</%s:%s>"'
op|'%'
op|'('
name|'prefix'
op|','
name|'name'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'write'
op|'('
string|'"/>"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'prefixStack'
op|'.'
name|'pop'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|SerializerClass
dedent|''
dedent|''
name|'SerializerClass'
op|'='
name|'_ListSerializer'
newline|'\n'
nl|'\n'
DECL|function|escapeToXml
name|'def'
name|'escapeToXml'
op|'('
name|'text'
op|','
name|'isattrib'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Escape text to proper XML form, per section 2.3 in the XML specification.\n\n    @type text: L{str}\n    @param text: Text to escape\n\n    @type isattrib: L{bool}\n    @param isattrib: Triggers escaping of characters necessary for use as\n                     attribute values\n    """'
newline|'\n'
name|'text'
op|'='
name|'text'
op|'.'
name|'replace'
op|'('
string|'"&"'
op|','
string|'"&amp;"'
op|')'
newline|'\n'
name|'text'
op|'='
name|'text'
op|'.'
name|'replace'
op|'('
string|'"<"'
op|','
string|'"&lt;"'
op|')'
newline|'\n'
name|'text'
op|'='
name|'text'
op|'.'
name|'replace'
op|'('
string|'">"'
op|','
string|'"&gt;"'
op|')'
newline|'\n'
name|'if'
name|'isattrib'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'text'
op|'='
name|'text'
op|'.'
name|'replace'
op|'('
string|'"\'"'
op|','
string|'"&apos;"'
op|')'
newline|'\n'
name|'text'
op|'='
name|'text'
op|'.'
name|'replace'
op|'('
string|'"\\""'
op|','
string|'"&quot;"'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'text'
newline|'\n'
nl|'\n'
DECL|function|unescapeFromXml
dedent|''
name|'def'
name|'unescapeFromXml'
op|'('
name|'text'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'text'
op|'='
name|'text'
op|'.'
name|'replace'
op|'('
string|'"&lt;"'
op|','
string|'"<"'
op|')'
newline|'\n'
name|'text'
op|'='
name|'text'
op|'.'
name|'replace'
op|'('
string|'"&gt;"'
op|','
string|'">"'
op|')'
newline|'\n'
name|'text'
op|'='
name|'text'
op|'.'
name|'replace'
op|'('
string|'"&apos;"'
op|','
string|'"\'"'
op|')'
newline|'\n'
name|'text'
op|'='
name|'text'
op|'.'
name|'replace'
op|'('
string|'"&quot;"'
op|','
string|'"\\""'
op|')'
newline|'\n'
name|'text'
op|'='
name|'text'
op|'.'
name|'replace'
op|'('
string|'"&amp;"'
op|','
string|'"&"'
op|')'
newline|'\n'
name|'return'
name|'text'
newline|'\n'
nl|'\n'
DECL|function|generateOnlyInterface
dedent|''
name|'def'
name|'generateOnlyInterface'
op|'('
name|'list'
op|','
name|'int'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Filters items in a list by class\n    """'
newline|'\n'
name|'for'
name|'n'
name|'in'
name|'list'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'int'
op|'.'
name|'providedBy'
op|'('
name|'n'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'yield'
name|'n'
newline|'\n'
nl|'\n'
DECL|function|generateElementsQNamed
dedent|''
dedent|''
dedent|''
name|'def'
name|'generateElementsQNamed'
op|'('
name|'list'
op|','
name|'name'
op|','
name|'uri'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Filters Element items in a list with matching name and URI. """'
newline|'\n'
name|'for'
name|'n'
name|'in'
name|'list'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'IElement'
op|'.'
name|'providedBy'
op|'('
name|'n'
op|')'
name|'and'
name|'n'
op|'.'
name|'name'
op|'=='
name|'name'
name|'and'
name|'n'
op|'.'
name|'uri'
op|'=='
name|'uri'
op|':'
newline|'\n'
indent|'            '
name|'yield'
name|'n'
newline|'\n'
nl|'\n'
DECL|function|generateElementsNamed
dedent|''
dedent|''
dedent|''
name|'def'
name|'generateElementsNamed'
op|'('
name|'list'
op|','
name|'name'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Filters Element items in a list with matching name, regardless of URI.\n    """'
newline|'\n'
name|'for'
name|'n'
name|'in'
name|'list'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'IElement'
op|'.'
name|'providedBy'
op|'('
name|'n'
op|')'
name|'and'
name|'n'
op|'.'
name|'name'
op|'=='
name|'name'
op|':'
newline|'\n'
indent|'            '
name|'yield'
name|'n'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|SerializedXML
dedent|''
dedent|''
dedent|''
name|'class'
name|'SerializedXML'
op|'('
name|'unicode'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Marker class for pre-serialized XML in the DOM. """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Namespace
dedent|''
name|'class'
name|'Namespace'
op|':'
newline|'\n'
indent|'    '
string|'""" Convenience object for tracking namespace declarations. """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'uri'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_uri'
op|'='
name|'uri'
newline|'\n'
DECL|member|__getattr__
dedent|''
name|'def'
name|'__getattr__'
op|'('
name|'self'
op|','
name|'n'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
name|'self'
op|'.'
name|'_uri'
op|','
name|'n'
op|')'
newline|'\n'
DECL|member|__getitem__
dedent|''
name|'def'
name|'__getitem__'
op|'('
name|'self'
op|','
name|'n'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
name|'self'
op|'.'
name|'_uri'
op|','
name|'n'
op|')'
newline|'\n'
nl|'\n'
DECL|class|IElement
dedent|''
dedent|''
name|'class'
name|'IElement'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Interface to XML element nodes.\n\n    See L{Element} for a detailed example of its general use.\n\n    Warning: this Interface is not yet complete!\n    """'
newline|'\n'
nl|'\n'
name|'uri'
op|'='
name|'Attribute'
op|'('
string|'""" Element\'s namespace URI """'
op|')'
newline|'\n'
name|'name'
op|'='
name|'Attribute'
op|'('
string|'""" Element\'s local name """'
op|')'
newline|'\n'
name|'defaultUri'
op|'='
name|'Attribute'
op|'('
string|'""" Default namespace URI of child elements """'
op|')'
newline|'\n'
name|'attributes'
op|'='
name|'Attribute'
op|'('
string|'""" Dictionary of element attributes """'
op|')'
newline|'\n'
name|'children'
op|'='
name|'Attribute'
op|'('
string|'""" List of child nodes """'
op|')'
newline|'\n'
name|'parent'
op|'='
name|'Attribute'
op|'('
string|'""" Reference to element\'s parent element """'
op|')'
newline|'\n'
name|'localPrefixes'
op|'='
name|'Attribute'
op|'('
string|'""" Dictionary of local prefixes """'
op|')'
newline|'\n'
nl|'\n'
DECL|member|toXml
name|'def'
name|'toXml'
op|'('
name|'prefixes'
op|'='
name|'None'
op|','
name|'closeElement'
op|'='
number|'1'
op|','
name|'defaultUri'
op|'='
string|"''"
op|','
nl|'\n'
name|'prefixesInScope'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Serializes object to a (partial) XML document\n\n        @param prefixes: dictionary that maps namespace URIs to suggested\n                         prefix names.\n        @type prefixes: L{dict}\n        @param closeElement: flag that determines whether to include the\n                             closing tag of the element in the serialized\n                             string. A value of C{0} only generates the\n                             element\'s start tag. A value of C{1} yields a\n                             complete serialization.\n        @type closeElement: L{int}\n        @param defaultUri: Initial default namespace URI. This is most useful\n                           for partial rendering, where the logical parent\n                           element (of which the starttag was already\n                           serialized) declares a default namespace that should\n                           be inherited.\n        @type defaultUri: L{str}\n        @param prefixesInScope: list of prefixes that are assumed to be\n                                declared by ancestors.\n        @type prefixesInScope: L{list}\n        @return: (partial) serialized XML\n        @rtype: L{unicode}\n        """'
newline|'\n'
nl|'\n'
DECL|member|addElement
dedent|''
name|'def'
name|'addElement'
op|'('
name|'name'
op|','
name|'defaultUri'
op|'='
name|'None'
op|','
name|'content'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Create an element and add as child.\n\n        The new element is added to this element as a child, and will have\n        this element as its parent.\n\n        @param name: element name. This can be either a L{unicode} object that\n                     contains the local name, or a tuple of (uri, local_name)\n                     for a fully qualified name. In the former case,\n                     the namespace URI is inherited from this element.\n        @type name: L{unicode} or L{tuple} of (L{unicode}, L{unicode})\n        @param defaultUri: default namespace URI for child elements. If\n                           C{None}, this is inherited from this element.\n        @type defaultUri: L{unicode}\n        @param content: text contained by the new element.\n        @type content: L{unicode}\n        @return: the created element\n        @rtype: object providing L{IElement}\n        """'
newline|'\n'
nl|'\n'
DECL|member|addChild
dedent|''
name|'def'
name|'addChild'
op|'('
name|'node'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Adds a node as child of this element.\n\n        The C{node} will be added to the list of childs of this element, and\n        will have this element set as its parent when C{node} provides\n        L{IElement}.\n\n        @param node: the child node.\n        @type node: L{unicode} or object implementing L{IElement}\n        """'
newline|'\n'
nl|'\n'
DECL|class|Element
dedent|''
dedent|''
name|'class'
name|'Element'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Represents an XML element node.\n\n    An Element contains a series of attributes (name/value pairs), content\n    (character data), and other child Element objects. When building a document\n    with markup (such as HTML or XML), use this object as the starting point.\n\n    Element objects fully support XML Namespaces. The fully qualified name of\n    the XML Element it represents is stored in the C{uri} and C{name}\n    attributes, where C{uri} holds the namespace URI. There is also a default\n    namespace, for child elements. This is stored in the C{defaultUri}\n    attribute. Note that C{\'\'} means the empty namespace.\n\n    Serialization of Elements through C{toXml()} will use these attributes\n    for generating proper serialized XML. When both C{uri} and C{defaultUri}\n    are not None in the Element and all of its descendents, serialization\n    proceeds as expected:\n\n      >>> from twisted.words.xish import domish\n      >>> root = domish.Element((\'myns\', \'root\'))\n      >>> root.addElement(\'child\', content=\'test\')\n      <twisted.words.xish.domish.Element object at 0x83002ac>\n      >>> root.toXml()\n      u"<root xmlns=\'myns\'><child>test</child></root>"\n\n    For partial serialization, needed for streaming XML, a special value for\n    namespace URIs can be used: C{None}.\n\n    Using C{None} as the value for C{uri} means: this element is in whatever\n    namespace inherited by the closest logical ancestor when the complete XML\n    document has been serialized. The serialized start tag will have a\n    non-prefixed name, and no xmlns declaration will be generated.\n\n    Similarly, C{None} for C{defaultUri} means: the default namespace for my\n    child elements is inherited from the logical ancestors of this element,\n    when the complete XML document has been serialized.\n\n    To illustrate, an example from a Jabber stream. Assume the start tag of the\n    root element of the stream has already been serialized, along with several\n    complete child elements, and sent off, looking like this::\n\n      <stream:stream xmlns:stream=\'http://etherx.jabber.org/streams\'\n                     xmlns=\'jabber:client\' to=\'example.com\'>\n        ...\n\n    Now suppose we want to send a complete element represented by an\n    object C{message} created like:\n\n      >>> message = domish.Element((None, \'message\'))\n      >>> message[\'to\'] = \'user@example.com\'\n      >>> message.addElement(\'body\', content=\'Hi!\')\n      <twisted.words.xish.domish.Element object at 0x8276e8c>\n      >>> message.toXml()\n      u"<message to=\'user@example.com\'><body>Hi!</body></message>"\n\n    As, you can see, this XML snippet has no xmlns declaration. When sent\n    off, it inherits the C{jabber:client} namespace from the root element.\n    Note that this renders the same as using C{\'\'} instead of C{None}:\n\n      >>> presence = domish.Element((\'\', \'presence\'))\n      >>> presence.toXml()\n      u"<presence/>"\n\n    However, if this object has a parent defined, the difference becomes\n    clear:\n\n      >>> child = message.addElement((\'http://example.com/\', \'envelope\'))\n      >>> child.addChild(presence)\n      <twisted.words.xish.domish.Element object at 0x8276fac>\n      >>> message.toXml()\n      u"<message to=\'user@example.com\'><body>Hi!</body><envelope xmlns=\'http://example.com/\'><presence xmlns=\'\'/></envelope></message>"\n\n    As, you can see, the <presence/> element is now in the empty namespace, not\n    in the default namespace of the parent or the streams\'.\n\n    @type uri: L{unicode} or None\n    @ivar uri: URI of this Element\'s name\n\n    @type name: L{unicode}\n    @ivar name: Name of this Element\n\n    @type defaultUri: L{unicode} or None\n    @ivar defaultUri: URI this Element exists within\n\n    @type children: L{list}\n    @ivar children: List of child Elements and content\n\n    @type parent: L{Element}\n    @ivar parent: Reference to the parent Element, if any.\n\n    @type attributes: L{dict}\n    @ivar attributes: Dictionary of attributes associated with this Element.\n\n    @type localPrefixes: L{dict}\n    @ivar localPrefixes: Dictionary of namespace declarations on this\n                         element. The key is the prefix to bind the\n                         namespace uri to.\n    """'
newline|'\n'
nl|'\n'
name|'implements'
op|'('
name|'IElement'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|_idCounter
name|'_idCounter'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'qname'
op|','
name|'defaultUri'
op|'='
name|'None'
op|','
name|'attribs'
op|'='
name|'None'
op|','
nl|'\n'
name|'localPrefixes'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @param qname: Tuple of (uri, name)\n        @param defaultUri: The default URI of the element; defaults to the URI\n                           specified in L{qname}\n        @param attribs: Dictionary of attributes\n        @param localPrefixes: Dictionary of namespace declarations on this\n                              element. The key is the prefix to bind the\n                              namespace uri to.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'localPrefixes'
op|'='
name|'localPrefixes'
name|'or'
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'uri'
op|','
name|'self'
op|'.'
name|'name'
op|'='
name|'qname'
newline|'\n'
name|'if'
name|'defaultUri'
name|'is'
name|'None'
name|'and'
name|'self'
op|'.'
name|'uri'
name|'not'
name|'in'
name|'self'
op|'.'
name|'localPrefixes'
op|'.'
name|'itervalues'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'defaultUri'
op|'='
name|'self'
op|'.'
name|'uri'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'defaultUri'
op|'='
name|'defaultUri'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'attributes'
op|'='
name|'attribs'
name|'or'
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'children'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'parent'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|__getattr__
dedent|''
name|'def'
name|'__getattr__'
op|'('
name|'self'
op|','
name|'key'
op|')'
op|':'
newline|'\n'
comment|'# Check child list for first Element with a name matching the key'
nl|'\n'
indent|'        '
name|'for'
name|'n'
name|'in'
name|'self'
op|'.'
name|'children'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'IElement'
op|'.'
name|'providedBy'
op|'('
name|'n'
op|')'
name|'and'
name|'n'
op|'.'
name|'name'
op|'=='
name|'key'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'n'
newline|'\n'
nl|'\n'
comment|"# Tweak the behaviour so that it's more friendly about not"
nl|'\n'
comment|'# finding elements -- we need to document this somewhere :)'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'key'
op|'.'
name|'startswith'
op|'('
string|"'_'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'AttributeError'
op|'('
name|'key'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
DECL|member|__getitem__
dedent|''
dedent|''
name|'def'
name|'__getitem__'
op|'('
name|'self'
op|','
name|'key'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'attributes'
op|'['
name|'self'
op|'.'
name|'_dqa'
op|'('
name|'key'
op|')'
op|']'
newline|'\n'
nl|'\n'
DECL|member|__delitem__
dedent|''
name|'def'
name|'__delitem__'
op|'('
name|'self'
op|','
name|'key'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'del'
name|'self'
op|'.'
name|'attributes'
op|'['
name|'self'
op|'.'
name|'_dqa'
op|'('
name|'key'
op|')'
op|']'
op|';'
newline|'\n'
nl|'\n'
DECL|member|__setitem__
dedent|''
name|'def'
name|'__setitem__'
op|'('
name|'self'
op|','
name|'key'
op|','
name|'value'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'attributes'
op|'['
name|'self'
op|'.'
name|'_dqa'
op|'('
name|'key'
op|')'
op|']'
op|'='
name|'value'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Retrieve the first CData (content) node\n        """'
newline|'\n'
name|'for'
name|'n'
name|'in'
name|'self'
op|'.'
name|'children'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'isinstance'
op|'('
name|'n'
op|','
name|'types'
op|'.'
name|'StringTypes'
op|')'
op|':'
name|'return'
name|'n'
newline|'\n'
dedent|''
name|'return'
string|'""'
newline|'\n'
nl|'\n'
DECL|member|_dqa
dedent|''
name|'def'
name|'_dqa'
op|'('
name|'self'
op|','
name|'attr'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Dequalify an attribute key as needed """'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'attr'
op|','
name|'types'
op|'.'
name|'TupleType'
op|')'
name|'and'
name|'not'
name|'attr'
op|'['
number|'0'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'attr'
op|'['
number|'1'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'attr'
newline|'\n'
nl|'\n'
DECL|member|getAttribute
dedent|''
dedent|''
name|'def'
name|'getAttribute'
op|'('
name|'self'
op|','
name|'attribname'
op|','
name|'default'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Retrieve the value of attribname, if it exists """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'attributes'
op|'.'
name|'get'
op|'('
name|'attribname'
op|','
name|'default'
op|')'
newline|'\n'
nl|'\n'
DECL|member|hasAttribute
dedent|''
name|'def'
name|'hasAttribute'
op|'('
name|'self'
op|','
name|'attrib'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Determine if the specified attribute exists """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'attributes'
op|'.'
name|'has_key'
op|'('
name|'self'
op|'.'
name|'_dqa'
op|'('
name|'attrib'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|compareAttribute
dedent|''
name|'def'
name|'compareAttribute'
op|'('
name|'self'
op|','
name|'attrib'
op|','
name|'value'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Safely compare the value of an attribute against a provided value.\n\n        C{None}-safe.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'attributes'
op|'.'
name|'get'
op|'('
name|'self'
op|'.'
name|'_dqa'
op|'('
name|'attrib'
op|')'
op|','
name|'None'
op|')'
op|'=='
name|'value'
newline|'\n'
nl|'\n'
DECL|member|swapAttributeValues
dedent|''
name|'def'
name|'swapAttributeValues'
op|'('
name|'self'
op|','
name|'left'
op|','
name|'right'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Swap the values of two attribute. """'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'attributes'
newline|'\n'
name|'l'
op|'='
name|'d'
op|'['
name|'left'
op|']'
newline|'\n'
name|'d'
op|'['
name|'left'
op|']'
op|'='
name|'d'
op|'['
name|'right'
op|']'
newline|'\n'
name|'d'
op|'['
name|'right'
op|']'
op|'='
name|'l'
newline|'\n'
nl|'\n'
DECL|member|addChild
dedent|''
name|'def'
name|'addChild'
op|'('
name|'self'
op|','
name|'node'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Add a child to this Element. """'
newline|'\n'
name|'if'
name|'IElement'
op|'.'
name|'providedBy'
op|'('
name|'node'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'node'
op|'.'
name|'parent'
op|'='
name|'self'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'children'
op|'.'
name|'append'
op|'('
name|'node'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'children'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
nl|'\n'
DECL|member|addContent
dedent|''
name|'def'
name|'addContent'
op|'('
name|'self'
op|','
name|'text'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Add some text data to this Element. """'
newline|'\n'
name|'c'
op|'='
name|'self'
op|'.'
name|'children'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'c'
op|')'
op|'>'
number|'0'
name|'and'
name|'isinstance'
op|'('
name|'c'
op|'['
op|'-'
number|'1'
op|']'
op|','
name|'types'
op|'.'
name|'StringTypes'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'c'
op|'['
op|'-'
number|'1'
op|']'
op|'='
name|'c'
op|'['
op|'-'
number|'1'
op|']'
op|'+'
name|'text'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'c'
op|'.'
name|'append'
op|'('
name|'text'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'c'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
nl|'\n'
DECL|member|addElement
dedent|''
name|'def'
name|'addElement'
op|'('
name|'self'
op|','
name|'name'
op|','
name|'defaultUri'
op|'='
name|'None'
op|','
name|'content'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'result'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'name'
op|','
name|'type'
op|'('
op|'('
op|')'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'defaultUri'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'defaultUri'
op|'='
name|'name'
op|'['
number|'0'
op|']'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'children'
op|'.'
name|'append'
op|'('
name|'Element'
op|'('
name|'name'
op|','
name|'defaultUri'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'defaultUri'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'defaultUri'
op|'='
name|'self'
op|'.'
name|'defaultUri'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'children'
op|'.'
name|'append'
op|'('
name|'Element'
op|'('
op|'('
name|'defaultUri'
op|','
name|'name'
op|')'
op|','
name|'defaultUri'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'result'
op|'='
name|'self'
op|'.'
name|'children'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
name|'result'
op|'.'
name|'parent'
op|'='
name|'self'
newline|'\n'
nl|'\n'
name|'if'
name|'content'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'.'
name|'children'
op|'.'
name|'append'
op|'('
name|'content'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
DECL|member|addRawXml
dedent|''
name|'def'
name|'addRawXml'
op|'('
name|'self'
op|','
name|'rawxmlstring'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Add a pre-serialized chunk o\' XML as a child of this Element. """'
newline|'\n'
name|'self'
op|'.'
name|'children'
op|'.'
name|'append'
op|'('
name|'SerializedXML'
op|'('
name|'rawxmlstring'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|addUniqueId
dedent|''
name|'def'
name|'addUniqueId'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Add a unique (across a given Python session) id attribute to this\n            Element.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'attributes'
op|'['
string|'"id"'
op|']'
op|'='
string|'"H_%d"'
op|'%'
name|'Element'
op|'.'
name|'_idCounter'
newline|'\n'
name|'Element'
op|'.'
name|'_idCounter'
op|'='
name|'Element'
op|'.'
name|'_idCounter'
op|'+'
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|elements
dedent|''
name|'def'
name|'elements'
op|'('
name|'self'
op|','
name|'uri'
op|'='
name|'None'
op|','
name|'name'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Iterate across all children of this Element that are Elements.\n\n        Returns a generator over the child elements. If both the C{uri} and\n        C{name} parameters are set, the returned generator will only yield\n        on elements matching the qualified name.\n\n        @param uri: Optional element URI.\n        @type uri: C{unicode}\n        @param name: Optional element name.\n        @type name: C{unicode}\n        @return: Iterator that yields objects implementing L{IElement}.\n        """'
newline|'\n'
name|'if'
name|'name'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'generateOnlyInterface'
op|'('
name|'self'
op|'.'
name|'children'
op|','
name|'IElement'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'generateElementsQNamed'
op|'('
name|'self'
op|'.'
name|'children'
op|','
name|'name'
op|','
name|'uri'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|toXml
dedent|''
dedent|''
name|'def'
name|'toXml'
op|'('
name|'self'
op|','
name|'prefixes'
op|'='
name|'None'
op|','
name|'closeElement'
op|'='
number|'1'
op|','
name|'defaultUri'
op|'='
string|"''"
op|','
nl|'\n'
name|'prefixesInScope'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Serialize this Element and all children to a string. """'
newline|'\n'
name|'s'
op|'='
name|'SerializerClass'
op|'('
name|'prefixes'
op|'='
name|'prefixes'
op|','
name|'prefixesInScope'
op|'='
name|'prefixesInScope'
op|')'
newline|'\n'
name|'s'
op|'.'
name|'serialize'
op|'('
name|'self'
op|','
name|'closeElement'
op|'='
name|'closeElement'
op|','
name|'defaultUri'
op|'='
name|'defaultUri'
op|')'
newline|'\n'
name|'return'
name|'s'
op|'.'
name|'getValue'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|firstChildElement
dedent|''
name|'def'
name|'firstChildElement'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'c'
name|'in'
name|'self'
op|'.'
name|'children'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'IElement'
op|'.'
name|'providedBy'
op|'('
name|'c'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'c'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ParserError
dedent|''
dedent|''
name|'class'
name|'ParserError'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Exception thrown when a parsing error occurs """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
DECL|function|elementStream
dedent|''
name|'def'
name|'elementStream'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Preferred method to construct an ElementStream\n\n    Uses Expat-based stream if available, and falls back to Sux if necessary.\n    """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'es'
op|'='
name|'ExpatElementStream'
op|'('
op|')'
newline|'\n'
name|'return'
name|'es'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'SuxElementStream'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'Exception'
op|'('
string|'"No parsers available :("'
op|')'
newline|'\n'
dedent|''
name|'es'
op|'='
name|'SuxElementStream'
op|'('
op|')'
newline|'\n'
name|'return'
name|'es'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'from'
name|'twisted'
op|'.'
name|'web'
name|'import'
name|'sux'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
DECL|variable|SuxElementStream
indent|'    '
name|'SuxElementStream'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
DECL|class|SuxElementStream
indent|'    '
name|'class'
name|'SuxElementStream'
op|'('
name|'sux'
op|'.'
name|'XMLParser'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'        '
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'connectionMade'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'DocumentStartEvent'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'ElementEvent'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'DocumentEndEvent'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'currElem'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'rootElem'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'documentStarted'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'defaultNsStack'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'prefixStack'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|parse
dedent|''
name|'def'
name|'parse'
op|'('
name|'self'
op|','
name|'buffer'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'dataReceived'
op|'('
name|'buffer'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'sux'
op|'.'
name|'ParseError'
op|','
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'ParserError'
op|','
name|'str'
op|'('
name|'e'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|findUri
dedent|''
dedent|''
name|'def'
name|'findUri'
op|'('
name|'self'
op|','
name|'prefix'
op|')'
op|':'
newline|'\n'
comment|'# Walk prefix stack backwards, looking for the uri'
nl|'\n'
comment|'# matching the specified prefix'
nl|'\n'
indent|'            '
name|'stack'
op|'='
name|'self'
op|'.'
name|'prefixStack'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
op|'-'
number|'1'
op|','
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'prefixStack'
op|')'
op|'+'
number|'1'
op|')'
op|'*'
op|'-'
number|'1'
op|','
op|'-'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'prefix'
name|'in'
name|'stack'
op|'['
name|'i'
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'stack'
op|'['
name|'i'
op|']'
op|'['
name|'prefix'
op|']'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'None'
newline|'\n'
nl|'\n'
DECL|member|gotTagStart
dedent|''
name|'def'
name|'gotTagStart'
op|'('
name|'self'
op|','
name|'name'
op|','
name|'attributes'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'defaultUri'
op|'='
name|'None'
newline|'\n'
name|'localPrefixes'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'attribs'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'uri'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# Pass 1 - Identify namespace decls'
nl|'\n'
name|'for'
name|'k'
op|','
name|'v'
name|'in'
name|'attributes'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'k'
op|'.'
name|'startswith'
op|'('
string|'"xmlns"'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'x'
op|','
name|'p'
op|'='
name|'_splitPrefix'
op|'('
name|'k'
op|')'
newline|'\n'
name|'if'
op|'('
name|'x'
name|'is'
name|'None'
op|')'
op|':'
comment|'# I.e.  default declaration'
newline|'\n'
indent|'                        '
name|'defaultUri'
op|'='
name|'v'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'localPrefixes'
op|'['
name|'p'
op|']'
op|'='
name|'v'
newline|'\n'
dedent|''
name|'del'
name|'attributes'
op|'['
name|'k'
op|']'
newline|'\n'
nl|'\n'
comment|'# Push namespace decls onto prefix stack'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'prefixStack'
op|'.'
name|'append'
op|'('
name|'localPrefixes'
op|')'
newline|'\n'
nl|'\n'
comment|'# Determine default namespace for this element; if there'
nl|'\n'
comment|'# is one'
nl|'\n'
name|'if'
name|'defaultUri'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'len'
op|'('
name|'self'
op|'.'
name|'defaultNsStack'
op|')'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'defaultUri'
op|'='
name|'self'
op|'.'
name|'defaultNsStack'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'defaultUri'
op|'='
string|"''"
newline|'\n'
nl|'\n'
comment|'# Fix up name'
nl|'\n'
dedent|''
dedent|''
name|'prefix'
op|','
name|'name'
op|'='
name|'_splitPrefix'
op|'('
name|'name'
op|')'
newline|'\n'
name|'if'
name|'prefix'
name|'is'
name|'None'
op|':'
comment|'# This element is in the default namespace'
newline|'\n'
indent|'                '
name|'uri'
op|'='
name|'defaultUri'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Find the URI for the prefix'
nl|'\n'
indent|'                '
name|'uri'
op|'='
name|'self'
op|'.'
name|'findUri'
op|'('
name|'prefix'
op|')'
newline|'\n'
nl|'\n'
comment|'# Pass 2 - Fix up and escape attributes'
nl|'\n'
dedent|''
name|'for'
name|'k'
op|','
name|'v'
name|'in'
name|'attributes'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'p'
op|','
name|'n'
op|'='
name|'_splitPrefix'
op|'('
name|'k'
op|')'
newline|'\n'
name|'if'
name|'p'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'attribs'
op|'['
name|'n'
op|']'
op|'='
name|'v'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'attribs'
op|'['
op|'('
name|'self'
op|'.'
name|'findUri'
op|'('
name|'p'
op|')'
op|')'
op|','
name|'n'
op|']'
op|'='
name|'unescapeFromXml'
op|'('
name|'v'
op|')'
newline|'\n'
nl|'\n'
comment|'# Construct the actual Element object'
nl|'\n'
dedent|''
dedent|''
name|'e'
op|'='
name|'Element'
op|'('
op|'('
name|'uri'
op|','
name|'name'
op|')'
op|','
name|'defaultUri'
op|','
name|'attribs'
op|','
name|'localPrefixes'
op|')'
newline|'\n'
nl|'\n'
comment|'# Save current default namespace'
nl|'\n'
name|'self'
op|'.'
name|'defaultNsStack'
op|'.'
name|'append'
op|'('
name|'defaultUri'
op|')'
newline|'\n'
nl|'\n'
comment|'# Document already started'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'documentStarted'
op|':'
newline|'\n'
comment|'# Starting a new packet'
nl|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'currElem'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'currElem'
op|'='
name|'e'
newline|'\n'
comment|'# Adding to existing element'
nl|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'currElem'
op|'='
name|'self'
op|'.'
name|'currElem'
op|'.'
name|'addChild'
op|'('
name|'e'
op|')'
newline|'\n'
comment|'# New document'
nl|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'rootElem'
op|'='
name|'e'
newline|'\n'
name|'self'
op|'.'
name|'documentStarted'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'DocumentStartEvent'
op|'('
name|'e'
op|')'
newline|'\n'
nl|'\n'
DECL|member|gotText
dedent|''
dedent|''
name|'def'
name|'gotText'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'currElem'
op|'!='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'currElem'
op|'.'
name|'addContent'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
DECL|member|gotCData
dedent|''
dedent|''
name|'def'
name|'gotCData'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'currElem'
op|'!='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'currElem'
op|'.'
name|'addContent'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
DECL|member|gotComment
dedent|''
dedent|''
name|'def'
name|'gotComment'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
comment|'# Ignore comments for the moment'
nl|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
DECL|variable|entities
dedent|''
name|'entities'
op|'='
op|'{'
string|'"amp"'
op|':'
string|'"&"'
op|','
nl|'\n'
string|'"lt"'
op|':'
string|'"<"'
op|','
nl|'\n'
string|'"gt"'
op|':'
string|'">"'
op|','
nl|'\n'
string|'"apos"'
op|':'
string|'"\'"'
op|','
nl|'\n'
string|'"quot"'
op|':'
string|'"\\""'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|gotEntityReference
name|'def'
name|'gotEntityReference'
op|'('
name|'self'
op|','
name|'entityRef'
op|')'
op|':'
newline|'\n'
comment|'# If this is an entity we know about, add it as content'
nl|'\n'
comment|'# to the current element'
nl|'\n'
indent|'            '
name|'if'
name|'entityRef'
name|'in'
name|'SuxElementStream'
op|'.'
name|'entities'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'currElem'
op|'.'
name|'addContent'
op|'('
name|'SuxElementStream'
op|'.'
name|'entities'
op|'['
name|'entityRef'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|gotTagEnd
dedent|''
dedent|''
name|'def'
name|'gotTagEnd'
op|'('
name|'self'
op|','
name|'name'
op|')'
op|':'
newline|'\n'
comment|"# Ensure the document hasn't already ended"
nl|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'rootElem'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|'# XXX: Write more legible explanation'
nl|'\n'
indent|'                '
name|'raise'
name|'ParserError'
op|','
string|'"Element closed after end of document."'
newline|'\n'
nl|'\n'
comment|'# Fix up name'
nl|'\n'
dedent|''
name|'prefix'
op|','
name|'name'
op|'='
name|'_splitPrefix'
op|'('
name|'name'
op|')'
newline|'\n'
name|'if'
name|'prefix'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'uri'
op|'='
name|'self'
op|'.'
name|'defaultNsStack'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'uri'
op|'='
name|'self'
op|'.'
name|'findUri'
op|'('
name|'prefix'
op|')'
newline|'\n'
nl|'\n'
comment|'# End of document'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'currElem'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|'# Ensure element name and uri matches'
nl|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'rootElem'
op|'.'
name|'name'
op|'!='
name|'name'
name|'or'
name|'self'
op|'.'
name|'rootElem'
op|'.'
name|'uri'
op|'!='
name|'uri'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'ParserError'
op|','
string|'"Mismatched root elements"'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'DocumentEndEvent'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'rootElem'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# Other elements'
nl|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Ensure the tag being closed matches the name of the current'
nl|'\n'
comment|'# element'
nl|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'currElem'
op|'.'
name|'name'
op|'!='
name|'name'
name|'or'
name|'self'
op|'.'
name|'currElem'
op|'.'
name|'uri'
op|'!='
name|'uri'
op|':'
newline|'\n'
comment|'# XXX: Write more legible explanation'
nl|'\n'
indent|'                    '
name|'raise'
name|'ParserError'
op|','
string|'"Malformed element close"'
newline|'\n'
nl|'\n'
comment|'# Pop prefix and default NS stack'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'prefixStack'
op|'.'
name|'pop'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'defaultNsStack'
op|'.'
name|'pop'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Check for parent null parent of current elem;'
nl|'\n'
comment|"# that's the top of the stack"
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'currElem'
op|'.'
name|'parent'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'currElem'
op|'.'
name|'parent'
op|'='
name|'self'
op|'.'
name|'rootElem'
newline|'\n'
name|'self'
op|'.'
name|'ElementEvent'
op|'('
name|'self'
op|'.'
name|'currElem'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'currElem'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# Anything else is just some element wrapping up'
nl|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'currElem'
op|'='
name|'self'
op|'.'
name|'currElem'
op|'.'
name|'parent'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ExpatElementStream
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'class'
name|'ExpatElementStream'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'import'
name|'pyexpat'
newline|'\n'
name|'self'
op|'.'
name|'DocumentStartEvent'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'ElementEvent'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'DocumentEndEvent'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'error'
op|'='
name|'pyexpat'
op|'.'
name|'error'
newline|'\n'
name|'self'
op|'.'
name|'parser'
op|'='
name|'pyexpat'
op|'.'
name|'ParserCreate'
op|'('
string|'"UTF-8"'
op|','
string|'" "'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'parser'
op|'.'
name|'StartElementHandler'
op|'='
name|'self'
op|'.'
name|'_onStartElement'
newline|'\n'
name|'self'
op|'.'
name|'parser'
op|'.'
name|'EndElementHandler'
op|'='
name|'self'
op|'.'
name|'_onEndElement'
newline|'\n'
name|'self'
op|'.'
name|'parser'
op|'.'
name|'CharacterDataHandler'
op|'='
name|'self'
op|'.'
name|'_onCdata'
newline|'\n'
name|'self'
op|'.'
name|'parser'
op|'.'
name|'StartNamespaceDeclHandler'
op|'='
name|'self'
op|'.'
name|'_onStartNamespace'
newline|'\n'
name|'self'
op|'.'
name|'parser'
op|'.'
name|'EndNamespaceDeclHandler'
op|'='
name|'self'
op|'.'
name|'_onEndNamespace'
newline|'\n'
name|'self'
op|'.'
name|'currElem'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'defaultNsStack'
op|'='
op|'['
string|"''"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'documentStarted'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'localPrefixes'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|parse
dedent|''
name|'def'
name|'parse'
op|'('
name|'self'
op|','
name|'buffer'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'parser'
op|'.'
name|'Parse'
op|'('
name|'buffer'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'self'
op|'.'
name|'error'
op|','
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ParserError'
op|','
name|'str'
op|'('
name|'e'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_onStartElement
dedent|''
dedent|''
name|'def'
name|'_onStartElement'
op|'('
name|'self'
op|','
name|'name'
op|','
name|'attrs'
op|')'
op|':'
newline|'\n'
comment|'# Generate a qname tuple from the provided name'
nl|'\n'
indent|'        '
name|'qname'
op|'='
name|'name'
op|'.'
name|'split'
op|'('
string|'" "'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'qname'
op|')'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'qname'
op|'='
op|'('
string|"''"
op|','
name|'name'
op|')'
newline|'\n'
nl|'\n'
comment|'# Process attributes'
nl|'\n'
dedent|''
name|'for'
name|'k'
op|','
name|'v'
name|'in'
name|'attrs'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'k'
op|'.'
name|'find'
op|'('
string|'" "'
op|')'
op|'!='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'aqname'
op|'='
name|'k'
op|'.'
name|'split'
op|'('
string|'" "'
op|')'
newline|'\n'
name|'attrs'
op|'['
op|'('
name|'aqname'
op|'['
number|'0'
op|']'
op|','
name|'aqname'
op|'['
number|'1'
op|']'
op|')'
op|']'
op|'='
name|'v'
newline|'\n'
name|'del'
name|'attrs'
op|'['
name|'k'
op|']'
newline|'\n'
nl|'\n'
comment|'# Construct the new element'
nl|'\n'
dedent|''
dedent|''
name|'e'
op|'='
name|'Element'
op|'('
name|'qname'
op|','
name|'self'
op|'.'
name|'defaultNsStack'
op|'['
op|'-'
number|'1'
op|']'
op|','
name|'attrs'
op|','
name|'self'
op|'.'
name|'localPrefixes'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'localPrefixes'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
comment|'# Document already started'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'documentStarted'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'currElem'
op|'!='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'currElem'
op|'.'
name|'children'
op|'.'
name|'append'
op|'('
name|'e'
op|')'
newline|'\n'
name|'e'
op|'.'
name|'parent'
op|'='
name|'self'
op|'.'
name|'currElem'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'currElem'
op|'='
name|'e'
newline|'\n'
nl|'\n'
comment|'# New document'
nl|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'documentStarted'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'DocumentStartEvent'
op|'('
name|'e'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_onEndElement
dedent|''
dedent|''
name|'def'
name|'_onEndElement'
op|'('
name|'self'
op|','
name|'_'
op|')'
op|':'
newline|'\n'
comment|'# Check for null current elem; end of doc'
nl|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'currElem'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'DocumentEndEvent'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|"# Check for parent that is None; that's"
nl|'\n'
comment|'# the top of the stack'
nl|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'currElem'
op|'.'
name|'parent'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'ElementEvent'
op|'('
name|'self'
op|'.'
name|'currElem'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'currElem'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# Anything else is just some element in the current'
nl|'\n'
comment|'# packet wrapping up'
nl|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'currElem'
op|'='
name|'self'
op|'.'
name|'currElem'
op|'.'
name|'parent'
newline|'\n'
nl|'\n'
DECL|member|_onCdata
dedent|''
dedent|''
name|'def'
name|'_onCdata'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'currElem'
op|'!='
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'currElem'
op|'.'
name|'addContent'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_onStartNamespace
dedent|''
dedent|''
name|'def'
name|'_onStartNamespace'
op|'('
name|'self'
op|','
name|'prefix'
op|','
name|'uri'
op|')'
op|':'
newline|'\n'
comment|'# If this is the default namespace, put'
nl|'\n'
comment|'# it on the stack'
nl|'\n'
indent|'        '
name|'if'
name|'prefix'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'defaultNsStack'
op|'.'
name|'append'
op|'('
name|'uri'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'localPrefixes'
op|'['
name|'prefix'
op|']'
op|'='
name|'uri'
newline|'\n'
nl|'\n'
DECL|member|_onEndNamespace
dedent|''
dedent|''
name|'def'
name|'_onEndNamespace'
op|'('
name|'self'
op|','
name|'prefix'
op|')'
op|':'
newline|'\n'
comment|'# Remove last element on the stack'
nl|'\n'
indent|'        '
name|'if'
name|'prefix'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'defaultNsStack'
op|'.'
name|'pop'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'## class FileParser(ElementStream):'
nl|'\n'
comment|'##     def __init__(self):'
nl|'\n'
comment|'##         ElementStream.__init__(self)'
nl|'\n'
comment|'##         self.DocumentStartEvent = self.docStart'
nl|'\n'
comment|'##         self.ElementEvent = self.elem'
nl|'\n'
comment|'##         self.DocumentEndEvent = self.docEnd'
nl|'\n'
comment|'##         self.done = 0'
nl|'\n'
nl|'\n'
comment|'##     def docStart(self, elem):'
nl|'\n'
comment|'##         self.document = elem'
nl|'\n'
nl|'\n'
comment|'##     def elem(self, elem):'
nl|'\n'
comment|'##         self.document.addChild(elem)'
nl|'\n'
nl|'\n'
comment|'##     def docEnd(self):'
nl|'\n'
comment|'##         self.done = 1'
nl|'\n'
nl|'\n'
comment|'##     def parse(self, filename):'
nl|'\n'
comment|'##         for l in open(filename).readlines():'
nl|'\n'
comment|'##             self.parser.Parse(l)'
nl|'\n'
comment|'##         assert self.done == 1'
nl|'\n'
comment|'##         return self.document'
nl|'\n'
nl|'\n'
comment|'## def parseFile(filename):'
nl|'\n'
comment|'##     return FileParser().parse(filename)'
nl|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
