begin_unit
comment|'# Copyright (c) 2001-2007 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
comment|'# DO NOT EDIT xpathparser.py!'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# It is generated from xpathparser.g using Yapps. Make needed changes there.'
nl|'\n'
comment|"# This also means that the generated Python may not conform to Twisted's coding"
nl|'\n'
comment|'# standards.'
nl|'\n'
nl|'\n'
comment|'# HOWTO Generate me:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# 1.) Grab a copy of yapps2, version 2.1.1:'
nl|'\n'
comment|'#         http://theory.stanford.edu/~amitp/Yapps/'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     Note: Do NOT use the package in debian/ubuntu as it has incompatible'
nl|'\n'
comment|'#     modifications.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# 2.) Generate the grammar:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         yapps2 xpathparser.g xpathparser.py.proto'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# 3.) Edit the output to depend on the embedded runtime, not yappsrt.'
nl|'\n'
comment|'#'
nl|'\n'
comment|"#         sed -e '/^import yapps/d' -e '/^[^#]/s/yappsrt\\.//g' \\"
nl|'\n'
comment|'#             xpathparser.py.proto > xpathparser.py'
nl|'\n'
nl|'\n'
string|'"""\nXPath Parser.\n\nBesides the parser code produced by Yapps, this module also defines the\nparse-time exception classes, a scanner class, a base class for parsers\nproduced by Yapps, and a context class that keeps track of the parse stack.\nThese have been copied from the Yapps runtime.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'sys'
op|','
name|'re'
newline|'\n'
nl|'\n'
DECL|class|SyntaxError
name|'class'
name|'SyntaxError'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""When we run into an unexpected token, this is the exception to use"""'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'charpos'
op|'='
op|'-'
number|'1'
op|','
name|'msg'
op|'='
string|'"Bad Token"'
op|','
name|'context'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'Exception'
op|'.'
name|'__init__'
op|'('
name|'self'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'charpos'
op|'='
name|'charpos'
newline|'\n'
name|'self'
op|'.'
name|'msg'
op|'='
name|'msg'
newline|'\n'
name|'self'
op|'.'
name|'context'
op|'='
name|'context'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'charpos'
op|'<'
number|'0'
op|':'
name|'return'
string|"'SyntaxError'"
newline|'\n'
name|'else'
op|':'
name|'return'
string|"'SyntaxError@char%s(%s)'"
op|'%'
op|'('
name|'repr'
op|'('
name|'self'
op|'.'
name|'charpos'
op|')'
op|','
name|'self'
op|'.'
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|class|NoMoreTokens
dedent|''
dedent|''
name|'class'
name|'NoMoreTokens'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Another exception object, for when we run out of tokens"""'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
DECL|class|Scanner
dedent|''
name|'class'
name|'Scanner'
op|':'
newline|'\n'
indent|'    '
string|'"""Yapps scanner.\n\n    The Yapps scanner can work in context sensitive or context\n    insensitive modes.  The token(i) method is used to retrieve the\n    i-th token.  It takes a restrict set that limits the set of tokens\n    it is allowed to return.  In context sensitive mode, this restrict\n    set guides the scanner.  In context insensitive mode, there is no\n    restriction (the set is always the full set of tokens).\n\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'patterns'
op|','
name|'ignore'
op|','
name|'input'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Initialize the scanner.\n\n        @param patterns: [(terminal, uncompiled regex), ...] or C{None}\n        @param ignore: [terminal,...]\n        @param input: string\n\n        If patterns is C{None}, we assume that the subclass has defined\n        C{self.patterns} : [(terminal, compiled regex), ...]. Note that the\n        patterns parameter expects uncompiled regexes, whereas the\n        C{self.patterns} field expects compiled regexes.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'tokens'
op|'='
op|'['
op|']'
comment|'# [(begin char pos, end char pos, token name, matched text), ...]'
newline|'\n'
name|'self'
op|'.'
name|'restrictions'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'input'
op|'='
name|'input'
newline|'\n'
name|'self'
op|'.'
name|'pos'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'ignore'
op|'='
name|'ignore'
newline|'\n'
name|'self'
op|'.'
name|'first_line_number'
op|'='
number|'1'
newline|'\n'
nl|'\n'
name|'if'
name|'patterns'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
comment|'# Compile the regex strings into regex objects'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'patterns'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'terminal'
op|','
name|'regex'
name|'in'
name|'patterns'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'patterns'
op|'.'
name|'append'
op|'('
op|'('
name|'terminal'
op|','
name|'re'
op|'.'
name|'compile'
op|'('
name|'regex'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_token_pos
dedent|''
dedent|''
dedent|''
name|'def'
name|'get_token_pos'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the current token position in the input text."""'
newline|'\n'
name|'return'
name|'len'
op|'('
name|'self'
op|'.'
name|'tokens'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_char_pos
dedent|''
name|'def'
name|'get_char_pos'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the current char position in the input text."""'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'pos'
newline|'\n'
nl|'\n'
DECL|member|get_prev_char_pos
dedent|''
name|'def'
name|'get_prev_char_pos'
op|'('
name|'self'
op|','
name|'i'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the previous position (one token back) in the input text."""'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'pos'
op|'=='
number|'0'
op|':'
name|'return'
number|'0'
newline|'\n'
name|'if'
name|'i'
name|'is'
name|'None'
op|':'
name|'i'
op|'='
op|'-'
number|'1'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'tokens'
op|'['
name|'i'
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
DECL|member|get_line_number
dedent|''
name|'def'
name|'get_line_number'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the line number of the current position in the input text."""'
newline|'\n'
comment|'# TODO: make this work at any token/char position'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'first_line_number'
op|'+'
name|'self'
op|'.'
name|'get_input_scanned'
op|'('
op|')'
op|'.'
name|'count'
op|'('
string|"'\\n'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_column_number
dedent|''
name|'def'
name|'get_column_number'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the column number of the current position in the input text."""'
newline|'\n'
name|'s'
op|'='
name|'self'
op|'.'
name|'get_input_scanned'
op|'('
op|')'
newline|'\n'
name|'i'
op|'='
name|'s'
op|'.'
name|'rfind'
op|'('
string|"'\\n'"
op|')'
comment|"# may be -1, but that's okay in this case"
newline|'\n'
name|'return'
name|'len'
op|'('
name|'s'
op|')'
op|'-'
op|'('
name|'i'
op|'+'
number|'1'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_input_scanned
dedent|''
name|'def'
name|'get_input_scanned'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the portion of the input that has been tokenized."""'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'input'
op|'['
op|':'
name|'self'
op|'.'
name|'pos'
op|']'
newline|'\n'
nl|'\n'
DECL|member|get_input_unscanned
dedent|''
name|'def'
name|'get_input_unscanned'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the portion of the input that has not yet been tokenized."""'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'input'
op|'['
name|'self'
op|'.'
name|'pos'
op|':'
op|']'
newline|'\n'
nl|'\n'
DECL|member|token
dedent|''
name|'def'
name|'token'
op|'('
name|'self'
op|','
name|'i'
op|','
name|'restrict'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the i\'th token in the input.\n\n        If C{i} is one past the end, then scan for another token.\n\n        @param i: token index\n\n        @param restrict: [token, ...] or C{None}; if restrict is\n                         C{None}, then any token is allowed.  You may call\n                         token(i) more than once.  However, the restrict set\n                         may never be larger than what was passed in on the\n                         first call to token(i).\n        """'
newline|'\n'
name|'if'
name|'i'
op|'=='
name|'len'
op|'('
name|'self'
op|'.'
name|'tokens'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'scan'
op|'('
name|'restrict'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'i'
op|'<'
name|'len'
op|'('
name|'self'
op|'.'
name|'tokens'
op|')'
op|':'
newline|'\n'
comment|'# Make sure the restriction is more restricted.  This'
nl|'\n'
comment|'# invariant is needed to avoid ruining tokenization at'
nl|'\n'
comment|'# position i+1 and higher.'
nl|'\n'
indent|'            '
name|'if'
name|'restrict'
name|'and'
name|'self'
op|'.'
name|'restrictions'
op|'['
name|'i'
op|']'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'r'
name|'in'
name|'restrict'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'r'
name|'not'
name|'in'
name|'self'
op|'.'
name|'restrictions'
op|'['
name|'i'
op|']'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
name|'NotImplementedError'
op|'('
string|'"Unimplemented: restriction set changed"'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'tokens'
op|'['
name|'i'
op|']'
newline|'\n'
dedent|''
name|'raise'
name|'NoMoreTokens'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Print the last 10 tokens that have been scanned in"""'
newline|'\n'
name|'output'
op|'='
string|"''"
newline|'\n'
name|'for'
name|'t'
name|'in'
name|'self'
op|'.'
name|'tokens'
op|'['
op|'-'
number|'10'
op|':'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'output'
op|'='
string|"'%s\\n  (@%s)  %s  =  %s'"
op|'%'
op|'('
name|'output'
op|','
name|'t'
op|'['
number|'0'
op|']'
op|','
name|'t'
op|'['
number|'2'
op|']'
op|','
name|'repr'
op|'('
name|'t'
op|'['
number|'3'
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'output'
newline|'\n'
nl|'\n'
DECL|member|scan
dedent|''
name|'def'
name|'scan'
op|'('
name|'self'
op|','
name|'restrict'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Should scan another token and add it to the list, self.tokens,\n        and add the restriction to self.restrictions"""'
newline|'\n'
comment|'# Keep looking for a token, ignoring any in self.ignore'
nl|'\n'
name|'while'
number|'1'
op|':'
newline|'\n'
comment|'# Search the patterns for the longest match, with earlier'
nl|'\n'
comment|'# tokens in the list having preference'
nl|'\n'
indent|'            '
name|'best_match'
op|'='
op|'-'
number|'1'
newline|'\n'
name|'best_pat'
op|'='
string|"'(error)'"
newline|'\n'
name|'for'
name|'p'
op|','
name|'regexp'
name|'in'
name|'self'
op|'.'
name|'patterns'
op|':'
newline|'\n'
comment|"# First check to see if we're ignoring this token"
nl|'\n'
indent|'                '
name|'if'
name|'restrict'
name|'and'
name|'p'
name|'not'
name|'in'
name|'restrict'
name|'and'
name|'p'
name|'not'
name|'in'
name|'self'
op|'.'
name|'ignore'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'m'
op|'='
name|'regexp'
op|'.'
name|'match'
op|'('
name|'self'
op|'.'
name|'input'
op|','
name|'self'
op|'.'
name|'pos'
op|')'
newline|'\n'
name|'if'
name|'m'
name|'and'
name|'len'
op|'('
name|'m'
op|'.'
name|'group'
op|'('
number|'0'
op|')'
op|')'
op|'>'
name|'best_match'
op|':'
newline|'\n'
comment|"# We got a match that's better than the previous one"
nl|'\n'
indent|'                    '
name|'best_pat'
op|'='
name|'p'
newline|'\n'
name|'best_match'
op|'='
name|'len'
op|'('
name|'m'
op|'.'
name|'group'
op|'('
number|'0'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|"# If we didn't find anything, raise an error"
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'best_pat'
op|'=='
string|"'(error)'"
name|'and'
name|'best_match'
op|'<'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
string|"'Bad Token'"
newline|'\n'
name|'if'
name|'restrict'
op|':'
newline|'\n'
indent|'                    '
name|'msg'
op|'='
string|"'Trying to find one of '"
op|'+'
string|"', '"
op|'.'
name|'join'
op|'('
name|'restrict'
op|')'
newline|'\n'
dedent|''
name|'raise'
name|'SyntaxError'
op|'('
name|'self'
op|'.'
name|'pos'
op|','
name|'msg'
op|')'
newline|'\n'
nl|'\n'
comment|"# If we found something that isn't to be ignored, return it"
nl|'\n'
dedent|''
name|'if'
name|'best_pat'
name|'not'
name|'in'
name|'self'
op|'.'
name|'ignore'
op|':'
newline|'\n'
comment|'# Create a token with this data'
nl|'\n'
indent|'                '
name|'token'
op|'='
op|'('
name|'self'
op|'.'
name|'pos'
op|','
name|'self'
op|'.'
name|'pos'
op|'+'
name|'best_match'
op|','
name|'best_pat'
op|','
nl|'\n'
name|'self'
op|'.'
name|'input'
op|'['
name|'self'
op|'.'
name|'pos'
op|':'
name|'self'
op|'.'
name|'pos'
op|'+'
name|'best_match'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'pos'
op|'='
name|'self'
op|'.'
name|'pos'
op|'+'
name|'best_match'
newline|'\n'
comment|"# Only add this token if it's not in the list"
nl|'\n'
comment|'# (to prevent looping)'
nl|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'tokens'
name|'or'
name|'token'
op|'!='
name|'self'
op|'.'
name|'tokens'
op|'['
op|'-'
number|'1'
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'tokens'
op|'.'
name|'append'
op|'('
name|'token'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'restrictions'
op|'.'
name|'append'
op|'('
name|'restrict'
op|')'
newline|'\n'
dedent|''
name|'return'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# This token should be ignored ..'
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'pos'
op|'='
name|'self'
op|'.'
name|'pos'
op|'+'
name|'best_match'
newline|'\n'
nl|'\n'
DECL|class|Parser
dedent|''
dedent|''
dedent|''
dedent|''
name|'class'
name|'Parser'
op|':'
newline|'\n'
indent|'    '
string|'"""Base class for Yapps-generated parsers.\n\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'scanner'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_scanner'
op|'='
name|'scanner'
newline|'\n'
name|'self'
op|'.'
name|'_pos'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|member|_peek
dedent|''
name|'def'
name|'_peek'
op|'('
name|'self'
op|','
op|'*'
name|'types'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns the token type for lookahead; if there are any args\n        then the list of args is the set of token types to allow"""'
newline|'\n'
name|'tok'
op|'='
name|'self'
op|'.'
name|'_scanner'
op|'.'
name|'token'
op|'('
name|'self'
op|'.'
name|'_pos'
op|','
name|'types'
op|')'
newline|'\n'
name|'return'
name|'tok'
op|'['
number|'2'
op|']'
newline|'\n'
nl|'\n'
DECL|member|_scan
dedent|''
name|'def'
name|'_scan'
op|'('
name|'self'
op|','
name|'type'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns the matched text, and moves to the next token"""'
newline|'\n'
name|'tok'
op|'='
name|'self'
op|'.'
name|'_scanner'
op|'.'
name|'token'
op|'('
name|'self'
op|'.'
name|'_pos'
op|','
op|'['
name|'type'
op|']'
op|')'
newline|'\n'
name|'if'
name|'tok'
op|'['
number|'2'
op|']'
op|'!='
name|'type'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'SyntaxError'
op|'('
name|'tok'
op|'['
number|'0'
op|']'
op|','
string|"'Trying to find '"
op|'+'
name|'type'
op|'+'
string|"' :'"
op|'+'
string|"' ,'"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'_scanner'
op|'.'
name|'restrictions'
op|'['
name|'self'
op|'.'
name|'_pos'
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_pos'
op|'='
number|'1'
op|'+'
name|'self'
op|'.'
name|'_pos'
newline|'\n'
name|'return'
name|'tok'
op|'['
number|'3'
op|']'
newline|'\n'
nl|'\n'
DECL|class|Context
dedent|''
dedent|''
name|'class'
name|'Context'
op|':'
newline|'\n'
indent|'    '
string|'"""Class to represent the parser\'s call stack.\n\n    Every rule creates a Context that links to its parent rule.  The\n    contexts can be used for debugging.\n\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'scanner'
op|','
name|'tokenpos'
op|','
name|'rule'
op|','
name|'args'
op|'='
op|'('
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a new context.\n\n        @param parent: Context object or C{None}\n        @param scanner: Scanner object\n        @param tokenpos: scanner token position\n        @type tokenpos: L{int}\n        @param rule: name of the rule\n        @type rule: L{str}\n        @param args: tuple listing parameters to the rule\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'parent'
op|'='
name|'parent'
newline|'\n'
name|'self'
op|'.'
name|'scanner'
op|'='
name|'scanner'
newline|'\n'
name|'self'
op|'.'
name|'tokenpos'
op|'='
name|'tokenpos'
newline|'\n'
name|'self'
op|'.'
name|'rule'
op|'='
name|'rule'
newline|'\n'
name|'self'
op|'.'
name|'args'
op|'='
name|'args'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'output'
op|'='
string|"''"
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'parent'
op|':'
name|'output'
op|'='
name|'str'
op|'('
name|'self'
op|'.'
name|'parent'
op|')'
op|'+'
string|"' > '"
newline|'\n'
name|'output'
op|'+='
name|'self'
op|'.'
name|'rule'
newline|'\n'
name|'return'
name|'output'
newline|'\n'
nl|'\n'
DECL|function|print_line_with_pointer
dedent|''
dedent|''
name|'def'
name|'print_line_with_pointer'
op|'('
name|'text'
op|','
name|'p'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Print the line of \'text\' that includes position \'p\',\n    along with a second line with a single caret (^) at position p"""'
newline|'\n'
nl|'\n'
comment|'# TODO: separate out the logic for determining the line/character'
nl|'\n'
comment|'# location from the logic for determining how to display an'
nl|'\n'
comment|'# 80-column line to stderr.'
nl|'\n'
nl|'\n'
comment|'# Now try printing part of the line'
nl|'\n'
name|'text'
op|'='
name|'text'
op|'['
name|'max'
op|'('
name|'p'
op|'-'
number|'80'
op|','
number|'0'
op|')'
op|':'
name|'p'
op|'+'
number|'80'
op|']'
newline|'\n'
name|'p'
op|'='
name|'p'
op|'-'
name|'max'
op|'('
name|'p'
op|'-'
number|'80'
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
comment|'# Strip to the left'
nl|'\n'
name|'i'
op|'='
name|'text'
op|'['
op|':'
name|'p'
op|']'
op|'.'
name|'rfind'
op|'('
string|"'\\n'"
op|')'
newline|'\n'
name|'j'
op|'='
name|'text'
op|'['
op|':'
name|'p'
op|']'
op|'.'
name|'rfind'
op|'('
string|"'\\r'"
op|')'
newline|'\n'
name|'if'
name|'i'
op|'<'
number|'0'
name|'or'
op|'('
number|'0'
op|'<='
name|'j'
op|'<'
name|'i'
op|')'
op|':'
name|'i'
op|'='
name|'j'
newline|'\n'
name|'if'
number|'0'
op|'<='
name|'i'
op|'<'
name|'p'
op|':'
newline|'\n'
indent|'        '
name|'p'
op|'='
name|'p'
op|'-'
name|'i'
op|'-'
number|'1'
newline|'\n'
name|'text'
op|'='
name|'text'
op|'['
name|'i'
op|'+'
number|'1'
op|':'
op|']'
newline|'\n'
nl|'\n'
comment|'# Strip to the right'
nl|'\n'
dedent|''
name|'i'
op|'='
name|'text'
op|'.'
name|'find'
op|'('
string|"'\\n'"
op|','
name|'p'
op|')'
newline|'\n'
name|'j'
op|'='
name|'text'
op|'.'
name|'find'
op|'('
string|"'\\r'"
op|','
name|'p'
op|')'
newline|'\n'
name|'if'
name|'i'
op|'<'
number|'0'
name|'or'
op|'('
number|'0'
op|'<='
name|'j'
op|'<'
name|'i'
op|')'
op|':'
name|'i'
op|'='
name|'j'
newline|'\n'
name|'if'
name|'i'
op|'>='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'text'
op|'='
name|'text'
op|'['
op|':'
name|'i'
op|']'
newline|'\n'
nl|'\n'
comment|'# Now shorten the text'
nl|'\n'
dedent|''
name|'while'
name|'len'
op|'('
name|'text'
op|')'
op|'>'
number|'70'
name|'and'
name|'p'
op|'>'
number|'60'
op|':'
newline|'\n'
comment|'# Cut off 10 chars'
nl|'\n'
indent|'        '
name|'text'
op|'='
string|'"..."'
op|'+'
name|'text'
op|'['
number|'10'
op|':'
op|']'
newline|'\n'
name|'p'
op|'='
name|'p'
op|'-'
number|'7'
newline|'\n'
nl|'\n'
comment|'# Now print the string, along with an indicator'
nl|'\n'
dedent|''
name|'print'
op|'>>'
name|'sys'
op|'.'
name|'stderr'
op|','
string|"'> '"
op|','
name|'text'
newline|'\n'
name|'print'
op|'>>'
name|'sys'
op|'.'
name|'stderr'
op|','
string|"'> '"
op|','
string|"' '"
op|'*'
name|'p'
op|'+'
string|"'^'"
newline|'\n'
nl|'\n'
DECL|function|print_error
dedent|''
name|'def'
name|'print_error'
op|'('
name|'input'
op|','
name|'err'
op|','
name|'scanner'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Print error messages, the parser stack, and the input text -- for human-readable error messages."""'
newline|'\n'
comment|'# NOTE: this function assumes 80 columns :-('
nl|'\n'
comment|'# Figure out the line number'
nl|'\n'
name|'line_number'
op|'='
name|'scanner'
op|'.'
name|'get_line_number'
op|'('
op|')'
newline|'\n'
name|'column_number'
op|'='
name|'scanner'
op|'.'
name|'get_column_number'
op|'('
op|')'
newline|'\n'
name|'print'
op|'>>'
name|'sys'
op|'.'
name|'stderr'
op|','
string|"'%d:%d: %s'"
op|'%'
op|'('
name|'line_number'
op|','
name|'column_number'
op|','
name|'err'
op|'.'
name|'msg'
op|')'
newline|'\n'
nl|'\n'
name|'context'
op|'='
name|'err'
op|'.'
name|'context'
newline|'\n'
name|'if'
name|'not'
name|'context'
op|':'
newline|'\n'
indent|'        '
name|'print_line_with_pointer'
op|'('
name|'input'
op|','
name|'err'
op|'.'
name|'charpos'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'while'
name|'context'
op|':'
newline|'\n'
comment|'# TODO: add line number'
nl|'\n'
indent|'        '
name|'print'
op|'>>'
name|'sys'
op|'.'
name|'stderr'
op|','
string|"'while parsing %s%s:'"
op|'%'
op|'('
name|'context'
op|'.'
name|'rule'
op|','
name|'tuple'
op|'('
name|'context'
op|'.'
name|'args'
op|')'
op|')'
newline|'\n'
name|'print_line_with_pointer'
op|'('
name|'input'
op|','
name|'context'
op|'.'
name|'scanner'
op|'.'
name|'get_prev_char_pos'
op|'('
name|'context'
op|'.'
name|'tokenpos'
op|')'
op|')'
newline|'\n'
name|'context'
op|'='
name|'context'
op|'.'
name|'parent'
newline|'\n'
nl|'\n'
DECL|function|wrap_error_reporter
dedent|''
dedent|''
name|'def'
name|'wrap_error_reporter'
op|'('
name|'parser'
op|','
name|'rule'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'getattr'
op|'('
name|'parser'
op|','
name|'rule'
op|')'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'SyntaxError'
op|','
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'input'
op|'='
name|'parser'
op|'.'
name|'_scanner'
op|'.'
name|'input'
newline|'\n'
name|'print_error'
op|'('
name|'input'
op|','
name|'e'
op|','
name|'parser'
op|'.'
name|'_scanner'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'NoMoreTokens'
op|':'
newline|'\n'
indent|'        '
name|'print'
op|'>>'
name|'sys'
op|'.'
name|'stderr'
op|','
string|"'Could not complete parsing; stopped around here:'"
newline|'\n'
name|'print'
op|'>>'
name|'sys'
op|'.'
name|'stderr'
op|','
name|'parser'
op|'.'
name|'_scanner'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'from'
name|'twisted'
op|'.'
name|'words'
op|'.'
name|'xish'
op|'.'
name|'xpath'
name|'import'
name|'AttribValue'
op|','
name|'BooleanValue'
op|','
name|'CompareValue'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'words'
op|'.'
name|'xish'
op|'.'
name|'xpath'
name|'import'
name|'Function'
op|','
name|'IndexValue'
op|','
name|'LiteralValue'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'words'
op|'.'
name|'xish'
op|'.'
name|'xpath'
name|'import'
name|'_AnyLocation'
op|','
name|'_Location'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# Begin -- grammar generated by Yapps'
nl|'\n'
name|'import'
name|'sys'
op|','
name|'re'
newline|'\n'
nl|'\n'
DECL|class|XPathParserScanner
name|'class'
name|'XPathParserScanner'
op|'('
name|'Scanner'
op|')'
op|':'
newline|'\n'
DECL|variable|patterns
indent|'    '
name|'patterns'
op|'='
op|'['
nl|'\n'
op|'('
string|'\'","\''
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|"','"
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|'\'"@"\''
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|"'@'"
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|'\'"\\\\)"\''
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|"'\\\\)'"
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|'\'"\\\\("\''
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|"'\\\\('"
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|'\'"\\\\]"\''
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|"'\\\\]'"
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|'\'"\\\\["\''
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|"'\\\\['"
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|'\'"//"\''
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|"'//'"
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|'\'"/"\''
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|"'/'"
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|"'\\\\s+'"
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|"'\\\\s+'"
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|"'INDEX'"
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|"'[0-9]+'"
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|"'WILDCARD'"
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|"'\\\\*'"
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|"'IDENTIFIER'"
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|"'[a-zA-Z][a-zA-Z0-9_\\\\-]*'"
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|"'ATTRIBUTE'"
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|"'\\\\@[a-zA-Z][a-zA-Z0-9_\\\\-]*'"
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|"'FUNCNAME'"
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|"'[a-zA-Z][a-zA-Z0-9_]*'"
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|"'CMP_EQ'"
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|"'\\\\='"
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|"'CMP_NE'"
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|"'\\\\!\\\\='"
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|"'STR_DQ'"
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|'\'"([^"]|(\\\\"))*?"\''
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|"'STR_SQ'"
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|'"\'([^\']|(\\\\\'))*?\'"'
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|"'OP_AND'"
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|"'and'"
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|"'OP_OR'"
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|"'or'"
op|')'
op|')'
op|','
nl|'\n'
op|'('
string|"'END'"
op|','
name|'re'
op|'.'
name|'compile'
op|'('
string|"'$'"
op|')'
op|')'
op|','
nl|'\n'
op|']'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'str'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'Scanner'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'None'
op|','
op|'['
string|"'\\\\s+'"
op|']'
op|','
name|'str'
op|')'
newline|'\n'
nl|'\n'
DECL|class|XPathParser
dedent|''
dedent|''
name|'class'
name|'XPathParser'
op|'('
name|'Parser'
op|')'
op|':'
newline|'\n'
DECL|variable|Context
indent|'    '
name|'Context'
op|'='
name|'Context'
newline|'\n'
DECL|member|XPATH
name|'def'
name|'XPATH'
op|'('
name|'self'
op|','
name|'_parent'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'_context'
op|'='
name|'self'
op|'.'
name|'Context'
op|'('
name|'_parent'
op|','
name|'self'
op|'.'
name|'_scanner'
op|','
name|'self'
op|'.'
name|'_pos'
op|','
string|"'XPATH'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'PATH'
op|'='
name|'self'
op|'.'
name|'PATH'
op|'('
name|'_context'
op|')'
newline|'\n'
name|'result'
op|'='
name|'PATH'
op|';'
name|'current'
op|'='
name|'result'
newline|'\n'
name|'while'
name|'self'
op|'.'
name|'_peek'
op|'('
string|"'END'"
op|','
string|'\'"/"\''
op|','
string|'\'"//"\''
op|')'
op|'!='
string|"'END'"
op|':'
newline|'\n'
indent|'            '
name|'PATH'
op|'='
name|'self'
op|'.'
name|'PATH'
op|'('
name|'_context'
op|')'
newline|'\n'
name|'current'
op|'.'
name|'childLocation'
op|'='
name|'PATH'
op|';'
name|'current'
op|'='
name|'current'
op|'.'
name|'childLocation'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_peek'
op|'('
op|')'
name|'not'
name|'in'
op|'['
string|"'END'"
op|','
string|'\'"/"\''
op|','
string|'\'"//"\''
op|']'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'SyntaxError'
op|'('
name|'charpos'
op|'='
name|'self'
op|'.'
name|'_scanner'
op|'.'
name|'get_prev_char_pos'
op|'('
op|')'
op|','
name|'context'
op|'='
name|'_context'
op|','
name|'msg'
op|'='
string|"'Need one of '"
op|'+'
string|"', '"
op|'.'
name|'join'
op|'('
op|'['
string|"'END'"
op|','
string|'\'"/"\''
op|','
string|'\'"//"\''
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'END'
op|'='
name|'self'
op|'.'
name|'_scan'
op|'('
string|"'END'"
op|')'
newline|'\n'
name|'return'
name|'result'
newline|'\n'
nl|'\n'
DECL|member|PATH
dedent|''
name|'def'
name|'PATH'
op|'('
name|'self'
op|','
name|'_parent'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'_context'
op|'='
name|'self'
op|'.'
name|'Context'
op|'('
name|'_parent'
op|','
name|'self'
op|'.'
name|'_scanner'
op|','
name|'self'
op|'.'
name|'_pos'
op|','
string|"'PATH'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'_token'
op|'='
name|'self'
op|'.'
name|'_peek'
op|'('
string|'\'"/"\''
op|','
string|'\'"//"\''
op|')'
newline|'\n'
name|'if'
name|'_token'
op|'=='
string|'\'"/"\''
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_scan'
op|'('
string|'\'"/"\''
op|')'
newline|'\n'
name|'result'
op|'='
name|'_Location'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
comment|'# == \'"//"\''
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_scan'
op|'('
string|'\'"//"\''
op|')'
newline|'\n'
name|'result'
op|'='
name|'_AnyLocation'
op|'('
op|')'
newline|'\n'
dedent|''
name|'_token'
op|'='
name|'self'
op|'.'
name|'_peek'
op|'('
string|"'IDENTIFIER'"
op|','
string|"'WILDCARD'"
op|')'
newline|'\n'
name|'if'
name|'_token'
op|'=='
string|"'IDENTIFIER'"
op|':'
newline|'\n'
indent|'            '
name|'IDENTIFIER'
op|'='
name|'self'
op|'.'
name|'_scan'
op|'('
string|"'IDENTIFIER'"
op|')'
newline|'\n'
name|'result'
op|'.'
name|'elementName'
op|'='
name|'IDENTIFIER'
newline|'\n'
dedent|''
name|'else'
op|':'
comment|"# == 'WILDCARD'"
newline|'\n'
indent|'            '
name|'WILDCARD'
op|'='
name|'self'
op|'.'
name|'_scan'
op|'('
string|"'WILDCARD'"
op|')'
newline|'\n'
name|'result'
op|'.'
name|'elementName'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'while'
name|'self'
op|'.'
name|'_peek'
op|'('
string|'\'"\\\\["\''
op|','
string|"'END'"
op|','
string|'\'"/"\''
op|','
string|'\'"//"\''
op|')'
op|'=='
string|'\'"\\\\["\''
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_scan'
op|'('
string|'\'"\\\\["\''
op|')'
newline|'\n'
name|'PREDICATE'
op|'='
name|'self'
op|'.'
name|'PREDICATE'
op|'('
name|'_context'
op|')'
newline|'\n'
name|'result'
op|'.'
name|'predicates'
op|'.'
name|'append'
op|'('
name|'PREDICATE'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_scan'
op|'('
string|'\'"\\\\]"\''
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_peek'
op|'('
op|')'
name|'not'
name|'in'
op|'['
string|'\'"\\\\["\''
op|','
string|"'END'"
op|','
string|'\'"/"\''
op|','
string|'\'"//"\''
op|']'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'SyntaxError'
op|'('
name|'charpos'
op|'='
name|'self'
op|'.'
name|'_scanner'
op|'.'
name|'get_prev_char_pos'
op|'('
op|')'
op|','
name|'context'
op|'='
name|'_context'
op|','
name|'msg'
op|'='
string|"'Need one of '"
op|'+'
string|"', '"
op|'.'
name|'join'
op|'('
op|'['
string|'\'"\\\\["\''
op|','
string|"'END'"
op|','
string|'\'"/"\''
op|','
string|'\'"//"\''
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
DECL|member|PREDICATE
dedent|''
name|'def'
name|'PREDICATE'
op|'('
name|'self'
op|','
name|'_parent'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'_context'
op|'='
name|'self'
op|'.'
name|'Context'
op|'('
name|'_parent'
op|','
name|'self'
op|'.'
name|'_scanner'
op|','
name|'self'
op|'.'
name|'_pos'
op|','
string|"'PREDICATE'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'_token'
op|'='
name|'self'
op|'.'
name|'_peek'
op|'('
string|"'INDEX'"
op|','
string|'\'"\\\\("\''
op|','
string|'\'"@"\''
op|','
string|"'FUNCNAME'"
op|','
string|"'STR_DQ'"
op|','
string|"'STR_SQ'"
op|')'
newline|'\n'
name|'if'
name|'_token'
op|'!='
string|"'INDEX'"
op|':'
newline|'\n'
indent|'            '
name|'EXPR'
op|'='
name|'self'
op|'.'
name|'EXPR'
op|'('
name|'_context'
op|')'
newline|'\n'
name|'return'
name|'EXPR'
newline|'\n'
dedent|''
name|'else'
op|':'
comment|"# == 'INDEX'"
newline|'\n'
indent|'            '
name|'INDEX'
op|'='
name|'self'
op|'.'
name|'_scan'
op|'('
string|"'INDEX'"
op|')'
newline|'\n'
name|'return'
name|'IndexValue'
op|'('
name|'INDEX'
op|')'
newline|'\n'
nl|'\n'
DECL|member|EXPR
dedent|''
dedent|''
name|'def'
name|'EXPR'
op|'('
name|'self'
op|','
name|'_parent'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'_context'
op|'='
name|'self'
op|'.'
name|'Context'
op|'('
name|'_parent'
op|','
name|'self'
op|'.'
name|'_scanner'
op|','
name|'self'
op|'.'
name|'_pos'
op|','
string|"'EXPR'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'FACTOR'
op|'='
name|'self'
op|'.'
name|'FACTOR'
op|'('
name|'_context'
op|')'
newline|'\n'
name|'e'
op|'='
name|'FACTOR'
newline|'\n'
name|'while'
name|'self'
op|'.'
name|'_peek'
op|'('
string|"'OP_AND'"
op|','
string|"'OP_OR'"
op|','
string|'\'"\\\\)"\''
op|','
string|'\'"\\\\]"\''
op|')'
name|'in'
op|'['
string|"'OP_AND'"
op|','
string|"'OP_OR'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'BOOLOP'
op|'='
name|'self'
op|'.'
name|'BOOLOP'
op|'('
name|'_context'
op|')'
newline|'\n'
name|'FACTOR'
op|'='
name|'self'
op|'.'
name|'FACTOR'
op|'('
name|'_context'
op|')'
newline|'\n'
name|'e'
op|'='
name|'BooleanValue'
op|'('
name|'e'
op|','
name|'BOOLOP'
op|','
name|'FACTOR'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_peek'
op|'('
op|')'
name|'not'
name|'in'
op|'['
string|"'OP_AND'"
op|','
string|"'OP_OR'"
op|','
string|'\'"\\\\)"\''
op|','
string|'\'"\\\\]"\''
op|']'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'SyntaxError'
op|'('
name|'charpos'
op|'='
name|'self'
op|'.'
name|'_scanner'
op|'.'
name|'get_prev_char_pos'
op|'('
op|')'
op|','
name|'context'
op|'='
name|'_context'
op|','
name|'msg'
op|'='
string|"'Need one of '"
op|'+'
string|"', '"
op|'.'
name|'join'
op|'('
op|'['
string|"'OP_AND'"
op|','
string|"'OP_OR'"
op|','
string|'\'"\\\\)"\''
op|','
string|'\'"\\\\]"\''
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'e'
newline|'\n'
nl|'\n'
DECL|member|BOOLOP
dedent|''
name|'def'
name|'BOOLOP'
op|'('
name|'self'
op|','
name|'_parent'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'_context'
op|'='
name|'self'
op|'.'
name|'Context'
op|'('
name|'_parent'
op|','
name|'self'
op|'.'
name|'_scanner'
op|','
name|'self'
op|'.'
name|'_pos'
op|','
string|"'BOOLOP'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'_token'
op|'='
name|'self'
op|'.'
name|'_peek'
op|'('
string|"'OP_AND'"
op|','
string|"'OP_OR'"
op|')'
newline|'\n'
name|'if'
name|'_token'
op|'=='
string|"'OP_AND'"
op|':'
newline|'\n'
indent|'            '
name|'OP_AND'
op|'='
name|'self'
op|'.'
name|'_scan'
op|'('
string|"'OP_AND'"
op|')'
newline|'\n'
name|'return'
name|'OP_AND'
newline|'\n'
dedent|''
name|'else'
op|':'
comment|"# == 'OP_OR'"
newline|'\n'
indent|'            '
name|'OP_OR'
op|'='
name|'self'
op|'.'
name|'_scan'
op|'('
string|"'OP_OR'"
op|')'
newline|'\n'
name|'return'
name|'OP_OR'
newline|'\n'
nl|'\n'
DECL|member|FACTOR
dedent|''
dedent|''
name|'def'
name|'FACTOR'
op|'('
name|'self'
op|','
name|'_parent'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'_context'
op|'='
name|'self'
op|'.'
name|'Context'
op|'('
name|'_parent'
op|','
name|'self'
op|'.'
name|'_scanner'
op|','
name|'self'
op|'.'
name|'_pos'
op|','
string|"'FACTOR'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'_token'
op|'='
name|'self'
op|'.'
name|'_peek'
op|'('
string|'\'"\\\\("\''
op|','
string|'\'"@"\''
op|','
string|"'FUNCNAME'"
op|','
string|"'STR_DQ'"
op|','
string|"'STR_SQ'"
op|')'
newline|'\n'
name|'if'
name|'_token'
op|'!='
string|'\'"\\\\("\''
op|':'
newline|'\n'
indent|'            '
name|'TERM'
op|'='
name|'self'
op|'.'
name|'TERM'
op|'('
name|'_context'
op|')'
newline|'\n'
name|'return'
name|'TERM'
newline|'\n'
dedent|''
name|'else'
op|':'
comment|'# == \'"\\\\("\''
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_scan'
op|'('
string|'\'"\\\\("\''
op|')'
newline|'\n'
name|'EXPR'
op|'='
name|'self'
op|'.'
name|'EXPR'
op|'('
name|'_context'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_scan'
op|'('
string|'\'"\\\\)"\''
op|')'
newline|'\n'
name|'return'
name|'EXPR'
newline|'\n'
nl|'\n'
DECL|member|TERM
dedent|''
dedent|''
name|'def'
name|'TERM'
op|'('
name|'self'
op|','
name|'_parent'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'_context'
op|'='
name|'self'
op|'.'
name|'Context'
op|'('
name|'_parent'
op|','
name|'self'
op|'.'
name|'_scanner'
op|','
name|'self'
op|'.'
name|'_pos'
op|','
string|"'TERM'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'VALUE'
op|'='
name|'self'
op|'.'
name|'VALUE'
op|'('
name|'_context'
op|')'
newline|'\n'
name|'t'
op|'='
name|'VALUE'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_peek'
op|'('
string|"'CMP_EQ'"
op|','
string|"'CMP_NE'"
op|','
string|"'OP_AND'"
op|','
string|"'OP_OR'"
op|','
string|'\'"\\\\)"\''
op|','
string|'\'"\\\\]"\''
op|')'
name|'in'
op|'['
string|"'CMP_EQ'"
op|','
string|"'CMP_NE'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'CMP'
op|'='
name|'self'
op|'.'
name|'CMP'
op|'('
name|'_context'
op|')'
newline|'\n'
name|'VALUE'
op|'='
name|'self'
op|'.'
name|'VALUE'
op|'('
name|'_context'
op|')'
newline|'\n'
name|'t'
op|'='
name|'CompareValue'
op|'('
name|'t'
op|','
name|'CMP'
op|','
name|'VALUE'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'t'
newline|'\n'
nl|'\n'
DECL|member|VALUE
dedent|''
name|'def'
name|'VALUE'
op|'('
name|'self'
op|','
name|'_parent'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'_context'
op|'='
name|'self'
op|'.'
name|'Context'
op|'('
name|'_parent'
op|','
name|'self'
op|'.'
name|'_scanner'
op|','
name|'self'
op|'.'
name|'_pos'
op|','
string|"'VALUE'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'_token'
op|'='
name|'self'
op|'.'
name|'_peek'
op|'('
string|'\'"@"\''
op|','
string|"'FUNCNAME'"
op|','
string|"'STR_DQ'"
op|','
string|"'STR_SQ'"
op|')'
newline|'\n'
name|'if'
name|'_token'
op|'=='
string|'\'"@"\''
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_scan'
op|'('
string|'\'"@"\''
op|')'
newline|'\n'
name|'IDENTIFIER'
op|'='
name|'self'
op|'.'
name|'_scan'
op|'('
string|"'IDENTIFIER'"
op|')'
newline|'\n'
name|'return'
name|'AttribValue'
op|'('
name|'IDENTIFIER'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'_token'
op|'=='
string|"'FUNCNAME'"
op|':'
newline|'\n'
indent|'            '
name|'FUNCNAME'
op|'='
name|'self'
op|'.'
name|'_scan'
op|'('
string|"'FUNCNAME'"
op|')'
newline|'\n'
name|'f'
op|'='
name|'Function'
op|'('
name|'FUNCNAME'
op|')'
op|';'
name|'args'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_scan'
op|'('
string|'\'"\\\\("\''
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_peek'
op|'('
string|'\'"\\\\)"\''
op|','
string|'\'"@"\''
op|','
string|"'FUNCNAME'"
op|','
string|'\'","\''
op|','
string|"'STR_DQ'"
op|','
string|"'STR_SQ'"
op|')'
name|'not'
name|'in'
op|'['
string|'\'"\\\\)"\''
op|','
string|'\'","\''
op|']'
op|':'
newline|'\n'
indent|'                '
name|'VALUE'
op|'='
name|'self'
op|'.'
name|'VALUE'
op|'('
name|'_context'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'append'
op|'('
name|'VALUE'
op|')'
newline|'\n'
name|'while'
name|'self'
op|'.'
name|'_peek'
op|'('
string|'\'","\''
op|','
string|'\'"\\\\)"\''
op|')'
op|'=='
string|'\'","\''
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_scan'
op|'('
string|'\'","\''
op|')'
newline|'\n'
name|'VALUE'
op|'='
name|'self'
op|'.'
name|'VALUE'
op|'('
name|'_context'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'append'
op|'('
name|'VALUE'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_peek'
op|'('
op|')'
name|'not'
name|'in'
op|'['
string|'\'","\''
op|','
string|'\'"\\\\)"\''
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'SyntaxError'
op|'('
name|'charpos'
op|'='
name|'self'
op|'.'
name|'_scanner'
op|'.'
name|'get_prev_char_pos'
op|'('
op|')'
op|','
name|'context'
op|'='
name|'_context'
op|','
name|'msg'
op|'='
string|"'Need one of '"
op|'+'
string|"', '"
op|'.'
name|'join'
op|'('
op|'['
string|'\'","\''
op|','
string|'\'"\\\\)"\''
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_scan'
op|'('
string|'\'"\\\\)"\''
op|')'
newline|'\n'
name|'f'
op|'.'
name|'setParams'
op|'('
op|'*'
name|'args'
op|')'
op|';'
name|'return'
name|'f'
newline|'\n'
dedent|''
name|'else'
op|':'
comment|"# in ['STR_DQ', 'STR_SQ']"
newline|'\n'
indent|'            '
name|'STR'
op|'='
name|'self'
op|'.'
name|'STR'
op|'('
name|'_context'
op|')'
newline|'\n'
name|'return'
name|'LiteralValue'
op|'('
name|'STR'
op|'['
number|'1'
op|':'
name|'len'
op|'('
name|'STR'
op|')'
op|'-'
number|'1'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|CMP
dedent|''
dedent|''
name|'def'
name|'CMP'
op|'('
name|'self'
op|','
name|'_parent'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'_context'
op|'='
name|'self'
op|'.'
name|'Context'
op|'('
name|'_parent'
op|','
name|'self'
op|'.'
name|'_scanner'
op|','
name|'self'
op|'.'
name|'_pos'
op|','
string|"'CMP'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'_token'
op|'='
name|'self'
op|'.'
name|'_peek'
op|'('
string|"'CMP_EQ'"
op|','
string|"'CMP_NE'"
op|')'
newline|'\n'
name|'if'
name|'_token'
op|'=='
string|"'CMP_EQ'"
op|':'
newline|'\n'
indent|'            '
name|'CMP_EQ'
op|'='
name|'self'
op|'.'
name|'_scan'
op|'('
string|"'CMP_EQ'"
op|')'
newline|'\n'
name|'return'
name|'CMP_EQ'
newline|'\n'
dedent|''
name|'else'
op|':'
comment|"# == 'CMP_NE'"
newline|'\n'
indent|'            '
name|'CMP_NE'
op|'='
name|'self'
op|'.'
name|'_scan'
op|'('
string|"'CMP_NE'"
op|')'
newline|'\n'
name|'return'
name|'CMP_NE'
newline|'\n'
nl|'\n'
DECL|member|STR
dedent|''
dedent|''
name|'def'
name|'STR'
op|'('
name|'self'
op|','
name|'_parent'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'_context'
op|'='
name|'self'
op|'.'
name|'Context'
op|'('
name|'_parent'
op|','
name|'self'
op|'.'
name|'_scanner'
op|','
name|'self'
op|'.'
name|'_pos'
op|','
string|"'STR'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'_token'
op|'='
name|'self'
op|'.'
name|'_peek'
op|'('
string|"'STR_DQ'"
op|','
string|"'STR_SQ'"
op|')'
newline|'\n'
name|'if'
name|'_token'
op|'=='
string|"'STR_DQ'"
op|':'
newline|'\n'
indent|'            '
name|'STR_DQ'
op|'='
name|'self'
op|'.'
name|'_scan'
op|'('
string|"'STR_DQ'"
op|')'
newline|'\n'
name|'return'
name|'STR_DQ'
newline|'\n'
dedent|''
name|'else'
op|':'
comment|"# == 'STR_SQ'"
newline|'\n'
indent|'            '
name|'STR_SQ'
op|'='
name|'self'
op|'.'
name|'_scan'
op|'('
string|"'STR_SQ'"
op|')'
newline|'\n'
name|'return'
name|'STR_SQ'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|parse
dedent|''
dedent|''
dedent|''
name|'def'
name|'parse'
op|'('
name|'rule'
op|','
name|'text'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'P'
op|'='
name|'XPathParser'
op|'('
name|'XPathParserScanner'
op|'('
name|'text'
op|')'
op|')'
newline|'\n'
name|'return'
name|'wrap_error_reporter'
op|'('
name|'P'
op|','
name|'rule'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'__name__'
op|'=='
string|"'__main__'"
op|':'
newline|'\n'
indent|'    '
name|'from'
name|'sys'
name|'import'
name|'argv'
op|','
name|'stdin'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'argv'
op|')'
op|'>='
number|'2'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'len'
op|'('
name|'argv'
op|')'
op|'>='
number|'3'
op|':'
newline|'\n'
DECL|variable|f
indent|'            '
name|'f'
op|'='
name|'open'
op|'('
name|'argv'
op|'['
number|'2'
op|']'
op|','
string|"'r'"
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
DECL|variable|f
indent|'            '
name|'f'
op|'='
name|'stdin'
newline|'\n'
dedent|''
name|'print'
name|'parse'
op|'('
name|'argv'
op|'['
number|'1'
op|']'
op|','
name|'f'
op|'.'
name|'read'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
name|'print'
op|'>>'
name|'sys'
op|'.'
name|'stderr'
op|','
string|"'Args:  <rule> [<filename>]'"
newline|'\n'
comment|'# End -- grammar generated by Yapps'
nl|'\n'
dedent|''
endmarker|''
end_unit
