begin_unit
comment|'# -*- test-case-name: twisted.words.test.test_jabberxmlstream -*-'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Copyright (c) 2001-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nXMPP XML Streams\n\nBuilding blocks for setting up XML Streams, including helping classes for\ndoing authentication on either client or server side, and working with XML\nStanzas.\n"""'
newline|'\n'
nl|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'directlyProvides'
op|','
name|'implements'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'defer'
op|','
name|'protocol'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'error'
name|'import'
name|'ConnectionLost'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'failure'
op|','
name|'log'
op|','
name|'randbytes'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'hashlib'
name|'import'
name|'sha1'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'words'
op|'.'
name|'protocols'
op|'.'
name|'jabber'
name|'import'
name|'error'
op|','
name|'ijabber'
op|','
name|'jid'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'words'
op|'.'
name|'xish'
name|'import'
name|'domish'
op|','
name|'xmlstream'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'words'
op|'.'
name|'xish'
op|'.'
name|'xmlstream'
name|'import'
name|'STREAM_CONNECTED_EVENT'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'words'
op|'.'
name|'xish'
op|'.'
name|'xmlstream'
name|'import'
name|'STREAM_START_EVENT'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'words'
op|'.'
name|'xish'
op|'.'
name|'xmlstream'
name|'import'
name|'STREAM_END_EVENT'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'words'
op|'.'
name|'xish'
op|'.'
name|'xmlstream'
name|'import'
name|'STREAM_ERROR_EVENT'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'ssl'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
DECL|variable|ssl
indent|'    '
name|'ssl'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'if'
name|'ssl'
name|'and'
name|'not'
name|'ssl'
op|'.'
name|'supported'
op|':'
newline|'\n'
DECL|variable|ssl
indent|'    '
name|'ssl'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|variable|STREAM_AUTHD_EVENT
dedent|''
name|'STREAM_AUTHD_EVENT'
op|'='
name|'intern'
op|'('
string|'"//event/stream/authd"'
op|')'
newline|'\n'
DECL|variable|INIT_FAILED_EVENT
name|'INIT_FAILED_EVENT'
op|'='
name|'intern'
op|'('
string|'"//event/xmpp/initfailed"'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|NS_STREAMS
name|'NS_STREAMS'
op|'='
string|"'http://etherx.jabber.org/streams'"
newline|'\n'
DECL|variable|NS_XMPP_TLS
name|'NS_XMPP_TLS'
op|'='
string|"'urn:ietf:params:xml:ns:xmpp-tls'"
newline|'\n'
nl|'\n'
DECL|variable|Reset
name|'Reset'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|hashPassword
name|'def'
name|'hashPassword'
op|'('
name|'sid'
op|','
name|'password'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Create a SHA1-digest string of a session identifier and password.\n\n    @param sid: The stream session identifier.\n    @type sid: C{unicode}.\n    @param password: The password to be hashed.\n    @type password: C{unicode}.\n    """'
newline|'\n'
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'sid'
op|','
name|'unicode'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'TypeError'
op|'('
string|'"The session identifier must be a unicode object"'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'password'
op|','
name|'unicode'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'TypeError'
op|'('
string|'"The password must be a unicode object"'
op|')'
newline|'\n'
dedent|''
name|'input'
op|'='
string|'u"%s%s"'
op|'%'
op|'('
name|'sid'
op|','
name|'password'
op|')'
newline|'\n'
name|'return'
name|'sha1'
op|'('
name|'input'
op|'.'
name|'encode'
op|'('
string|"'utf-8'"
op|')'
op|')'
op|'.'
name|'hexdigest'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|Authenticator
dedent|''
name|'class'
name|'Authenticator'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Base class for business logic of initializing an XmlStream\n\n    Subclass this object to enable an XmlStream to initialize and authenticate\n    to different types of stream hosts (such as clients, components, etc.).\n\n    Rules:\n      1. The Authenticator MUST dispatch a L{STREAM_AUTHD_EVENT} when the\n         stream has been completely initialized.\n      2. The Authenticator SHOULD reset all state information when\n         L{associateWithStream} is called.\n      3. The Authenticator SHOULD override L{streamStarted}, and start\n         initialization there.\n\n    @type xmlstream: L{XmlStream}\n    @ivar xmlstream: The XmlStream that needs authentication\n\n    @note: the term authenticator is historical. Authenticators perform\n           all steps required to prepare the stream for the exchange\n           of XML stanzas.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'xmlstream'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionMade
dedent|''
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called by the XmlStream when the underlying socket connection is\n        in place.\n\n        This allows the Authenticator to send an initial root element, if it\'s\n        connecting, or wait for an inbound root from the peer if it\'s accepting\n        the connection.\n\n        Subclasses can use self.xmlstream.send() to send any initial data to\n        the peer.\n        """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|streamStarted
dedent|''
name|'def'
name|'streamStarted'
op|'('
name|'self'
op|','
name|'rootElement'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called by the XmlStream when the stream has started.\n\n        A stream is considered to have started when the start tag of the root\n        element has been received.\n\n        This examines L{rootElement} to see if there is a version attribute.\n        If absent, C{0.0} is assumed per RFC 3920. Subsequently, the\n        minimum of the version from the received stream header and the\n        value stored in L{xmlstream} is taken and put back in {xmlstream}.\n\n        Extensions of this method can extract more information from the\n        stream header and perform checks on them, optionally sending\n        stream errors and closing the stream.\n        """'
newline|'\n'
name|'if'
name|'rootElement'
op|'.'
name|'hasAttribute'
op|'('
string|'"version"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'version'
op|'='
name|'rootElement'
op|'['
string|'"version"'
op|']'
op|'.'
name|'split'
op|'('
string|'"."'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'version'
op|'='
op|'('
name|'int'
op|'('
name|'version'
op|'['
number|'0'
op|']'
op|')'
op|','
name|'int'
op|'('
name|'version'
op|'['
number|'1'
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'IndexError'
op|','
name|'ValueError'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'version'
op|'='
op|'('
number|'0'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'version'
op|'='
op|'('
number|'0'
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'version'
op|'='
name|'min'
op|'('
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'version'
op|','
name|'version'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|associateWithStream
dedent|''
name|'def'
name|'associateWithStream'
op|'('
name|'self'
op|','
name|'xmlstream'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called by the XmlStreamFactory when a connection has been made\n        to the requested peer, and an XmlStream object has been\n        instantiated.\n\n        The default implementation just saves a handle to the new\n        XmlStream.\n\n        @type xmlstream: L{XmlStream}\n        @param xmlstream: The XmlStream that will be passing events to this\n                          Authenticator.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'='
name|'xmlstream'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ConnectAuthenticator
dedent|''
dedent|''
name|'class'
name|'ConnectAuthenticator'
op|'('
name|'Authenticator'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Authenticator for initiating entities.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|namespace
name|'namespace'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'otherHost'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'otherHost'
op|'='
name|'otherHost'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionMade
dedent|''
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'namespace'
op|'='
name|'self'
op|'.'
name|'namespace'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'otherEntity'
op|'='
name|'jid'
op|'.'
name|'internJID'
op|'('
name|'self'
op|'.'
name|'otherHost'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'sendHeader'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|initializeStream
dedent|''
name|'def'
name|'initializeStream'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Perform stream initialization procedures.\n\n        An L{XmlStream} holds a list of initializer objects in its\n        C{initializers} attribute. This method calls these initializers in\n        order and dispatches the C{STREAM_AUTHD_EVENT} event when the list has\n        been successfully processed. Otherwise it dispatches the\n        C{INIT_FAILED_EVENT} event with the failure.\n\n        Initializers may return the special L{Reset} object to halt the\n        initialization processing. It signals that the current initializer was\n        successfully processed, but that the XML Stream has been reset. An\n        example is the TLSInitiatingInitializer.\n        """'
newline|'\n'
nl|'\n'
DECL|function|remove_first
name|'def'
name|'remove_first'
op|'('
name|'result'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'initializers'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'result'
newline|'\n'
nl|'\n'
DECL|function|do_next
dedent|''
name|'def'
name|'do_next'
op|'('
name|'result'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""\n            Take the first initializer and process it.\n\n            On success, the initializer is removed from the list and\n            then next initializer will be tried.\n            """'
newline|'\n'
nl|'\n'
name|'if'
name|'result'
name|'is'
name|'Reset'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'init'
op|'='
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'initializers'
op|'['
number|'0'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'IndexError'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'dispatch'
op|'('
name|'self'
op|'.'
name|'xmlstream'
op|','
name|'STREAM_AUTHD_EVENT'
op|')'
newline|'\n'
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'d'
op|'='
name|'defer'
op|'.'
name|'maybeDeferred'
op|'('
name|'init'
op|'.'
name|'initialize'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'remove_first'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'do_next'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'d'
op|'='
name|'defer'
op|'.'
name|'succeed'
op|'('
name|'None'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'do_next'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addErrback'
op|'('
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'dispatch'
op|','
name|'INIT_FAILED_EVENT'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|streamStarted
dedent|''
name|'def'
name|'streamStarted'
op|'('
name|'self'
op|','
name|'rootElement'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called by the XmlStream when the stream has started.\n\n        This extends L{Authenticator.streamStarted} to extract further stream\n        headers from L{rootElement}, optionally wait for stream features being\n        received and then call C{initializeStream}.\n        """'
newline|'\n'
nl|'\n'
name|'Authenticator'
op|'.'
name|'streamStarted'
op|'('
name|'self'
op|','
name|'rootElement'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'sid'
op|'='
name|'rootElement'
op|'.'
name|'getAttribute'
op|'('
string|'"id"'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'rootElement'
op|'.'
name|'hasAttribute'
op|'('
string|'"from"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'otherEntity'
op|'='
name|'jid'
op|'.'
name|'internJID'
op|'('
name|'rootElement'
op|'['
string|'"from"'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Setup observer for stream features, if applicable'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'version'
op|'>='
op|'('
number|'1'
op|','
number|'0'
op|')'
op|':'
newline|'\n'
DECL|function|onFeatures
indent|'            '
name|'def'
name|'onFeatures'
op|'('
name|'element'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'features'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'feature'
name|'in'
name|'element'
op|'.'
name|'elements'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'features'
op|'['
op|'('
name|'feature'
op|'.'
name|'uri'
op|','
name|'feature'
op|'.'
name|'name'
op|')'
op|']'
op|'='
name|'feature'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'features'
op|'='
name|'features'
newline|'\n'
name|'self'
op|'.'
name|'initializeStream'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'addOnetimeObserver'
op|'('
string|'\'/features[@xmlns="%s"]\''
op|'%'
nl|'\n'
name|'NS_STREAMS'
op|','
nl|'\n'
name|'onFeatures'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'initializeStream'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ListenAuthenticator
dedent|''
dedent|''
dedent|''
name|'class'
name|'ListenAuthenticator'
op|'('
name|'Authenticator'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Authenticator for receiving entities.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|namespace
name|'namespace'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|associateWithStream
name|'def'
name|'associateWithStream'
op|'('
name|'self'
op|','
name|'xmlstream'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called by the XmlStreamFactory when a connection has been made.\n\n        Extend L{Authenticator.associateWithStream} to set the L{XmlStream}\n        to be non-initiating.\n        """'
newline|'\n'
name|'Authenticator'
op|'.'
name|'associateWithStream'
op|'('
name|'self'
op|','
name|'xmlstream'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'initiating'
op|'='
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|streamStarted
dedent|''
name|'def'
name|'streamStarted'
op|'('
name|'self'
op|','
name|'rootElement'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called by the XmlStream when the stream has started.\n\n        This extends L{Authenticator.streamStarted} to extract further\n        information from the stream headers from L{rootElement}.\n        """'
newline|'\n'
name|'Authenticator'
op|'.'
name|'streamStarted'
op|'('
name|'self'
op|','
name|'rootElement'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'namespace'
op|'='
name|'rootElement'
op|'.'
name|'defaultUri'
newline|'\n'
nl|'\n'
name|'if'
name|'rootElement'
op|'.'
name|'hasAttribute'
op|'('
string|'"to"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'thisEntity'
op|'='
name|'jid'
op|'.'
name|'internJID'
op|'('
name|'rootElement'
op|'['
string|'"to"'
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'prefixes'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'prefix'
op|','
name|'uri'
name|'in'
name|'rootElement'
op|'.'
name|'localPrefixes'
op|'.'
name|'iteritems'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'prefixes'
op|'['
name|'uri'
op|']'
op|'='
name|'prefix'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'sid'
op|'='
name|'randbytes'
op|'.'
name|'secureRandom'
op|'('
number|'8'
op|')'
op|'.'
name|'encode'
op|'('
string|"'hex'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|FeatureNotAdvertized
dedent|''
dedent|''
name|'class'
name|'FeatureNotAdvertized'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Exception indicating a stream feature was not advertized, while required by\n    the initiating entity.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|BaseFeatureInitiatingInitializer
dedent|''
name|'class'
name|'BaseFeatureInitiatingInitializer'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Base class for initializers with a stream feature.\n\n    This assumes the associated XmlStream represents the initiating entity\n    of the connection.\n\n    @cvar feature: tuple of (uri, name) of the stream feature root element.\n    @type feature: tuple of (L{str}, L{str})\n    @ivar required: whether the stream feature is required to be advertized\n                    by the receiving entity.\n    @type required: L{bool}\n    """'
newline|'\n'
nl|'\n'
name|'implements'
op|'('
name|'ijabber'
op|'.'
name|'IInitiatingInitializer'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|feature
name|'feature'
op|'='
name|'None'
newline|'\n'
DECL|variable|required
name|'required'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'xs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'xmlstream'
op|'='
name|'xs'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|initialize
dedent|''
name|'def'
name|'initialize'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Initiate the initialization.\n\n        Checks if the receiving entity advertizes the stream feature. If it\n        does, the initialization is started. If it is not advertized, and the\n        C{required} instance variable is L{True}, it raises\n        L{FeatureNotAdvertized}. Otherwise, the initialization silently\n        succeeds.\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'feature'
name|'in'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'features'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'start'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'required'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'FeatureNotAdvertized'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|start
dedent|''
dedent|''
name|'def'
name|'start'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Start the actual initialization.\n\n        May return a deferred for asynchronous initialization.\n        """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TLSError
dedent|''
dedent|''
name|'class'
name|'TLSError'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    TLS base exception.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TLSFailed
dedent|''
name|'class'
name|'TLSFailed'
op|'('
name|'TLSError'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Exception indicating failed TLS negotiation\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TLSRequired
dedent|''
name|'class'
name|'TLSRequired'
op|'('
name|'TLSError'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Exception indicating required TLS negotiation.\n\n    This exception is raised when the receiving entity requires TLS\n    negotiation and the initiating does not desire to negotiate TLS.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TLSNotSupported
dedent|''
name|'class'
name|'TLSNotSupported'
op|'('
name|'TLSError'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Exception indicating missing TLS support.\n\n    This exception is raised when the initiating entity wants and requires to\n    negotiate TLS when the OpenSSL library is not available.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TLSInitiatingInitializer
dedent|''
name|'class'
name|'TLSInitiatingInitializer'
op|'('
name|'BaseFeatureInitiatingInitializer'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    TLS stream initializer for the initiating entity.\n\n    It is strongly required to include this initializer in the list of\n    initializers for an XMPP stream. By default it will try to negotiate TLS.\n    An XMPP server may indicate that TLS is required. If TLS is not desired,\n    set the C{wanted} attribute to False instead of removing it from the list\n    of initializers, so a proper exception L{TLSRequired} can be raised.\n\n    @cvar wanted: indicates if TLS negotiation is wanted.\n    @type wanted: L{bool}\n    """'
newline|'\n'
nl|'\n'
DECL|variable|feature
name|'feature'
op|'='
op|'('
name|'NS_XMPP_TLS'
op|','
string|"'starttls'"
op|')'
newline|'\n'
DECL|variable|wanted
name|'wanted'
op|'='
name|'True'
newline|'\n'
DECL|variable|_deferred
name|'_deferred'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|onProceed
name|'def'
name|'onProceed'
op|'('
name|'self'
op|','
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Proceed with TLS negotiation and reset the XML stream.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'removeObserver'
op|'('
string|"'/failure'"
op|','
name|'self'
op|'.'
name|'onFailure'
op|')'
newline|'\n'
name|'ctx'
op|'='
name|'ssl'
op|'.'
name|'CertificateOptions'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'transport'
op|'.'
name|'startTLS'
op|'('
name|'ctx'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'reset'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'sendHeader'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_deferred'
op|'.'
name|'callback'
op|'('
name|'Reset'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|onFailure
dedent|''
name|'def'
name|'onFailure'
op|'('
name|'self'
op|','
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'removeObserver'
op|'('
string|"'/proceed'"
op|','
name|'self'
op|'.'
name|'onProceed'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_deferred'
op|'.'
name|'errback'
op|'('
name|'TLSFailed'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|start
dedent|''
name|'def'
name|'start'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Start TLS negotiation.\n\n        This checks if the receiving entity requires TLS, the SSL library is\n        available and uses the C{required} and C{wanted} instance variables to\n        determine what to do in the various different cases.\n\n        For example, if the SSL library is not available, and wanted and\n        required by the user, it raises an exception. However if it is not\n        required by both parties, initialization silently succeeds, moving\n        on to the next step.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'wanted'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'ssl'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'required'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'defer'
op|'.'
name|'fail'
op|'('
name|'TLSNotSupported'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'defer'
op|'.'
name|'succeed'
op|'('
name|'None'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'features'
op|'['
name|'self'
op|'.'
name|'feature'
op|']'
op|'.'
name|'required'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'defer'
op|'.'
name|'fail'
op|'('
name|'TLSRequired'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'defer'
op|'.'
name|'succeed'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_deferred'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'addOnetimeObserver'
op|'('
string|'"/proceed"'
op|','
name|'self'
op|'.'
name|'onProceed'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'addOnetimeObserver'
op|'('
string|'"/failure"'
op|','
name|'self'
op|'.'
name|'onFailure'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'send'
op|'('
name|'domish'
op|'.'
name|'Element'
op|'('
op|'('
name|'NS_XMPP_TLS'
op|','
string|'"starttls"'
op|')'
op|')'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_deferred'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|XmlStream
dedent|''
dedent|''
name|'class'
name|'XmlStream'
op|'('
name|'xmlstream'
op|'.'
name|'XmlStream'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    XMPP XML Stream protocol handler.\n\n    @ivar version: XML stream version as a tuple (major, minor). Initially,\n                   this is set to the minimally supported version. Upon\n                   receiving the stream header of the peer, it is set to the\n                   minimum of that value and the version on the received\n                   header.\n    @type version: (L{int}, L{int})\n    @ivar namespace: default namespace URI for stream\n    @type namespace: L{str}\n    @ivar thisEntity: JID of this entity\n    @type thisEntity: L{JID}\n    @ivar otherEntity: JID of the peer entity\n    @type otherEntity: L{JID}\n    @ivar sid: session identifier\n    @type sid: L{str}\n    @ivar initiating: True if this is the initiating stream\n    @type initiating: L{bool}\n    @ivar features: map of (uri, name) to stream features element received from\n                    the receiving entity.\n    @type features: L{dict} of (L{str}, L{str}) to L{domish.Element}.\n    @ivar prefixes: map of URI to prefixes that are to appear on stream\n                    header.\n    @type prefixes: L{dict} of L{str} to L{str}\n    @ivar initializers: list of stream initializer objects\n    @type initializers: L{list} of objects that provide L{IInitializer}\n    @ivar authenticator: associated authenticator that uses C{initializers} to\n                         initialize the XML stream.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|version
name|'version'
op|'='
op|'('
number|'1'
op|','
number|'0'
op|')'
newline|'\n'
DECL|variable|namespace
name|'namespace'
op|'='
string|"'invalid'"
newline|'\n'
DECL|variable|thisEntity
name|'thisEntity'
op|'='
name|'None'
newline|'\n'
DECL|variable|otherEntity
name|'otherEntity'
op|'='
name|'None'
newline|'\n'
DECL|variable|sid
name|'sid'
op|'='
name|'None'
newline|'\n'
DECL|variable|initiating
name|'initiating'
op|'='
name|'True'
newline|'\n'
nl|'\n'
DECL|variable|_headerSent
name|'_headerSent'
op|'='
name|'False'
comment|'# True if the stream header has been sent'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'authenticator'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'xmlstream'
op|'.'
name|'XmlStream'
op|'.'
name|'__init__'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'prefixes'
op|'='
op|'{'
name|'NS_STREAMS'
op|':'
string|"'stream'"
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'authenticator'
op|'='
name|'authenticator'
newline|'\n'
name|'self'
op|'.'
name|'initializers'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'features'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
comment|'# Reset the authenticator'
nl|'\n'
name|'authenticator'
op|'.'
name|'associateWithStream'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_callLater
dedent|''
name|'def'
name|'_callLater'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'reactor'
newline|'\n'
name|'return'
name|'reactor'
op|'.'
name|'callLater'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|reset
dedent|''
name|'def'
name|'reset'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Reset XML Stream.\n\n        Resets the XML Parser for incoming data. This is to be used after\n        successfully negotiating a new layer, e.g. TLS and SASL. Note that\n        registered event observers will continue to be in place.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_headerSent'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_initializeStream'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|onStreamError
dedent|''
name|'def'
name|'onStreamError'
op|'('
name|'self'
op|','
name|'errelem'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when a stream:error element has been received.\n\n        Dispatches a L{STREAM_ERROR_EVENT} event with the error element to\n        allow for cleanup actions and drops the connection.\n\n        @param errelem: The received error element.\n        @type errelem: L{domish.Element}\n        """'
newline|'\n'
name|'self'
op|'.'
name|'dispatch'
op|'('
name|'failure'
op|'.'
name|'Failure'
op|'('
name|'error'
op|'.'
name|'exceptionFromStreamError'
op|'('
name|'errelem'
op|')'
op|')'
op|','
nl|'\n'
name|'STREAM_ERROR_EVENT'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|sendHeader
dedent|''
name|'def'
name|'sendHeader'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send stream header.\n        """'
newline|'\n'
comment|'# set up optional extra namespaces'
nl|'\n'
name|'localPrefixes'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'uri'
op|','
name|'prefix'
name|'in'
name|'self'
op|'.'
name|'prefixes'
op|'.'
name|'iteritems'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'uri'
op|'!='
name|'NS_STREAMS'
op|':'
newline|'\n'
indent|'                '
name|'localPrefixes'
op|'['
name|'prefix'
op|']'
op|'='
name|'uri'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'rootElement'
op|'='
name|'domish'
op|'.'
name|'Element'
op|'('
op|'('
name|'NS_STREAMS'
op|','
string|"'stream'"
op|')'
op|','
name|'self'
op|'.'
name|'namespace'
op|','
nl|'\n'
name|'localPrefixes'
op|'='
name|'localPrefixes'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'otherEntity'
op|':'
newline|'\n'
indent|'            '
name|'rootElement'
op|'['
string|"'to'"
op|']'
op|'='
name|'self'
op|'.'
name|'otherEntity'
op|'.'
name|'userhost'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'thisEntity'
op|':'
newline|'\n'
indent|'            '
name|'rootElement'
op|'['
string|"'from'"
op|']'
op|'='
name|'self'
op|'.'
name|'thisEntity'
op|'.'
name|'userhost'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'initiating'
name|'and'
name|'self'
op|'.'
name|'sid'
op|':'
newline|'\n'
indent|'            '
name|'rootElement'
op|'['
string|"'id'"
op|']'
op|'='
name|'self'
op|'.'
name|'sid'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'version'
op|'>='
op|'('
number|'1'
op|','
number|'0'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'rootElement'
op|'['
string|"'version'"
op|']'
op|'='
string|'"%d.%d"'
op|'%'
name|'self'
op|'.'
name|'version'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'send'
op|'('
name|'rootElement'
op|'.'
name|'toXml'
op|'('
name|'prefixes'
op|'='
name|'self'
op|'.'
name|'prefixes'
op|','
name|'closeElement'
op|'='
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_headerSent'
op|'='
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|sendFooter
dedent|''
name|'def'
name|'sendFooter'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send stream footer.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'send'
op|'('
string|"'</stream:stream>'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|sendStreamError
dedent|''
name|'def'
name|'sendStreamError'
op|'('
name|'self'
op|','
name|'streamError'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send stream level error.\n\n        If we are the receiving entity, and haven\'t sent the header yet,\n        we sent one first.\n\n        After sending the stream error, the stream is closed and the transport\n        connection dropped.\n\n        @param streamError: stream error instance\n        @type streamError: L{error.StreamError}\n        """'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_headerSent'
name|'and'
name|'not'
name|'self'
op|'.'
name|'initiating'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sendHeader'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_headerSent'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'send'
op|'('
name|'streamError'
op|'.'
name|'getElement'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'sendFooter'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|send
dedent|''
name|'def'
name|'send'
op|'('
name|'self'
op|','
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send data over the stream.\n\n        This overrides L{xmlstream.Xmlstream.send} to use the default namespace\n        of the stream header when serializing L{domish.IElement}s. It is\n        assumed that if you pass an object that provides L{domish.IElement},\n        it represents a direct child of the stream\'s root element.\n        """'
newline|'\n'
name|'if'
name|'domish'
op|'.'
name|'IElement'
op|'.'
name|'providedBy'
op|'('
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'obj'
op|'='
name|'obj'
op|'.'
name|'toXml'
op|'('
name|'prefixes'
op|'='
name|'self'
op|'.'
name|'prefixes'
op|','
nl|'\n'
name|'defaultUri'
op|'='
name|'self'
op|'.'
name|'namespace'
op|','
nl|'\n'
name|'prefixesInScope'
op|'='
name|'self'
op|'.'
name|'prefixes'
op|'.'
name|'values'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'xmlstream'
op|'.'
name|'XmlStream'
op|'.'
name|'send'
op|'('
name|'self'
op|','
name|'obj'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionMade
dedent|''
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when a connection is made.\n\n        Notifies the authenticator when a connection has been made.\n        """'
newline|'\n'
name|'xmlstream'
op|'.'
name|'XmlStream'
op|'.'
name|'connectionMade'
op|'('
name|'self'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'authenticator'
op|'.'
name|'connectionMade'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|onDocumentStart
dedent|''
name|'def'
name|'onDocumentStart'
op|'('
name|'self'
op|','
name|'rootElement'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when the stream header has been received.\n\n        Extracts the header\'s C{id} and C{version} attributes from the root\n        element. The C{id} attribute is stored in our C{sid} attribute and the\n        C{version} attribute is parsed and the minimum of the version we sent\n        and the parsed C{version} attribute is stored as a tuple (major, minor)\n        in this class\' C{version} attribute. If no C{version} attribute was\n        present, we assume version 0.0.\n\n        If appropriate (we are the initiating stream and the minimum of our and\n        the other party\'s version is at least 1.0), a one-time observer is\n        registered for getting the stream features. The registered function is\n        C{onFeatures}.\n\n        Ultimately, the authenticator\'s C{streamStarted} method will be called.\n\n        @param rootElement: The root element.\n        @type rootElement: L{domish.Element}\n        """'
newline|'\n'
name|'xmlstream'
op|'.'
name|'XmlStream'
op|'.'
name|'onDocumentStart'
op|'('
name|'self'
op|','
name|'rootElement'
op|')'
newline|'\n'
nl|'\n'
comment|'# Setup observer for stream errors'
nl|'\n'
name|'self'
op|'.'
name|'addOnetimeObserver'
op|'('
string|'"/error[@xmlns=\'%s\']"'
op|'%'
name|'NS_STREAMS'
op|','
nl|'\n'
name|'self'
op|'.'
name|'onStreamError'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'authenticator'
op|'.'
name|'streamStarted'
op|'('
name|'rootElement'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|XmlStreamFactory
dedent|''
dedent|''
name|'class'
name|'XmlStreamFactory'
op|'('
name|'xmlstream'
op|'.'
name|'XmlStreamFactory'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Factory for Jabber XmlStream objects as a reconnecting client.\n\n    Note that this differs from L{xmlstream.XmlStreamFactory} in that\n    it generates Jabber specific L{XmlStream} instances that have\n    authenticators.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|protocol
name|'protocol'
op|'='
name|'XmlStream'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'authenticator'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'xmlstream'
op|'.'
name|'XmlStreamFactory'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'authenticator'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'authenticator'
op|'='
name|'authenticator'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'class'
name|'XmlStreamServerFactory'
op|'('
name|'xmlstream'
op|'.'
name|'BootstrapMixin'
op|','
nl|'\n'
DECL|class|XmlStreamServerFactory
name|'protocol'
op|'.'
name|'ServerFactory'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Factory for Jabber XmlStream objects as a server.\n\n    @since: 8.2.\n    @ivar authenticatorFactory: Factory callable that takes no arguments, to\n                                create a fresh authenticator to be associated\n                                with the XmlStream.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|protocol
name|'protocol'
op|'='
name|'XmlStream'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'authenticatorFactory'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'xmlstream'
op|'.'
name|'BootstrapMixin'
op|'.'
name|'__init__'
op|'('
name|'self'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'authenticatorFactory'
op|'='
name|'authenticatorFactory'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|buildProtocol
dedent|''
name|'def'
name|'buildProtocol'
op|'('
name|'self'
op|','
name|'addr'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create an instance of XmlStream.\n\n        A new authenticator instance will be created and passed to the new\n        XmlStream. Registered bootstrap event observers are installed as well.\n        """'
newline|'\n'
name|'authenticator'
op|'='
name|'self'
op|'.'
name|'authenticatorFactory'
op|'('
op|')'
newline|'\n'
name|'xs'
op|'='
name|'self'
op|'.'
name|'protocol'
op|'('
name|'authenticator'
op|')'
newline|'\n'
name|'xs'
op|'.'
name|'factory'
op|'='
name|'self'
newline|'\n'
name|'self'
op|'.'
name|'installBootstraps'
op|'('
name|'xs'
op|')'
newline|'\n'
name|'return'
name|'xs'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TimeoutError
dedent|''
dedent|''
name|'class'
name|'TimeoutError'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Exception raised when no IQ response has been received before the\n    configured timeout.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|upgradeWithIQResponseTracker
dedent|''
name|'def'
name|'upgradeWithIQResponseTracker'
op|'('
name|'xs'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Enhances an XmlStream for iq response tracking.\n\n    This makes an L{XmlStream} object provide L{IIQResponseTracker}. When a\n    response is an error iq stanza, the deferred has its errback invoked with a\n    failure that holds a L{StanzaException<error.StanzaException>} that is\n    easier to examine.\n    """'
newline|'\n'
DECL|function|callback
name|'def'
name|'callback'
op|'('
name|'iq'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Handle iq response by firing associated deferred.\n        """'
newline|'\n'
name|'if'
name|'getattr'
op|'('
name|'iq'
op|','
string|"'handled'"
op|','
name|'False'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'='
name|'xs'
op|'.'
name|'iqDeferreds'
op|'['
name|'iq'
op|'['
string|'"id"'
op|']'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'del'
name|'xs'
op|'.'
name|'iqDeferreds'
op|'['
name|'iq'
op|'['
string|'"id"'
op|']'
op|']'
newline|'\n'
name|'iq'
op|'.'
name|'handled'
op|'='
name|'True'
newline|'\n'
name|'if'
name|'iq'
op|'['
string|"'type'"
op|']'
op|'=='
string|"'error'"
op|':'
newline|'\n'
indent|'                '
name|'d'
op|'.'
name|'errback'
op|'('
name|'error'
op|'.'
name|'exceptionFromStanza'
op|'('
name|'iq'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'d'
op|'.'
name|'callback'
op|'('
name|'iq'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|disconnected
dedent|''
dedent|''
dedent|''
name|'def'
name|'disconnected'
op|'('
name|'_'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Make sure deferreds do not linger on after disconnect.\n\n        This errbacks all deferreds of iq\'s for which no response has been\n        received with a L{ConnectionLost} failure. Otherwise, the deferreds\n        will never be fired.\n        """'
newline|'\n'
name|'iqDeferreds'
op|'='
name|'xs'
op|'.'
name|'iqDeferreds'
newline|'\n'
name|'xs'
op|'.'
name|'iqDeferreds'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'d'
name|'in'
name|'iqDeferreds'
op|'.'
name|'itervalues'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'.'
name|'errback'
op|'('
name|'ConnectionLost'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'xs'
op|'.'
name|'iqDeferreds'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'xs'
op|'.'
name|'iqDefaultTimeout'
op|'='
name|'getattr'
op|'('
name|'xs'
op|','
string|"'iqDefaultTimeout'"
op|','
name|'None'
op|')'
newline|'\n'
name|'xs'
op|'.'
name|'addObserver'
op|'('
name|'xmlstream'
op|'.'
name|'STREAM_END_EVENT'
op|','
name|'disconnected'
op|')'
newline|'\n'
name|'xs'
op|'.'
name|'addObserver'
op|'('
string|'\'/iq[@type="result"]\''
op|','
name|'callback'
op|')'
newline|'\n'
name|'xs'
op|'.'
name|'addObserver'
op|'('
string|'\'/iq[@type="error"]\''
op|','
name|'callback'
op|')'
newline|'\n'
name|'directlyProvides'
op|'('
name|'xs'
op|','
name|'ijabber'
op|'.'
name|'IIQResponseTracker'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|IQ
dedent|''
name|'class'
name|'IQ'
op|'('
name|'domish'
op|'.'
name|'Element'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Wrapper for an iq stanza.\n\n    Iq stanzas are used for communications with a request-response behaviour.\n    Each iq request is associated with an XML stream and has its own unique id\n    to be able to track the response.\n\n    @ivar timeout: if set, a timeout period after which the deferred returned\n                   by C{send} will have its errback called with a\n                   L{TimeoutError} failure.\n    @type timeout: C{float}\n    """'
newline|'\n'
nl|'\n'
DECL|variable|timeout
name|'timeout'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'xmlstream'
op|','
name|'stanzaType'
op|'='
string|'"set"'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @type xmlstream: L{xmlstream.XmlStream}\n        @param xmlstream: XmlStream to use for transmission of this IQ\n\n        @type stanzaType: L{str}\n        @param stanzaType: IQ type identifier (\'get\' or \'set\')\n        """'
newline|'\n'
name|'domish'
op|'.'
name|'Element'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
op|'('
name|'None'
op|','
string|'"iq"'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addUniqueId'
op|'('
op|')'
newline|'\n'
name|'self'
op|'['
string|'"type"'
op|']'
op|'='
name|'stanzaType'
newline|'\n'
name|'self'
op|'.'
name|'_xmlstream'
op|'='
name|'xmlstream'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|send
dedent|''
name|'def'
name|'send'
op|'('
name|'self'
op|','
name|'to'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send out this iq.\n\n        Returns a deferred that is fired when an iq response with the same id\n        is received. Result responses will be passed to the deferred callback.\n        Error responses will be transformed into a\n        L{StanzaError<error.StanzaError>} and result in the errback of the\n        deferred being invoked.\n\n        @rtype: L{defer.Deferred}\n        """'
newline|'\n'
name|'if'
name|'to'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'['
string|'"to"'
op|']'
op|'='
name|'to'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'ijabber'
op|'.'
name|'IIQResponseTracker'
op|'.'
name|'providedBy'
op|'('
name|'self'
op|'.'
name|'_xmlstream'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'upgradeWithIQResponseTracker'
op|'('
name|'self'
op|'.'
name|'_xmlstream'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'d'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_xmlstream'
op|'.'
name|'iqDeferreds'
op|'['
name|'self'
op|'['
string|"'id'"
op|']'
op|']'
op|'='
name|'d'
newline|'\n'
nl|'\n'
name|'timeout'
op|'='
name|'self'
op|'.'
name|'timeout'
name|'or'
name|'self'
op|'.'
name|'_xmlstream'
op|'.'
name|'iqDefaultTimeout'
newline|'\n'
name|'if'
name|'timeout'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
DECL|function|onTimeout
indent|'            '
name|'def'
name|'onTimeout'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'del'
name|'self'
op|'.'
name|'_xmlstream'
op|'.'
name|'iqDeferreds'
op|'['
name|'self'
op|'['
string|"'id'"
op|']'
op|']'
newline|'\n'
name|'d'
op|'.'
name|'errback'
op|'('
name|'TimeoutError'
op|'('
string|'"IQ timed out"'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'call'
op|'='
name|'self'
op|'.'
name|'_xmlstream'
op|'.'
name|'_callLater'
op|'('
name|'timeout'
op|','
name|'onTimeout'
op|')'
newline|'\n'
nl|'\n'
DECL|function|cancelTimeout
name|'def'
name|'cancelTimeout'
op|'('
name|'result'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'call'
op|'.'
name|'active'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'call'
op|'.'
name|'cancel'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
dedent|''
name|'d'
op|'.'
name|'addBoth'
op|'('
name|'cancelTimeout'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_xmlstream'
op|'.'
name|'send'
op|'('
name|'self'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|toResponse
dedent|''
dedent|''
name|'def'
name|'toResponse'
op|'('
name|'stanza'
op|','
name|'stanzaType'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Create a response stanza from another stanza.\n\n    This takes the addressing and id attributes from a stanza to create a (new,\n    empty) response stanza. The addressing attributes are swapped and the id\n    copied. Optionally, the stanza type of the response can be specified.\n\n    @param stanza: the original stanza\n    @type stanza: L{domish.Element}\n    @param stanzaType: optional response stanza type\n    @type stanzaType: C{str}\n    @return: the response stanza.\n    @rtype: L{domish.Element}\n    """'
newline|'\n'
nl|'\n'
name|'toAddr'
op|'='
name|'stanza'
op|'.'
name|'getAttribute'
op|'('
string|"'from'"
op|')'
newline|'\n'
name|'fromAddr'
op|'='
name|'stanza'
op|'.'
name|'getAttribute'
op|'('
string|"'to'"
op|')'
newline|'\n'
name|'stanzaID'
op|'='
name|'stanza'
op|'.'
name|'getAttribute'
op|'('
string|"'id'"
op|')'
newline|'\n'
nl|'\n'
name|'response'
op|'='
name|'domish'
op|'.'
name|'Element'
op|'('
op|'('
name|'None'
op|','
name|'stanza'
op|'.'
name|'name'
op|')'
op|')'
newline|'\n'
name|'if'
name|'toAddr'
op|':'
newline|'\n'
indent|'        '
name|'response'
op|'['
string|"'to'"
op|']'
op|'='
name|'toAddr'
newline|'\n'
dedent|''
name|'if'
name|'fromAddr'
op|':'
newline|'\n'
indent|'        '
name|'response'
op|'['
string|"'from'"
op|']'
op|'='
name|'fromAddr'
newline|'\n'
dedent|''
name|'if'
name|'stanzaID'
op|':'
newline|'\n'
indent|'        '
name|'response'
op|'['
string|"'id'"
op|']'
op|'='
name|'stanzaID'
newline|'\n'
dedent|''
name|'if'
name|'stanzaType'
op|':'
newline|'\n'
indent|'        '
name|'response'
op|'['
string|"'type'"
op|']'
op|'='
name|'stanzaType'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'response'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|XMPPHandler
dedent|''
name|'class'
name|'XMPPHandler'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    XMPP protocol handler.\n\n    Classes derived from this class implement (part of) one or more XMPP\n    extension protocols, and are referred to as a subprotocol implementation.\n    """'
newline|'\n'
nl|'\n'
name|'implements'
op|'('
name|'ijabber'
op|'.'
name|'IXMPPHandler'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'parent'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|setHandlerParent
dedent|''
name|'def'
name|'setHandlerParent'
op|'('
name|'self'
op|','
name|'parent'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'parent'
op|'='
name|'parent'
newline|'\n'
name|'self'
op|'.'
name|'parent'
op|'.'
name|'addHandler'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|disownHandlerParent
dedent|''
name|'def'
name|'disownHandlerParent'
op|'('
name|'self'
op|','
name|'parent'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'parent'
op|'.'
name|'removeHandler'
op|'('
name|'self'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'parent'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|makeConnection
dedent|''
name|'def'
name|'makeConnection'
op|'('
name|'self'
op|','
name|'xs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'xmlstream'
op|'='
name|'xs'
newline|'\n'
name|'self'
op|'.'
name|'connectionMade'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionMade
dedent|''
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called after a connection has been established.\n\n        Can be overridden to perform work before stream initialization.\n        """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionInitialized
dedent|''
name|'def'
name|'connectionInitialized'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The XML stream has been initialized.\n\n        Can be overridden to perform work after stream initialization, e.g. to\n        set up observers and start exchanging XML stanzas.\n        """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionLost
dedent|''
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The XML stream has been closed.\n\n        This method can be extended to inspect the C{reason} argument and\n        act on it.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|send
dedent|''
name|'def'
name|'send'
op|'('
name|'self'
op|','
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send data over the managed XML stream.\n\n        @note: The stream manager maintains a queue for data sent using this\n               method when there is no current initialized XML stream. This\n               data is then sent as soon as a new stream has been established\n               and initialized. Subsequently, L{connectionInitialized} will be\n               called again. If this queueing is not desired, use C{send} on\n               C{self.xmlstream}.\n\n        @param obj: data to be sent over the XML stream. This is usually an\n                    object providing L{domish.IElement}, or serialized XML. See\n                    L{xmlstream.XmlStream} for details.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'parent'
op|'.'
name|'send'
op|'('
name|'obj'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|XMPPHandlerCollection
dedent|''
dedent|''
name|'class'
name|'XMPPHandlerCollection'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Collection of XMPP subprotocol handlers.\n\n    This allows for grouping of subprotocol handlers, but is not an\n    L{XMPPHandler} itself, so this is not recursive.\n\n    @ivar handlers: List of protocol handlers.\n    @type handlers: L{list} of objects providing\n                      L{IXMPPHandler}\n    """'
newline|'\n'
nl|'\n'
name|'implements'
op|'('
name|'ijabber'
op|'.'
name|'IXMPPHandlerCollection'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'handlers'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__iter__
dedent|''
name|'def'
name|'__iter__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Act as a container for handlers.\n        """'
newline|'\n'
name|'return'
name|'iter'
op|'('
name|'self'
op|'.'
name|'handlers'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|addHandler
dedent|''
name|'def'
name|'addHandler'
op|'('
name|'self'
op|','
name|'handler'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Add protocol handler.\n\n        Protocol handlers are expected to provide L{ijabber.IXMPPHandler}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'handlers'
op|'.'
name|'append'
op|'('
name|'handler'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|removeHandler
dedent|''
name|'def'
name|'removeHandler'
op|'('
name|'self'
op|','
name|'handler'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Remove protocol handler.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'handlers'
op|'.'
name|'remove'
op|'('
name|'handler'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|StreamManager
dedent|''
dedent|''
name|'class'
name|'StreamManager'
op|'('
name|'XMPPHandlerCollection'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Business logic representing a managed XMPP connection.\n\n    This maintains a single XMPP connection and provides facilities for packet\n    routing and transmission. Business logic modules are objects providing\n    L{ijabber.IXMPPHandler} (like subclasses of L{XMPPHandler}), and added\n    using L{addHandler}.\n\n    @ivar xmlstream: currently managed XML stream\n    @type xmlstream: L{XmlStream}\n    @ivar logTraffic: if true, log all traffic.\n    @type logTraffic: L{bool}\n    @ivar _initialized: Whether the stream represented by L{xmlstream} has\n                        been initialized. This is used when caching outgoing\n                        stanzas.\n    @type _initialized: C{bool}\n    @ivar _packetQueue: internal buffer of unsent data. See L{send} for details.\n    @type _packetQueue: L{list}\n    """'
newline|'\n'
nl|'\n'
DECL|variable|logTraffic
name|'logTraffic'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'factory'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'XMPPHandlerCollection'
op|'.'
name|'__init__'
op|'('
name|'self'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_packetQueue'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_initialized'
op|'='
name|'False'
newline|'\n'
nl|'\n'
name|'factory'
op|'.'
name|'addBootstrap'
op|'('
name|'STREAM_CONNECTED_EVENT'
op|','
name|'self'
op|'.'
name|'_connected'
op|')'
newline|'\n'
name|'factory'
op|'.'
name|'addBootstrap'
op|'('
name|'STREAM_AUTHD_EVENT'
op|','
name|'self'
op|'.'
name|'_authd'
op|')'
newline|'\n'
name|'factory'
op|'.'
name|'addBootstrap'
op|'('
name|'INIT_FAILED_EVENT'
op|','
name|'self'
op|'.'
name|'initializationFailed'
op|')'
newline|'\n'
name|'factory'
op|'.'
name|'addBootstrap'
op|'('
name|'STREAM_END_EVENT'
op|','
name|'self'
op|'.'
name|'_disconnected'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'factory'
op|'='
name|'factory'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|addHandler
dedent|''
name|'def'
name|'addHandler'
op|'('
name|'self'
op|','
name|'handler'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Add protocol handler.\n\n        When an XML stream has already been established, the handler\'s\n        C{connectionInitialized} will be called to get it up to speed.\n        """'
newline|'\n'
name|'XMPPHandlerCollection'
op|'.'
name|'addHandler'
op|'('
name|'self'
op|','
name|'handler'
op|')'
newline|'\n'
nl|'\n'
comment|'# get protocol handler up to speed when a connection has already'
nl|'\n'
comment|'# been established'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'xmlstream'
name|'and'
name|'self'
op|'.'
name|'_initialized'
op|':'
newline|'\n'
indent|'            '
name|'handler'
op|'.'
name|'makeConnection'
op|'('
name|'self'
op|'.'
name|'xmlstream'
op|')'
newline|'\n'
name|'handler'
op|'.'
name|'connectionInitialized'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_connected
dedent|''
dedent|''
name|'def'
name|'_connected'
op|'('
name|'self'
op|','
name|'xs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when the transport connection has been established.\n\n        Here we optionally set up traffic logging (depending on L{logTraffic})\n        and call each handler\'s C{makeConnection} method with the L{XmlStream}\n        instance.\n        """'
newline|'\n'
DECL|function|logDataIn
name|'def'
name|'logDataIn'
op|'('
name|'buf'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'log'
op|'.'
name|'msg'
op|'('
string|'"RECV: %r"'
op|'%'
name|'buf'
op|')'
newline|'\n'
nl|'\n'
DECL|function|logDataOut
dedent|''
name|'def'
name|'logDataOut'
op|'('
name|'buf'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'log'
op|'.'
name|'msg'
op|'('
string|'"SEND: %r"'
op|'%'
name|'buf'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'logTraffic'
op|':'
newline|'\n'
indent|'            '
name|'xs'
op|'.'
name|'rawDataInFn'
op|'='
name|'logDataIn'
newline|'\n'
name|'xs'
op|'.'
name|'rawDataOutFn'
op|'='
name|'logDataOut'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'xmlstream'
op|'='
name|'xs'
newline|'\n'
nl|'\n'
name|'for'
name|'e'
name|'in'
name|'self'
op|':'
newline|'\n'
indent|'            '
name|'e'
op|'.'
name|'makeConnection'
op|'('
name|'xs'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_authd
dedent|''
dedent|''
name|'def'
name|'_authd'
op|'('
name|'self'
op|','
name|'xs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when the stream has been initialized.\n\n        Send out cached stanzas and call each handler\'s\n        C{connectionInitialized} method.\n        """'
newline|'\n'
comment|'# Flush all pending packets'
nl|'\n'
name|'for'
name|'p'
name|'in'
name|'self'
op|'.'
name|'_packetQueue'
op|':'
newline|'\n'
indent|'            '
name|'xs'
op|'.'
name|'send'
op|'('
name|'p'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_packetQueue'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_initialized'
op|'='
name|'True'
newline|'\n'
nl|'\n'
comment|'# Notify all child services which implement'
nl|'\n'
comment|'# the IService interface'
nl|'\n'
name|'for'
name|'e'
name|'in'
name|'self'
op|':'
newline|'\n'
indent|'            '
name|'e'
op|'.'
name|'connectionInitialized'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|initializationFailed
dedent|''
dedent|''
name|'def'
name|'initializationFailed'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when stream initialization has failed.\n\n        Stream initialization has halted, with the reason indicated by\n        C{reason}. It may be retried by calling the authenticator\'s\n        C{initializeStream}. See the respective authenticators for details.\n\n        @param reason: A failure instance indicating why stream initialization\n                       failed.\n        @type reason: L{failure.Failure}\n        """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_disconnected
dedent|''
name|'def'
name|'_disconnected'
op|'('
name|'self'
op|','
name|'_'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when the stream has been closed.\n\n        From this point on, the manager doesn\'t interact with the\n        L{XmlStream} anymore and notifies each handler that the connection\n        was lost by calling its C{connectionLost} method.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_initialized'
op|'='
name|'False'
newline|'\n'
nl|'\n'
comment|'# Notify all child services which implement'
nl|'\n'
comment|'# the IService interface'
nl|'\n'
name|'for'
name|'e'
name|'in'
name|'self'
op|':'
newline|'\n'
indent|'            '
name|'e'
op|'.'
name|'connectionLost'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|send
dedent|''
dedent|''
name|'def'
name|'send'
op|'('
name|'self'
op|','
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send data over the XML stream.\n\n        When there is no established XML stream, the data is queued and sent\n        out when a new XML stream has been established and initialized.\n\n        @param obj: data to be sent over the XML stream. See\n                    L{xmlstream.XmlStream.send} for details.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_initialized'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'send'
op|'('
name|'obj'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_packetQueue'
op|'.'
name|'append'
op|'('
name|'obj'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|variable|__all__
dedent|''
dedent|''
dedent|''
name|'__all__'
op|'='
op|'['
string|"'Authenticator'"
op|','
string|"'BaseFeatureInitiatingInitializer'"
op|','
nl|'\n'
string|"'ConnectAuthenticator'"
op|','
string|"'ConnectionLost'"
op|','
string|"'FeatureNotAdvertized'"
op|','
nl|'\n'
string|"'INIT_FAILED_EVENT'"
op|','
string|"'IQ'"
op|','
string|"'ListenAuthenticator'"
op|','
string|"'NS_STREAMS'"
op|','
nl|'\n'
string|"'NS_XMPP_TLS'"
op|','
string|"'Reset'"
op|','
string|"'STREAM_AUTHD_EVENT'"
op|','
nl|'\n'
string|"'STREAM_CONNECTED_EVENT'"
op|','
string|"'STREAM_END_EVENT'"
op|','
string|"'STREAM_ERROR_EVENT'"
op|','
nl|'\n'
string|"'STREAM_START_EVENT'"
op|','
string|"'StreamManager'"
op|','
string|"'TLSError'"
op|','
string|"'TLSFailed'"
op|','
nl|'\n'
string|"'TLSInitiatingInitializer'"
op|','
string|"'TLSNotSupported'"
op|','
string|"'TLSRequired'"
op|','
nl|'\n'
string|"'TimeoutError'"
op|','
string|"'XMPPHandler'"
op|','
string|"'XMPPHandlerCollection'"
op|','
string|"'XmlStream'"
op|','
nl|'\n'
string|"'XmlStreamFactory'"
op|','
string|"'XmlStreamServerFactory'"
op|','
string|"'hashPassword'"
op|','
nl|'\n'
string|"'toResponse'"
op|','
string|"'upgradeWithIQResponseTracker'"
op|']'
newline|'\n'
endmarker|''
end_unit
