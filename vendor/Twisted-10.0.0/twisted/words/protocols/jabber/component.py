begin_unit
comment|'# -*- test-case-name: twisted.words.test.test_jabbercomponent -*-'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Copyright (c) 2001-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nExternal server-side components.\n\nMost Jabber server implementations allow for add-on components that act as a\nseperate entity on the Jabber network, but use the server-to-server\nfunctionality of a regular Jabber IM server. These so-called \'external\ncomponents\' are connected to the Jabber server using the Jabber Component\nProtocol as defined in U{JEP-0114<http://www.jabber.org/jeps/jep-0114.html>}.\n\nThis module allows for writing external server-side component by assigning one\nor more services implementing L{ijabber.IService} up to L{ServiceManager}. The\nServiceManager connects to the Jabber server and is responsible for the\ncorresponding XML stream.\n"""'
newline|'\n'
nl|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'implements'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'application'
name|'import'
name|'service'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'defer'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'log'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'words'
op|'.'
name|'xish'
name|'import'
name|'domish'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'words'
op|'.'
name|'protocols'
op|'.'
name|'jabber'
name|'import'
name|'error'
op|','
name|'ijabber'
op|','
name|'jstrports'
op|','
name|'xmlstream'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'words'
op|'.'
name|'protocols'
op|'.'
name|'jabber'
op|'.'
name|'jid'
name|'import'
name|'internJID'
name|'as'
name|'JID'
newline|'\n'
nl|'\n'
DECL|variable|NS_COMPONENT_ACCEPT
name|'NS_COMPONENT_ACCEPT'
op|'='
string|"'jabber:component:accept'"
newline|'\n'
nl|'\n'
DECL|function|componentFactory
name|'def'
name|'componentFactory'
op|'('
name|'componentid'
op|','
name|'password'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    XML stream factory for external server-side components.\n\n    @param componentid: JID of the component.\n    @type componentid: L{unicode}\n    @param password: password used to authenticate to the server.\n    @type password: L{str}\n    """'
newline|'\n'
name|'a'
op|'='
name|'ConnectComponentAuthenticator'
op|'('
name|'componentid'
op|','
name|'password'
op|')'
newline|'\n'
name|'return'
name|'xmlstream'
op|'.'
name|'XmlStreamFactory'
op|'('
name|'a'
op|')'
newline|'\n'
nl|'\n'
DECL|class|ComponentInitiatingInitializer
dedent|''
name|'class'
name|'ComponentInitiatingInitializer'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    External server-side component authentication initializer for the\n    initiating entity.\n\n    @ivar xmlstream: XML stream between server and component.\n    @type xmlstream: L{xmlstream.XmlStream}\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'xs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'xmlstream'
op|'='
name|'xs'
newline|'\n'
name|'self'
op|'.'
name|'_deferred'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|initialize
dedent|''
name|'def'
name|'initialize'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'xs'
op|'='
name|'self'
op|'.'
name|'xmlstream'
newline|'\n'
name|'hs'
op|'='
name|'domish'
op|'.'
name|'Element'
op|'('
op|'('
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'namespace'
op|','
string|'"handshake"'
op|')'
op|')'
newline|'\n'
name|'hs'
op|'.'
name|'addContent'
op|'('
name|'xmlstream'
op|'.'
name|'hashPassword'
op|'('
name|'xs'
op|'.'
name|'sid'
op|','
nl|'\n'
name|'unicode'
op|'('
name|'xs'
op|'.'
name|'authenticator'
op|'.'
name|'password'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Setup observer to watch for handshake result'
nl|'\n'
name|'xs'
op|'.'
name|'addOnetimeObserver'
op|'('
string|'"/handshake"'
op|','
name|'self'
op|'.'
name|'_cbHandshake'
op|')'
newline|'\n'
name|'xs'
op|'.'
name|'send'
op|'('
name|'hs'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_deferred'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_deferred'
newline|'\n'
nl|'\n'
DECL|member|_cbHandshake
dedent|''
name|'def'
name|'_cbHandshake'
op|'('
name|'self'
op|','
name|'_'
op|')'
op|':'
newline|'\n'
comment|'# we have successfully shaken hands and can now consider this'
nl|'\n'
comment|'# entity to represent the component JID.'
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'thisEntity'
op|'='
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'otherEntity'
newline|'\n'
name|'self'
op|'.'
name|'_deferred'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ConnectComponentAuthenticator
dedent|''
dedent|''
name|'class'
name|'ConnectComponentAuthenticator'
op|'('
name|'xmlstream'
op|'.'
name|'ConnectAuthenticator'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Authenticator to permit an XmlStream to authenticate against a Jabber\n    server as an external component (where the Authenticator is initiating the\n    stream).\n    """'
newline|'\n'
DECL|variable|namespace
name|'namespace'
op|'='
name|'NS_COMPONENT_ACCEPT'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'componentjid'
op|','
name|'password'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @type componentjid: L{str}\n        @param componentjid: Jabber ID that this component wishes to bind to.\n\n        @type password: L{str}\n        @param password: Password/secret this component uses to authenticate.\n        """'
newline|'\n'
comment|"# Note that we are sending 'to' our desired component JID."
nl|'\n'
name|'xmlstream'
op|'.'
name|'ConnectAuthenticator'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'componentjid'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'password'
op|'='
name|'password'
newline|'\n'
nl|'\n'
DECL|member|associateWithStream
dedent|''
name|'def'
name|'associateWithStream'
op|'('
name|'self'
op|','
name|'xs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'xs'
op|'.'
name|'version'
op|'='
op|'('
number|'0'
op|','
number|'0'
op|')'
newline|'\n'
name|'xmlstream'
op|'.'
name|'ConnectAuthenticator'
op|'.'
name|'associateWithStream'
op|'('
name|'self'
op|','
name|'xs'
op|')'
newline|'\n'
nl|'\n'
name|'xs'
op|'.'
name|'initializers'
op|'='
op|'['
name|'ComponentInitiatingInitializer'
op|'('
name|'xs'
op|')'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ListenComponentAuthenticator
dedent|''
dedent|''
name|'class'
name|'ListenComponentAuthenticator'
op|'('
name|'xmlstream'
op|'.'
name|'ListenAuthenticator'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Authenticator for accepting components.\n\n    @since: 8.2\n    @ivar secret: The shared secret used to authorized incoming component\n                  connections.\n    @type secret: C{unicode}.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|namespace
name|'namespace'
op|'='
name|'NS_COMPONENT_ACCEPT'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'secret'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'secret'
op|'='
name|'secret'
newline|'\n'
name|'xmlstream'
op|'.'
name|'ListenAuthenticator'
op|'.'
name|'__init__'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|associateWithStream
dedent|''
name|'def'
name|'associateWithStream'
op|'('
name|'self'
op|','
name|'xs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Associate the authenticator with a stream.\n\n        This sets the stream\'s version to 0.0, because the XEP-0114 component\n        protocol was not designed for XMPP 1.0.\n        """'
newline|'\n'
name|'xs'
op|'.'
name|'version'
op|'='
op|'('
number|'0'
op|','
number|'0'
op|')'
newline|'\n'
name|'xmlstream'
op|'.'
name|'ListenAuthenticator'
op|'.'
name|'associateWithStream'
op|'('
name|'self'
op|','
name|'xs'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|streamStarted
dedent|''
name|'def'
name|'streamStarted'
op|'('
name|'self'
op|','
name|'rootElement'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called by the stream when it has started.\n\n        This examines the default namespace of the incoming stream and whether\n        there is a requested hostname for the component. Then it generates a\n        stream identifier, sends a response header and adds an observer for\n        the first incoming element, triggering L{onElement}.\n        """'
newline|'\n'
nl|'\n'
name|'xmlstream'
op|'.'
name|'ListenAuthenticator'
op|'.'
name|'streamStarted'
op|'('
name|'self'
op|','
name|'rootElement'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'rootElement'
op|'.'
name|'defaultUri'
op|'!='
name|'self'
op|'.'
name|'namespace'
op|':'
newline|'\n'
indent|'            '
name|'exc'
op|'='
name|'error'
op|'.'
name|'StreamError'
op|'('
string|"'invalid-namespace'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'sendStreamError'
op|'('
name|'exc'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
comment|'# self.xmlstream.thisEntity is set to the address the component'
nl|'\n'
comment|'# wants to assume.'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'thisEntity'
op|':'
newline|'\n'
indent|'            '
name|'exc'
op|'='
name|'error'
op|'.'
name|'StreamError'
op|'('
string|"'improper-addressing'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'sendStreamError'
op|'('
name|'exc'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'sendHeader'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'addOnetimeObserver'
op|'('
string|"'/*'"
op|','
name|'self'
op|'.'
name|'onElement'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|onElement
dedent|''
name|'def'
name|'onElement'
op|'('
name|'self'
op|','
name|'element'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called on incoming XML Stanzas.\n\n        The very first element received should be a request for handshake.\n        Otherwise, the stream is dropped with a \'not-authorized\' error. If a\n        handshake request was received, the hash is extracted and passed to\n        L{onHandshake}.\n        """'
newline|'\n'
name|'if'
op|'('
name|'element'
op|'.'
name|'uri'
op|','
name|'element'
op|'.'
name|'name'
op|')'
op|'=='
op|'('
name|'self'
op|'.'
name|'namespace'
op|','
string|"'handshake'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'onHandshake'
op|'('
name|'unicode'
op|'('
name|'element'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'exc'
op|'='
name|'error'
op|'.'
name|'StreamError'
op|'('
string|"'not-authorized'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'sendStreamError'
op|'('
name|'exc'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|onHandshake
dedent|''
dedent|''
name|'def'
name|'onHandshake'
op|'('
name|'self'
op|','
name|'handshake'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called upon receiving the handshake request.\n\n        This checks that the given hash in C{handshake} is equal to a\n        calculated hash, responding with a handshake reply or a stream error.\n        If the handshake was ok, the stream is authorized, and  XML Stanzas may\n        be exchanged.\n        """'
newline|'\n'
name|'calculatedHash'
op|'='
name|'xmlstream'
op|'.'
name|'hashPassword'
op|'('
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'sid'
op|','
nl|'\n'
name|'unicode'
op|'('
name|'self'
op|'.'
name|'secret'
op|')'
op|')'
newline|'\n'
name|'if'
name|'handshake'
op|'!='
name|'calculatedHash'
op|':'
newline|'\n'
indent|'            '
name|'exc'
op|'='
name|'error'
op|'.'
name|'StreamError'
op|'('
string|"'not-authorized'"
op|','
name|'text'
op|'='
string|"'Invalid hash'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'sendStreamError'
op|'('
name|'exc'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'send'
op|'('
string|"'<handshake/>'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'dispatch'
op|'('
name|'self'
op|'.'
name|'xmlstream'
op|','
nl|'\n'
name|'xmlstream'
op|'.'
name|'STREAM_AUTHD_EVENT'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|Service
dedent|''
dedent|''
dedent|''
name|'class'
name|'Service'
op|'('
name|'service'
op|'.'
name|'Service'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    External server-side component service.\n    """'
newline|'\n'
nl|'\n'
name|'implements'
op|'('
name|'ijabber'
op|'.'
name|'IService'
op|')'
newline|'\n'
nl|'\n'
DECL|member|componentConnected
name|'def'
name|'componentConnected'
op|'('
name|'self'
op|','
name|'xs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|componentDisconnected
dedent|''
name|'def'
name|'componentDisconnected'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|transportConnected
dedent|''
name|'def'
name|'transportConnected'
op|'('
name|'self'
op|','
name|'xs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|send
dedent|''
name|'def'
name|'send'
op|'('
name|'self'
op|','
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send data over service parent\'s XML stream.\n\n        @note: L{ServiceManager} maintains a queue for data sent using this\n        method when there is no current established XML stream. This data is\n        then sent as soon as a new stream has been established and initialized.\n        Subsequently, L{componentConnected} will be called again. If this\n        queueing is not desired, use C{send} on the XmlStream object (passed to\n        L{componentConnected}) directly.\n\n        @param obj: data to be sent over the XML stream. This is usually an\n        object providing L{domish.IElement}, or serialized XML. See\n        L{xmlstream.XmlStream} for details.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'parent'
op|'.'
name|'send'
op|'('
name|'obj'
op|')'
newline|'\n'
nl|'\n'
DECL|class|ServiceManager
dedent|''
dedent|''
name|'class'
name|'ServiceManager'
op|'('
name|'service'
op|'.'
name|'MultiService'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Business logic representing a managed component connection to a Jabber\n    router.\n\n    This service maintains a single connection to a Jabber router and provides\n    facilities for packet routing and transmission. Business logic modules are\n    services implementing L{ijabber.IService} (like subclasses of L{Service}), and\n    added as sub-service.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'jid'
op|','
name|'password'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'service'
op|'.'
name|'MultiService'
op|'.'
name|'__init__'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
comment|'# Setup defaults'
nl|'\n'
name|'self'
op|'.'
name|'jabberId'
op|'='
name|'jid'
newline|'\n'
name|'self'
op|'.'
name|'xmlstream'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# Internal buffer of packets'
nl|'\n'
name|'self'
op|'.'
name|'_packetQueue'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
comment|'# Setup the xmlstream factory'
nl|'\n'
name|'self'
op|'.'
name|'_xsFactory'
op|'='
name|'componentFactory'
op|'('
name|'self'
op|'.'
name|'jabberId'
op|','
name|'password'
op|')'
newline|'\n'
nl|'\n'
comment|'# Register some lambda functions to keep the self.xmlstream var up to'
nl|'\n'
comment|'# date'
nl|'\n'
name|'self'
op|'.'
name|'_xsFactory'
op|'.'
name|'addBootstrap'
op|'('
name|'xmlstream'
op|'.'
name|'STREAM_CONNECTED_EVENT'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_connected'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_xsFactory'
op|'.'
name|'addBootstrap'
op|'('
name|'xmlstream'
op|'.'
name|'STREAM_AUTHD_EVENT'
op|','
name|'self'
op|'.'
name|'_authd'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_xsFactory'
op|'.'
name|'addBootstrap'
op|'('
name|'xmlstream'
op|'.'
name|'STREAM_END_EVENT'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_disconnected'
op|')'
newline|'\n'
nl|'\n'
comment|'# Map addBootstrap and removeBootstrap to the underlying factory -- is'
nl|'\n'
comment|"# this right? I have no clue...but it'll work for now, until i can"
nl|'\n'
comment|'# think about it more.'
nl|'\n'
name|'self'
op|'.'
name|'addBootstrap'
op|'='
name|'self'
op|'.'
name|'_xsFactory'
op|'.'
name|'addBootstrap'
newline|'\n'
name|'self'
op|'.'
name|'removeBootstrap'
op|'='
name|'self'
op|'.'
name|'_xsFactory'
op|'.'
name|'removeBootstrap'
newline|'\n'
nl|'\n'
DECL|member|getFactory
dedent|''
name|'def'
name|'getFactory'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_xsFactory'
newline|'\n'
nl|'\n'
DECL|member|_connected
dedent|''
name|'def'
name|'_connected'
op|'('
name|'self'
op|','
name|'xs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'xmlstream'
op|'='
name|'xs'
newline|'\n'
name|'for'
name|'c'
name|'in'
name|'self'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'ijabber'
op|'.'
name|'IService'
op|'.'
name|'providedBy'
op|'('
name|'c'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'c'
op|'.'
name|'transportConnected'
op|'('
name|'xs'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_authd
dedent|''
dedent|''
dedent|''
name|'def'
name|'_authd'
op|'('
name|'self'
op|','
name|'xs'
op|')'
op|':'
newline|'\n'
comment|'# Flush all pending packets'
nl|'\n'
indent|'        '
name|'for'
name|'p'
name|'in'
name|'self'
op|'.'
name|'_packetQueue'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'send'
op|'('
name|'p'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_packetQueue'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
comment|'# Notify all child services which implement the IService interface'
nl|'\n'
name|'for'
name|'c'
name|'in'
name|'self'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'ijabber'
op|'.'
name|'IService'
op|'.'
name|'providedBy'
op|'('
name|'c'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'c'
op|'.'
name|'componentConnected'
op|'('
name|'xs'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_disconnected
dedent|''
dedent|''
dedent|''
name|'def'
name|'_disconnected'
op|'('
name|'self'
op|','
name|'_'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'xmlstream'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# Notify all child services which implement'
nl|'\n'
comment|'# the IService interface'
nl|'\n'
name|'for'
name|'c'
name|'in'
name|'self'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'ijabber'
op|'.'
name|'IService'
op|'.'
name|'providedBy'
op|'('
name|'c'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'c'
op|'.'
name|'componentDisconnected'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|send
dedent|''
dedent|''
dedent|''
name|'def'
name|'send'
op|'('
name|'self'
op|','
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send data over the XML stream.\n\n        When there is no established XML stream, the data is queued and sent\n        out when a new XML stream has been established and initialized.\n\n        @param obj: data to be sent over the XML stream. This is usually an\n        object providing L{domish.IElement}, or serialized XML. See\n        L{xmlstream.XmlStream} for details.\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'xmlstream'
op|'!='
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'xmlstream'
op|'.'
name|'send'
op|'('
name|'obj'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_packetQueue'
op|'.'
name|'append'
op|'('
name|'obj'
op|')'
newline|'\n'
nl|'\n'
DECL|function|buildServiceManager
dedent|''
dedent|''
dedent|''
name|'def'
name|'buildServiceManager'
op|'('
name|'jid'
op|','
name|'password'
op|','
name|'strport'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Constructs a pre-built L{ServiceManager}, using the specified strport\n    string.\n    """'
newline|'\n'
nl|'\n'
name|'svc'
op|'='
name|'ServiceManager'
op|'('
name|'jid'
op|','
name|'password'
op|')'
newline|'\n'
name|'client_svc'
op|'='
name|'jstrports'
op|'.'
name|'client'
op|'('
name|'strport'
op|','
name|'svc'
op|'.'
name|'getFactory'
op|'('
op|')'
op|')'
newline|'\n'
name|'client_svc'
op|'.'
name|'setServiceParent'
op|'('
name|'svc'
op|')'
newline|'\n'
name|'return'
name|'svc'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|Router
dedent|''
name|'class'
name|'Router'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    XMPP Server\'s Router.\n\n    A router connects the different components of the XMPP service and routes\n    messages between them based on the given routing table.\n\n    Connected components are trusted to have correct addressing in the\n    stanzas they offer for routing.\n\n    A route destination of C{None} adds a default route. Traffic for which no\n    specific route exists, will be routed to this default route.\n\n    @since: 8.2\n    @ivar routes: Routes based on the host part of JIDs. Maps host names to the\n                  L{EventDispatcher<utility.EventDispatcher>}s that should\n                  receive the traffic. A key of C{None} means the default\n                  route.\n    @type routes: C{dict}\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'routes'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|addRoute
dedent|''
name|'def'
name|'addRoute'
op|'('
name|'self'
op|','
name|'destination'
op|','
name|'xs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Add a new route.\n\n        The passed XML Stream C{xs} will have an observer for all stanzas\n        added to route its outgoing traffic. In turn, traffic for\n        C{destination} will be passed to this stream.\n\n        @param destination: Destination of the route to be added as a host name\n                            or C{None} for the default route.\n        @type destination: C{str} or C{NoneType}.\n        @param xs: XML Stream to register the route for.\n        @type xs: L{EventDispatcher<utility.EventDispatcher>}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'routes'
op|'['
name|'destination'
op|']'
op|'='
name|'xs'
newline|'\n'
name|'xs'
op|'.'
name|'addObserver'
op|'('
string|"'/*'"
op|','
name|'self'
op|'.'
name|'route'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|removeRoute
dedent|''
name|'def'
name|'removeRoute'
op|'('
name|'self'
op|','
name|'destination'
op|','
name|'xs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Remove a route.\n\n        @param destination: Destination of the route that should be removed.\n        @type destination: C{str}.\n        @param xs: XML Stream to remove the route for.\n        @type xs: L{EventDispatcher<utility.EventDispatcher>}.\n        """'
newline|'\n'
name|'xs'
op|'.'
name|'removeObserver'
op|'('
string|"'/*'"
op|','
name|'self'
op|'.'
name|'route'
op|')'
newline|'\n'
name|'if'
op|'('
name|'xs'
op|'=='
name|'self'
op|'.'
name|'routes'
op|'['
name|'destination'
op|']'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'del'
name|'self'
op|'.'
name|'routes'
op|'['
name|'destination'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|route
dedent|''
dedent|''
name|'def'
name|'route'
op|'('
name|'self'
op|','
name|'stanza'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Route a stanza.\n\n        @param stanza: The stanza to be routed.\n        @type stanza: L{domish.Element}.\n        """'
newline|'\n'
name|'destination'
op|'='
name|'JID'
op|'('
name|'stanza'
op|'['
string|"'to'"
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'log'
op|'.'
name|'msg'
op|'('
string|'"Routing to %s: %r"'
op|'%'
op|'('
name|'destination'
op|'.'
name|'full'
op|'('
op|')'
op|','
name|'stanza'
op|'.'
name|'toXml'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'destination'
op|'.'
name|'host'
name|'in'
name|'self'
op|'.'
name|'routes'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'routes'
op|'['
name|'destination'
op|'.'
name|'host'
op|']'
op|'.'
name|'send'
op|'('
name|'stanza'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'routes'
op|'['
name|'None'
op|']'
op|'.'
name|'send'
op|'('
name|'stanza'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|XMPPComponentServerFactory
dedent|''
dedent|''
dedent|''
name|'class'
name|'XMPPComponentServerFactory'
op|'('
name|'xmlstream'
op|'.'
name|'XmlStreamServerFactory'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    XMPP Component Server factory.\n\n    This factory accepts XMPP external component connections and makes\n    the router service route traffic for a component\'s bound domain\n    to that component.\n\n    @since: 8.2\n    """'
newline|'\n'
nl|'\n'
DECL|variable|logTraffic
name|'logTraffic'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'router'
op|','
name|'secret'
op|'='
string|"'secret'"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'router'
op|'='
name|'router'
newline|'\n'
name|'self'
op|'.'
name|'secret'
op|'='
name|'secret'
newline|'\n'
nl|'\n'
DECL|function|authenticatorFactory
name|'def'
name|'authenticatorFactory'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'ListenComponentAuthenticator'
op|'('
name|'self'
op|'.'
name|'secret'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'xmlstream'
op|'.'
name|'XmlStreamServerFactory'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'authenticatorFactory'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addBootstrap'
op|'('
name|'xmlstream'
op|'.'
name|'STREAM_CONNECTED_EVENT'
op|','
nl|'\n'
name|'self'
op|'.'
name|'onConnectionMade'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addBootstrap'
op|'('
name|'xmlstream'
op|'.'
name|'STREAM_AUTHD_EVENT'
op|','
nl|'\n'
name|'self'
op|'.'
name|'onAuthenticated'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'serial'
op|'='
number|'0'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|onConnectionMade
dedent|''
name|'def'
name|'onConnectionMade'
op|'('
name|'self'
op|','
name|'xs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when a component connection was made.\n\n        This enables traffic debugging on incoming streams.\n        """'
newline|'\n'
name|'xs'
op|'.'
name|'serial'
op|'='
name|'self'
op|'.'
name|'serial'
newline|'\n'
name|'self'
op|'.'
name|'serial'
op|'+='
number|'1'
newline|'\n'
nl|'\n'
DECL|function|logDataIn
name|'def'
name|'logDataIn'
op|'('
name|'buf'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'log'
op|'.'
name|'msg'
op|'('
string|'"RECV (%d): %r"'
op|'%'
op|'('
name|'xs'
op|'.'
name|'serial'
op|','
name|'buf'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|logDataOut
dedent|''
name|'def'
name|'logDataOut'
op|'('
name|'buf'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'log'
op|'.'
name|'msg'
op|'('
string|'"SEND (%d): %r"'
op|'%'
op|'('
name|'xs'
op|'.'
name|'serial'
op|','
name|'buf'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'logTraffic'
op|':'
newline|'\n'
indent|'            '
name|'xs'
op|'.'
name|'rawDataInFn'
op|'='
name|'logDataIn'
newline|'\n'
name|'xs'
op|'.'
name|'rawDataOutFn'
op|'='
name|'logDataOut'
newline|'\n'
nl|'\n'
dedent|''
name|'xs'
op|'.'
name|'addObserver'
op|'('
name|'xmlstream'
op|'.'
name|'STREAM_ERROR_EVENT'
op|','
name|'self'
op|'.'
name|'onError'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|onAuthenticated
dedent|''
name|'def'
name|'onAuthenticated'
op|'('
name|'self'
op|','
name|'xs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Called when a component has succesfully authenticated.\n\n        Add the component to the routing table and establish a handler\n        for a closed connection.\n        """'
newline|'\n'
name|'destination'
op|'='
name|'xs'
op|'.'
name|'thisEntity'
op|'.'
name|'host'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'router'
op|'.'
name|'addRoute'
op|'('
name|'destination'
op|','
name|'xs'
op|')'
newline|'\n'
name|'xs'
op|'.'
name|'addObserver'
op|'('
name|'xmlstream'
op|'.'
name|'STREAM_END_EVENT'
op|','
name|'self'
op|'.'
name|'onConnectionLost'
op|','
number|'0'
op|','
nl|'\n'
name|'destination'
op|','
name|'xs'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|onError
dedent|''
name|'def'
name|'onError'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'log'
op|'.'
name|'err'
op|'('
name|'reason'
op|','
string|'"Stream Error"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|onConnectionLost
dedent|''
name|'def'
name|'onConnectionLost'
op|'('
name|'self'
op|','
name|'destination'
op|','
name|'xs'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'router'
op|'.'
name|'removeRoute'
op|'('
name|'destination'
op|','
name|'xs'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
