begin_unit
comment|'# -*- test-case-name: twisted.words.test.test_jabbererror -*-'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Copyright (c) 2001-2007 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nXMPP Error support.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'copy'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'words'
op|'.'
name|'xish'
name|'import'
name|'domish'
newline|'\n'
nl|'\n'
DECL|variable|NS_XML
name|'NS_XML'
op|'='
string|'"http://www.w3.org/XML/1998/namespace"'
newline|'\n'
DECL|variable|NS_XMPP_STREAMS
name|'NS_XMPP_STREAMS'
op|'='
string|'"urn:ietf:params:xml:ns:xmpp-streams"'
newline|'\n'
DECL|variable|NS_XMPP_STANZAS
name|'NS_XMPP_STANZAS'
op|'='
string|'"urn:ietf:params:xml:ns:xmpp-stanzas"'
newline|'\n'
nl|'\n'
DECL|variable|STANZA_CONDITIONS
name|'STANZA_CONDITIONS'
op|'='
op|'{'
nl|'\n'
string|"'bad-request'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'400'"
op|','
string|"'type'"
op|':'
string|"'modify'"
op|'}'
op|','
nl|'\n'
string|"'conflict'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'409'"
op|','
string|"'type'"
op|':'
string|"'cancel'"
op|'}'
op|','
nl|'\n'
string|"'feature-not-implemented'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'501'"
op|','
string|"'type'"
op|':'
string|"'cancel'"
op|'}'
op|','
nl|'\n'
string|"'forbidden'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'403'"
op|','
string|"'type'"
op|':'
string|"'auth'"
op|'}'
op|','
nl|'\n'
string|"'gone'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'302'"
op|','
string|"'type'"
op|':'
string|"'modify'"
op|'}'
op|','
nl|'\n'
string|"'internal-server-error'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'500'"
op|','
string|"'type'"
op|':'
string|"'wait'"
op|'}'
op|','
nl|'\n'
string|"'item-not-found'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'404'"
op|','
string|"'type'"
op|':'
string|"'cancel'"
op|'}'
op|','
nl|'\n'
string|"'jid-malformed'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'400'"
op|','
string|"'type'"
op|':'
string|"'modify'"
op|'}'
op|','
nl|'\n'
string|"'not-acceptable'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'406'"
op|','
string|"'type'"
op|':'
string|"'modify'"
op|'}'
op|','
nl|'\n'
string|"'not-allowed'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'405'"
op|','
string|"'type'"
op|':'
string|"'cancel'"
op|'}'
op|','
nl|'\n'
string|"'not-authorized'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'401'"
op|','
string|"'type'"
op|':'
string|"'auth'"
op|'}'
op|','
nl|'\n'
string|"'payment-required'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'402'"
op|','
string|"'type'"
op|':'
string|"'auth'"
op|'}'
op|','
nl|'\n'
string|"'recipient-unavailable'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'404'"
op|','
string|"'type'"
op|':'
string|"'wait'"
op|'}'
op|','
nl|'\n'
string|"'redirect'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'302'"
op|','
string|"'type'"
op|':'
string|"'modify'"
op|'}'
op|','
nl|'\n'
string|"'registration-required'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'407'"
op|','
string|"'type'"
op|':'
string|"'auth'"
op|'}'
op|','
nl|'\n'
string|"'remote-server-not-found'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'404'"
op|','
string|"'type'"
op|':'
string|"'cancel'"
op|'}'
op|','
nl|'\n'
string|"'remove-server-timeout'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'504'"
op|','
string|"'type'"
op|':'
string|"'wait'"
op|'}'
op|','
nl|'\n'
string|"'resource-constraint'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'500'"
op|','
string|"'type'"
op|':'
string|"'wait'"
op|'}'
op|','
nl|'\n'
string|"'service-unavailable'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'503'"
op|','
string|"'type'"
op|':'
string|"'cancel'"
op|'}'
op|','
nl|'\n'
string|"'subscription-required'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'407'"
op|','
string|"'type'"
op|':'
string|"'auth'"
op|'}'
op|','
nl|'\n'
string|"'undefined-condition'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'500'"
op|','
string|"'type'"
op|':'
name|'None'
op|'}'
op|','
nl|'\n'
string|"'unexpected-request'"
op|':'
op|'{'
string|"'code'"
op|':'
string|"'400'"
op|','
string|"'type'"
op|':'
string|"'wait'"
op|'}'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
DECL|variable|CODES_TO_CONDITIONS
name|'CODES_TO_CONDITIONS'
op|'='
op|'{'
nl|'\n'
string|"'302'"
op|':'
op|'('
string|"'gone'"
op|','
string|"'modify'"
op|')'
op|','
nl|'\n'
string|"'400'"
op|':'
op|'('
string|"'bad-request'"
op|','
string|"'modify'"
op|')'
op|','
nl|'\n'
string|"'401'"
op|':'
op|'('
string|"'not-authorized'"
op|','
string|"'auth'"
op|')'
op|','
nl|'\n'
string|"'402'"
op|':'
op|'('
string|"'payment-required'"
op|','
string|"'auth'"
op|')'
op|','
nl|'\n'
string|"'403'"
op|':'
op|'('
string|"'forbidden'"
op|','
string|"'auth'"
op|')'
op|','
nl|'\n'
string|"'404'"
op|':'
op|'('
string|"'item-not-found'"
op|','
string|"'cancel'"
op|')'
op|','
nl|'\n'
string|"'405'"
op|':'
op|'('
string|"'not-allowed'"
op|','
string|"'cancel'"
op|')'
op|','
nl|'\n'
string|"'406'"
op|':'
op|'('
string|"'not-acceptable'"
op|','
string|"'modify'"
op|')'
op|','
nl|'\n'
string|"'407'"
op|':'
op|'('
string|"'registration-required'"
op|','
string|"'auth'"
op|')'
op|','
nl|'\n'
string|"'408'"
op|':'
op|'('
string|"'remote-server-timeout'"
op|','
string|"'wait'"
op|')'
op|','
nl|'\n'
string|"'409'"
op|':'
op|'('
string|"'conflict'"
op|','
string|"'cancel'"
op|')'
op|','
nl|'\n'
string|"'500'"
op|':'
op|'('
string|"'internal-server-error'"
op|','
string|"'wait'"
op|')'
op|','
nl|'\n'
string|"'501'"
op|':'
op|'('
string|"'feature-not-implemented'"
op|','
string|"'cancel'"
op|')'
op|','
nl|'\n'
string|"'502'"
op|':'
op|'('
string|"'service-unavailable'"
op|','
string|"'wait'"
op|')'
op|','
nl|'\n'
string|"'503'"
op|':'
op|'('
string|"'service-unavailable'"
op|','
string|"'cancel'"
op|')'
op|','
nl|'\n'
string|"'504'"
op|':'
op|'('
string|"'remote-server-timeout'"
op|','
string|"'wait'"
op|')'
op|','
nl|'\n'
string|"'510'"
op|':'
op|'('
string|"'service-unavailable'"
op|','
string|"'cancel'"
op|')'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
DECL|class|BaseError
name|'class'
name|'BaseError'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Base class for XMPP error exceptions.\n\n    @cvar namespace: The namespace of the C{error} element generated by\n                     C{getElement}.\n    @type namespace: C{str}\n    @ivar condition: The error condition. The valid values are defined by\n                     subclasses of L{BaseError}.\n    @type contition: C{str}\n    @ivar text: Optional text message to supplement the condition or application\n                specific condition.\n    @type text: C{unicode}\n    @ivar textLang: Identifier of the language used for the message in C{text}.\n                    Values are as described in RFC 3066.\n    @type textLang: C{str}\n    @ivar appCondition: Application specific condition element, supplementing\n                        the error condition in C{condition}.\n    @type appCondition: object providing L{domish.IElement}.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|namespace
name|'namespace'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'condition'
op|','
name|'text'
op|'='
name|'None'
op|','
name|'textLang'
op|'='
name|'None'
op|','
name|'appCondition'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'Exception'
op|'.'
name|'__init__'
op|'('
name|'self'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'condition'
op|'='
name|'condition'
newline|'\n'
name|'self'
op|'.'
name|'text'
op|'='
name|'text'
newline|'\n'
name|'self'
op|'.'
name|'textLang'
op|'='
name|'textLang'
newline|'\n'
name|'self'
op|'.'
name|'appCondition'
op|'='
name|'appCondition'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'message'
op|'='
string|'"%s with condition %r"'
op|'%'
op|'('
name|'self'
op|'.'
name|'__class__'
op|'.'
name|'__name__'
op|','
nl|'\n'
name|'self'
op|'.'
name|'condition'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'text'
op|':'
newline|'\n'
indent|'            '
name|'message'
op|'+='
string|"': '"
op|'+'
name|'self'
op|'.'
name|'text'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'message'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getElement
dedent|''
name|'def'
name|'getElement'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Get XML representation from self.\n\n        The method creates an L{domish} representation of the\n        error data contained in this exception.\n\n        @rtype: L{domish.Element}\n        """'
newline|'\n'
name|'error'
op|'='
name|'domish'
op|'.'
name|'Element'
op|'('
op|'('
name|'None'
op|','
string|"'error'"
op|')'
op|')'
newline|'\n'
name|'error'
op|'.'
name|'addElement'
op|'('
op|'('
name|'self'
op|'.'
name|'namespace'
op|','
name|'self'
op|'.'
name|'condition'
op|')'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'text'
op|':'
newline|'\n'
indent|'            '
name|'text'
op|'='
name|'error'
op|'.'
name|'addElement'
op|'('
op|'('
name|'self'
op|'.'
name|'namespace'
op|','
string|"'text'"
op|')'
op|','
nl|'\n'
name|'content'
op|'='
name|'self'
op|'.'
name|'text'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'textLang'
op|':'
newline|'\n'
indent|'                '
name|'text'
op|'['
op|'('
name|'NS_XML'
op|','
string|"'lang'"
op|')'
op|']'
op|'='
name|'self'
op|'.'
name|'textLang'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'self'
op|'.'
name|'appCondition'
op|':'
newline|'\n'
indent|'            '
name|'error'
op|'.'
name|'addChild'
op|'('
name|'self'
op|'.'
name|'appCondition'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'error'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|StreamError
dedent|''
dedent|''
name|'class'
name|'StreamError'
op|'('
name|'BaseError'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Stream Error exception.\n\n    Refer to RFC 3920, section 4.7.3, for the allowed values for C{condition}.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|namespace
name|'namespace'
op|'='
name|'NS_XMPP_STREAMS'
newline|'\n'
nl|'\n'
DECL|member|getElement
name|'def'
name|'getElement'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Get XML representation from self.\n\n        Overrides the base L{BaseError.getElement} to make sure the returned\n        element is in the XML Stream namespace.\n\n        @rtype: L{domish.Element}\n        """'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'words'
op|'.'
name|'protocols'
op|'.'
name|'jabber'
op|'.'
name|'xmlstream'
name|'import'
name|'NS_STREAMS'
newline|'\n'
nl|'\n'
name|'error'
op|'='
name|'BaseError'
op|'.'
name|'getElement'
op|'('
name|'self'
op|')'
newline|'\n'
name|'error'
op|'.'
name|'uri'
op|'='
name|'NS_STREAMS'
newline|'\n'
name|'return'
name|'error'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|StanzaError
dedent|''
dedent|''
name|'class'
name|'StanzaError'
op|'('
name|'BaseError'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Stanza Error exception.\n\n    Refer to RFC 3920, section 9.3, for the allowed values for C{condition} and\n    C{type}.\n\n    @ivar type: The stanza error type. Gives a suggestion to the recipient\n                of the error on how to proceed.\n    @type type: C{str}\n    @ivar code: A numeric identifier for the error condition for backwards\n                compatibility with pre-XMPP Jabber implementations.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|namespace
name|'namespace'
op|'='
name|'NS_XMPP_STANZAS'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'condition'
op|','
name|'type'
op|'='
name|'None'
op|','
name|'text'
op|'='
name|'None'
op|','
name|'textLang'
op|'='
name|'None'
op|','
nl|'\n'
name|'appCondition'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'BaseError'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'condition'
op|','
name|'text'
op|','
name|'textLang'
op|','
name|'appCondition'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'type'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'type'
op|'='
name|'STANZA_CONDITIONS'
op|'['
name|'condition'
op|']'
op|'['
string|"'type'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'type'
op|'='
name|'type'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'code'
op|'='
name|'STANZA_CONDITIONS'
op|'['
name|'condition'
op|']'
op|'['
string|"'code'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'code'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'children'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'iq'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getElement
dedent|''
name|'def'
name|'getElement'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Get XML representation from self.\n\n        Overrides the base L{BaseError.getElement} to make sure the returned\n        element has a C{type} attribute and optionally a legacy C{code}\n        attribute.\n\n        @rtype: L{domish.Element}\n        """'
newline|'\n'
name|'error'
op|'='
name|'BaseError'
op|'.'
name|'getElement'
op|'('
name|'self'
op|')'
newline|'\n'
name|'error'
op|'['
string|"'type'"
op|']'
op|'='
name|'self'
op|'.'
name|'type'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'code'
op|':'
newline|'\n'
indent|'            '
name|'error'
op|'['
string|"'code'"
op|']'
op|'='
name|'self'
op|'.'
name|'code'
newline|'\n'
dedent|''
name|'return'
name|'error'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|toResponse
dedent|''
name|'def'
name|'toResponse'
op|'('
name|'self'
op|','
name|'stanza'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Construct error response stanza.\n\n        The C{stanza} is transformed into an error response stanza by\n        swapping the C{to} and C{from} addresses and inserting an error\n        element.\n\n        @note: This creates a shallow copy of the list of child elements of the\n               stanza. The child elements themselves are not copied themselves,\n               and references to their parent element will still point to the\n               original stanza element.\n\n               The serialization of an element does not use the reference to\n               its parent, so the typical use case of immediately sending out\n               the constructed error response is not affected.\n\n        @param stanza: the stanza to respond to\n        @type stanza: L{domish.Element}\n        """'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'words'
op|'.'
name|'protocols'
op|'.'
name|'jabber'
op|'.'
name|'xmlstream'
name|'import'
name|'toResponse'
newline|'\n'
name|'response'
op|'='
name|'toResponse'
op|'('
name|'stanza'
op|','
name|'stanzaType'
op|'='
string|"'error'"
op|')'
newline|'\n'
name|'response'
op|'.'
name|'children'
op|'='
name|'copy'
op|'.'
name|'copy'
op|'('
name|'stanza'
op|'.'
name|'children'
op|')'
newline|'\n'
name|'response'
op|'.'
name|'addChild'
op|'('
name|'self'
op|'.'
name|'getElement'
op|'('
op|')'
op|')'
newline|'\n'
name|'return'
name|'response'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_getText
dedent|''
dedent|''
name|'def'
name|'_getText'
op|'('
name|'element'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'for'
name|'child'
name|'in'
name|'element'
op|'.'
name|'children'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'isinstance'
op|'('
name|'child'
op|','
name|'basestring'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'unicode'
op|'('
name|'child'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|_parseError
dedent|''
name|'def'
name|'_parseError'
op|'('
name|'error'
op|','
name|'errorNamespace'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Parses an error element.\n\n    @param error: The error element to be parsed\n    @type error: L{domish.Element}\n    @param errorNamespace: The namespace of the elements that hold the error\n                           condition and text.\n    @type errorNamespace: C{str}\n    @return: Dictionary with extracted error information. If present, keys\n             C{condition}, C{text}, C{textLang} have a string value,\n             and C{appCondition} has an L{domish.Element} value.\n    @rtype: L{dict}\n    """'
newline|'\n'
name|'condition'
op|'='
name|'None'
newline|'\n'
name|'text'
op|'='
name|'None'
newline|'\n'
name|'textLang'
op|'='
name|'None'
newline|'\n'
name|'appCondition'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'for'
name|'element'
name|'in'
name|'error'
op|'.'
name|'elements'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'element'
op|'.'
name|'uri'
op|'=='
name|'errorNamespace'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'element'
op|'.'
name|'name'
op|'=='
string|"'text'"
op|':'
newline|'\n'
indent|'                '
name|'text'
op|'='
name|'_getText'
op|'('
name|'element'
op|')'
newline|'\n'
name|'textLang'
op|'='
name|'element'
op|'.'
name|'getAttribute'
op|'('
op|'('
name|'NS_XML'
op|','
string|"'lang'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'condition'
op|'='
name|'element'
op|'.'
name|'name'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'appCondition'
op|'='
name|'element'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
op|'{'
nl|'\n'
string|"'condition'"
op|':'
name|'condition'
op|','
nl|'\n'
string|"'text'"
op|':'
name|'text'
op|','
nl|'\n'
string|"'textLang'"
op|':'
name|'textLang'
op|','
nl|'\n'
string|"'appCondition'"
op|':'
name|'appCondition'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|exceptionFromStreamError
dedent|''
name|'def'
name|'exceptionFromStreamError'
op|'('
name|'element'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Build an exception object from a stream error.\n\n    @param element: the stream error\n    @type element: L{domish.Element}\n    @return: the generated exception object\n    @rtype: L{StreamError}\n    """'
newline|'\n'
name|'error'
op|'='
name|'_parseError'
op|'('
name|'element'
op|','
name|'NS_XMPP_STREAMS'
op|')'
newline|'\n'
nl|'\n'
name|'exception'
op|'='
name|'StreamError'
op|'('
name|'error'
op|'['
string|"'condition'"
op|']'
op|','
nl|'\n'
name|'error'
op|'['
string|"'text'"
op|']'
op|','
nl|'\n'
name|'error'
op|'['
string|"'textLang'"
op|']'
op|','
nl|'\n'
name|'error'
op|'['
string|"'appCondition'"
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'exception'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|exceptionFromStanza
dedent|''
name|'def'
name|'exceptionFromStanza'
op|'('
name|'stanza'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Build an exception object from an error stanza.\n\n    @param stanza: the error stanza\n    @type stanza: L{domish.Element}\n    @return: the generated exception object\n    @rtype: L{StanzaError}\n    """'
newline|'\n'
name|'children'
op|'='
op|'['
op|']'
newline|'\n'
name|'condition'
op|'='
name|'text'
op|'='
name|'textLang'
op|'='
name|'appCondition'
op|'='
name|'type'
op|'='
name|'code'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'for'
name|'element'
name|'in'
name|'stanza'
op|'.'
name|'elements'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'element'
op|'.'
name|'name'
op|'=='
string|"'error'"
name|'and'
name|'element'
op|'.'
name|'uri'
op|'=='
name|'stanza'
op|'.'
name|'uri'
op|':'
newline|'\n'
indent|'            '
name|'code'
op|'='
name|'element'
op|'.'
name|'getAttribute'
op|'('
string|"'code'"
op|')'
newline|'\n'
name|'type'
op|'='
name|'element'
op|'.'
name|'getAttribute'
op|'('
string|"'type'"
op|')'
newline|'\n'
name|'error'
op|'='
name|'_parseError'
op|'('
name|'element'
op|','
name|'NS_XMPP_STANZAS'
op|')'
newline|'\n'
name|'condition'
op|'='
name|'error'
op|'['
string|"'condition'"
op|']'
newline|'\n'
name|'text'
op|'='
name|'error'
op|'['
string|"'text'"
op|']'
newline|'\n'
name|'textLang'
op|'='
name|'error'
op|'['
string|"'textLang'"
op|']'
newline|'\n'
name|'appCondition'
op|'='
name|'error'
op|'['
string|"'appCondition'"
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'condition'
name|'and'
name|'code'
op|':'
newline|'\n'
indent|'               '
name|'condition'
op|','
name|'type'
op|'='
name|'CODES_TO_CONDITIONS'
op|'['
name|'code'
op|']'
newline|'\n'
name|'text'
op|'='
name|'_getText'
op|'('
name|'stanza'
op|'.'
name|'error'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'children'
op|'.'
name|'append'
op|'('
name|'element'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'condition'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|'# TODO: raise exception instead?'
nl|'\n'
indent|'        '
name|'return'
name|'StanzaError'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'exception'
op|'='
name|'StanzaError'
op|'('
name|'condition'
op|','
name|'type'
op|','
name|'text'
op|','
name|'textLang'
op|','
name|'appCondition'
op|')'
newline|'\n'
nl|'\n'
name|'exception'
op|'.'
name|'children'
op|'='
name|'children'
newline|'\n'
name|'exception'
op|'.'
name|'stanza'
op|'='
name|'stanza'
newline|'\n'
nl|'\n'
name|'return'
name|'exception'
newline|'\n'
dedent|''
endmarker|''
end_unit
