begin_unit
comment|'# -*- test-case-name: twisted.test.test_protocols -*-'
nl|'\n'
comment|'# Copyright (c) 2001-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
nl|'\n'
string|'"""\nBasic protocols, such as line-oriented, netstring, and int prefixed strings.\n\nMaintainer: Itamar Shtull-Trauring\n"""'
newline|'\n'
nl|'\n'
comment|'# System imports'
nl|'\n'
name|'import'
name|'re'
newline|'\n'
name|'import'
name|'struct'
newline|'\n'
name|'import'
name|'warnings'
newline|'\n'
nl|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'implements'
newline|'\n'
nl|'\n'
comment|'# Twisted imports'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'protocol'
op|','
name|'defer'
op|','
name|'interfaces'
op|','
name|'error'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'log'
newline|'\n'
nl|'\n'
name|'LENGTH'
op|','
name|'DATA'
op|','
name|'COMMA'
op|'='
name|'range'
op|'('
number|'3'
op|')'
newline|'\n'
DECL|variable|NUMBER
name|'NUMBER'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"'(\\d*)(:?)'"
op|')'
newline|'\n'
DECL|variable|DEBUG
name|'DEBUG'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|class|NetstringParseError
name|'class'
name|'NetstringParseError'
op|'('
name|'ValueError'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""The incoming data is not in valid Netstring format."""'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|NetstringReceiver
dedent|''
name|'class'
name|'NetstringReceiver'
op|'('
name|'protocol'
op|'.'
name|'Protocol'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""This uses djb\'s Netstrings protocol to break up the input into strings.\n\n    Each string makes a callback to stringReceived, with a single\n    argument of that string.\n\n    Security features:\n        1. Messages are limited in size, useful if you don\'t want someone\n           sending you a 500MB netstring (change MAX_LENGTH to the maximum\n           length you wish to accept).\n        2. The connection is lost if an illegal message is received.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|MAX_LENGTH
name|'MAX_LENGTH'
op|'='
number|'99999'
newline|'\n'
DECL|variable|brokenPeer
name|'brokenPeer'
op|'='
number|'0'
newline|'\n'
DECL|variable|_readerState
name|'_readerState'
op|'='
name|'LENGTH'
newline|'\n'
DECL|variable|_readerLength
name|'_readerLength'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|member|stringReceived
name|'def'
name|'stringReceived'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Override this.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
newline|'\n'
nl|'\n'
DECL|member|doData
dedent|''
name|'def'
name|'doData'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'buffer'
op|','
name|'self'
op|'.'
name|'__data'
op|'='
name|'self'
op|'.'
name|'__data'
op|'['
op|':'
name|'int'
op|'('
name|'self'
op|'.'
name|'_readerLength'
op|')'
op|']'
op|','
name|'self'
op|'.'
name|'__data'
op|'['
name|'int'
op|'('
name|'self'
op|'.'
name|'_readerLength'
op|')'
op|':'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_readerLength'
op|'='
name|'self'
op|'.'
name|'_readerLength'
op|'-'
name|'len'
op|'('
name|'buffer'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'__buffer'
op|'='
name|'self'
op|'.'
name|'__buffer'
op|'+'
name|'buffer'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_readerLength'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'stringReceived'
op|'('
name|'self'
op|'.'
name|'__buffer'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_readerState'
op|'='
name|'COMMA'
newline|'\n'
nl|'\n'
DECL|member|doComma
dedent|''
name|'def'
name|'doComma'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_readerState'
op|'='
name|'LENGTH'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'__data'
op|'['
number|'0'
op|']'
op|'!='
string|"','"
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'DEBUG'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'NetstringParseError'
op|'('
name|'repr'
op|'('
name|'self'
op|'.'
name|'__data'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'NetstringParseError'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'__data'
op|'='
name|'self'
op|'.'
name|'__data'
op|'['
number|'1'
op|':'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|doLength
dedent|''
name|'def'
name|'doLength'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'m'
op|'='
name|'NUMBER'
op|'.'
name|'match'
op|'('
name|'self'
op|'.'
name|'__data'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'m'
op|'.'
name|'end'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'DEBUG'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'NetstringParseError'
op|'('
name|'repr'
op|'('
name|'self'
op|'.'
name|'__data'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'NetstringParseError'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'__data'
op|'='
name|'self'
op|'.'
name|'__data'
op|'['
name|'m'
op|'.'
name|'end'
op|'('
op|')'
op|':'
op|']'
newline|'\n'
name|'if'
name|'m'
op|'.'
name|'group'
op|'('
number|'1'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_readerLength'
op|'='
name|'self'
op|'.'
name|'_readerLength'
op|'*'
op|'('
number|'10'
op|'**'
name|'len'
op|'('
name|'m'
op|'.'
name|'group'
op|'('
number|'1'
op|')'
op|')'
op|')'
op|'+'
name|'long'
op|'('
name|'m'
op|'.'
name|'group'
op|'('
number|'1'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OverflowError'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'NetstringParseError'
op|','
string|'"netstring too long"'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_readerLength'
op|'>'
name|'self'
op|'.'
name|'MAX_LENGTH'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'NetstringParseError'
op|','
string|'"netstring too long"'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'m'
op|'.'
name|'group'
op|'('
number|'2'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'__buffer'
op|'='
string|"''"
newline|'\n'
name|'self'
op|'.'
name|'_readerState'
op|'='
name|'DATA'
newline|'\n'
nl|'\n'
DECL|member|dataReceived
dedent|''
dedent|''
name|'def'
name|'dataReceived'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'__data'
op|'='
name|'data'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'while'
name|'self'
op|'.'
name|'__data'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'_readerState'
op|'=='
name|'DATA'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'doData'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_readerState'
op|'=='
name|'COMMA'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'doComma'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_readerState'
op|'=='
name|'LENGTH'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'doLength'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'RuntimeError'
op|','
string|'"mode is not DATA, COMMA or LENGTH"'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
name|'NetstringParseError'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'brokenPeer'
op|'='
number|'1'
newline|'\n'
nl|'\n'
DECL|member|sendString
dedent|''
dedent|''
name|'def'
name|'sendString'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A method for sending a Netstring. This method accepts a string and\n        writes it to the transport.\n\n        @type data: C{str}\n        """'
newline|'\n'
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'data'
op|','
name|'str'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'warnings'
op|'.'
name|'warn'
op|'('
nl|'\n'
string|'"data passed to sendString() must be a string. Non-string "'
nl|'\n'
string|'"support is deprecated since Twisted 10.0"'
op|','
nl|'\n'
name|'DeprecationWarning'
op|','
number|'2'
op|')'
newline|'\n'
name|'data'
op|'='
name|'str'
op|'('
name|'data'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
string|"'%d:%s,'"
op|'%'
op|'('
name|'len'
op|'('
name|'data'
op|')'
op|','
name|'data'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|SafeNetstringReceiver
dedent|''
dedent|''
name|'class'
name|'SafeNetstringReceiver'
op|'('
name|'NetstringReceiver'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""This class is deprecated, use NetstringReceiver instead.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|LineOnlyReceiver
dedent|''
name|'class'
name|'LineOnlyReceiver'
op|'('
name|'protocol'
op|'.'
name|'Protocol'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""A protocol that receives only lines.\n\n    This is purely a speed optimisation over LineReceiver, for the\n    cases that raw mode is known to be unnecessary.\n\n    @cvar delimiter: The line-ending delimiter to use. By default this is\n                     \'\\\\r\\\\n\'.\n    @cvar MAX_LENGTH: The maximum length of a line to allow (If a\n                      sent line is longer than this, the connection is dropped).\n                      Default is 16384.\n    """'
newline|'\n'
DECL|variable|_buffer
name|'_buffer'
op|'='
string|"''"
newline|'\n'
DECL|variable|delimiter
name|'delimiter'
op|'='
string|"'\\r\\n'"
newline|'\n'
DECL|variable|MAX_LENGTH
name|'MAX_LENGTH'
op|'='
number|'16384'
newline|'\n'
nl|'\n'
DECL|member|dataReceived
name|'def'
name|'dataReceived'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Translates bytes into lines, and calls lineReceived."""'
newline|'\n'
name|'lines'
op|'='
op|'('
name|'self'
op|'.'
name|'_buffer'
op|'+'
name|'data'
op|')'
op|'.'
name|'split'
op|'('
name|'self'
op|'.'
name|'delimiter'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_buffer'
op|'='
name|'lines'
op|'.'
name|'pop'
op|'('
op|'-'
number|'1'
op|')'
newline|'\n'
name|'for'
name|'line'
name|'in'
name|'lines'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'disconnecting'
op|':'
newline|'\n'
comment|'# this is necessary because the transport may be told to lose'
nl|'\n'
comment|'# the connection by a line within a larger packet, and it is'
nl|'\n'
comment|'# important to disregard all the lines in that packet following'
nl|'\n'
comment|'# the one that told it to close.'
nl|'\n'
indent|'                '
name|'return'
newline|'\n'
dedent|''
name|'if'
name|'len'
op|'('
name|'line'
op|')'
op|'>'
name|'self'
op|'.'
name|'MAX_LENGTH'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'self'
op|'.'
name|'lineLengthExceeded'
op|'('
name|'line'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'lineReceived'
op|'('
name|'line'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'len'
op|'('
name|'self'
op|'.'
name|'_buffer'
op|')'
op|'>'
name|'self'
op|'.'
name|'MAX_LENGTH'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'lineLengthExceeded'
op|'('
name|'self'
op|'.'
name|'_buffer'
op|')'
newline|'\n'
nl|'\n'
DECL|member|lineReceived
dedent|''
dedent|''
name|'def'
name|'lineReceived'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Override this for when each line is received.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
newline|'\n'
nl|'\n'
DECL|member|sendLine
dedent|''
name|'def'
name|'sendLine'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Sends a line to the other end of the connection.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'writeSequence'
op|'('
op|'('
name|'line'
op|','
name|'self'
op|'.'
name|'delimiter'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|lineLengthExceeded
dedent|''
name|'def'
name|'lineLengthExceeded'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Called when the maximum line length has been reached.\n        Override if it needs to be dealt with in some special way.\n        """'
newline|'\n'
name|'return'
name|'error'
op|'.'
name|'ConnectionLost'
op|'('
string|"'Line length exceeded'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|_PauseableMixin
dedent|''
dedent|''
name|'class'
name|'_PauseableMixin'
op|':'
newline|'\n'
DECL|variable|paused
indent|'    '
name|'paused'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|member|pauseProducing
name|'def'
name|'pauseProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'paused'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'pauseProducing'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|resumeProducing
dedent|''
name|'def'
name|'resumeProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'paused'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'resumeProducing'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'dataReceived'
op|'('
string|"''"
op|')'
newline|'\n'
nl|'\n'
DECL|member|stopProducing
dedent|''
name|'def'
name|'stopProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'paused'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'stopProducing'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|LineReceiver
dedent|''
dedent|''
name|'class'
name|'LineReceiver'
op|'('
name|'protocol'
op|'.'
name|'Protocol'
op|','
name|'_PauseableMixin'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""A protocol that receives lines and/or raw data, depending on mode.\n\n    In line mode, each line that\'s received becomes a callback to\n    L{lineReceived}.  In raw data mode, each chunk of raw data becomes a\n    callback to L{rawDataReceived}.  The L{setLineMode} and L{setRawMode}\n    methods switch between the two modes.\n\n    This is useful for line-oriented protocols such as IRC, HTTP, POP, etc.\n\n    @cvar delimiter: The line-ending delimiter to use. By default this is\n                     \'\\\\r\\\\n\'.\n    @cvar MAX_LENGTH: The maximum length of a line to allow (If a\n                      sent line is longer than this, the connection is dropped).\n                      Default is 16384.\n    """'
newline|'\n'
DECL|variable|line_mode
name|'line_mode'
op|'='
number|'1'
newline|'\n'
DECL|variable|__buffer
name|'__buffer'
op|'='
string|"''"
newline|'\n'
DECL|variable|delimiter
name|'delimiter'
op|'='
string|"'\\r\\n'"
newline|'\n'
DECL|variable|MAX_LENGTH
name|'MAX_LENGTH'
op|'='
number|'16384'
newline|'\n'
nl|'\n'
DECL|member|clearLineBuffer
name|'def'
name|'clearLineBuffer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Clear buffered data.\n\n        @return: All of the cleared buffered data.\n        @rtype: C{str}\n        """'
newline|'\n'
name|'b'
op|'='
name|'self'
op|'.'
name|'__buffer'
newline|'\n'
name|'self'
op|'.'
name|'__buffer'
op|'='
string|'""'
newline|'\n'
name|'return'
name|'b'
newline|'\n'
nl|'\n'
DECL|member|dataReceived
dedent|''
name|'def'
name|'dataReceived'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Protocol.dataReceived.\n        Translates bytes into lines, and calls lineReceived (or\n        rawDataReceived, depending on mode.)\n        """'
newline|'\n'
name|'self'
op|'.'
name|'__buffer'
op|'='
name|'self'
op|'.'
name|'__buffer'
op|'+'
name|'data'
newline|'\n'
name|'while'
name|'self'
op|'.'
name|'line_mode'
name|'and'
name|'not'
name|'self'
op|'.'
name|'paused'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'line'
op|','
name|'self'
op|'.'
name|'__buffer'
op|'='
name|'self'
op|'.'
name|'__buffer'
op|'.'
name|'split'
op|'('
name|'self'
op|'.'
name|'delimiter'
op|','
number|'1'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'len'
op|'('
name|'self'
op|'.'
name|'__buffer'
op|')'
op|'>'
name|'self'
op|'.'
name|'MAX_LENGTH'
op|':'
newline|'\n'
indent|'                    '
name|'line'
op|','
name|'self'
op|'.'
name|'__buffer'
op|'='
name|'self'
op|'.'
name|'__buffer'
op|','
string|"''"
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'lineLengthExceeded'
op|'('
name|'line'
op|')'
newline|'\n'
dedent|''
name|'break'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'linelength'
op|'='
name|'len'
op|'('
name|'line'
op|')'
newline|'\n'
name|'if'
name|'linelength'
op|'>'
name|'self'
op|'.'
name|'MAX_LENGTH'
op|':'
newline|'\n'
indent|'                    '
name|'exceeded'
op|'='
name|'line'
op|'+'
name|'self'
op|'.'
name|'__buffer'
newline|'\n'
name|'self'
op|'.'
name|'__buffer'
op|'='
string|"''"
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'lineLengthExceeded'
op|'('
name|'exceeded'
op|')'
newline|'\n'
dedent|''
name|'why'
op|'='
name|'self'
op|'.'
name|'lineReceived'
op|'('
name|'line'
op|')'
newline|'\n'
name|'if'
name|'why'
name|'or'
name|'self'
op|'.'
name|'transport'
name|'and'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'disconnecting'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'why'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'self'
op|'.'
name|'paused'
op|':'
newline|'\n'
indent|'                '
name|'data'
op|'='
name|'self'
op|'.'
name|'__buffer'
newline|'\n'
name|'self'
op|'.'
name|'__buffer'
op|'='
string|"''"
newline|'\n'
name|'if'
name|'data'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'self'
op|'.'
name|'rawDataReceived'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
DECL|member|setLineMode
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'setLineMode'
op|'('
name|'self'
op|','
name|'extra'
op|'='
string|"''"
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Sets the line-mode of this receiver.\n\n        If you are calling this from a rawDataReceived callback,\n        you can pass in extra unhandled data, and that data will\n        be parsed for lines.  Further data received will be sent\n        to lineReceived rather than rawDataReceived.\n\n        Do not pass extra data if calling this function from\n        within a lineReceived callback.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'line_mode'
op|'='
number|'1'
newline|'\n'
name|'if'
name|'extra'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'dataReceived'
op|'('
name|'extra'
op|')'
newline|'\n'
nl|'\n'
DECL|member|setRawMode
dedent|''
dedent|''
name|'def'
name|'setRawMode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Sets the raw mode of this receiver.\n        Further data received will be sent to rawDataReceived rather\n        than lineReceived.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'line_mode'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|member|rawDataReceived
dedent|''
name|'def'
name|'rawDataReceived'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Override this for when raw data is received.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
newline|'\n'
nl|'\n'
DECL|member|lineReceived
dedent|''
name|'def'
name|'lineReceived'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Override this for when each line is received.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
newline|'\n'
nl|'\n'
DECL|member|sendLine
dedent|''
name|'def'
name|'sendLine'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Sends a line to the other end of the connection.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
name|'line'
op|'+'
name|'self'
op|'.'
name|'delimiter'
op|')'
newline|'\n'
nl|'\n'
DECL|member|lineLengthExceeded
dedent|''
name|'def'
name|'lineLengthExceeded'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Called when the maximum line length has been reached.\n        Override if it needs to be dealt with in some special way.\n\n        The argument \'line\' contains the remainder of the buffer, starting\n        with (at least some part) of the line which is too long. This may\n        be more than one line, or may be only the initial portion of the\n        line.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|StringTooLongError
dedent|''
dedent|''
name|'class'
name|'StringTooLongError'
op|'('
name|'AssertionError'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Raised when trying to send a string too long for a length prefixed\n    protocol.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|IntNStringReceiver
dedent|''
name|'class'
name|'IntNStringReceiver'
op|'('
name|'protocol'
op|'.'
name|'Protocol'
op|','
name|'_PauseableMixin'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Generic class for length prefixed protocols.\n\n    @ivar recvd: buffer holding received data when splitted.\n    @type recvd: C{str}\n\n    @ivar structFormat: format used for struct packing/unpacking. Define it in\n        subclass.\n    @type structFormat: C{str}\n\n    @ivar prefixLength: length of the prefix, in bytes. Define it in subclass,\n        using C{struct.calcsize(structFormat)}\n    @type prefixLength: C{int}\n    """'
newline|'\n'
DECL|variable|MAX_LENGTH
name|'MAX_LENGTH'
op|'='
number|'99999'
newline|'\n'
DECL|variable|recvd
name|'recvd'
op|'='
string|'""'
newline|'\n'
nl|'\n'
DECL|member|stringReceived
name|'def'
name|'stringReceived'
op|'('
name|'self'
op|','
name|'msg'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Override this.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|lengthLimitExceeded
dedent|''
name|'def'
name|'lengthLimitExceeded'
op|'('
name|'self'
op|','
name|'length'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Callback invoked when a length prefix greater than C{MAX_LENGTH} is\n        received.  The default implementation disconnects the transport.\n        Override this.\n\n        @param length: The length prefix which was received.\n        @type length: C{int}\n        """'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|dataReceived
dedent|''
name|'def'
name|'dataReceived'
op|'('
name|'self'
op|','
name|'recd'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Convert int prefixed strings into calls to stringReceived.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'recvd'
op|'='
name|'self'
op|'.'
name|'recvd'
op|'+'
name|'recd'
newline|'\n'
name|'while'
name|'len'
op|'('
name|'self'
op|'.'
name|'recvd'
op|')'
op|'>='
name|'self'
op|'.'
name|'prefixLength'
name|'and'
name|'not'
name|'self'
op|'.'
name|'paused'
op|':'
newline|'\n'
indent|'            '
name|'length'
op|','
op|'='
name|'struct'
op|'.'
name|'unpack'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'structFormat'
op|','
name|'self'
op|'.'
name|'recvd'
op|'['
op|':'
name|'self'
op|'.'
name|'prefixLength'
op|']'
op|')'
newline|'\n'
name|'if'
name|'length'
op|'>'
name|'self'
op|'.'
name|'MAX_LENGTH'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'lengthLimitExceeded'
op|'('
name|'length'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'if'
name|'len'
op|'('
name|'self'
op|'.'
name|'recvd'
op|')'
op|'<'
name|'length'
op|'+'
name|'self'
op|'.'
name|'prefixLength'
op|':'
newline|'\n'
indent|'                '
name|'break'
newline|'\n'
dedent|''
name|'packet'
op|'='
name|'self'
op|'.'
name|'recvd'
op|'['
name|'self'
op|'.'
name|'prefixLength'
op|':'
name|'length'
op|'+'
name|'self'
op|'.'
name|'prefixLength'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'recvd'
op|'='
name|'self'
op|'.'
name|'recvd'
op|'['
name|'length'
op|'+'
name|'self'
op|'.'
name|'prefixLength'
op|':'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'stringReceived'
op|'('
name|'packet'
op|')'
newline|'\n'
nl|'\n'
DECL|member|sendString
dedent|''
dedent|''
name|'def'
name|'sendString'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send an prefixed string to the other end of the connection.\n\n        @type data: C{str}\n        """'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'data'
op|')'
op|'>='
number|'2'
op|'**'
op|'('
number|'8'
op|'*'
name|'self'
op|'.'
name|'prefixLength'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'StringTooLongError'
op|'('
nl|'\n'
string|'"Try to send %s bytes whereas maximum is %s"'
op|'%'
op|'('
nl|'\n'
name|'len'
op|'('
name|'data'
op|')'
op|','
number|'2'
op|'**'
op|'('
number|'8'
op|'*'
name|'self'
op|'.'
name|'prefixLength'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
name|'struct'
op|'.'
name|'pack'
op|'('
name|'self'
op|'.'
name|'structFormat'
op|','
name|'len'
op|'('
name|'data'
op|')'
op|')'
op|'+'
name|'data'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Int32StringReceiver
dedent|''
dedent|''
name|'class'
name|'Int32StringReceiver'
op|'('
name|'IntNStringReceiver'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A receiver for int32-prefixed strings.\n\n    An int32 string is a string prefixed by 4 bytes, the 32-bit length of\n    the string encoded in network byte order.\n\n    This class publishes the same interface as NetstringReceiver.\n    """'
newline|'\n'
DECL|variable|structFormat
name|'structFormat'
op|'='
string|'"!I"'
newline|'\n'
DECL|variable|prefixLength
name|'prefixLength'
op|'='
name|'struct'
op|'.'
name|'calcsize'
op|'('
name|'structFormat'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Int16StringReceiver
dedent|''
name|'class'
name|'Int16StringReceiver'
op|'('
name|'IntNStringReceiver'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A receiver for int16-prefixed strings.\n\n    An int16 string is a string prefixed by 2 bytes, the 16-bit length of\n    the string encoded in network byte order.\n\n    This class publishes the same interface as NetstringReceiver.\n    """'
newline|'\n'
DECL|variable|structFormat
name|'structFormat'
op|'='
string|'"!H"'
newline|'\n'
DECL|variable|prefixLength
name|'prefixLength'
op|'='
name|'struct'
op|'.'
name|'calcsize'
op|'('
name|'structFormat'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Int8StringReceiver
dedent|''
name|'class'
name|'Int8StringReceiver'
op|'('
name|'IntNStringReceiver'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A receiver for int8-prefixed strings.\n\n    An int8 string is a string prefixed by 1 byte, the 8-bit length of\n    the string.\n\n    This class publishes the same interface as NetstringReceiver.\n    """'
newline|'\n'
DECL|variable|structFormat
name|'structFormat'
op|'='
string|'"!B"'
newline|'\n'
DECL|variable|prefixLength
name|'prefixLength'
op|'='
name|'struct'
op|'.'
name|'calcsize'
op|'('
name|'structFormat'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|StatefulStringProtocol
dedent|''
name|'class'
name|'StatefulStringProtocol'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A stateful string protocol.\n\n    This is a mixin for string protocols (Int32StringReceiver,\n    NetstringReceiver) which translates stringReceived into a callback\n    (prefixed with \'proto_\') depending on state.\n\n    The state \'done\' is special; if a proto_* method returns it, the\n    connection will be closed immediately.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|state
name|'state'
op|'='
string|"'init'"
newline|'\n'
nl|'\n'
DECL|member|stringReceived
name|'def'
name|'stringReceived'
op|'('
name|'self'
op|','
name|'string'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Choose a protocol phase function and call it.\n\n        Call back to the appropriate protocol phase; this begins with\n        the function proto_init and moves on to proto_* depending on\n        what each proto_* function returns.  (For example, if\n        self.proto_init returns \'foo\', then self.proto_foo will be the\n        next function called when a protocol message is received.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'pto'
op|'='
string|"'proto_'"
op|'+'
name|'self'
op|'.'
name|'state'
newline|'\n'
name|'statehandler'
op|'='
name|'getattr'
op|'('
name|'self'
op|','
name|'pto'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'            '
name|'log'
op|'.'
name|'msg'
op|'('
string|"'callback'"
op|','
name|'self'
op|'.'
name|'state'
op|','
string|"'not found'"
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'state'
op|'='
name|'statehandler'
op|'('
name|'string'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'state'
op|'=='
string|"'done'"
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|class|FileSender
dedent|''
dedent|''
dedent|''
dedent|''
name|'class'
name|'FileSender'
op|':'
newline|'\n'
indent|'    '
string|'"""A producer that sends the contents of a file to a consumer.\n\n    This is a helper for protocols that, at some point, will take a\n    file-like object, read its contents, and write them out to the network,\n    optionally performing some transformation on the bytes in between.\n    """'
newline|'\n'
name|'implements'
op|'('
name|'interfaces'
op|'.'
name|'IProducer'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|CHUNK_SIZE
name|'CHUNK_SIZE'
op|'='
number|'2'
op|'**'
number|'14'
newline|'\n'
nl|'\n'
DECL|variable|lastSent
name|'lastSent'
op|'='
string|"''"
newline|'\n'
DECL|variable|deferred
name|'deferred'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|beginFileTransfer
name|'def'
name|'beginFileTransfer'
op|'('
name|'self'
op|','
name|'file'
op|','
name|'consumer'
op|','
name|'transform'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Begin transferring a file\n\n        @type file: Any file-like object\n        @param file: The file object to read data from\n\n        @type consumer: Any implementor of IConsumer\n        @param consumer: The object to write data to\n\n        @param transform: A callable taking one string argument and returning\n        the same.  All bytes read from the file are passed through this before\n        being written to the consumer.\n\n        @rtype: C{Deferred}\n        @return: A deferred whose callback will be invoked when the file has been\n        completely written to the consumer.  The last byte written to the consumer\n        is passed to the callback.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'file'
op|'='
name|'file'
newline|'\n'
name|'self'
op|'.'
name|'consumer'
op|'='
name|'consumer'
newline|'\n'
name|'self'
op|'.'
name|'transform'
op|'='
name|'transform'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'deferred'
op|'='
name|'deferred'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'consumer'
op|'.'
name|'registerProducer'
op|'('
name|'self'
op|','
name|'False'
op|')'
newline|'\n'
name|'return'
name|'deferred'
newline|'\n'
nl|'\n'
DECL|member|resumeProducing
dedent|''
name|'def'
name|'resumeProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'chunk'
op|'='
string|"''"
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'file'
op|':'
newline|'\n'
indent|'            '
name|'chunk'
op|'='
name|'self'
op|'.'
name|'file'
op|'.'
name|'read'
op|'('
name|'self'
op|'.'
name|'CHUNK_SIZE'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'chunk'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'file'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'consumer'
op|'.'
name|'unregisterProducer'
op|'('
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'deferred'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'deferred'
op|'.'
name|'callback'
op|'('
name|'self'
op|'.'
name|'lastSent'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'deferred'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'transform'
op|':'
newline|'\n'
indent|'            '
name|'chunk'
op|'='
name|'self'
op|'.'
name|'transform'
op|'('
name|'chunk'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'consumer'
op|'.'
name|'write'
op|'('
name|'chunk'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'lastSent'
op|'='
name|'chunk'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
nl|'\n'
DECL|member|pauseProducing
dedent|''
name|'def'
name|'pauseProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|stopProducing
dedent|''
name|'def'
name|'stopProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'deferred'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'deferred'
op|'.'
name|'errback'
op|'('
name|'Exception'
op|'('
string|'"Consumer asked us to stop producing"'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'deferred'
op|'='
name|'None'
newline|'\n'
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
