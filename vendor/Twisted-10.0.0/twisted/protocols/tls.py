begin_unit
comment|'# -*- test-case-name: twisted.protocols.test.test_tls,twisted.internet.test.test_tls,twisted.test.test_sslverify -*-'
nl|'\n'
comment|'# Copyright (c) 2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nImplementation of a TLS transport (L{ISSLTransport}) as an L{IProtocol}\nlayered on top of any L{ITransport} implementation, based on OpenSSL\'s\nmemory BIO features.\n\nL{TLSMemoryBIOFactory} is a L{WrappingFactory} which wraps protocols created by\nthe factory it wraps with L{TLSMemoryBIOProtocol}.  L{TLSMemoryBIOProtocol}\nintercedes between the underlying transport and the wrapped protocol to\nimplement SSL and TLS.  Typical usage of this module looks like this::\n\n    from twisted.protocols.tls import TLSMemoryBIOFactory\n    from twisted.internet.protocol import ServerFactory\n    from twisted.internet.ssl import PrivateCertificate\n    from twisted.internet import reactor\n\n    from someapplication import ApplicationProtocol\n\n    serverFactory = ServerFactory()\n    serverFactory.protocol = ApplicationProtocol\n    certificate = PrivateCertificate.loadPEM(certPEMData)\n    contextFactory = certificate.options()\n    tlsFactory = TLSMemoryBIOFactory(contextFactory, False, serverFactory)\n    reactor.listenTCP(12345, tlsFactory)\n    reactor.run()\n\nBecause the reactor\'s SSL and TLS APIs are likely implemented in a more\nefficient way, it is more common to use them (see L{IReactorSSL} and\nL{ITLSTransport}).  However, this API offers somewhat more flexibility; for\nexample, a L{TLSMemoryBIOProtocol} instance can use another instance of\nL{TLSMemoryBIOProtocol} as its transport, yielding TLS over TLS - useful to\nimplement onion routing.  Or it can be used to run TLS over a UNIX socket,\nor over stdio to a child process.\n"""'
newline|'\n'
nl|'\n'
nl|'\n'
name|'from'
name|'OpenSSL'
op|'.'
name|'SSL'
name|'import'
name|'Error'
op|','
name|'ZeroReturnError'
op|','
name|'WantReadError'
newline|'\n'
name|'from'
name|'OpenSSL'
op|'.'
name|'SSL'
name|'import'
name|'TLSv1_METHOD'
op|','
name|'Context'
op|','
name|'Connection'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'Connection'
op|'('
name|'Context'
op|'('
name|'TLSv1_METHOD'
op|')'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'TypeError'
op|','
name|'e'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'str'
op|'('
name|'e'
op|')'
op|'!='
string|'"argument must be an int, or have a fileno() method."'
op|':'
newline|'\n'
indent|'        '
name|'raise'
newline|'\n'
dedent|''
name|'raise'
name|'ImportError'
op|'('
string|'"twisted.protocols.tls requires pyOpenSSL 0.10 or newer."'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'implements'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'failure'
name|'import'
name|'Failure'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'interfaces'
name|'import'
name|'ISystemHandle'
op|','
name|'ISSLTransport'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'main'
name|'import'
name|'CONNECTION_DONE'
op|','
name|'CONNECTION_LOST'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'protocol'
name|'import'
name|'Protocol'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'protocols'
op|'.'
name|'policies'
name|'import'
name|'ProtocolWrapper'
op|','
name|'WrappingFactory'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|TLSMemoryBIOProtocol
name|'class'
name|'TLSMemoryBIOProtocol'
op|'('
name|'ProtocolWrapper'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    L{TLSMemoryBIOProtocol} is a protocol wrapper which uses OpenSSL via a\n    memory BIO to encrypt bytes written to it before sending them on to the\n    underlying transport and decrypts bytes received from the underlying\n    transport before delivering them to the wrapped protocol.\n\n    @ivar _tlsConnection: The L{OpenSSL.SSL.Connection} instance which is\n        encrypted and decrypting this connection.\n\n    @ivar _lostConnection: A flag indicating whether connection loss has\n        already been dealt with (C{True}) or not (C{False}).\n\n    @ivar _writeBlockedOnRead: A flag indicating whether further writing must\n        wait for data to be received (C{True}) or not (C{False}).\n\n    @ivar _appSendBuffer: A C{list} of C{str} of application-level (cleartext)\n        data which is waiting for C{_writeBlockedOnRead} to be reset to\n        C{False} so it can be passed to and perhaps accepted by\n        C{_tlsConnection.send}.\n\n    @ivar _connectWrapped: A flag indicating whether or not to call\n        C{makeConnection} on the wrapped protocol.  This is for the reactor\'s\n        L{ITLSTransport.startTLS} implementation, since it has a protocol which\n        it has already called C{makeConnection} on, and which has no interest\n        in a new transport.  See #3821.\n\n    @ivar _handshakeDone: A flag indicating whether or not the handshake is\n        known to have completed successfully (C{True}) or not (C{False}).  This\n        is used to control error reporting behavior.  If the handshake has not\n        completed, the underlying L{OpenSSL.SSL.Error} will be passed to the\n        application\'s C{connectionLost} method.  If it has completed, any\n        unexpected L{OpenSSL.SSL.Error} will be turned into a\n        L{ConnectionLost}.  This is weird; however, it is simply an attempt at\n        a faithful re-implementation of the behavior provided by\n        L{twisted.internet.ssl}.\n\n    @ivar _reason: If an unexpected L{OpenSSL.SSL.Error} occurs which causes\n        the connection to be lost, it is saved here.  If appropriate, this may\n        be used as the reason passed to the application protocol\'s\n        C{connectionLost} method.\n    """'
newline|'\n'
name|'implements'
op|'('
name|'ISystemHandle'
op|','
name|'ISSLTransport'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|_reason
name|'_reason'
op|'='
name|'None'
newline|'\n'
DECL|variable|_handshakeDone
name|'_handshakeDone'
op|'='
name|'False'
newline|'\n'
DECL|variable|_lostConnection
name|'_lostConnection'
op|'='
name|'False'
newline|'\n'
DECL|variable|_writeBlockedOnRead
name|'_writeBlockedOnRead'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'factory'
op|','
name|'wrappedProtocol'
op|','
name|'_connectWrapped'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'ProtocolWrapper'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'factory'
op|','
name|'wrappedProtocol'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_connectWrapped'
op|'='
name|'_connectWrapped'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getHandle
dedent|''
name|'def'
name|'getHandle'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the L{OpenSSL.SSL.Connection} object being used to encrypt and\n        decrypt this connection.\n\n        This is done for the benefit of L{twisted.internet.ssl.Certificate}\'s\n        C{peerFromTransport} and C{hostFromTransport} methods only.  A\n        different system handle may be returned by future versions of this\n        method.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_tlsConnection'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|makeConnection
dedent|''
name|'def'
name|'makeConnection'
op|'('
name|'self'
op|','
name|'transport'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Connect this wrapper to the given transport and initialize the\n        necessary L{OpenSSL.SSL.Connection} with a memory BIO.\n        """'
newline|'\n'
name|'tlsContext'
op|'='
name|'self'
op|'.'
name|'factory'
op|'.'
name|'_contextFactory'
op|'.'
name|'getContext'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_tlsConnection'
op|'='
name|'Connection'
op|'('
name|'tlsContext'
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'factory'
op|'.'
name|'_isClient'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_tlsConnection'
op|'.'
name|'set_connect_state'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_tlsConnection'
op|'.'
name|'set_accept_state'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_appSendBuffer'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
comment|'# Intentionally skip ProtocolWrapper.makeConnection - it might call'
nl|'\n'
comment|'# wrappedProtocol.makeConnection, which we want to make conditional.'
nl|'\n'
name|'Protocol'
op|'.'
name|'makeConnection'
op|'('
name|'self'
op|','
name|'transport'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'factory'
op|'.'
name|'registerProtocol'
op|'('
name|'self'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_connectWrapped'
op|':'
newline|'\n'
comment|'# Now that the TLS layer is initialized, notify the application of'
nl|'\n'
comment|'# the connection.'
nl|'\n'
indent|'            '
name|'ProtocolWrapper'
op|'.'
name|'makeConnection'
op|'('
name|'self'
op|','
name|'transport'
op|')'
newline|'\n'
nl|'\n'
comment|'# Now that we ourselves have a transport (initialized by the'
nl|'\n'
comment|'# ProtocolWrapper.makeConnection call above), kick off the TLS'
nl|'\n'
comment|'# handshake.'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_tlsConnection'
op|'.'
name|'do_handshake'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'WantReadError'
op|':'
newline|'\n'
comment|"# This is the expected case - there's no data in the connection's"
nl|'\n'
comment|"# input buffer yet, so it won't be able to complete the whole"
nl|'\n'
comment|'# handshake now.  If this is the speak-first side of the'
nl|'\n'
comment|'# connection, then some bytes will be in the send buffer now; flush'
nl|'\n'
comment|'# them.'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_flushSendBIO'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_flushSendBIO
dedent|''
dedent|''
name|'def'
name|'_flushSendBIO'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Read any bytes out of the send BIO and write them to the underlying\n        transport.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'bytes'
op|'='
name|'self'
op|'.'
name|'_tlsConnection'
op|'.'
name|'bio_read'
op|'('
number|'2'
op|'**'
number|'15'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'WantReadError'
op|':'
newline|'\n'
comment|'# There may be nothing in the send BIO right now.'
nl|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
name|'bytes'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_flushReceiveBIO
dedent|''
dedent|''
name|'def'
name|'_flushReceiveBIO'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Try to receive any application-level bytes which are now available\n        because of a previous write into the receive BIO.  This will take\n        care of delivering any application-level bytes which are received to\n        the protocol, as well as handling of the various exceptions which\n        can come from trying to get such bytes.\n        """'
newline|'\n'
comment|'# Keep trying this until an error indicates we should stop or we'
nl|'\n'
comment|'# close the connection.  Looping is necessary to make sure we'
nl|'\n'
comment|'# process all of the data which was put into the receive BIO, as'
nl|'\n'
comment|'# there is no guarantee that a single recv call will do it all.'
nl|'\n'
name|'while'
name|'not'
name|'self'
op|'.'
name|'_lostConnection'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'bytes'
op|'='
name|'self'
op|'.'
name|'_tlsConnection'
op|'.'
name|'recv'
op|'('
number|'2'
op|'**'
number|'15'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'WantReadError'
op|':'
newline|'\n'
comment|'# The newly received bytes might not have been enough to produce'
nl|'\n'
comment|'# any application data.'
nl|'\n'
indent|'                '
name|'break'
newline|'\n'
dedent|''
name|'except'
name|'ZeroReturnError'
op|':'
newline|'\n'
comment|'# TLS has shut down and no more TLS data will be received over'
nl|'\n'
comment|'# this connection.'
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'_lostConnection'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_handshakeDone'
name|'and'
name|'self'
op|'.'
name|'_reason'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'failure'
op|'='
name|'self'
op|'.'
name|'_reason'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'failure'
op|'='
name|'Failure'
op|'('
name|'CONNECTION_DONE'
op|')'
newline|'\n'
comment|"# Failure's are fat.  Drop the reference."
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_reason'
op|'='
name|'None'
newline|'\n'
name|'ProtocolWrapper'
op|'.'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'failure'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Error'
op|','
name|'e'
op|':'
newline|'\n'
comment|'# Something went pretty wrong.  For example, this might be a'
nl|'\n'
comment|'# handshake failure (because there were no shared ciphers, because'
nl|'\n'
comment|'# a certificate failed to verify, etc).  TLS can no longer proceed.'
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'_flushSendBIO'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_lostConnection'
op|'='
name|'True'
newline|'\n'
nl|'\n'
comment|'# Squash EOF in violation of protocol into ConnectionLost'
nl|'\n'
name|'if'
name|'e'
op|'.'
name|'args'
op|'['
number|'0'
op|']'
op|'=='
op|'-'
number|'1'
name|'and'
name|'e'
op|'.'
name|'args'
op|'['
number|'1'
op|']'
op|'=='
string|"'Unexpected EOF'"
op|':'
newline|'\n'
indent|'                    '
name|'failure'
op|'='
name|'Failure'
op|'('
name|'CONNECTION_LOST'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'failure'
op|'='
name|'Failure'
op|'('
op|')'
newline|'\n'
dedent|''
name|'ProtocolWrapper'
op|'.'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'failure'
op|')'
newline|'\n'
comment|'# This loseConnection call is basically tested by'
nl|'\n'
comment|'# test_handshakeFailure.  At least one side will need to do it'
nl|'\n'
comment|'# or the test never finishes.'
nl|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# If we got application bytes, the handshake must be done by'
nl|'\n'
comment|'# now.  Keep track of this to control error reporting later.'
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'_handshakeDone'
op|'='
name|'True'
newline|'\n'
name|'ProtocolWrapper'
op|'.'
name|'dataReceived'
op|'('
name|'self'
op|','
name|'bytes'
op|')'
newline|'\n'
nl|'\n'
comment|'# The received bytes might have generated a response which needs to be'
nl|'\n'
comment|'# sent now.  For example, the handshake involves several round-trip'
nl|'\n'
comment|'# exchanges without ever producing application-bytes.'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_flushSendBIO'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|dataReceived
dedent|''
name|'def'
name|'dataReceived'
op|'('
name|'self'
op|','
name|'bytes'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Deliver any received bytes to the receive BIO and then read and deliver\n        to the application any application-level data which becomes available\n        as a result of this.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_tlsConnection'
op|'.'
name|'bio_write'
op|'('
name|'bytes'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_writeBlockedOnRead'
op|':'
newline|'\n'
comment|'# A read just happened, so we might not be blocked anymore.  Try to'
nl|'\n'
comment|'# flush all the pending application bytes.'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_writeBlockedOnRead'
op|'='
name|'False'
newline|'\n'
name|'appSendBuffer'
op|'='
name|'self'
op|'.'
name|'_appSendBuffer'
newline|'\n'
name|'self'
op|'.'
name|'_appSendBuffer'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'bytes'
name|'in'
name|'appSendBuffer'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'write'
op|'('
name|'bytes'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'_writeBlockedOnRead'
name|'and'
name|'self'
op|'.'
name|'disconnecting'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_flushReceiveBIO'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionLost
dedent|''
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Handle the possible repetition of calls to this method (due to either\n        the underlying transport going away or due to an error at the TLS\n        layer) and make sure the base implementation only gets invoked once.\n        """'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_lostConnection'
op|':'
newline|'\n'
comment|"# Tell the TLS connection that it's not going to get any more data"
nl|'\n'
comment|'# and give it a chance to finish reading.'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_tlsConnection'
op|'.'
name|'bio_shutdown'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_flushReceiveBIO'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|loseConnection
dedent|''
dedent|''
name|'def'
name|'loseConnection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send a TLS close alert and close the underlying connection.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'disconnecting'
op|'='
name|'True'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_writeBlockedOnRead'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_tlsConnection'
op|'.'
name|'shutdown'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_flushSendBIO'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|write
dedent|''
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'bytes'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Process the given application bytes and send any resulting TLS traffic\n        which arrives in the send BIO.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_lostConnection'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'leftToSend'
op|'='
name|'bytes'
newline|'\n'
name|'while'
name|'leftToSend'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'sent'
op|'='
name|'self'
op|'.'
name|'_tlsConnection'
op|'.'
name|'send'
op|'('
name|'leftToSend'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'WantReadError'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_writeBlockedOnRead'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'_appSendBuffer'
op|'.'
name|'append'
op|'('
name|'leftToSend'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'except'
name|'Error'
op|','
name|'e'
op|':'
newline|'\n'
comment|'# Just drop the connection.  This has two useful consequences.'
nl|'\n'
comment|"# First, for the application protocol's connectionLost method,"
nl|'\n'
comment|'# it will squash any error into connection lost.  We *could*'
nl|'\n'
comment|'# let the real exception propagate to application code, but the'
nl|'\n'
comment|"# other SSL implementation doesn't.  Second, it causes the"
nl|'\n'
comment|"# protocol's connectionLost method to be invoked"
nl|'\n'
comment|'# non-reentrantly, which is always a nice feature.'
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'_reason'
op|'='
name|'Failure'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# If we sent some bytes, the handshake must be done.  Keep'
nl|'\n'
comment|'# track of this to control error reporting behavior.'
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'_handshakeDone'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'_flushSendBIO'
op|'('
op|')'
newline|'\n'
name|'leftToSend'
op|'='
name|'leftToSend'
op|'['
name|'sent'
op|':'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|writeSequence
dedent|''
dedent|''
dedent|''
name|'def'
name|'writeSequence'
op|'('
name|'self'
op|','
name|'iovec'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write a sequence of application bytes by joining them into one string\n        and passing them to L{write}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'write'
op|'('
string|'""'
op|'.'
name|'join'
op|'('
name|'iovec'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getPeerCertificate
dedent|''
name|'def'
name|'getPeerCertificate'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_tlsConnection'
op|'.'
name|'get_peer_certificate'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TLSMemoryBIOFactory
dedent|''
dedent|''
name|'class'
name|'TLSMemoryBIOFactory'
op|'('
name|'WrappingFactory'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    L{TLSMemoryBIOFactory} adds TLS to connections.\n\n    @ivar _contextFactory: The TLS context factory which will be used to define\n        certain TLS connection parameters.\n\n    @ivar _isClient: A flag which is C{True} if this is a client TLS\n        connection, C{False} if it is a server TLS connection.\n    """'
newline|'\n'
DECL|variable|protocol
name|'protocol'
op|'='
name|'TLSMemoryBIOProtocol'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'contextFactory'
op|','
name|'isClient'
op|','
name|'wrappedFactory'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'WrappingFactory'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'wrappedFactory'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_contextFactory'
op|'='
name|'contextFactory'
newline|'\n'
name|'self'
op|'.'
name|'_isClient'
op|'='
name|'isClient'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
