begin_unit
comment|'# Copyright (c) 2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTests for L{twisted.protocols.tls}.\n"""'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'from'
name|'twisted'
op|'.'
name|'protocols'
op|'.'
name|'tls'
name|'import'
name|'TLSMemoryBIOProtocol'
op|','
name|'TLSMemoryBIOFactory'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
comment|"# Skip the whole test module if it can't be imported."
nl|'\n'
DECL|variable|skip
indent|'    '
name|'skip'
op|'='
string|'"pyOpenSSL 0.10 or newer required for twisted.protocol.tls"'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Otherwise, the pyOpenSSL dependency must be satisfied, so all these'
nl|'\n'
comment|'# imports will work.'
nl|'\n'
indent|'    '
name|'from'
name|'OpenSSL'
op|'.'
name|'crypto'
name|'import'
name|'X509Type'
newline|'\n'
name|'from'
name|'OpenSSL'
op|'.'
name|'SSL'
name|'import'
name|'TLSv1_METHOD'
op|','
name|'Error'
op|','
name|'Context'
op|','
name|'ConnectionType'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'ssl'
name|'import'
name|'ClientContextFactory'
op|','
name|'PrivateCertificate'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'ssl'
name|'import'
name|'DefaultOpenSSLContextFactory'
newline|'\n'
nl|'\n'
dedent|''
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'filepath'
name|'import'
name|'FilePath'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'interfaces'
name|'import'
name|'ISystemHandle'
op|','
name|'ISSLTransport'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'error'
name|'import'
name|'ConnectionDone'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'defer'
name|'import'
name|'Deferred'
op|','
name|'gatherResults'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'protocol'
name|'import'
name|'Protocol'
op|','
name|'ClientFactory'
op|','
name|'ServerFactory'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'protocols'
op|'.'
name|'loopback'
name|'import'
name|'loopbackAsync'
op|','
name|'collapsingPumpPolicy'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
op|'.'
name|'unittest'
name|'import'
name|'TestCase'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'test'
op|'.'
name|'test_tcp'
name|'import'
name|'ConnectionLostNotifyingProtocol'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'test'
op|'.'
name|'test_ssl'
name|'import'
name|'certPath'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'test'
op|'.'
name|'proto_helpers'
name|'import'
name|'StringTransport'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|HandshakeCallbackContextFactory
name|'class'
name|'HandshakeCallbackContextFactory'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    L{HandshakeCallbackContextFactory} is a factory for SSL contexts which\n    allows applications to get notification when the SSL handshake completes.\n\n    @ivar _finished: A L{Deferred} which will be called back when the handshake\n        is done.\n    """'
newline|'\n'
comment|'# pyOpenSSL needs to expose this.'
nl|'\n'
comment|'# https://bugs.launchpad.net/pyopenssl/+bug/372832'
nl|'\n'
DECL|variable|SSL_CB_HANDSHAKE_DONE
name|'SSL_CB_HANDSHAKE_DONE'
op|'='
number|'0x20'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_finished'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|factoryAndDeferred
dedent|''
name|'def'
name|'factoryAndDeferred'
op|'('
name|'cls'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a new L{HandshakeCallbackContextFactory} and return a two-tuple\n        of it and a L{Deferred} which will fire when a connection created with\n        it completes a TLS handshake.\n        """'
newline|'\n'
name|'contextFactory'
op|'='
name|'cls'
op|'('
op|')'
newline|'\n'
name|'return'
name|'contextFactory'
op|','
name|'contextFactory'
op|'.'
name|'_finished'
newline|'\n'
DECL|variable|factoryAndDeferred
dedent|''
name|'factoryAndDeferred'
op|'='
name|'classmethod'
op|'('
name|'factoryAndDeferred'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_info
name|'def'
name|'_info'
op|'('
name|'self'
op|','
name|'connection'
op|','
name|'where'
op|','
name|'ret'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        This is the "info callback" on the context.  It will be called\n        periodically by pyOpenSSL with information about the state of a\n        connection.  When it indicates the handshake is complete, it will fire\n        C{self._finished}.\n        """'
newline|'\n'
name|'if'
name|'where'
op|'&'
name|'self'
op|'.'
name|'SSL_CB_HANDSHAKE_DONE'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_finished'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getContext
dedent|''
dedent|''
name|'def'
name|'getContext'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create and return an SSL context configured to use L{self._info} as the\n        info callback.\n        """'
newline|'\n'
name|'context'
op|'='
name|'Context'
op|'('
name|'TLSv1_METHOD'
op|')'
newline|'\n'
name|'context'
op|'.'
name|'set_info_callback'
op|'('
name|'self'
op|'.'
name|'_info'
op|')'
newline|'\n'
name|'return'
name|'context'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|AccumulatingProtocol
dedent|''
dedent|''
name|'class'
name|'AccumulatingProtocol'
op|'('
name|'Protocol'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A protocol which collects the bytes it receives and closes its connection\n    after receiving a certain minimum of data.\n\n    @ivar howMany: The number of bytes of data to wait for before closing the connection.\n    @ivar receiving: A C{list} of C{str} of the bytes received so far.\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'howMany'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'howMany'
op|'='
name|'howMany'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionMade
dedent|''
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'received'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|dataReceived
dedent|''
name|'def'
name|'dataReceived'
op|'('
name|'self'
op|','
name|'bytes'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'received'
op|'.'
name|'append'
op|'('
name|'bytes'
op|')'
newline|'\n'
name|'if'
name|'sum'
op|'('
name|'map'
op|'('
name|'len'
op|','
name|'self'
op|'.'
name|'received'
op|')'
op|')'
op|'>='
name|'self'
op|'.'
name|'howMany'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TLSMemoryBIOTests
dedent|''
dedent|''
dedent|''
name|'class'
name|'TLSMemoryBIOTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for the implementation of L{ISSLTransport} which runs over another\n    L{ITransport}.\n    """'
newline|'\n'
DECL|member|test_interfaces
name|'def'
name|'test_interfaces'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{TLSMemoryBIOProtocol} instances provide L{ISSLTransport} and\n        L{ISystemHandle}.\n        """'
newline|'\n'
name|'proto'
op|'='
name|'TLSMemoryBIOProtocol'
op|'('
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'ISSLTransport'
op|'.'
name|'providedBy'
op|'('
name|'proto'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'ISystemHandle'
op|'.'
name|'providedBy'
op|'('
name|'proto'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getHandle
dedent|''
name|'def'
name|'test_getHandle'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{TLSMemoryBIOProtocol.getHandle} returns the L{OpenSSL.SSL.Connection}\n        instance it uses to actually implement TLS.\n\n        This may seem odd.  In fact, it is.  The L{OpenSSL.SSL.Connection} is\n        not actually the "system handle" here, nor even an object the reactor\n        knows about directly.  However, L{twisted.internet.ssl.Certificate}\'s\n        C{peerFromTransport} and C{hostFromTransport} methods depend on being\n        able to get an L{OpenSSL.SSL.Connection} object in order to work\n        properly.  Implementing L{ISystemHandle.getHandle} like this is the\n        easiest way for those APIs to be made to work.  If they are changed,\n        then it may make sense to get rid of this implementation of\n        L{ISystemHandle} and return the underlying socket instead.\n        """'
newline|'\n'
name|'factory'
op|'='
name|'ClientFactory'
op|'('
op|')'
newline|'\n'
name|'contextFactory'
op|'='
name|'ClientContextFactory'
op|'('
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
name|'contextFactory'
op|','
name|'True'
op|','
name|'factory'
op|')'
newline|'\n'
name|'proto'
op|'='
name|'TLSMemoryBIOProtocol'
op|'('
name|'wrapperFactory'
op|','
name|'Protocol'
op|'('
op|')'
op|')'
newline|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'proto'
op|'.'
name|'makeConnection'
op|'('
name|'transport'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'proto'
op|'.'
name|'getHandle'
op|'('
op|')'
op|','
name|'ConnectionType'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_makeConnection
dedent|''
name|'def'
name|'test_makeConnection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When L{TLSMemoryBIOProtocol} is connected to a transport, it connects\n        the protocol it wraps to a transport.\n        """'
newline|'\n'
name|'clientProtocol'
op|'='
name|'Protocol'
op|'('
op|')'
newline|'\n'
name|'clientFactory'
op|'='
name|'ClientFactory'
op|'('
op|')'
newline|'\n'
name|'clientFactory'
op|'.'
name|'protocol'
op|'='
name|'lambda'
op|':'
name|'clientProtocol'
newline|'\n'
nl|'\n'
name|'contextFactory'
op|'='
name|'ClientContextFactory'
op|'('
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
nl|'\n'
name|'contextFactory'
op|','
name|'True'
op|','
name|'clientFactory'
op|')'
newline|'\n'
name|'sslProtocol'
op|'='
name|'wrapperFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'transport'
op|'='
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'sslProtocol'
op|'.'
name|'makeConnection'
op|'('
name|'transport'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertNotIdentical'
op|'('
name|'clientProtocol'
op|'.'
name|'transport'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertNotIdentical'
op|'('
name|'clientProtocol'
op|'.'
name|'transport'
op|','
name|'transport'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_handshake
dedent|''
name|'def'
name|'test_handshake'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The TLS handshake is performed when L{TLSMemoryBIOProtocol} is\n        connected to a transport.\n        """'
newline|'\n'
name|'clientFactory'
op|'='
name|'ClientFactory'
op|'('
op|')'
newline|'\n'
name|'clientFactory'
op|'.'
name|'protocol'
op|'='
name|'Protocol'
newline|'\n'
nl|'\n'
name|'clientContextFactory'
op|','
name|'handshakeDeferred'
op|'='
op|'('
nl|'\n'
name|'HandshakeCallbackContextFactory'
op|'.'
name|'factoryAndDeferred'
op|'('
op|')'
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
nl|'\n'
name|'clientContextFactory'
op|','
name|'True'
op|','
name|'clientFactory'
op|')'
newline|'\n'
name|'sslClientProtocol'
op|'='
name|'wrapperFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'serverFactory'
op|'='
name|'ServerFactory'
op|'('
op|')'
newline|'\n'
name|'serverFactory'
op|'.'
name|'protocol'
op|'='
name|'Protocol'
newline|'\n'
nl|'\n'
name|'serverContextFactory'
op|'='
name|'DefaultOpenSSLContextFactory'
op|'('
name|'certPath'
op|','
name|'certPath'
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
nl|'\n'
name|'serverContextFactory'
op|','
name|'False'
op|','
name|'serverFactory'
op|')'
newline|'\n'
name|'sslServerProtocol'
op|'='
name|'wrapperFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'connectionDeferred'
op|'='
name|'loopbackAsync'
op|'('
name|'sslServerProtocol'
op|','
name|'sslClientProtocol'
op|')'
newline|'\n'
nl|'\n'
comment|"# Only wait for the handshake to complete.  Anything after that isn't"
nl|'\n'
comment|'# important here.'
nl|'\n'
name|'return'
name|'handshakeDeferred'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_handshakeFailure
dedent|''
name|'def'
name|'test_handshakeFailure'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{TLSMemoryBIOProtocol} reports errors in the handshake process to the\n        application-level protocol object using its C{connectionLost} method\n        and disconnects the underlying transport.\n        """'
newline|'\n'
name|'clientConnectionLost'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'clientFactory'
op|'='
name|'ClientFactory'
op|'('
op|')'
newline|'\n'
name|'clientFactory'
op|'.'
name|'protocol'
op|'='
op|'('
nl|'\n'
name|'lambda'
op|':'
name|'ConnectionLostNotifyingProtocol'
op|'('
nl|'\n'
name|'clientConnectionLost'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'clientContextFactory'
op|'='
name|'HandshakeCallbackContextFactory'
op|'('
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
nl|'\n'
name|'clientContextFactory'
op|','
name|'True'
op|','
name|'clientFactory'
op|')'
newline|'\n'
name|'sslClientProtocol'
op|'='
name|'wrapperFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'serverConnectionLost'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'serverFactory'
op|'='
name|'ServerFactory'
op|'('
op|')'
newline|'\n'
name|'serverFactory'
op|'.'
name|'protocol'
op|'='
op|'('
nl|'\n'
name|'lambda'
op|':'
name|'ConnectionLostNotifyingProtocol'
op|'('
nl|'\n'
name|'serverConnectionLost'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# This context factory rejects any clients which do not present a'
nl|'\n'
comment|'# certificate.'
nl|'\n'
name|'certificateData'
op|'='
name|'FilePath'
op|'('
name|'certPath'
op|')'
op|'.'
name|'getContent'
op|'('
op|')'
newline|'\n'
name|'certificate'
op|'='
name|'PrivateCertificate'
op|'.'
name|'loadPEM'
op|'('
name|'certificateData'
op|')'
newline|'\n'
name|'serverContextFactory'
op|'='
name|'certificate'
op|'.'
name|'options'
op|'('
name|'certificate'
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
nl|'\n'
name|'serverContextFactory'
op|','
name|'False'
op|','
name|'serverFactory'
op|')'
newline|'\n'
name|'sslServerProtocol'
op|'='
name|'wrapperFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'connectionDeferred'
op|'='
name|'loopbackAsync'
op|'('
name|'sslServerProtocol'
op|','
name|'sslClientProtocol'
op|')'
newline|'\n'
nl|'\n'
DECL|function|cbConnectionLost
name|'def'
name|'cbConnectionLost'
op|'('
name|'protocol'
op|')'
op|':'
newline|'\n'
comment|'# The connection should close on its own in response to the error'
nl|'\n'
comment|'# induced by the client not supplying the required certificate.'
nl|'\n'
comment|"# After that, check to make sure the protocol's connectionLost was"
nl|'\n'
comment|'# called with the right thing.'
nl|'\n'
indent|'            '
name|'protocol'
op|'.'
name|'lostConnectionReason'
op|'.'
name|'trap'
op|'('
name|'Error'
op|')'
newline|'\n'
dedent|''
name|'clientConnectionLost'
op|'.'
name|'addCallback'
op|'('
name|'cbConnectionLost'
op|')'
newline|'\n'
name|'serverConnectionLost'
op|'.'
name|'addCallback'
op|'('
name|'cbConnectionLost'
op|')'
newline|'\n'
nl|'\n'
comment|'# Additionally, the underlying transport should have been told to'
nl|'\n'
comment|'# go away.'
nl|'\n'
name|'return'
name|'gatherResults'
op|'('
op|'['
nl|'\n'
name|'clientConnectionLost'
op|','
name|'serverConnectionLost'
op|','
nl|'\n'
name|'connectionDeferred'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getPeerCertificate
dedent|''
name|'def'
name|'test_getPeerCertificate'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{TLSMemoryBIOFactory.getPeerCertificate} returns the\n        L{OpenSSL.crypto.X509Type} instance representing the peer\'s\n        certificate.\n        """'
newline|'\n'
comment|"# Set up a client and server so there's a certificate to grab."
nl|'\n'
name|'clientFactory'
op|'='
name|'ClientFactory'
op|'('
op|')'
newline|'\n'
name|'clientFactory'
op|'.'
name|'protocol'
op|'='
name|'Protocol'
newline|'\n'
nl|'\n'
name|'clientContextFactory'
op|','
name|'handshakeDeferred'
op|'='
op|'('
nl|'\n'
name|'HandshakeCallbackContextFactory'
op|'.'
name|'factoryAndDeferred'
op|'('
op|')'
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
nl|'\n'
name|'clientContextFactory'
op|','
name|'True'
op|','
name|'clientFactory'
op|')'
newline|'\n'
name|'sslClientProtocol'
op|'='
name|'wrapperFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'serverFactory'
op|'='
name|'ServerFactory'
op|'('
op|')'
newline|'\n'
name|'serverFactory'
op|'.'
name|'protocol'
op|'='
name|'Protocol'
newline|'\n'
nl|'\n'
name|'serverContextFactory'
op|'='
name|'DefaultOpenSSLContextFactory'
op|'('
name|'certPath'
op|','
name|'certPath'
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
nl|'\n'
name|'serverContextFactory'
op|','
name|'False'
op|','
name|'serverFactory'
op|')'
newline|'\n'
name|'sslServerProtocol'
op|'='
name|'wrapperFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'connectionDeferred'
op|'='
name|'loopbackAsync'
op|'('
nl|'\n'
name|'sslServerProtocol'
op|','
name|'sslClientProtocol'
op|')'
newline|'\n'
nl|'\n'
comment|'# Wait for the handshake'
nl|'\n'
DECL|function|cbHandshook
name|'def'
name|'cbHandshook'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
comment|"# Grab the server's certificate and check it out"
nl|'\n'
indent|'            '
name|'cert'
op|'='
name|'sslClientProtocol'
op|'.'
name|'getPeerCertificate'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'cert'
op|','
name|'X509Type'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'cert'
op|'.'
name|'digest'
op|'('
string|"'md5'"
op|')'
op|','
nl|'\n'
string|"'9B:A4:AB:43:10:BE:82:AE:94:3E:6B:91:F2:F3:40:E8'"
op|')'
newline|'\n'
dedent|''
name|'handshakeDeferred'
op|'.'
name|'addCallback'
op|'('
name|'cbHandshook'
op|')'
newline|'\n'
name|'return'
name|'handshakeDeferred'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_writeAfterHandshake
dedent|''
name|'def'
name|'test_writeAfterHandshake'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Bytes written to L{TLSMemoryBIOProtocol} before the handshake is\n        complete are received by the protocol on the other side of the\n        connection once the handshake succeeds.\n        """'
newline|'\n'
name|'bytes'
op|'='
string|'"some bytes"'
newline|'\n'
nl|'\n'
name|'clientProtocol'
op|'='
name|'Protocol'
op|'('
op|')'
newline|'\n'
name|'clientFactory'
op|'='
name|'ClientFactory'
op|'('
op|')'
newline|'\n'
name|'clientFactory'
op|'.'
name|'protocol'
op|'='
name|'lambda'
op|':'
name|'clientProtocol'
newline|'\n'
nl|'\n'
name|'clientContextFactory'
op|','
name|'handshakeDeferred'
op|'='
op|'('
nl|'\n'
name|'HandshakeCallbackContextFactory'
op|'.'
name|'factoryAndDeferred'
op|'('
op|')'
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
nl|'\n'
name|'clientContextFactory'
op|','
name|'True'
op|','
name|'clientFactory'
op|')'
newline|'\n'
name|'sslClientProtocol'
op|'='
name|'wrapperFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'serverProtocol'
op|'='
name|'AccumulatingProtocol'
op|'('
name|'len'
op|'('
name|'bytes'
op|')'
op|')'
newline|'\n'
name|'serverFactory'
op|'='
name|'ServerFactory'
op|'('
op|')'
newline|'\n'
name|'serverFactory'
op|'.'
name|'protocol'
op|'='
name|'lambda'
op|':'
name|'serverProtocol'
newline|'\n'
nl|'\n'
name|'serverContextFactory'
op|'='
name|'DefaultOpenSSLContextFactory'
op|'('
name|'certPath'
op|','
name|'certPath'
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
nl|'\n'
name|'serverContextFactory'
op|','
name|'False'
op|','
name|'serverFactory'
op|')'
newline|'\n'
name|'sslServerProtocol'
op|'='
name|'wrapperFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'connectionDeferred'
op|'='
name|'loopbackAsync'
op|'('
name|'sslServerProtocol'
op|','
name|'sslClientProtocol'
op|')'
newline|'\n'
nl|'\n'
comment|'# Wait for the handshake to finish before writing anything.'
nl|'\n'
DECL|function|cbHandshook
name|'def'
name|'cbHandshook'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'clientProtocol'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
name|'bytes'
op|')'
newline|'\n'
nl|'\n'
comment|'# The server will drop the connection once it gets the bytes.'
nl|'\n'
name|'return'
name|'connectionDeferred'
newline|'\n'
dedent|''
name|'handshakeDeferred'
op|'.'
name|'addCallback'
op|'('
name|'cbHandshook'
op|')'
newline|'\n'
nl|'\n'
comment|'# Once the connection is lost, make sure the server received the'
nl|'\n'
comment|'# expected bytes.'
nl|'\n'
DECL|function|cbDisconnected
name|'def'
name|'cbDisconnected'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
string|'""'
op|'.'
name|'join'
op|'('
name|'serverProtocol'
op|'.'
name|'received'
op|')'
op|','
name|'bytes'
op|')'
newline|'\n'
dedent|''
name|'handshakeDeferred'
op|'.'
name|'addCallback'
op|'('
name|'cbDisconnected'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'handshakeDeferred'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_writeBeforeHandshake
dedent|''
name|'def'
name|'test_writeBeforeHandshake'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Bytes written to L{TLSMemoryBIOProtocol} before the handshake is\n        complete are received by the protocol on the other side of the\n        connection once the handshake succeeds.\n        """'
newline|'\n'
name|'bytes'
op|'='
string|'"some bytes"'
newline|'\n'
nl|'\n'
DECL|class|SimpleSendingProtocol
name|'class'
name|'SimpleSendingProtocol'
op|'('
name|'Protocol'
op|')'
op|':'
newline|'\n'
DECL|member|connectionMade
indent|'            '
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
name|'bytes'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'clientFactory'
op|'='
name|'ClientFactory'
op|'('
op|')'
newline|'\n'
name|'clientFactory'
op|'.'
name|'protocol'
op|'='
name|'SimpleSendingProtocol'
newline|'\n'
nl|'\n'
name|'clientContextFactory'
op|','
name|'handshakeDeferred'
op|'='
op|'('
nl|'\n'
name|'HandshakeCallbackContextFactory'
op|'.'
name|'factoryAndDeferred'
op|'('
op|')'
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
nl|'\n'
name|'clientContextFactory'
op|','
name|'True'
op|','
name|'clientFactory'
op|')'
newline|'\n'
name|'sslClientProtocol'
op|'='
name|'wrapperFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'serverProtocol'
op|'='
name|'AccumulatingProtocol'
op|'('
name|'len'
op|'('
name|'bytes'
op|')'
op|')'
newline|'\n'
name|'serverFactory'
op|'='
name|'ServerFactory'
op|'('
op|')'
newline|'\n'
name|'serverFactory'
op|'.'
name|'protocol'
op|'='
name|'lambda'
op|':'
name|'serverProtocol'
newline|'\n'
nl|'\n'
name|'serverContextFactory'
op|'='
name|'DefaultOpenSSLContextFactory'
op|'('
name|'certPath'
op|','
name|'certPath'
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
nl|'\n'
name|'serverContextFactory'
op|','
name|'False'
op|','
name|'serverFactory'
op|')'
newline|'\n'
name|'sslServerProtocol'
op|'='
name|'wrapperFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'connectionDeferred'
op|'='
name|'loopbackAsync'
op|'('
name|'sslServerProtocol'
op|','
name|'sslClientProtocol'
op|')'
newline|'\n'
nl|'\n'
comment|'# Wait for the connection to end, then make sure the server received'
nl|'\n'
comment|'# the bytes sent by the client.'
nl|'\n'
DECL|function|cbConnectionDone
name|'def'
name|'cbConnectionDone'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
string|'""'
op|'.'
name|'join'
op|'('
name|'serverProtocol'
op|'.'
name|'received'
op|')'
op|','
name|'bytes'
op|')'
newline|'\n'
dedent|''
name|'connectionDeferred'
op|'.'
name|'addCallback'
op|'('
name|'cbConnectionDone'
op|')'
newline|'\n'
name|'return'
name|'connectionDeferred'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_writeSequence
dedent|''
name|'def'
name|'test_writeSequence'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Bytes written to L{TLSMemoryBIOProtocol} with C{writeSequence} are\n        received by the protocol on the other side of the connection.\n        """'
newline|'\n'
name|'bytes'
op|'='
string|'"some bytes"'
newline|'\n'
DECL|class|SimpleSendingProtocol
name|'class'
name|'SimpleSendingProtocol'
op|'('
name|'Protocol'
op|')'
op|':'
newline|'\n'
DECL|member|connectionMade
indent|'            '
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'writeSequence'
op|'('
name|'list'
op|'('
name|'bytes'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'clientFactory'
op|'='
name|'ClientFactory'
op|'('
op|')'
newline|'\n'
name|'clientFactory'
op|'.'
name|'protocol'
op|'='
name|'SimpleSendingProtocol'
newline|'\n'
nl|'\n'
name|'clientContextFactory'
op|'='
name|'HandshakeCallbackContextFactory'
op|'('
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
nl|'\n'
name|'clientContextFactory'
op|','
name|'True'
op|','
name|'clientFactory'
op|')'
newline|'\n'
name|'sslClientProtocol'
op|'='
name|'wrapperFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'serverProtocol'
op|'='
name|'AccumulatingProtocol'
op|'('
name|'len'
op|'('
name|'bytes'
op|')'
op|')'
newline|'\n'
name|'serverFactory'
op|'='
name|'ServerFactory'
op|'('
op|')'
newline|'\n'
name|'serverFactory'
op|'.'
name|'protocol'
op|'='
name|'lambda'
op|':'
name|'serverProtocol'
newline|'\n'
nl|'\n'
name|'serverContextFactory'
op|'='
name|'DefaultOpenSSLContextFactory'
op|'('
name|'certPath'
op|','
name|'certPath'
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
nl|'\n'
name|'serverContextFactory'
op|','
name|'False'
op|','
name|'serverFactory'
op|')'
newline|'\n'
name|'sslServerProtocol'
op|'='
name|'wrapperFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'connectionDeferred'
op|'='
name|'loopbackAsync'
op|'('
name|'sslServerProtocol'
op|','
name|'sslClientProtocol'
op|')'
newline|'\n'
nl|'\n'
comment|'# Wait for the connection to end, then make sure the server received'
nl|'\n'
comment|'# the bytes sent by the client.'
nl|'\n'
DECL|function|cbConnectionDone
name|'def'
name|'cbConnectionDone'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
string|'""'
op|'.'
name|'join'
op|'('
name|'serverProtocol'
op|'.'
name|'received'
op|')'
op|','
name|'bytes'
op|')'
newline|'\n'
dedent|''
name|'connectionDeferred'
op|'.'
name|'addCallback'
op|'('
name|'cbConnectionDone'
op|')'
newline|'\n'
name|'return'
name|'connectionDeferred'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_multipleWrites
dedent|''
name|'def'
name|'test_multipleWrites'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If multiple separate TLS messages are received in a single chunk from\n        the underlying transport, all of the application bytes from each\n        message are delivered to the application-level protocol.\n        """'
newline|'\n'
name|'bytes'
op|'='
op|'['
name|'str'
op|'('
name|'i'
op|')'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
number|'10'
op|')'
op|']'
newline|'\n'
DECL|class|SimpleSendingProtocol
name|'class'
name|'SimpleSendingProtocol'
op|'('
name|'Protocol'
op|')'
op|':'
newline|'\n'
DECL|member|connectionMade
indent|'            '
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'b'
name|'in'
name|'bytes'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
name|'b'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'clientFactory'
op|'='
name|'ClientFactory'
op|'('
op|')'
newline|'\n'
name|'clientFactory'
op|'.'
name|'protocol'
op|'='
name|'SimpleSendingProtocol'
newline|'\n'
nl|'\n'
name|'clientContextFactory'
op|'='
name|'HandshakeCallbackContextFactory'
op|'('
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
nl|'\n'
name|'clientContextFactory'
op|','
name|'True'
op|','
name|'clientFactory'
op|')'
newline|'\n'
name|'sslClientProtocol'
op|'='
name|'wrapperFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'serverProtocol'
op|'='
name|'AccumulatingProtocol'
op|'('
name|'sum'
op|'('
name|'map'
op|'('
name|'len'
op|','
name|'bytes'
op|')'
op|')'
op|')'
newline|'\n'
name|'serverFactory'
op|'='
name|'ServerFactory'
op|'('
op|')'
newline|'\n'
name|'serverFactory'
op|'.'
name|'protocol'
op|'='
name|'lambda'
op|':'
name|'serverProtocol'
newline|'\n'
nl|'\n'
name|'serverContextFactory'
op|'='
name|'DefaultOpenSSLContextFactory'
op|'('
name|'certPath'
op|','
name|'certPath'
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
nl|'\n'
name|'serverContextFactory'
op|','
name|'False'
op|','
name|'serverFactory'
op|')'
newline|'\n'
name|'sslServerProtocol'
op|'='
name|'wrapperFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'connectionDeferred'
op|'='
name|'loopbackAsync'
op|'('
name|'sslServerProtocol'
op|','
name|'sslClientProtocol'
op|','
name|'collapsingPumpPolicy'
op|')'
newline|'\n'
nl|'\n'
comment|'# Wait for the connection to end, then make sure the server received'
nl|'\n'
comment|'# the bytes sent by the client.'
nl|'\n'
DECL|function|cbConnectionDone
name|'def'
name|'cbConnectionDone'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
string|'""'
op|'.'
name|'join'
op|'('
name|'serverProtocol'
op|'.'
name|'received'
op|')'
op|','
string|"''"
op|'.'
name|'join'
op|'('
name|'bytes'
op|')'
op|')'
newline|'\n'
dedent|''
name|'connectionDeferred'
op|'.'
name|'addCallback'
op|'('
name|'cbConnectionDone'
op|')'
newline|'\n'
name|'return'
name|'connectionDeferred'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_hugeWrite
dedent|''
name|'def'
name|'test_hugeWrite'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a very long string is passed to L{TLSMemoryBIOProtocol.write}, any\n        trailing part of it which cannot be send immediately is buffered and\n        sent later.\n        """'
newline|'\n'
name|'bytes'
op|'='
string|'"some bytes"'
newline|'\n'
name|'factor'
op|'='
number|'8192'
newline|'\n'
DECL|class|SimpleSendingProtocol
name|'class'
name|'SimpleSendingProtocol'
op|'('
name|'Protocol'
op|')'
op|':'
newline|'\n'
DECL|member|connectionMade
indent|'            '
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
name|'bytes'
op|'*'
name|'factor'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'clientFactory'
op|'='
name|'ClientFactory'
op|'('
op|')'
newline|'\n'
name|'clientFactory'
op|'.'
name|'protocol'
op|'='
name|'SimpleSendingProtocol'
newline|'\n'
nl|'\n'
name|'clientContextFactory'
op|'='
name|'HandshakeCallbackContextFactory'
op|'('
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
nl|'\n'
name|'clientContextFactory'
op|','
name|'True'
op|','
name|'clientFactory'
op|')'
newline|'\n'
name|'sslClientProtocol'
op|'='
name|'wrapperFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'serverProtocol'
op|'='
name|'AccumulatingProtocol'
op|'('
name|'len'
op|'('
name|'bytes'
op|')'
op|'*'
name|'factor'
op|')'
newline|'\n'
name|'serverFactory'
op|'='
name|'ServerFactory'
op|'('
op|')'
newline|'\n'
name|'serverFactory'
op|'.'
name|'protocol'
op|'='
name|'lambda'
op|':'
name|'serverProtocol'
newline|'\n'
nl|'\n'
name|'serverContextFactory'
op|'='
name|'DefaultOpenSSLContextFactory'
op|'('
name|'certPath'
op|','
name|'certPath'
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
nl|'\n'
name|'serverContextFactory'
op|','
name|'False'
op|','
name|'serverFactory'
op|')'
newline|'\n'
name|'sslServerProtocol'
op|'='
name|'wrapperFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'connectionDeferred'
op|'='
name|'loopbackAsync'
op|'('
name|'sslServerProtocol'
op|','
name|'sslClientProtocol'
op|')'
newline|'\n'
nl|'\n'
comment|'# Wait for the connection to end, then make sure the server received'
nl|'\n'
comment|'# the bytes sent by the client.'
nl|'\n'
DECL|function|cbConnectionDone
name|'def'
name|'cbConnectionDone'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
string|'""'
op|'.'
name|'join'
op|'('
name|'serverProtocol'
op|'.'
name|'received'
op|')'
op|','
name|'bytes'
op|'*'
name|'factor'
op|')'
newline|'\n'
dedent|''
name|'connectionDeferred'
op|'.'
name|'addCallback'
op|'('
name|'cbConnectionDone'
op|')'
newline|'\n'
name|'return'
name|'connectionDeferred'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_disorderlyShutdown
dedent|''
name|'def'
name|'test_disorderlyShutdown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a L{TLSMemoryBIOProtocol} loses its connection unexpectedly, this is\n        reported to the application.\n        """'
newline|'\n'
name|'clientConnectionLost'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'clientFactory'
op|'='
name|'ClientFactory'
op|'('
op|')'
newline|'\n'
name|'clientFactory'
op|'.'
name|'protocol'
op|'='
op|'('
nl|'\n'
name|'lambda'
op|':'
name|'ConnectionLostNotifyingProtocol'
op|'('
nl|'\n'
name|'clientConnectionLost'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'clientContextFactory'
op|'='
name|'HandshakeCallbackContextFactory'
op|'('
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
nl|'\n'
name|'clientContextFactory'
op|','
name|'True'
op|','
name|'clientFactory'
op|')'
newline|'\n'
name|'sslClientProtocol'
op|'='
name|'wrapperFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
comment|'# Client speaks first, so the server can be dumb.'
nl|'\n'
name|'serverProtocol'
op|'='
name|'Protocol'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'connectionDeferred'
op|'='
name|'loopbackAsync'
op|'('
name|'serverProtocol'
op|','
name|'sslClientProtocol'
op|')'
newline|'\n'
nl|'\n'
comment|'# Now destroy the connection.'
nl|'\n'
name|'serverProtocol'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# And when the connection completely dies, check the reason.'
nl|'\n'
DECL|function|cbDisconnected
name|'def'
name|'cbDisconnected'
op|'('
name|'clientProtocol'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'clientProtocol'
op|'.'
name|'lostConnectionReason'
op|'.'
name|'trap'
op|'('
name|'Error'
op|')'
newline|'\n'
dedent|''
name|'clientConnectionLost'
op|'.'
name|'addCallback'
op|'('
name|'cbDisconnected'
op|')'
newline|'\n'
name|'return'
name|'clientConnectionLost'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_loseConnectionAfterHandshake
dedent|''
name|'def'
name|'test_loseConnectionAfterHandshake'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{TLSMemoryBIOProtocol.loseConnection} sends a TLS close alert and\n        shuts down the underlying connection.\n        """'
newline|'\n'
name|'clientConnectionLost'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'clientFactory'
op|'='
name|'ClientFactory'
op|'('
op|')'
newline|'\n'
name|'clientFactory'
op|'.'
name|'protocol'
op|'='
op|'('
nl|'\n'
name|'lambda'
op|':'
name|'ConnectionLostNotifyingProtocol'
op|'('
nl|'\n'
name|'clientConnectionLost'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'clientContextFactory'
op|','
name|'handshakeDeferred'
op|'='
op|'('
nl|'\n'
name|'HandshakeCallbackContextFactory'
op|'.'
name|'factoryAndDeferred'
op|'('
op|')'
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
nl|'\n'
name|'clientContextFactory'
op|','
name|'True'
op|','
name|'clientFactory'
op|')'
newline|'\n'
name|'sslClientProtocol'
op|'='
name|'wrapperFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'serverProtocol'
op|'='
name|'Protocol'
op|'('
op|')'
newline|'\n'
name|'serverFactory'
op|'='
name|'ServerFactory'
op|'('
op|')'
newline|'\n'
name|'serverFactory'
op|'.'
name|'protocol'
op|'='
name|'lambda'
op|':'
name|'serverProtocol'
newline|'\n'
nl|'\n'
name|'serverContextFactory'
op|'='
name|'DefaultOpenSSLContextFactory'
op|'('
name|'certPath'
op|','
name|'certPath'
op|')'
newline|'\n'
name|'wrapperFactory'
op|'='
name|'TLSMemoryBIOFactory'
op|'('
nl|'\n'
name|'serverContextFactory'
op|','
name|'False'
op|','
name|'serverFactory'
op|')'
newline|'\n'
name|'sslServerProtocol'
op|'='
name|'wrapperFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'connectionDeferred'
op|'='
name|'loopbackAsync'
op|'('
name|'sslServerProtocol'
op|','
name|'sslClientProtocol'
op|')'
newline|'\n'
nl|'\n'
comment|'# Wait for the handshake before dropping the connection.'
nl|'\n'
DECL|function|cbHandshake
name|'def'
name|'cbHandshake'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'serverProtocol'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Now wait for the client to notice.'
nl|'\n'
name|'return'
name|'clientConnectionLost'
newline|'\n'
dedent|''
name|'handshakeDeferred'
op|'.'
name|'addCallback'
op|'('
name|'cbHandshake'
op|')'
newline|'\n'
nl|'\n'
comment|'# Wait for the connection to end, then make sure the client was'
nl|'\n'
comment|'# notified of a handshake failure.'
nl|'\n'
DECL|function|cbConnectionDone
name|'def'
name|'cbConnectionDone'
op|'('
name|'clientProtocol'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'clientProtocol'
op|'.'
name|'lostConnectionReason'
op|'.'
name|'trap'
op|'('
name|'ConnectionDone'
op|')'
newline|'\n'
nl|'\n'
comment|'# The server should have closed its underlying transport, in'
nl|'\n'
comment|'# addition to whatever it did to shut down the TLS layer.'
nl|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'serverProtocol'
op|'.'
name|'transport'
op|'.'
name|'q'
op|'.'
name|'disconnect'
op|')'
newline|'\n'
nl|'\n'
comment|'# The client should also have closed its underlying transport once'
nl|'\n'
comment|'# it saw the server shut down the TLS layer, so as to avoid relying'
nl|'\n'
comment|'# on the server to close the underlying connection.'
nl|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'clientProtocol'
op|'.'
name|'transport'
op|'.'
name|'q'
op|'.'
name|'disconnect'
op|')'
newline|'\n'
dedent|''
name|'handshakeDeferred'
op|'.'
name|'addCallback'
op|'('
name|'cbConnectionDone'
op|')'
newline|'\n'
name|'return'
name|'handshakeDeferred'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
