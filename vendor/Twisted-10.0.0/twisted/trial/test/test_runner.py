begin_unit
comment|'# Copyright (c) 2005-2010 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Maintainer: Jonathan Lange'
nl|'\n'
comment|'# Author: Robert Collins'
nl|'\n'
nl|'\n'
nl|'\n'
name|'import'
name|'StringIO'
op|','
name|'os'
op|','
name|'sys'
newline|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'implements'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
op|'.'
name|'itrial'
name|'import'
name|'IReporter'
op|','
name|'ITestCase'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
op|','
name|'runner'
op|','
name|'reporter'
op|','
name|'util'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'failure'
op|','
name|'log'
op|','
name|'reflect'
op|','
name|'filepath'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'scripts'
name|'import'
name|'trial'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'plugins'
name|'import'
name|'twisted_trial'
newline|'\n'
name|'from'
name|'twisted'
name|'import'
name|'plugin'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'defer'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|pyunit
name|'pyunit'
op|'='
name|'__import__'
op|'('
string|"'unittest'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|CapturingDebugger
name|'class'
name|'CapturingDebugger'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_calls'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|runcall
dedent|''
name|'def'
name|'runcall'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_calls'
op|'.'
name|'append'
op|'('
string|"'runcall'"
op|')'
newline|'\n'
name|'args'
op|'['
number|'0'
op|']'
op|'('
op|'*'
name|'args'
op|'['
number|'1'
op|':'
op|']'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|CapturingReporter
dedent|''
dedent|''
name|'class'
name|'CapturingReporter'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Reporter that keeps a log of all actions performed on it.\n    """'
newline|'\n'
nl|'\n'
name|'implements'
op|'('
name|'IReporter'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|stream
name|'stream'
op|'='
name|'None'
newline|'\n'
DECL|variable|tbformat
name|'tbformat'
op|'='
name|'None'
newline|'\n'
DECL|variable|args
name|'args'
op|'='
name|'None'
newline|'\n'
DECL|variable|separator
name|'separator'
op|'='
name|'None'
newline|'\n'
DECL|variable|testsRun
name|'testsRun'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'stream'
op|'='
name|'None'
op|','
name|'tbformat'
op|'='
name|'None'
op|','
name|'rterrors'
op|'='
name|'None'
op|','
nl|'\n'
name|'publisher'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a capturing reporter.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_calls'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'shouldStop'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_stream'
op|'='
name|'stream'
newline|'\n'
name|'self'
op|'.'
name|'_tbformat'
op|'='
name|'tbformat'
newline|'\n'
name|'self'
op|'.'
name|'_rterrors'
op|'='
name|'rterrors'
newline|'\n'
name|'self'
op|'.'
name|'_publisher'
op|'='
name|'publisher'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|startTest
dedent|''
name|'def'
name|'startTest'
op|'('
name|'self'
op|','
name|'method'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Report the beginning of a run of a single test method\n        @param method: an object that is adaptable to ITestMethod\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_calls'
op|'.'
name|'append'
op|'('
string|"'startTest'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|stopTest
dedent|''
name|'def'
name|'stopTest'
op|'('
name|'self'
op|','
name|'method'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Report the status of a single test method\n        @param method: an object that is adaptable to ITestMethod\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_calls'
op|'.'
name|'append'
op|'('
string|"'stopTest'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|cleanupErrors
dedent|''
name|'def'
name|'cleanupErrors'
op|'('
name|'self'
op|','
name|'errs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""called when the reactor has been left in a \'dirty\' state\n        @param errs: a list of L{twisted.python.failure.Failure}s\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_calls'
op|'.'
name|'append'
op|'('
string|"'cleanupError'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|addSuccess
dedent|''
name|'def'
name|'addSuccess'
op|'('
name|'self'
op|','
name|'test'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_calls'
op|'.'
name|'append'
op|'('
string|"'addSuccess'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|done
dedent|''
name|'def'
name|'done'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Do nothing. These tests don\'t care about done.\n        """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TrialRunnerTestsMixin
dedent|''
dedent|''
name|'class'
name|'TrialRunnerTestsMixin'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Mixin defining tests for L{runner.TrialRunner}.\n    """'
newline|'\n'
DECL|member|tearDown
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'runner'
op|'.'
name|'_tearDownLogFile'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_empty
dedent|''
name|'def'
name|'test_empty'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Empty test method, used by the other tests.\n        """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_getObservers
dedent|''
name|'def'
name|'_getObservers'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'log'
op|'.'
name|'theLogPublisher'
op|'.'
name|'observers'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_addObservers
dedent|''
name|'def'
name|'test_addObservers'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Any log system observers L{TrialRunner.run} adds are removed by the\n        time it returns.\n        """'
newline|'\n'
name|'originalCount'
op|'='
name|'len'
op|'('
name|'self'
op|'.'
name|'_getObservers'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'runner'
op|'.'
name|'run'
op|'('
name|'self'
op|'.'
name|'test'
op|')'
newline|'\n'
name|'newCount'
op|'='
name|'len'
op|'('
name|'self'
op|'.'
name|'_getObservers'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'newCount'
op|','
name|'originalCount'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_logFileAlwaysActive
dedent|''
name|'def'
name|'test_logFileAlwaysActive'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that a new file is opened on each run.\n        """'
newline|'\n'
name|'oldSetUpLogFile'
op|'='
name|'self'
op|'.'
name|'runner'
op|'.'
name|'_setUpLogFile'
newline|'\n'
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|setUpLogFile
name|'def'
name|'setUpLogFile'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'oldSetUpLogFile'
op|'('
op|')'
newline|'\n'
name|'l'
op|'.'
name|'append'
op|'('
name|'self'
op|'.'
name|'runner'
op|'.'
name|'_logFileObserver'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'runner'
op|'.'
name|'_setUpLogFile'
op|'='
name|'setUpLogFile'
newline|'\n'
name|'self'
op|'.'
name|'runner'
op|'.'
name|'run'
op|'('
name|'self'
op|'.'
name|'test'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'runner'
op|'.'
name|'run'
op|'('
name|'self'
op|'.'
name|'test'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'len'
op|'('
name|'l'
op|')'
op|','
number|'2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'l'
op|'['
number|'0'
op|']'
name|'is'
name|'l'
op|'['
number|'1'
op|']'
op|','
string|'"Should have created a new file observer"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_logFileGetsClosed
dedent|''
name|'def'
name|'test_logFileGetsClosed'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that file created is closed during the run.\n        """'
newline|'\n'
name|'oldSetUpLogFile'
op|'='
name|'self'
op|'.'
name|'runner'
op|'.'
name|'_setUpLogFile'
newline|'\n'
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|setUpLogFile
name|'def'
name|'setUpLogFile'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'oldSetUpLogFile'
op|'('
op|')'
newline|'\n'
name|'l'
op|'.'
name|'append'
op|'('
name|'self'
op|'.'
name|'runner'
op|'.'
name|'_logFileObject'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'runner'
op|'.'
name|'_setUpLogFile'
op|'='
name|'setUpLogFile'
newline|'\n'
name|'self'
op|'.'
name|'runner'
op|'.'
name|'run'
op|'('
name|'self'
op|'.'
name|'test'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'len'
op|'('
name|'l'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'l'
op|'['
number|'0'
op|']'
op|'.'
name|'closed'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestTrialRunner
dedent|''
dedent|''
name|'class'
name|'TestTrialRunner'
op|'('
name|'TrialRunnerTestsMixin'
op|','
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{runner.TrialRunner} with the feature to turn unclean errors\n    into warnings disabled.\n    """'
newline|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'stream'
op|'='
name|'StringIO'
op|'.'
name|'StringIO'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'runner'
op|'='
name|'runner'
op|'.'
name|'TrialRunner'
op|'('
name|'CapturingReporter'
op|','
name|'stream'
op|'='
name|'self'
op|'.'
name|'stream'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'test'
op|'='
name|'TestTrialRunner'
op|'('
string|"'test_empty'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_publisher
dedent|''
name|'def'
name|'test_publisher'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The reporter constructed by L{runner.TrialRunner} is passed\n        L{twisted.python.log} as the value for the C{publisher} parameter.\n        """'
newline|'\n'
name|'result'
op|'='
name|'self'
op|'.'
name|'runner'
op|'.'
name|'_makeResult'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'result'
op|'.'
name|'_publisher'
op|','
name|'log'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'class'
name|'TrialRunnerWithUncleanWarningsReporter'
op|'('
name|'TrialRunnerTestsMixin'
op|','
nl|'\n'
DECL|class|TrialRunnerWithUncleanWarningsReporter
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for the TrialRunner\'s interaction with an unclean-error suppressing\n    reporter.\n    """'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'stream'
op|'='
name|'StringIO'
op|'.'
name|'StringIO'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'runner'
op|'='
name|'runner'
op|'.'
name|'TrialRunner'
op|'('
name|'CapturingReporter'
op|','
name|'stream'
op|'='
name|'self'
op|'.'
name|'stream'
op|','
nl|'\n'
name|'uncleanWarnings'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'test'
op|'='
name|'TestTrialRunner'
op|'('
string|"'test_empty'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DryRunMixin
dedent|''
dedent|''
name|'class'
name|'DryRunMixin'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|suppress
indent|'    '
name|'suppress'
op|'='
op|'['
name|'util'
op|'.'
name|'suppress'
op|'('
nl|'\n'
DECL|variable|category
name|'category'
op|'='
name|'DeprecationWarning'
op|','
nl|'\n'
DECL|variable|message
name|'message'
op|'='
string|'"Test visitors deprecated in Twisted 8.0"'
op|')'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'log'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'stream'
op|'='
name|'StringIO'
op|'.'
name|'StringIO'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'runner'
op|'='
name|'runner'
op|'.'
name|'TrialRunner'
op|'('
name|'CapturingReporter'
op|','
nl|'\n'
name|'runner'
op|'.'
name|'TrialRunner'
op|'.'
name|'DRY_RUN'
op|','
nl|'\n'
name|'stream'
op|'='
name|'self'
op|'.'
name|'stream'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'makeTestFixtures'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|makeTestFixtures
dedent|''
name|'def'
name|'makeTestFixtures'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Set C{self.test} and C{self.suite}, where C{self.suite} is an empty\n        TestSuite.\n        """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_empty
dedent|''
name|'def'
name|'test_empty'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If there are no tests, the reporter should not receive any events to\n        report.\n        """'
newline|'\n'
name|'result'
op|'='
name|'self'
op|'.'
name|'runner'
op|'.'
name|'run'
op|'('
name|'runner'
op|'.'
name|'TestSuite'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'result'
op|'.'
name|'_calls'
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_singleCaseReporting
dedent|''
name|'def'
name|'test_singleCaseReporting'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If we are running a single test, check the reporter starts, passes and\n        then stops the test during a dry run.\n        """'
newline|'\n'
name|'result'
op|'='
name|'self'
op|'.'
name|'runner'
op|'.'
name|'run'
op|'('
name|'self'
op|'.'
name|'test'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'result'
op|'.'
name|'_calls'
op|','
op|'['
string|"'startTest'"
op|','
string|"'addSuccess'"
op|','
string|"'stopTest'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_testsNotRun
dedent|''
name|'def'
name|'test_testsNotRun'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When we are doing a dry run, the tests should not actually be run.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'runner'
op|'.'
name|'run'
op|'('
name|'self'
op|'.'
name|'test'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'log'
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DryRunTest
dedent|''
dedent|''
name|'class'
name|'DryRunTest'
op|'('
name|'DryRunMixin'
op|','
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Check that \'dry run\' mode works well with Trial tests.\n    """'
newline|'\n'
DECL|member|makeTestFixtures
name|'def'
name|'makeTestFixtures'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
DECL|class|MockTest
indent|'        '
name|'class'
name|'MockTest'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|test_foo
indent|'            '
name|'def'
name|'test_foo'
op|'('
name|'test'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'log'
op|'.'
name|'append'
op|'('
string|"'test_foo'"
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'test'
op|'='
name|'MockTest'
op|'('
string|"'test_foo'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'suite'
op|'='
name|'runner'
op|'.'
name|'TestSuite'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|PyUnitDryRunTest
dedent|''
dedent|''
name|'class'
name|'PyUnitDryRunTest'
op|'('
name|'DryRunMixin'
op|','
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Check that \'dry run\' mode works well with stdlib unittest tests.\n    """'
newline|'\n'
DECL|member|makeTestFixtures
name|'def'
name|'makeTestFixtures'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
DECL|class|PyunitCase
indent|'        '
name|'class'
name|'PyunitCase'
op|'('
name|'pyunit'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|test_foo
indent|'            '
name|'def'
name|'test_foo'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'test'
op|'='
name|'PyunitCase'
op|'('
string|"'test_foo'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'suite'
op|'='
name|'pyunit'
op|'.'
name|'TestSuite'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestRunner
dedent|''
dedent|''
name|'class'
name|'TestRunner'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|setUp
indent|'    '
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'config'
op|'='
name|'trial'
op|'.'
name|'Options'
op|'('
op|')'
newline|'\n'
comment|'# whitebox hack a reporter in, because plugins are CACHED and will'
nl|'\n'
comment|'# only reload if the FILE gets changed.'
nl|'\n'
nl|'\n'
name|'parts'
op|'='
name|'reflect'
op|'.'
name|'qual'
op|'('
name|'CapturingReporter'
op|')'
op|'.'
name|'split'
op|'('
string|"'.'"
op|')'
newline|'\n'
name|'package'
op|'='
string|"'.'"
op|'.'
name|'join'
op|'('
name|'parts'
op|'['
op|':'
op|'-'
number|'1'
op|']'
op|')'
newline|'\n'
name|'klass'
op|'='
name|'parts'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
name|'plugins'
op|'='
op|'['
name|'twisted_trial'
op|'.'
name|'_Reporter'
op|'('
nl|'\n'
string|'"Test Helper Reporter"'
op|','
nl|'\n'
name|'package'
op|','
nl|'\n'
name|'description'
op|'='
string|'"Utility for unit testing."'
op|','
nl|'\n'
name|'longOpt'
op|'='
string|'"capturing"'
op|','
nl|'\n'
name|'shortOpt'
op|'='
name|'None'
op|','
nl|'\n'
name|'klass'
op|'='
name|'klass'
op|')'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# XXX There should really be a general way to hook the plugin system'
nl|'\n'
comment|'# for tests.'
nl|'\n'
DECL|function|getPlugins
name|'def'
name|'getPlugins'
op|'('
name|'iface'
op|','
op|'*'
name|'a'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'iface'
op|','
name|'IReporter'
op|')'
newline|'\n'
name|'return'
name|'plugins'
op|'+'
name|'list'
op|'('
name|'self'
op|'.'
name|'original'
op|'('
name|'iface'
op|','
op|'*'
name|'a'
op|','
op|'**'
name|'kw'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'original'
op|'='
name|'plugin'
op|'.'
name|'getPlugins'
newline|'\n'
name|'plugin'
op|'.'
name|'getPlugins'
op|'='
name|'getPlugins'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'standardReport'
op|'='
op|'['
string|"'startTest'"
op|','
string|"'addSuccess'"
op|','
string|"'stopTest'"
op|','
nl|'\n'
string|"'startTest'"
op|','
string|"'addSuccess'"
op|','
string|"'stopTest'"
op|','
nl|'\n'
string|"'startTest'"
op|','
string|"'addSuccess'"
op|','
string|"'stopTest'"
op|','
nl|'\n'
string|"'startTest'"
op|','
string|"'addSuccess'"
op|','
string|"'stopTest'"
op|','
nl|'\n'
string|"'startTest'"
op|','
string|"'addSuccess'"
op|','
string|"'stopTest'"
op|','
nl|'\n'
string|"'startTest'"
op|','
string|"'addSuccess'"
op|','
string|"'stopTest'"
op|','
nl|'\n'
string|"'startTest'"
op|','
string|"'addSuccess'"
op|','
string|"'stopTest'"
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tearDown
dedent|''
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'plugin'
op|'.'
name|'getPlugins'
op|'='
name|'self'
op|'.'
name|'original'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|parseOptions
dedent|''
name|'def'
name|'parseOptions'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'config'
op|'.'
name|'parseOptions'
op|'('
name|'args'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getRunner
dedent|''
name|'def'
name|'getRunner'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'r'
op|'='
name|'trial'
op|'.'
name|'_makeRunner'
op|'('
name|'self'
op|'.'
name|'config'
op|')'
newline|'\n'
name|'r'
op|'.'
name|'stream'
op|'='
name|'StringIO'
op|'.'
name|'StringIO'
op|'('
op|')'
newline|'\n'
comment|'# XXX The runner should always take care of cleaning this up itself.'
nl|'\n'
comment|"# It's not clear why this is necessary.  The runner always tears down"
nl|'\n'
comment|'# its log file.'
nl|'\n'
name|'self'
op|'.'
name|'addCleanup'
op|'('
name|'r'
op|'.'
name|'_tearDownLogFile'
op|')'
newline|'\n'
comment|'# XXX The runner should always take care of cleaning this up itself as'
nl|'\n'
comment|"# well.  It's necessary because TrialRunner._setUpTestdir might raise"
nl|'\n'
comment|'# an exception preventing Reporter.done from being run, leaving the'
nl|'\n'
comment|'# observer added by Reporter.__init__ still present in the system.'
nl|'\n'
comment|'# Something better needs to happen inside'
nl|'\n'
comment|'# TrialRunner._runWithoutDecoration to remove the need for this cludge.'
nl|'\n'
name|'r'
op|'.'
name|'_log'
op|'='
name|'log'
op|'.'
name|'LogPublisher'
op|'('
op|')'
newline|'\n'
name|'return'
name|'r'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_runner_can_get_reporter
dedent|''
name|'def'
name|'test_runner_can_get_reporter'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'parseOptions'
op|'('
op|'['
op|']'
op|')'
newline|'\n'
name|'result'
op|'='
name|'self'
op|'.'
name|'config'
op|'['
string|"'reporter'"
op|']'
newline|'\n'
name|'runner'
op|'='
name|'self'
op|'.'
name|'getRunner'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'result'
op|','
name|'runner'
op|'.'
name|'_makeResult'
op|'('
op|')'
op|'.'
name|'__class__'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_runner_get_result
dedent|''
name|'def'
name|'test_runner_get_result'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'parseOptions'
op|'('
op|'['
op|']'
op|')'
newline|'\n'
name|'runner'
op|'='
name|'self'
op|'.'
name|'getRunner'
op|'('
op|')'
newline|'\n'
name|'result'
op|'='
name|'runner'
op|'.'
name|'_makeResult'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'result'
op|'.'
name|'__class__'
op|','
name|'self'
op|'.'
name|'config'
op|'['
string|"'reporter'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_uncleanWarningsOffByDefault
dedent|''
name|'def'
name|'test_uncleanWarningsOffByDefault'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        By default Trial sets the \'uncleanWarnings\' option on the runner to\n        False. This means that dirty reactor errors will be reported as\n        errors. See L{test_reporter.TestDirtyReactor}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'parseOptions'
op|'('
op|'['
op|']'
op|')'
newline|'\n'
name|'runner'
op|'='
name|'self'
op|'.'
name|'getRunner'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertNotIsInstance'
op|'('
name|'runner'
op|'.'
name|'_makeResult'
op|'('
op|')'
op|','
nl|'\n'
name|'reporter'
op|'.'
name|'UncleanWarningsReporterWrapper'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getsUncleanWarnings
dedent|''
name|'def'
name|'test_getsUncleanWarnings'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Specifying \'--unclean-warnings\' on the trial command line will cause\n        reporters to be wrapped in a device which converts unclean errors to\n        warnings.  See L{test_reporter.TestDirtyReactor} for implications.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'parseOptions'
op|'('
op|'['
string|"'--unclean-warnings'"
op|']'
op|')'
newline|'\n'
name|'runner'
op|'='
name|'self'
op|'.'
name|'getRunner'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'runner'
op|'.'
name|'_makeResult'
op|'('
op|')'
op|','
nl|'\n'
name|'reporter'
op|'.'
name|'UncleanWarningsReporterWrapper'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_runner_working_directory
dedent|''
name|'def'
name|'test_runner_working_directory'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'parseOptions'
op|'('
op|'['
string|"'--temp-directory'"
op|','
string|"'some_path'"
op|']'
op|')'
newline|'\n'
name|'runner'
op|'='
name|'self'
op|'.'
name|'getRunner'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'runner'
op|'.'
name|'workingDirectory'
op|','
string|"'some_path'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_concurrentImplicitWorkingDirectory
dedent|''
name|'def'
name|'test_concurrentImplicitWorkingDirectory'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If no working directory is explicitly specified and the default\n        working directory is in use by another runner, L{TrialRunner.run}\n        selects a different default working directory to use.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'parseOptions'
op|'('
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'initialDirectory'
op|'='
name|'os'
op|'.'
name|'getcwd'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addCleanup'
op|'('
name|'os'
op|'.'
name|'chdir'
op|','
name|'initialDirectory'
op|')'
newline|'\n'
nl|'\n'
name|'firstRunner'
op|'='
name|'self'
op|'.'
name|'getRunner'
op|'('
op|')'
newline|'\n'
name|'secondRunner'
op|'='
name|'self'
op|'.'
name|'getRunner'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'where'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
DECL|class|ConcurrentCase
name|'class'
name|'ConcurrentCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|test_first
indent|'            '
name|'def'
name|'test_first'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
string|'"""\n                Start a second test run which will have a default working\n                directory which is the same as the working directory of the\n                test run already in progress.\n                """'
newline|'\n'
comment|'# Change the working directory to the value it had before this'
nl|'\n'
comment|'# test suite was started.'
nl|'\n'
name|'where'
op|'['
string|"'concurrent'"
op|']'
op|'='
name|'subsequentDirectory'
op|'='
name|'os'
op|'.'
name|'getcwd'
op|'('
op|')'
newline|'\n'
name|'os'
op|'.'
name|'chdir'
op|'('
name|'initialDirectory'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addCleanup'
op|'('
name|'os'
op|'.'
name|'chdir'
op|','
name|'subsequentDirectory'
op|')'
newline|'\n'
nl|'\n'
name|'secondRunner'
op|'.'
name|'run'
op|'('
name|'ConcurrentCase'
op|'('
string|"'test_second'"
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_second
dedent|''
name|'def'
name|'test_second'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
string|'"""\n                Record the working directory for later analysis.\n                """'
newline|'\n'
name|'where'
op|'['
string|"'record'"
op|']'
op|'='
name|'os'
op|'.'
name|'getcwd'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'result'
op|'='
name|'firstRunner'
op|'.'
name|'run'
op|'('
name|'ConcurrentCase'
op|'('
string|"'test_first'"
op|')'
op|')'
newline|'\n'
name|'bad'
op|'='
name|'result'
op|'.'
name|'errors'
op|'+'
name|'result'
op|'.'
name|'failures'
newline|'\n'
name|'if'
name|'bad'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'fail'
op|'('
name|'bad'
op|'['
number|'0'
op|']'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'where'
op|','
op|'{'
nl|'\n'
string|"'concurrent'"
op|':'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'initialDirectory'
op|','
string|"'_trial_temp'"
op|')'
op|','
nl|'\n'
string|"'record'"
op|':'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'initialDirectory'
op|','
string|"'_trial_temp-1'"
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_concurrentExplicitWorkingDirectory
dedent|''
name|'def'
name|'test_concurrentExplicitWorkingDirectory'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a working directory which is already in use is explicitly specified,\n        L{TrialRunner.run} raises L{_WorkingDirectoryBusy}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'parseOptions'
op|'('
op|'['
string|"'--temp-directory'"
op|','
name|'os'
op|'.'
name|'path'
op|'.'
name|'abspath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'initialDirectory'
op|'='
name|'os'
op|'.'
name|'getcwd'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addCleanup'
op|'('
name|'os'
op|'.'
name|'chdir'
op|','
name|'initialDirectory'
op|')'
newline|'\n'
nl|'\n'
name|'firstRunner'
op|'='
name|'self'
op|'.'
name|'getRunner'
op|'('
op|')'
newline|'\n'
name|'secondRunner'
op|'='
name|'self'
op|'.'
name|'getRunner'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|class|ConcurrentCase
name|'class'
name|'ConcurrentCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|test_concurrent
indent|'            '
name|'def'
name|'test_concurrent'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
string|'"""\n                Try to start another runner in the same working directory and\n                assert that it raises L{_WorkingDirectoryBusy}.\n                """'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
nl|'\n'
name|'runner'
op|'.'
name|'_WorkingDirectoryBusy'
op|','
nl|'\n'
name|'secondRunner'
op|'.'
name|'run'
op|','
name|'ConcurrentCase'
op|'('
string|"'test_failure'"
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_failure
dedent|''
name|'def'
name|'test_failure'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
string|'"""\n                Should not be called, always fails.\n                """'
newline|'\n'
name|'self'
op|'.'
name|'fail'
op|'('
string|'"test_failure should never be called."'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'result'
op|'='
name|'firstRunner'
op|'.'
name|'run'
op|'('
name|'ConcurrentCase'
op|'('
string|"'test_concurrent'"
op|')'
op|')'
newline|'\n'
name|'bad'
op|'='
name|'result'
op|'.'
name|'errors'
op|'+'
name|'result'
op|'.'
name|'failures'
newline|'\n'
name|'if'
name|'bad'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'fail'
op|'('
name|'bad'
op|'['
number|'0'
op|']'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_runner_normal
dedent|''
dedent|''
name|'def'
name|'test_runner_normal'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'parseOptions'
op|'('
op|'['
string|"'--temp-directory'"
op|','
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|','
nl|'\n'
string|"'--reporter'"
op|','
string|"'capturing'"
op|','
nl|'\n'
string|"'twisted.trial.test.sample'"
op|']'
op|')'
newline|'\n'
name|'my_runner'
op|'='
name|'self'
op|'.'
name|'getRunner'
op|'('
op|')'
newline|'\n'
name|'loader'
op|'='
name|'runner'
op|'.'
name|'TestLoader'
op|'('
op|')'
newline|'\n'
name|'suite'
op|'='
name|'loader'
op|'.'
name|'loadByName'
op|'('
string|"'twisted.trial.test.sample'"
op|','
name|'True'
op|')'
newline|'\n'
name|'result'
op|'='
name|'my_runner'
op|'.'
name|'run'
op|'('
name|'suite'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'standardReport'
op|','
name|'result'
op|'.'
name|'_calls'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_runner_debug
dedent|''
name|'def'
name|'test_runner_debug'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'parseOptions'
op|'('
op|'['
string|"'--reporter'"
op|','
string|"'capturing'"
op|','
nl|'\n'
string|"'--debug'"
op|','
string|"'twisted.trial.test.sample'"
op|']'
op|')'
newline|'\n'
name|'my_runner'
op|'='
name|'self'
op|'.'
name|'getRunner'
op|'('
op|')'
newline|'\n'
name|'debugger'
op|'='
name|'CapturingDebugger'
op|'('
op|')'
newline|'\n'
DECL|function|get_debugger
name|'def'
name|'get_debugger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'debugger'
newline|'\n'
dedent|''
name|'my_runner'
op|'.'
name|'_getDebugger'
op|'='
name|'get_debugger'
newline|'\n'
name|'loader'
op|'='
name|'runner'
op|'.'
name|'TestLoader'
op|'('
op|')'
newline|'\n'
name|'suite'
op|'='
name|'loader'
op|'.'
name|'loadByName'
op|'('
string|"'twisted.trial.test.sample'"
op|','
name|'True'
op|')'
newline|'\n'
name|'result'
op|'='
name|'my_runner'
op|'.'
name|'run'
op|'('
name|'suite'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'standardReport'
op|','
name|'result'
op|'.'
name|'_calls'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
op|'['
string|"'runcall'"
op|']'
op|','
name|'debugger'
op|'.'
name|'_calls'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_removeSafelyNoTrialMarker
dedent|''
name|'def'
name|'test_removeSafelyNoTrialMarker'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a path doesn\'t contain a node named C{"_trial_marker"}, that path is\n        not removed by L{runner._removeSafely} and a L{runner._NoTrialMarker}\n        exception is raised instead.\n        """'
newline|'\n'
name|'directory'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'os'
op|'.'
name|'mkdir'
op|'('
name|'directory'
op|')'
newline|'\n'
name|'dirPath'
op|'='
name|'filepath'
op|'.'
name|'FilePath'
op|'('
name|'directory'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'parseOptions'
op|'('
op|'['
op|']'
op|')'
newline|'\n'
name|'myRunner'
op|'='
name|'self'
op|'.'
name|'getRunner'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'runner'
op|'.'
name|'_NoTrialMarker'
op|','
nl|'\n'
name|'myRunner'
op|'.'
name|'_removeSafely'
op|','
name|'dirPath'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_removeSafelyRemoveFailsMoveSucceeds
dedent|''
name|'def'
name|'test_removeSafelyRemoveFailsMoveSucceeds'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If an L{OSError} is raised while removing a path in\n        L{runner._removeSafely}, an attempt is made to move the path to a new\n        name.\n        """'
newline|'\n'
DECL|function|dummyRemove
name|'def'
name|'dummyRemove'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""\n            Raise an C{OSError} to emulate the branch of L{runner._removeSafely}\n            in which path removal fails.\n            """'
newline|'\n'
name|'raise'
name|'OSError'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Patch stdout so we can check the print statements in _removeSafely'
nl|'\n'
dedent|''
name|'out'
op|'='
name|'StringIO'
op|'.'
name|'StringIO'
op|'('
op|')'
newline|'\n'
name|'stdout'
op|'='
name|'self'
op|'.'
name|'patch'
op|'('
name|'sys'
op|','
string|"'stdout'"
op|','
name|'out'
op|')'
newline|'\n'
nl|'\n'
comment|'# Set up a trial directory with a _trial_marker'
nl|'\n'
name|'directory'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'os'
op|'.'
name|'mkdir'
op|'('
name|'directory'
op|')'
newline|'\n'
name|'dirPath'
op|'='
name|'filepath'
op|'.'
name|'FilePath'
op|'('
name|'directory'
op|')'
newline|'\n'
name|'dirPath'
op|'.'
name|'child'
op|'('
string|"'_trial_marker'"
op|')'
op|'.'
name|'touch'
op|'('
op|')'
newline|'\n'
comment|'# Ensure that path.remove() raises an OSError'
nl|'\n'
name|'dirPath'
op|'.'
name|'remove'
op|'='
name|'dummyRemove'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'parseOptions'
op|'('
op|'['
op|']'
op|')'
newline|'\n'
name|'myRunner'
op|'='
name|'self'
op|'.'
name|'getRunner'
op|'('
op|')'
newline|'\n'
name|'myRunner'
op|'.'
name|'_removeSafely'
op|'('
name|'dirPath'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIn'
op|'('
string|'"could not remove FilePath"'
op|','
name|'out'
op|'.'
name|'getvalue'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_removeSafelyRemoveFailsMoveFails
dedent|''
name|'def'
name|'test_removeSafelyRemoveFailsMoveFails'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If an L{OSError} is raised while removing a path in\n        L{runner._removeSafely}, an attempt is made to move the path to a new\n        name. If that attempt fails, the L{OSError} is re-raised.\n        """'
newline|'\n'
DECL|function|dummyRemove
name|'def'
name|'dummyRemove'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""\n            Raise an C{OSError} to emulate the branch of L{runner._removeSafely}\n            in which path removal fails.\n            """'
newline|'\n'
name|'raise'
name|'OSError'
op|'('
string|'"path removal failed"'
op|')'
newline|'\n'
nl|'\n'
DECL|function|dummyMoveTo
dedent|''
name|'def'
name|'dummyMoveTo'
op|'('
name|'path'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""\n            Raise an C{OSError} to emulate the branch of L{runner._removeSafely}\n            in which path movement fails.\n            """'
newline|'\n'
name|'raise'
name|'OSError'
op|'('
string|'"path movement failed"'
op|')'
newline|'\n'
nl|'\n'
comment|'# Patch stdout so we can check the print statements in _removeSafely'
nl|'\n'
dedent|''
name|'out'
op|'='
name|'StringIO'
op|'.'
name|'StringIO'
op|'('
op|')'
newline|'\n'
name|'stdout'
op|'='
name|'self'
op|'.'
name|'patch'
op|'('
name|'sys'
op|','
string|"'stdout'"
op|','
name|'out'
op|')'
newline|'\n'
nl|'\n'
comment|'# Set up a trial directory with a _trial_marker'
nl|'\n'
name|'directory'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'os'
op|'.'
name|'mkdir'
op|'('
name|'directory'
op|')'
newline|'\n'
name|'dirPath'
op|'='
name|'filepath'
op|'.'
name|'FilePath'
op|'('
name|'directory'
op|')'
newline|'\n'
name|'dirPath'
op|'.'
name|'child'
op|'('
string|"'_trial_marker'"
op|')'
op|'.'
name|'touch'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Ensure that path.remove() and path.moveTo() both raise OSErrors'
nl|'\n'
name|'dirPath'
op|'.'
name|'remove'
op|'='
name|'dummyRemove'
newline|'\n'
name|'dirPath'
op|'.'
name|'moveTo'
op|'='
name|'dummyMoveTo'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'parseOptions'
op|'('
op|'['
op|']'
op|')'
newline|'\n'
name|'myRunner'
op|'='
name|'self'
op|'.'
name|'getRunner'
op|'('
op|')'
newline|'\n'
name|'error'
op|'='
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'OSError'
op|','
name|'myRunner'
op|'.'
name|'_removeSafely'
op|','
name|'dirPath'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'str'
op|'('
name|'error'
op|')'
op|','
string|'"path movement failed"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIn'
op|'('
string|'"could not remove FilePath"'
op|','
name|'out'
op|'.'
name|'getvalue'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestTrialSuite
dedent|''
dedent|''
name|'class'
name|'TestTrialSuite'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|test_imports
indent|'    '
name|'def'
name|'test_imports'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# FIXME, HTF do you test the reactor can be cleaned up ?!!!'
nl|'\n'
indent|'        '
name|'from'
name|'twisted'
op|'.'
name|'trial'
op|'.'
name|'runner'
name|'import'
name|'TrialSuite'
newline|'\n'
comment|'# silence pyflakes warning'
nl|'\n'
name|'silencePyflakes'
op|'='
name|'TrialSuite'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestUntilFailure
dedent|''
dedent|''
name|'class'
name|'TestUntilFailure'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|class|FailAfter
indent|'    '
name|'class'
name|'FailAfter'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A test  case that fails when run 3 times in a row.\n        """'
newline|'\n'
DECL|variable|count
name|'count'
op|'='
op|'['
op|']'
newline|'\n'
DECL|member|test_foo
name|'def'
name|'test_foo'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'count'
op|'.'
name|'append'
op|'('
name|'None'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'self'
op|'.'
name|'count'
op|')'
op|'=='
number|'3'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'fail'
op|'('
string|"'Count reached 3'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|setUp
dedent|''
dedent|''
dedent|''
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'TestUntilFailure'
op|'.'
name|'FailAfter'
op|'.'
name|'count'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'test'
op|'='
name|'TestUntilFailure'
op|'.'
name|'FailAfter'
op|'('
string|"'test_foo'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'stream'
op|'='
name|'StringIO'
op|'.'
name|'StringIO'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'runner'
op|'='
name|'runner'
op|'.'
name|'TrialRunner'
op|'('
name|'reporter'
op|'.'
name|'Reporter'
op|','
name|'stream'
op|'='
name|'self'
op|'.'
name|'stream'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_runUntilFailure
dedent|''
name|'def'
name|'test_runUntilFailure'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that the runUntilFailure method of the runner actually fail after\n        a few runs.\n        """'
newline|'\n'
name|'result'
op|'='
name|'self'
op|'.'
name|'runner'
op|'.'
name|'runUntilFailure'
op|'('
name|'self'
op|'.'
name|'test'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'result'
op|'.'
name|'testsRun'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'result'
op|'.'
name|'wasSuccessful'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'_getFailures'
op|'('
name|'result'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_getFailures
dedent|''
name|'def'
name|'_getFailures'
op|'('
name|'self'
op|','
name|'result'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Get the number of failures that were reported to a result.\n        """'
newline|'\n'
name|'return'
name|'len'
op|'('
name|'result'
op|'.'
name|'failures'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_runUntilFailureDecorate
dedent|''
name|'def'
name|'test_runUntilFailureDecorate'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{runUntilFailure} doesn\'t decorate the tests uselessly: it does it one\n        time when run starts, but not at each turn.\n        """'
newline|'\n'
name|'decorated'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|decorate
name|'def'
name|'decorate'
op|'('
name|'test'
op|','
name|'interface'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'decorated'
op|'.'
name|'append'
op|'('
op|'('
name|'test'
op|','
name|'interface'
op|')'
op|')'
newline|'\n'
name|'return'
name|'test'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'patch'
op|'('
name|'unittest'
op|','
string|'"decorate"'
op|','
name|'decorate'
op|')'
newline|'\n'
name|'result'
op|'='
name|'self'
op|'.'
name|'runner'
op|'.'
name|'runUntilFailure'
op|'('
name|'self'
op|'.'
name|'test'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'result'
op|'.'
name|'testsRun'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'decorated'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'decorated'
op|','
op|'['
op|'('
name|'self'
op|'.'
name|'test'
op|','
name|'ITestCase'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_runUntilFailureForceGCDecorate
dedent|''
name|'def'
name|'test_runUntilFailureForceGCDecorate'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{runUntilFailure} applies the force-gc decoration after the standard\n        L{ITestCase} decoration, but only one time.\n        """'
newline|'\n'
name|'decorated'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|decorate
name|'def'
name|'decorate'
op|'('
name|'test'
op|','
name|'interface'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'decorated'
op|'.'
name|'append'
op|'('
op|'('
name|'test'
op|','
name|'interface'
op|')'
op|')'
newline|'\n'
name|'return'
name|'test'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'patch'
op|'('
name|'unittest'
op|','
string|'"decorate"'
op|','
name|'decorate'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'runner'
op|'.'
name|'_forceGarbageCollection'
op|'='
name|'True'
newline|'\n'
name|'result'
op|'='
name|'self'
op|'.'
name|'runner'
op|'.'
name|'runUntilFailure'
op|'('
name|'self'
op|'.'
name|'test'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'result'
op|'.'
name|'testsRun'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'decorated'
op|')'
op|','
number|'2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'decorated'
op|','
nl|'\n'
op|'['
op|'('
name|'self'
op|'.'
name|'test'
op|','
name|'ITestCase'
op|')'
op|','
nl|'\n'
op|'('
name|'self'
op|'.'
name|'test'
op|','
name|'unittest'
op|'.'
name|'_ForceGarbageCollectionDecorator'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|UncleanUntilFailureTests
dedent|''
dedent|''
name|'class'
name|'UncleanUntilFailureTests'
op|'('
name|'TestUntilFailure'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test that the run-until-failure feature works correctly with the unclean\n    error suppressor.\n    """'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'TestUntilFailure'
op|'.'
name|'setUp'
op|'('
name|'self'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'runner'
op|'='
name|'runner'
op|'.'
name|'TrialRunner'
op|'('
name|'reporter'
op|'.'
name|'Reporter'
op|','
name|'stream'
op|'='
name|'self'
op|'.'
name|'stream'
op|','
nl|'\n'
name|'uncleanWarnings'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_getFailures
dedent|''
name|'def'
name|'_getFailures'
op|'('
name|'self'
op|','
name|'result'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Get the number of failures that were reported to a result that\n        is wrapped in an UncleanFailureWrapper.\n        """'
newline|'\n'
name|'return'
name|'len'
op|'('
name|'result'
op|'.'
name|'_originalReporter'
op|'.'
name|'failures'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|BreakingSuite
dedent|''
dedent|''
name|'class'
name|'BreakingSuite'
op|'('
name|'runner'
op|'.'
name|'TestSuite'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A L{TestSuite} that logs an error when it is run.\n    """'
newline|'\n'
nl|'\n'
DECL|member|run
name|'def'
name|'run'
op|'('
name|'self'
op|','
name|'result'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'RuntimeError'
op|'('
string|'"error that occurs outside of a test"'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'RuntimeError'
op|','
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'log'
op|'.'
name|'err'
op|'('
name|'failure'
op|'.'
name|'Failure'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestLoggedErrors
dedent|''
dedent|''
dedent|''
name|'class'
name|'TestLoggedErrors'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    It is possible for an error generated by a test to be logged I{outside} of\n    any test. The log observers constructed by L{TestCase} won\'t catch these\n    errors. Here we try to generate such errors and ensure they are reported to\n    a L{TestResult} object.\n    """'
newline|'\n'
nl|'\n'
DECL|member|tearDown
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'flushLoggedErrors'
op|'('
name|'RuntimeError'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_construct
dedent|''
name|'def'
name|'test_construct'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that we can construct a L{runner.LoggedSuite} and that it\n        starts empty.\n        """'
newline|'\n'
name|'suite'
op|'='
name|'runner'
op|'.'
name|'LoggedSuite'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'suite'
op|'.'
name|'countTestCases'
op|'('
op|')'
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_capturesError
dedent|''
name|'def'
name|'test_capturesError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Chek that a L{LoggedSuite} reports any logged errors to its result.\n        """'
newline|'\n'
name|'result'
op|'='
name|'reporter'
op|'.'
name|'TestResult'
op|'('
op|')'
newline|'\n'
name|'suite'
op|'='
name|'runner'
op|'.'
name|'LoggedSuite'
op|'('
op|'['
name|'BreakingSuite'
op|'('
op|')'
op|']'
op|')'
newline|'\n'
name|'suite'
op|'.'
name|'run'
op|'('
name|'result'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'len'
op|'('
name|'result'
op|'.'
name|'errors'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'result'
op|'.'
name|'errors'
op|'['
number|'0'
op|']'
op|'['
number|'0'
op|']'
op|'.'
name|'id'
op|'('
op|')'
op|','
name|'runner'
op|'.'
name|'NOT_IN_TEST'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'result'
op|'.'
name|'errors'
op|'['
number|'0'
op|']'
op|'['
number|'1'
op|']'
op|'.'
name|'check'
op|'('
name|'RuntimeError'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestTestHolder
dedent|''
dedent|''
name|'class'
name|'TestTestHolder'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|setUp
indent|'    '
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'description'
op|'='
string|'"description"'
newline|'\n'
name|'self'
op|'.'
name|'holder'
op|'='
name|'runner'
op|'.'
name|'TestHolder'
op|'('
name|'self'
op|'.'
name|'description'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_holder
dedent|''
name|'def'
name|'test_holder'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that L{runner.TestHolder} takes a description as a parameter\n        and that this description is returned by the C{id} and\n        C{shortDescription} methods.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'holder'
op|'.'
name|'id'
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'description'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'holder'
op|'.'
name|'shortDescription'
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'description'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_holderImplementsITestCase
dedent|''
name|'def'
name|'test_holderImplementsITestCase'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{runner.TestHolder} implements L{ITestCase}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'self'
op|'.'
name|'holder'
op|','
name|'ITestCase'
op|'('
name|'self'
op|'.'
name|'holder'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestErrorHolder
dedent|''
dedent|''
name|'class'
name|'TestErrorHolder'
op|'('
name|'TestTestHolder'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test L{runner.ErrorHolder} shares behaviour with L{runner.TestHolder}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'description'
op|'='
string|'"description"'
newline|'\n'
comment|'# make a real Failure so we can construct ErrorHolder()'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
number|'1'
op|'/'
number|'0'
newline|'\n'
dedent|''
name|'except'
name|'ZeroDivisionError'
op|':'
newline|'\n'
indent|'            '
name|'error'
op|'='
name|'failure'
op|'.'
name|'Failure'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'holder'
op|'='
name|'runner'
op|'.'
name|'ErrorHolder'
op|'('
name|'self'
op|'.'
name|'description'
op|','
name|'error'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestMalformedMethod
dedent|''
dedent|''
name|'class'
name|'TestMalformedMethod'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test that trial manages when test methods don\'t have correct signatures.\n    """'
newline|'\n'
DECL|class|ContainMalformed
name|'class'
name|'ContainMalformed'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        This TestCase holds malformed test methods that trial should handle.\n        """'
newline|'\n'
DECL|member|test_foo
name|'def'
name|'test_foo'
op|'('
name|'self'
op|','
name|'blah'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
DECL|member|test_bar
dedent|''
name|'def'
name|'test_bar'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
DECL|variable|test_spam
dedent|''
name|'test_spam'
op|'='
name|'defer'
op|'.'
name|'deferredGenerator'
op|'('
name|'test_bar'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_test
dedent|''
name|'def'
name|'_test'
op|'('
name|'self'
op|','
name|'method'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Wrapper for one of the test method of L{ContainMalformed}.\n        """'
newline|'\n'
name|'stream'
op|'='
name|'StringIO'
op|'.'
name|'StringIO'
op|'('
op|')'
newline|'\n'
name|'trialRunner'
op|'='
name|'runner'
op|'.'
name|'TrialRunner'
op|'('
name|'reporter'
op|'.'
name|'Reporter'
op|','
name|'stream'
op|'='
name|'stream'
op|')'
newline|'\n'
name|'test'
op|'='
name|'TestMalformedMethod'
op|'.'
name|'ContainMalformed'
op|'('
name|'method'
op|')'
newline|'\n'
name|'result'
op|'='
name|'trialRunner'
op|'.'
name|'run'
op|'('
name|'test'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'result'
op|'.'
name|'testsRun'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'result'
op|'.'
name|'wasSuccessful'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'len'
op|'('
name|'result'
op|'.'
name|'errors'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_extraArg
dedent|''
name|'def'
name|'test_extraArg'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test when the method has extra (useless) arguments.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_test'
op|'('
string|"'test_foo'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_noArg
dedent|''
name|'def'
name|'test_noArg'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test when the method doesn\'t have even self as argument.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_test'
op|'('
string|"'test_bar'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_decorated
dedent|''
name|'def'
name|'test_decorated'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test a decorated method also fails.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_test'
op|'('
string|"'test_spam'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DestructiveTestSuiteTestCase
dedent|''
dedent|''
name|'class'
name|'DestructiveTestSuiteTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test for L{runner.DestructiveTestSuite}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|test_basic
name|'def'
name|'test_basic'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Thes destructive test suite should run the tests normally.\n        """'
newline|'\n'
name|'called'
op|'='
op|'['
op|']'
newline|'\n'
DECL|class|MockTest
name|'class'
name|'MockTest'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|test_foo
indent|'            '
name|'def'
name|'test_foo'
op|'('
name|'test'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'called'
op|'.'
name|'append'
op|'('
name|'True'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'test'
op|'='
name|'MockTest'
op|'('
string|"'test_foo'"
op|')'
newline|'\n'
name|'result'
op|'='
name|'reporter'
op|'.'
name|'TestResult'
op|'('
op|')'
newline|'\n'
name|'suite'
op|'='
name|'runner'
op|'.'
name|'DestructiveTestSuite'
op|'('
op|'['
name|'test'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'called'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'suite'
op|'.'
name|'run'
op|'('
name|'result'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'called'
op|','
op|'['
name|'True'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'suite'
op|'.'
name|'countTestCases'
op|'('
op|')'
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_shouldStop
dedent|''
name|'def'
name|'test_shouldStop'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test the C{shouldStop} management: raising a C{KeyboardInterrupt} must\n        interrupt the suite.\n        """'
newline|'\n'
name|'called'
op|'='
op|'['
op|']'
newline|'\n'
DECL|class|MockTest
name|'class'
name|'MockTest'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|test_foo1
indent|'            '
name|'def'
name|'test_foo1'
op|'('
name|'test'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'called'
op|'.'
name|'append'
op|'('
number|'1'
op|')'
newline|'\n'
DECL|member|test_foo2
dedent|''
name|'def'
name|'test_foo2'
op|'('
name|'test'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'KeyboardInterrupt'
op|'('
op|')'
newline|'\n'
DECL|member|test_foo3
dedent|''
name|'def'
name|'test_foo3'
op|'('
name|'test'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'called'
op|'.'
name|'append'
op|'('
number|'2'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'result'
op|'='
name|'reporter'
op|'.'
name|'TestResult'
op|'('
op|')'
newline|'\n'
name|'loader'
op|'='
name|'runner'
op|'.'
name|'TestLoader'
op|'('
op|')'
newline|'\n'
name|'loader'
op|'.'
name|'suiteFactory'
op|'='
name|'runner'
op|'.'
name|'DestructiveTestSuite'
newline|'\n'
name|'suite'
op|'='
name|'loader'
op|'.'
name|'loadClass'
op|'('
name|'MockTest'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'called'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'suite'
op|'.'
name|'run'
op|'('
name|'result'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'called'
op|','
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
comment|"# The last test shouldn't have been run"
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'suite'
op|'.'
name|'countTestCases'
op|'('
op|')'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_cleanup
dedent|''
name|'def'
name|'test_cleanup'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Checks that the test suite cleanups its tests during the run, so that\n        it ends empty.\n        """'
newline|'\n'
DECL|class|MockTest
name|'class'
name|'MockTest'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|test_foo
indent|'            '
name|'def'
name|'test_foo'
op|'('
name|'test'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'test'
op|'='
name|'MockTest'
op|'('
string|"'test_foo'"
op|')'
newline|'\n'
name|'result'
op|'='
name|'reporter'
op|'.'
name|'TestResult'
op|'('
op|')'
newline|'\n'
name|'suite'
op|'='
name|'runner'
op|'.'
name|'DestructiveTestSuite'
op|'('
op|'['
name|'test'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'suite'
op|'.'
name|'countTestCases'
op|'('
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'suite'
op|'.'
name|'run'
op|'('
name|'result'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'suite'
op|'.'
name|'countTestCases'
op|'('
op|')'
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestRunnerDeprecation
dedent|''
dedent|''
name|'class'
name|'TestRunnerDeprecation'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|class|FakeReporter
indent|'    '
name|'class'
name|'FakeReporter'
op|'('
name|'reporter'
op|'.'
name|'Reporter'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Fake reporter that does *not* implement done() but *does* implement\n        printErrors, separator, printSummary, stream, write and writeln\n        without deprecations.\n        """'
newline|'\n'
nl|'\n'
DECL|variable|done
name|'done'
op|'='
name|'None'
newline|'\n'
DECL|variable|separator
name|'separator'
op|'='
name|'None'
newline|'\n'
DECL|variable|stream
name|'stream'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|printErrors
name|'def'
name|'printErrors'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|printSummary
dedent|''
name|'def'
name|'printSummary'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|write
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|writeln
dedent|''
name|'def'
name|'writeln'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_reporterDeprecations
dedent|''
dedent|''
name|'def'
name|'test_reporterDeprecations'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The runner emits a warning if it is using a result that doesn\'t\n        implement \'done\'.\n        """'
newline|'\n'
name|'trialRunner'
op|'='
name|'runner'
op|'.'
name|'TrialRunner'
op|'('
name|'None'
op|')'
newline|'\n'
name|'result'
op|'='
name|'self'
op|'.'
name|'FakeReporter'
op|'('
op|')'
newline|'\n'
name|'trialRunner'
op|'.'
name|'_makeResult'
op|'='
name|'lambda'
op|':'
name|'result'
newline|'\n'
DECL|function|f
name|'def'
name|'f'
op|'('
op|')'
op|':'
newline|'\n'
comment|"# We have to use a pyunit test, otherwise we'll get deprecation"
nl|'\n'
comment|'# warnings about using iterate() in a test.'
nl|'\n'
indent|'            '
name|'trialRunner'
op|'.'
name|'run'
op|'('
name|'pyunit'
op|'.'
name|'TestCase'
op|'('
string|"'id'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertWarns'
op|'('
nl|'\n'
name|'DeprecationWarning'
op|','
nl|'\n'
string|'"%s should implement done() but doesn\'t. Falling back to "'
nl|'\n'
string|'"printErrors() and friends."'
op|'%'
name|'reflect'
op|'.'
name|'qual'
op|'('
name|'result'
op|'.'
name|'__class__'
op|')'
op|','
nl|'\n'
name|'__file__'
op|','
name|'f'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
