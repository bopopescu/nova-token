begin_unit
name|'import'
name|'os'
newline|'\n'
nl|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'implements'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'interfaces'
name|'import'
name|'IProcessTransport'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'defer'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'base'
name|'import'
name|'DelayedCall'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
op|'.'
name|'unittest'
name|'import'
name|'TestCase'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'util'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
op|'.'
name|'util'
name|'import'
name|'DirtyReactorAggregateError'
op|','
name|'_Janitor'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
op|'.'
name|'test'
name|'import'
name|'packages'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestMktemp
name|'class'
name|'TestMktemp'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|test_name
indent|'    '
name|'def'
name|'test_name'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'name'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'dirs'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'dirname'
op|'('
name|'name'
op|')'
op|'.'
name|'split'
op|'('
name|'os'
op|'.'
name|'sep'
op|')'
op|'['
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
nl|'\n'
name|'dirs'
op|','
op|'['
string|"'twisted.trial.test.test_util'"
op|','
string|"'TestMktemp'"
op|','
string|"'test_name'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_unique
dedent|''
name|'def'
name|'test_unique'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'name'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIfEqual'
op|'('
name|'name'
op|','
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_created
dedent|''
name|'def'
name|'test_created'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'name'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'dirname'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'dirname'
op|'('
name|'name'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'dirname'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'name'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_location
dedent|''
name|'def'
name|'test_location'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'abspath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'path'
op|'.'
name|'startswith'
op|'('
name|'os'
op|'.'
name|'getcwd'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestIntrospection
dedent|''
dedent|''
name|'class'
name|'TestIntrospection'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|test_containers
indent|'    '
name|'def'
name|'test_containers'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'import'
name|'suppression'
newline|'\n'
name|'parents'
op|'='
name|'util'
op|'.'
name|'getPythonContainers'
op|'('
nl|'\n'
name|'suppression'
op|'.'
name|'TestSuppression2'
op|'.'
name|'testSuppressModule'
op|')'
newline|'\n'
name|'expected'
op|'='
op|'['
name|'suppression'
op|'.'
name|'TestSuppression2'
op|','
name|'suppression'
op|']'
newline|'\n'
name|'for'
name|'a'
op|','
name|'b'
name|'in'
name|'zip'
op|'('
name|'parents'
op|','
name|'expected'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'a'
op|','
name|'b'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestFindObject
dedent|''
dedent|''
dedent|''
name|'class'
name|'TestFindObject'
op|'('
name|'packages'
op|'.'
name|'SysPathManglingTest'
op|')'
op|':'
newline|'\n'
DECL|member|test_importPackage
indent|'    '
name|'def'
name|'test_importPackage'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'package1'
op|'='
name|'util'
op|'.'
name|'findObject'
op|'('
string|"'package'"
op|')'
newline|'\n'
name|'import'
name|'package'
name|'as'
name|'package2'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'package1'
op|','
op|'('
name|'True'
op|','
name|'package2'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_importModule
dedent|''
name|'def'
name|'test_importModule'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'test_sample2'
op|'='
name|'util'
op|'.'
name|'findObject'
op|'('
string|"'goodpackage.test_sample'"
op|')'
newline|'\n'
name|'from'
name|'goodpackage'
name|'import'
name|'test_sample'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
op|'('
name|'True'
op|','
name|'test_sample'
op|')'
op|','
name|'test_sample2'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_importError
dedent|''
name|'def'
name|'test_importError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'failUnlessRaises'
op|'('
name|'ZeroDivisionError'
op|','
nl|'\n'
name|'util'
op|'.'
name|'findObject'
op|','
string|"'package.test_bad_module'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_sophisticatedImportError
dedent|''
name|'def'
name|'test_sophisticatedImportError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'failUnlessRaises'
op|'('
name|'ImportError'
op|','
nl|'\n'
name|'util'
op|'.'
name|'findObject'
op|','
string|"'package2.test_module'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_importNonexistentPackage
dedent|''
name|'def'
name|'test_importNonexistentPackage'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'util'
op|'.'
name|'findObject'
op|'('
string|"'doesntexist'"
op|')'
op|'['
number|'0'
op|']'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_findNonexistentModule
dedent|''
name|'def'
name|'test_findNonexistentModule'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'util'
op|'.'
name|'findObject'
op|'('
string|"'package.doesntexist'"
op|')'
op|'['
number|'0'
op|']'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_findNonexistentObject
dedent|''
name|'def'
name|'test_findNonexistentObject'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'util'
op|'.'
name|'findObject'
op|'('
nl|'\n'
string|"'goodpackage.test_sample.doesnt'"
op|')'
op|'['
number|'0'
op|']'
op|','
name|'False'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'util'
op|'.'
name|'findObject'
op|'('
nl|'\n'
string|"'goodpackage.test_sample.AlphabetTest.doesntexist'"
op|')'
op|'['
number|'0'
op|']'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_findObjectExist
dedent|''
name|'def'
name|'test_findObjectExist'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'alpha1'
op|'='
name|'util'
op|'.'
name|'findObject'
op|'('
string|"'goodpackage.test_sample.AlphabetTest'"
op|')'
newline|'\n'
name|'from'
name|'goodpackage'
name|'import'
name|'test_sample'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'alpha1'
op|','
op|'('
name|'True'
op|','
name|'test_sample'
op|'.'
name|'AlphabetTest'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestRunSequentially
dedent|''
dedent|''
name|'class'
name|'TestRunSequentially'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Sometimes it is useful to be able to run an arbitrary list of callables,\n    one after the other.\n\n    When some of those callables can return Deferreds, things become complex.\n    """'
newline|'\n'
nl|'\n'
DECL|member|test_emptyList
name|'def'
name|'test_emptyList'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When asked to run an empty list of callables, runSequentially returns a\n        successful Deferred that fires an empty list.\n        """'
newline|'\n'
name|'d'
op|'='
name|'util'
op|'.'
name|'_runSequentially'
op|'('
op|'['
op|']'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'assertEqual'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_singleSynchronousSuccess
dedent|''
name|'def'
name|'test_singleSynchronousSuccess'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When given a callable that succeeds without returning a Deferred,\n        include the return value in the results list, tagged with a SUCCESS\n        flag.\n        """'
newline|'\n'
name|'d'
op|'='
name|'util'
op|'.'
name|'_runSequentially'
op|'('
op|'['
name|'lambda'
op|':'
name|'None'
op|']'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'assertEqual'
op|','
op|'['
op|'('
name|'defer'
op|'.'
name|'SUCCESS'
op|','
name|'None'
op|')'
op|']'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_singleSynchronousFailure
dedent|''
name|'def'
name|'test_singleSynchronousFailure'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When given a callable that raises an exception, include a Failure for\n        that exception in the results list, tagged with a FAILURE flag.\n        """'
newline|'\n'
name|'d'
op|'='
name|'util'
op|'.'
name|'_runSequentially'
op|'('
op|'['
name|'lambda'
op|':'
name|'self'
op|'.'
name|'fail'
op|'('
string|"'foo'"
op|')'
op|']'
op|')'
newline|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
name|'results'
op|')'
op|':'
newline|'\n'
indent|'            '
op|'['
op|'('
name|'flag'
op|','
name|'fail'
op|')'
op|']'
op|'='
name|'results'
newline|'\n'
name|'fail'
op|'.'
name|'trap'
op|'('
name|'self'
op|'.'
name|'failureException'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'fail'
op|'.'
name|'getErrorMessage'
op|'('
op|')'
op|','
string|"'foo'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'flag'
op|','
name|'defer'
op|'.'
name|'FAILURE'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'check'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_singleAsynchronousSuccess
dedent|''
name|'def'
name|'test_singleAsynchronousSuccess'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When given a callable that returns a successful Deferred, include the\n        result of the Deferred in the results list, tagged with a SUCCESS flag.\n        """'
newline|'\n'
name|'d'
op|'='
name|'util'
op|'.'
name|'_runSequentially'
op|'('
op|'['
name|'lambda'
op|':'
name|'defer'
op|'.'
name|'succeed'
op|'('
name|'None'
op|')'
op|']'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'assertEqual'
op|','
op|'['
op|'('
name|'defer'
op|'.'
name|'SUCCESS'
op|','
name|'None'
op|')'
op|']'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_singleAsynchronousFailure
dedent|''
name|'def'
name|'test_singleAsynchronousFailure'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When given a callable that returns a failing Deferred, include the\n        failure the results list, tagged with a FAILURE flag.\n        """'
newline|'\n'
name|'d'
op|'='
name|'util'
op|'.'
name|'_runSequentially'
op|'('
op|'['
name|'lambda'
op|':'
name|'defer'
op|'.'
name|'fail'
op|'('
name|'ValueError'
op|'('
string|"'foo'"
op|')'
op|')'
op|']'
op|')'
newline|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
name|'results'
op|')'
op|':'
newline|'\n'
indent|'            '
op|'['
op|'('
name|'flag'
op|','
name|'fail'
op|')'
op|']'
op|'='
name|'results'
newline|'\n'
name|'fail'
op|'.'
name|'trap'
op|'('
name|'ValueError'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'fail'
op|'.'
name|'getErrorMessage'
op|'('
op|')'
op|','
string|"'foo'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'flag'
op|','
name|'defer'
op|'.'
name|'FAILURE'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'check'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_callablesCalledInOrder
dedent|''
name|'def'
name|'test_callablesCalledInOrder'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that the callables are called in the given order, one after the\n        other.\n        """'
newline|'\n'
name|'log'
op|'='
op|'['
op|']'
newline|'\n'
name|'deferreds'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|function|append
name|'def'
name|'append'
op|'('
name|'value'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'log'
op|'.'
name|'append'
op|'('
name|'value'
op|')'
newline|'\n'
name|'deferreds'
op|'.'
name|'append'
op|'('
name|'d'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
dedent|''
name|'d'
op|'='
name|'util'
op|'.'
name|'_runSequentially'
op|'('
op|'['
name|'lambda'
op|':'
name|'append'
op|'('
string|"'foo'"
op|')'
op|','
nl|'\n'
name|'lambda'
op|':'
name|'append'
op|'('
string|"'bar'"
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# runSequentially should wait until the Deferred has fired before'
nl|'\n'
comment|'# running the second callable.'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'log'
op|','
op|'['
string|"'foo'"
op|']'
op|')'
newline|'\n'
name|'deferreds'
op|'['
op|'-'
number|'1'
op|']'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'log'
op|','
op|'['
string|"'foo'"
op|','
string|"'bar'"
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Because returning created Deferreds makes jml happy.'
nl|'\n'
name|'deferreds'
op|'['
op|'-'
number|'1'
op|']'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_continuesAfterError
dedent|''
name|'def'
name|'test_continuesAfterError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If one of the callables raises an error, then runSequentially continues\n        to run the remaining callables.\n        """'
newline|'\n'
name|'d'
op|'='
name|'util'
op|'.'
name|'_runSequentially'
op|'('
op|'['
name|'lambda'
op|':'
name|'self'
op|'.'
name|'fail'
op|'('
string|"'foo'"
op|')'
op|','
name|'lambda'
op|':'
string|"'bar'"
op|']'
op|')'
newline|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
name|'results'
op|')'
op|':'
newline|'\n'
indent|'            '
op|'['
op|'('
name|'flag1'
op|','
name|'fail'
op|')'
op|','
op|'('
name|'flag2'
op|','
name|'result'
op|')'
op|']'
op|'='
name|'results'
newline|'\n'
name|'fail'
op|'.'
name|'trap'
op|'('
name|'self'
op|'.'
name|'failureException'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'flag1'
op|','
name|'defer'
op|'.'
name|'FAILURE'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'fail'
op|'.'
name|'getErrorMessage'
op|'('
op|')'
op|','
string|"'foo'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'flag2'
op|','
name|'defer'
op|'.'
name|'SUCCESS'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'result'
op|','
string|"'bar'"
op|')'
newline|'\n'
dedent|''
name|'return'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'check'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_stopOnFirstError
dedent|''
name|'def'
name|'test_stopOnFirstError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the C{stopOnFirstError} option is passed to C{runSequentially}, then\n        no further callables are called after the first exception is raised.\n        """'
newline|'\n'
name|'d'
op|'='
name|'util'
op|'.'
name|'_runSequentially'
op|'('
op|'['
name|'lambda'
op|':'
name|'self'
op|'.'
name|'fail'
op|'('
string|"'foo'"
op|')'
op|','
name|'lambda'
op|':'
string|"'bar'"
op|']'
op|','
nl|'\n'
name|'stopOnFirstError'
op|'='
name|'True'
op|')'
newline|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
name|'results'
op|')'
op|':'
newline|'\n'
indent|'            '
op|'['
op|'('
name|'flag1'
op|','
name|'fail'
op|')'
op|']'
op|'='
name|'results'
newline|'\n'
name|'fail'
op|'.'
name|'trap'
op|'('
name|'self'
op|'.'
name|'failureException'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'flag1'
op|','
name|'defer'
op|'.'
name|'FAILURE'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'fail'
op|'.'
name|'getErrorMessage'
op|'('
op|')'
op|','
string|"'foo'"
op|')'
newline|'\n'
dedent|''
name|'return'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'check'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_stripFlags
dedent|''
name|'def'
name|'test_stripFlags'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the C{stripFlags} option is passed to C{runSequentially} then the\n        SUCCESS / FAILURE flags are stripped from the output. Instead, the\n        Deferred fires a flat list of results containing only the results and\n        failures.\n        """'
newline|'\n'
name|'d'
op|'='
name|'util'
op|'.'
name|'_runSequentially'
op|'('
op|'['
name|'lambda'
op|':'
name|'self'
op|'.'
name|'fail'
op|'('
string|"'foo'"
op|')'
op|','
name|'lambda'
op|':'
string|"'bar'"
op|']'
op|','
nl|'\n'
name|'stripFlags'
op|'='
name|'True'
op|')'
newline|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
name|'results'
op|')'
op|':'
newline|'\n'
indent|'            '
op|'['
name|'fail'
op|','
name|'result'
op|']'
op|'='
name|'results'
newline|'\n'
name|'fail'
op|'.'
name|'trap'
op|'('
name|'self'
op|'.'
name|'failureException'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'fail'
op|'.'
name|'getErrorMessage'
op|'('
op|')'
op|','
string|"'foo'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'result'
op|','
string|"'bar'"
op|')'
newline|'\n'
dedent|''
name|'return'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'check'
op|')'
newline|'\n'
dedent|''
name|'test_stripFlags'
op|'.'
name|'todo'
op|'='
string|'"YAGNI"'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DirtyReactorAggregateErrorTest
dedent|''
name|'class'
name|'DirtyReactorAggregateErrorTest'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for the L{DirtyReactorAggregateError}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|test_formatDelayedCall
name|'def'
name|'test_formatDelayedCall'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Delayed calls are formatted nicely.\n        """'
newline|'\n'
name|'error'
op|'='
name|'DirtyReactorAggregateError'
op|'('
op|'['
string|'"Foo"'
op|','
string|'"bar"'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'str'
op|'('
name|'error'
op|')'
op|','
nl|'\n'
string|'"""\\\nReactor was unclean.\nDelayedCalls: (set twisted.internet.base.DelayedCall.debug = True to debug)\nFoo\nbar"""'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_formatSelectables
dedent|''
name|'def'
name|'test_formatSelectables'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Selectables are formatted nicely.\n        """'
newline|'\n'
name|'error'
op|'='
name|'DirtyReactorAggregateError'
op|'('
op|'['
op|']'
op|','
op|'['
string|'"selectable 1"'
op|','
string|'"selectable 2"'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'str'
op|'('
name|'error'
op|')'
op|','
nl|'\n'
string|'"""\\\nReactor was unclean.\nSelectables:\nselectable 1\nselectable 2"""'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_formatDelayedCallsAndSelectables
dedent|''
name|'def'
name|'test_formatDelayedCallsAndSelectables'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Both delayed calls and selectables can appear in the same error.\n        """'
newline|'\n'
name|'error'
op|'='
name|'DirtyReactorAggregateError'
op|'('
op|'['
string|'"bleck"'
op|','
string|'"Boozo"'
op|']'
op|','
nl|'\n'
op|'['
string|'"Sel1"'
op|','
string|'"Sel2"'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'str'
op|'('
name|'error'
op|')'
op|','
nl|'\n'
string|'"""\\\nReactor was unclean.\nDelayedCalls: (set twisted.internet.base.DelayedCall.debug = True to debug)\nbleck\nBoozo\nSelectables:\nSel1\nSel2"""'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|StubReactor
dedent|''
dedent|''
name|'class'
name|'StubReactor'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A reactor stub which contains enough functionality to be used with the\n    L{_Janitor}.\n\n    @ivar iterations: A list of the arguments passed to L{iterate}.\n    @ivar removeAllCalled: Number of times that L{removeAll} was called.\n    @ivar selectables: The value that will be returned from L{removeAll}.\n    @ivar delayedCalls: The value to return from L{getDelayedCalls}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'delayedCalls'
op|','
name|'selectables'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @param delayedCalls: See L{StubReactor.delayedCalls}.\n        @param selectables: See L{StubReactor.selectables}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'delayedCalls'
op|'='
name|'delayedCalls'
newline|'\n'
name|'self'
op|'.'
name|'iterations'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'removeAllCalled'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'not'
name|'selectables'
op|':'
newline|'\n'
indent|'            '
name|'selectables'
op|'='
op|'['
op|']'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'selectables'
op|'='
name|'selectables'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|iterate
dedent|''
name|'def'
name|'iterate'
op|'('
name|'self'
op|','
name|'timeout'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Increment C{self.iterations}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'iterations'
op|'.'
name|'append'
op|'('
name|'timeout'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getDelayedCalls
dedent|''
name|'def'
name|'getDelayedCalls'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return C{self.delayedCalls}.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'delayedCalls'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|removeAll
dedent|''
name|'def'
name|'removeAll'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Increment C{self.removeAllCalled} and return C{self.selectables}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'removeAllCalled'
op|'+='
number|'1'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'selectables'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|StubErrorReporter
dedent|''
dedent|''
name|'class'
name|'StubErrorReporter'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A subset of L{twisted.trial.itrial.IReporter} which records L{addError}\n    calls.\n\n    @ivar errors: List of two-tuples of (test, error) which were passed to\n        L{addError}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'errors'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|addError
dedent|''
name|'def'
name|'addError'
op|'('
name|'self'
op|','
name|'test'
op|','
name|'error'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Record parameters in C{self.errors}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'errors'
op|'.'
name|'append'
op|'('
op|'('
name|'test'
op|','
name|'error'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|JanitorTests
dedent|''
dedent|''
name|'class'
name|'JanitorTests'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{_Janitor}!\n    """'
newline|'\n'
nl|'\n'
DECL|member|test_cleanPendingSpinsReactor
name|'def'
name|'test_cleanPendingSpinsReactor'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        During pending-call cleanup, the reactor will be spun twice with an\n        instant timeout. This is not a requirement, it is only a test for\n        current behavior. Hopefully Trial will eventually not do this kind of\n        reactor stuff.\n        """'
newline|'\n'
name|'reactor'
op|'='
name|'StubReactor'
op|'('
op|'['
op|']'
op|')'
newline|'\n'
name|'jan'
op|'='
name|'_Janitor'
op|'('
name|'None'
op|','
name|'None'
op|','
name|'reactor'
op|'='
name|'reactor'
op|')'
newline|'\n'
name|'jan'
op|'.'
name|'_cleanPending'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'reactor'
op|'.'
name|'iterations'
op|','
op|'['
number|'0'
op|','
number|'0'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_cleanPendingCancelsCalls
dedent|''
name|'def'
name|'test_cleanPendingCancelsCalls'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        During pending-call cleanup, the janitor cancels pending timed calls.\n        """'
newline|'\n'
DECL|function|func
name|'def'
name|'func'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|'"Lulz"'
newline|'\n'
dedent|''
name|'cancelled'
op|'='
op|'['
op|']'
newline|'\n'
name|'delayedCall'
op|'='
name|'DelayedCall'
op|'('
number|'300'
op|','
name|'func'
op|','
op|'('
op|')'
op|','
op|'{'
op|'}'
op|','
nl|'\n'
name|'cancelled'
op|'.'
name|'append'
op|','
name|'lambda'
name|'x'
op|':'
name|'None'
op|')'
newline|'\n'
name|'reactor'
op|'='
name|'StubReactor'
op|'('
op|'['
name|'delayedCall'
op|']'
op|')'
newline|'\n'
name|'jan'
op|'='
name|'_Janitor'
op|'('
name|'None'
op|','
name|'None'
op|','
name|'reactor'
op|'='
name|'reactor'
op|')'
newline|'\n'
name|'jan'
op|'.'
name|'_cleanPending'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'cancelled'
op|','
op|'['
name|'delayedCall'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_cleanPendingReturnsDelayedCallStrings
dedent|''
name|'def'
name|'test_cleanPendingReturnsDelayedCallStrings'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The Janitor produces string representations of delayed calls from the\n        delayed call cleanup method. It gets the string representations\n        *before* cancelling the calls; this is important because cancelling the\n        call removes critical debugging information from the string\n        representation.\n        """'
newline|'\n'
name|'delayedCall'
op|'='
name|'DelayedCall'
op|'('
number|'300'
op|','
name|'lambda'
op|':'
name|'None'
op|','
op|'('
op|')'
op|','
op|'{'
op|'}'
op|','
nl|'\n'
name|'lambda'
name|'x'
op|':'
name|'None'
op|','
name|'lambda'
name|'x'
op|':'
name|'None'
op|','
nl|'\n'
name|'seconds'
op|'='
name|'lambda'
op|':'
number|'0'
op|')'
newline|'\n'
name|'delayedCallString'
op|'='
name|'str'
op|'('
name|'delayedCall'
op|')'
newline|'\n'
name|'reactor'
op|'='
name|'StubReactor'
op|'('
op|'['
name|'delayedCall'
op|']'
op|')'
newline|'\n'
name|'jan'
op|'='
name|'_Janitor'
op|'('
name|'None'
op|','
name|'None'
op|','
name|'reactor'
op|'='
name|'reactor'
op|')'
newline|'\n'
name|'strings'
op|'='
name|'jan'
op|'.'
name|'_cleanPending'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'strings'
op|','
op|'['
name|'delayedCallString'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_cleanReactorRemovesSelectables
dedent|''
name|'def'
name|'test_cleanReactorRemovesSelectables'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The Janitor will remove selectables during reactor cleanup.\n        """'
newline|'\n'
name|'reactor'
op|'='
name|'StubReactor'
op|'('
op|'['
op|']'
op|')'
newline|'\n'
name|'jan'
op|'='
name|'_Janitor'
op|'('
name|'None'
op|','
name|'None'
op|','
name|'reactor'
op|'='
name|'reactor'
op|')'
newline|'\n'
name|'jan'
op|'.'
name|'_cleanReactor'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'reactor'
op|'.'
name|'removeAllCalled'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_cleanReactorKillsProcesses
dedent|''
name|'def'
name|'test_cleanReactorKillsProcesses'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The Janitor will kill processes during reactor cleanup.\n        """'
newline|'\n'
DECL|class|StubProcessTransport
name|'class'
name|'StubProcessTransport'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""\n            A stub L{IProcessTransport} provider which records signals.\n            @ivar signals: The signals passed to L{signalProcess}.\n            """'
newline|'\n'
name|'implements'
op|'('
name|'IProcessTransport'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'signals'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|signalProcess
dedent|''
name|'def'
name|'signalProcess'
op|'('
name|'self'
op|','
name|'signal'
op|')'
op|':'
newline|'\n'
indent|'                '
string|'"""\n                Append C{signal} to C{self.signals}.\n                """'
newline|'\n'
name|'self'
op|'.'
name|'signals'
op|'.'
name|'append'
op|'('
name|'signal'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'pt'
op|'='
name|'StubProcessTransport'
op|'('
op|')'
newline|'\n'
name|'reactor'
op|'='
name|'StubReactor'
op|'('
op|'['
op|']'
op|','
op|'['
name|'pt'
op|']'
op|')'
newline|'\n'
name|'jan'
op|'='
name|'_Janitor'
op|'('
name|'None'
op|','
name|'None'
op|','
name|'reactor'
op|'='
name|'reactor'
op|')'
newline|'\n'
name|'jan'
op|'.'
name|'_cleanReactor'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'pt'
op|'.'
name|'signals'
op|','
op|'['
string|'"KILL"'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_cleanReactorReturnsSelectableStrings
dedent|''
name|'def'
name|'test_cleanReactorReturnsSelectableStrings'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The Janitor returns string representations of the selectables that it\n        cleaned up from the reactor cleanup method.\n        """'
newline|'\n'
DECL|class|Selectable
name|'class'
name|'Selectable'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""\n            A stub Selectable which only has an interesting string\n            representation.\n            """'
newline|'\n'
DECL|member|__repr__
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
string|'"(SELECTABLE!)"'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'reactor'
op|'='
name|'StubReactor'
op|'('
op|'['
op|']'
op|','
op|'['
name|'Selectable'
op|'('
op|')'
op|']'
op|')'
newline|'\n'
name|'jan'
op|'='
name|'_Janitor'
op|'('
name|'None'
op|','
name|'None'
op|','
name|'reactor'
op|'='
name|'reactor'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'jan'
op|'.'
name|'_cleanReactor'
op|'('
op|')'
op|','
op|'['
string|'"(SELECTABLE!)"'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_postCaseCleanupNoErrors
dedent|''
name|'def'
name|'test_postCaseCleanupNoErrors'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The post-case cleanup method will return True and not call C{addError}\n        on the result if there are no pending calls.\n        """'
newline|'\n'
name|'reactor'
op|'='
name|'StubReactor'
op|'('
op|'['
op|']'
op|')'
newline|'\n'
name|'test'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
name|'reporter'
op|'='
name|'StubErrorReporter'
op|'('
op|')'
newline|'\n'
name|'jan'
op|'='
name|'_Janitor'
op|'('
name|'test'
op|','
name|'reporter'
op|','
name|'reactor'
op|'='
name|'reactor'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'jan'
op|'.'
name|'postCaseCleanup'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'reporter'
op|'.'
name|'errors'
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_postCaseCleanupWithErrors
dedent|''
name|'def'
name|'test_postCaseCleanupWithErrors'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The post-case cleanup method will return False and call C{addError} on\n        the result with a L{DirtyReactorAggregateError} Failure if there are\n        pending calls.\n        """'
newline|'\n'
name|'delayedCall'
op|'='
name|'DelayedCall'
op|'('
number|'300'
op|','
name|'lambda'
op|':'
name|'None'
op|','
op|'('
op|')'
op|','
op|'{'
op|'}'
op|','
nl|'\n'
name|'lambda'
name|'x'
op|':'
name|'None'
op|','
name|'lambda'
name|'x'
op|':'
name|'None'
op|','
nl|'\n'
name|'seconds'
op|'='
name|'lambda'
op|':'
number|'0'
op|')'
newline|'\n'
name|'delayedCallString'
op|'='
name|'str'
op|'('
name|'delayedCall'
op|')'
newline|'\n'
name|'reactor'
op|'='
name|'StubReactor'
op|'('
op|'['
name|'delayedCall'
op|']'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'test'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
name|'reporter'
op|'='
name|'StubErrorReporter'
op|'('
op|')'
newline|'\n'
name|'jan'
op|'='
name|'_Janitor'
op|'('
name|'test'
op|','
name|'reporter'
op|','
name|'reactor'
op|'='
name|'reactor'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'jan'
op|'.'
name|'postCaseCleanup'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'reporter'
op|'.'
name|'errors'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'reporter'
op|'.'
name|'errors'
op|'['
number|'0'
op|']'
op|'['
number|'1'
op|']'
op|'.'
name|'value'
op|'.'
name|'delayedCalls'
op|','
nl|'\n'
op|'['
name|'delayedCallString'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_postClassCleanupNoErrors
dedent|''
name|'def'
name|'test_postClassCleanupNoErrors'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The post-class cleanup method will not call C{addError} on the result\n        if there are no pending calls or selectables.\n        """'
newline|'\n'
name|'reactor'
op|'='
name|'StubReactor'
op|'('
op|'['
op|']'
op|')'
newline|'\n'
name|'test'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
name|'reporter'
op|'='
name|'StubErrorReporter'
op|'('
op|')'
newline|'\n'
name|'jan'
op|'='
name|'_Janitor'
op|'('
name|'test'
op|','
name|'reporter'
op|','
name|'reactor'
op|'='
name|'reactor'
op|')'
newline|'\n'
name|'jan'
op|'.'
name|'postClassCleanup'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'reporter'
op|'.'
name|'errors'
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_postClassCleanupWithPendingCallErrors
dedent|''
name|'def'
name|'test_postClassCleanupWithPendingCallErrors'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The post-class cleanup method call C{addError} on the result with a\n        L{DirtyReactorAggregateError} Failure if there are pending calls.\n        """'
newline|'\n'
name|'delayedCall'
op|'='
name|'DelayedCall'
op|'('
number|'300'
op|','
name|'lambda'
op|':'
name|'None'
op|','
op|'('
op|')'
op|','
op|'{'
op|'}'
op|','
nl|'\n'
name|'lambda'
name|'x'
op|':'
name|'None'
op|','
name|'lambda'
name|'x'
op|':'
name|'None'
op|','
nl|'\n'
name|'seconds'
op|'='
name|'lambda'
op|':'
number|'0'
op|')'
newline|'\n'
name|'delayedCallString'
op|'='
name|'str'
op|'('
name|'delayedCall'
op|')'
newline|'\n'
name|'reactor'
op|'='
name|'StubReactor'
op|'('
op|'['
name|'delayedCall'
op|']'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'test'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
name|'reporter'
op|'='
name|'StubErrorReporter'
op|'('
op|')'
newline|'\n'
name|'jan'
op|'='
name|'_Janitor'
op|'('
name|'test'
op|','
name|'reporter'
op|','
name|'reactor'
op|'='
name|'reactor'
op|')'
newline|'\n'
name|'jan'
op|'.'
name|'postClassCleanup'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'reporter'
op|'.'
name|'errors'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'reporter'
op|'.'
name|'errors'
op|'['
number|'0'
op|']'
op|'['
number|'1'
op|']'
op|'.'
name|'value'
op|'.'
name|'delayedCalls'
op|','
nl|'\n'
op|'['
name|'delayedCallString'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_postClassCleanupWithSelectableErrors
dedent|''
name|'def'
name|'test_postClassCleanupWithSelectableErrors'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The post-class cleanup method call C{addError} on the result with a\n        L{DirtyReactorAggregateError} Failure if there are selectables.\n        """'
newline|'\n'
name|'selectable'
op|'='
string|'"SELECTABLE HERE"'
newline|'\n'
name|'reactor'
op|'='
name|'StubReactor'
op|'('
op|'['
op|']'
op|','
op|'['
name|'selectable'
op|']'
op|')'
newline|'\n'
name|'test'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
name|'reporter'
op|'='
name|'StubErrorReporter'
op|'('
op|')'
newline|'\n'
name|'jan'
op|'='
name|'_Janitor'
op|'('
name|'test'
op|','
name|'reporter'
op|','
name|'reactor'
op|'='
name|'reactor'
op|')'
newline|'\n'
name|'jan'
op|'.'
name|'postClassCleanup'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'reporter'
op|'.'
name|'errors'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'reporter'
op|'.'
name|'errors'
op|'['
number|'0'
op|']'
op|'['
number|'1'
op|']'
op|'.'
name|'value'
op|'.'
name|'selectables'
op|','
nl|'\n'
op|'['
name|'repr'
op|'('
name|'selectable'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
