begin_unit
comment|'# -*- test-case-name: twisted.test.test_modules -*-'
nl|'\n'
comment|'# Copyright (c) 2006-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nThis module aims to provide a unified, object-oriented view of Python\'s\nruntime hierarchy.\n\nPython is a very dynamic language with wide variety of introspection utilities.\nHowever, these utilities can be hard to use, because there is no consistent\nAPI.  The introspection API in python is made up of attributes (__name__,\n__module__, func_name, etc) on instances, modules, classes and functions which\nvary between those four types, utility modules such as \'inspect\' which provide\nsome functionality, the \'imp\' module, the "compiler" module, the semantics of\nPEP 302 support, and setuptools, among other things.\n\nAt the top, you have "PythonPath", an abstract representation of sys.path which\nincludes methods to locate top-level modules, with or without loading them.\nThe top-level exposed functions in this module for accessing the system path\nare "walkModules", "iterModules", and "getModule".\n\nFrom most to least specific, here are the objects provided::\n\n                  PythonPath  # sys.path\n                      |\n                      v\n                  PathEntry   # one entry on sys.path: an importer\n                      |\n                      v\n                 PythonModule # a module or package that can be loaded\n                      |\n                      v\n                 PythonAttribute # an attribute of a module (function or class)\n                      |\n                      v\n                 PythonAttribute # an attribute of a function or class\n                      |\n                      v\n                     ...\n\nHere\'s an example of idiomatic usage: this is what you would do to list all of\nthe modules outside the standard library\'s python-files directory::\n\n    import os\n    stdlibdir = os.path.dirname(os.__file__)\n\n    from twisted.python.modules import iterModules\n\n    for modinfo in iterModules():\n        if (modinfo.pathEntry.filePath.path != stdlibdir\n            and not modinfo.isPackage()):\n            print \'unpackaged: %s: %s\' % (\n                modinfo.name, modinfo.filePath.path)\n"""'
newline|'\n'
nl|'\n'
DECL|variable|__metaclass__
name|'__metaclass__'
op|'='
name|'type'
newline|'\n'
nl|'\n'
comment|"# let's try to keep path imports to a minimum..."
nl|'\n'
name|'from'
name|'os'
op|'.'
name|'path'
name|'import'
name|'dirname'
op|','
name|'split'
name|'as'
name|'splitpath'
newline|'\n'
nl|'\n'
name|'import'
name|'sys'
newline|'\n'
name|'import'
name|'zipimport'
newline|'\n'
name|'import'
name|'inspect'
newline|'\n'
name|'import'
name|'warnings'
newline|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'Interface'
op|','
name|'implements'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'components'
name|'import'
name|'registerAdapter'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'filepath'
name|'import'
name|'FilePath'
op|','
name|'UnlistableError'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'zippath'
name|'import'
name|'ZipArchive'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'reflect'
name|'import'
name|'namedAny'
newline|'\n'
nl|'\n'
DECL|variable|_nothing
name|'_nothing'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|variable|PYTHON_EXTENSIONS
name|'PYTHON_EXTENSIONS'
op|'='
op|'['
string|"'.py'"
op|']'
newline|'\n'
DECL|variable|OPTIMIZED_MODE
name|'OPTIMIZED_MODE'
op|'='
name|'__doc__'
name|'is'
name|'None'
newline|'\n'
name|'if'
name|'OPTIMIZED_MODE'
op|':'
newline|'\n'
indent|'    '
name|'PYTHON_EXTENSIONS'
op|'.'
name|'append'
op|'('
string|"'.pyo'"
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'    '
name|'PYTHON_EXTENSIONS'
op|'.'
name|'append'
op|'('
string|"'.pyc'"
op|')'
newline|'\n'
nl|'\n'
DECL|function|_isPythonIdentifier
dedent|''
name|'def'
name|'_isPythonIdentifier'
op|'('
name|'string'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    cheezy fake test for proper identifier-ness.\n\n    @param string: a str which might or might not be a valid python identifier.\n\n    @return: True or False\n    """'
newline|'\n'
name|'return'
op|'('
string|"' '"
name|'not'
name|'in'
name|'string'
name|'and'
nl|'\n'
string|"'.'"
name|'not'
name|'in'
name|'string'
name|'and'
nl|'\n'
string|"'-'"
name|'not'
name|'in'
name|'string'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|_isPackagePath
dedent|''
name|'def'
name|'_isPackagePath'
op|'('
name|'fpath'
op|')'
op|':'
newline|'\n'
comment|'# Determine if a FilePath-like object is a Python package.  TODO: deal with'
nl|'\n'
comment|'# __init__module.(so|dll|pyd)?'
nl|'\n'
indent|'    '
name|'extless'
op|'='
name|'fpath'
op|'.'
name|'splitext'
op|'('
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'basend'
op|'='
name|'splitpath'
op|'('
name|'extless'
op|')'
op|'['
number|'1'
op|']'
newline|'\n'
name|'return'
name|'basend'
op|'=='
string|'"__init__"'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|_ModuleIteratorHelper
dedent|''
name|'class'
name|'_ModuleIteratorHelper'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    This mixin provides common behavior between python module and path entries,\n    since the mechanism for searching sys.path and __path__ attributes is\n    remarkably similar.\n    """'
newline|'\n'
nl|'\n'
DECL|member|iterModules
name|'def'
name|'iterModules'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Loop over the modules present below this entry or package on PYTHONPATH.\n\n        For modules which are not packages, this will yield nothing.\n\n        For packages and path entries, this will only yield modules one level\n        down; i.e. if there is a package a.b.c, iterModules on a will only\n        return a.b.  If you want to descend deeply, use walkModules.\n\n        @return: a generator which yields PythonModule instances that describe\n        modules which can be, or have been, imported.\n        """'
newline|'\n'
name|'yielded'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'filePath'
op|'.'
name|'exists'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'placeToLook'
name|'in'
name|'self'
op|'.'
name|'_packagePaths'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'children'
op|'='
name|'placeToLook'
op|'.'
name|'children'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'UnlistableError'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'children'
op|'.'
name|'sort'
op|'('
op|')'
newline|'\n'
name|'for'
name|'potentialTopLevel'
name|'in'
name|'children'
op|':'
newline|'\n'
indent|'                '
name|'ext'
op|'='
name|'potentialTopLevel'
op|'.'
name|'splitext'
op|'('
op|')'
op|'['
number|'1'
op|']'
newline|'\n'
name|'potentialBasename'
op|'='
name|'potentialTopLevel'
op|'.'
name|'basename'
op|'('
op|')'
op|'['
op|':'
op|'-'
name|'len'
op|'('
name|'ext'
op|')'
op|']'
newline|'\n'
name|'if'
name|'ext'
name|'in'
name|'PYTHON_EXTENSIONS'
op|':'
newline|'\n'
comment|'# TODO: this should be a little choosier about which path entry'
nl|'\n'
comment|'# it selects first, and it should do all the .so checking and'
nl|'\n'
comment|'# crud'
nl|'\n'
indent|'                    '
name|'if'
name|'not'
name|'_isPythonIdentifier'
op|'('
name|'potentialBasename'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'continue'
newline|'\n'
dedent|''
name|'modname'
op|'='
name|'self'
op|'.'
name|'_subModuleName'
op|'('
name|'potentialBasename'
op|')'
newline|'\n'
name|'if'
name|'modname'
op|'.'
name|'split'
op|'('
string|'"."'
op|')'
op|'['
op|'-'
number|'1'
op|']'
op|'=='
string|"'__init__'"
op|':'
newline|'\n'
comment|"# This marks the directory as a package so it can't be"
nl|'\n'
comment|'# a module.'
nl|'\n'
indent|'                        '
name|'continue'
newline|'\n'
dedent|''
name|'if'
name|'modname'
name|'not'
name|'in'
name|'yielded'
op|':'
newline|'\n'
indent|'                        '
name|'yielded'
op|'['
name|'modname'
op|']'
op|'='
name|'True'
newline|'\n'
name|'pm'
op|'='
name|'PythonModule'
op|'('
name|'modname'
op|','
name|'potentialTopLevel'
op|','
name|'self'
op|'.'
name|'_getEntry'
op|'('
op|')'
op|')'
newline|'\n'
name|'assert'
name|'pm'
op|'!='
name|'self'
newline|'\n'
name|'yield'
name|'pm'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'if'
op|'('
name|'ext'
name|'or'
name|'not'
name|'_isPythonIdentifier'
op|'('
name|'potentialBasename'
op|')'
nl|'\n'
name|'or'
name|'not'
name|'potentialTopLevel'
op|'.'
name|'isdir'
op|'('
op|')'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'continue'
newline|'\n'
dedent|''
name|'modname'
op|'='
name|'self'
op|'.'
name|'_subModuleName'
op|'('
name|'potentialTopLevel'
op|'.'
name|'basename'
op|'('
op|')'
op|')'
newline|'\n'
name|'for'
name|'ext'
name|'in'
name|'PYTHON_EXTENSIONS'
op|':'
newline|'\n'
indent|'                        '
name|'initpy'
op|'='
name|'potentialTopLevel'
op|'.'
name|'child'
op|'('
string|'"__init__"'
op|'+'
name|'ext'
op|')'
newline|'\n'
name|'if'
name|'initpy'
op|'.'
name|'exists'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                            '
name|'yielded'
op|'['
name|'modname'
op|']'
op|'='
name|'True'
newline|'\n'
name|'pm'
op|'='
name|'PythonModule'
op|'('
name|'modname'
op|','
name|'initpy'
op|','
name|'self'
op|'.'
name|'_getEntry'
op|'('
op|')'
op|')'
newline|'\n'
name|'assert'
name|'pm'
op|'!='
name|'self'
newline|'\n'
name|'yield'
name|'pm'
newline|'\n'
name|'break'
newline|'\n'
nl|'\n'
DECL|member|walkModules
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'walkModules'
op|'('
name|'self'
op|','
name|'importPackages'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Similar to L{iterModules}, this yields self, and then every module in my\n        package or entry, and every submodule in each package or entry.\n\n        In other words, this is deep, and L{iterModules} is shallow.\n        """'
newline|'\n'
name|'yield'
name|'self'
newline|'\n'
name|'for'
name|'package'
name|'in'
name|'self'
op|'.'
name|'iterModules'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'module'
name|'in'
name|'package'
op|'.'
name|'walkModules'
op|'('
name|'importPackages'
op|'='
name|'importPackages'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'yield'
name|'module'
newline|'\n'
nl|'\n'
DECL|member|_subModuleName
dedent|''
dedent|''
dedent|''
name|'def'
name|'_subModuleName'
op|'('
name|'self'
op|','
name|'mn'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        This is a hook to provide packages with the ability to specify their names\n        as a prefix to submodules here.\n        """'
newline|'\n'
name|'return'
name|'mn'
newline|'\n'
nl|'\n'
DECL|member|_packagePaths
dedent|''
name|'def'
name|'_packagePaths'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Implement in subclasses to specify where to look for modules.\n\n        @return: iterable of FilePath-like objects.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_getEntry
dedent|''
name|'def'
name|'_getEntry'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Implement in subclasses to specify what path entry submodules will come\n        from.\n\n        @return: a PathEntry instance.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__getitem__
dedent|''
name|'def'
name|'__getitem__'
op|'('
name|'self'
op|','
name|'modname'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Retrieve a module from below this path or package.\n\n        @param modname: a str naming a module to be loaded.  For entries, this\n        is a top-level, undotted package name, and for packages it is the name\n        of the module without the package prefix.  For example, if you have a\n        PythonModule representing the \'twisted\' package, you could use::\n\n            twistedPackageObj[\'python\'][\'modules\']\n\n        to retrieve this module.\n\n        @raise: KeyError if the module is not found.\n\n        @return: a PythonModule.\n        """'
newline|'\n'
name|'for'
name|'module'
name|'in'
name|'self'
op|'.'
name|'iterModules'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'module'
op|'.'
name|'name'
op|'=='
name|'self'
op|'.'
name|'_subModuleName'
op|'('
name|'modname'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'module'
newline|'\n'
dedent|''
dedent|''
name|'raise'
name|'KeyError'
op|'('
name|'modname'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__iter__
dedent|''
name|'def'
name|'__iter__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Implemented to raise NotImplementedError for clarity, so that attempting to\n        loop over this object won\'t call __getitem__.\n\n        Note: in the future there might be some sensible default for iteration,\n        like \'walkEverything\', so this is deliberately untested and undefined\n        behavior.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|class|PythonAttribute
dedent|''
dedent|''
name|'class'
name|'PythonAttribute'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    I represent a function, class, or other object that is present.\n\n    @ivar name: the fully-qualified python name of this attribute.\n\n    @ivar onObject: a reference to a PythonModule or other PythonAttribute that\n    is this attribute\'s logical parent.\n\n    @ivar name: the fully qualified python name of the attribute represented by\n    this class.\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'name'
op|','
name|'onObject'
op|','
name|'loaded'
op|','
name|'pythonValue'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a PythonAttribute.  This is a private constructor.  Do not construct\n        me directly, use PythonModule.iterAttributes.\n\n        @param name: the FQPN\n        @param onObject: see ivar\n        @param loaded: always True, for now\n        @param pythonValue: the value of the attribute we\'re pointing to.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'name'
op|'='
name|'name'
newline|'\n'
name|'self'
op|'.'
name|'onObject'
op|'='
name|'onObject'
newline|'\n'
name|'self'
op|'.'
name|'_loaded'
op|'='
name|'loaded'
newline|'\n'
name|'self'
op|'.'
name|'pythonValue'
op|'='
name|'pythonValue'
newline|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|"'PythonAttribute<%r>'"
op|'%'
op|'('
name|'self'
op|'.'
name|'name'
op|','
op|')'
newline|'\n'
nl|'\n'
DECL|member|isLoaded
dedent|''
name|'def'
name|'isLoaded'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a boolean describing whether the attribute this describes has\n        actually been loaded into memory by importing its module.\n\n        Note: this currently always returns true; there is no Python parser\n        support in this module yet.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_loaded'
newline|'\n'
nl|'\n'
DECL|member|load
dedent|''
name|'def'
name|'load'
op|'('
name|'self'
op|','
name|'default'
op|'='
name|'_nothing'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Load the value associated with this attribute.\n\n        @return: an arbitrary Python object, or \'default\' if there is an error\n        loading it.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'pythonValue'
newline|'\n'
nl|'\n'
DECL|member|iterAttributes
dedent|''
name|'def'
name|'iterAttributes'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'name'
op|','
name|'val'
name|'in'
name|'inspect'
op|'.'
name|'getmembers'
op|'('
name|'self'
op|'.'
name|'load'
op|'('
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'yield'
name|'PythonAttribute'
op|'('
name|'self'
op|'.'
name|'name'
op|'+'
string|"'.'"
op|'+'
name|'name'
op|','
name|'self'
op|','
name|'True'
op|','
name|'val'
op|')'
newline|'\n'
nl|'\n'
DECL|class|PythonModule
dedent|''
dedent|''
dedent|''
name|'class'
name|'PythonModule'
op|'('
name|'_ModuleIteratorHelper'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Representation of a module which could be imported from sys.path.\n\n    @ivar name: the fully qualified python name of this module.\n\n    @ivar filePath: a FilePath-like object which points to the location of this\n    module.\n\n    @ivar pathEntry: a L{PathEntry} instance which this module was located\n    from.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'name'
op|','
name|'filePath'
op|','
name|'pathEntry'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a PythonModule.  Do not construct this directly, instead inspect a\n        PythonPath or other PythonModule instances.\n\n        @param name: see ivar\n        @param filePath: see ivar\n        @param pathEntry: see ivar\n        """'
newline|'\n'
name|'assert'
name|'not'
name|'name'
op|'.'
name|'endswith'
op|'('
string|'".__init__"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'name'
op|'='
name|'name'
newline|'\n'
name|'self'
op|'.'
name|'filePath'
op|'='
name|'filePath'
newline|'\n'
name|'self'
op|'.'
name|'parentPath'
op|'='
name|'filePath'
op|'.'
name|'parent'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'pathEntry'
op|'='
name|'pathEntry'
newline|'\n'
nl|'\n'
DECL|member|_getEntry
dedent|''
name|'def'
name|'_getEntry'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'pathEntry'
newline|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a string representation including the module name.\n        """'
newline|'\n'
name|'return'
string|"'PythonModule<%r>'"
op|'%'
op|'('
name|'self'
op|'.'
name|'name'
op|','
op|')'
newline|'\n'
nl|'\n'
DECL|member|isLoaded
dedent|''
name|'def'
name|'isLoaded'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Determine if the module is loaded into sys.modules.\n\n        @return: a boolean: true if loaded, false if not.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'name'
name|'in'
name|'self'
op|'.'
name|'pathEntry'
op|'.'
name|'pythonPath'
op|'.'
name|'moduleDict'
newline|'\n'
nl|'\n'
DECL|member|iterAttributes
dedent|''
name|'def'
name|'iterAttributes'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        List all the attributes defined in this module.\n\n        Note: Future work is planned here to make it possible to list python\n        attributes on a module without loading the module by inspecting ASTs or\n        bytecode, but currently any iteration of PythonModule objects insists\n        they must be loaded, and will use inspect.getmodule.\n\n        @raise NotImplementedError: if this module is not loaded.\n\n        @return: a generator yielding PythonAttribute instances describing the\n        attributes of this module.\n        """'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'isLoaded'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'NotImplementedError'
op|'('
nl|'\n'
string|'"You can\'t load attributes from non-loaded modules yet."'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'name'
op|','
name|'val'
name|'in'
name|'inspect'
op|'.'
name|'getmembers'
op|'('
name|'self'
op|'.'
name|'load'
op|'('
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'yield'
name|'PythonAttribute'
op|'('
name|'self'
op|'.'
name|'name'
op|'+'
string|"'.'"
op|'+'
name|'name'
op|','
name|'self'
op|','
name|'True'
op|','
name|'val'
op|')'
newline|'\n'
nl|'\n'
DECL|member|isPackage
dedent|''
dedent|''
name|'def'
name|'isPackage'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns true if this module is also a package, and might yield something\n        from iterModules.\n        """'
newline|'\n'
name|'return'
name|'_isPackagePath'
op|'('
name|'self'
op|'.'
name|'filePath'
op|')'
newline|'\n'
nl|'\n'
DECL|member|load
dedent|''
name|'def'
name|'load'
op|'('
name|'self'
op|','
name|'default'
op|'='
name|'_nothing'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Load this module.\n\n        @param default: if specified, the value to return in case of an error.\n\n        @return: a genuine python module.\n\n        @raise: any type of exception.  Importing modules is a risky business;\n        the erorrs of any code run at module scope may be raised from here, as\n        well as ImportError if something bizarre happened to the system path\n        between the discovery of this PythonModule object and the attempt to\n        import it.  If you specify a default, the error will be swallowed\n        entirely, and not logged.\n\n        @rtype: types.ModuleType.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'pathEntry'
op|'.'
name|'pythonPath'
op|'.'
name|'moduleLoader'
op|'('
name|'self'
op|'.'
name|'name'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
comment|'# this needs more thought...'
newline|'\n'
indent|'            '
name|'if'
name|'default'
name|'is'
name|'not'
name|'_nothing'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'default'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
nl|'\n'
DECL|member|__eq__
dedent|''
dedent|''
name|'def'
name|'__eq__'
op|'('
name|'self'
op|','
name|'other'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        PythonModules with the same name are equal.\n        """'
newline|'\n'
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'other'
op|','
name|'PythonModule'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'return'
name|'other'
op|'.'
name|'name'
op|'=='
name|'self'
op|'.'
name|'name'
newline|'\n'
nl|'\n'
DECL|member|__ne__
dedent|''
name|'def'
name|'__ne__'
op|'('
name|'self'
op|','
name|'other'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        PythonModules with different names are not equal.\n        """'
newline|'\n'
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'other'
op|','
name|'PythonModule'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'return'
name|'other'
op|'.'
name|'name'
op|'!='
name|'self'
op|'.'
name|'name'
newline|'\n'
nl|'\n'
DECL|member|walkModules
dedent|''
name|'def'
name|'walkModules'
op|'('
name|'self'
op|','
name|'importPackages'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'importPackages'
name|'and'
name|'self'
op|'.'
name|'isPackage'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'load'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'super'
op|'('
name|'PythonModule'
op|','
name|'self'
op|')'
op|'.'
name|'walkModules'
op|'('
name|'importPackages'
op|'='
name|'importPackages'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_subModuleName
dedent|''
name|'def'
name|'_subModuleName'
op|'('
name|'self'
op|','
name|'mn'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        submodules of this module are prefixed with our name.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'name'
op|'+'
string|"'.'"
op|'+'
name|'mn'
newline|'\n'
nl|'\n'
DECL|member|_packagePaths
dedent|''
name|'def'
name|'_packagePaths'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Yield a sequence of FilePath-like objects which represent path segments.\n        """'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'isPackage'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'isLoaded'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'load'
op|'='
name|'self'
op|'.'
name|'load'
op|'('
op|')'
newline|'\n'
name|'if'
name|'hasattr'
op|'('
name|'load'
op|','
string|"'__path__'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'fn'
name|'in'
name|'load'
op|'.'
name|'__path__'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'fn'
op|'=='
name|'self'
op|'.'
name|'parentPath'
op|'.'
name|'path'
op|':'
newline|'\n'
comment|'# this should _really_ exist.'
nl|'\n'
indent|'                        '
name|'assert'
name|'self'
op|'.'
name|'parentPath'
op|'.'
name|'exists'
op|'('
op|')'
newline|'\n'
name|'yield'
name|'self'
op|'.'
name|'parentPath'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'smp'
op|'='
name|'self'
op|'.'
name|'pathEntry'
op|'.'
name|'pythonPath'
op|'.'
name|'_smartPath'
op|'('
name|'fn'
op|')'
newline|'\n'
name|'if'
name|'smp'
op|'.'
name|'exists'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                            '
name|'yield'
name|'smp'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'yield'
name|'self'
op|'.'
name|'parentPath'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|PathEntry
dedent|''
dedent|''
dedent|''
name|'class'
name|'PathEntry'
op|'('
name|'_ModuleIteratorHelper'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    I am a proxy for a single entry on sys.path.\n\n    @ivar filePath: a FilePath-like object pointing at the filesystem location\n    or archive file where this path entry is stored.\n\n    @ivar pythonPath: a PythonPath instance.\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'filePath'
op|','
name|'pythonPath'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a PathEntry.  This is a private constructor.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'filePath'
op|'='
name|'filePath'
newline|'\n'
name|'self'
op|'.'
name|'pythonPath'
op|'='
name|'pythonPath'
newline|'\n'
nl|'\n'
DECL|member|_getEntry
dedent|''
name|'def'
name|'_getEntry'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
newline|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|"'PathEntry<%r>'"
op|'%'
op|'('
name|'self'
op|'.'
name|'filePath'
op|','
op|')'
newline|'\n'
nl|'\n'
DECL|member|_packagePaths
dedent|''
name|'def'
name|'_packagePaths'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'yield'
name|'self'
op|'.'
name|'filePath'
newline|'\n'
nl|'\n'
DECL|class|IPathImportMapper
dedent|''
dedent|''
name|'class'
name|'IPathImportMapper'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    This is an internal interface, used to map importers to factories for\n    FilePath-like objects.\n    """'
newline|'\n'
DECL|member|mapPath
name|'def'
name|'mapPath'
op|'('
name|'self'
op|','
name|'pathLikeString'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a FilePath-like object.\n\n        @param pathLikeString: a path-like string, like one that might be\n        passed to an import hook.\n\n        @return: a L{FilePath}, or something like it (currently only a\n        L{ZipPath}, but more might be added later).\n        """'
newline|'\n'
nl|'\n'
DECL|class|_DefaultMapImpl
dedent|''
dedent|''
name|'class'
name|'_DefaultMapImpl'
op|':'
newline|'\n'
indent|'    '
string|'""" Wrapper for the default importer, i.e. None.  """'
newline|'\n'
name|'implements'
op|'('
name|'IPathImportMapper'
op|')'
newline|'\n'
DECL|member|mapPath
name|'def'
name|'mapPath'
op|'('
name|'self'
op|','
name|'fsPathString'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'FilePath'
op|'('
name|'fsPathString'
op|')'
newline|'\n'
DECL|variable|_theDefaultMapper
dedent|''
dedent|''
name|'_theDefaultMapper'
op|'='
name|'_DefaultMapImpl'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|class|_ZipMapImpl
name|'class'
name|'_ZipMapImpl'
op|':'
newline|'\n'
indent|'    '
string|'""" IPathImportMapper implementation for zipimport.ZipImporter.  """'
newline|'\n'
name|'implements'
op|'('
name|'IPathImportMapper'
op|')'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'importer'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'importer'
op|'='
name|'importer'
newline|'\n'
nl|'\n'
DECL|member|mapPath
dedent|''
name|'def'
name|'mapPath'
op|'('
name|'self'
op|','
name|'fsPathString'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Map the given FS path to a ZipPath, by looking at the ZipImporter\'s\n        "archive" attribute and using it as our ZipArchive root, then walking\n        down into the archive from there.\n\n        @return: a L{zippath.ZipPath} or L{zippath.ZipArchive} instance.\n        """'
newline|'\n'
name|'za'
op|'='
name|'ZipArchive'
op|'('
name|'self'
op|'.'
name|'importer'
op|'.'
name|'archive'
op|')'
newline|'\n'
name|'myPath'
op|'='
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'importer'
op|'.'
name|'archive'
op|')'
newline|'\n'
name|'itsPath'
op|'='
name|'FilePath'
op|'('
name|'fsPathString'
op|')'
newline|'\n'
name|'if'
name|'myPath'
op|'=='
name|'itsPath'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'za'
newline|'\n'
comment|'# This is NOT a general-purpose rule for sys.path or __file__:'
nl|'\n'
comment|'# zipimport specifically uses regular OS path syntax in its pathnames,'
nl|'\n'
comment|'# even though zip files specify that slashes are always the separator,'
nl|'\n'
comment|'# regardless of platform.'
nl|'\n'
dedent|''
name|'segs'
op|'='
name|'itsPath'
op|'.'
name|'segmentsFrom'
op|'('
name|'myPath'
op|')'
newline|'\n'
name|'zp'
op|'='
name|'za'
newline|'\n'
name|'for'
name|'seg'
name|'in'
name|'segs'
op|':'
newline|'\n'
indent|'            '
name|'zp'
op|'='
name|'zp'
op|'.'
name|'child'
op|'('
name|'seg'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'zp'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'registerAdapter'
op|'('
name|'_ZipMapImpl'
op|','
name|'zipimport'
op|'.'
name|'zipimporter'
op|','
name|'IPathImportMapper'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_defaultSysPathFactory
name|'def'
name|'_defaultSysPathFactory'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Provide the default behavior of PythonPath\'s sys.path factory, which is to\n    return the current value of sys.path.\n\n    @return: L{sys.path}\n    """'
newline|'\n'
name|'return'
name|'sys'
op|'.'
name|'path'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|PythonPath
dedent|''
name|'class'
name|'PythonPath'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    I represent the very top of the Python object-space, the module list in\n    sys.path and the modules list in sys.modules.\n\n    @ivar _sysPath: a sequence of strings like sys.path.  This attribute is\n    read-only.\n\n    @ivar moduleDict: a dictionary mapping string module names to module\n    objects, like sys.modules.\n\n    @ivar sysPathHooks: a list of PEP-302 path hooks, like sys.path_hooks.\n\n    @ivar moduleLoader: a function that takes a fully-qualified python name and\n    returns a module, like twisted.python.reflect.namedAny.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
nl|'\n'
name|'sysPath'
op|'='
name|'None'
op|','
nl|'\n'
name|'moduleDict'
op|'='
name|'sys'
op|'.'
name|'modules'
op|','
nl|'\n'
name|'sysPathHooks'
op|'='
name|'sys'
op|'.'
name|'path_hooks'
op|','
nl|'\n'
name|'importerCache'
op|'='
name|'sys'
op|'.'
name|'path_importer_cache'
op|','
nl|'\n'
name|'moduleLoader'
op|'='
name|'namedAny'
op|','
nl|'\n'
name|'sysPathFactory'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a PythonPath.  You almost certainly want to use\n        modules.theSystemPath, or its aliased methods, rather than creating a\n        new instance yourself, though.\n\n        All parameters are optional, and if unspecified, will use \'system\'\n        equivalents that makes this PythonPath like the global L{theSystemPath}\n        instance.\n\n        @param sysPath: a sys.path-like list to use for this PythonPath, to\n        specify where to load modules from.\n\n        @param moduleDict: a sys.modules-like dictionary to use for keeping\n        track of what modules this PythonPath has loaded.\n\n        @param sysPathHooks: sys.path_hooks-like list of PEP-302 path hooks to\n        be used for this PythonPath, to determie which importers should be\n        used.\n\n        @param importerCache: a sys.path_importer_cache-like list of PEP-302\n        importers.  This will be used in conjunction with the given\n        sysPathHooks.\n\n        @param moduleLoader: a module loader function which takes a string and\n        returns a module.  That is to say, it is like L{namedAny} - *not* like\n        L{__import__}.\n\n        @param sysPathFactory: a 0-argument callable which returns the current\n        value of a sys.path-like list of strings.  Specify either this, or\n        sysPath, not both.  This alternative interface is provided because the\n        way the Python import mechanism works, you can re-bind the \'sys.path\'\n        name and that is what is used for current imports, so it must be a\n        factory rather than a value to deal with modification by rebinding\n        rather than modification by mutation.  Note: it is not recommended to\n        rebind sys.path.  Although this mechanism can deal with that, it is a\n        subtle point which some tools that it is easy for tools which interact\n        with sys.path to miss.\n        """'
newline|'\n'
name|'if'
name|'sysPath'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'sysPathFactory'
op|'='
name|'lambda'
op|':'
name|'sysPath'
newline|'\n'
dedent|''
name|'elif'
name|'sysPathFactory'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'sysPathFactory'
op|'='
name|'_defaultSysPathFactory'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_sysPathFactory'
op|'='
name|'sysPathFactory'
newline|'\n'
name|'self'
op|'.'
name|'_sysPath'
op|'='
name|'sysPath'
newline|'\n'
name|'self'
op|'.'
name|'moduleDict'
op|'='
name|'moduleDict'
newline|'\n'
name|'self'
op|'.'
name|'sysPathHooks'
op|'='
name|'sysPathHooks'
newline|'\n'
name|'self'
op|'.'
name|'importerCache'
op|'='
name|'importerCache'
newline|'\n'
name|'self'
op|'.'
name|'moduleLoader'
op|'='
name|'moduleLoader'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_getSysPath
dedent|''
name|'def'
name|'_getSysPath'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Retrieve the current value of the module search path list.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_sysPathFactory'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|variable|sysPath
dedent|''
name|'sysPath'
op|'='
name|'property'
op|'('
name|'_getSysPath'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_findEntryPathString
name|'def'
name|'_findEntryPathString'
op|'('
name|'self'
op|','
name|'modobj'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Determine where a given Python module object came from by looking at path\n        entries.\n        """'
newline|'\n'
name|'topPackageObj'
op|'='
name|'modobj'
newline|'\n'
name|'while'
string|"'.'"
name|'in'
name|'topPackageObj'
op|'.'
name|'__name__'
op|':'
newline|'\n'
indent|'            '
name|'topPackageObj'
op|'='
name|'self'
op|'.'
name|'moduleDict'
op|'['
string|"'.'"
op|'.'
name|'join'
op|'('
nl|'\n'
name|'topPackageObj'
op|'.'
name|'__name__'
op|'.'
name|'split'
op|'('
string|"'.'"
op|')'
op|'['
op|':'
op|'-'
number|'1'
op|']'
op|')'
op|']'
newline|'\n'
dedent|''
name|'if'
name|'_isPackagePath'
op|'('
name|'FilePath'
op|'('
name|'topPackageObj'
op|'.'
name|'__file__'
op|')'
op|')'
op|':'
newline|'\n'
comment|"# if package 'foo' is on sys.path at /a/b/foo, package 'foo's"
nl|'\n'
comment|'# __file__ will be /a/b/foo/__init__.py, and we are looking for'
nl|'\n'
comment|'# /a/b here, the path-entry; so go up two steps.'
nl|'\n'
indent|'            '
name|'rval'
op|'='
name|'dirname'
op|'('
name|'dirname'
op|'('
name|'topPackageObj'
op|'.'
name|'__file__'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# the module is completely top-level, not within any packages.  The'
nl|'\n'
comment|"# path entry it's on is just its dirname."
nl|'\n'
indent|'            '
name|'rval'
op|'='
name|'dirname'
op|'('
name|'topPackageObj'
op|'.'
name|'__file__'
op|')'
newline|'\n'
nl|'\n'
comment|'# There are probably some awful tricks that an importer could pull'
nl|'\n'
comment|"# which would break this, so let's just make sure... it's a loaded"
nl|'\n'
comment|'# module after all, which means that its path MUST be in'
nl|'\n'
comment|'# path_importer_cache according to PEP 302 -glyph'
nl|'\n'
dedent|''
name|'if'
name|'rval'
name|'not'
name|'in'
name|'self'
op|'.'
name|'importerCache'
op|':'
newline|'\n'
indent|'            '
name|'warnings'
op|'.'
name|'warn'
op|'('
nl|'\n'
string|'"%s (for module %s) not in path importer cache "'
nl|'\n'
string|'"(PEP 302 violation - check your local configuration)."'
op|'%'
op|'('
nl|'\n'
name|'rval'
op|','
name|'modobj'
op|'.'
name|'__name__'
op|')'
op|','
nl|'\n'
name|'stacklevel'
op|'='
number|'3'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'rval'
newline|'\n'
nl|'\n'
DECL|member|_smartPath
dedent|''
name|'def'
name|'_smartPath'
op|'('
name|'self'
op|','
name|'pathName'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Given a path entry from sys.path which may refer to an importer,\n        return the appropriate FilePath-like instance.\n\n        @param pathName: a str describing the path.\n\n        @return: a FilePath-like object.\n        """'
newline|'\n'
name|'importr'
op|'='
name|'self'
op|'.'
name|'importerCache'
op|'.'
name|'get'
op|'('
name|'pathName'
op|','
name|'_nothing'
op|')'
newline|'\n'
name|'if'
name|'importr'
name|'is'
name|'_nothing'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'hook'
name|'in'
name|'self'
op|'.'
name|'sysPathHooks'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'importr'
op|'='
name|'hook'
op|'('
name|'pathName'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|','
name|'ie'
op|':'
newline|'\n'
indent|'                    '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'importr'
name|'is'
name|'_nothing'
op|':'
comment|'# still'
newline|'\n'
indent|'                '
name|'importr'
op|'='
name|'None'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'IPathImportMapper'
op|'('
name|'importr'
op|','
name|'_theDefaultMapper'
op|')'
op|'.'
name|'mapPath'
op|'('
name|'pathName'
op|')'
newline|'\n'
nl|'\n'
DECL|member|iterEntries
dedent|''
name|'def'
name|'iterEntries'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Iterate the entries on my sysPath.\n\n        @return: a generator yielding PathEntry objects\n        """'
newline|'\n'
name|'for'
name|'pathName'
name|'in'
name|'self'
op|'.'
name|'sysPath'
op|':'
newline|'\n'
indent|'            '
name|'fp'
op|'='
name|'self'
op|'.'
name|'_smartPath'
op|'('
name|'pathName'
op|')'
newline|'\n'
name|'yield'
name|'PathEntry'
op|'('
name|'fp'
op|','
name|'self'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__getitem__
dedent|''
dedent|''
name|'def'
name|'__getitem__'
op|'('
name|'self'
op|','
name|'modname'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Get a python module by a given fully-qualified name.\n\n        @return: a PythonModule object.\n\n        @raise: KeyError, if the module name is a module name.\n        """'
newline|'\n'
comment|'# See if the module is already somewhere in Python-land.'
nl|'\n'
name|'if'
name|'modname'
name|'in'
name|'self'
op|'.'
name|'moduleDict'
op|':'
newline|'\n'
comment|'# we need 2 paths; one of the path entry and one for the module.'
nl|'\n'
indent|'            '
name|'moduleObject'
op|'='
name|'self'
op|'.'
name|'moduleDict'
op|'['
name|'modname'
op|']'
newline|'\n'
name|'pe'
op|'='
name|'PathEntry'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_smartPath'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_findEntryPathString'
op|'('
name|'moduleObject'
op|')'
op|')'
op|','
nl|'\n'
name|'self'
op|')'
newline|'\n'
name|'mp'
op|'='
name|'self'
op|'.'
name|'_smartPath'
op|'('
name|'moduleObject'
op|'.'
name|'__file__'
op|')'
newline|'\n'
name|'return'
name|'PythonModule'
op|'('
name|'modname'
op|','
name|'mp'
op|','
name|'pe'
op|')'
newline|'\n'
nl|'\n'
comment|"# Recurse if we're trying to get a submodule."
nl|'\n'
dedent|''
name|'if'
string|"'.'"
name|'in'
name|'modname'
op|':'
newline|'\n'
indent|'            '
name|'pkg'
op|'='
name|'self'
newline|'\n'
name|'for'
name|'name'
name|'in'
name|'modname'
op|'.'
name|'split'
op|'('
string|"'.'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'pkg'
op|'='
name|'pkg'
op|'['
name|'name'
op|']'
newline|'\n'
dedent|''
name|'return'
name|'pkg'
newline|'\n'
nl|'\n'
comment|'# Finally do the slowest possible thing and iterate'
nl|'\n'
dedent|''
name|'for'
name|'module'
name|'in'
name|'self'
op|'.'
name|'iterModules'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'module'
op|'.'
name|'name'
op|'=='
name|'modname'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'module'
newline|'\n'
dedent|''
dedent|''
name|'raise'
name|'KeyError'
op|'('
name|'modname'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Display my sysPath and moduleDict in a string representation.\n        """'
newline|'\n'
name|'return'
string|'"PythonPath(%r,%r)"'
op|'%'
op|'('
name|'self'
op|'.'
name|'sysPath'
op|','
name|'self'
op|'.'
name|'moduleDict'
op|')'
newline|'\n'
nl|'\n'
DECL|member|iterModules
dedent|''
name|'def'
name|'iterModules'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Yield all top-level modules on my sysPath.\n        """'
newline|'\n'
name|'for'
name|'entry'
name|'in'
name|'self'
op|'.'
name|'iterEntries'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'module'
name|'in'
name|'entry'
op|'.'
name|'iterModules'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'yield'
name|'module'
newline|'\n'
nl|'\n'
DECL|member|walkModules
dedent|''
dedent|''
dedent|''
name|'def'
name|'walkModules'
op|'('
name|'self'
op|','
name|'importPackages'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Similar to L{iterModules}, this yields every module on the path, then every\n        submodule in each package or entry.\n        """'
newline|'\n'
name|'for'
name|'package'
name|'in'
name|'self'
op|'.'
name|'iterModules'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'module'
name|'in'
name|'package'
op|'.'
name|'walkModules'
op|'('
name|'importPackages'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'yield'
name|'module'
newline|'\n'
nl|'\n'
DECL|variable|theSystemPath
dedent|''
dedent|''
dedent|''
dedent|''
name|'theSystemPath'
op|'='
name|'PythonPath'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|walkModules
name|'def'
name|'walkModules'
op|'('
name|'importPackages'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Deeply iterate all modules on the global python path.\n\n    @param importPackages: Import packages as they are seen.\n    """'
newline|'\n'
name|'return'
name|'theSystemPath'
op|'.'
name|'walkModules'
op|'('
name|'importPackages'
op|'='
name|'importPackages'
op|')'
newline|'\n'
nl|'\n'
DECL|function|iterModules
dedent|''
name|'def'
name|'iterModules'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Iterate all modules and top-level packages on the global Python path, but\n    do not descend into packages.\n\n    @param importPackages: Import packages as they are seen.\n    """'
newline|'\n'
name|'return'
name|'theSystemPath'
op|'.'
name|'iterModules'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|getModule
dedent|''
name|'def'
name|'getModule'
op|'('
name|'moduleName'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Retrieve a module from the system path.\n    """'
newline|'\n'
name|'return'
name|'theSystemPath'
op|'['
name|'moduleName'
op|']'
newline|'\n'
dedent|''
endmarker|''
end_unit
