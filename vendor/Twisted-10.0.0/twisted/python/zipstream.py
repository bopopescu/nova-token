begin_unit
comment|'# -*- test-case-name: twisted.python.test.test_zipstream -*-'
nl|'\n'
comment|'# Copyright (c) 2001-2008 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nAn incremental approach to unzipping files.  This allows you to unzip a little\nbit of a file at a time, which means you can report progress as a file unzips.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'warnings'
newline|'\n'
name|'import'
name|'zipfile'
newline|'\n'
name|'import'
name|'os'
op|'.'
name|'path'
newline|'\n'
name|'import'
name|'zlib'
newline|'\n'
name|'import'
name|'struct'
newline|'\n'
nl|'\n'
DECL|variable|_fileHeaderSize
name|'_fileHeaderSize'
op|'='
name|'struct'
op|'.'
name|'calcsize'
op|'('
name|'zipfile'
op|'.'
name|'structFileHeader'
op|')'
newline|'\n'
nl|'\n'
DECL|class|ChunkingZipFile
name|'class'
name|'ChunkingZipFile'
op|'('
name|'zipfile'
op|'.'
name|'ZipFile'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A ZipFile object which, with readfile(), also gives you access to a\n    filelike object for each entry.\n    """'
newline|'\n'
nl|'\n'
DECL|member|readfile
name|'def'
name|'readfile'
op|'('
name|'self'
op|','
name|'name'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return file-like object for name.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'mode'
name|'not'
name|'in'
op|'('
string|'"r"'
op|','
string|'"a"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'RuntimeError'
op|'('
string|'\'read() requires mode "r" or "a"\''
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'fp'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'RuntimeError'
op|'('
nl|'\n'
string|'"Attempt to read ZIP archive that was already closed"'
op|')'
newline|'\n'
dedent|''
name|'zinfo'
op|'='
name|'self'
op|'.'
name|'getinfo'
op|'('
name|'name'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'fp'
op|'.'
name|'seek'
op|'('
name|'zinfo'
op|'.'
name|'header_offset'
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
name|'fheader'
op|'='
name|'self'
op|'.'
name|'fp'
op|'.'
name|'read'
op|'('
name|'_fileHeaderSize'
op|')'
newline|'\n'
name|'if'
name|'fheader'
op|'['
number|'0'
op|':'
number|'4'
op|']'
op|'!='
name|'zipfile'
op|'.'
name|'stringFileHeader'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'zipfile'
op|'.'
name|'BadZipfile'
op|'('
string|'"Bad magic number for file header"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'fheader'
op|'='
name|'struct'
op|'.'
name|'unpack'
op|'('
name|'zipfile'
op|'.'
name|'structFileHeader'
op|','
name|'fheader'
op|')'
newline|'\n'
name|'fname'
op|'='
name|'self'
op|'.'
name|'fp'
op|'.'
name|'read'
op|'('
name|'fheader'
op|'['
name|'zipfile'
op|'.'
name|'_FH_FILENAME_LENGTH'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'fheader'
op|'['
name|'zipfile'
op|'.'
name|'_FH_EXTRA_FIELD_LENGTH'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'fp'
op|'.'
name|'read'
op|'('
name|'fheader'
op|'['
name|'zipfile'
op|'.'
name|'_FH_EXTRA_FIELD_LENGTH'
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'fname'
op|'!='
name|'zinfo'
op|'.'
name|'orig_filename'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'zipfile'
op|'.'
name|'BadZipfile'
op|'('
nl|'\n'
string|'\'File name in directory "%s" and header "%s" differ.\''
op|'%'
op|'('
nl|'\n'
name|'zinfo'
op|'.'
name|'orig_filename'
op|','
name|'fname'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'zinfo'
op|'.'
name|'compress_type'
op|'=='
name|'zipfile'
op|'.'
name|'ZIP_STORED'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'ZipFileEntry'
op|'('
name|'self'
op|','
name|'zinfo'
op|'.'
name|'compress_size'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'zinfo'
op|'.'
name|'compress_type'
op|'=='
name|'zipfile'
op|'.'
name|'ZIP_DEFLATED'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'DeflatedZipFileEntry'
op|'('
name|'self'
op|','
name|'zinfo'
op|'.'
name|'compress_size'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'zipfile'
op|'.'
name|'BadZipfile'
op|'('
nl|'\n'
string|'"Unsupported compression method %d for file %s"'
op|'%'
nl|'\n'
op|'('
name|'zinfo'
op|'.'
name|'compress_type'
op|','
name|'name'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|_FileEntry
dedent|''
dedent|''
dedent|''
name|'class'
name|'_FileEntry'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Abstract superclass of both compressed and uncompressed variants of\n    file-like objects within a zip archive.\n\n    @ivar chunkingZipFile: a chunking zip file.\n    @type chunkingZipFile: L{ChunkingZipFile}\n\n    @ivar length: The number of bytes within the zip file that represent this\n    file.  (This is the size on disk, not the number of decompressed bytes\n    which will result from reading it.)\n\n    @ivar fp: the underlying file object (that contains pkzip data).  Do not\n    touch this, please.  It will quite likely move or go away.\n\n    @ivar closed: File-like \'closed\' attribute; True before this file has been\n    closed, False after.\n    @type closed: L{bool}\n\n    @ivar finished: An older, broken synonym for \'closed\'.  Do not touch this,\n    please.\n    @type finished: L{int}\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'chunkingZipFile'
op|','
name|'length'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a L{_FileEntry} from a L{ChunkingZipFile}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'chunkingZipFile'
op|'='
name|'chunkingZipFile'
newline|'\n'
name|'self'
op|'.'
name|'fp'
op|'='
name|'self'
op|'.'
name|'chunkingZipFile'
op|'.'
name|'fp'
newline|'\n'
name|'self'
op|'.'
name|'length'
op|'='
name|'length'
newline|'\n'
name|'self'
op|'.'
name|'finished'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'closed'
op|'='
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|isatty
dedent|''
name|'def'
name|'isatty'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns false because zip files should not be ttys\n        """'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|close
dedent|''
name|'def'
name|'close'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Close self (file-like object)\n        """'
newline|'\n'
name|'self'
op|'.'
name|'closed'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'finished'
op|'='
number|'1'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'fp'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|readline
dedent|''
name|'def'
name|'readline'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Read a line.\n        """'
newline|'\n'
name|'bytes'
op|'='
string|'""'
newline|'\n'
name|'for'
name|'byte'
name|'in'
name|'iter'
op|'('
name|'lambda'
op|':'
name|'self'
op|'.'
name|'read'
op|'('
number|'1'
op|')'
op|','
string|'""'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'bytes'
op|'+='
name|'byte'
newline|'\n'
name|'if'
name|'byte'
op|'=='
string|'"\\n"'
op|':'
newline|'\n'
indent|'                '
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'bytes'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|next
dedent|''
name|'def'
name|'next'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Implement next as file does (like readline, except raises StopIteration\n        at EOF)\n        """'
newline|'\n'
name|'nextline'
op|'='
name|'self'
op|'.'
name|'readline'
op|'('
op|')'
newline|'\n'
name|'if'
name|'nextline'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'nextline'
newline|'\n'
dedent|''
name|'raise'
name|'StopIteration'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|readlines
dedent|''
name|'def'
name|'readlines'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns a list of all the lines\n        """'
newline|'\n'
name|'return'
name|'list'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|xreadlines
dedent|''
name|'def'
name|'xreadlines'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns an iterator (so self)\n        """'
newline|'\n'
name|'return'
name|'self'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__iter__
dedent|''
name|'def'
name|'__iter__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns an iterator (so self)\n        """'
newline|'\n'
name|'return'
name|'self'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ZipFileEntry
dedent|''
dedent|''
name|'class'
name|'ZipFileEntry'
op|'('
name|'_FileEntry'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    File-like object used to read an uncompressed entry in a ZipFile\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'chunkingZipFile'
op|','
name|'length'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'_FileEntry'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'chunkingZipFile'
op|','
name|'length'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'readBytes'
op|'='
number|'0'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tell
dedent|''
name|'def'
name|'tell'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'readBytes'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|read
dedent|''
name|'def'
name|'read'
op|'('
name|'self'
op|','
name|'n'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'n'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'n'
op|'='
name|'self'
op|'.'
name|'length'
op|'-'
name|'self'
op|'.'
name|'readBytes'
newline|'\n'
dedent|''
name|'if'
name|'n'
op|'=='
number|'0'
name|'or'
name|'self'
op|'.'
name|'finished'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"''"
newline|'\n'
dedent|''
name|'data'
op|'='
name|'self'
op|'.'
name|'chunkingZipFile'
op|'.'
name|'fp'
op|'.'
name|'read'
op|'('
nl|'\n'
name|'min'
op|'('
name|'n'
op|','
name|'self'
op|'.'
name|'length'
op|'-'
name|'self'
op|'.'
name|'readBytes'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'readBytes'
op|'+='
name|'len'
op|'('
name|'data'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'readBytes'
op|'=='
name|'self'
op|'.'
name|'length'
name|'or'
name|'len'
op|'('
name|'data'
op|')'
op|'<'
name|'n'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'finished'
op|'='
number|'1'
newline|'\n'
dedent|''
name|'return'
name|'data'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DeflatedZipFileEntry
dedent|''
dedent|''
name|'class'
name|'DeflatedZipFileEntry'
op|'('
name|'_FileEntry'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    File-like object used to read a deflated entry in a ZipFile\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'chunkingZipFile'
op|','
name|'length'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'_FileEntry'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'chunkingZipFile'
op|','
name|'length'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'returnedBytes'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'readBytes'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'decomp'
op|'='
name|'zlib'
op|'.'
name|'decompressobj'
op|'('
op|'-'
number|'15'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'buffer'
op|'='
string|'""'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tell
dedent|''
name|'def'
name|'tell'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'returnedBytes'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|read
dedent|''
name|'def'
name|'read'
op|'('
name|'self'
op|','
name|'n'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'finished'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|'""'
newline|'\n'
dedent|''
name|'if'
name|'n'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'='
op|'['
name|'self'
op|'.'
name|'buffer'
op|','
op|']'
newline|'\n'
name|'result'
op|'.'
name|'append'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'decomp'
op|'.'
name|'decompress'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'chunkingZipFile'
op|'.'
name|'fp'
op|'.'
name|'read'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'length'
op|'-'
name|'self'
op|'.'
name|'readBytes'
op|')'
op|')'
op|')'
newline|'\n'
name|'result'
op|'.'
name|'append'
op|'('
name|'self'
op|'.'
name|'decomp'
op|'.'
name|'decompress'
op|'('
string|'"Z"'
op|')'
op|')'
newline|'\n'
name|'result'
op|'.'
name|'append'
op|'('
name|'self'
op|'.'
name|'decomp'
op|'.'
name|'flush'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'buffer'
op|'='
string|'""'
newline|'\n'
name|'self'
op|'.'
name|'finished'
op|'='
number|'1'
newline|'\n'
name|'result'
op|'='
string|'""'
op|'.'
name|'join'
op|'('
name|'result'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'returnedBytes'
op|'+='
name|'len'
op|'('
name|'result'
op|')'
newline|'\n'
name|'return'
name|'result'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'while'
name|'len'
op|'('
name|'self'
op|'.'
name|'buffer'
op|')'
op|'<'
name|'n'
op|':'
newline|'\n'
indent|'                '
name|'data'
op|'='
name|'self'
op|'.'
name|'chunkingZipFile'
op|'.'
name|'fp'
op|'.'
name|'read'
op|'('
nl|'\n'
name|'min'
op|'('
name|'n'
op|','
number|'1024'
op|','
name|'self'
op|'.'
name|'length'
op|'-'
name|'self'
op|'.'
name|'readBytes'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'readBytes'
op|'+='
name|'len'
op|'('
name|'data'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'data'
op|':'
newline|'\n'
indent|'                    '
name|'result'
op|'='
op|'('
name|'self'
op|'.'
name|'buffer'
nl|'\n'
op|'+'
name|'self'
op|'.'
name|'decomp'
op|'.'
name|'decompress'
op|'('
string|'"Z"'
op|')'
nl|'\n'
op|'+'
name|'self'
op|'.'
name|'decomp'
op|'.'
name|'flush'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'finished'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'buffer'
op|'='
string|'""'
newline|'\n'
name|'self'
op|'.'
name|'returnedBytes'
op|'+='
name|'len'
op|'('
name|'result'
op|')'
newline|'\n'
name|'return'
name|'result'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'buffer'
op|'+='
name|'self'
op|'.'
name|'decomp'
op|'.'
name|'decompress'
op|'('
name|'data'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'result'
op|'='
name|'self'
op|'.'
name|'buffer'
op|'['
op|':'
name|'n'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'buffer'
op|'='
name|'self'
op|'.'
name|'buffer'
op|'['
name|'n'
op|':'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'returnedBytes'
op|'+='
name|'len'
op|'('
name|'result'
op|')'
newline|'\n'
name|'return'
name|'result'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|unzip
dedent|''
dedent|''
dedent|''
name|'def'
name|'unzip'
op|'('
name|'filename'
op|','
name|'directory'
op|'='
string|'"."'
op|','
name|'overwrite'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Unzip the file\n\n    @param filename: the name of the zip file\n    @param directory: the directory into which the files will be\n    extracted\n    @param overwrite: if on, overwrite files when they exist.  You can\n    still get an error if you try to create a directory over a file\n    with the same name or vice-versa.\n    """'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'unzipIter'
op|'('
name|'filename'
op|','
name|'directory'
op|','
name|'overwrite'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|variable|DIR_BIT
dedent|''
dedent|''
name|'DIR_BIT'
op|'='
number|'16'
newline|'\n'
nl|'\n'
DECL|function|unzipIter
name|'def'
name|'unzipIter'
op|'('
name|'filename'
op|','
name|'directory'
op|'='
string|"'.'"
op|','
name|'overwrite'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Return a generator for the zipfile.  This implementation will yield\n    after every file.\n\n    The value it yields is the number of files left to unzip.\n    """'
newline|'\n'
name|'zf'
op|'='
name|'zipfile'
op|'.'
name|'ZipFile'
op|'('
name|'filename'
op|','
string|"'r'"
op|')'
newline|'\n'
name|'names'
op|'='
name|'zf'
op|'.'
name|'namelist'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'directory'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'os'
op|'.'
name|'makedirs'
op|'('
name|'directory'
op|')'
newline|'\n'
dedent|''
name|'remaining'
op|'='
name|'len'
op|'('
name|'zf'
op|'.'
name|'namelist'
op|'('
op|')'
op|')'
newline|'\n'
name|'for'
name|'entry'
name|'in'
name|'names'
op|':'
newline|'\n'
indent|'        '
name|'remaining'
op|'-='
number|'1'
newline|'\n'
name|'isdir'
op|'='
name|'zf'
op|'.'
name|'getinfo'
op|'('
name|'entry'
op|')'
op|'.'
name|'external_attr'
op|'&'
name|'DIR_BIT'
newline|'\n'
name|'f'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'directory'
op|','
name|'entry'
op|')'
newline|'\n'
name|'if'
name|'isdir'
op|':'
newline|'\n'
comment|'# overwrite flag only applies to files'
nl|'\n'
indent|'            '
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'f'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'makedirs'
op|'('
name|'f'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# create the directory the file will be in first,'
nl|'\n'
comment|"# since we can't guarantee it exists"
nl|'\n'
indent|'            '
name|'fdir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'split'
op|'('
name|'f'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'fdir'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'makedirs'
op|'('
name|'fdir'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'overwrite'
name|'or'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'f'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'outfile'
op|'='
name|'file'
op|'('
name|'f'
op|','
string|"'wb'"
op|')'
newline|'\n'
name|'outfile'
op|'.'
name|'write'
op|'('
name|'zf'
op|'.'
name|'read'
op|'('
name|'entry'
op|')'
op|')'
newline|'\n'
name|'outfile'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'yield'
name|'remaining'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|countZipFileChunks
dedent|''
dedent|''
name|'def'
name|'countZipFileChunks'
op|'('
name|'filename'
op|','
name|'chunksize'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Predict the number of chunks that will be extracted from the entire\n    zipfile, given chunksize blocks.\n    """'
newline|'\n'
name|'totalchunks'
op|'='
number|'0'
newline|'\n'
name|'zf'
op|'='
name|'ChunkingZipFile'
op|'('
name|'filename'
op|')'
newline|'\n'
name|'for'
name|'info'
name|'in'
name|'zf'
op|'.'
name|'infolist'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'totalchunks'
op|'+='
name|'countFileChunks'
op|'('
name|'info'
op|','
name|'chunksize'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'totalchunks'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|countFileChunks
dedent|''
name|'def'
name|'countFileChunks'
op|'('
name|'zipinfo'
op|','
name|'chunksize'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Count the number of chunks that will result from the given L{ZipInfo}.\n\n    @param zipinfo: a L{zipfile.ZipInfo} instance describing an entry in a zip\n    archive to be counted.\n\n    @return: the number of chunks present in the zip file.  (Even an empty file\n    counts as one chunk.)\n    @rtype: L{int}\n    """'
newline|'\n'
name|'count'
op|','
name|'extra'
op|'='
name|'divmod'
op|'('
name|'zipinfo'
op|'.'
name|'file_size'
op|','
name|'chunksize'
op|')'
newline|'\n'
name|'if'
name|'extra'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'count'
op|'+='
number|'1'
newline|'\n'
dedent|''
name|'return'
name|'count'
name|'or'
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|countZipFileEntries
dedent|''
name|'def'
name|'countZipFileEntries'
op|'('
name|'filename'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Count the number of entries in a zip archive.  (Don\'t use this function.)\n\n    @param filename: The filename of a zip archive.\n    @type filename: L{str}\n    """'
newline|'\n'
name|'warnings'
op|'.'
name|'warn'
op|'('
string|'"countZipFileEntries is deprecated."'
op|','
nl|'\n'
name|'DeprecationWarning'
op|','
number|'2'
op|')'
newline|'\n'
name|'zf'
op|'='
name|'zipfile'
op|'.'
name|'ZipFile'
op|'('
name|'filename'
op|')'
newline|'\n'
name|'return'
name|'len'
op|'('
name|'zf'
op|'.'
name|'namelist'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|unzipIterChunky
dedent|''
name|'def'
name|'unzipIterChunky'
op|'('
name|'filename'
op|','
name|'directory'
op|'='
string|"'.'"
op|','
name|'overwrite'
op|'='
number|'0'
op|','
nl|'\n'
name|'chunksize'
op|'='
number|'4096'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Return a generator for the zipfile.  This implementation will yield after\n    every chunksize uncompressed bytes, or at the end of a file, whichever\n    comes first.\n\n    The value it yields is the number of chunks left to unzip.\n    """'
newline|'\n'
name|'czf'
op|'='
name|'ChunkingZipFile'
op|'('
name|'filename'
op|','
string|"'r'"
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'directory'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'os'
op|'.'
name|'makedirs'
op|'('
name|'directory'
op|')'
newline|'\n'
dedent|''
name|'remaining'
op|'='
name|'countZipFileChunks'
op|'('
name|'filename'
op|','
name|'chunksize'
op|')'
newline|'\n'
name|'names'
op|'='
name|'czf'
op|'.'
name|'namelist'
op|'('
op|')'
newline|'\n'
name|'infos'
op|'='
name|'czf'
op|'.'
name|'infolist'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'entry'
op|','
name|'info'
name|'in'
name|'zip'
op|'('
name|'names'
op|','
name|'infos'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'isdir'
op|'='
name|'info'
op|'.'
name|'external_attr'
op|'&'
name|'DIR_BIT'
newline|'\n'
name|'f'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'directory'
op|','
name|'entry'
op|')'
newline|'\n'
name|'if'
name|'isdir'
op|':'
newline|'\n'
comment|'# overwrite flag only applies to files'
nl|'\n'
indent|'            '
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'f'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'makedirs'
op|'('
name|'f'
op|')'
newline|'\n'
dedent|''
name|'remaining'
op|'-='
number|'1'
newline|'\n'
name|'yield'
name|'remaining'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# create the directory the file will be in first,'
nl|'\n'
comment|"# since we can't guarantee it exists"
nl|'\n'
indent|'            '
name|'fdir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'split'
op|'('
name|'f'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'fdir'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'makedirs'
op|'('
name|'fdir'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'overwrite'
name|'or'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'f'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'outfile'
op|'='
name|'file'
op|'('
name|'f'
op|','
string|"'wb'"
op|')'
newline|'\n'
name|'fp'
op|'='
name|'czf'
op|'.'
name|'readfile'
op|'('
name|'entry'
op|')'
newline|'\n'
name|'if'
name|'info'
op|'.'
name|'file_size'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'remaining'
op|'-='
number|'1'
newline|'\n'
name|'yield'
name|'remaining'
newline|'\n'
dedent|''
name|'while'
name|'fp'
op|'.'
name|'tell'
op|'('
op|')'
op|'<'
name|'info'
op|'.'
name|'file_size'
op|':'
newline|'\n'
indent|'                    '
name|'hunk'
op|'='
name|'fp'
op|'.'
name|'read'
op|'('
name|'chunksize'
op|')'
newline|'\n'
name|'outfile'
op|'.'
name|'write'
op|'('
name|'hunk'
op|')'
newline|'\n'
name|'remaining'
op|'-='
number|'1'
newline|'\n'
name|'yield'
name|'remaining'
newline|'\n'
dedent|''
name|'outfile'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'remaining'
op|'-='
name|'countFileChunks'
op|'('
name|'info'
op|','
name|'chunksize'
op|')'
newline|'\n'
name|'yield'
name|'remaining'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
