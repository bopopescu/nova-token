begin_unit
comment|'# Copyright (c) 2001-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
nl|'\n'
string|'"""\nTest cases for Twisted component architecture.\n"""'
newline|'\n'
nl|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'Interface'
op|','
name|'implements'
op|','
name|'Attribute'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'components'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'components'
name|'import'
name|'proxyForInterface'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|InterfacesTestCase
name|'class'
name|'InterfacesTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Test interfaces."""'
newline|'\n'
nl|'\n'
DECL|class|Compo
dedent|''
name|'class'
name|'Compo'
op|'('
name|'components'
op|'.'
name|'Componentized'
op|')'
op|':'
newline|'\n'
DECL|variable|num
indent|'    '
name|'num'
op|'='
number|'0'
newline|'\n'
DECL|member|inc
name|'def'
name|'inc'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'num'
op|'='
name|'self'
op|'.'
name|'num'
op|'+'
number|'1'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'num'
newline|'\n'
nl|'\n'
DECL|class|IAdept
dedent|''
dedent|''
name|'class'
name|'IAdept'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
DECL|member|adaptorFunc
indent|'    '
name|'def'
name|'adaptorFunc'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|class|IElapsed
dedent|''
dedent|''
name|'class'
name|'IElapsed'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
DECL|member|elapsedFunc
indent|'    '
name|'def'
name|'elapsedFunc'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        1!\n        """'
newline|'\n'
nl|'\n'
DECL|class|Adept
dedent|''
dedent|''
name|'class'
name|'Adept'
op|'('
name|'components'
op|'.'
name|'Adapter'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'implements'
op|'('
name|'IAdept'
op|')'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'orig'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'original'
op|'='
name|'orig'
newline|'\n'
name|'self'
op|'.'
name|'num'
op|'='
number|'0'
newline|'\n'
DECL|member|adaptorFunc
dedent|''
name|'def'
name|'adaptorFunc'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'num'
op|'='
name|'self'
op|'.'
name|'num'
op|'+'
number|'1'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'num'
op|','
name|'self'
op|'.'
name|'original'
op|'.'
name|'inc'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|class|Elapsed
dedent|''
dedent|''
name|'class'
name|'Elapsed'
op|'('
name|'components'
op|'.'
name|'Adapter'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'implements'
op|'('
name|'IElapsed'
op|')'
newline|'\n'
DECL|member|elapsedFunc
name|'def'
name|'elapsedFunc'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
number|'1'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'components'
op|'.'
name|'registerAdapter'
op|'('
name|'Adept'
op|','
name|'Compo'
op|','
name|'IAdept'
op|')'
newline|'\n'
name|'components'
op|'.'
name|'registerAdapter'
op|'('
name|'Elapsed'
op|','
name|'Compo'
op|','
name|'IElapsed'
op|')'
newline|'\n'
nl|'\n'
DECL|class|AComp
name|'class'
name|'AComp'
op|'('
name|'components'
op|'.'
name|'Componentized'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
DECL|class|BComp
dedent|''
name|'class'
name|'BComp'
op|'('
name|'AComp'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
DECL|class|CComp
dedent|''
name|'class'
name|'CComp'
op|'('
name|'BComp'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
nl|'\n'
DECL|class|ITest
dedent|''
name|'class'
name|'ITest'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
DECL|class|ITest2
dedent|''
name|'class'
name|'ITest2'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
DECL|class|ITest3
dedent|''
name|'class'
name|'ITest3'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
DECL|class|ITest4
dedent|''
name|'class'
name|'ITest4'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
DECL|class|Test
dedent|''
name|'class'
name|'Test'
op|'('
name|'components'
op|'.'
name|'Adapter'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'implements'
op|'('
name|'ITest'
op|','
name|'ITest3'
op|','
name|'ITest4'
op|')'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'orig'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
DECL|class|Test2
dedent|''
dedent|''
name|'class'
name|'Test2'
op|':'
newline|'\n'
indent|'    '
name|'implements'
op|'('
name|'ITest2'
op|')'
newline|'\n'
DECL|variable|temporaryAdapter
name|'temporaryAdapter'
op|'='
number|'1'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'orig'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'components'
op|'.'
name|'registerAdapter'
op|'('
name|'Test'
op|','
name|'AComp'
op|','
name|'ITest'
op|')'
newline|'\n'
name|'components'
op|'.'
name|'registerAdapter'
op|'('
name|'Test'
op|','
name|'AComp'
op|','
name|'ITest3'
op|')'
newline|'\n'
name|'components'
op|'.'
name|'registerAdapter'
op|'('
name|'Test2'
op|','
name|'AComp'
op|','
name|'ITest2'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ComponentizedTestCase
name|'class'
name|'ComponentizedTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Simple test case for caching in Componentized.\n    """'
newline|'\n'
DECL|member|testComponentized
name|'def'
name|'testComponentized'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'c'
op|'='
name|'Compo'
op|'('
op|')'
newline|'\n'
name|'assert'
name|'c'
op|'.'
name|'getComponent'
op|'('
name|'IAdept'
op|')'
op|'.'
name|'adaptorFunc'
op|'('
op|')'
op|'=='
op|'('
number|'1'
op|','
number|'1'
op|')'
newline|'\n'
name|'assert'
name|'c'
op|'.'
name|'getComponent'
op|'('
name|'IAdept'
op|')'
op|'.'
name|'adaptorFunc'
op|'('
op|')'
op|'=='
op|'('
number|'2'
op|','
number|'2'
op|')'
newline|'\n'
name|'assert'
name|'IElapsed'
op|'('
name|'IAdept'
op|'('
name|'c'
op|')'
op|')'
op|'.'
name|'elapsedFunc'
op|'('
op|')'
op|'=='
number|'1'
newline|'\n'
nl|'\n'
DECL|member|testInheritanceAdaptation
dedent|''
name|'def'
name|'testInheritanceAdaptation'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'c'
op|'='
name|'CComp'
op|'('
op|')'
newline|'\n'
name|'co1'
op|'='
name|'c'
op|'.'
name|'getComponent'
op|'('
name|'ITest'
op|')'
newline|'\n'
name|'co2'
op|'='
name|'c'
op|'.'
name|'getComponent'
op|'('
name|'ITest'
op|')'
newline|'\n'
name|'co3'
op|'='
name|'c'
op|'.'
name|'getComponent'
op|'('
name|'ITest2'
op|')'
newline|'\n'
name|'co4'
op|'='
name|'c'
op|'.'
name|'getComponent'
op|'('
name|'ITest2'
op|')'
newline|'\n'
name|'assert'
name|'co1'
name|'is'
name|'co2'
newline|'\n'
name|'assert'
name|'co3'
name|'is'
name|'not'
name|'co4'
newline|'\n'
name|'c'
op|'.'
name|'removeComponent'
op|'('
name|'co1'
op|')'
newline|'\n'
name|'co5'
op|'='
name|'c'
op|'.'
name|'getComponent'
op|'('
name|'ITest'
op|')'
newline|'\n'
name|'co6'
op|'='
name|'c'
op|'.'
name|'getComponent'
op|'('
name|'ITest'
op|')'
newline|'\n'
name|'assert'
name|'co5'
name|'is'
name|'co6'
newline|'\n'
name|'assert'
name|'co1'
name|'is'
name|'not'
name|'co5'
newline|'\n'
nl|'\n'
DECL|member|testMultiAdapter
dedent|''
name|'def'
name|'testMultiAdapter'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'c'
op|'='
name|'CComp'
op|'('
op|')'
newline|'\n'
name|'co1'
op|'='
name|'c'
op|'.'
name|'getComponent'
op|'('
name|'ITest'
op|')'
newline|'\n'
name|'co2'
op|'='
name|'c'
op|'.'
name|'getComponent'
op|'('
name|'ITest2'
op|')'
newline|'\n'
name|'co3'
op|'='
name|'c'
op|'.'
name|'getComponent'
op|'('
name|'ITest3'
op|')'
newline|'\n'
name|'co4'
op|'='
name|'c'
op|'.'
name|'getComponent'
op|'('
name|'ITest4'
op|')'
newline|'\n'
name|'assert'
name|'co4'
op|'=='
name|'None'
newline|'\n'
name|'assert'
name|'co1'
name|'is'
name|'co3'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getComponentDefaults
dedent|''
name|'def'
name|'test_getComponentDefaults'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that a default value specified to Componentized.getComponent if\n        there is no component for the requested interface.\n        """'
newline|'\n'
name|'componentized'
op|'='
name|'components'
op|'.'
name|'Componentized'
op|'('
op|')'
newline|'\n'
name|'default'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
nl|'\n'
name|'componentized'
op|'.'
name|'getComponent'
op|'('
name|'ITest'
op|','
name|'default'
op|')'
op|','
nl|'\n'
name|'default'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
nl|'\n'
name|'componentized'
op|'.'
name|'getComponent'
op|'('
name|'ITest'
op|','
name|'default'
op|'='
name|'default'
op|')'
op|','
nl|'\n'
name|'default'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
nl|'\n'
name|'componentized'
op|'.'
name|'getComponent'
op|'('
name|'ITest'
op|')'
op|','
nl|'\n'
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|AdapterTestCase
dedent|''
dedent|''
name|'class'
name|'AdapterTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Test adapters."""'
newline|'\n'
nl|'\n'
DECL|member|testAdapterGetComponent
name|'def'
name|'testAdapterGetComponent'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'o'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
name|'a'
op|'='
name|'Adept'
op|'('
name|'o'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'components'
op|'.'
name|'CannotAdapt'
op|','
name|'ITest'
op|','
name|'a'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'ITest'
op|'('
name|'a'
op|','
name|'None'
op|')'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|IMeta
dedent|''
dedent|''
name|'class'
name|'IMeta'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
nl|'\n'
DECL|class|MetaAdder
dedent|''
name|'class'
name|'MetaAdder'
op|'('
name|'components'
op|'.'
name|'Adapter'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'implements'
op|'('
name|'IMeta'
op|')'
newline|'\n'
DECL|member|add
name|'def'
name|'add'
op|'('
name|'self'
op|','
name|'num'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'original'
op|'.'
name|'num'
op|'+'
name|'num'
newline|'\n'
nl|'\n'
DECL|class|BackwardsAdder
dedent|''
dedent|''
name|'class'
name|'BackwardsAdder'
op|'('
name|'components'
op|'.'
name|'Adapter'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'implements'
op|'('
name|'IMeta'
op|')'
newline|'\n'
DECL|member|add
name|'def'
name|'add'
op|'('
name|'self'
op|','
name|'num'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'original'
op|'.'
name|'num'
op|'-'
name|'num'
newline|'\n'
nl|'\n'
DECL|class|MetaNumber
dedent|''
dedent|''
name|'class'
name|'MetaNumber'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'num'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'num'
op|'='
name|'num'
newline|'\n'
nl|'\n'
DECL|class|FakeAdder
dedent|''
dedent|''
name|'class'
name|'FakeAdder'
op|':'
newline|'\n'
DECL|member|add
indent|'    '
name|'def'
name|'add'
op|'('
name|'self'
op|','
name|'num'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'num'
op|'+'
number|'5'
newline|'\n'
nl|'\n'
DECL|class|FakeNumber
dedent|''
dedent|''
name|'class'
name|'FakeNumber'
op|':'
newline|'\n'
DECL|variable|num
indent|'    '
name|'num'
op|'='
number|'3'
newline|'\n'
nl|'\n'
DECL|class|ComponentNumber
dedent|''
name|'class'
name|'ComponentNumber'
op|'('
name|'components'
op|'.'
name|'Componentized'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'num'
op|'='
number|'0'
newline|'\n'
name|'components'
op|'.'
name|'Componentized'
op|'.'
name|'__init__'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
DECL|class|ComponentMeta
dedent|''
dedent|''
name|'class'
name|'ComponentMeta'
op|'('
name|'components'
op|'.'
name|'Adapter'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'implements'
op|'('
name|'IMeta'
op|')'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'original'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'components'
op|'.'
name|'Adapter'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
name|'original'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'num'
op|'='
name|'self'
op|'.'
name|'original'
op|'.'
name|'num'
newline|'\n'
nl|'\n'
DECL|class|ComponentAdder
dedent|''
dedent|''
name|'class'
name|'ComponentAdder'
op|'('
name|'ComponentMeta'
op|')'
op|':'
newline|'\n'
DECL|member|add
indent|'    '
name|'def'
name|'add'
op|'('
name|'self'
op|','
name|'num'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'num'
op|'+='
name|'num'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'num'
newline|'\n'
nl|'\n'
DECL|class|ComponentDoubler
dedent|''
dedent|''
name|'class'
name|'ComponentDoubler'
op|'('
name|'ComponentMeta'
op|')'
op|':'
newline|'\n'
DECL|member|add
indent|'    '
name|'def'
name|'add'
op|'('
name|'self'
op|','
name|'num'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'num'
op|'+='
op|'('
name|'num'
op|'*'
number|'2'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'original'
op|'.'
name|'num'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'components'
op|'.'
name|'registerAdapter'
op|'('
name|'MetaAdder'
op|','
name|'MetaNumber'
op|','
name|'IMeta'
op|')'
newline|'\n'
name|'components'
op|'.'
name|'registerAdapter'
op|'('
name|'ComponentAdder'
op|','
name|'ComponentNumber'
op|','
name|'IMeta'
op|')'
newline|'\n'
nl|'\n'
DECL|class|IAttrX
name|'class'
name|'IAttrX'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
DECL|member|x
indent|'    '
name|'def'
name|'x'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|class|IAttrXX
dedent|''
dedent|''
name|'class'
name|'IAttrXX'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
DECL|member|xx
indent|'    '
name|'def'
name|'xx'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|class|Xcellent
dedent|''
dedent|''
name|'class'
name|'Xcellent'
op|':'
newline|'\n'
indent|'    '
name|'implements'
op|'('
name|'IAttrX'
op|')'
newline|'\n'
DECL|member|x
name|'def'
name|'x'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|"'x!'"
newline|'\n'
nl|'\n'
DECL|class|DoubleXAdapter
dedent|''
dedent|''
name|'class'
name|'DoubleXAdapter'
op|':'
newline|'\n'
DECL|variable|num
indent|'    '
name|'num'
op|'='
number|'42'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'original'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'original'
op|'='
name|'original'
newline|'\n'
DECL|member|xx
dedent|''
name|'def'
name|'xx'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
name|'self'
op|'.'
name|'original'
op|'.'
name|'x'
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'original'
op|'.'
name|'x'
op|'('
op|')'
op|')'
newline|'\n'
DECL|member|__cmp__
dedent|''
name|'def'
name|'__cmp__'
op|'('
name|'self'
op|','
name|'other'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'cmp'
op|'('
name|'self'
op|'.'
name|'num'
op|','
name|'other'
op|'.'
name|'num'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'components'
op|'.'
name|'registerAdapter'
op|'('
name|'DoubleXAdapter'
op|','
name|'IAttrX'
op|','
name|'IAttrXX'
op|')'
newline|'\n'
nl|'\n'
DECL|class|TestMetaInterface
name|'class'
name|'TestMetaInterface'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|testBasic
indent|'    '
name|'def'
name|'testBasic'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'n'
op|'='
name|'MetaNumber'
op|'('
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'IMeta'
op|'('
name|'n'
op|')'
op|'.'
name|'add'
op|'('
number|'1'
op|')'
op|','
number|'2'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testComponentizedInteraction
dedent|''
name|'def'
name|'testComponentizedInteraction'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'c'
op|'='
name|'ComponentNumber'
op|'('
op|')'
newline|'\n'
name|'IMeta'
op|'('
name|'c'
op|')'
op|'.'
name|'add'
op|'('
number|'1'
op|')'
newline|'\n'
name|'IMeta'
op|'('
name|'c'
op|')'
op|'.'
name|'add'
op|'('
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'IMeta'
op|'('
name|'c'
op|')'
op|'.'
name|'add'
op|'('
number|'1'
op|')'
op|','
number|'3'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testAdapterWithCmp
dedent|''
name|'def'
name|'testAdapterWithCmp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|"# Make sure that a __cmp__ on an adapter doesn't break anything"
nl|'\n'
indent|'        '
name|'xx'
op|'='
name|'IAttrXX'
op|'('
name|'Xcellent'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
op|'('
string|"'x!'"
op|','
string|"'x!'"
op|')'
op|','
name|'xx'
op|'.'
name|'xx'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|RegistrationTestCase
dedent|''
dedent|''
name|'class'
name|'RegistrationTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for adapter registration.\n    """'
newline|'\n'
DECL|member|_registerAdapterForClassOrInterface
name|'def'
name|'_registerAdapterForClassOrInterface'
op|'('
name|'self'
op|','
name|'original'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'adapter'
op|'='
name|'lambda'
name|'o'
op|':'
name|'None'
newline|'\n'
DECL|class|TheInterface
name|'class'
name|'TheInterface'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'components'
op|'.'
name|'registerAdapter'
op|'('
name|'adapter'
op|','
name|'original'
op|','
name|'TheInterface'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
nl|'\n'
name|'components'
op|'.'
name|'getAdapterFactory'
op|'('
name|'original'
op|','
name|'TheInterface'
op|','
name|'None'
op|')'
op|','
nl|'\n'
name|'adapter'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_registerAdapterForClass
dedent|''
name|'def'
name|'test_registerAdapterForClass'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that an adapter from a class can be registered and then looked\n        up.\n        """'
newline|'\n'
DECL|class|TheOriginal
name|'class'
name|'TheOriginal'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_registerAdapterForClassOrInterface'
op|'('
name|'TheOriginal'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_registerAdapterForInterface
dedent|''
name|'def'
name|'test_registerAdapterForInterface'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that an adapter from an interface can be registered and then\n        looked up.\n        """'
newline|'\n'
DECL|class|TheOriginal
name|'class'
name|'TheOriginal'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_registerAdapterForClassOrInterface'
op|'('
name|'TheOriginal'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_duplicateAdapterForClassOrInterface
dedent|''
name|'def'
name|'_duplicateAdapterForClassOrInterface'
op|'('
name|'self'
op|','
name|'original'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'firstAdapter'
op|'='
name|'lambda'
name|'o'
op|':'
name|'False'
newline|'\n'
name|'secondAdapter'
op|'='
name|'lambda'
name|'o'
op|':'
name|'True'
newline|'\n'
DECL|class|TheInterface
name|'class'
name|'TheInterface'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'components'
op|'.'
name|'registerAdapter'
op|'('
name|'firstAdapter'
op|','
name|'original'
op|','
name|'TheInterface'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
nl|'\n'
name|'ValueError'
op|','
nl|'\n'
name|'components'
op|'.'
name|'registerAdapter'
op|','
nl|'\n'
name|'secondAdapter'
op|','
name|'original'
op|','
name|'TheInterface'
op|')'
newline|'\n'
comment|'# Make sure that the original adapter is still around as well'
nl|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
nl|'\n'
name|'components'
op|'.'
name|'getAdapterFactory'
op|'('
name|'original'
op|','
name|'TheInterface'
op|','
name|'None'
op|')'
op|','
nl|'\n'
name|'firstAdapter'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_duplicateAdapterForClass
dedent|''
name|'def'
name|'test_duplicateAdapterForClass'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that attempting to register a second adapter from a class\n        raises the appropriate exception.\n        """'
newline|'\n'
DECL|class|TheOriginal
name|'class'
name|'TheOriginal'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_duplicateAdapterForClassOrInterface'
op|'('
name|'TheOriginal'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_duplicateAdapterForInterface
dedent|''
name|'def'
name|'test_duplicateAdapterForInterface'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that attempting to register a second adapter from an interface\n        raises the appropriate exception.\n        """'
newline|'\n'
DECL|class|TheOriginal
name|'class'
name|'TheOriginal'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_duplicateAdapterForClassOrInterface'
op|'('
name|'TheOriginal'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_duplicateAdapterForClassOrInterfaceAllowed
dedent|''
name|'def'
name|'_duplicateAdapterForClassOrInterfaceAllowed'
op|'('
name|'self'
op|','
name|'original'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'firstAdapter'
op|'='
name|'lambda'
name|'o'
op|':'
name|'False'
newline|'\n'
name|'secondAdapter'
op|'='
name|'lambda'
name|'o'
op|':'
name|'True'
newline|'\n'
DECL|class|TheInterface
name|'class'
name|'TheInterface'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'components'
op|'.'
name|'registerAdapter'
op|'('
name|'firstAdapter'
op|','
name|'original'
op|','
name|'TheInterface'
op|')'
newline|'\n'
name|'components'
op|'.'
name|'ALLOW_DUPLICATES'
op|'='
name|'True'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'components'
op|'.'
name|'registerAdapter'
op|'('
name|'secondAdapter'
op|','
name|'original'
op|','
name|'TheInterface'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
nl|'\n'
name|'components'
op|'.'
name|'getAdapterFactory'
op|'('
name|'original'
op|','
name|'TheInterface'
op|','
name|'None'
op|')'
op|','
nl|'\n'
name|'secondAdapter'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'components'
op|'.'
name|'ALLOW_DUPLICATES'
op|'='
name|'False'
newline|'\n'
nl|'\n'
comment|'# It should be rejected again at this point'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'assertRaises'
op|'('
nl|'\n'
name|'ValueError'
op|','
nl|'\n'
name|'components'
op|'.'
name|'registerAdapter'
op|','
nl|'\n'
name|'firstAdapter'
op|','
name|'original'
op|','
name|'TheInterface'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
nl|'\n'
name|'components'
op|'.'
name|'getAdapterFactory'
op|'('
name|'original'
op|','
name|'TheInterface'
op|','
name|'None'
op|')'
op|','
nl|'\n'
name|'secondAdapter'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_duplicateAdapterForClassAllowed
dedent|''
name|'def'
name|'test_duplicateAdapterForClassAllowed'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that when L{components.ALLOW_DUPLICATES} is set to a true\n        value, duplicate registrations from classes are allowed to override\n        the original registration.\n        """'
newline|'\n'
DECL|class|TheOriginal
name|'class'
name|'TheOriginal'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_duplicateAdapterForClassOrInterfaceAllowed'
op|'('
name|'TheOriginal'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_duplicateAdapterForInterfaceAllowed
dedent|''
name|'def'
name|'test_duplicateAdapterForInterfaceAllowed'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that when L{components.ALLOW_DUPLICATES} is set to a true\n        value, duplicate registrations from interfaces are allowed to\n        override the original registration.\n        """'
newline|'\n'
DECL|class|TheOriginal
name|'class'
name|'TheOriginal'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_duplicateAdapterForClassOrInterfaceAllowed'
op|'('
name|'TheOriginal'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_multipleInterfacesForClassOrInterface
dedent|''
name|'def'
name|'_multipleInterfacesForClassOrInterface'
op|'('
name|'self'
op|','
name|'original'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'adapter'
op|'='
name|'lambda'
name|'o'
op|':'
name|'None'
newline|'\n'
DECL|class|FirstInterface
name|'class'
name|'FirstInterface'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
DECL|class|SecondInterface
dedent|''
name|'class'
name|'SecondInterface'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'components'
op|'.'
name|'registerAdapter'
op|'('
name|'adapter'
op|','
name|'original'
op|','
name|'FirstInterface'
op|','
name|'SecondInterface'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
nl|'\n'
name|'components'
op|'.'
name|'getAdapterFactory'
op|'('
name|'original'
op|','
name|'FirstInterface'
op|','
name|'None'
op|')'
op|','
nl|'\n'
name|'adapter'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
nl|'\n'
name|'components'
op|'.'
name|'getAdapterFactory'
op|'('
name|'original'
op|','
name|'SecondInterface'
op|','
name|'None'
op|')'
op|','
nl|'\n'
name|'adapter'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_multipleInterfacesForClass
dedent|''
name|'def'
name|'test_multipleInterfacesForClass'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test the registration of an adapter from a class to several\n        interfaces at once.\n        """'
newline|'\n'
DECL|class|TheOriginal
name|'class'
name|'TheOriginal'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_multipleInterfacesForClassOrInterface'
op|'('
name|'TheOriginal'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_multipleInterfacesForInterface
dedent|''
name|'def'
name|'test_multipleInterfacesForInterface'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test the registration of an adapter from an interface to several\n        interfaces at once.\n        """'
newline|'\n'
DECL|class|TheOriginal
name|'class'
name|'TheOriginal'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_multipleInterfacesForClassOrInterface'
op|'('
name|'TheOriginal'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_subclassAdapterRegistrationForClassOrInterface
dedent|''
name|'def'
name|'_subclassAdapterRegistrationForClassOrInterface'
op|'('
name|'self'
op|','
name|'original'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'firstAdapter'
op|'='
name|'lambda'
name|'o'
op|':'
name|'True'
newline|'\n'
name|'secondAdapter'
op|'='
name|'lambda'
name|'o'
op|':'
name|'False'
newline|'\n'
DECL|class|TheSubclass
name|'class'
name|'TheSubclass'
op|'('
name|'original'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
DECL|class|TheInterface
dedent|''
name|'class'
name|'TheInterface'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'components'
op|'.'
name|'registerAdapter'
op|'('
name|'firstAdapter'
op|','
name|'original'
op|','
name|'TheInterface'
op|')'
newline|'\n'
name|'components'
op|'.'
name|'registerAdapter'
op|'('
name|'secondAdapter'
op|','
name|'TheSubclass'
op|','
name|'TheInterface'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
nl|'\n'
name|'components'
op|'.'
name|'getAdapterFactory'
op|'('
name|'original'
op|','
name|'TheInterface'
op|','
name|'None'
op|')'
op|','
nl|'\n'
name|'firstAdapter'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
nl|'\n'
name|'components'
op|'.'
name|'getAdapterFactory'
op|'('
name|'TheSubclass'
op|','
name|'TheInterface'
op|','
name|'None'
op|')'
op|','
nl|'\n'
name|'secondAdapter'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_subclassAdapterRegistrationForClass
dedent|''
name|'def'
name|'test_subclassAdapterRegistrationForClass'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that an adapter to a particular interface can be registered\n        from both a class and its subclass.\n        """'
newline|'\n'
DECL|class|TheOriginal
name|'class'
name|'TheOriginal'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_subclassAdapterRegistrationForClassOrInterface'
op|'('
name|'TheOriginal'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_subclassAdapterRegistrationForInterface
dedent|''
name|'def'
name|'test_subclassAdapterRegistrationForInterface'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that an adapter to a particular interface can be registered\n        from both an interface and its subclass.\n        """'
newline|'\n'
DECL|class|TheOriginal
name|'class'
name|'TheOriginal'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_subclassAdapterRegistrationForClassOrInterface'
op|'('
name|'TheOriginal'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|IProxiedInterface
dedent|''
dedent|''
name|'class'
name|'IProxiedInterface'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    An interface class for use by L{proxyForInterface}.\n    """'
newline|'\n'
nl|'\n'
name|'ifaceAttribute'
op|'='
name|'Attribute'
op|'('
string|'"""\n        An example declared attribute, which should be proxied."""'
op|')'
newline|'\n'
nl|'\n'
DECL|member|yay
name|'def'
name|'yay'
op|'('
op|'*'
name|'a'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A sample method which should be proxied.\n        """'
newline|'\n'
nl|'\n'
DECL|class|IProxiedSubInterface
dedent|''
dedent|''
name|'class'
name|'IProxiedSubInterface'
op|'('
name|'IProxiedInterface'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    An interface that derives from another for use with L{proxyForInterface}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|boo
name|'def'
name|'boo'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A different sample method which should be proxied.\n        """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|Yayable
dedent|''
dedent|''
name|'class'
name|'Yayable'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A provider of L{IProxiedInterface} which increments a counter for\n    every call to C{yay}.\n\n    @ivar yays: The number of times C{yay} has been called.\n    """'
newline|'\n'
name|'implements'
op|'('
name|'IProxiedInterface'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'yays'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'yayArgs'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|yay
dedent|''
name|'def'
name|'yay'
op|'('
name|'self'
op|','
op|'*'
name|'a'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Increment C{self.yays}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'yays'
op|'+='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'yayArgs'
op|'.'
name|'append'
op|'('
op|'('
name|'a'
op|','
name|'kw'
op|')'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'yays'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Booable
dedent|''
dedent|''
name|'class'
name|'Booable'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    An implementation of IProxiedSubInterface\n    """'
newline|'\n'
name|'implements'
op|'('
name|'IProxiedSubInterface'
op|')'
newline|'\n'
DECL|variable|yayed
name|'yayed'
op|'='
name|'False'
newline|'\n'
DECL|variable|booed
name|'booed'
op|'='
name|'False'
newline|'\n'
DECL|member|yay
name|'def'
name|'yay'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Mark the fact that \'yay\' has been called.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'yayed'
op|'='
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|boo
dedent|''
name|'def'
name|'boo'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Mark the fact that \'boo\' has been called.1\n        """'
newline|'\n'
name|'self'
op|'.'
name|'booed'
op|'='
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|IMultipleMethods
dedent|''
dedent|''
name|'class'
name|'IMultipleMethods'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    An interface with multiple methods.\n    """'
newline|'\n'
nl|'\n'
DECL|member|methodOne
name|'def'
name|'methodOne'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The first method. Should return 1.\n        """'
newline|'\n'
nl|'\n'
DECL|member|methodTwo
dedent|''
name|'def'
name|'methodTwo'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The second method. Should return 2.\n        """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|MultipleMethodImplementor
dedent|''
dedent|''
name|'class'
name|'MultipleMethodImplementor'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A precise implementation of L{IMultipleMethods}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|methodOne
name|'def'
name|'methodOne'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @return: 1\n        """'
newline|'\n'
name|'return'
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|methodTwo
dedent|''
name|'def'
name|'methodTwo'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @return: 2\n        """'
newline|'\n'
name|'return'
number|'2'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ProxyForInterfaceTests
dedent|''
dedent|''
name|'class'
name|'ProxyForInterfaceTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{proxyForInterface}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|test_original
name|'def'
name|'test_original'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Proxy objects should have an C{original} attribute which refers to the\n        original object passed to the constructor.\n        """'
newline|'\n'
name|'original'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
name|'proxy'
op|'='
name|'proxyForInterface'
op|'('
name|'IProxiedInterface'
op|')'
op|'('
name|'original'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'proxy'
op|'.'
name|'original'
op|','
name|'original'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_proxyMethod
dedent|''
name|'def'
name|'test_proxyMethod'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The class created from L{proxyForInterface} passes methods on an\n        interface to the object which is passed to its constructor.\n        """'
newline|'\n'
name|'klass'
op|'='
name|'proxyForInterface'
op|'('
name|'IProxiedInterface'
op|')'
newline|'\n'
name|'yayable'
op|'='
name|'Yayable'
op|'('
op|')'
newline|'\n'
name|'proxy'
op|'='
name|'klass'
op|'('
name|'yayable'
op|')'
newline|'\n'
name|'proxy'
op|'.'
name|'yay'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'proxy'
op|'.'
name|'yay'
op|'('
op|')'
op|','
number|'2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'yayable'
op|'.'
name|'yays'
op|','
number|'2'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_proxyAttribute
dedent|''
name|'def'
name|'test_proxyAttribute'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Proxy objects should proxy declared attributes, but not other\n        attributes.\n        """'
newline|'\n'
name|'yayable'
op|'='
name|'Yayable'
op|'('
op|')'
newline|'\n'
name|'yayable'
op|'.'
name|'ifaceAttribute'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
name|'proxy'
op|'='
name|'proxyForInterface'
op|'('
name|'IProxiedInterface'
op|')'
op|'('
name|'yayable'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'proxy'
op|'.'
name|'ifaceAttribute'
op|','
name|'yayable'
op|'.'
name|'ifaceAttribute'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'AttributeError'
op|','
name|'lambda'
op|':'
name|'proxy'
op|'.'
name|'yays'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_proxySetAttribute
dedent|''
name|'def'
name|'test_proxySetAttribute'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The attributes that proxy objects proxy should be assignable and affect\n        the original object.\n        """'
newline|'\n'
name|'yayable'
op|'='
name|'Yayable'
op|'('
op|')'
newline|'\n'
name|'proxy'
op|'='
name|'proxyForInterface'
op|'('
name|'IProxiedInterface'
op|')'
op|'('
name|'yayable'
op|')'
newline|'\n'
name|'thingy'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
name|'proxy'
op|'.'
name|'ifaceAttribute'
op|'='
name|'thingy'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'yayable'
op|'.'
name|'ifaceAttribute'
op|','
name|'thingy'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_proxyDeleteAttribute
dedent|''
name|'def'
name|'test_proxyDeleteAttribute'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The attributes that proxy objects proxy should be deletable and affect\n        the original object.\n        """'
newline|'\n'
name|'yayable'
op|'='
name|'Yayable'
op|'('
op|')'
newline|'\n'
name|'yayable'
op|'.'
name|'ifaceAttribute'
op|'='
name|'None'
newline|'\n'
name|'proxy'
op|'='
name|'proxyForInterface'
op|'('
name|'IProxiedInterface'
op|')'
op|'('
name|'yayable'
op|')'
newline|'\n'
name|'del'
name|'proxy'
op|'.'
name|'ifaceAttribute'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'hasattr'
op|'('
name|'yayable'
op|','
string|"'ifaceAttribute'"
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_multipleMethods
dedent|''
name|'def'
name|'test_multipleMethods'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        [Regression test] The proxy should send its method calls to the correct\n        method, not the incorrect one.\n        """'
newline|'\n'
name|'multi'
op|'='
name|'MultipleMethodImplementor'
op|'('
op|')'
newline|'\n'
name|'proxy'
op|'='
name|'proxyForInterface'
op|'('
name|'IMultipleMethods'
op|')'
op|'('
name|'multi'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'proxy'
op|'.'
name|'methodOne'
op|'('
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'proxy'
op|'.'
name|'methodTwo'
op|'('
op|')'
op|','
number|'2'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_subclassing
dedent|''
name|'def'
name|'test_subclassing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        It is possible to subclass the result of L{proxyForInterface}.\n        """'
newline|'\n'
nl|'\n'
DECL|class|SpecializedProxy
name|'class'
name|'SpecializedProxy'
op|'('
name|'proxyForInterface'
op|'('
name|'IProxiedInterface'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""\n            A specialized proxy which can decrement the number of yays.\n            """'
newline|'\n'
DECL|member|boo
name|'def'
name|'boo'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
string|'"""\n                Decrement the number of yays.\n                """'
newline|'\n'
name|'self'
op|'.'
name|'original'
op|'.'
name|'yays'
op|'-='
number|'1'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'yayable'
op|'='
name|'Yayable'
op|'('
op|')'
newline|'\n'
name|'special'
op|'='
name|'SpecializedProxy'
op|'('
name|'yayable'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'yayable'
op|'.'
name|'yays'
op|','
number|'0'
op|')'
newline|'\n'
name|'special'
op|'.'
name|'boo'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'yayable'
op|'.'
name|'yays'
op|','
op|'-'
number|'1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_proxyName
dedent|''
name|'def'
name|'test_proxyName'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The name of a proxy class indicates which interface it proxies.\n        """'
newline|'\n'
name|'proxy'
op|'='
name|'proxyForInterface'
op|'('
name|'IProxiedInterface'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'proxy'
op|'.'
name|'__name__'
op|','
nl|'\n'
string|'"(Proxy for "'
nl|'\n'
string|'"twisted.python.test.test_components.IProxiedInterface)"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_implements
dedent|''
name|'def'
name|'test_implements'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The resulting proxy implements the interface that it proxies.\n        """'
newline|'\n'
name|'proxy'
op|'='
name|'proxyForInterface'
op|'('
name|'IProxiedInterface'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'IProxiedInterface'
op|'.'
name|'implementedBy'
op|'('
name|'proxy'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_proxyDescriptorGet
dedent|''
name|'def'
name|'test_proxyDescriptorGet'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        _ProxyDescriptor\'s __get__ method should return the appropriate\n        attribute of its argument\'s \'original\' attribute if it is invoked with\n        an object.  If it is invoked with None, it should return a false\n        class-method emulator instead.\n\n        For some reason, Python\'s documentation recommends to define\n        descriptors\' __get__ methods with the \'type\' parameter as optional,\n        despite the fact that Python itself never actually calls the descriptor\n        that way.  This is probably do to support \'foo.__get__(bar)\' as an\n        idiom.  Let\'s make sure that the behavior is correct.  Since we don\'t\n        actually use the \'type\' argument at all, this test calls it the\n        idiomatic way to ensure that signature works; test_proxyInheritance\n        verifies the how-Python-actually-calls-it signature.\n        """'
newline|'\n'
DECL|class|Sample
name|'class'
name|'Sample'
op|':'
newline|'\n'
DECL|variable|called
indent|'            '
name|'called'
op|'='
name|'False'
newline|'\n'
DECL|member|hello
name|'def'
name|'hello'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'called'
op|'='
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'fakeProxy'
op|'='
name|'Sample'
op|'('
op|')'
newline|'\n'
name|'testObject'
op|'='
name|'Sample'
op|'('
op|')'
newline|'\n'
name|'fakeProxy'
op|'.'
name|'original'
op|'='
name|'testObject'
newline|'\n'
name|'pd'
op|'='
name|'components'
op|'.'
name|'_ProxyDescriptor'
op|'('
string|'"hello"'
op|','
string|'"original"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'pd'
op|'.'
name|'__get__'
op|'('
name|'fakeProxy'
op|')'
op|','
name|'testObject'
op|'.'
name|'hello'
op|')'
newline|'\n'
name|'fakeClassMethod'
op|'='
name|'pd'
op|'.'
name|'__get__'
op|'('
name|'None'
op|')'
newline|'\n'
name|'fakeClassMethod'
op|'('
name|'fakeProxy'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'testObject'
op|'.'
name|'called'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_proxyInheritance
dedent|''
name|'def'
name|'test_proxyInheritance'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Subclasses of the class returned from L{proxyForInterface} should be\n        able to upcall methods by reference to their superclass, as any normal\n        Python class can.\n        """'
newline|'\n'
DECL|class|YayableWrapper
name|'class'
name|'YayableWrapper'
op|'('
name|'proxyForInterface'
op|'('
name|'IProxiedInterface'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""\n            This class does not override any functionality.\n            """'
newline|'\n'
nl|'\n'
DECL|class|EnhancedWrapper
dedent|''
name|'class'
name|'EnhancedWrapper'
op|'('
name|'YayableWrapper'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""\n            This class overrides the \'yay\' method.\n            """'
newline|'\n'
DECL|variable|wrappedYays
name|'wrappedYays'
op|'='
number|'1'
newline|'\n'
DECL|member|yay
name|'def'
name|'yay'
op|'('
name|'self'
op|','
op|'*'
name|'a'
op|','
op|'**'
name|'k'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'wrappedYays'
op|'+='
number|'1'
newline|'\n'
name|'return'
name|'YayableWrapper'
op|'.'
name|'yay'
op|'('
name|'self'
op|','
op|'*'
name|'a'
op|','
op|'**'
name|'k'
op|')'
op|'+'
number|'7'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'yayable'
op|'='
name|'Yayable'
op|'('
op|')'
newline|'\n'
name|'wrapper'
op|'='
name|'EnhancedWrapper'
op|'('
name|'yayable'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'wrapper'
op|'.'
name|'yay'
op|'('
number|'3'
op|','
number|'4'
op|','
name|'x'
op|'='
number|'5'
op|','
name|'y'
op|'='
number|'6'
op|')'
op|','
number|'8'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'yayable'
op|'.'
name|'yayArgs'
op|','
nl|'\n'
op|'['
op|'('
op|'('
number|'3'
op|','
number|'4'
op|')'
op|','
name|'dict'
op|'('
name|'x'
op|'='
number|'5'
op|','
name|'y'
op|'='
number|'6'
op|')'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_interfaceInheritance
dedent|''
name|'def'
name|'test_interfaceInheritance'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Proxies of subinterfaces generated with proxyForInterface should allow\n        access to attributes of both the child and the base interfaces.\n        """'
newline|'\n'
name|'proxyClass'
op|'='
name|'proxyForInterface'
op|'('
name|'IProxiedSubInterface'
op|')'
newline|'\n'
name|'booable'
op|'='
name|'Booable'
op|'('
op|')'
newline|'\n'
name|'proxy'
op|'='
name|'proxyClass'
op|'('
name|'booable'
op|')'
newline|'\n'
name|'proxy'
op|'.'
name|'yay'
op|'('
op|')'
newline|'\n'
name|'proxy'
op|'.'
name|'boo'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'booable'
op|'.'
name|'yayed'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'booable'
op|'.'
name|'booed'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_attributeCustomization
dedent|''
name|'def'
name|'test_attributeCustomization'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The original attribute name can be customized via the\n        C{originalAttribute} argument of L{proxyForInterface}: the attribute\n        should change, but the methods of the original object should still be\n        callable, and the attributes still accessible.\n        """'
newline|'\n'
name|'yayable'
op|'='
name|'Yayable'
op|'('
op|')'
newline|'\n'
name|'yayable'
op|'.'
name|'ifaceAttribute'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
name|'proxy'
op|'='
name|'proxyForInterface'
op|'('
nl|'\n'
name|'IProxiedInterface'
op|','
name|'originalAttribute'
op|'='
string|"'foo'"
op|')'
op|'('
name|'yayable'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'proxy'
op|'.'
name|'foo'
op|','
name|'yayable'
op|')'
newline|'\n'
nl|'\n'
comment|'# Check the behavior'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'proxy'
op|'.'
name|'yay'
op|'('
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'proxy'
op|'.'
name|'ifaceAttribute'
op|','
name|'yayable'
op|'.'
name|'ifaceAttribute'
op|')'
newline|'\n'
name|'thingy'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
name|'proxy'
op|'.'
name|'ifaceAttribute'
op|'='
name|'thingy'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'yayable'
op|'.'
name|'ifaceAttribute'
op|','
name|'thingy'
op|')'
newline|'\n'
name|'del'
name|'proxy'
op|'.'
name|'ifaceAttribute'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'hasattr'
op|'('
name|'yayable'
op|','
string|"'ifaceAttribute'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
