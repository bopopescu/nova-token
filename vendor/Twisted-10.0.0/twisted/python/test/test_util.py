begin_unit
comment|'# -*- test-case-name: twisted.test.test_util -*-'
nl|'\n'
comment|'# Copyright (c) 2001-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
name|'import'
name|'os'
op|'.'
name|'path'
op|','
name|'sys'
newline|'\n'
name|'import'
name|'shutil'
op|','
name|'errno'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'import'
name|'pwd'
op|','
name|'grp'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
indent|'    '
name|'pwd'
op|'='
name|'grp'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'util'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'reactor'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'interfaces'
name|'import'
name|'IReactorProcess'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'protocol'
name|'import'
name|'ProcessProtocol'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'defer'
name|'import'
name|'Deferred'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'error'
name|'import'
name|'ProcessDone'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'test'
op|'.'
name|'test_process'
name|'import'
name|'MockOS'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|UtilTestCase
name|'class'
name|'UtilTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|testUniq
indent|'    '
name|'def'
name|'testUniq'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'l'
op|'='
op|'['
string|'"a"'
op|','
number|'1'
op|','
string|'"ab"'
op|','
string|'"a"'
op|','
number|'3'
op|','
number|'4'
op|','
number|'1'
op|','
number|'2'
op|','
number|'2'
op|','
number|'4'
op|','
number|'6'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'util'
op|'.'
name|'uniquify'
op|'('
name|'l'
op|')'
op|','
op|'['
string|'"a"'
op|','
number|'1'
op|','
string|'"ab"'
op|','
number|'3'
op|','
number|'4'
op|','
number|'2'
op|','
number|'6'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testRaises
dedent|''
name|'def'
name|'testRaises'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'util'
op|'.'
name|'raises'
op|'('
name|'ZeroDivisionError'
op|','
name|'divmod'
op|','
number|'1'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'util'
op|'.'
name|'raises'
op|'('
name|'ZeroDivisionError'
op|','
name|'divmod'
op|','
number|'0'
op|','
number|'1'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'util'
op|'.'
name|'raises'
op|'('
name|'TypeError'
op|','
name|'divmod'
op|','
number|'1'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ZeroDivisionError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'unittest'
op|'.'
name|'FailTest'
op|','
string|'"util.raises didn\'t raise when it should have"'
newline|'\n'
nl|'\n'
DECL|member|testUninterruptably
dedent|''
dedent|''
name|'def'
name|'testUninterruptably'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
DECL|function|f
indent|'        '
name|'def'
name|'f'
op|'('
name|'a'
op|','
name|'b'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'calls'
op|'+='
number|'1'
newline|'\n'
name|'exc'
op|'='
name|'self'
op|'.'
name|'exceptions'
op|'.'
name|'pop'
op|'('
op|')'
newline|'\n'
name|'if'
name|'exc'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exc'
op|'('
name|'errno'
op|'.'
name|'EINTR'
op|','
string|'"Interrupted system call!"'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'a'
op|'+'
name|'b'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'exceptions'
op|'='
op|'['
name|'None'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'calls'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'util'
op|'.'
name|'untilConcludes'
op|'('
name|'f'
op|','
number|'1'
op|','
number|'2'
op|')'
op|','
number|'3'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'calls'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'exceptions'
op|'='
op|'['
name|'None'
op|','
name|'OSError'
op|','
name|'IOError'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'calls'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'util'
op|'.'
name|'untilConcludes'
op|'('
name|'f'
op|','
number|'2'
op|','
number|'3'
op|')'
op|','
number|'5'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'calls'
op|','
number|'3'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testNameToLabel
dedent|''
name|'def'
name|'testNameToLabel'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test the various kinds of inputs L{nameToLabel} supports.\n        """'
newline|'\n'
name|'nameData'
op|'='
op|'['
nl|'\n'
op|'('
string|"'f'"
op|','
string|"'F'"
op|')'
op|','
nl|'\n'
op|'('
string|"'fo'"
op|','
string|"'Fo'"
op|')'
op|','
nl|'\n'
op|'('
string|"'foo'"
op|','
string|"'Foo'"
op|')'
op|','
nl|'\n'
op|'('
string|"'fooBar'"
op|','
string|"'Foo Bar'"
op|')'
op|','
nl|'\n'
op|'('
string|"'fooBarBaz'"
op|','
string|"'Foo Bar Baz'"
op|')'
op|','
nl|'\n'
op|']'
newline|'\n'
name|'for'
name|'inp'
op|','
name|'out'
name|'in'
name|'nameData'
op|':'
newline|'\n'
indent|'            '
name|'got'
op|'='
name|'util'
op|'.'
name|'nameToLabel'
op|'('
name|'inp'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'got'
op|','
name|'out'
op|','
nl|'\n'
string|'"nameToLabel(%r) == %r != %r"'
op|'%'
op|'('
name|'inp'
op|','
name|'got'
op|','
name|'out'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_uidFromNumericString
dedent|''
dedent|''
name|'def'
name|'test_uidFromNumericString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When L{uidFromString} is called with a base-ten string representation\n        of an integer, it returns the integer.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'util'
op|'.'
name|'uidFromString'
op|'('
string|'"100"'
op|')'
op|','
number|'100'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_uidFromUsernameString
dedent|''
name|'def'
name|'test_uidFromUsernameString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When L{uidFromString} is called with a base-ten string representation\n        of an integer, it returns the integer.\n        """'
newline|'\n'
name|'pwent'
op|'='
name|'pwd'
op|'.'
name|'getpwuid'
op|'('
name|'os'
op|'.'
name|'getuid'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'util'
op|'.'
name|'uidFromString'
op|'('
name|'pwent'
op|'.'
name|'pw_name'
op|')'
op|','
name|'pwent'
op|'.'
name|'pw_uid'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'pwd'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'test_uidFromUsernameString'
op|'.'
name|'skip'
op|'='
op|'('
nl|'\n'
string|'"Username/UID conversion requires the pwd module."'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_gidFromNumericString
dedent|''
name|'def'
name|'test_gidFromNumericString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When L{gidFromString} is called with a base-ten string representation\n        of an integer, it returns the integer.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'util'
op|'.'
name|'gidFromString'
op|'('
string|'"100"'
op|')'
op|','
number|'100'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_gidFromGroupnameString
dedent|''
name|'def'
name|'test_gidFromGroupnameString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When L{gidFromString} is called with a base-ten string representation\n        of an integer, it returns the integer.\n        """'
newline|'\n'
name|'grent'
op|'='
name|'grp'
op|'.'
name|'getgrgid'
op|'('
name|'os'
op|'.'
name|'getgid'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'util'
op|'.'
name|'gidFromString'
op|'('
name|'grent'
op|'.'
name|'gr_name'
op|')'
op|','
name|'grent'
op|'.'
name|'gr_gid'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'grp'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'test_gidFromGroupnameString'
op|'.'
name|'skip'
op|'='
op|'('
nl|'\n'
string|'"Group Name/GID conversion requires the grp module."'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_moduleMovedForSplitDeprecation
dedent|''
name|'def'
name|'test_moduleMovedForSplitDeprecation'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Calling L{moduleMovedForSplit} results in a deprecation warning.\n        """'
newline|'\n'
name|'util'
op|'.'
name|'moduleMovedForSplit'
op|'('
string|'"foo"'
op|','
string|'"bar"'
op|','
string|'"baz"'
op|','
string|'"quux"'
op|','
string|'"corge"'
op|','
op|'{'
op|'}'
op|')'
newline|'\n'
name|'warnings'
op|'='
name|'self'
op|'.'
name|'flushWarnings'
op|'('
nl|'\n'
name|'offendingFunctions'
op|'='
op|'['
name|'self'
op|'.'
name|'test_moduleMovedForSplitDeprecation'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'warnings'
op|'['
number|'0'
op|']'
op|'['
string|"'message'"
op|']'
op|','
nl|'\n'
string|'"moduleMovedForSplit is deprecated since Twisted 9.0."'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'warnings'
op|'['
number|'0'
op|']'
op|'['
string|"'category'"
op|']'
op|','
name|'DeprecationWarning'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'warnings'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestMergeFunctionMetadata
dedent|''
dedent|''
name|'class'
name|'TestMergeFunctionMetadata'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{mergeFunctionMetadata}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|test_mergedFunctionBehavesLikeMergeTarget
name|'def'
name|'test_mergedFunctionBehavesLikeMergeTarget'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        After merging C{foo}\'s data into C{bar}, the returned function behaves\n        as if it is C{bar}.\n        """'
newline|'\n'
name|'foo_object'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
name|'bar_object'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|foo
name|'def'
name|'foo'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'foo_object'
newline|'\n'
nl|'\n'
DECL|function|bar
dedent|''
name|'def'
name|'bar'
op|'('
name|'x'
op|','
name|'y'
op|','
op|'('
name|'a'
op|','
name|'b'
op|')'
op|','
name|'c'
op|'='
number|'10'
op|','
op|'*'
name|'d'
op|','
op|'**'
name|'e'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'bar_object'
newline|'\n'
nl|'\n'
dedent|''
name|'baz'
op|'='
name|'util'
op|'.'
name|'mergeFunctionMetadata'
op|'('
name|'foo'
op|','
name|'bar'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'baz'
op|'('
number|'1'
op|','
number|'2'
op|','
op|'('
number|'3'
op|','
number|'4'
op|')'
op|','
name|'quux'
op|'='
number|'10'
op|')'
op|','
name|'bar_object'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_moduleIsMerged
dedent|''
name|'def'
name|'test_moduleIsMerged'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Merging C{foo} into C{bar} returns a function with C{foo}\'s\n        C{__module__}.\n        """'
newline|'\n'
DECL|function|foo
name|'def'
name|'foo'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
DECL|function|bar
dedent|''
name|'def'
name|'bar'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'bar'
op|'.'
name|'__module__'
op|'='
string|"'somewhere.else'"
newline|'\n'
nl|'\n'
name|'baz'
op|'='
name|'util'
op|'.'
name|'mergeFunctionMetadata'
op|'('
name|'foo'
op|','
name|'bar'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'baz'
op|'.'
name|'__module__'
op|','
name|'foo'
op|'.'
name|'__module__'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_docstringIsMerged
dedent|''
name|'def'
name|'test_docstringIsMerged'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Merging C{foo} into C{bar} returns a function with C{foo}\'s docstring.\n        """'
newline|'\n'
nl|'\n'
DECL|function|foo
name|'def'
name|'foo'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""\n            This is foo.\n            """'
newline|'\n'
nl|'\n'
DECL|function|bar
dedent|''
name|'def'
name|'bar'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""\n            This is bar.\n            """'
newline|'\n'
nl|'\n'
dedent|''
name|'baz'
op|'='
name|'util'
op|'.'
name|'mergeFunctionMetadata'
op|'('
name|'foo'
op|','
name|'bar'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'baz'
op|'.'
name|'__doc__'
op|','
name|'foo'
op|'.'
name|'__doc__'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_nameIsMerged
dedent|''
name|'def'
name|'test_nameIsMerged'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Merging C{foo} into C{bar} returns a function with C{foo}\'s name.\n        """'
newline|'\n'
nl|'\n'
DECL|function|foo
name|'def'
name|'foo'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
DECL|function|bar
dedent|''
name|'def'
name|'bar'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
dedent|''
name|'baz'
op|'='
name|'util'
op|'.'
name|'mergeFunctionMetadata'
op|'('
name|'foo'
op|','
name|'bar'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'baz'
op|'.'
name|'__name__'
op|','
name|'foo'
op|'.'
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_instanceDictionaryIsMerged
dedent|''
name|'def'
name|'test_instanceDictionaryIsMerged'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Merging C{foo} into C{bar} returns a function with C{bar}\'s\n        dictionary, updated by C{foo}\'s.\n        """'
newline|'\n'
nl|'\n'
DECL|function|foo
name|'def'
name|'foo'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'foo'
op|'.'
name|'a'
op|'='
number|'1'
newline|'\n'
name|'foo'
op|'.'
name|'b'
op|'='
number|'2'
newline|'\n'
nl|'\n'
DECL|function|bar
name|'def'
name|'bar'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'bar'
op|'.'
name|'b'
op|'='
number|'3'
newline|'\n'
name|'bar'
op|'.'
name|'c'
op|'='
number|'4'
newline|'\n'
nl|'\n'
name|'baz'
op|'='
name|'util'
op|'.'
name|'mergeFunctionMetadata'
op|'('
name|'foo'
op|','
name|'bar'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'foo'
op|'.'
name|'a'
op|','
name|'baz'
op|'.'
name|'a'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'foo'
op|'.'
name|'b'
op|','
name|'baz'
op|'.'
name|'b'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'bar'
op|'.'
name|'c'
op|','
name|'baz'
op|'.'
name|'c'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|OrderedDictTest
dedent|''
dedent|''
name|'class'
name|'OrderedDictTest'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|testOrderedDict
indent|'    '
name|'def'
name|'testOrderedDict'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'d'
op|'='
name|'util'
op|'.'
name|'OrderedDict'
op|'('
op|')'
newline|'\n'
name|'d'
op|'['
string|"'a'"
op|']'
op|'='
string|"'b'"
newline|'\n'
name|'d'
op|'['
string|"'b'"
op|']'
op|'='
string|"'a'"
newline|'\n'
name|'d'
op|'['
number|'3'
op|']'
op|'='
number|'12'
newline|'\n'
name|'d'
op|'['
number|'1234'
op|']'
op|'='
number|'4321'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'repr'
op|'('
name|'d'
op|')'
op|','
string|'"{\'a\': \'b\', \'b\': \'a\', 3: 12, 1234: 4321}"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'values'
op|'('
op|')'
op|','
op|'['
string|"'b'"
op|','
string|"'a'"
op|','
number|'12'
op|','
number|'4321'
op|']'
op|')'
newline|'\n'
name|'del'
name|'d'
op|'['
number|'3'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'repr'
op|'('
name|'d'
op|')'
op|','
string|'"{\'a\': \'b\', \'b\': \'a\', 1234: 4321}"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|','
op|'{'
string|"'a'"
op|':'
string|"'b'"
op|','
string|"'b'"
op|':'
string|"'a'"
op|','
number|'1234'
op|':'
number|'4321'
op|'}'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'keys'
op|'('
op|')'
op|','
op|'['
string|"'a'"
op|','
string|"'b'"
op|','
number|'1234'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'list'
op|'('
name|'d'
op|'.'
name|'iteritems'
op|'('
op|')'
op|')'
op|','
nl|'\n'
op|'['
op|'('
string|"'a'"
op|','
string|"'b'"
op|')'
op|','
op|'('
string|"'b'"
op|','
string|"'a'"
op|')'
op|','
op|'('
number|'1234'
op|','
number|'4321'
op|')'
op|']'
op|')'
newline|'\n'
name|'item'
op|'='
name|'d'
op|'.'
name|'popitem'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'item'
op|','
op|'('
number|'1234'
op|','
number|'4321'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testInitialization
dedent|''
name|'def'
name|'testInitialization'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'d'
op|'='
name|'util'
op|'.'
name|'OrderedDict'
op|'('
op|'{'
string|"'monkey'"
op|':'
string|"'ook'"
op|','
nl|'\n'
string|"'apple'"
op|':'
string|"'red'"
op|'}'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'d'
op|'.'
name|'_order'
op|')'
newline|'\n'
nl|'\n'
name|'d'
op|'='
name|'util'
op|'.'
name|'OrderedDict'
op|'('
op|'('
op|'('
number|'1'
op|','
number|'1'
op|')'
op|','
op|'('
number|'3'
op|','
number|'3'
op|')'
op|','
op|'('
number|'2'
op|','
number|'2'
op|')'
op|','
op|'('
number|'0'
op|','
number|'0'
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'repr'
op|'('
name|'d'
op|')'
op|','
string|'"{1: 1, 3: 3, 2: 2, 0: 0}"'
op|')'
newline|'\n'
nl|'\n'
DECL|class|InsensitiveDictTest
dedent|''
dedent|''
name|'class'
name|'InsensitiveDictTest'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|testPreserve
indent|'    '
name|'def'
name|'testPreserve'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'InsensitiveDict'
op|'='
name|'util'
op|'.'
name|'InsensitiveDict'
newline|'\n'
name|'dct'
op|'='
name|'InsensitiveDict'
op|'('
op|'{'
string|"'Foo'"
op|':'
string|"'bar'"
op|','
number|'1'
op|':'
number|'2'
op|','
string|"'fnz'"
op|':'
op|'{'
number|'1'
op|':'
number|'2'
op|'}'
op|'}'
op|','
name|'preserve'
op|'='
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'dct'
op|'['
string|"'fnz'"
op|']'
op|','
op|'{'
number|'1'
op|':'
number|'2'
op|'}'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'dct'
op|'['
string|"'foo'"
op|']'
op|','
string|"'bar'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'dct'
op|'.'
name|'copy'
op|'('
op|')'
op|','
name|'dct'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'dct'
op|'['
string|"'foo'"
op|']'
op|','
name|'dct'
op|'.'
name|'get'
op|'('
string|"'Foo'"
op|')'
op|')'
newline|'\n'
name|'assert'
number|'1'
name|'in'
name|'dct'
name|'and'
string|"'foo'"
name|'in'
name|'dct'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'eval'
op|'('
name|'repr'
op|'('
name|'dct'
op|')'
op|')'
op|','
name|'dct'
op|')'
newline|'\n'
name|'keys'
op|'='
op|'['
string|"'Foo'"
op|','
string|"'fnz'"
op|','
number|'1'
op|']'
newline|'\n'
name|'for'
name|'x'
name|'in'
name|'keys'
op|':'
newline|'\n'
indent|'            '
name|'assert'
name|'x'
name|'in'
name|'dct'
op|'.'
name|'keys'
op|'('
op|')'
newline|'\n'
name|'assert'
op|'('
name|'x'
op|','
name|'dct'
op|'['
name|'x'
op|']'
op|')'
name|'in'
name|'dct'
op|'.'
name|'items'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'keys'
op|')'
op|','
name|'len'
op|'('
name|'dct'
op|')'
op|')'
newline|'\n'
name|'del'
name|'dct'
op|'['
number|'1'
op|']'
newline|'\n'
name|'del'
name|'dct'
op|'['
string|"'foo'"
op|']'
newline|'\n'
nl|'\n'
DECL|member|testNoPreserve
dedent|''
name|'def'
name|'testNoPreserve'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'InsensitiveDict'
op|'='
name|'util'
op|'.'
name|'InsensitiveDict'
newline|'\n'
name|'dct'
op|'='
name|'InsensitiveDict'
op|'('
op|'{'
string|"'Foo'"
op|':'
string|"'bar'"
op|','
number|'1'
op|':'
number|'2'
op|','
string|"'fnz'"
op|':'
op|'{'
number|'1'
op|':'
number|'2'
op|'}'
op|'}'
op|','
name|'preserve'
op|'='
number|'0'
op|')'
newline|'\n'
name|'keys'
op|'='
op|'['
string|"'foo'"
op|','
string|"'fnz'"
op|','
number|'1'
op|']'
newline|'\n'
name|'for'
name|'x'
name|'in'
name|'keys'
op|':'
newline|'\n'
indent|'            '
name|'assert'
name|'x'
name|'in'
name|'dct'
op|'.'
name|'keys'
op|'('
op|')'
newline|'\n'
name|'assert'
op|'('
name|'x'
op|','
name|'dct'
op|'['
name|'x'
op|']'
op|')'
name|'in'
name|'dct'
op|'.'
name|'items'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'keys'
op|')'
op|','
name|'len'
op|'('
name|'dct'
op|')'
op|')'
newline|'\n'
name|'del'
name|'dct'
op|'['
number|'1'
op|']'
newline|'\n'
name|'del'
name|'dct'
op|'['
string|"'foo'"
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|PasswordTestingProcessProtocol
dedent|''
dedent|''
name|'class'
name|'PasswordTestingProcessProtocol'
op|'('
name|'ProcessProtocol'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Write the string C{"secret\\n"} to a subprocess and then collect all of\n    its output and fire a Deferred with it when the process ends.\n    """'
newline|'\n'
DECL|member|connectionMade
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'output'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
string|"'secret\\n'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|childDataReceived
dedent|''
name|'def'
name|'childDataReceived'
op|'('
name|'self'
op|','
name|'fd'
op|','
name|'output'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'output'
op|'.'
name|'append'
op|'('
op|'('
name|'fd'
op|','
name|'output'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|processEnded
dedent|''
name|'def'
name|'processEnded'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'finished'
op|'.'
name|'callback'
op|'('
op|'('
name|'reason'
op|','
name|'self'
op|'.'
name|'output'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|GetPasswordTest
dedent|''
dedent|''
name|'class'
name|'GetPasswordTest'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'not'
name|'IReactorProcess'
op|'.'
name|'providedBy'
op|'('
name|'reactor'
op|')'
op|':'
newline|'\n'
DECL|variable|skip
indent|'        '
name|'skip'
op|'='
string|'"Process support required to test getPassword"'
newline|'\n'
nl|'\n'
DECL|member|test_stdin
dedent|''
name|'def'
name|'test_stdin'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Making sure getPassword accepts a password from standard input by\n        running a child process which uses getPassword to read in a string\n        which it then writes it out again.  Write a string to the child\n        process and then read one and make sure it is the right string.\n        """'
newline|'\n'
name|'p'
op|'='
name|'PasswordTestingProcessProtocol'
op|'('
op|')'
newline|'\n'
name|'p'
op|'.'
name|'finished'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'spawnProcess'
op|'('
nl|'\n'
name|'p'
op|','
nl|'\n'
name|'sys'
op|'.'
name|'executable'
op|','
nl|'\n'
op|'['
name|'sys'
op|'.'
name|'executable'
op|','
nl|'\n'
string|"'-c'"
op|','
nl|'\n'
op|'('
string|"'import sys\\n'"
nl|'\n'
string|"'from twisted.python.util import getPassword\\n'"
nl|'\n'
string|"'sys.stdout.write(getPassword())\\n'"
nl|'\n'
string|"'sys.stdout.flush()\\n'"
op|')'
op|']'
op|','
nl|'\n'
name|'env'
op|'='
op|'{'
string|"'PYTHONPATH'"
op|':'
name|'os'
op|'.'
name|'pathsep'
op|'.'
name|'join'
op|'('
name|'sys'
op|'.'
name|'path'
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
DECL|function|processFinished
name|'def'
name|'processFinished'
op|'('
op|'('
name|'reason'
op|','
name|'output'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'.'
name|'trap'
op|'('
name|'ProcessDone'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIn'
op|'('
op|'('
number|'1'
op|','
string|"'secret'"
op|')'
op|','
name|'output'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'p'
op|'.'
name|'finished'
op|'.'
name|'addCallback'
op|'('
name|'processFinished'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|SearchUpwardsTest
dedent|''
dedent|''
name|'class'
name|'SearchUpwardsTest'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|testSearchupwards
indent|'    '
name|'def'
name|'testSearchupwards'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'os'
op|'.'
name|'makedirs'
op|'('
string|"'searchupwards/a/b/c'"
op|')'
newline|'\n'
name|'file'
op|'('
string|"'searchupwards/foo.txt'"
op|','
string|"'w'"
op|')'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'file'
op|'('
string|"'searchupwards/a/foo.txt'"
op|','
string|"'w'"
op|')'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'file'
op|'('
string|"'searchupwards/a/b/c/foo.txt'"
op|','
string|"'w'"
op|')'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'os'
op|'.'
name|'mkdir'
op|'('
string|"'searchupwards/bar'"
op|')'
newline|'\n'
name|'os'
op|'.'
name|'mkdir'
op|'('
string|"'searchupwards/bam'"
op|')'
newline|'\n'
name|'os'
op|'.'
name|'mkdir'
op|'('
string|"'searchupwards/a/bar'"
op|')'
newline|'\n'
name|'os'
op|'.'
name|'mkdir'
op|'('
string|"'searchupwards/a/b/bam'"
op|')'
newline|'\n'
name|'actual'
op|'='
name|'util'
op|'.'
name|'searchupwards'
op|'('
string|"'searchupwards/a/b/c'"
op|','
nl|'\n'
name|'files'
op|'='
op|'['
string|"'foo.txt'"
op|']'
op|','
nl|'\n'
name|'dirs'
op|'='
op|'['
string|"'bar'"
op|','
string|"'bam'"
op|']'
op|')'
newline|'\n'
name|'expected'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'abspath'
op|'('
string|"'searchupwards'"
op|')'
op|'+'
name|'os'
op|'.'
name|'sep'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'actual'
op|','
name|'expected'
op|')'
newline|'\n'
name|'shutil'
op|'.'
name|'rmtree'
op|'('
string|"'searchupwards'"
op|')'
newline|'\n'
name|'actual'
op|'='
name|'util'
op|'.'
name|'searchupwards'
op|'('
string|"'searchupwards/a/b/c'"
op|','
nl|'\n'
name|'files'
op|'='
op|'['
string|"'foo.txt'"
op|']'
op|','
nl|'\n'
name|'dirs'
op|'='
op|'['
string|"'bar'"
op|','
string|"'bam'"
op|']'
op|')'
newline|'\n'
name|'expected'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'actual'
op|','
name|'expected'
op|')'
newline|'\n'
nl|'\n'
DECL|class|Foo
dedent|''
dedent|''
name|'class'
name|'Foo'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'x'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'x'
op|'='
name|'x'
newline|'\n'
nl|'\n'
DECL|class|DSU
dedent|''
dedent|''
name|'class'
name|'DSU'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|testDSU
indent|'    '
name|'def'
name|'testDSU'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'L'
op|'='
op|'['
name|'Foo'
op|'('
name|'x'
op|')'
name|'for'
name|'x'
name|'in'
name|'range'
op|'('
number|'20'
op|','
number|'9'
op|','
op|'-'
number|'1'
op|')'
op|']'
newline|'\n'
name|'L2'
op|'='
name|'util'
op|'.'
name|'dsu'
op|'('
name|'L'
op|','
name|'lambda'
name|'o'
op|':'
name|'o'
op|'.'
name|'x'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'range'
op|'('
number|'10'
op|','
number|'21'
op|')'
op|','
op|'['
name|'o'
op|'.'
name|'x'
name|'for'
name|'o'
name|'in'
name|'L2'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|class|IntervalDifferentialTestCase
dedent|''
dedent|''
name|'class'
name|'IntervalDifferentialTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|testDefault
indent|'    '
name|'def'
name|'testDefault'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'d'
op|'='
name|'iter'
op|'('
name|'util'
op|'.'
name|'IntervalDifferential'
op|'('
op|'['
op|']'
op|','
number|'10'
op|')'
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
number|'100'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'10'
op|','
name|'None'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testSingle
dedent|''
dedent|''
name|'def'
name|'testSingle'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'d'
op|'='
name|'iter'
op|'('
name|'util'
op|'.'
name|'IntervalDifferential'
op|'('
op|'['
number|'5'
op|']'
op|','
number|'10'
op|')'
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
number|'100'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'5'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testPair
dedent|''
dedent|''
name|'def'
name|'testPair'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'d'
op|'='
name|'iter'
op|'('
name|'util'
op|'.'
name|'IntervalDifferential'
op|'('
op|'['
number|'5'
op|','
number|'7'
op|']'
op|','
number|'10'
op|')'
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
number|'100'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'5'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'2'
op|','
number|'1'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'3'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'4'
op|','
number|'1'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'1'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'5'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'1'
op|','
number|'1'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'4'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'3'
op|','
number|'1'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'2'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'5'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'0'
op|','
number|'1'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testTriple
dedent|''
dedent|''
name|'def'
name|'testTriple'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'d'
op|'='
name|'iter'
op|'('
name|'util'
op|'.'
name|'IntervalDifferential'
op|'('
op|'['
number|'2'
op|','
number|'4'
op|','
number|'5'
op|']'
op|','
number|'10'
op|')'
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
number|'100'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'2'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'2'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'0'
op|','
number|'1'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'1'
op|','
number|'2'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'1'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'2'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'0'
op|','
number|'1'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'2'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'0'
op|','
number|'2'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'2'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'0'
op|','
number|'1'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'2'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'1'
op|','
number|'2'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'1'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'0'
op|','
number|'1'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'2'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'2'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'0'
op|','
number|'1'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'0'
op|','
number|'2'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testInsert
dedent|''
dedent|''
name|'def'
name|'testInsert'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'d'
op|'='
name|'iter'
op|'('
name|'util'
op|'.'
name|'IntervalDifferential'
op|'('
op|'['
op|']'
op|','
number|'10'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'10'
op|','
name|'None'
op|')'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addInterval'
op|'('
number|'3'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'3'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'3'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addInterval'
op|'('
number|'6'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'3'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'3'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'0'
op|','
number|'1'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'3'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'3'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'0'
op|','
number|'1'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testRemove
dedent|''
name|'def'
name|'testRemove'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'d'
op|'='
name|'iter'
op|'('
name|'util'
op|'.'
name|'IntervalDifferential'
op|'('
op|'['
number|'3'
op|','
number|'5'
op|']'
op|','
number|'10'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'3'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'2'
op|','
number|'1'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'1'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'removeInterval'
op|'('
number|'3'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'4'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'5'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'removeInterval'
op|'('
number|'5'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|'.'
name|'next'
op|'('
op|')'
op|','
op|'('
number|'10'
op|','
name|'None'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'ValueError'
op|','
name|'d'
op|'.'
name|'removeInterval'
op|','
number|'10'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|Record
dedent|''
dedent|''
name|'class'
name|'Record'
op|'('
name|'util'
op|'.'
name|'FancyEqMixin'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Trivial user of L{FancyEqMixin} used by tests.\n    """'
newline|'\n'
DECL|variable|compareAttributes
name|'compareAttributes'
op|'='
op|'('
string|"'a'"
op|','
string|"'b'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'a'
op|','
name|'b'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'a'
op|'='
name|'a'
newline|'\n'
name|'self'
op|'.'
name|'b'
op|'='
name|'b'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DifferentRecord
dedent|''
dedent|''
name|'class'
name|'DifferentRecord'
op|'('
name|'util'
op|'.'
name|'FancyEqMixin'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Trivial user of L{FancyEqMixin} which is not related to L{Record}.\n    """'
newline|'\n'
DECL|variable|compareAttributes
name|'compareAttributes'
op|'='
op|'('
string|"'a'"
op|','
string|"'b'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'a'
op|','
name|'b'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'a'
op|'='
name|'a'
newline|'\n'
name|'self'
op|'.'
name|'b'
op|'='
name|'b'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DerivedRecord
dedent|''
dedent|''
name|'class'
name|'DerivedRecord'
op|'('
name|'Record'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A class with an inheritance relationship to L{Record}.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|EqualToEverything
dedent|''
name|'class'
name|'EqualToEverything'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A class the instances of which consider themselves equal to everything.\n    """'
newline|'\n'
DECL|member|__eq__
name|'def'
name|'__eq__'
op|'('
name|'self'
op|','
name|'other'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__ne__
dedent|''
name|'def'
name|'__ne__'
op|'('
name|'self'
op|','
name|'other'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|EqualToNothing
dedent|''
dedent|''
name|'class'
name|'EqualToNothing'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A class the instances of which consider themselves equal to nothing.\n    """'
newline|'\n'
DECL|member|__eq__
name|'def'
name|'__eq__'
op|'('
name|'self'
op|','
name|'other'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__ne__
dedent|''
name|'def'
name|'__ne__'
op|'('
name|'self'
op|','
name|'other'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|EqualityTests
dedent|''
dedent|''
name|'class'
name|'EqualityTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{FancyEqMixin}.\n    """'
newline|'\n'
DECL|member|test_identity
name|'def'
name|'test_identity'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Instances of a class which mixes in L{FancyEqMixin} but which\n        defines no comparison attributes compare by identity.\n        """'
newline|'\n'
DECL|class|Empty
name|'class'
name|'Empty'
op|'('
name|'util'
op|'.'
name|'FancyEqMixin'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'Empty'
op|'('
op|')'
op|'=='
name|'Empty'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'Empty'
op|'('
op|')'
op|'!='
name|'Empty'
op|'('
op|')'
op|')'
newline|'\n'
name|'empty'
op|'='
name|'Empty'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'empty'
op|'=='
name|'empty'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'empty'
op|'!='
name|'empty'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_equality
dedent|''
name|'def'
name|'test_equality'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Instances of a class which mixes in L{FancyEqMixin} should compare\n        equal if all of their attributes compare equal.  They should not\n        compare equal if any of their attributes do not compare equal.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'=='
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'=='
name|'Record'
op|'('
number|'1'
op|','
number|'3'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'=='
name|'Record'
op|'('
number|'2'
op|','
number|'2'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'=='
name|'Record'
op|'('
number|'3'
op|','
number|'4'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_unequality
dedent|''
name|'def'
name|'test_unequality'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Unequality between instances of a particular L{record} should be\n        defined as the negation of equality.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'!='
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'!='
name|'Record'
op|'('
number|'1'
op|','
number|'3'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'!='
name|'Record'
op|'('
number|'2'
op|','
number|'2'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'!='
name|'Record'
op|'('
number|'3'
op|','
number|'4'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_differentClassesEquality
dedent|''
name|'def'
name|'test_differentClassesEquality'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Instances of different classes which mix in L{FancyEqMixin} should not\n        compare equal.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'=='
name|'DifferentRecord'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_differentClassesInequality
dedent|''
name|'def'
name|'test_differentClassesInequality'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Instances of different classes which mix in L{FancyEqMixin} should\n        compare unequal.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'!='
name|'DifferentRecord'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_inheritedClassesEquality
dedent|''
name|'def'
name|'test_inheritedClassesEquality'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        An instance of a class which derives from a class which mixes in\n        L{FancyEqMixin} should compare equal to an instance of the base class\n        if and only if all of their attributes compare equal.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'=='
name|'DerivedRecord'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'=='
name|'DerivedRecord'
op|'('
number|'1'
op|','
number|'3'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'=='
name|'DerivedRecord'
op|'('
number|'2'
op|','
number|'2'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'=='
name|'DerivedRecord'
op|'('
number|'3'
op|','
number|'4'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_inheritedClassesInequality
dedent|''
name|'def'
name|'test_inheritedClassesInequality'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        An instance of a class which derives from a class which mixes in\n        L{FancyEqMixin} should compare unequal to an instance of the base\n        class if any of their attributes compare unequal.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'!='
name|'DerivedRecord'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'!='
name|'DerivedRecord'
op|'('
number|'1'
op|','
number|'3'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'!='
name|'DerivedRecord'
op|'('
number|'2'
op|','
number|'2'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'!='
name|'DerivedRecord'
op|'('
number|'3'
op|','
number|'4'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_rightHandArgumentImplementsEquality
dedent|''
name|'def'
name|'test_rightHandArgumentImplementsEquality'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The right-hand argument to the equality operator is given a chance\n        to determine the result of the operation if it is of a type\n        unrelated to the L{FancyEqMixin}-based instance on the left-hand\n        side.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'=='
name|'EqualToEverything'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'=='
name|'EqualToNothing'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_rightHandArgumentImplementsUnequality
dedent|''
name|'def'
name|'test_rightHandArgumentImplementsUnequality'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The right-hand argument to the non-equality operator is given a\n        chance to determine the result of the operation if it is of a type\n        unrelated to the L{FancyEqMixin}-based instance on the left-hand\n        side.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'!='
name|'EqualToEverything'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'Record'
op|'('
number|'1'
op|','
number|'2'
op|')'
op|'!='
name|'EqualToNothing'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|RunAsEffectiveUserTests
dedent|''
dedent|''
name|'class'
name|'RunAsEffectiveUserTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test for the L{util.runAsEffectiveUser} function.\n    """'
newline|'\n'
nl|'\n'
name|'if'
name|'getattr'
op|'('
name|'os'
op|','
string|'"geteuid"'
op|','
name|'None'
op|')'
name|'is'
name|'None'
op|':'
newline|'\n'
DECL|variable|skip
indent|'        '
name|'skip'
op|'='
string|'"geteuid/seteuid not available"'
newline|'\n'
nl|'\n'
DECL|member|setUp
dedent|''
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'mockos'
op|'='
name|'MockOS'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'patch'
op|'('
name|'os'
op|','
string|'"geteuid"'
op|','
name|'self'
op|'.'
name|'mockos'
op|'.'
name|'geteuid'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'patch'
op|'('
name|'os'
op|','
string|'"getegid"'
op|','
name|'self'
op|'.'
name|'mockos'
op|'.'
name|'getegid'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'patch'
op|'('
name|'os'
op|','
string|'"seteuid"'
op|','
name|'self'
op|'.'
name|'mockos'
op|'.'
name|'seteuid'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'patch'
op|'('
name|'os'
op|','
string|'"setegid"'
op|','
name|'self'
op|'.'
name|'mockos'
op|'.'
name|'setegid'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_securedFunction
dedent|''
name|'def'
name|'_securedFunction'
op|'('
name|'self'
op|','
name|'startUID'
op|','
name|'startGID'
op|','
name|'wantUID'
op|','
name|'wantGID'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check if wanted UID/GID matched start or saved ones.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'wantUID'
op|'=='
name|'startUID'
name|'or'
nl|'\n'
name|'wantUID'
op|'=='
name|'self'
op|'.'
name|'mockos'
op|'.'
name|'seteuidCalls'
op|'['
op|'-'
number|'1'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'wantGID'
op|'=='
name|'startGID'
name|'or'
nl|'\n'
name|'wantGID'
op|'=='
name|'self'
op|'.'
name|'mockos'
op|'.'
name|'setegidCalls'
op|'['
op|'-'
number|'1'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_forwardResult
dedent|''
name|'def'
name|'test_forwardResult'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{util.runAsEffectiveUser} forwards the result obtained by calling the\n        given function\n        """'
newline|'\n'
name|'result'
op|'='
name|'util'
op|'.'
name|'runAsEffectiveUser'
op|'('
number|'0'
op|','
number|'0'
op|','
name|'lambda'
op|':'
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'result'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_takeParameters
dedent|''
name|'def'
name|'test_takeParameters'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{util.runAsEffectiveUser} pass the given parameters to the given\n        function.\n        """'
newline|'\n'
name|'result'
op|'='
name|'util'
op|'.'
name|'runAsEffectiveUser'
op|'('
number|'0'
op|','
number|'0'
op|','
name|'lambda'
name|'x'
op|':'
number|'2'
op|'*'
name|'x'
op|','
number|'3'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'result'
op|','
number|'6'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_takesKeyworkArguments
dedent|''
name|'def'
name|'test_takesKeyworkArguments'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{util.runAsEffectiveUser} pass the keyword parameters to the given\n        function.\n        """'
newline|'\n'
name|'result'
op|'='
name|'util'
op|'.'
name|'runAsEffectiveUser'
op|'('
number|'0'
op|','
number|'0'
op|','
name|'lambda'
name|'x'
op|','
name|'y'
op|'='
number|'1'
op|','
name|'z'
op|'='
number|'1'
op|':'
name|'x'
op|'*'
name|'y'
op|'*'
name|'z'
op|','
number|'2'
op|','
name|'z'
op|'='
number|'3'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'result'
op|','
number|'6'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_testUIDGIDSwitch
dedent|''
name|'def'
name|'_testUIDGIDSwitch'
op|'('
name|'self'
op|','
name|'startUID'
op|','
name|'startGID'
op|','
name|'wantUID'
op|','
name|'wantGID'
op|','
nl|'\n'
name|'expectedUIDSwitches'
op|','
name|'expectedGIDSwitches'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Helper method checking the calls to C{os.seteuid} and C{os.setegid}\n        made by L{util.runAsEffectiveUser}, when switching from startUID to\n        wantUID and from startGID to wantGID.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'mockos'
op|'.'
name|'euid'
op|'='
name|'startUID'
newline|'\n'
name|'self'
op|'.'
name|'mockos'
op|'.'
name|'egid'
op|'='
name|'startGID'
newline|'\n'
name|'util'
op|'.'
name|'runAsEffectiveUser'
op|'('
nl|'\n'
name|'wantUID'
op|','
name|'wantGID'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_securedFunction'
op|','
name|'startUID'
op|','
name|'startGID'
op|','
name|'wantUID'
op|','
name|'wantGID'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'mockos'
op|'.'
name|'seteuidCalls'
op|','
name|'expectedUIDSwitches'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'mockos'
op|'.'
name|'setegidCalls'
op|','
name|'expectedGIDSwitches'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'mockos'
op|'.'
name|'seteuidCalls'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'mockos'
op|'.'
name|'setegidCalls'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_root
dedent|''
name|'def'
name|'test_root'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check UID/GID switches when current effective UID is root.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_testUIDGIDSwitch'
op|'('
number|'0'
op|','
number|'0'
op|','
number|'0'
op|','
number|'0'
op|','
op|'['
op|']'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_testUIDGIDSwitch'
op|'('
number|'0'
op|','
number|'0'
op|','
number|'1'
op|','
number|'0'
op|','
op|'['
number|'1'
op|','
number|'0'
op|']'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_testUIDGIDSwitch'
op|'('
number|'0'
op|','
number|'0'
op|','
number|'0'
op|','
number|'1'
op|','
op|'['
op|']'
op|','
op|'['
number|'1'
op|','
number|'0'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_testUIDGIDSwitch'
op|'('
number|'0'
op|','
number|'0'
op|','
number|'1'
op|','
number|'1'
op|','
op|'['
number|'1'
op|','
number|'0'
op|']'
op|','
op|'['
number|'1'
op|','
number|'0'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_UID
dedent|''
name|'def'
name|'test_UID'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check UID/GID switches when current effective UID is non-root.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_testUIDGIDSwitch'
op|'('
number|'1'
op|','
number|'0'
op|','
number|'0'
op|','
number|'0'
op|','
op|'['
number|'0'
op|','
number|'1'
op|']'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_testUIDGIDSwitch'
op|'('
number|'1'
op|','
number|'0'
op|','
number|'1'
op|','
number|'0'
op|','
op|'['
op|']'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_testUIDGIDSwitch'
op|'('
number|'1'
op|','
number|'0'
op|','
number|'1'
op|','
number|'1'
op|','
op|'['
number|'0'
op|','
number|'1'
op|','
number|'0'
op|','
number|'1'
op|']'
op|','
op|'['
number|'1'
op|','
number|'0'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_testUIDGIDSwitch'
op|'('
number|'1'
op|','
number|'0'
op|','
number|'2'
op|','
number|'1'
op|','
op|'['
number|'0'
op|','
number|'2'
op|','
number|'0'
op|','
number|'1'
op|']'
op|','
op|'['
number|'1'
op|','
number|'0'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_GID
dedent|''
name|'def'
name|'test_GID'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check UID/GID switches when current effective GID is non-root.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_testUIDGIDSwitch'
op|'('
number|'0'
op|','
number|'1'
op|','
number|'0'
op|','
number|'0'
op|','
op|'['
op|']'
op|','
op|'['
number|'0'
op|','
number|'1'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_testUIDGIDSwitch'
op|'('
number|'0'
op|','
number|'1'
op|','
number|'0'
op|','
number|'1'
op|','
op|'['
op|']'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_testUIDGIDSwitch'
op|'('
number|'0'
op|','
number|'1'
op|','
number|'1'
op|','
number|'1'
op|','
op|'['
number|'1'
op|','
number|'0'
op|']'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_testUIDGIDSwitch'
op|'('
number|'0'
op|','
number|'1'
op|','
number|'1'
op|','
number|'2'
op|','
op|'['
number|'1'
op|','
number|'0'
op|']'
op|','
op|'['
number|'2'
op|','
number|'1'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_UIDGID
dedent|''
name|'def'
name|'test_UIDGID'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check UID/GID switches when current effective UID/GID is non-root.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_testUIDGIDSwitch'
op|'('
number|'1'
op|','
number|'1'
op|','
number|'0'
op|','
number|'0'
op|','
op|'['
number|'0'
op|','
number|'1'
op|']'
op|','
op|'['
number|'0'
op|','
number|'1'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_testUIDGIDSwitch'
op|'('
number|'1'
op|','
number|'1'
op|','
number|'0'
op|','
number|'1'
op|','
op|'['
number|'0'
op|','
number|'1'
op|']'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_testUIDGIDSwitch'
op|'('
number|'1'
op|','
number|'1'
op|','
number|'1'
op|','
number|'0'
op|','
op|'['
number|'0'
op|','
number|'1'
op|','
number|'0'
op|','
number|'1'
op|']'
op|','
op|'['
number|'0'
op|','
number|'1'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_testUIDGIDSwitch'
op|'('
number|'1'
op|','
number|'1'
op|','
number|'1'
op|','
number|'1'
op|','
op|'['
op|']'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_testUIDGIDSwitch'
op|'('
number|'1'
op|','
number|'1'
op|','
number|'2'
op|','
number|'1'
op|','
op|'['
number|'0'
op|','
number|'2'
op|','
number|'0'
op|','
number|'1'
op|']'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_testUIDGIDSwitch'
op|'('
number|'1'
op|','
number|'1'
op|','
number|'1'
op|','
number|'2'
op|','
op|'['
number|'0'
op|','
number|'1'
op|','
number|'0'
op|','
number|'1'
op|']'
op|','
op|'['
number|'2'
op|','
number|'1'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_testUIDGIDSwitch'
op|'('
number|'1'
op|','
number|'1'
op|','
number|'2'
op|','
number|'2'
op|','
op|'['
number|'0'
op|','
number|'2'
op|','
number|'0'
op|','
number|'1'
op|']'
op|','
op|'['
number|'2'
op|','
number|'1'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|UnsignedIDTests
dedent|''
dedent|''
name|'class'
name|'UnsignedIDTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{util.unsignedID} and L{util.setIDFunction}.\n    """'
newline|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Save the value of L{util._idFunction} and arrange for it to be restored\n        after the test runs.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'addCleanup'
op|'('
name|'setattr'
op|','
name|'util'
op|','
string|"'_idFunction'"
op|','
name|'util'
op|'.'
name|'_idFunction'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_setIDFunction
dedent|''
name|'def'
name|'test_setIDFunction'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{util.setIDFunction} returns the last value passed to it.\n        """'
newline|'\n'
name|'value'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
name|'previous'
op|'='
name|'util'
op|'.'
name|'setIDFunction'
op|'('
name|'value'
op|')'
newline|'\n'
name|'result'
op|'='
name|'util'
op|'.'
name|'setIDFunction'
op|'('
name|'previous'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'value'
op|','
name|'result'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_unsignedID
dedent|''
name|'def'
name|'test_unsignedID'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{util.unsignedID} uses the function passed to L{util.setIDFunction} to\n        determine the unique integer id of an object and then adjusts it to be\n        positive if necessary.\n        """'
newline|'\n'
name|'foo'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
name|'bar'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# A fake object identity mapping'
nl|'\n'
name|'objects'
op|'='
op|'{'
name|'foo'
op|':'
number|'17'
op|','
name|'bar'
op|':'
op|'-'
number|'73'
op|'}'
newline|'\n'
DECL|function|fakeId
name|'def'
name|'fakeId'
op|'('
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'objects'
op|'['
name|'obj'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'util'
op|'.'
name|'setIDFunction'
op|'('
name|'fakeId'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'util'
op|'.'
name|'unsignedID'
op|'('
name|'foo'
op|')'
op|','
number|'17'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'util'
op|'.'
name|'unsignedID'
op|'('
name|'bar'
op|')'
op|','
op|'('
name|'sys'
op|'.'
name|'maxint'
op|'+'
number|'1'
op|')'
op|'*'
number|'2'
op|'-'
number|'73'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_defaultIDFunction
dedent|''
name|'def'
name|'test_defaultIDFunction'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{util.unsignedID} uses the built in L{id} by default.\n        """'
newline|'\n'
name|'obj'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
name|'idValue'
op|'='
name|'id'
op|'('
name|'obj'
op|')'
newline|'\n'
name|'if'
name|'idValue'
op|'<'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'idValue'
op|'+='
op|'('
name|'sys'
op|'.'
name|'maxint'
op|'+'
number|'1'
op|')'
op|'*'
number|'2'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'util'
op|'.'
name|'unsignedID'
op|'('
name|'obj'
op|')'
op|','
name|'idValue'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|InitGroupsTests
dedent|''
dedent|''
name|'class'
name|'InitGroupsTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{util.initgroups}.\n    """'
newline|'\n'
nl|'\n'
name|'if'
name|'pwd'
name|'is'
name|'None'
op|':'
newline|'\n'
DECL|variable|skip
indent|'        '
name|'skip'
op|'='
string|'"pwd not available"'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|setUp
dedent|''
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'addCleanup'
op|'('
name|'setattr'
op|','
name|'util'
op|','
string|'"_c_initgroups"'
op|','
name|'util'
op|'.'
name|'_c_initgroups'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addCleanup'
op|'('
name|'setattr'
op|','
name|'util'
op|','
string|'"setgroups"'
op|','
name|'util'
op|'.'
name|'setgroups'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_initgroupsForceC
dedent|''
name|'def'
name|'test_initgroupsForceC'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If we fake the presence of the C extension, it\'s called instead of the\n        Python implementation.\n        """'
newline|'\n'
name|'calls'
op|'='
op|'['
op|']'
newline|'\n'
name|'util'
op|'.'
name|'_c_initgroups'
op|'='
name|'lambda'
name|'x'
op|','
name|'y'
op|':'
name|'calls'
op|'.'
name|'append'
op|'('
op|'('
name|'x'
op|','
name|'y'
op|')'
op|')'
newline|'\n'
name|'setgroupsCalls'
op|'='
op|'['
op|']'
newline|'\n'
name|'util'
op|'.'
name|'setgroups'
op|'='
name|'calls'
op|'.'
name|'append'
newline|'\n'
nl|'\n'
name|'util'
op|'.'
name|'initgroups'
op|'('
name|'os'
op|'.'
name|'getuid'
op|'('
op|')'
op|','
number|'4'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'calls'
op|','
op|'['
op|'('
name|'pwd'
op|'.'
name|'getpwuid'
op|'('
name|'os'
op|'.'
name|'getuid'
op|'('
op|')'
op|')'
op|'['
number|'0'
op|']'
op|','
number|'4'
op|')'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'setgroupsCalls'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_initgroupsForcePython
dedent|''
name|'def'
name|'test_initgroupsForcePython'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If we fake the absence of the C extension, the Python implementation is\n        called instead, calling C{os.setgroups}.\n        """'
newline|'\n'
name|'util'
op|'.'
name|'_c_initgroups'
op|'='
name|'None'
newline|'\n'
name|'calls'
op|'='
op|'['
op|']'
newline|'\n'
name|'util'
op|'.'
name|'setgroups'
op|'='
name|'calls'
op|'.'
name|'append'
newline|'\n'
name|'util'
op|'.'
name|'initgroups'
op|'('
name|'os'
op|'.'
name|'getuid'
op|'('
op|')'
op|','
name|'os'
op|'.'
name|'getgid'
op|'('
op|')'
op|')'
newline|'\n'
comment|"# Something should be in the calls, we don't really care what"
nl|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'calls'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_initgroupsInC
dedent|''
name|'def'
name|'test_initgroupsInC'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the C extension is present, it\'s called instead of the Python\n        version.  We check that by making sure C{os.setgroups} is not called.\n        """'
newline|'\n'
name|'calls'
op|'='
op|'['
op|']'
newline|'\n'
name|'util'
op|'.'
name|'setgroups'
op|'='
name|'calls'
op|'.'
name|'append'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'util'
op|'.'
name|'initgroups'
op|'('
name|'os'
op|'.'
name|'getuid'
op|'('
op|')'
op|','
name|'os'
op|'.'
name|'getgid'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'calls'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
name|'if'
name|'util'
op|'.'
name|'_c_initgroups'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'test_initgroupsInC'
op|'.'
name|'skip'
op|'='
string|'"C initgroups not available"'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
