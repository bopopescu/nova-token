begin_unit
comment|'# Copyright (c) 2001-2008 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTests for L{twisted.python.zipstream}\n"""'
newline|'\n'
name|'import'
name|'sys'
newline|'\n'
name|'import'
name|'random'
newline|'\n'
name|'import'
name|'zipfile'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'compat'
name|'import'
name|'set'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'zipstream'
op|','
name|'filepath'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'hashlib'
name|'import'
name|'md5'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
newline|'\n'
nl|'\n'
DECL|class|FileEntryMixin
name|'class'
name|'FileEntryMixin'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    File entry classes should behave as file-like objects\n    """'
newline|'\n'
DECL|member|getFileEntry
name|'def'
name|'getFileEntry'
op|'('
name|'self'
op|','
name|'contents'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return an appropriate zip file entry\n        """'
newline|'\n'
name|'filename'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'z'
op|'='
name|'zipfile'
op|'.'
name|'ZipFile'
op|'('
name|'filename'
op|','
string|"'w'"
op|','
name|'self'
op|'.'
name|'compression'
op|')'
newline|'\n'
name|'z'
op|'.'
name|'writestr'
op|'('
string|"'content'"
op|','
name|'contents'
op|')'
newline|'\n'
name|'z'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'z'
op|'='
name|'zipstream'
op|'.'
name|'ChunkingZipFile'
op|'('
name|'filename'
op|','
string|"'r'"
op|')'
newline|'\n'
name|'return'
name|'z'
op|'.'
name|'readfile'
op|'('
string|"'content'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_isatty
dedent|''
name|'def'
name|'test_isatty'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        zip files should not be ttys, so isatty() should be false\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'getFileEntry'
op|'('
string|"''"
op|')'
op|'.'
name|'isatty'
op|'('
op|')'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_closed
dedent|''
name|'def'
name|'test_closed'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The C{closed} attribute should reflect whether C{close()} has been\n        called.\n        """'
newline|'\n'
name|'fileEntry'
op|'='
name|'self'
op|'.'
name|'getFileEntry'
op|'('
string|"''"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'fileEntry'
op|'.'
name|'closed'
op|','
name|'False'
op|')'
newline|'\n'
name|'fileEntry'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'fileEntry'
op|'.'
name|'closed'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_readline
dedent|''
name|'def'
name|'test_readline'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{readline()} should mirror L{file.readline} and return up to a single\n        deliminter.\n        """'
newline|'\n'
name|'fileEntry'
op|'='
name|'self'
op|'.'
name|'getFileEntry'
op|'('
string|"'hoho\\nho'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'fileEntry'
op|'.'
name|'readline'
op|'('
op|')'
op|','
string|"'hoho\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'fileEntry'
op|'.'
name|'readline'
op|'('
op|')'
op|','
string|"'ho'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'fileEntry'
op|'.'
name|'readline'
op|'('
op|')'
op|','
string|"''"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_next
dedent|''
name|'def'
name|'test_next'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Zip file entries should implement the iterator protocol as files do.\n        """'
newline|'\n'
name|'fileEntry'
op|'='
name|'self'
op|'.'
name|'getFileEntry'
op|'('
string|"'ho\\nhoho'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'fileEntry'
op|'.'
name|'next'
op|'('
op|')'
op|','
string|"'ho\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'fileEntry'
op|'.'
name|'next'
op|'('
op|')'
op|','
string|"'hoho'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'StopIteration'
op|','
name|'fileEntry'
op|'.'
name|'next'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_readlines
dedent|''
name|'def'
name|'test_readlines'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{readlines()} should return a list of all the lines.\n        """'
newline|'\n'
name|'fileEntry'
op|'='
name|'self'
op|'.'
name|'getFileEntry'
op|'('
string|"'ho\\nho\\nho'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'fileEntry'
op|'.'
name|'readlines'
op|'('
op|')'
op|','
op|'['
string|"'ho\\n'"
op|','
string|"'ho\\n'"
op|','
string|"'ho'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_iteration
dedent|''
name|'def'
name|'test_iteration'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{__iter__()} and C{xreadlines()} should return C{self}.\n        """'
newline|'\n'
name|'fileEntry'
op|'='
name|'self'
op|'.'
name|'getFileEntry'
op|'('
string|"''"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'iter'
op|'('
name|'fileEntry'
op|')'
op|','
name|'fileEntry'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'fileEntry'
op|'.'
name|'xreadlines'
op|'('
op|')'
op|','
name|'fileEntry'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_readWhole
dedent|''
name|'def'
name|'test_readWhole'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{.read()} should read the entire file.\n        """'
newline|'\n'
name|'contents'
op|'='
string|'"Hello, world!"'
newline|'\n'
name|'entry'
op|'='
name|'self'
op|'.'
name|'getFileEntry'
op|'('
name|'contents'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'entry'
op|'.'
name|'read'
op|'('
op|')'
op|','
name|'contents'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_readPartial
dedent|''
name|'def'
name|'test_readPartial'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{.read(num)} should read num bytes from the file.\n        """'
newline|'\n'
name|'contents'
op|'='
string|'"0123456789"'
newline|'\n'
name|'entry'
op|'='
name|'self'
op|'.'
name|'getFileEntry'
op|'('
name|'contents'
op|')'
newline|'\n'
name|'one'
op|'='
name|'entry'
op|'.'
name|'read'
op|'('
number|'4'
op|')'
newline|'\n'
name|'two'
op|'='
name|'entry'
op|'.'
name|'read'
op|'('
number|'200'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'one'
op|','
string|'"0123"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'two'
op|','
string|'"456789"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_tell
dedent|''
name|'def'
name|'test_tell'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{.tell()} should return the number of bytes that have been read so\n        far.\n        """'
newline|'\n'
name|'contents'
op|'='
string|'"x"'
op|'*'
number|'100'
newline|'\n'
name|'entry'
op|'='
name|'self'
op|'.'
name|'getFileEntry'
op|'('
name|'contents'
op|')'
newline|'\n'
name|'entry'
op|'.'
name|'read'
op|'('
number|'2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'entry'
op|'.'
name|'tell'
op|'('
op|')'
op|','
number|'2'
op|')'
newline|'\n'
name|'entry'
op|'.'
name|'read'
op|'('
number|'4'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'entry'
op|'.'
name|'tell'
op|'('
op|')'
op|','
number|'6'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DeflatedZipFileEntryTest
dedent|''
dedent|''
name|'class'
name|'DeflatedZipFileEntryTest'
op|'('
name|'FileEntryMixin'
op|','
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    DeflatedZipFileEntry should be file-like\n    """'
newline|'\n'
DECL|variable|compression
name|'compression'
op|'='
name|'zipfile'
op|'.'
name|'ZIP_DEFLATED'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ZipFileEntryTest
dedent|''
name|'class'
name|'ZipFileEntryTest'
op|'('
name|'FileEntryMixin'
op|','
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'   '
string|'"""\n   ZipFileEntry should be file-like\n   """'
newline|'\n'
DECL|variable|compression
name|'compression'
op|'='
name|'zipfile'
op|'.'
name|'ZIP_STORED'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ZipstreamTest
dedent|''
name|'class'
name|'ZipstreamTest'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for twisted.python.zipstream\n    """'
newline|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Creates junk data that can be compressed and a test directory for any\n        files that will be created\n        """'
newline|'\n'
name|'self'
op|'.'
name|'testdir'
op|'='
name|'filepath'
op|'.'
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'testdir'
op|'.'
name|'makedirs'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'unzipdir'
op|'='
name|'self'
op|'.'
name|'testdir'
op|'.'
name|'child'
op|'('
string|"'unzipped'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'makedirs'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|makeZipFile
dedent|''
name|'def'
name|'makeZipFile'
op|'('
name|'self'
op|','
name|'contents'
op|','
name|'directory'
op|'='
string|"''"
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Makes a zip file archive containing len(contents) files.  Contents\n        should be a list of strings, each string being the content of one file.\n        """'
newline|'\n'
name|'zpfilename'
op|'='
name|'self'
op|'.'
name|'testdir'
op|'.'
name|'child'
op|'('
string|"'zipfile.zip'"
op|')'
op|'.'
name|'path'
newline|'\n'
name|'zpfile'
op|'='
name|'zipfile'
op|'.'
name|'ZipFile'
op|'('
name|'zpfilename'
op|','
string|"'w'"
op|')'
newline|'\n'
name|'for'
name|'i'
op|','
name|'content'
name|'in'
name|'enumerate'
op|'('
name|'contents'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'filename'
op|'='
name|'str'
op|'('
name|'i'
op|')'
newline|'\n'
name|'if'
name|'directory'
op|':'
newline|'\n'
indent|'                '
name|'filename'
op|'='
name|'directory'
op|'+'
string|'"/"'
op|'+'
name|'filename'
newline|'\n'
dedent|''
name|'zpfile'
op|'.'
name|'writestr'
op|'('
name|'filename'
op|','
name|'content'
op|')'
newline|'\n'
dedent|''
name|'zpfile'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'return'
name|'zpfilename'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_countEntries
dedent|''
name|'def'
name|'test_countEntries'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Make sure the deprecated L{countZipFileEntries} returns the correct\n        number of entries for a zip file.\n        """'
newline|'\n'
name|'name'
op|'='
name|'self'
op|'.'
name|'makeZipFile'
op|'('
op|'['
string|'"one"'
op|','
string|'"two"'
op|','
string|'"three"'
op|','
string|'"four"'
op|','
string|'"five"'
op|']'
op|')'
newline|'\n'
name|'result'
op|'='
name|'self'
op|'.'
name|'assertWarns'
op|'('
name|'DeprecationWarning'
op|','
nl|'\n'
string|'"countZipFileEntries is deprecated."'
op|','
nl|'\n'
name|'__file__'
op|','
name|'lambda'
op|':'
nl|'\n'
name|'zipstream'
op|'.'
name|'countZipFileEntries'
op|'('
name|'name'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'result'
op|','
number|'5'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_invalidMode
dedent|''
name|'def'
name|'test_invalidMode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A ChunkingZipFile opened in write-mode should not allow .readfile(),\n        and raise a RuntimeError instead.\n        """'
newline|'\n'
name|'czf'
op|'='
name|'zipstream'
op|'.'
name|'ChunkingZipFile'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|','
string|'"w"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'RuntimeError'
op|','
name|'czf'
op|'.'
name|'readfile'
op|','
string|'"something"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_closedArchive
dedent|''
name|'def'
name|'test_closedArchive'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A closed ChunkingZipFile should raise a L{RuntimeError} when\n        .readfile() is invoked.\n        """'
newline|'\n'
name|'czf'
op|'='
name|'zipstream'
op|'.'
name|'ChunkingZipFile'
op|'('
name|'self'
op|'.'
name|'makeZipFile'
op|'('
op|'['
string|'"something"'
op|']'
op|')'
op|','
string|'"r"'
op|')'
newline|'\n'
name|'czf'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'RuntimeError'
op|','
name|'czf'
op|'.'
name|'readfile'
op|','
string|'"something"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_invalidHeader
dedent|''
name|'def'
name|'test_invalidHeader'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A zipfile entry with the wrong magic number should raise BadZipfile for\n        readfile(), but that should not affect other files in the archive.\n        """'
newline|'\n'
name|'fn'
op|'='
name|'self'
op|'.'
name|'makeZipFile'
op|'('
op|'['
string|'"test contents"'
op|','
nl|'\n'
string|'"more contents"'
op|']'
op|')'
newline|'\n'
name|'zf'
op|'='
name|'zipfile'
op|'.'
name|'ZipFile'
op|'('
name|'fn'
op|','
string|'"r"'
op|')'
newline|'\n'
name|'zeroOffset'
op|'='
name|'zf'
op|'.'
name|'getinfo'
op|'('
string|'"0"'
op|')'
op|'.'
name|'header_offset'
newline|'\n'
name|'zf'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
comment|'# Zero out just the one header.'
nl|'\n'
name|'scribble'
op|'='
name|'file'
op|'('
name|'fn'
op|','
string|'"r+b"'
op|')'
newline|'\n'
name|'scribble'
op|'.'
name|'seek'
op|'('
name|'zeroOffset'
op|','
number|'0'
op|')'
newline|'\n'
name|'scribble'
op|'.'
name|'write'
op|'('
name|'chr'
op|'('
number|'0'
op|')'
op|'*'
number|'4'
op|')'
newline|'\n'
name|'scribble'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'czf'
op|'='
name|'zipstream'
op|'.'
name|'ChunkingZipFile'
op|'('
name|'fn'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'zipfile'
op|'.'
name|'BadZipfile'
op|','
name|'czf'
op|'.'
name|'readfile'
op|','
string|'"0"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'czf'
op|'.'
name|'readfile'
op|'('
string|'"1"'
op|')'
op|'.'
name|'read'
op|'('
op|')'
op|','
string|'"more contents"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_filenameMismatch
dedent|''
name|'def'
name|'test_filenameMismatch'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A zipfile entry with a different filename than is found in the central\n        directory should raise BadZipfile.\n        """'
newline|'\n'
name|'fn'
op|'='
name|'self'
op|'.'
name|'makeZipFile'
op|'('
op|'['
string|'"test contents"'
op|','
nl|'\n'
string|'"more contents"'
op|']'
op|')'
newline|'\n'
name|'zf'
op|'='
name|'zipfile'
op|'.'
name|'ZipFile'
op|'('
name|'fn'
op|','
string|'"r"'
op|')'
newline|'\n'
name|'info'
op|'='
name|'zf'
op|'.'
name|'getinfo'
op|'('
string|'"0"'
op|')'
newline|'\n'
name|'info'
op|'.'
name|'filename'
op|'='
string|'"not zero"'
newline|'\n'
name|'zf'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'scribble'
op|'='
name|'file'
op|'('
name|'fn'
op|','
string|'"r+b"'
op|')'
newline|'\n'
name|'scribble'
op|'.'
name|'seek'
op|'('
name|'info'
op|'.'
name|'header_offset'
op|','
number|'0'
op|')'
newline|'\n'
name|'scribble'
op|'.'
name|'write'
op|'('
name|'info'
op|'.'
name|'FileHeader'
op|'('
op|')'
op|')'
newline|'\n'
name|'scribble'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'czf'
op|'='
name|'zipstream'
op|'.'
name|'ChunkingZipFile'
op|'('
name|'fn'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'zipfile'
op|'.'
name|'BadZipfile'
op|','
name|'czf'
op|'.'
name|'readfile'
op|','
string|'"0"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'czf'
op|'.'
name|'readfile'
op|'('
string|'"1"'
op|')'
op|'.'
name|'read'
op|'('
op|')'
op|','
string|'"more contents"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
name|'if'
name|'sys'
op|'.'
name|'version_info'
op|'<'
op|'('
number|'2'
op|','
number|'5'
op|')'
op|':'
newline|'\n'
comment|'# In python 2.4 and earlier, consistency between the directory and the'
nl|'\n'
comment|'# file header are verified at archive-opening time.  In python 2.5'
nl|'\n'
comment|"# (and, presumably, later) it is readzipfile's responsibility."
nl|'\n'
indent|'        '
name|'message'
op|'='
string|'"Consistency-checking only necessary in 2.5."'
newline|'\n'
name|'test_invalidHeader'
op|'.'
name|'skip'
op|'='
name|'message'
newline|'\n'
name|'test_filenameMismatch'
op|'.'
name|'skip'
op|'='
name|'message'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_unsupportedCompression
dedent|''
name|'def'
name|'test_unsupportedCompression'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A zipfile which describes an unsupported compression mechanism should\n        raise BadZipfile.\n        """'
newline|'\n'
name|'fn'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'zf'
op|'='
name|'zipfile'
op|'.'
name|'ZipFile'
op|'('
name|'fn'
op|','
string|'"w"'
op|')'
newline|'\n'
name|'zi'
op|'='
name|'zipfile'
op|'.'
name|'ZipInfo'
op|'('
string|'"0"'
op|')'
newline|'\n'
name|'zf'
op|'.'
name|'writestr'
op|'('
name|'zi'
op|','
string|'"some data"'
op|')'
newline|'\n'
comment|"# Mangle its compression type in the central directory; can't do this"
nl|'\n'
comment|'# before the writestr call or zipfile will (correctly) tell us not to'
nl|'\n'
comment|'# pass bad compression types :)'
nl|'\n'
name|'zi'
op|'.'
name|'compress_type'
op|'='
number|'1234'
newline|'\n'
name|'zf'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'czf'
op|'='
name|'zipstream'
op|'.'
name|'ChunkingZipFile'
op|'('
name|'fn'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'zipfile'
op|'.'
name|'BadZipfile'
op|','
name|'czf'
op|'.'
name|'readfile'
op|','
string|'"0"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_extraData
dedent|''
name|'def'
name|'test_extraData'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        readfile() should skip over \'extra\' data present in the zip metadata.\n        """'
newline|'\n'
name|'fn'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'zf'
op|'='
name|'zipfile'
op|'.'
name|'ZipFile'
op|'('
name|'fn'
op|','
string|"'w'"
op|')'
newline|'\n'
name|'zi'
op|'='
name|'zipfile'
op|'.'
name|'ZipInfo'
op|'('
string|'"0"'
op|')'
newline|'\n'
name|'zi'
op|'.'
name|'extra'
op|'='
string|'"hello, extra"'
newline|'\n'
name|'zf'
op|'.'
name|'writestr'
op|'('
name|'zi'
op|','
string|'"the real data"'
op|')'
newline|'\n'
name|'zf'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'czf'
op|'='
name|'zipstream'
op|'.'
name|'ChunkingZipFile'
op|'('
name|'fn'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'czf'
op|'.'
name|'readfile'
op|'('
string|'"0"'
op|')'
op|'.'
name|'read'
op|'('
op|')'
op|','
string|'"the real data"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_unzipIter
dedent|''
name|'def'
name|'test_unzipIter'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{twisted.python.zipstream.unzipIter} should unzip a file for each\n        iteration and yield the number of files left to unzip after that\n        iteration\n        """'
newline|'\n'
name|'numfiles'
op|'='
number|'10'
newline|'\n'
name|'contents'
op|'='
op|'['
string|"'This is test file %d!'"
op|'%'
name|'i'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'numfiles'
op|')'
op|']'
newline|'\n'
name|'zpfilename'
op|'='
name|'self'
op|'.'
name|'makeZipFile'
op|'('
name|'contents'
op|')'
newline|'\n'
name|'uziter'
op|'='
name|'zipstream'
op|'.'
name|'unzipIter'
op|'('
name|'zpfilename'
op|','
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'numfiles'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'list'
op|'('
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'children'
op|'('
op|')'
op|')'
op|')'
op|','
name|'i'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'uziter'
op|'.'
name|'next'
op|'('
op|')'
op|','
name|'numfiles'
op|'-'
name|'i'
op|'-'
number|'1'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'list'
op|'('
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'children'
op|'('
op|')'
op|')'
op|')'
op|','
name|'numfiles'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'child'
name|'in'
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'children'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'num'
op|'='
name|'int'
op|'('
name|'child'
op|'.'
name|'basename'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'child'
op|'.'
name|'open'
op|'('
op|')'
op|'.'
name|'read'
op|'('
op|')'
op|','
name|'contents'
op|'['
name|'num'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_unzipIterChunky
dedent|''
dedent|''
name|'def'
name|'test_unzipIterChunky'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{twisted.python.zipstream.unzipIterChunky} returns an iterator which\n        must be exhausted to completely unzip the input archive.\n        """'
newline|'\n'
name|'numfiles'
op|'='
number|'10'
newline|'\n'
name|'contents'
op|'='
op|'['
string|"'This is test file %d!'"
op|'%'
name|'i'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'numfiles'
op|')'
op|']'
newline|'\n'
name|'zpfilename'
op|'='
name|'self'
op|'.'
name|'makeZipFile'
op|'('
name|'contents'
op|')'
newline|'\n'
name|'list'
op|'('
name|'zipstream'
op|'.'
name|'unzipIterChunky'
op|'('
name|'zpfilename'
op|','
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'path'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'set'
op|'('
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'listdir'
op|'('
op|')'
op|')'
op|','
nl|'\n'
name|'set'
op|'('
name|'map'
op|'('
name|'str'
op|','
name|'range'
op|'('
name|'numfiles'
op|')'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'child'
name|'in'
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'children'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'num'
op|'='
name|'int'
op|'('
name|'child'
op|'.'
name|'basename'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'child'
op|'.'
name|'getContent'
op|'('
op|')'
op|','
name|'contents'
op|'['
name|'num'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_unzipIterChunkyDirectory
dedent|''
dedent|''
name|'def'
name|'test_unzipIterChunkyDirectory'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The path to which a file is extracted by L{zipstream.unzipIterChunky}\n        is determined by joining the C{directory} argument to C{unzip} with the\n        path within the archive of the file being extracted.\n        """'
newline|'\n'
name|'numfiles'
op|'='
number|'10'
newline|'\n'
name|'contents'
op|'='
op|'['
string|"'This is test file %d!'"
op|'%'
name|'i'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'numfiles'
op|')'
op|']'
newline|'\n'
name|'zpfilename'
op|'='
name|'self'
op|'.'
name|'makeZipFile'
op|'('
name|'contents'
op|','
string|"'foo'"
op|')'
newline|'\n'
name|'list'
op|'('
name|'zipstream'
op|'.'
name|'unzipIterChunky'
op|'('
name|'zpfilename'
op|','
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'path'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'set'
op|'('
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'child'
op|'('
string|"'foo'"
op|')'
op|'.'
name|'listdir'
op|'('
op|')'
op|')'
op|','
nl|'\n'
name|'set'
op|'('
name|'map'
op|'('
name|'str'
op|','
name|'range'
op|'('
name|'numfiles'
op|')'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'child'
name|'in'
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'child'
op|'('
string|"'foo'"
op|')'
op|'.'
name|'children'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'num'
op|'='
name|'int'
op|'('
name|'child'
op|'.'
name|'basename'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'child'
op|'.'
name|'getContent'
op|'('
op|')'
op|','
name|'contents'
op|'['
name|'num'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_unzip
dedent|''
dedent|''
name|'def'
name|'test_unzip'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{twisted.python.zipstream.unzip} should extract all files from a zip\n        archive\n        """'
newline|'\n'
name|'numfiles'
op|'='
number|'3'
newline|'\n'
name|'zpfilename'
op|'='
name|'self'
op|'.'
name|'makeZipFile'
op|'('
op|'['
name|'str'
op|'('
name|'i'
op|')'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'numfiles'
op|')'
op|']'
op|')'
newline|'\n'
name|'zipstream'
op|'.'
name|'unzip'
op|'('
name|'zpfilename'
op|','
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'set'
op|'('
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'listdir'
op|'('
op|')'
op|')'
op|','
nl|'\n'
name|'set'
op|'('
name|'map'
op|'('
name|'str'
op|','
name|'range'
op|'('
name|'numfiles'
op|')'
op|')'
op|')'
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'numfiles'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'child'
op|'('
name|'str'
op|'('
name|'i'
op|')'
op|')'
op|'.'
name|'getContent'
op|'('
op|')'
op|','
name|'str'
op|'('
name|'i'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_unzipDirectory
dedent|''
dedent|''
name|'def'
name|'test_unzipDirectory'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The path to which a file is extracted by L{zipstream.unzip} is\n        determined by joining the C{directory} argument to C{unzip} with the\n        path within the archive of the file being extracted.\n        """'
newline|'\n'
name|'numfiles'
op|'='
number|'3'
newline|'\n'
name|'zpfilename'
op|'='
name|'self'
op|'.'
name|'makeZipFile'
op|'('
op|'['
name|'str'
op|'('
name|'i'
op|')'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'numfiles'
op|')'
op|']'
op|','
string|"'foo'"
op|')'
newline|'\n'
name|'zipstream'
op|'.'
name|'unzip'
op|'('
name|'zpfilename'
op|','
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'set'
op|'('
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'child'
op|'('
string|"'foo'"
op|')'
op|'.'
name|'listdir'
op|'('
op|')'
op|')'
op|','
nl|'\n'
name|'set'
op|'('
name|'map'
op|'('
name|'str'
op|','
name|'range'
op|'('
name|'numfiles'
op|')'
op|')'
op|')'
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'numfiles'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'child'
op|'('
string|"'foo'"
op|')'
op|'.'
name|'child'
op|'('
name|'str'
op|'('
name|'i'
op|')'
op|')'
op|'.'
name|'getContent'
op|'('
op|')'
op|','
name|'str'
op|'('
name|'i'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_overwrite
dedent|''
dedent|''
name|'def'
name|'test_overwrite'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{twisted.python.zipstream.unzip} and\n        L{twisted.python.zipstream.unzipIter} shouldn\'t overwrite files unless\n        the \'overwrite\' flag is passed\n        """'
newline|'\n'
name|'testfile'
op|'='
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'child'
op|'('
string|"'0'"
op|')'
newline|'\n'
name|'zpfilename'
op|'='
name|'self'
op|'.'
name|'makeZipFile'
op|'('
op|'['
string|"'OVERWRITTEN'"
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'testfile'
op|'.'
name|'setContent'
op|'('
string|"'NOT OVERWRITTEN'"
op|')'
newline|'\n'
name|'zipstream'
op|'.'
name|'unzip'
op|'('
name|'zpfilename'
op|','
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'testfile'
op|'.'
name|'open'
op|'('
op|')'
op|'.'
name|'read'
op|'('
op|')'
op|','
string|"'NOT OVERWRITTEN'"
op|')'
newline|'\n'
name|'zipstream'
op|'.'
name|'unzip'
op|'('
name|'zpfilename'
op|','
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'path'
op|','
name|'overwrite'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'testfile'
op|'.'
name|'open'
op|'('
op|')'
op|'.'
name|'read'
op|'('
op|')'
op|','
string|"'OVERWRITTEN'"
op|')'
newline|'\n'
nl|'\n'
name|'testfile'
op|'.'
name|'setContent'
op|'('
string|"'NOT OVERWRITTEN'"
op|')'
newline|'\n'
name|'uziter'
op|'='
name|'zipstream'
op|'.'
name|'unzipIter'
op|'('
name|'zpfilename'
op|','
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'uziter'
op|'.'
name|'next'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'testfile'
op|'.'
name|'open'
op|'('
op|')'
op|'.'
name|'read'
op|'('
op|')'
op|','
string|"'NOT OVERWRITTEN'"
op|')'
newline|'\n'
name|'uziter'
op|'='
name|'zipstream'
op|'.'
name|'unzipIter'
op|'('
name|'zpfilename'
op|','
name|'self'
op|'.'
name|'unzipdir'
op|'.'
name|'path'
op|','
nl|'\n'
name|'overwrite'
op|'='
name|'True'
op|')'
newline|'\n'
name|'uziter'
op|'.'
name|'next'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'testfile'
op|'.'
name|'open'
op|'('
op|')'
op|'.'
name|'read'
op|'('
op|')'
op|','
string|"'OVERWRITTEN'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# XXX these tests are kind of gross and old, but I think unzipIterChunky is'
nl|'\n'
comment|'# kind of a gross function anyway.  We should really write an abstract'
nl|'\n'
comment|'# copyTo/moveTo that operates on FilePath and make sure ZipPath can support'
nl|'\n'
comment|'# it, then just deprecate / remove this stuff.'
nl|'\n'
DECL|member|_unzipIterChunkyTest
dedent|''
name|'def'
name|'_unzipIterChunkyTest'
op|'('
name|'self'
op|','
name|'compression'
op|','
name|'chunksize'
op|','
name|'lower'
op|','
name|'upper'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        unzipIterChunky should unzip the given number of bytes per iteration.\n        """'
newline|'\n'
name|'junk'
op|'='
string|"' '"
op|'.'
name|'join'
op|'('
op|'['
name|'str'
op|'('
name|'random'
op|'.'
name|'random'
op|'('
op|')'
op|')'
name|'for'
name|'n'
name|'in'
name|'xrange'
op|'('
number|'1000'
op|')'
op|']'
op|')'
newline|'\n'
name|'junkmd5'
op|'='
name|'md5'
op|'('
name|'junk'
op|')'
op|'.'
name|'hexdigest'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'tempdir'
op|'='
name|'filepath'
op|'.'
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'tempdir'
op|'.'
name|'makedirs'
op|'('
op|')'
newline|'\n'
name|'zfpath'
op|'='
name|'tempdir'
op|'.'
name|'child'
op|'('
string|"'bigfile.zip'"
op|')'
op|'.'
name|'path'
newline|'\n'
name|'self'
op|'.'
name|'_makebigfile'
op|'('
name|'zfpath'
op|','
name|'compression'
op|','
name|'junk'
op|')'
newline|'\n'
name|'uziter'
op|'='
name|'zipstream'
op|'.'
name|'unzipIterChunky'
op|'('
name|'zfpath'
op|','
name|'tempdir'
op|'.'
name|'path'
op|','
nl|'\n'
name|'chunksize'
op|'='
name|'chunksize'
op|')'
newline|'\n'
name|'r'
op|'='
name|'uziter'
op|'.'
name|'next'
op|'('
op|')'
newline|'\n'
comment|'# test that the number of chunks is in the right ballpark;'
nl|'\n'
comment|'# this could theoretically be any number but statistically it'
nl|'\n'
comment|'# should always be in this range'
nl|'\n'
name|'approx'
op|'='
name|'lower'
op|'<'
name|'r'
op|'<'
name|'upper'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'approx'
op|')'
newline|'\n'
name|'for'
name|'r'
name|'in'
name|'uziter'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'r'
op|','
number|'0'
op|')'
newline|'\n'
name|'newmd5'
op|'='
name|'md5'
op|'('
nl|'\n'
name|'tempdir'
op|'.'
name|'child'
op|'('
string|'"zipstreamjunk"'
op|')'
op|'.'
name|'open'
op|'('
op|')'
op|'.'
name|'read'
op|'('
op|')'
op|')'
op|'.'
name|'hexdigest'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'newmd5'
op|','
name|'junkmd5'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_unzipIterChunkyStored
dedent|''
name|'def'
name|'test_unzipIterChunkyStored'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        unzipIterChunky should unzip the given number of bytes per iteration on\n        a stored archive.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_unzipIterChunkyTest'
op|'('
name|'zipfile'
op|'.'
name|'ZIP_STORED'
op|','
number|'500'
op|','
number|'35'
op|','
number|'45'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_chunkyDeflated
dedent|''
name|'def'
name|'test_chunkyDeflated'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        unzipIterChunky should unzip the given number of bytes per iteration on\n        a deflated archive.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_unzipIterChunkyTest'
op|'('
name|'zipfile'
op|'.'
name|'ZIP_DEFLATED'
op|','
number|'972'
op|','
number|'23'
op|','
number|'27'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_makebigfile
dedent|''
name|'def'
name|'_makebigfile'
op|'('
name|'self'
op|','
name|'filename'
op|','
name|'compression'
op|','
name|'junk'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a zip file with the given file name and compression scheme.\n        """'
newline|'\n'
name|'zf'
op|'='
name|'zipfile'
op|'.'
name|'ZipFile'
op|'('
name|'filename'
op|','
string|"'w'"
op|','
name|'compression'
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
number|'10'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'fn'
op|'='
string|"'zipstream%d'"
op|'%'
name|'i'
newline|'\n'
name|'zf'
op|'.'
name|'writestr'
op|'('
name|'fn'
op|','
string|'""'
op|')'
newline|'\n'
dedent|''
name|'zf'
op|'.'
name|'writestr'
op|'('
string|"'zipstreamjunk'"
op|','
name|'junk'
op|')'
newline|'\n'
name|'zf'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
