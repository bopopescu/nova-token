begin_unit
comment|'# -*- test-case-name: twisted.test.test_text -*-'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Copyright (c) 2001-2004 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
nl|'\n'
string|'"""Miscellany of text-munging functions.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'string'
op|','
name|'types'
newline|'\n'
nl|'\n'
DECL|function|stringyString
name|'def'
name|'stringyString'
op|'('
name|'object'
op|','
name|'indentation'
op|'='
string|"''"
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Expansive string formatting for sequence types.\n\n    list.__str__ and dict.__str__ use repr() to display their\n    elements.  This function also turns these sequence types\n    into strings, but uses str() on their elements instead.\n\n    Sequence elements are also displayed on seperate lines,\n    and nested sequences have nested indentation.\n    """'
newline|'\n'
name|'braces'
op|'='
string|"''"
newline|'\n'
name|'sl'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'type'
op|'('
name|'object'
op|')'
name|'is'
name|'types'
op|'.'
name|'DictType'
op|':'
newline|'\n'
indent|'        '
name|'braces'
op|'='
string|"'{}'"
newline|'\n'
name|'for'
name|'key'
op|','
name|'value'
name|'in'
name|'object'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'value'
op|'='
name|'stringyString'
op|'('
name|'value'
op|','
name|'indentation'
op|'+'
string|"'   '"
op|')'
newline|'\n'
name|'if'
name|'isMultiline'
op|'('
name|'value'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'endsInNewline'
op|'('
name|'value'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'value'
op|'='
name|'value'
op|'['
op|':'
op|'-'
name|'len'
op|'('
string|"'\\n'"
op|')'
op|']'
newline|'\n'
dedent|''
name|'sl'
op|'.'
name|'append'
op|'('
string|'"%s %s:\\n%s"'
op|'%'
op|'('
name|'indentation'
op|','
name|'key'
op|','
name|'value'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Oops.  Will have to move that indentation.'
nl|'\n'
indent|'                '
name|'sl'
op|'.'
name|'append'
op|'('
string|'"%s %s: %s"'
op|'%'
op|'('
name|'indentation'
op|','
name|'key'
op|','
nl|'\n'
name|'value'
op|'['
name|'len'
op|'('
name|'indentation'
op|')'
op|'+'
number|'3'
op|':'
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'elif'
name|'type'
op|'('
name|'object'
op|')'
name|'in'
op|'('
name|'types'
op|'.'
name|'TupleType'
op|','
name|'types'
op|'.'
name|'ListType'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'type'
op|'('
name|'object'
op|')'
name|'is'
name|'types'
op|'.'
name|'TupleType'
op|':'
newline|'\n'
indent|'            '
name|'braces'
op|'='
string|"'()'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'braces'
op|'='
string|"'[]'"
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'element'
name|'in'
name|'object'
op|':'
newline|'\n'
indent|'            '
name|'element'
op|'='
name|'stringyString'
op|'('
name|'element'
op|','
name|'indentation'
op|'+'
string|"' '"
op|')'
newline|'\n'
name|'sl'
op|'.'
name|'append'
op|'('
name|'string'
op|'.'
name|'rstrip'
op|'('
name|'element'
op|')'
op|'+'
string|"','"
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'sl'
op|'['
op|':'
op|']'
op|'='
name|'map'
op|'('
name|'lambda'
name|'s'
op|','
name|'i'
op|'='
name|'indentation'
op|':'
name|'i'
op|'+'
name|'s'
op|','
nl|'\n'
name|'string'
op|'.'
name|'split'
op|'('
name|'str'
op|'('
name|'object'
op|')'
op|','
string|"'\\n'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'sl'
op|':'
newline|'\n'
indent|'        '
name|'sl'
op|'.'
name|'append'
op|'('
name|'indentation'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'braces'
op|':'
newline|'\n'
indent|'        '
name|'sl'
op|'['
number|'0'
op|']'
op|'='
name|'indentation'
op|'+'
name|'braces'
op|'['
number|'0'
op|']'
op|'+'
name|'sl'
op|'['
number|'0'
op|']'
op|'['
name|'len'
op|'('
name|'indentation'
op|')'
op|'+'
number|'1'
op|':'
op|']'
newline|'\n'
name|'sl'
op|'['
op|'-'
number|'1'
op|']'
op|'='
name|'sl'
op|'['
op|'-'
number|'1'
op|']'
op|'+'
name|'braces'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'s'
op|'='
name|'string'
op|'.'
name|'join'
op|'('
name|'sl'
op|','
string|'"\\n"'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'isMultiline'
op|'('
name|'s'
op|')'
name|'and'
name|'not'
name|'endsInNewline'
op|'('
name|'s'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
name|'s'
op|'+'
string|"'\\n'"
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'s'
newline|'\n'
nl|'\n'
DECL|function|isMultiline
dedent|''
name|'def'
name|'isMultiline'
op|'('
name|'s'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Returns True if this string has a newline in it."""'
newline|'\n'
name|'return'
op|'('
name|'string'
op|'.'
name|'find'
op|'('
name|'s'
op|','
string|"'\\n'"
op|')'
op|'!='
op|'-'
number|'1'
op|')'
newline|'\n'
nl|'\n'
DECL|function|endsInNewline
dedent|''
name|'def'
name|'endsInNewline'
op|'('
name|'s'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Returns True if this string ends in a newline."""'
newline|'\n'
name|'return'
op|'('
name|'s'
op|'['
op|'-'
name|'len'
op|'('
string|"'\\n'"
op|')'
op|':'
op|']'
op|'=='
string|"'\\n'"
op|')'
newline|'\n'
nl|'\n'
DECL|function|docstringLStrip
dedent|''
name|'def'
name|'docstringLStrip'
op|'('
name|'docstring'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Gets rid of unsightly lefthand docstring whitespace residue.\n\n    You\'d think someone would have done this already, but apparently\n    not in 1.5.2.\n\n    BUT since we\'re all using Python 2.1 now, use L{inspect.getdoc}\n    instead.  I{This function should go away soon.}\n    """'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'docstring'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'docstring'
newline|'\n'
nl|'\n'
dedent|''
name|'docstring'
op|'='
name|'string'
op|'.'
name|'replace'
op|'('
name|'docstring'
op|','
string|"'\\t'"
op|','
string|"' '"
op|'*'
number|'8'
op|')'
newline|'\n'
name|'lines'
op|'='
name|'string'
op|'.'
name|'split'
op|'('
name|'docstring'
op|','
string|"'\\n'"
op|')'
newline|'\n'
nl|'\n'
name|'leading'
op|'='
number|'0'
newline|'\n'
name|'for'
name|'l'
name|'in'
name|'xrange'
op|'('
number|'1'
op|','
name|'len'
op|'('
name|'lines'
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'line'
op|'='
name|'lines'
op|'['
name|'l'
op|']'
newline|'\n'
name|'if'
name|'string'
op|'.'
name|'strip'
op|'('
name|'line'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'while'
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'line'
op|'['
name|'leading'
op|']'
op|'=='
string|"' '"
op|':'
newline|'\n'
indent|'                    '
name|'leading'
op|'='
name|'leading'
op|'+'
number|'1'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'break'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'leading'
op|':'
newline|'\n'
indent|'            '
name|'break'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'outlines'
op|'='
name|'lines'
op|'['
number|'0'
op|':'
number|'1'
op|']'
newline|'\n'
name|'for'
name|'l'
name|'in'
name|'xrange'
op|'('
number|'1'
op|','
name|'len'
op|'('
name|'lines'
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'outlines'
op|'.'
name|'append'
op|'('
name|'lines'
op|'['
name|'l'
op|']'
op|'['
name|'leading'
op|':'
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'string'
op|'.'
name|'join'
op|'('
name|'outlines'
op|','
string|"'\\n'"
op|')'
newline|'\n'
nl|'\n'
DECL|function|greedyWrap
dedent|''
name|'def'
name|'greedyWrap'
op|'('
name|'inString'
op|','
name|'width'
op|'='
number|'80'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Given a string and a column width, return a list of lines.\n\n    Caveat: I\'m use a stupid greedy word-wrapping\n    algorythm.  I won\'t put two spaces at the end\n    of a sentence.  I don\'t do full justification.\n    And no, I\'ve never even *heard* of hypenation.\n    """'
newline|'\n'
nl|'\n'
name|'outLines'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
comment|'#eww, evil hacks to allow paragraphs delimited by two \\ns :('
nl|'\n'
name|'if'
name|'inString'
op|'.'
name|'find'
op|'('
string|"'\\n\\n'"
op|')'
op|'>='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'paragraphs'
op|'='
name|'string'
op|'.'
name|'split'
op|'('
name|'inString'
op|','
string|"'\\n\\n'"
op|')'
newline|'\n'
name|'for'
name|'para'
name|'in'
name|'paragraphs'
op|':'
newline|'\n'
indent|'            '
name|'outLines'
op|'.'
name|'extend'
op|'('
name|'greedyWrap'
op|'('
name|'para'
op|')'
op|'+'
op|'['
string|"''"
op|']'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'outLines'
newline|'\n'
dedent|''
name|'inWords'
op|'='
name|'string'
op|'.'
name|'split'
op|'('
name|'inString'
op|')'
newline|'\n'
nl|'\n'
name|'column'
op|'='
number|'0'
newline|'\n'
name|'ptr_line'
op|'='
number|'0'
newline|'\n'
name|'while'
name|'inWords'
op|':'
newline|'\n'
indent|'        '
name|'column'
op|'='
name|'column'
op|'+'
name|'len'
op|'('
name|'inWords'
op|'['
name|'ptr_line'
op|']'
op|')'
newline|'\n'
name|'ptr_line'
op|'='
name|'ptr_line'
op|'+'
number|'1'
newline|'\n'
nl|'\n'
name|'if'
op|'('
name|'column'
op|'>'
name|'width'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'ptr_line'
op|'=='
number|'1'
op|':'
newline|'\n'
comment|'# This single word is too long, it will be the whole line.'
nl|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|"# We've gone too far, stop the line one word back."
nl|'\n'
indent|'                '
name|'ptr_line'
op|'='
name|'ptr_line'
op|'-'
number|'1'
newline|'\n'
dedent|''
op|'('
name|'l'
op|','
name|'inWords'
op|')'
op|'='
op|'('
name|'inWords'
op|'['
number|'0'
op|':'
name|'ptr_line'
op|']'
op|','
name|'inWords'
op|'['
name|'ptr_line'
op|':'
op|']'
op|')'
newline|'\n'
name|'outLines'
op|'.'
name|'append'
op|'('
name|'string'
op|'.'
name|'join'
op|'('
name|'l'
op|','
string|"' '"
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'ptr_line'
op|'='
number|'0'
newline|'\n'
name|'column'
op|'='
number|'0'
newline|'\n'
dedent|''
name|'elif'
name|'not'
op|'('
name|'len'
op|'('
name|'inWords'
op|')'
op|'>'
name|'ptr_line'
op|')'
op|':'
newline|'\n'
comment|'# Clean up the last bit.'
nl|'\n'
indent|'            '
name|'outLines'
op|'.'
name|'append'
op|'('
name|'string'
op|'.'
name|'join'
op|'('
name|'inWords'
op|','
string|"' '"
op|')'
op|')'
newline|'\n'
name|'del'
name|'inWords'
op|'['
op|':'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Space'
nl|'\n'
indent|'            '
name|'column'
op|'='
name|'column'
op|'+'
number|'1'
newline|'\n'
comment|'# next word'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'outLines'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|wordWrap
dedent|''
name|'wordWrap'
op|'='
name|'greedyWrap'
newline|'\n'
nl|'\n'
DECL|function|removeLeadingBlanks
name|'def'
name|'removeLeadingBlanks'
op|'('
name|'lines'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'ret'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'line'
name|'in'
name|'lines'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'ret'
name|'or'
name|'line'
op|'.'
name|'strip'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'ret'
op|'.'
name|'append'
op|'('
name|'line'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'ret'
newline|'\n'
nl|'\n'
DECL|function|removeLeadingTrailingBlanks
dedent|''
name|'def'
name|'removeLeadingTrailingBlanks'
op|'('
name|'s'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'lines'
op|'='
name|'removeLeadingBlanks'
op|'('
name|'s'
op|'.'
name|'split'
op|'('
string|"'\\n'"
op|')'
op|')'
newline|'\n'
name|'lines'
op|'.'
name|'reverse'
op|'('
op|')'
newline|'\n'
name|'lines'
op|'='
name|'removeLeadingBlanks'
op|'('
name|'lines'
op|')'
newline|'\n'
name|'lines'
op|'.'
name|'reverse'
op|'('
op|')'
newline|'\n'
name|'return'
string|"'\\n'"
op|'.'
name|'join'
op|'('
name|'lines'
op|')'
op|'+'
string|"'\\n'"
newline|'\n'
nl|'\n'
DECL|function|splitQuoted
dedent|''
name|'def'
name|'splitQuoted'
op|'('
name|'s'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Like string.split, but don\'t break substrings inside quotes.\n\n    >>> splitQuoted(\'the \\"hairy monkey\\" likes pie\')\n    [\'the\', \'hairy monkey\', \'likes\', \'pie\']\n\n    Another one of those \\"someone must have a better solution for\n    this\\" things.  This implementation is a VERY DUMB hack done too\n    quickly.\n    """'
newline|'\n'
name|'out'
op|'='
op|'['
op|']'
newline|'\n'
name|'quot'
op|'='
name|'None'
newline|'\n'
name|'phrase'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'word'
name|'in'
name|'s'
op|'.'
name|'split'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'phrase'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'word'
name|'and'
op|'('
name|'word'
op|'['
number|'0'
op|']'
name|'in'
op|'('
string|'"\\""'
op|','
string|'"\'"'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'quot'
op|'='
name|'word'
op|'['
number|'0'
op|']'
newline|'\n'
name|'word'
op|'='
name|'word'
op|'['
number|'1'
op|':'
op|']'
newline|'\n'
name|'phrase'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'phrase'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'out'
op|'.'
name|'append'
op|'('
name|'word'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'word'
name|'and'
op|'('
name|'word'
op|'['
op|'-'
number|'1'
op|']'
op|'=='
name|'quot'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'word'
op|'='
name|'word'
op|'['
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
name|'phrase'
op|'.'
name|'append'
op|'('
name|'word'
op|')'
newline|'\n'
name|'out'
op|'.'
name|'append'
op|'('
string|'" "'
op|'.'
name|'join'
op|'('
name|'phrase'
op|')'
op|')'
newline|'\n'
name|'phrase'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'phrase'
op|'.'
name|'append'
op|'('
name|'word'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'out'
newline|'\n'
nl|'\n'
DECL|function|strFile
dedent|''
name|'def'
name|'strFile'
op|'('
name|'p'
op|','
name|'f'
op|','
name|'caseSensitive'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Find whether string p occurs in a read()able object f\n    @rtype: C{bool}\n    """'
newline|'\n'
name|'buf'
op|'='
string|'""'
newline|'\n'
name|'buf_len'
op|'='
name|'max'
op|'('
name|'len'
op|'('
name|'p'
op|')'
op|','
number|'2'
op|'**'
number|'2'
op|'**'
number|'2'
op|'**'
number|'2'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'caseSensitive'
op|':'
newline|'\n'
indent|'        '
name|'p'
op|'='
name|'p'
op|'.'
name|'lower'
op|'('
op|')'
newline|'\n'
dedent|''
name|'while'
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'r'
op|'='
name|'f'
op|'.'
name|'read'
op|'('
name|'buf_len'
op|'-'
name|'len'
op|'('
name|'p'
op|')'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'caseSensitive'
op|':'
newline|'\n'
indent|'            '
name|'r'
op|'='
name|'r'
op|'.'
name|'lower'
op|'('
op|')'
newline|'\n'
dedent|''
name|'bytes_read'
op|'='
name|'len'
op|'('
name|'r'
op|')'
newline|'\n'
name|'if'
name|'bytes_read'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'l'
op|'='
name|'len'
op|'('
name|'buf'
op|')'
op|'+'
name|'bytes_read'
op|'-'
name|'buf_len'
newline|'\n'
name|'if'
name|'l'
op|'<='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'buf'
op|'='
name|'buf'
op|'+'
name|'r'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'buf'
op|'='
name|'buf'
op|'['
name|'l'
op|':'
op|']'
op|'+'
name|'r'
newline|'\n'
dedent|''
name|'if'
name|'buf'
op|'.'
name|'find'
op|'('
name|'p'
op|')'
op|'!='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
