begin_unit
comment|'# -*- test-case-name: twisted.python.test.test_components -*-'
nl|'\n'
comment|'# Copyright (c) 2001-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
nl|'\n'
string|'"""\nComponent architecture for Twisted, based on Zope3 components.\n\nUsing the Zope3 API directly is strongly recommended. Everything\nyou need is in the top-level of the zope.interface package, e.g.::\n\n   from zope.interface import Interface, implements\n\n   class IFoo(Interface):\n       pass\n\n   class Foo:\n       implements(IFoo)\n\n   print IFoo.implementedBy(Foo) # True\n   print IFoo.providedBy(Foo()) # True\n\nL{twisted.python.components.registerAdapter} from this module may be used to\nadd to Twisted\'s global adapter registry. \n\nL{twisted.python.components.proxyForInterface} is a factory for classes\nwhich allow access to only the parts of another class defined by a specified\ninterface.\n"""'
newline|'\n'
nl|'\n'
comment|'# system imports'
nl|'\n'
name|'import'
name|'warnings'
newline|'\n'
nl|'\n'
comment|'# zope3 imports'
nl|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'interface'
op|','
name|'declarations'
newline|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
op|'.'
name|'adapter'
name|'import'
name|'AdapterRegistry'
newline|'\n'
nl|'\n'
comment|'# twisted imports'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'reflect'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'persisted'
name|'import'
name|'styles'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ComponentsDeprecationWarning
name|'class'
name|'ComponentsDeprecationWarning'
op|'('
name|'DeprecationWarning'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Nothing emits this warning anymore.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
comment|"# Twisted's global adapter registry"
nl|'\n'
DECL|variable|globalRegistry
dedent|''
name|'globalRegistry'
op|'='
name|'AdapterRegistry'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Attribute that registerAdapter looks at. Is this supposed to be public?'
nl|'\n'
DECL|variable|ALLOW_DUPLICATES
name|'ALLOW_DUPLICATES'
op|'='
number|'0'
newline|'\n'
nl|'\n'
comment|'# Define a function to find the registered adapter factory, using either a'
nl|'\n'
comment|"# version of Zope Interface which has the `registered' method or an older"
nl|'\n'
comment|'# version which does not.'
nl|'\n'
name|'if'
name|'getattr'
op|'('
name|'AdapterRegistry'
op|','
string|"'registered'"
op|','
name|'None'
op|')'
name|'is'
name|'None'
op|':'
newline|'\n'
DECL|member|_registered
indent|'    '
name|'def'
name|'_registered'
op|'('
name|'registry'
op|','
name|'required'
op|','
name|'provided'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the adapter factory for the given parameters in the given\n        registry, or None if there is not one.\n        """'
newline|'\n'
name|'return'
name|'registry'
op|'.'
name|'get'
op|'('
name|'required'
op|')'
op|'.'
name|'selfImplied'
op|'.'
name|'get'
op|'('
name|'provided'
op|','
op|'{'
op|'}'
op|')'
op|'.'
name|'get'
op|'('
string|"''"
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
DECL|function|_registered
indent|'    '
name|'def'
name|'_registered'
op|'('
name|'registry'
op|','
name|'required'
op|','
name|'provided'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the adapter factory for the given parameters in the given\n        registry, or None if there is not one.\n        """'
newline|'\n'
name|'return'
name|'registry'
op|'.'
name|'registered'
op|'('
op|'['
name|'required'
op|']'
op|','
name|'provided'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|registerAdapter
dedent|''
dedent|''
name|'def'
name|'registerAdapter'
op|'('
name|'adapterFactory'
op|','
name|'origInterface'
op|','
op|'*'
name|'interfaceClasses'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Register an adapter class.\n\n    An adapter class is expected to implement the given interface, by\n    adapting instances implementing \'origInterface\'. An adapter class\'s\n    __init__ method should accept one parameter, an instance implementing\n    \'origInterface\'.\n    """'
newline|'\n'
name|'self'
op|'='
name|'globalRegistry'
newline|'\n'
name|'assert'
name|'interfaceClasses'
op|','
string|'"You need to pass an Interface"'
newline|'\n'
name|'global'
name|'ALLOW_DUPLICATES'
newline|'\n'
nl|'\n'
comment|'# deal with class->interface adapters:'
nl|'\n'
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'origInterface'
op|','
name|'interface'
op|'.'
name|'InterfaceClass'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'origInterface'
op|'='
name|'declarations'
op|'.'
name|'implementedBy'
op|'('
name|'origInterface'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'interfaceClass'
name|'in'
name|'interfaceClasses'
op|':'
newline|'\n'
indent|'        '
name|'factory'
op|'='
name|'_registered'
op|'('
name|'self'
op|','
name|'origInterface'
op|','
name|'interfaceClass'
op|')'
newline|'\n'
name|'if'
name|'factory'
name|'is'
name|'not'
name|'None'
name|'and'
name|'not'
name|'ALLOW_DUPLICATES'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|'"an adapter (%s) was already registered."'
op|'%'
op|'('
name|'factory'
op|','
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'for'
name|'interfaceClass'
name|'in'
name|'interfaceClasses'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'register'
op|'('
op|'['
name|'origInterface'
op|']'
op|','
name|'interfaceClass'
op|','
string|"''"
op|','
name|'adapterFactory'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|getAdapterFactory
dedent|''
dedent|''
name|'def'
name|'getAdapterFactory'
op|'('
name|'fromInterface'
op|','
name|'toInterface'
op|','
name|'default'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return registered adapter for a given class and interface.\n\n    Note that is tied to the *Twisted* global registry, and will\n    thus not find adapters registered elsewhere.\n    """'
newline|'\n'
name|'self'
op|'='
name|'globalRegistry'
newline|'\n'
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'fromInterface'
op|','
name|'interface'
op|'.'
name|'InterfaceClass'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'fromInterface'
op|'='
name|'declarations'
op|'.'
name|'implementedBy'
op|'('
name|'fromInterface'
op|')'
newline|'\n'
dedent|''
name|'factory'
op|'='
name|'self'
op|'.'
name|'lookup1'
op|'('
name|'fromInterface'
op|','
name|'toInterface'
op|')'
newline|'\n'
name|'if'
name|'factory'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'factory'
op|'='
name|'default'
newline|'\n'
dedent|''
name|'return'
name|'factory'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# add global adapter lookup hook for our newly created registry'
nl|'\n'
DECL|function|_hook
dedent|''
name|'def'
name|'_hook'
op|'('
name|'iface'
op|','
name|'ob'
op|','
name|'lookup'
op|'='
name|'globalRegistry'
op|'.'
name|'lookup1'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'factory'
op|'='
name|'lookup'
op|'('
name|'declarations'
op|'.'
name|'providedBy'
op|'('
name|'ob'
op|')'
op|','
name|'iface'
op|')'
newline|'\n'
name|'if'
name|'factory'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'factory'
op|'('
name|'ob'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'interface'
op|'.'
name|'adapter_hooks'
op|'.'
name|'append'
op|'('
name|'_hook'
op|')'
newline|'\n'
nl|'\n'
comment|'## backwardsCompatImplements and fixClassImplements should probably stick around for another'
nl|'\n'
comment|'## release cycle. No harm doing so in any case.'
nl|'\n'
nl|'\n'
DECL|function|backwardsCompatImplements
name|'def'
name|'backwardsCompatImplements'
op|'('
name|'klass'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""DEPRECATED.\n\n    Does nothing. Previously handled backwards compat from a\n    zope.interface using class to a class wanting old twisted\n    components interface behaviors.\n    """'
newline|'\n'
name|'warnings'
op|'.'
name|'warn'
op|'('
string|'"components.backwardsCompatImplements doesn\'t do anything in Twisted 2.3, stop calling it."'
op|','
name|'ComponentsDeprecationWarning'
op|','
name|'stacklevel'
op|'='
number|'2'
op|')'
newline|'\n'
nl|'\n'
DECL|function|fixClassImplements
dedent|''
name|'def'
name|'fixClassImplements'
op|'('
name|'klass'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""DEPRECATED.\n\n    Does nothing. Previously converted class from __implements__ to\n    zope implementation.\n    """'
newline|'\n'
name|'warnings'
op|'.'
name|'warn'
op|'('
string|'"components.fixClassImplements doesn\'t do anything in Twisted 2.3, stop calling it."'
op|','
name|'ComponentsDeprecationWarning'
op|','
name|'stacklevel'
op|'='
number|'2'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|getRegistry
dedent|''
name|'def'
name|'getRegistry'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Returns the Twisted global\n    C{zope.interface.adapter.AdapterRegistry} instance.\n    """'
newline|'\n'
name|'return'
name|'globalRegistry'
newline|'\n'
nl|'\n'
comment|'# FIXME: deprecate attribute somehow?'
nl|'\n'
DECL|variable|CannotAdapt
dedent|''
name|'CannotAdapt'
op|'='
name|'TypeError'
newline|'\n'
nl|'\n'
DECL|class|Adapter
name|'class'
name|'Adapter'
op|':'
newline|'\n'
indent|'    '
string|'"""I am the default implementation of an Adapter for some interface.\n\n    This docstring contains a limerick, by popular demand::\n\n        Subclassing made Zope and TR\n        much harder to work with by far.\n            So before you inherit,\n            be sure to declare it\n        Adapter, not PyObject*\n\n    @cvar temporaryAdapter: If this is True, the adapter will not be\n          persisted on the Componentized.\n    @cvar multiComponent: If this adapter is persistent, should it be\n          automatically registered for all appropriate interfaces.\n    """'
newline|'\n'
nl|'\n'
comment|'# These attributes are used with Componentized.'
nl|'\n'
nl|'\n'
DECL|variable|temporaryAdapter
name|'temporaryAdapter'
op|'='
number|'0'
newline|'\n'
DECL|variable|multiComponent
name|'multiComponent'
op|'='
number|'1'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'original'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Set my \'original\' attribute to be the object I am adapting.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'original'
op|'='
name|'original'
newline|'\n'
nl|'\n'
DECL|member|__conform__
dedent|''
name|'def'
name|'__conform__'
op|'('
name|'self'
op|','
name|'interface'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        I forward __conform__ to self.original if it has it, otherwise I\n        simply return None.\n        """'
newline|'\n'
name|'if'
name|'hasattr'
op|'('
name|'self'
op|'.'
name|'original'
op|','
string|'"__conform__"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'original'
op|'.'
name|'__conform__'
op|'('
name|'interface'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'None'
newline|'\n'
nl|'\n'
DECL|member|isuper
dedent|''
name|'def'
name|'isuper'
op|'('
name|'self'
op|','
name|'iface'
op|','
name|'adapter'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Forward isuper to self.original\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'original'
op|'.'
name|'isuper'
op|'('
name|'iface'
op|','
name|'adapter'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Componentized
dedent|''
dedent|''
name|'class'
name|'Componentized'
op|'('
name|'styles'
op|'.'
name|'Versioned'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""I am a mixin to allow you to be adapted in various ways persistently.\n\n    I define a list of persistent adapters.  This is to allow adapter classes\n    to store system-specific state, and initialized on demand.  The\n    getComponent method implements this.  You must also register adapters for\n    this class for the interfaces that you wish to pass to getComponent.\n\n    Many other classes and utilities listed here are present in Zope3; this one\n    is specific to Twisted.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|persistenceVersion
name|'persistenceVersion'
op|'='
number|'1'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_adapterCache'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|locateAdapterClass
dedent|''
name|'def'
name|'locateAdapterClass'
op|'('
name|'self'
op|','
name|'klass'
op|','
name|'interfaceClass'
op|','
name|'default'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'getAdapterFactory'
op|'('
name|'klass'
op|','
name|'interfaceClass'
op|','
name|'default'
op|')'
newline|'\n'
nl|'\n'
DECL|member|setAdapter
dedent|''
name|'def'
name|'setAdapter'
op|'('
name|'self'
op|','
name|'interfaceClass'
op|','
name|'adapterClass'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'setComponent'
op|'('
name|'interfaceClass'
op|','
name|'adapterClass'
op|'('
name|'self'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|addAdapter
dedent|''
name|'def'
name|'addAdapter'
op|'('
name|'self'
op|','
name|'adapterClass'
op|','
name|'ignoreClass'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Utility method that calls addComponent.  I take an adapter class and\n        instantiate it with myself as the first argument.\n\n        @return: The adapter instantiated.\n        """'
newline|'\n'
name|'adapt'
op|'='
name|'adapterClass'
op|'('
name|'self'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addComponent'
op|'('
name|'adapt'
op|','
name|'ignoreClass'
op|')'
newline|'\n'
name|'return'
name|'adapt'
newline|'\n'
nl|'\n'
DECL|member|setComponent
dedent|''
name|'def'
name|'setComponent'
op|'('
name|'self'
op|','
name|'interfaceClass'
op|','
name|'component'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_adapterCache'
op|'['
name|'reflect'
op|'.'
name|'qual'
op|'('
name|'interfaceClass'
op|')'
op|']'
op|'='
name|'component'
newline|'\n'
nl|'\n'
DECL|member|addComponent
dedent|''
name|'def'
name|'addComponent'
op|'('
name|'self'
op|','
name|'component'
op|','
name|'ignoreClass'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Add a component to me, for all appropriate interfaces.\n\n        In order to determine which interfaces are appropriate, the component\'s\n        provided interfaces will be scanned.\n\n        If the argument \'ignoreClass\' is True, then all interfaces are\n        considered appropriate.\n\n        Otherwise, an \'appropriate\' interface is one for which its class has\n        been registered as an adapter for my class according to the rules of\n        getComponent.\n\n        @return: the list of appropriate interfaces\n        """'
newline|'\n'
name|'for'
name|'iface'
name|'in'
name|'declarations'
op|'.'
name|'providedBy'
op|'('
name|'component'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
name|'ignoreClass'
name|'or'
nl|'\n'
op|'('
name|'self'
op|'.'
name|'locateAdapterClass'
op|'('
name|'self'
op|'.'
name|'__class__'
op|','
name|'iface'
op|','
name|'None'
op|')'
nl|'\n'
op|'=='
name|'component'
op|'.'
name|'__class__'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_adapterCache'
op|'['
name|'reflect'
op|'.'
name|'qual'
op|'('
name|'iface'
op|')'
op|']'
op|'='
name|'component'
newline|'\n'
nl|'\n'
DECL|member|unsetComponent
dedent|''
dedent|''
dedent|''
name|'def'
name|'unsetComponent'
op|'('
name|'self'
op|','
name|'interfaceClass'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Remove my component specified by the given interface class."""'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'_adapterCache'
op|'['
name|'reflect'
op|'.'
name|'qual'
op|'('
name|'interfaceClass'
op|')'
op|']'
newline|'\n'
nl|'\n'
DECL|member|removeComponent
dedent|''
name|'def'
name|'removeComponent'
op|'('
name|'self'
op|','
name|'component'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Remove the given component from me entirely, for all interfaces for which\n        it has been registered.\n\n        @return: a list of the interfaces that were removed.\n        """'
newline|'\n'
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'k'
op|','
name|'v'
name|'in'
name|'self'
op|'.'
name|'_adapterCache'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'v'
name|'is'
name|'component'
op|':'
newline|'\n'
indent|'                '
name|'del'
name|'self'
op|'.'
name|'_adapterCache'
op|'['
name|'k'
op|']'
newline|'\n'
name|'l'
op|'.'
name|'append'
op|'('
name|'reflect'
op|'.'
name|'namedObject'
op|'('
name|'k'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'l'
newline|'\n'
nl|'\n'
DECL|member|getComponent
dedent|''
name|'def'
name|'getComponent'
op|'('
name|'self'
op|','
name|'interface'
op|','
name|'default'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create or retrieve an adapter for the given interface.\n\n        If such an adapter has already been created, retrieve it from the cache\n        that this instance keeps of all its adapters.  Adapters created through\n        this mechanism may safely store system-specific state.\n\n        If you want to register an adapter that will be created through\n        getComponent, but you don\'t require (or don\'t want) your adapter to be\n        cached and kept alive for the lifetime of this Componentized object,\n        set the attribute \'temporaryAdapter\' to True on your adapter class.\n\n        If you want to automatically register an adapter for all appropriate\n        interfaces (with addComponent), set the attribute \'multiComponent\' to\n        True on your adapter class.\n        """'
newline|'\n'
name|'k'
op|'='
name|'reflect'
op|'.'
name|'qual'
op|'('
name|'interface'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_adapterCache'
op|'.'
name|'has_key'
op|'('
name|'k'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'_adapterCache'
op|'['
name|'k'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'adapter'
op|'='
name|'interface'
op|'.'
name|'__adapt__'
op|'('
name|'self'
op|')'
newline|'\n'
name|'if'
name|'adapter'
name|'is'
name|'not'
name|'None'
name|'and'
name|'not'
op|'('
nl|'\n'
name|'hasattr'
op|'('
name|'adapter'
op|','
string|'"temporaryAdapter"'
op|')'
name|'and'
nl|'\n'
name|'adapter'
op|'.'
name|'temporaryAdapter'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_adapterCache'
op|'['
name|'k'
op|']'
op|'='
name|'adapter'
newline|'\n'
name|'if'
op|'('
name|'hasattr'
op|'('
name|'adapter'
op|','
string|'"multiComponent"'
op|')'
name|'and'
nl|'\n'
name|'adapter'
op|'.'
name|'multiComponent'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'addComponent'
op|'('
name|'adapter'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'adapter'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'default'
newline|'\n'
dedent|''
name|'return'
name|'adapter'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__conform__
dedent|''
dedent|''
name|'def'
name|'__conform__'
op|'('
name|'self'
op|','
name|'interface'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'getComponent'
op|'('
name|'interface'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ReprableComponentized
dedent|''
dedent|''
name|'class'
name|'ReprableComponentized'
op|'('
name|'Componentized'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'Componentized'
op|'.'
name|'__init__'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'from'
name|'cStringIO'
name|'import'
name|'StringIO'
newline|'\n'
name|'from'
name|'pprint'
name|'import'
name|'pprint'
newline|'\n'
name|'sio'
op|'='
name|'StringIO'
op|'('
op|')'
newline|'\n'
name|'pprint'
op|'('
name|'self'
op|'.'
name|'_adapterCache'
op|','
name|'sio'
op|')'
newline|'\n'
name|'return'
name|'sio'
op|'.'
name|'getvalue'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|proxyForInterface
dedent|''
dedent|''
name|'def'
name|'proxyForInterface'
op|'('
name|'iface'
op|','
name|'originalAttribute'
op|'='
string|"'original'"
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Create a class which proxies all method calls which adhere to an interface\n    to another provider of that interface.\n\n    This function is intended for creating specialized proxies. The typical way\n    to use it is by subclassing the result::\n\n      class MySpecializedProxy(proxyForInterface(IFoo)):\n          def someInterfaceMethod(self, arg):\n              if arg == 3:\n                  return 3\n              return self.original.someInterfaceMethod(arg)\n\n    @param iface: The Interface to which the resulting object will conform, and\n        which the wrapped object must provide.\n\n    @param originalAttribute: name of the attribute used to save the original\n        object in the resulting class. Default to C{original}.\n    @type originalAttribute: C{str}\n\n    @return: A class whose constructor takes the original object as its only\n        argument. Constructing the class creates the proxy.\n    """'
newline|'\n'
DECL|function|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'original'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'setattr'
op|'('
name|'self'
op|','
name|'originalAttribute'
op|','
name|'original'
op|')'
newline|'\n'
dedent|''
name|'contents'
op|'='
op|'{'
string|'"__init__"'
op|':'
name|'__init__'
op|'}'
newline|'\n'
name|'for'
name|'name'
name|'in'
name|'iface'
op|':'
newline|'\n'
indent|'        '
name|'contents'
op|'['
name|'name'
op|']'
op|'='
name|'_ProxyDescriptor'
op|'('
name|'name'
op|','
name|'originalAttribute'
op|')'
newline|'\n'
dedent|''
name|'proxy'
op|'='
name|'type'
op|'('
string|'"(Proxy for %s)"'
nl|'\n'
op|'%'
op|'('
name|'reflect'
op|'.'
name|'qual'
op|'('
name|'iface'
op|')'
op|','
op|')'
op|','
op|'('
name|'object'
op|','
op|')'
op|','
name|'contents'
op|')'
newline|'\n'
name|'declarations'
op|'.'
name|'classImplements'
op|'('
name|'proxy'
op|','
name|'iface'
op|')'
newline|'\n'
name|'return'
name|'proxy'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|_ProxiedClassMethod
dedent|''
name|'class'
name|'_ProxiedClassMethod'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A proxied class method.\n\n    @ivar methodName: the name of the method which this should invoke when\n        called.\n    @type methodName: C{str}\n\n    @ivar originalAttribute: name of the attribute of the proxy where the\n        original object is stored.\n    @type orginalAttribute: C{str}\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'methodName'
op|','
name|'originalAttribute'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'methodName'
op|'='
name|'methodName'
newline|'\n'
name|'self'
op|'.'
name|'originalAttribute'
op|'='
name|'originalAttribute'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__call__
dedent|''
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'oself'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Invoke the specified L{methodName} method of the C{original} attribute\n        for proxyForInterface.\n\n        @param oself: an instance of a L{proxyForInterface} object.\n\n        @return: the result of the underlying method.\n        """'
newline|'\n'
name|'original'
op|'='
name|'getattr'
op|'('
name|'oself'
op|','
name|'self'
op|'.'
name|'originalAttribute'
op|')'
newline|'\n'
name|'actualMethod'
op|'='
name|'getattr'
op|'('
name|'original'
op|','
name|'self'
op|'.'
name|'methodName'
op|')'
newline|'\n'
name|'return'
name|'actualMethod'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|_ProxyDescriptor
dedent|''
dedent|''
name|'class'
name|'_ProxyDescriptor'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A descriptor which will proxy attribute access, mutation, and\n    deletion to the L{original} attribute of the object it is being accessed\n    from.\n\n    @ivar attributeName: the name of the attribute which this descriptor will\n        retrieve from instances\' C{original} attribute.\n    @type attributeName: C{str}\n\n    @ivar originalAttribute: name of the attribute of the proxy where the\n        original object is stored.\n    @type orginalAttribute: C{str}\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'attributeName'
op|','
name|'originalAttribute'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'attributeName'
op|'='
name|'attributeName'
newline|'\n'
name|'self'
op|'.'
name|'originalAttribute'
op|'='
name|'originalAttribute'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__get__
dedent|''
name|'def'
name|'__get__'
op|'('
name|'self'
op|','
name|'oself'
op|','
name|'type'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Retrieve the C{self.attributeName} property from L{oself}.\n        """'
newline|'\n'
name|'if'
name|'oself'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'_ProxiedClassMethod'
op|'('
name|'self'
op|'.'
name|'attributeName'
op|','
nl|'\n'
name|'self'
op|'.'
name|'originalAttribute'
op|')'
newline|'\n'
dedent|''
name|'original'
op|'='
name|'getattr'
op|'('
name|'oself'
op|','
name|'self'
op|'.'
name|'originalAttribute'
op|')'
newline|'\n'
name|'return'
name|'getattr'
op|'('
name|'original'
op|','
name|'self'
op|'.'
name|'attributeName'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__set__
dedent|''
name|'def'
name|'__set__'
op|'('
name|'self'
op|','
name|'oself'
op|','
name|'value'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Set the C{self.attributeName} property of L{oself}.\n        """'
newline|'\n'
name|'original'
op|'='
name|'getattr'
op|'('
name|'oself'
op|','
name|'self'
op|'.'
name|'originalAttribute'
op|')'
newline|'\n'
name|'setattr'
op|'('
name|'original'
op|','
name|'self'
op|'.'
name|'attributeName'
op|','
name|'value'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__delete__
dedent|''
name|'def'
name|'__delete__'
op|'('
name|'self'
op|','
name|'oself'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Delete the C{self.attributeName} property of L{oself}.\n        """'
newline|'\n'
name|'original'
op|'='
name|'getattr'
op|'('
name|'oself'
op|','
name|'self'
op|'.'
name|'originalAttribute'
op|')'
newline|'\n'
name|'delattr'
op|'('
name|'original'
op|','
name|'self'
op|'.'
name|'attributeName'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|variable|__all__
dedent|''
dedent|''
name|'__all__'
op|'='
op|'['
nl|'\n'
comment|'# Sticking around:'
nl|'\n'
string|'"ComponentsDeprecationWarning"'
op|','
nl|'\n'
string|'"registerAdapter"'
op|','
string|'"getAdapterFactory"'
op|','
nl|'\n'
string|'"Adapter"'
op|','
string|'"Componentized"'
op|','
string|'"ReprableComponentized"'
op|','
string|'"getRegistry"'
op|','
nl|'\n'
string|'"proxyForInterface"'
op|','
nl|'\n'
nl|'\n'
comment|'# Deprecated:'
nl|'\n'
string|'"backwardsCompatImplements"'
op|','
nl|'\n'
string|'"fixClassImplements"'
op|','
nl|'\n'
op|']'
newline|'\n'
endmarker|''
end_unit
