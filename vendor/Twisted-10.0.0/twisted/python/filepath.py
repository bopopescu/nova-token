begin_unit
comment|'# -*- test-case-name: twisted.test.test_paths -*-'
nl|'\n'
comment|'# Copyright (c) 2001-2008 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nObject-oriented filesystem path representation.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'errno'
newline|'\n'
name|'import'
name|'random'
newline|'\n'
name|'import'
name|'base64'
newline|'\n'
nl|'\n'
name|'from'
name|'os'
op|'.'
name|'path'
name|'import'
name|'isabs'
op|','
name|'exists'
op|','
name|'normpath'
op|','
name|'abspath'
op|','
name|'splitext'
newline|'\n'
name|'from'
name|'os'
op|'.'
name|'path'
name|'import'
name|'basename'
op|','
name|'dirname'
newline|'\n'
name|'from'
name|'os'
op|'.'
name|'path'
name|'import'
name|'join'
name|'as'
name|'joinpath'
newline|'\n'
name|'from'
name|'os'
name|'import'
name|'sep'
name|'as'
name|'slash'
newline|'\n'
name|'from'
name|'os'
name|'import'
name|'listdir'
op|','
name|'utime'
op|','
name|'stat'
newline|'\n'
nl|'\n'
name|'from'
name|'stat'
name|'import'
name|'S_ISREG'
op|','
name|'S_ISDIR'
newline|'\n'
nl|'\n'
comment|'# Please keep this as light as possible on other Twisted imports; many, many'
nl|'\n'
comment|'# things import this module, and it would be good if it could easily be'
nl|'\n'
comment|'# modified for inclusion in the standard library.  --glyph'
nl|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'runtime'
name|'import'
name|'platform'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'hashlib'
name|'import'
name|'sha1'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'win32'
name|'import'
name|'ERROR_FILE_NOT_FOUND'
op|','
name|'ERROR_PATH_NOT_FOUND'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'win32'
name|'import'
name|'ERROR_INVALID_NAME'
op|','
name|'ERROR_DIRECTORY'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'win32'
name|'import'
name|'WindowsError'
newline|'\n'
nl|'\n'
DECL|function|_stub_islink
name|'def'
name|'_stub_islink'
op|'('
name|'path'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Always return \'false\' if the operating system does not support symlinks.\n\n    @param path: a path string.\n    @type path: L{str}\n    @return: false\n    """'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_stub_urandom
dedent|''
name|'def'
name|'_stub_urandom'
op|'('
name|'n'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Provide random data in versions of Python prior to 2.4.  This is an\n    effectively compatible replacement for \'os.urandom\'.\n\n    @type n: L{int}\n    @param n: the number of bytes of data to return\n    @return: C{n} bytes of random data.\n    @rtype: str\n    """'
newline|'\n'
name|'randomData'
op|'='
op|'['
name|'random'
op|'.'
name|'randrange'
op|'('
number|'256'
op|')'
name|'for'
name|'n'
name|'in'
name|'xrange'
op|'('
name|'n'
op|')'
op|']'
newline|'\n'
name|'return'
string|"''"
op|'.'
name|'join'
op|'('
name|'map'
op|'('
name|'chr'
op|','
name|'randomData'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_stub_armor
dedent|''
name|'def'
name|'_stub_armor'
op|'('
name|'s'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    ASCII-armor for random data.  This uses a hex encoding, although we will\n    prefer url-safe base64 encoding for features in this module if it is\n    available.\n    """'
newline|'\n'
name|'return'
name|'s'
op|'.'
name|'encode'
op|'('
string|"'hex'"
op|')'
newline|'\n'
nl|'\n'
DECL|variable|islink
dedent|''
name|'islink'
op|'='
name|'getattr'
op|'('
name|'os'
op|'.'
name|'path'
op|','
string|"'islink'"
op|','
name|'_stub_islink'
op|')'
newline|'\n'
DECL|variable|randomBytes
name|'randomBytes'
op|'='
name|'getattr'
op|'('
name|'os'
op|','
string|"'urandom'"
op|','
name|'_stub_urandom'
op|')'
newline|'\n'
DECL|variable|armor
name|'armor'
op|'='
name|'getattr'
op|'('
name|'base64'
op|','
string|"'urlsafe_b64encode'"
op|','
name|'_stub_armor'
op|')'
newline|'\n'
nl|'\n'
DECL|class|InsecurePath
name|'class'
name|'InsecurePath'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Error that is raised when the path provided to FilePath is invalid.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|LinkError
dedent|''
name|'class'
name|'LinkError'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    An error with symlinks - either that there are cyclical symlinks or that\n    symlink are not supported on this platform.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|UnlistableError
dedent|''
name|'class'
name|'UnlistableError'
op|'('
name|'OSError'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    An exception which is used to distinguish between errors which mean \'this\n    is not a directory you can list\' and other, more catastrophic errors.\n\n    This error will try to look as much like the original error as possible,\n    while still being catchable as an independent type.\n\n    @ivar originalException: the actual original exception instance, either an\n    L{OSError} or a L{WindowsError}.\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'originalException'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create an UnlistableError exception.\n\n        @param originalException: an instance of OSError.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'__dict__'
op|'.'
name|'update'
op|'('
name|'originalException'
op|'.'
name|'__dict__'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'originalException'
op|'='
name|'originalException'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|_WindowsUnlistableError
dedent|''
dedent|''
name|'class'
name|'_WindowsUnlistableError'
op|'('
name|'UnlistableError'
op|','
name|'WindowsError'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    This exception is raised on Windows, for compatibility with previous\n    releases of FilePath where unportable programs may have done "except\n    WindowsError:" around a call to children().\n\n    It is private because all application code may portably catch\n    L{UnlistableError} instead.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|_secureEnoughString
dedent|''
name|'def'
name|'_secureEnoughString'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Create a pseudorandom, 16-character string for use in secure filenames.\n    """'
newline|'\n'
name|'return'
name|'armor'
op|'('
name|'sha1'
op|'('
name|'randomBytes'
op|'('
number|'64'
op|')'
op|')'
op|'.'
name|'digest'
op|'('
op|')'
op|')'
op|'['
op|':'
number|'16'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|_PathHelper
dedent|''
name|'class'
name|'_PathHelper'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Abstract helper class also used by ZipPath; implements certain utility\n    methods.\n    """'
newline|'\n'
nl|'\n'
DECL|member|getContent
name|'def'
name|'getContent'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'open'
op|'('
op|')'
op|'.'
name|'read'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|parents
dedent|''
name|'def'
name|'parents'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @return: an iterator of all the ancestors of this path, from the most\n        recent (its immediate parent) to the root of its filesystem.\n        """'
newline|'\n'
name|'path'
op|'='
name|'self'
newline|'\n'
name|'parent'
op|'='
name|'path'
op|'.'
name|'parent'
op|'('
op|')'
newline|'\n'
comment|'# root.parent() == root, so this means "are we the root"'
nl|'\n'
name|'while'
name|'path'
op|'!='
name|'parent'
op|':'
newline|'\n'
indent|'            '
name|'yield'
name|'parent'
newline|'\n'
name|'path'
op|'='
name|'parent'
newline|'\n'
name|'parent'
op|'='
name|'parent'
op|'.'
name|'parent'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|children
dedent|''
dedent|''
name|'def'
name|'children'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        List the chilren of this path object.\n\n        @raise OSError: If an error occurs while listing the directory.  If the\n        error is \'serious\', meaning that the operation failed due to an access\n        violation, exhaustion of some kind of resource (file descriptors or\n        memory), OSError or a platform-specific variant will be raised.\n\n        @raise UnlistableError: If the inability to list the directory is due\n        to this path not existing or not being a directory, the more specific\n        OSError subclass L{UnlistableError} is raised instead.\n\n        @return: an iterable of all currently-existing children of this object\n        accessible with L{_PathHelper.child}.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'subnames'
op|'='
name|'self'
op|'.'
name|'listdir'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'WindowsError'
op|','
name|'winErrObj'
op|':'
newline|'\n'
comment|'# WindowsError is an OSError subclass, so if not for this clause'
nl|'\n'
comment|'# the OSError clause below would be handling these.  Windows error'
nl|'\n'
comment|"# codes aren't the same as POSIX error codes, so we need to handle"
nl|'\n'
comment|'# them differently.'
nl|'\n'
nl|'\n'
comment|'# Under Python 2.5 on Windows, WindowsError has a winerror'
nl|'\n'
comment|'# attribute and an errno attribute.  The winerror attribute is'
nl|'\n'
comment|'# bound to the Windows error code while the errno attribute is'
nl|'\n'
comment|'# bound to a translation of that code to a perhaps equivalent POSIX'
nl|'\n'
comment|'# error number.'
nl|'\n'
nl|'\n'
comment|'# Under Python 2.4 on Windows, WindowsError only has an errno'
nl|'\n'
comment|'# attribute.  It is bound to the Windows error code.'
nl|'\n'
nl|'\n'
comment|'# For simplicity of code and to keep the number of paths through'
nl|'\n'
comment|'# this suite minimal, we grab the Windows error code under either'
nl|'\n'
comment|'# version.'
nl|'\n'
nl|'\n'
comment|'# Furthermore, attempting to use os.listdir on a non-existent path'
nl|'\n'
comment|'# in Python 2.4 will result in a Windows error code of'
nl|'\n'
comment|'# ERROR_PATH_NOT_FOUND.  However, in Python 2.5,'
nl|'\n'
comment|'# ERROR_FILE_NOT_FOUND results instead. -exarkun'
nl|'\n'
indent|'            '
name|'winerror'
op|'='
name|'getattr'
op|'('
name|'winErrObj'
op|','
string|"'winerror'"
op|','
name|'winErrObj'
op|'.'
name|'errno'
op|')'
newline|'\n'
name|'if'
name|'winerror'
name|'not'
name|'in'
op|'('
name|'ERROR_PATH_NOT_FOUND'
op|','
nl|'\n'
name|'ERROR_FILE_NOT_FOUND'
op|','
nl|'\n'
name|'ERROR_INVALID_NAME'
op|','
nl|'\n'
name|'ERROR_DIRECTORY'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
dedent|''
name|'raise'
name|'_WindowsUnlistableError'
op|'('
name|'winErrObj'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|','
name|'ose'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'ose'
op|'.'
name|'errno'
name|'not'
name|'in'
op|'('
name|'errno'
op|'.'
name|'ENOENT'
op|','
name|'errno'
op|'.'
name|'ENOTDIR'
op|')'
op|':'
newline|'\n'
comment|'# Other possible errors here, according to linux manpages:'
nl|'\n'
comment|'# EACCES, EMIFLE, ENFILE, ENOMEM.  None of these seem like the'
nl|'\n'
comment|'# sort of thing which should be handled normally. -glyph'
nl|'\n'
indent|'                '
name|'raise'
newline|'\n'
dedent|''
name|'raise'
name|'UnlistableError'
op|'('
name|'ose'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'map'
op|'('
name|'self'
op|'.'
name|'child'
op|','
name|'subnames'
op|')'
newline|'\n'
nl|'\n'
DECL|member|walk
dedent|''
name|'def'
name|'walk'
op|'('
name|'self'
op|','
name|'descend'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Yield myself, then each of my children, and each of those children\'s\n        children in turn.  The optional argument C{descend} is a predicate that\n        takes a FilePath, and determines whether or not that FilePath is\n        traversed/descended into.  It will be called with each path for which\n        C{isdir} returns C{True}.  If C{descend} is not specified, all\n        directories will be traversed (including symbolic links which refer to\n        directories).\n\n        @param descend: A one-argument callable that will return True for\n            FilePaths that should be traversed, False otherwise.\n\n        @return: a generator yielding FilePath-like objects.\n        """'
newline|'\n'
name|'yield'
name|'self'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'isdir'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'c'
name|'in'
name|'self'
op|'.'
name|'children'
op|'('
op|')'
op|':'
newline|'\n'
comment|"# we should first see if it's what we want, then we"
nl|'\n'
comment|'# can walk through the directory'
nl|'\n'
indent|'                '
name|'if'
op|'('
name|'descend'
name|'is'
name|'None'
name|'or'
name|'descend'
op|'('
name|'c'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'for'
name|'subc'
name|'in'
name|'c'
op|'.'
name|'walk'
op|'('
name|'descend'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'realpath'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
op|'.'
name|'startswith'
op|'('
nl|'\n'
name|'os'
op|'.'
name|'path'
op|'.'
name|'realpath'
op|'('
name|'subc'
op|'.'
name|'path'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                            '
name|'raise'
name|'LinkError'
op|'('
string|'"Cycle in file graph."'
op|')'
newline|'\n'
dedent|''
name|'yield'
name|'subc'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'yield'
name|'c'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|sibling
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'sibling'
op|'('
name|'self'
op|','
name|'path'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'parent'
op|'('
op|')'
op|'.'
name|'child'
op|'('
name|'path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|segmentsFrom
dedent|''
name|'def'
name|'segmentsFrom'
op|'('
name|'self'
op|','
name|'ancestor'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a list of segments between a child and its ancestor.\n\n        For example, in the case of a path X representing /a/b/c/d and a path Y\n        representing /a/b, C{Y.segmentsFrom(X)} will return C{[\'c\',\n        \'d\']}.\n\n        @param ancestor: an instance of the same class as self, ostensibly an\n        ancestor of self.\n\n        @raise: ValueError if the \'ancestor\' parameter is not actually an\n        ancestor, i.e. a path for /x/y/z is passed as an ancestor for /a/b/c/d.\n\n        @return: a list of strs\n        """'
newline|'\n'
comment|'# this might be an unnecessarily inefficient implementation but it will'
nl|'\n'
comment|'# work on win32 and for zipfiles; later I will deterimine if the'
nl|'\n'
comment|'# obvious fast implemenation does the right thing too'
nl|'\n'
name|'f'
op|'='
name|'self'
newline|'\n'
name|'p'
op|'='
name|'f'
op|'.'
name|'parent'
op|'('
op|')'
newline|'\n'
name|'segments'
op|'='
op|'['
op|']'
newline|'\n'
name|'while'
name|'f'
op|'!='
name|'ancestor'
name|'and'
name|'p'
op|'!='
name|'f'
op|':'
newline|'\n'
indent|'            '
name|'segments'
op|'['
number|'0'
op|':'
number|'0'
op|']'
op|'='
op|'['
name|'f'
op|'.'
name|'basename'
op|'('
op|')'
op|']'
newline|'\n'
name|'f'
op|'='
name|'p'
newline|'\n'
name|'p'
op|'='
name|'p'
op|'.'
name|'parent'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'f'
op|'=='
name|'ancestor'
name|'and'
name|'segments'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'segments'
newline|'\n'
dedent|''
name|'raise'
name|'ValueError'
op|'('
string|'"%r not parent of %r"'
op|'%'
op|'('
name|'ancestor'
op|','
name|'self'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# new in 8.0'
nl|'\n'
DECL|member|__hash__
dedent|''
name|'def'
name|'__hash__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Hash the same as another FilePath with the same path as mine.\n        """'
newline|'\n'
name|'return'
name|'hash'
op|'('
op|'('
name|'self'
op|'.'
name|'__class__'
op|','
name|'self'
op|'.'
name|'path'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# pending deprecation in 8.0'
nl|'\n'
DECL|member|getmtime
dedent|''
name|'def'
name|'getmtime'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Deprecated.  Use getModificationTime instead.\n        """'
newline|'\n'
name|'return'
name|'int'
op|'('
name|'self'
op|'.'
name|'getModificationTime'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getatime
dedent|''
name|'def'
name|'getatime'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Deprecated.  Use getAccessTime instead.\n        """'
newline|'\n'
name|'return'
name|'int'
op|'('
name|'self'
op|'.'
name|'getAccessTime'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getctime
dedent|''
name|'def'
name|'getctime'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Deprecated.  Use getStatusChangeTime instead.\n        """'
newline|'\n'
name|'return'
name|'int'
op|'('
name|'self'
op|'.'
name|'getStatusChangeTime'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|FilePath
dedent|''
dedent|''
name|'class'
name|'FilePath'
op|'('
name|'_PathHelper'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    I am a path on the filesystem that only permits \'downwards\' access.\n\n    Instantiate me with a pathname (for example,\n    FilePath(\'/home/myuser/public_html\')) and I will attempt to only provide\n    access to files which reside inside that path.  I may be a path to a file,\n    a directory, or a file which does not exist.\n\n    The correct way to use me is to instantiate me, and then do ALL filesystem\n    access through me.  In other words, do not import the \'os\' module; if you\n    need to open a file, call my \'open\' method.  If you need to list a\n    directory, call my \'path\' method.\n\n    Even if you pass me a relative path, I will convert that to an absolute\n    path internally.\n\n    Note: although time-related methods do return floating-point results, they\n    may still be only second resolution depending on the platform and the last\n    value passed to L{os.stat_float_times}.  If you want greater-than-second\n    precision, call C{os.stat_float_times(True)}, or use Python 2.5.\n    Greater-than-second precision is only available in Windows on Python2.5 and\n    later.\n\n    @type alwaysCreate: C{bool}\n    @ivar alwaysCreate: When opening this file, only succeed if the file does not\n    already exist.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|statinfo
name|'statinfo'
op|'='
name|'None'
newline|'\n'
DECL|variable|path
name|'path'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'path'
op|','
name|'alwaysCreate'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'path'
op|'='
name|'abspath'
op|'('
name|'path'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'alwaysCreate'
op|'='
name|'alwaysCreate'
newline|'\n'
nl|'\n'
DECL|member|__getstate__
dedent|''
name|'def'
name|'__getstate__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'d'
op|'='
name|'self'
op|'.'
name|'__dict__'
op|'.'
name|'copy'
op|'('
op|')'
newline|'\n'
name|'if'
name|'d'
op|'.'
name|'has_key'
op|'('
string|"'statinfo'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'del'
name|'d'
op|'['
string|"'statinfo'"
op|']'
newline|'\n'
dedent|''
name|'return'
name|'d'
newline|'\n'
nl|'\n'
DECL|member|child
dedent|''
name|'def'
name|'child'
op|'('
name|'self'
op|','
name|'path'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'platform'
op|'.'
name|'isWindows'
op|'('
op|')'
name|'and'
name|'path'
op|'.'
name|'count'
op|'('
string|'":"'
op|')'
op|':'
newline|'\n'
comment|"# Catch paths like C:blah that don't have a slash"
nl|'\n'
indent|'            '
name|'raise'
name|'InsecurePath'
op|'('
string|'"%r contains a colon."'
op|'%'
op|'('
name|'path'
op|','
op|')'
op|')'
newline|'\n'
dedent|''
name|'norm'
op|'='
name|'normpath'
op|'('
name|'path'
op|')'
newline|'\n'
name|'if'
name|'slash'
name|'in'
name|'norm'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'InsecurePath'
op|'('
string|'"%r contains one or more directory separators"'
op|'%'
op|'('
name|'path'
op|','
op|')'
op|')'
newline|'\n'
dedent|''
name|'newpath'
op|'='
name|'abspath'
op|'('
name|'joinpath'
op|'('
name|'self'
op|'.'
name|'path'
op|','
name|'norm'
op|')'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'newpath'
op|'.'
name|'startswith'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'InsecurePath'
op|'('
string|'"%r is not a child of %s"'
op|'%'
op|'('
name|'newpath'
op|','
name|'self'
op|'.'
name|'path'
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'clonePath'
op|'('
name|'newpath'
op|')'
newline|'\n'
nl|'\n'
DECL|member|preauthChild
dedent|''
name|'def'
name|'preauthChild'
op|'('
name|'self'
op|','
name|'path'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Use me if `path\' might have slashes in it, but you know they\'re safe.\n\n        (NOT slashes at the beginning. It still needs to be a _child_).\n        """'
newline|'\n'
name|'newpath'
op|'='
name|'abspath'
op|'('
name|'joinpath'
op|'('
name|'self'
op|'.'
name|'path'
op|','
name|'normpath'
op|'('
name|'path'
op|')'
op|')'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'newpath'
op|'.'
name|'startswith'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'InsecurePath'
op|'('
string|'"%s is not a child of %s"'
op|'%'
op|'('
name|'newpath'
op|','
name|'self'
op|'.'
name|'path'
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'clonePath'
op|'('
name|'newpath'
op|')'
newline|'\n'
nl|'\n'
DECL|member|childSearchPreauth
dedent|''
name|'def'
name|'childSearchPreauth'
op|'('
name|'self'
op|','
op|'*'
name|'paths'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return my first existing child with a name in \'paths\'.\n\n        paths is expected to be a list of *pre-secured* path fragments; in most\n        cases this will be specified by a system administrator and not an\n        arbitrary user.\n\n        If no appropriately-named children exist, this will return None.\n        """'
newline|'\n'
name|'p'
op|'='
name|'self'
op|'.'
name|'path'
newline|'\n'
name|'for'
name|'child'
name|'in'
name|'paths'
op|':'
newline|'\n'
indent|'            '
name|'jp'
op|'='
name|'joinpath'
op|'('
name|'p'
op|','
name|'child'
op|')'
newline|'\n'
name|'if'
name|'exists'
op|'('
name|'jp'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'self'
op|'.'
name|'clonePath'
op|'('
name|'jp'
op|')'
newline|'\n'
nl|'\n'
DECL|member|siblingExtensionSearch
dedent|''
dedent|''
dedent|''
name|'def'
name|'siblingExtensionSearch'
op|'('
name|'self'
op|','
op|'*'
name|'exts'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Attempt to return a path with my name, given multiple possible\n        extensions.\n\n        Each extension in exts will be tested and the first path which exists\n        will be returned.  If no path exists, None will be returned.  If \'\' is\n        in exts, then if the file referred to by this path exists, \'self\' will\n        be returned.\n\n        The extension \'*\' has a magic meaning, which means "any path that\n        begins with self.path+\'.\' is acceptable".\n        """'
newline|'\n'
name|'p'
op|'='
name|'self'
op|'.'
name|'path'
newline|'\n'
name|'for'
name|'ext'
name|'in'
name|'exts'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'ext'
name|'and'
name|'self'
op|'.'
name|'exists'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'self'
newline|'\n'
dedent|''
name|'if'
name|'ext'
op|'=='
string|"'*'"
op|':'
newline|'\n'
indent|'                '
name|'basedot'
op|'='
name|'basename'
op|'('
name|'p'
op|')'
op|'+'
string|"'.'"
newline|'\n'
name|'for'
name|'fn'
name|'in'
name|'listdir'
op|'('
name|'dirname'
op|'('
name|'p'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'fn'
op|'.'
name|'startswith'
op|'('
name|'basedot'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'return'
name|'self'
op|'.'
name|'clonePath'
op|'('
name|'joinpath'
op|'('
name|'dirname'
op|'('
name|'p'
op|')'
op|','
name|'fn'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'p2'
op|'='
name|'p'
op|'+'
name|'ext'
newline|'\n'
name|'if'
name|'exists'
op|'('
name|'p2'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'self'
op|'.'
name|'clonePath'
op|'('
name|'p2'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|realpath
dedent|''
dedent|''
dedent|''
name|'def'
name|'realpath'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns the absolute target as a FilePath if self is a link, self\n        otherwise.  The absolute link is the ultimate file or directory the\n        link refers to (for instance, if the link refers to another link, and\n        another...).  If the filesystem does not support symlinks, or\n        if the link is cyclical, raises a LinkError.\n\n        Behaves like L{os.path.realpath} in that it does not resolve link\n        names in the middle (ex. /x/y/z, y is a link to w - realpath on z\n        will return /x/y/z, not /x/w/z).\n\n        @return: FilePath of the target path\n        @raises LinkError: if links are not supported or links are cyclical.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'islink'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'realpath'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'if'
name|'result'
op|'=='
name|'self'
op|'.'
name|'path'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'LinkError'
op|'('
string|'"Cyclical link - will loop forever"'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'clonePath'
op|'('
name|'result'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|siblingExtension
dedent|''
name|'def'
name|'siblingExtension'
op|'('
name|'self'
op|','
name|'ext'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'clonePath'
op|'('
name|'self'
op|'.'
name|'path'
op|'+'
name|'ext'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|linkTo
dedent|''
name|'def'
name|'linkTo'
op|'('
name|'self'
op|','
name|'linkFilePath'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Creates a symlink to self to at the path in the L{FilePath}\n        C{linkFilePath}.  Only works on posix systems due to its dependence on\n        C{os.symlink}.  Propagates C{OSError}s up from C{os.symlink} if\n        C{linkFilePath.parent()} does not exist, or C{linkFilePath} already\n        exists.\n\n        @param linkFilePath: a FilePath representing the link to be created\n        @type linkFilePath: L{FilePath}\n        """'
newline|'\n'
name|'os'
op|'.'
name|'symlink'
op|'('
name|'self'
op|'.'
name|'path'
op|','
name|'linkFilePath'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|open
dedent|''
name|'def'
name|'open'
op|'('
name|'self'
op|','
name|'mode'
op|'='
string|"'r'"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'alwaysCreate'
op|':'
newline|'\n'
indent|'            '
name|'assert'
string|"'a'"
name|'not'
name|'in'
name|'mode'
op|','
string|'"Appending not supported when alwaysCreate == True"'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'create'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'open'
op|'('
name|'self'
op|'.'
name|'path'
op|','
name|'mode'
op|'+'
string|"'b'"
op|')'
newline|'\n'
nl|'\n'
comment|'# stat methods below'
nl|'\n'
nl|'\n'
DECL|member|restat
dedent|''
name|'def'
name|'restat'
op|'('
name|'self'
op|','
name|'reraise'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Re-calculate cached effects of \'stat\'.  To refresh information on this path\n        after you know the filesystem may have changed, call this method.\n\n        @param reraise: a boolean.  If true, re-raise exceptions from\n        L{os.stat}; otherwise, mark this path as not existing, and remove any\n        cached stat information.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'statinfo'
op|'='
name|'stat'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'statinfo'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'reraise'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|chmod
dedent|''
dedent|''
dedent|''
name|'def'
name|'chmod'
op|'('
name|'self'
op|','
name|'mode'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Changes the permissions on self, if possible.  Propagates errors from\n        C{os.chmod} up.\n\n        @param mode: integer representing the new permissions desired (same as\n            the command line chmod)\n        @type mode: C{int}\n        """'
newline|'\n'
name|'os'
op|'.'
name|'chmod'
op|'('
name|'self'
op|'.'
name|'path'
op|','
name|'mode'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getsize
dedent|''
name|'def'
name|'getsize'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'st'
op|'='
name|'self'
op|'.'
name|'statinfo'
newline|'\n'
name|'if'
name|'not'
name|'st'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'restat'
op|'('
op|')'
newline|'\n'
name|'st'
op|'='
name|'self'
op|'.'
name|'statinfo'
newline|'\n'
dedent|''
name|'return'
name|'st'
op|'.'
name|'st_size'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getModificationTime
dedent|''
name|'def'
name|'getModificationTime'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Retrieve the time of last access from this file.\n\n        @return: a number of seconds from the epoch.\n        @rtype: float\n        """'
newline|'\n'
name|'st'
op|'='
name|'self'
op|'.'
name|'statinfo'
newline|'\n'
name|'if'
name|'not'
name|'st'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'restat'
op|'('
op|')'
newline|'\n'
name|'st'
op|'='
name|'self'
op|'.'
name|'statinfo'
newline|'\n'
dedent|''
name|'return'
name|'float'
op|'('
name|'st'
op|'.'
name|'st_mtime'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getStatusChangeTime
dedent|''
name|'def'
name|'getStatusChangeTime'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Retrieve the time of the last status change for this file.\n\n        @return: a number of seconds from the epoch.\n        @rtype: float\n        """'
newline|'\n'
name|'st'
op|'='
name|'self'
op|'.'
name|'statinfo'
newline|'\n'
name|'if'
name|'not'
name|'st'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'restat'
op|'('
op|')'
newline|'\n'
name|'st'
op|'='
name|'self'
op|'.'
name|'statinfo'
newline|'\n'
dedent|''
name|'return'
name|'float'
op|'('
name|'st'
op|'.'
name|'st_ctime'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getAccessTime
dedent|''
name|'def'
name|'getAccessTime'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Retrieve the time that this file was last accessed.\n\n        @return: a number of seconds from the epoch.\n        @rtype: float\n        """'
newline|'\n'
name|'st'
op|'='
name|'self'
op|'.'
name|'statinfo'
newline|'\n'
name|'if'
name|'not'
name|'st'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'restat'
op|'('
op|')'
newline|'\n'
name|'st'
op|'='
name|'self'
op|'.'
name|'statinfo'
newline|'\n'
dedent|''
name|'return'
name|'float'
op|'('
name|'st'
op|'.'
name|'st_atime'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|exists
dedent|''
name|'def'
name|'exists'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check if the C{path} exists.\n\n        @return: C{True} if the stats of C{path} can be retrieved successfully,\n            C{False} in the other cases.\n        @rtype: C{bool}\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'statinfo'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'restat'
op|'('
name|'False'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'statinfo'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|isdir
dedent|''
dedent|''
dedent|''
name|'def'
name|'isdir'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'st'
op|'='
name|'self'
op|'.'
name|'statinfo'
newline|'\n'
name|'if'
name|'not'
name|'st'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'restat'
op|'('
name|'False'
op|')'
newline|'\n'
name|'st'
op|'='
name|'self'
op|'.'
name|'statinfo'
newline|'\n'
name|'if'
name|'not'
name|'st'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'False'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'S_ISDIR'
op|'('
name|'st'
op|'.'
name|'st_mode'
op|')'
newline|'\n'
nl|'\n'
DECL|member|isfile
dedent|''
name|'def'
name|'isfile'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'st'
op|'='
name|'self'
op|'.'
name|'statinfo'
newline|'\n'
name|'if'
name|'not'
name|'st'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'restat'
op|'('
name|'False'
op|')'
newline|'\n'
name|'st'
op|'='
name|'self'
op|'.'
name|'statinfo'
newline|'\n'
name|'if'
name|'not'
name|'st'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'False'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'S_ISREG'
op|'('
name|'st'
op|'.'
name|'st_mode'
op|')'
newline|'\n'
nl|'\n'
DECL|member|islink
dedent|''
name|'def'
name|'islink'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|"# We can't use cached stat results here, because that is the stat of"
nl|'\n'
comment|'# the destination - (see #1773) which in *every case* but this one is'
nl|'\n'
comment|'# the right thing to use.  We could call lstat here and use that, but'
nl|'\n'
comment|"# it seems unlikely we'd actually save any work that way.  -glyph"
nl|'\n'
indent|'        '
name|'return'
name|'islink'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|isabs
dedent|''
name|'def'
name|'isabs'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'isabs'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|listdir
dedent|''
name|'def'
name|'listdir'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'listdir'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|splitext
dedent|''
name|'def'
name|'splitext'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'splitext'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|"'FilePath(%r)'"
op|'%'
op|'('
name|'self'
op|'.'
name|'path'
op|','
op|')'
newline|'\n'
nl|'\n'
DECL|member|touch
dedent|''
name|'def'
name|'touch'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'open'
op|'('
string|"'a'"
op|')'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'IOError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'utime'
op|'('
name|'self'
op|'.'
name|'path'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
DECL|member|remove
dedent|''
name|'def'
name|'remove'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Removes the file or directory that is represented by self.  If\n        C{self.path} is a directory, recursively remove all its children\n        before removing the directory.  If it\'s a file or link, just delete\n        it.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'isdir'
op|'('
op|')'
name|'and'
name|'not'
name|'self'
op|'.'
name|'islink'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'child'
name|'in'
name|'self'
op|'.'
name|'children'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'child'
op|'.'
name|'remove'
op|'('
op|')'
newline|'\n'
dedent|''
name|'os'
op|'.'
name|'rmdir'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'os'
op|'.'
name|'remove'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'restat'
op|'('
name|'False'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|makedirs
dedent|''
name|'def'
name|'makedirs'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create all directories not yet existing in C{path} segments, using\n        C{os.makedirs}.\n        """'
newline|'\n'
name|'return'
name|'os'
op|'.'
name|'makedirs'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|globChildren
dedent|''
name|'def'
name|'globChildren'
op|'('
name|'self'
op|','
name|'pattern'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Assuming I am representing a directory, return a list of\n        FilePaths representing my children that match the given\n        pattern.\n        """'
newline|'\n'
name|'import'
name|'glob'
newline|'\n'
name|'path'
op|'='
name|'self'
op|'.'
name|'path'
op|'['
op|'-'
number|'1'
op|']'
op|'=='
string|"'/'"
name|'and'
name|'self'
op|'.'
name|'path'
op|'+'
name|'pattern'
name|'or'
name|'slash'
op|'.'
name|'join'
op|'('
op|'['
name|'self'
op|'.'
name|'path'
op|','
name|'pattern'
op|']'
op|')'
newline|'\n'
name|'return'
name|'map'
op|'('
name|'self'
op|'.'
name|'clonePath'
op|','
name|'glob'
op|'.'
name|'glob'
op|'('
name|'path'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|basename
dedent|''
name|'def'
name|'basename'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'basename'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|dirname
dedent|''
name|'def'
name|'dirname'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'dirname'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|parent
dedent|''
name|'def'
name|'parent'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'clonePath'
op|'('
name|'self'
op|'.'
name|'dirname'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|setContent
dedent|''
name|'def'
name|'setContent'
op|'('
name|'self'
op|','
name|'content'
op|','
name|'ext'
op|'='
string|"'.new'"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'sib'
op|'='
name|'self'
op|'.'
name|'siblingExtension'
op|'('
name|'ext'
op|')'
newline|'\n'
name|'f'
op|'='
name|'sib'
op|'.'
name|'open'
op|'('
string|"'w'"
op|')'
newline|'\n'
name|'f'
op|'.'
name|'write'
op|'('
name|'content'
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'if'
name|'platform'
op|'.'
name|'isWindows'
op|'('
op|')'
name|'and'
name|'exists'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'os'
op|'.'
name|'unlink'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
dedent|''
name|'os'
op|'.'
name|'rename'
op|'('
name|'sib'
op|'.'
name|'path'
op|','
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
comment|'# new in 2.2.0'
nl|'\n'
nl|'\n'
DECL|member|__cmp__
dedent|''
name|'def'
name|'__cmp__'
op|'('
name|'self'
op|','
name|'other'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'other'
op|','
name|'FilePath'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'NotImplemented'
newline|'\n'
dedent|''
name|'return'
name|'cmp'
op|'('
name|'self'
op|'.'
name|'path'
op|','
name|'other'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|createDirectory
dedent|''
name|'def'
name|'createDirectory'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'os'
op|'.'
name|'mkdir'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|requireCreate
dedent|''
name|'def'
name|'requireCreate'
op|'('
name|'self'
op|','
name|'val'
op|'='
number|'1'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'alwaysCreate'
op|'='
name|'val'
newline|'\n'
nl|'\n'
DECL|member|create
dedent|''
name|'def'
name|'create'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Exclusively create a file, only if this file previously did not exist.\n        """'
newline|'\n'
name|'fdint'
op|'='
name|'os'
op|'.'
name|'open'
op|'('
name|'self'
op|'.'
name|'path'
op|','
op|'('
name|'os'
op|'.'
name|'O_EXCL'
op|'|'
nl|'\n'
name|'os'
op|'.'
name|'O_CREAT'
op|'|'
nl|'\n'
name|'os'
op|'.'
name|'O_RDWR'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|"# XXX TODO: 'name' attribute of returned files is not mutable or"
nl|'\n'
comment|'# settable via fdopen, so this file is slighly less functional than the'
nl|'\n'
comment|"# one returned from 'open' by default.  send a patch to Python..."
nl|'\n'
nl|'\n'
name|'return'
name|'os'
op|'.'
name|'fdopen'
op|'('
name|'fdint'
op|','
string|"'w+b'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|temporarySibling
dedent|''
name|'def'
name|'temporarySibling'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a path naming a temporary sibling of this path in a secure fashion.\n        """'
newline|'\n'
name|'sib'
op|'='
name|'self'
op|'.'
name|'sibling'
op|'('
name|'_secureEnoughString'
op|'('
op|')'
op|'+'
name|'self'
op|'.'
name|'basename'
op|'('
op|')'
op|')'
newline|'\n'
name|'sib'
op|'.'
name|'requireCreate'
op|'('
op|')'
newline|'\n'
name|'return'
name|'sib'
newline|'\n'
nl|'\n'
DECL|variable|_chunkSize
dedent|''
name|'_chunkSize'
op|'='
number|'2'
op|'**'
number|'2'
op|'**'
number|'2'
op|'**'
number|'2'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|copyTo
name|'def'
name|'copyTo'
op|'('
name|'self'
op|','
name|'destination'
op|','
name|'followLinks'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Copies self to destination.\n\n        If self is a directory, this method copies its children (but not\n        itself) recursively to destination - if destination does not exist as a\n        directory, this method creates it.  If destination is a file, an\n        IOError will be raised.\n\n        If self is a file, this method copies it to destination.  If\n        destination is a file, this method overwrites it.  If destination is a\n        directory, an IOError will be raised.\n\n        If self is a link (and followLinks is False), self will be copied\n        over as a new symlink with the same target as returned by os.readlink.\n        That means that if it is absolute, both the old and new symlink will\n        link to the same thing.  If it\'s relative, then perhaps not (and\n        it\'s also possible that this relative link will be broken).\n\n        File/directory permissions and ownership will NOT be copied over.\n\n        If followLinks is True, symlinks are followed so that they\'re treated\n        as their targets.  In other words, if self is a link, the link\'s target\n        will be copied.  If destination is a link, self will be copied to the\n        destination\'s target (the actual destination will be destination\'s\n        target).  Symlinks under self (if self is a directory) will be\n        followed and its target\'s children be copied recursively.\n\n        If followLinks is False, symlinks will be copied over as symlinks.\n\n        @param destination: the destination (a FilePath) to which self\n            should be copied\n        @param followLinks: whether symlinks in self should be treated as links\n            or as their targets\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'islink'
op|'('
op|')'
name|'and'
name|'not'
name|'followLinks'
op|':'
newline|'\n'
indent|'            '
name|'os'
op|'.'
name|'symlink'
op|'('
name|'os'
op|'.'
name|'readlink'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
op|','
name|'destination'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'return'
newline|'\n'
comment|'# XXX TODO: *thorough* audit and documentation of the exact desired'
nl|'\n'
comment|'# semantics of this code.  Right now the behavior of existent'
nl|'\n'
comment|'# destination symlinks is convenient, and quite possibly correct, but'
nl|'\n'
comment|'# its security properties need to be explained.'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'isdir'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'destination'
op|'.'
name|'exists'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'destination'
op|'.'
name|'createDirectory'
op|'('
op|')'
newline|'\n'
dedent|''
name|'for'
name|'child'
name|'in'
name|'self'
op|'.'
name|'children'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'destChild'
op|'='
name|'destination'
op|'.'
name|'child'
op|'('
name|'child'
op|'.'
name|'basename'
op|'('
op|')'
op|')'
newline|'\n'
name|'child'
op|'.'
name|'copyTo'
op|'('
name|'destChild'
op|','
name|'followLinks'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'self'
op|'.'
name|'isfile'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'writefile'
op|'='
name|'destination'
op|'.'
name|'open'
op|'('
string|"'w'"
op|')'
newline|'\n'
name|'readfile'
op|'='
name|'self'
op|'.'
name|'open'
op|'('
op|')'
newline|'\n'
name|'while'
number|'1'
op|':'
newline|'\n'
comment|'# XXX TODO: optionally use os.open, os.read and O_DIRECT and'
nl|'\n'
comment|'# use os.fstatvfs to determine chunk sizes and make'
nl|'\n'
comment|'# *****sure**** copy is page-atomic; the following is good'
nl|'\n'
comment|"# enough for 99.9% of everybody and won't take a week to audit"
nl|'\n'
comment|'# though.'
nl|'\n'
indent|'                '
name|'chunk'
op|'='
name|'readfile'
op|'.'
name|'read'
op|'('
name|'self'
op|'.'
name|'_chunkSize'
op|')'
newline|'\n'
name|'writefile'
op|'.'
name|'write'
op|'('
name|'chunk'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'chunk'
op|')'
op|'<'
name|'self'
op|'.'
name|'_chunkSize'
op|':'
newline|'\n'
indent|'                    '
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'writefile'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'readfile'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# If you see the following message because you want to copy'
nl|'\n'
comment|'# symlinks, fifos, block devices, character devices, or unix'
nl|'\n'
comment|'# sockets, please feel free to add support to do sensible things in'
nl|'\n'
comment|'# reaction to those types!'
nl|'\n'
indent|'            '
name|'raise'
name|'NotImplementedError'
op|'('
nl|'\n'
string|'"Only copying of files and directories supported"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|moveTo
dedent|''
dedent|''
name|'def'
name|'moveTo'
op|'('
name|'self'
op|','
name|'destination'
op|','
name|'followLinks'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Move self to destination - basically renaming self to whatever\n        destination is named.  If destination is an already-existing directory,\n        moves all children to destination if destination is empty.  If\n        destination is a non-empty directory, or destination is a file, an\n        OSError will be raised.\n\n        If moving between filesystems, self needs to be copied, and everything\n        that applies to copyTo applies to moveTo.\n\n        @param destination: the destination (a FilePath) to which self\n            should be copied\n        @param followLinks: whether symlinks in self should be treated as links\n            or as their targets (only applicable when moving between\n            filesystems)\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'os'
op|'.'
name|'rename'
op|'('
name|'self'
op|'.'
name|'path'
op|','
name|'destination'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'restat'
op|'('
name|'False'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|','
name|'ose'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'ose'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'EXDEV'
op|':'
newline|'\n'
comment|'# man 2 rename, ubuntu linux 5.10 "breezy":'
nl|'\n'
nl|'\n'
comment|'#   oldpath and newpath are not on the same mounted filesystem.'
nl|'\n'
comment|'#   (Linux permits a filesystem to be mounted at multiple'
nl|'\n'
comment|'#   points, but rename(2) does not work across different mount'
nl|'\n'
comment|'#   points, even if the same filesystem is mounted on both.)'
nl|'\n'
nl|'\n'
comment|"# that means it's time to copy trees of directories!"
nl|'\n'
indent|'                '
name|'secsib'
op|'='
name|'destination'
op|'.'
name|'temporarySibling'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'copyTo'
op|'('
name|'secsib'
op|','
name|'followLinks'
op|')'
comment|'# slow'
newline|'\n'
name|'secsib'
op|'.'
name|'moveTo'
op|'('
name|'destination'
op|','
name|'followLinks'
op|')'
comment|'# visible'
newline|'\n'
nl|'\n'
comment|"# done creating new stuff.  let's clean me up."
nl|'\n'
name|'mysecsib'
op|'='
name|'self'
op|'.'
name|'temporarySibling'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'moveTo'
op|'('
name|'mysecsib'
op|','
name|'followLinks'
op|')'
comment|'# visible'
newline|'\n'
name|'mysecsib'
op|'.'
name|'remove'
op|'('
op|')'
comment|'# slow'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'FilePath'
op|'.'
name|'clonePath'
op|'='
name|'FilePath'
newline|'\n'
endmarker|''
end_unit
