begin_unit
comment|'# Copyright (c) 2001-2008 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
nl|'\n'
string|'"""\nTest methods in twisted.internet.threads and reactor thread APIs.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'sys'
op|','
name|'os'
op|','
name|'time'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'reactor'
op|','
name|'defer'
op|','
name|'interfaces'
op|','
name|'threads'
op|','
name|'protocol'
op|','
name|'error'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'failure'
op|','
name|'threadable'
op|','
name|'log'
op|','
name|'threadpool'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ReactorThreadsTestCase
name|'class'
name|'ReactorThreadsTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for the reactor threading API.\n    """'
newline|'\n'
nl|'\n'
DECL|member|test_suggestThreadPoolSize
name|'def'
name|'test_suggestThreadPoolSize'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Try to change maximum number of threads.\n        """'
newline|'\n'
name|'reactor'
op|'.'
name|'suggestThreadPoolSize'
op|'('
number|'34'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'reactor'
op|'.'
name|'threadpool'
op|'.'
name|'max'
op|','
number|'34'
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'suggestThreadPoolSize'
op|'('
number|'4'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'reactor'
op|'.'
name|'threadpool'
op|'.'
name|'max'
op|','
number|'4'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_waitForThread
dedent|''
name|'def'
name|'_waitForThread'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The reactor\'s threadpool is only available when the reactor is running,\n        so to have a sane behavior during the tests we make a dummy\n        L{threads.deferToThread} call.\n        """'
newline|'\n'
name|'return'
name|'threads'
op|'.'
name|'deferToThread'
op|'('
name|'time'
op|'.'
name|'sleep'
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_callInThread
dedent|''
name|'def'
name|'test_callInThread'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test callInThread functionality: set a C{threading.Event}, and check\n        that it\'s not in the main thread.\n        """'
newline|'\n'
DECL|function|cb
name|'def'
name|'cb'
op|'('
name|'ign'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'waiter'
op|'='
name|'threading'
op|'.'
name|'Event'
op|'('
op|')'
newline|'\n'
name|'result'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|threadedFunc
name|'def'
name|'threadedFunc'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'result'
op|'.'
name|'append'
op|'('
name|'threadable'
op|'.'
name|'isInIOThread'
op|'('
op|')'
op|')'
newline|'\n'
name|'waiter'
op|'.'
name|'set'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'reactor'
op|'.'
name|'callInThread'
op|'('
name|'threadedFunc'
op|')'
newline|'\n'
name|'waiter'
op|'.'
name|'wait'
op|'('
number|'120'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'waiter'
op|'.'
name|'isSet'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'fail'
op|'('
string|'"Timed out waiting for event."'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'result'
op|','
op|'['
name|'False'
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'_waitForThread'
op|'('
op|')'
op|'.'
name|'addCallback'
op|'('
name|'cb'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_callFromThread
dedent|''
name|'def'
name|'test_callFromThread'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test callFromThread functionality: from the main thread, and from\n        another thread.\n        """'
newline|'\n'
DECL|function|cb
name|'def'
name|'cb'
op|'('
name|'ign'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'firedByReactorThread'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'firedByOtherThread'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|threadedFunc
name|'def'
name|'threadedFunc'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'reactor'
op|'.'
name|'callFromThread'
op|'('
name|'firedByOtherThread'
op|'.'
name|'callback'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'reactor'
op|'.'
name|'callInThread'
op|'('
name|'threadedFunc'
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'callFromThread'
op|'('
name|'firedByReactorThread'
op|'.'
name|'callback'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'defer'
op|'.'
name|'DeferredList'
op|'('
nl|'\n'
op|'['
name|'firedByReactorThread'
op|','
name|'firedByOtherThread'
op|']'
op|','
nl|'\n'
name|'fireOnOneErrback'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_waitForThread'
op|'('
op|')'
op|'.'
name|'addCallback'
op|'('
name|'cb'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_wakerOverflow
dedent|''
name|'def'
name|'test_wakerOverflow'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Try to make an overflow on the reactor waker using callFromThread.\n        """'
newline|'\n'
DECL|function|cb
name|'def'
name|'cb'
op|'('
name|'ign'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'failure'
op|'='
name|'None'
newline|'\n'
name|'waiter'
op|'='
name|'threading'
op|'.'
name|'Event'
op|'('
op|')'
newline|'\n'
DECL|function|threadedFunction
name|'def'
name|'threadedFunction'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# Hopefully a hundred thousand queued calls is enough to'
nl|'\n'
comment|'# trigger the error condition'
nl|'\n'
indent|'                '
name|'for'
name|'i'
name|'in'
name|'xrange'
op|'('
number|'100000'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'try'
op|':'
newline|'\n'
indent|'                        '
name|'reactor'
op|'.'
name|'callFromThread'
op|'('
name|'lambda'
op|':'
name|'None'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'failure'
op|'='
name|'failure'
op|'.'
name|'Failure'
op|'('
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'waiter'
op|'.'
name|'set'
op|'('
op|')'
newline|'\n'
dedent|''
name|'reactor'
op|'.'
name|'callInThread'
op|'('
name|'threadedFunction'
op|')'
newline|'\n'
name|'waiter'
op|'.'
name|'wait'
op|'('
number|'120'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'waiter'
op|'.'
name|'isSet'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'fail'
op|'('
string|'"Timed out waiting for event"'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'failure'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'defer'
op|'.'
name|'fail'
op|'('
name|'self'
op|'.'
name|'failure'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'_waitForThread'
op|'('
op|')'
op|'.'
name|'addCallback'
op|'('
name|'cb'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_testBlockingCallFromThread
dedent|''
name|'def'
name|'_testBlockingCallFromThread'
op|'('
name|'self'
op|','
name|'reactorFunc'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Utility method to test L{threads.blockingCallFromThread}.\n        """'
newline|'\n'
name|'waiter'
op|'='
name|'threading'
op|'.'
name|'Event'
op|'('
op|')'
newline|'\n'
name|'results'
op|'='
op|'['
op|']'
newline|'\n'
name|'errors'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|cb1
name|'def'
name|'cb1'
op|'('
name|'ign'
op|')'
op|':'
newline|'\n'
DECL|function|threadedFunc
indent|'            '
name|'def'
name|'threadedFunc'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'r'
op|'='
name|'threads'
op|'.'
name|'blockingCallFromThread'
op|'('
name|'reactor'
op|','
name|'reactorFunc'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|','
name|'e'
op|':'
newline|'\n'
indent|'                    '
name|'errors'
op|'.'
name|'append'
op|'('
name|'e'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'results'
op|'.'
name|'append'
op|'('
name|'r'
op|')'
newline|'\n'
dedent|''
name|'waiter'
op|'.'
name|'set'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'reactor'
op|'.'
name|'callInThread'
op|'('
name|'threadedFunc'
op|')'
newline|'\n'
name|'return'
name|'threads'
op|'.'
name|'deferToThread'
op|'('
name|'waiter'
op|'.'
name|'wait'
op|','
name|'self'
op|'.'
name|'getTimeout'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|cb2
dedent|''
name|'def'
name|'cb2'
op|'('
name|'ign'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'waiter'
op|'.'
name|'isSet'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'fail'
op|'('
string|'"Timed out waiting for event"'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'results'
op|','
name|'errors'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_waitForThread'
op|'('
op|')'
op|'.'
name|'addCallback'
op|'('
name|'cb1'
op|')'
op|'.'
name|'addBoth'
op|'('
name|'cb2'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_blockingCallFromThread
dedent|''
name|'def'
name|'test_blockingCallFromThread'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test blockingCallFromThread facility: create a thread, call a function\n        in the reactor using L{threads.blockingCallFromThread}, and verify the\n        result returned.\n        """'
newline|'\n'
DECL|function|reactorFunc
name|'def'
name|'reactorFunc'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'defer'
op|'.'
name|'succeed'
op|'('
string|'"foo"'
op|')'
newline|'\n'
DECL|function|cb
dedent|''
name|'def'
name|'cb'
op|'('
name|'res'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'res'
op|'['
number|'0'
op|']'
op|'['
number|'0'
op|']'
op|','
string|'"foo"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_testBlockingCallFromThread'
op|'('
name|'reactorFunc'
op|')'
op|'.'
name|'addCallback'
op|'('
name|'cb'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_asyncBlockingCallFromThread
dedent|''
name|'def'
name|'test_asyncBlockingCallFromThread'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test blockingCallFromThread as above, but be sure the resulting\n        Deferred is not already fired.\n        """'
newline|'\n'
DECL|function|reactorFunc
name|'def'
name|'reactorFunc'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0.1'
op|','
name|'d'
op|'.'
name|'callback'
op|','
string|'"egg"'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
DECL|function|cb
dedent|''
name|'def'
name|'cb'
op|'('
name|'res'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'res'
op|'['
number|'0'
op|']'
op|'['
number|'0'
op|']'
op|','
string|'"egg"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_testBlockingCallFromThread'
op|'('
name|'reactorFunc'
op|')'
op|'.'
name|'addCallback'
op|'('
name|'cb'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_errorBlockingCallFromThread
dedent|''
name|'def'
name|'test_errorBlockingCallFromThread'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test error report for blockingCallFromThread.\n        """'
newline|'\n'
DECL|function|reactorFunc
name|'def'
name|'reactorFunc'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'defer'
op|'.'
name|'fail'
op|'('
name|'RuntimeError'
op|'('
string|'"bar"'
op|')'
op|')'
newline|'\n'
DECL|function|cb
dedent|''
name|'def'
name|'cb'
op|'('
name|'res'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assert_'
op|'('
name|'isinstance'
op|'('
name|'res'
op|'['
number|'1'
op|']'
op|'['
number|'0'
op|']'
op|','
name|'RuntimeError'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'res'
op|'['
number|'1'
op|']'
op|'['
number|'0'
op|']'
op|'.'
name|'args'
op|'['
number|'0'
op|']'
op|','
string|'"bar"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_testBlockingCallFromThread'
op|'('
name|'reactorFunc'
op|')'
op|'.'
name|'addCallback'
op|'('
name|'cb'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_asyncErrorBlockingCallFromThread
dedent|''
name|'def'
name|'test_asyncErrorBlockingCallFromThread'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test error report for blockingCallFromThread as above, but be sure the\n        resulting Deferred is not already fired.\n        """'
newline|'\n'
DECL|function|reactorFunc
name|'def'
name|'reactorFunc'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0.1'
op|','
name|'d'
op|'.'
name|'errback'
op|','
name|'RuntimeError'
op|'('
string|'"spam"'
op|')'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
DECL|function|cb
dedent|''
name|'def'
name|'cb'
op|'('
name|'res'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assert_'
op|'('
name|'isinstance'
op|'('
name|'res'
op|'['
number|'1'
op|']'
op|'['
number|'0'
op|']'
op|','
name|'RuntimeError'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'res'
op|'['
number|'1'
op|']'
op|'['
number|'0'
op|']'
op|'.'
name|'args'
op|'['
number|'0'
op|']'
op|','
string|'"spam"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_testBlockingCallFromThread'
op|'('
name|'reactorFunc'
op|')'
op|'.'
name|'addCallback'
op|'('
name|'cb'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Counter
dedent|''
dedent|''
name|'class'
name|'Counter'
op|':'
newline|'\n'
DECL|variable|index
indent|'    '
name|'index'
op|'='
number|'0'
newline|'\n'
DECL|variable|problem
name|'problem'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|member|add
name|'def'
name|'add'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""A non thread-safe method."""'
newline|'\n'
name|'next'
op|'='
name|'self'
op|'.'
name|'index'
op|'+'
number|'1'
newline|'\n'
comment|'# another thread could jump in here and increment self.index on us'
nl|'\n'
name|'if'
name|'next'
op|'!='
name|'self'
op|'.'
name|'index'
op|'+'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'problem'
op|'='
number|'1'
newline|'\n'
name|'raise'
name|'ValueError'
newline|'\n'
comment|"# or here, same issue but we wouldn't catch it. We'd overwrite"
nl|'\n'
comment|'# their results, and the index will have lost a count. If'
nl|'\n'
comment|'# several threads get in here, we will actually make the count'
nl|'\n'
comment|'# go backwards when we overwrite it.'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'index'
op|'='
name|'next'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DeferredResultTestCase
dedent|''
dedent|''
name|'class'
name|'DeferredResultTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test twisted.internet.threads.\n    """'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'reactor'
op|'.'
name|'suggestThreadPoolSize'
op|'('
number|'8'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tearDown
dedent|''
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'reactor'
op|'.'
name|'suggestThreadPoolSize'
op|'('
number|'0'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testCallMultiple
dedent|''
name|'def'
name|'testCallMultiple'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'L'
op|'='
op|'['
op|']'
newline|'\n'
name|'N'
op|'='
number|'10'
newline|'\n'
name|'d'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|finished
name|'def'
name|'finished'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'L'
op|','
name|'range'
op|'('
name|'N'
op|')'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'threads'
op|'.'
name|'callMultipleInThread'
op|'('
op|'['
nl|'\n'
op|'('
name|'L'
op|'.'
name|'append'
op|','
op|'('
name|'i'
op|','
op|')'
op|','
op|'{'
op|'}'
op|')'
name|'for'
name|'i'
name|'in'
name|'xrange'
op|'('
name|'N'
op|')'
nl|'\n'
op|']'
op|'+'
op|'['
op|'('
name|'reactor'
op|'.'
name|'callFromThread'
op|','
op|'('
name|'finished'
op|','
op|')'
op|','
op|'{'
op|'}'
op|')'
op|']'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_deferredResult
dedent|''
name|'def'
name|'test_deferredResult'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{threads.deferToThread} executes the function passed, and correctly\n        handles the positional and keyword arguments given.\n        """'
newline|'\n'
name|'d'
op|'='
name|'threads'
op|'.'
name|'deferToThread'
op|'('
name|'lambda'
name|'x'
op|','
name|'y'
op|'='
number|'5'
op|':'
name|'x'
op|'+'
name|'y'
op|','
number|'3'
op|','
name|'y'
op|'='
number|'4'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'assertEquals'
op|','
number|'7'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_deferredFailure
dedent|''
name|'def'
name|'test_deferredFailure'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that L{threads.deferToThread} return a failure object\n        with an appropriate exception instance when the called\n        function raises an exception.\n        """'
newline|'\n'
DECL|class|NewError
name|'class'
name|'NewError'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
DECL|function|raiseError
dedent|''
name|'def'
name|'raiseError'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'NewError'
op|'('
op|')'
newline|'\n'
dedent|''
name|'d'
op|'='
name|'threads'
op|'.'
name|'deferToThread'
op|'('
name|'raiseError'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'NewError'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_deferredFailureAfterSuccess
dedent|''
name|'def'
name|'test_deferredFailureAfterSuccess'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that a successfull L{threads.deferToThread} followed by a one\n        that raises an exception correctly result as a failure.\n        """'
newline|'\n'
comment|'# set up a condition that causes cReactor to hang. These conditions'
nl|'\n'
comment|'# can also be set by other tests when the full test suite is run in'
nl|'\n'
comment|'# alphabetical order (test_flow.FlowTest.testThreaded followed by'
nl|'\n'
comment|'# test_internet.ReactorCoreTestCase.testStop, to be precise). By'
nl|'\n'
comment|'# setting them up explicitly here, we can reproduce the hang in a'
nl|'\n'
comment|'# single precise test case instead of depending upon side effects of'
nl|'\n'
comment|'# other tests.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# alas, this test appears to flunk the default reactor too'
nl|'\n'
nl|'\n'
name|'d'
op|'='
name|'threads'
op|'.'
name|'deferToThread'
op|'('
name|'lambda'
op|':'
name|'None'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'lambda'
name|'ign'
op|':'
name|'threads'
op|'.'
name|'deferToThread'
op|'('
name|'lambda'
op|':'
number|'1'
op|'/'
number|'0'
op|')'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'ZeroDivisionError'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DeferToThreadPoolTestCase
dedent|''
dedent|''
name|'class'
name|'DeferToThreadPoolTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test L{twisted.internet.threads.deferToThreadPool}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'tp'
op|'='
name|'threadpool'
op|'.'
name|'ThreadPool'
op|'('
number|'0'
op|','
number|'8'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'tp'
op|'.'
name|'start'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tearDown
dedent|''
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'tp'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_deferredResult
dedent|''
name|'def'
name|'test_deferredResult'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{threads.deferToThreadPool} executes the function passed, and\n        correctly handles the positional and keyword arguments given.\n        """'
newline|'\n'
name|'d'
op|'='
name|'threads'
op|'.'
name|'deferToThreadPool'
op|'('
name|'reactor'
op|','
name|'self'
op|'.'
name|'tp'
op|','
nl|'\n'
name|'lambda'
name|'x'
op|','
name|'y'
op|'='
number|'5'
op|':'
name|'x'
op|'+'
name|'y'
op|','
number|'3'
op|','
name|'y'
op|'='
number|'4'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'assertEqual'
op|','
number|'7'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_deferredFailure
dedent|''
name|'def'
name|'test_deferredFailure'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that L{threads.deferToThreadPool} return a failure object with an\n        appropriate exception instance when the called function raises an\n        exception.\n        """'
newline|'\n'
DECL|class|NewError
name|'class'
name|'NewError'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
DECL|function|raiseError
dedent|''
name|'def'
name|'raiseError'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'NewError'
op|'('
op|')'
newline|'\n'
dedent|''
name|'d'
op|'='
name|'threads'
op|'.'
name|'deferToThreadPool'
op|'('
name|'reactor'
op|','
name|'self'
op|'.'
name|'tp'
op|','
name|'raiseError'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'NewError'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'_callBeforeStartupProgram'
op|'='
string|'"""\nimport time\nimport %(reactor)s\n%(reactor)s.install()\n\nfrom twisted.internet import reactor\n\ndef threadedCall():\n    print \'threaded call\'\n\nreactor.callInThread(threadedCall)\n\n# Spin very briefly to try to give the thread a chance to run, if it\n# is going to.  Is there a better way to achieve this behavior?\nfor i in xrange(100):\n    time.sleep(0.0)\n"""'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ThreadStartupProcessProtocol
name|'class'
name|'ThreadStartupProcessProtocol'
op|'('
name|'protocol'
op|'.'
name|'ProcessProtocol'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'finished'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'finished'
op|'='
name|'finished'
newline|'\n'
name|'self'
op|'.'
name|'out'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'err'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|outReceived
dedent|''
name|'def'
name|'outReceived'
op|'('
name|'self'
op|','
name|'out'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'out'
op|'.'
name|'append'
op|'('
name|'out'
op|')'
newline|'\n'
nl|'\n'
DECL|member|errReceived
dedent|''
name|'def'
name|'errReceived'
op|'('
name|'self'
op|','
name|'err'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'err'
op|'.'
name|'append'
op|'('
name|'err'
op|')'
newline|'\n'
nl|'\n'
DECL|member|processEnded
dedent|''
name|'def'
name|'processEnded'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'finished'
op|'.'
name|'callback'
op|'('
op|'('
name|'self'
op|'.'
name|'out'
op|','
name|'self'
op|'.'
name|'err'
op|','
name|'reason'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|StartupBehaviorTestCase
dedent|''
dedent|''
name|'class'
name|'StartupBehaviorTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test cases for the behavior of the reactor threadpool near startup\n    boundary conditions.\n\n    In particular, this asserts that no threaded calls are attempted\n    until the reactor starts up, that calls attempted before it starts\n    are in fact executed once it has started, and that in both cases,\n    the reactor properly cleans itself up (which is tested for\n    somewhat implicitly, by requiring a child process be able to exit,\n    something it cannot do unless the threadpool has been properly\n    torn down).\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testCallBeforeStartupUnexecuted
name|'def'
name|'testCallBeforeStartupUnexecuted'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'progname'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'progfile'
op|'='
name|'file'
op|'('
name|'progname'
op|','
string|"'w'"
op|')'
newline|'\n'
name|'progfile'
op|'.'
name|'write'
op|'('
name|'_callBeforeStartupProgram'
op|'%'
op|'{'
string|"'reactor'"
op|':'
name|'reactor'
op|'.'
name|'__module__'
op|'}'
op|')'
newline|'\n'
name|'progfile'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|programFinished
name|'def'
name|'programFinished'
op|'('
op|'('
name|'out'
op|','
name|'err'
op|','
name|'reason'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'reason'
op|'.'
name|'check'
op|'('
name|'error'
op|'.'
name|'ProcessTerminated'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'fail'
op|'('
string|'"Process did not exit cleanly (out: %s err: %s)"'
op|'%'
op|'('
name|'out'
op|','
name|'err'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'err'
op|':'
newline|'\n'
indent|'                '
name|'log'
op|'.'
name|'msg'
op|'('
string|'"Unexpected output on standard error: %s"'
op|'%'
op|'('
name|'err'
op|','
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'failIf'
op|'('
name|'out'
op|','
string|'"Expected no output, instead received:\\n%s"'
op|'%'
op|'('
name|'out'
op|','
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|programTimeout
dedent|''
name|'def'
name|'programTimeout'
op|'('
name|'err'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'err'
op|'.'
name|'trap'
op|'('
name|'error'
op|'.'
name|'TimeoutError'
op|')'
newline|'\n'
name|'proto'
op|'.'
name|'signalProcess'
op|'('
string|"'KILL'"
op|')'
newline|'\n'
name|'return'
name|'err'
newline|'\n'
nl|'\n'
dedent|''
name|'env'
op|'='
name|'os'
op|'.'
name|'environ'
op|'.'
name|'copy'
op|'('
op|')'
newline|'\n'
name|'env'
op|'['
string|"'PYTHONPATH'"
op|']'
op|'='
name|'os'
op|'.'
name|'pathsep'
op|'.'
name|'join'
op|'('
name|'sys'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'d'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
op|'.'
name|'addCallbacks'
op|'('
name|'programFinished'
op|','
name|'programTimeout'
op|')'
newline|'\n'
name|'proto'
op|'='
name|'ThreadStartupProcessProtocol'
op|'('
name|'d'
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'spawnProcess'
op|'('
name|'proto'
op|','
name|'sys'
op|'.'
name|'executable'
op|','
op|'('
string|"'python'"
op|','
name|'progname'
op|')'
op|','
name|'env'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'interfaces'
op|'.'
name|'IReactorThreads'
op|'('
name|'reactor'
op|','
name|'None'
op|')'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'    '
name|'for'
name|'cls'
name|'in'
op|'('
name|'ReactorThreadsTestCase'
op|','
nl|'\n'
name|'DeferredResultTestCase'
op|','
nl|'\n'
name|'StartupBehaviorTestCase'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'cls'
op|'.'
name|'skip'
op|'='
string|'"No thread support, nothing to test here."'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'    '
name|'import'
name|'threading'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'interfaces'
op|'.'
name|'IReactorProcess'
op|'('
name|'reactor'
op|','
name|'None'
op|')'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'    '
name|'for'
name|'cls'
name|'in'
op|'('
name|'StartupBehaviorTestCase'
op|','
op|')'
op|':'
newline|'\n'
indent|'        '
name|'cls'
op|'.'
name|'skip'
op|'='
string|'"No process support, cannot run subprocess thread tests."'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
