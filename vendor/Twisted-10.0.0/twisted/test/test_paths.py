begin_unit
comment|'# Copyright (c) 2001-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTest cases covering L{twisted.python.filepath} and L{twisted.python.zippath}.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'os'
op|','
name|'time'
op|','
name|'pickle'
op|','
name|'errno'
op|','
name|'zipfile'
op|','
name|'stat'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'compat'
name|'import'
name|'set'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'win32'
name|'import'
name|'WindowsError'
op|','
name|'ERROR_DIRECTORY'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'filepath'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'zippath'
name|'import'
name|'ZipArchive'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'runtime'
name|'import'
name|'platform'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|AbstractFilePathTestCase
name|'class'
name|'AbstractFilePathTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|f1content
indent|'    '
name|'f1content'
op|'='
string|'"file 1"'
newline|'\n'
DECL|variable|f2content
name|'f2content'
op|'='
string|'"file 2"'
newline|'\n'
nl|'\n'
DECL|member|_mkpath
name|'def'
name|'_mkpath'
op|'('
name|'self'
op|','
op|'*'
name|'p'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'x'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'abspath'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'cmn'
op|','
op|'*'
name|'p'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'all'
op|'.'
name|'append'
op|'('
name|'x'
op|')'
newline|'\n'
name|'return'
name|'x'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|subdir
dedent|''
name|'def'
name|'subdir'
op|'('
name|'self'
op|','
op|'*'
name|'dirname'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'os'
op|'.'
name|'mkdir'
op|'('
name|'self'
op|'.'
name|'_mkpath'
op|'('
op|'*'
name|'dirname'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|subfile
dedent|''
name|'def'
name|'subfile'
op|'('
name|'self'
op|','
op|'*'
name|'dirname'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'open'
op|'('
name|'self'
op|'.'
name|'_mkpath'
op|'('
op|'*'
name|'dirname'
op|')'
op|','
string|'"wb"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|setUp
dedent|''
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'now'
op|'='
name|'time'
op|'.'
name|'time'
op|'('
op|')'
newline|'\n'
name|'cmn'
op|'='
name|'self'
op|'.'
name|'cmn'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'abspath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'all'
op|'='
op|'['
name|'cmn'
op|']'
newline|'\n'
name|'os'
op|'.'
name|'mkdir'
op|'('
name|'cmn'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'subdir'
op|'('
string|'"sub1"'
op|')'
newline|'\n'
name|'f'
op|'='
name|'self'
op|'.'
name|'subfile'
op|'('
string|'"file1"'
op|')'
newline|'\n'
name|'f'
op|'.'
name|'write'
op|'('
name|'self'
op|'.'
name|'f1content'
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'f'
op|'='
name|'self'
op|'.'
name|'subfile'
op|'('
string|'"sub1"'
op|','
string|'"file2"'
op|')'
newline|'\n'
name|'f'
op|'.'
name|'write'
op|'('
name|'self'
op|'.'
name|'f2content'
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'subdir'
op|'('
string|"'sub3'"
op|')'
newline|'\n'
name|'f'
op|'='
name|'self'
op|'.'
name|'subfile'
op|'('
string|'"sub3"'
op|','
string|'"file3.ext1"'
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'f'
op|'='
name|'self'
op|'.'
name|'subfile'
op|'('
string|'"sub3"'
op|','
string|'"file3.ext2"'
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'f'
op|'='
name|'self'
op|'.'
name|'subfile'
op|'('
string|'"sub3"'
op|','
string|'"file3.ext3"'
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'path'
op|'='
name|'filepath'
op|'.'
name|'FilePath'
op|'('
name|'cmn'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'root'
op|'='
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|'"/"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_segmentsFromPositive
dedent|''
name|'def'
name|'test_segmentsFromPositive'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that the segments between two paths are correctly identified.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"a"'
op|')'
op|'.'
name|'child'
op|'('
string|'"b"'
op|')'
op|'.'
name|'child'
op|'('
string|'"c"'
op|')'
op|'.'
name|'segmentsFrom'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
op|','
nl|'\n'
op|'['
string|'"a"'
op|','
string|'"b"'
op|','
string|'"c"'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_segmentsFromNegative
dedent|''
name|'def'
name|'test_segmentsFromNegative'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Verify that segmentsFrom notices when the ancestor isn\'t an ancestor.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
nl|'\n'
name|'ValueError'
op|','
nl|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"a"'
op|')'
op|'.'
name|'child'
op|'('
string|'"b"'
op|')'
op|'.'
name|'child'
op|'('
string|'"c"'
op|')'
op|'.'
name|'segmentsFrom'
op|','
nl|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"d"'
op|')'
op|'.'
name|'child'
op|'('
string|'"c"'
op|')'
op|'.'
name|'child'
op|'('
string|'"e"'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_walk
dedent|''
name|'def'
name|'test_walk'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that walking the path gives the same result as the known file\n        hierarchy.\n        """'
newline|'\n'
name|'x'
op|'='
op|'['
name|'foo'
op|'.'
name|'path'
name|'for'
name|'foo'
name|'in'
name|'self'
op|'.'
name|'path'
op|'.'
name|'walk'
op|'('
op|')'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'set'
op|'('
name|'x'
op|')'
op|','
name|'set'
op|'('
name|'self'
op|'.'
name|'all'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_parents
dedent|''
name|'def'
name|'test_parents'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{FilePath.parents()} should return an iterator of every ancestor of\n        the L{FilePath} in question.\n        """'
newline|'\n'
name|'L'
op|'='
op|'['
op|']'
newline|'\n'
name|'pathobj'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"a"'
op|')'
op|'.'
name|'child'
op|'('
string|'"b"'
op|')'
op|'.'
name|'child'
op|'('
string|'"c"'
op|')'
newline|'\n'
name|'fullpath'
op|'='
name|'pathobj'
op|'.'
name|'path'
newline|'\n'
name|'lastpath'
op|'='
name|'fullpath'
newline|'\n'
name|'thispath'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'dirname'
op|'('
name|'fullpath'
op|')'
newline|'\n'
name|'while'
name|'lastpath'
op|'!='
name|'self'
op|'.'
name|'root'
op|'.'
name|'path'
op|':'
newline|'\n'
indent|'            '
name|'L'
op|'.'
name|'append'
op|'('
name|'thispath'
op|')'
newline|'\n'
name|'lastpath'
op|'='
name|'thispath'
newline|'\n'
name|'thispath'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'dirname'
op|'('
name|'thispath'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertEquals'
op|'('
op|'['
name|'x'
op|'.'
name|'path'
name|'for'
name|'x'
name|'in'
name|'pathobj'
op|'.'
name|'parents'
op|'('
op|')'
op|']'
op|','
name|'L'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_validSubdir
dedent|''
name|'def'
name|'test_validSubdir'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Verify that a valid subdirectory will show up as a directory, but not as a\n        file, not as a symlink, and be listable.\n        """'
newline|'\n'
name|'sub1'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'sub1'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'sub1'
op|'.'
name|'exists'
op|'('
op|')'
op|','
nl|'\n'
string|'"This directory does exist."'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'sub1'
op|'.'
name|'isdir'
op|'('
op|')'
op|','
nl|'\n'
string|'"It\'s a directory."'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'not'
name|'sub1'
op|'.'
name|'isfile'
op|'('
op|')'
op|','
nl|'\n'
string|'"It\'s a directory."'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'not'
name|'sub1'
op|'.'
name|'islink'
op|'('
op|')'
op|','
nl|'\n'
string|'"It\'s a directory."'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'sub1'
op|'.'
name|'listdir'
op|'('
op|')'
op|','
nl|'\n'
op|'['
string|"'file2'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_invalidSubdir
dedent|''
name|'def'
name|'test_invalidSubdir'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that a subdirectory that doesn\'t exist is reported as such.\n        """'
newline|'\n'
name|'sub2'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'sub2'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'sub2'
op|'.'
name|'exists'
op|'('
op|')'
op|','
nl|'\n'
string|'"This directory does not exist."'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_validFiles
dedent|''
name|'def'
name|'test_validFiles'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Make sure that we can read existent non-empty files.\n        """'
newline|'\n'
name|'f1'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'file1'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'f1'
op|'.'
name|'open'
op|'('
op|')'
op|'.'
name|'read'
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'f1content'
op|')'
newline|'\n'
name|'f2'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'sub1'"
op|')'
op|'.'
name|'child'
op|'('
string|"'file2'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'f2'
op|'.'
name|'open'
op|'('
op|')'
op|'.'
name|'read'
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'f2content'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_dictionaryKeys
dedent|''
name|'def'
name|'test_dictionaryKeys'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that path instances are usable as dictionary keys.\n        """'
newline|'\n'
name|'f1'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'file1'"
op|')'
newline|'\n'
name|'f1prime'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'file1'"
op|')'
newline|'\n'
name|'f2'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'file2'"
op|')'
newline|'\n'
name|'dictoid'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'dictoid'
op|'['
name|'f1'
op|']'
op|'='
number|'3'
newline|'\n'
name|'dictoid'
op|'['
name|'f1prime'
op|']'
op|'='
number|'4'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'dictoid'
op|'['
name|'f1'
op|']'
op|','
number|'4'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'dictoid'
op|'.'
name|'keys'
op|'('
op|')'
op|','
op|'['
name|'f1'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'dictoid'
op|'.'
name|'keys'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|','
name|'f1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertNotIdentical'
op|'('
name|'dictoid'
op|'.'
name|'keys'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|','
name|'f1prime'
op|')'
comment|'# sanity check'
newline|'\n'
name|'dictoid'
op|'['
name|'f2'
op|']'
op|'='
number|'5'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'dictoid'
op|'['
name|'f2'
op|']'
op|','
number|'5'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'dictoid'
op|')'
op|','
number|'2'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_dictionaryKeyWithString
dedent|''
name|'def'
name|'test_dictionaryKeyWithString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that path instances are usable as dictionary keys which do not clash\n        with their string counterparts.\n        """'
newline|'\n'
name|'f1'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'file1'"
op|')'
newline|'\n'
name|'dictoid'
op|'='
op|'{'
name|'f1'
op|':'
string|"'hello'"
op|'}'
newline|'\n'
name|'dictoid'
op|'['
name|'f1'
op|'.'
name|'path'
op|']'
op|'='
string|"'goodbye'"
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'dictoid'
op|')'
op|','
number|'2'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_childrenNonexistentError
dedent|''
name|'def'
name|'test_childrenNonexistentError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that children raises the appropriate exception for non-existent\n        directories.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'filepath'
op|'.'
name|'UnlistableError'
op|','
nl|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'not real'"
op|')'
op|'.'
name|'children'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_childrenNotDirectoryError
dedent|''
name|'def'
name|'test_childrenNotDirectoryError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that listdir raises the appropriate exception for attempting to list\n        a file rather than a directory.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'filepath'
op|'.'
name|'UnlistableError'
op|','
nl|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'file1'"
op|')'
op|'.'
name|'children'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_newTimesAreFloats
dedent|''
name|'def'
name|'test_newTimesAreFloats'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that all times returned from the various new time functions are ints\n        (and hopefully therefore \'high precision\').\n        """'
newline|'\n'
name|'for'
name|'p'
name|'in'
name|'self'
op|'.'
name|'path'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'file1'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'type'
op|'('
name|'p'
op|'.'
name|'getAccessTime'
op|'('
op|')'
op|')'
op|','
name|'float'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'type'
op|'('
name|'p'
op|'.'
name|'getModificationTime'
op|'('
op|')'
op|')'
op|','
name|'float'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'type'
op|'('
name|'p'
op|'.'
name|'getStatusChangeTime'
op|'('
op|')'
op|')'
op|','
name|'float'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_oldTimesAreInts
dedent|''
dedent|''
name|'def'
name|'test_oldTimesAreInts'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that all times returned from the various time functions are\n        integers, for compatibility.\n        """'
newline|'\n'
name|'for'
name|'p'
name|'in'
name|'self'
op|'.'
name|'path'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'file1'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'type'
op|'('
name|'p'
op|'.'
name|'getatime'
op|'('
op|')'
op|')'
op|','
name|'int'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'type'
op|'('
name|'p'
op|'.'
name|'getmtime'
op|'('
op|')'
op|')'
op|','
name|'int'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'type'
op|'('
name|'p'
op|'.'
name|'getctime'
op|'('
op|')'
op|')'
op|','
name|'int'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|FakeWindowsPath
dedent|''
dedent|''
dedent|''
name|'class'
name|'FakeWindowsPath'
op|'('
name|'filepath'
op|'.'
name|'FilePath'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A test version of FilePath which overrides listdir to raise L{WindowsError}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|listdir
name|'def'
name|'listdir'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @raise WindowsError: always.\n        """'
newline|'\n'
name|'raise'
name|'WindowsError'
op|'('
nl|'\n'
name|'ERROR_DIRECTORY'
op|','
nl|'\n'
string|'"A directory\'s validness was called into question"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ListingCompatibilityTests
dedent|''
dedent|''
name|'class'
name|'ListingCompatibilityTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    These tests verify compatibility with legacy behavior of directory listing.\n    """'
newline|'\n'
nl|'\n'
DECL|member|test_windowsErrorExcept
name|'def'
name|'test_windowsErrorExcept'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that when a WindowsError is raised from listdir, catching\n        WindowsError works.\n        """'
newline|'\n'
name|'fwp'
op|'='
name|'FakeWindowsPath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'filepath'
op|'.'
name|'UnlistableError'
op|','
name|'fwp'
op|'.'
name|'children'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'WindowsError'
op|','
name|'fwp'
op|'.'
name|'children'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_alwaysCatchOSError
dedent|''
name|'def'
name|'test_alwaysCatchOSError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that in the normal case where a directory does not exist, we will\n        get an OSError.\n        """'
newline|'\n'
name|'fp'
op|'='
name|'filepath'
op|'.'
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'OSError'
op|','
name|'fp'
op|'.'
name|'children'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_keepOriginalAttributes
dedent|''
name|'def'
name|'test_keepOriginalAttributes'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that the Unlistable exception raised will preserve the attributes of\n        the previously-raised exception.\n        """'
newline|'\n'
name|'fp'
op|'='
name|'filepath'
op|'.'
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'ose'
op|'='
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'OSError'
op|','
name|'fp'
op|'.'
name|'children'
op|')'
newline|'\n'
name|'d1'
op|'='
name|'ose'
op|'.'
name|'__dict__'
op|'.'
name|'keys'
op|'('
op|')'
newline|'\n'
name|'d1'
op|'.'
name|'remove'
op|'('
string|"'originalException'"
op|')'
newline|'\n'
name|'d2'
op|'='
name|'ose'
op|'.'
name|'originalException'
op|'.'
name|'__dict__'
op|'.'
name|'keys'
op|'('
op|')'
newline|'\n'
name|'d1'
op|'.'
name|'sort'
op|'('
op|')'
newline|'\n'
name|'d2'
op|'.'
name|'sort'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d1'
op|','
name|'d2'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|zipit
dedent|''
dedent|''
name|'def'
name|'zipit'
op|'('
name|'dirname'
op|','
name|'zfname'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    create a zipfile on zfname, containing the contents of dirname\'\n    """'
newline|'\n'
name|'zf'
op|'='
name|'zipfile'
op|'.'
name|'ZipFile'
op|'('
name|'zfname'
op|','
string|'"w"'
op|')'
newline|'\n'
name|'basedir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'dirname'
op|')'
newline|'\n'
name|'for'
name|'root'
op|','
name|'dirs'
op|','
name|'files'
op|','
name|'in'
name|'os'
op|'.'
name|'walk'
op|'('
name|'dirname'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'fname'
name|'in'
name|'files'
op|':'
newline|'\n'
indent|'            '
name|'fspath'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'root'
op|','
name|'fname'
op|')'
newline|'\n'
name|'arcpath'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'root'
op|','
name|'fname'
op|')'
op|'['
name|'len'
op|'('
name|'dirname'
op|')'
op|'+'
number|'1'
op|':'
op|']'
newline|'\n'
comment|"# print fspath, '=>', arcpath"
nl|'\n'
name|'zf'
op|'.'
name|'write'
op|'('
name|'fspath'
op|','
name|'arcpath'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'zf'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ZipFilePathTestCase
dedent|''
name|'class'
name|'ZipFilePathTestCase'
op|'('
name|'AbstractFilePathTestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test various L{ZipPath} path manipulations as well as reprs for L{ZipPath}\n    and L{ZipArchive}.\n    """'
newline|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'AbstractFilePathTestCase'
op|'.'
name|'setUp'
op|'('
name|'self'
op|')'
newline|'\n'
name|'zipit'
op|'('
name|'self'
op|'.'
name|'cmn'
op|','
name|'self'
op|'.'
name|'cmn'
op|'+'
string|"'.zip'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'path'
op|'='
name|'ZipArchive'
op|'('
name|'self'
op|'.'
name|'cmn'
op|'+'
string|"'.zip'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'root'
op|'='
name|'self'
op|'.'
name|'path'
newline|'\n'
name|'self'
op|'.'
name|'all'
op|'='
op|'['
name|'x'
op|'.'
name|'replace'
op|'('
name|'self'
op|'.'
name|'cmn'
op|','
name|'self'
op|'.'
name|'cmn'
op|'+'
string|"'.zip'"
op|')'
name|'for'
name|'x'
name|'in'
name|'self'
op|'.'
name|'all'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_zipPathRepr
dedent|''
name|'def'
name|'test_zipPathRepr'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Make sure that invoking ZipPath\'s repr prints the correct class name\n        and an absolute path to the zip file.\n        """'
newline|'\n'
name|'child'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'pathRepr'
op|'='
string|'"ZipPath(%r)"'
op|'%'
op|'('
nl|'\n'
name|'os'
op|'.'
name|'path'
op|'.'
name|'abspath'
op|'('
name|'self'
op|'.'
name|'cmn'
op|'+'
string|'".zip"'
op|'+'
name|'os'
op|'.'
name|'sep'
op|'+'
string|"'foo'"
op|')'
op|','
op|')'
newline|'\n'
nl|'\n'
comment|'# Check for an absolute path'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'repr'
op|'('
name|'child'
op|')'
op|','
name|'pathRepr'
op|')'
newline|'\n'
nl|'\n'
comment|'# Create a path to the file rooted in the current working directory'
nl|'\n'
name|'relativeCommon'
op|'='
name|'self'
op|'.'
name|'cmn'
op|'.'
name|'replace'
op|'('
name|'os'
op|'.'
name|'getcwd'
op|'('
op|')'
op|'+'
name|'os'
op|'.'
name|'sep'
op|','
string|'""'
op|','
number|'1'
op|')'
op|'+'
string|'".zip"'
newline|'\n'
name|'relpath'
op|'='
name|'ZipArchive'
op|'('
name|'relativeCommon'
op|')'
newline|'\n'
name|'child'
op|'='
name|'relpath'
op|'.'
name|'child'
op|'('
string|'"foo"'
op|')'
newline|'\n'
nl|'\n'
comment|'# Check using a path without the cwd prepended'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'repr'
op|'('
name|'child'
op|')'
op|','
name|'pathRepr'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_zipArchiveRepr
dedent|''
name|'def'
name|'test_zipArchiveRepr'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Make sure that invoking ZipArchive\'s repr prints the correct class\n        name and an absolute path to the zip file.\n        """'
newline|'\n'
name|'pathRepr'
op|'='
string|"'ZipArchive(%r)'"
op|'%'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'abspath'
op|'('
name|'self'
op|'.'
name|'cmn'
op|'+'
string|"'.zip'"
op|')'
op|','
op|')'
newline|'\n'
nl|'\n'
comment|'# Check for an absolute path'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'repr'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
op|','
name|'pathRepr'
op|')'
newline|'\n'
nl|'\n'
comment|'# Create a path to the file rooted in the current working directory'
nl|'\n'
name|'relativeCommon'
op|'='
name|'self'
op|'.'
name|'cmn'
op|'.'
name|'replace'
op|'('
name|'os'
op|'.'
name|'getcwd'
op|'('
op|')'
op|'+'
name|'os'
op|'.'
name|'sep'
op|','
string|'""'
op|','
number|'1'
op|')'
op|'+'
string|'".zip"'
newline|'\n'
name|'relpath'
op|'='
name|'ZipArchive'
op|'('
name|'relativeCommon'
op|')'
newline|'\n'
nl|'\n'
comment|'# Check using a path without the cwd prepended'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'repr'
op|'('
name|'relpath'
op|')'
op|','
name|'pathRepr'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|FilePathTestCase
dedent|''
dedent|''
name|'class'
name|'FilePathTestCase'
op|'('
name|'AbstractFilePathTestCase'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|test_chmod
indent|'    '
name|'def'
name|'test_chmod'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Make sure that calling L{FilePath.chmod} modifies the permissions of\n        the passed file as expected (using C{os.stat} to check). We use some\n        basic modes that should work everywhere (even on Windows).\n        """'
newline|'\n'
name|'for'
name|'mode'
name|'in'
op|'('
number|'0555'
op|','
number|'0777'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"sub1"'
op|')'
op|'.'
name|'chmod'
op|'('
name|'mode'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'stat'
op|'.'
name|'S_IMODE'
op|'('
name|'os'
op|'.'
name|'stat'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"sub1"'
op|')'
op|'.'
name|'path'
op|')'
op|'.'
name|'st_mode'
op|')'
op|','
nl|'\n'
name|'mode'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|symlink
dedent|''
dedent|''
name|'def'
name|'symlink'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'name'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a symbolic link named C{name} pointing at C{target}.\n\n        @type target: C{str}\n        @type name: C{str}\n        @raise SkipTest: raised if symbolic links are not supported on the\n            host platform.\n        """'
newline|'\n'
name|'if'
name|'getattr'
op|'('
name|'os'
op|','
string|"'symlink'"
op|','
name|'None'
op|')'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'unittest'
op|'.'
name|'SkipTest'
op|'('
nl|'\n'
string|'"Platform does not support symbolic links."'
op|')'
newline|'\n'
dedent|''
name|'os'
op|'.'
name|'symlink'
op|'('
name|'target'
op|','
name|'name'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|createLinks
dedent|''
name|'def'
name|'createLinks'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create several symbolic links to files and directories.\n        """'
newline|'\n'
name|'subdir'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"sub1"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'symlink'
op|'('
name|'subdir'
op|'.'
name|'path'
op|','
name|'self'
op|'.'
name|'_mkpath'
op|'('
string|'"sub1.link"'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'symlink'
op|'('
name|'subdir'
op|'.'
name|'child'
op|'('
string|'"file2"'
op|')'
op|'.'
name|'path'
op|','
name|'self'
op|'.'
name|'_mkpath'
op|'('
string|'"file2.link"'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'symlink'
op|'('
name|'subdir'
op|'.'
name|'child'
op|'('
string|'"file2"'
op|')'
op|'.'
name|'path'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_mkpath'
op|'('
string|'"sub1"'
op|','
string|'"sub1.file2.link"'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_realpathSymlink
dedent|''
name|'def'
name|'test_realpathSymlink'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{FilePath.realpath} returns the path of the ultimate target of a\n        symlink.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'createLinks'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'symlink'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"file2.link"'
op|')'
op|'.'
name|'path'
op|','
nl|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"link.link"'
op|')'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"link.link"'
op|')'
op|'.'
name|'realpath'
op|'('
op|')'
op|','
nl|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"sub1"'
op|')'
op|'.'
name|'child'
op|'('
string|'"file2"'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_realpathCyclicalSymlink
dedent|''
name|'def'
name|'test_realpathCyclicalSymlink'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{FilePath.realpath} raises L{filepath.LinkError} if the path is a\n        symbolic link which is part of a cycle.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'symlink'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"link1"'
op|')'
op|'.'
name|'path'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"link2"'
op|')'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'symlink'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"link2"'
op|')'
op|'.'
name|'path'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"link1"'
op|')'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'filepath'
op|'.'
name|'LinkError'
op|','
nl|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"link2"'
op|')'
op|'.'
name|'realpath'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_realpathNoSymlink
dedent|''
name|'def'
name|'test_realpathNoSymlink'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{FilePath.realpath} returns the path itself if the path is not a\n        symbolic link.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"sub1"'
op|')'
op|'.'
name|'realpath'
op|'('
op|')'
op|','
nl|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"sub1"'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_walkCyclicalSymlink
dedent|''
name|'def'
name|'test_walkCyclicalSymlink'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that walking a path with a cyclical symlink raises an error\n        """'
newline|'\n'
name|'self'
op|'.'
name|'createLinks'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'symlink'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"sub1"'
op|')'
op|'.'
name|'path'
op|','
nl|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"sub1"'
op|')'
op|'.'
name|'child'
op|'('
string|'"sub1.loopylink"'
op|')'
op|'.'
name|'path'
op|')'
newline|'\n'
DECL|function|iterateOverPath
name|'def'
name|'iterateOverPath'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'['
name|'foo'
op|'.'
name|'path'
name|'for'
name|'foo'
name|'in'
name|'self'
op|'.'
name|'path'
op|'.'
name|'walk'
op|'('
op|')'
op|']'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'filepath'
op|'.'
name|'LinkError'
op|','
name|'iterateOverPath'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_walkObeysDescendWithCyclicalSymlinks
dedent|''
name|'def'
name|'test_walkObeysDescendWithCyclicalSymlinks'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that, after making a path with cyclical symlinks, when the\n        supplied C{descend} predicate returns C{False}, the target is not\n        traversed, as if it was a simple symlink.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'createLinks'
op|'('
op|')'
newline|'\n'
comment|'# we create cyclical symlinks'
nl|'\n'
name|'self'
op|'.'
name|'symlink'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"sub1"'
op|')'
op|'.'
name|'path'
op|','
nl|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"sub1"'
op|')'
op|'.'
name|'child'
op|'('
string|'"sub1.loopylink"'
op|')'
op|'.'
name|'path'
op|')'
newline|'\n'
DECL|function|noSymLinks
name|'def'
name|'noSymLinks'
op|'('
name|'path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'not'
name|'path'
op|'.'
name|'islink'
op|'('
op|')'
newline|'\n'
DECL|function|iterateOverPath
dedent|''
name|'def'
name|'iterateOverPath'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'['
name|'foo'
op|'.'
name|'path'
name|'for'
name|'foo'
name|'in'
name|'self'
op|'.'
name|'path'
op|'.'
name|'walk'
op|'('
name|'descend'
op|'='
name|'noSymLinks'
op|')'
op|']'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'iterateOverPath'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_walkObeysDescend
dedent|''
name|'def'
name|'test_walkObeysDescend'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that when the supplied C{descend} predicate returns C{False},\n        the target is not traversed.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'createLinks'
op|'('
op|')'
newline|'\n'
DECL|function|noSymLinks
name|'def'
name|'noSymLinks'
op|'('
name|'path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'not'
name|'path'
op|'.'
name|'islink'
op|'('
op|')'
newline|'\n'
dedent|''
name|'x'
op|'='
op|'['
name|'foo'
op|'.'
name|'path'
name|'for'
name|'foo'
name|'in'
name|'self'
op|'.'
name|'path'
op|'.'
name|'walk'
op|'('
name|'descend'
op|'='
name|'noSymLinks'
op|')'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'set'
op|'('
name|'x'
op|')'
op|','
name|'set'
op|'('
name|'self'
op|'.'
name|'all'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getAndSet
dedent|''
name|'def'
name|'test_getAndSet'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'content'
op|'='
string|"'newcontent'"
newline|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'new'"
op|')'
op|'.'
name|'setContent'
op|'('
name|'content'
op|')'
newline|'\n'
name|'newcontent'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'new'"
op|')'
op|'.'
name|'getContent'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'content'
op|','
name|'newcontent'
op|')'
newline|'\n'
name|'content'
op|'='
string|"'content'"
newline|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'new'"
op|')'
op|'.'
name|'setContent'
op|'('
name|'content'
op|','
string|"'.tmp'"
op|')'
newline|'\n'
name|'newcontent'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'new'"
op|')'
op|'.'
name|'getContent'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'content'
op|','
name|'newcontent'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_symbolicLink
dedent|''
name|'def'
name|'test_symbolicLink'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify the behavior of the C{isLink} method against links and\n        non-links. Also check that the symbolic link shares the directory\n        property with its target.\n        """'
newline|'\n'
name|'s4'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"sub4"'
op|')'
newline|'\n'
name|'s3'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"sub3"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'symlink'
op|'('
name|'s3'
op|'.'
name|'path'
op|','
name|'s4'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'s4'
op|'.'
name|'islink'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'s3'
op|'.'
name|'islink'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'s4'
op|'.'
name|'isdir'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'s3'
op|'.'
name|'isdir'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_linkTo
dedent|''
name|'def'
name|'test_linkTo'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that symlink creates a valid symlink that is both a link and a\n        file if its target is a file, or a directory if its target is a\n        directory.\n        """'
newline|'\n'
name|'targetLinks'
op|'='
op|'['
nl|'\n'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"sub2"'
op|')'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"sub2.link"'
op|')'
op|')'
op|','
nl|'\n'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"sub2"'
op|')'
op|'.'
name|'child'
op|'('
string|'"file3.ext1"'
op|')'
op|','
nl|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"file3.ext1.link"'
op|')'
op|')'
nl|'\n'
op|']'
newline|'\n'
name|'for'
name|'target'
op|','
name|'link'
name|'in'
name|'targetLinks'
op|':'
newline|'\n'
indent|'            '
name|'target'
op|'.'
name|'linkTo'
op|'('
name|'link'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'link'
op|'.'
name|'islink'
op|'('
op|')'
op|','
string|'"This is a link"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'target'
op|'.'
name|'isdir'
op|'('
op|')'
op|','
name|'link'
op|'.'
name|'isdir'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'target'
op|'.'
name|'isfile'
op|'('
op|')'
op|','
name|'link'
op|'.'
name|'isfile'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_linkToErrors
dedent|''
dedent|''
name|'def'
name|'test_linkToErrors'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify C{linkTo} fails in the following case:\n            - the target is in a directory that doesn\'t exist\n            - the target already exists\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'OSError'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"file1"'
op|')'
op|'.'
name|'linkTo'
op|','
nl|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'nosub'"
op|')'
op|'.'
name|'child'
op|'('
string|"'file1'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'OSError'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"file1"'
op|')'
op|'.'
name|'linkTo'
op|','
nl|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'sub1'"
op|')'
op|'.'
name|'child'
op|'('
string|"'file2'"
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'getattr'
op|'('
name|'os'
op|','
string|'"symlink"'
op|','
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'skipMsg'
op|'='
string|'"Your platform does not support symbolic links."'
newline|'\n'
name|'test_symbolicLink'
op|'.'
name|'skip'
op|'='
name|'skipMsg'
newline|'\n'
name|'test_linkTo'
op|'.'
name|'skip'
op|'='
name|'skipMsg'
newline|'\n'
name|'test_linkToErrors'
op|'.'
name|'skip'
op|'='
name|'skipMsg'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testMultiExt
dedent|''
name|'def'
name|'testMultiExt'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'f3'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'sub3'"
op|')'
op|'.'
name|'child'
op|'('
string|"'file3'"
op|')'
newline|'\n'
name|'exts'
op|'='
string|"'.foo'"
op|','
string|"'.bar'"
op|','
string|"'ext1'"
op|','
string|"'ext2'"
op|','
string|"'ext3'"
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'f3'
op|'.'
name|'siblingExtensionSearch'
op|'('
op|'*'
name|'exts'
op|')'
op|')'
newline|'\n'
name|'f3e'
op|'='
name|'f3'
op|'.'
name|'siblingExtension'
op|'('
string|'".foo"'
op|')'
newline|'\n'
name|'f3e'
op|'.'
name|'touch'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'not'
name|'f3'
op|'.'
name|'siblingExtensionSearch'
op|'('
op|'*'
name|'exts'
op|')'
op|'.'
name|'exists'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'not'
name|'f3'
op|'.'
name|'siblingExtensionSearch'
op|'('
string|"'*'"
op|')'
op|'.'
name|'exists'
op|'('
op|')'
op|')'
newline|'\n'
name|'f3e'
op|'.'
name|'remove'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'f3'
op|'.'
name|'siblingExtensionSearch'
op|'('
op|'*'
name|'exts'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testPreauthChild
dedent|''
name|'def'
name|'testPreauthChild'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'fp'
op|'='
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'.'"
op|')'
newline|'\n'
name|'fp'
op|'.'
name|'preauthChild'
op|'('
string|"'foo/bar'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'filepath'
op|'.'
name|'InsecurePath'
op|','
name|'fp'
op|'.'
name|'child'
op|','
string|"'/foo'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|testStatCache
dedent|''
name|'def'
name|'testStatCache'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'p'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'stattest'"
op|')'
newline|'\n'
name|'p'
op|'.'
name|'touch'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'p'
op|'.'
name|'getsize'
op|'('
op|')'
op|','
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'abs'
op|'('
name|'p'
op|'.'
name|'getmtime'
op|'('
op|')'
op|'-'
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|')'
op|'//'
number|'20'
op|','
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'abs'
op|'('
name|'p'
op|'.'
name|'getctime'
op|'('
op|')'
op|'-'
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|')'
op|'//'
number|'20'
op|','
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'abs'
op|'('
name|'p'
op|'.'
name|'getatime'
op|'('
op|')'
op|'-'
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|')'
op|'//'
number|'20'
op|','
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'p'
op|'.'
name|'exists'
op|'('
op|')'
op|','
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'p'
op|'.'
name|'exists'
op|'('
op|')'
op|','
name|'True'
op|')'
newline|'\n'
comment|'# OOB removal: FilePath.remove() will automatically restat'
nl|'\n'
name|'os'
op|'.'
name|'remove'
op|'('
name|'p'
op|'.'
name|'path'
op|')'
newline|'\n'
comment|'# test caching'
nl|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'p'
op|'.'
name|'exists'
op|'('
op|')'
op|','
name|'True'
op|')'
newline|'\n'
name|'p'
op|'.'
name|'restat'
op|'('
name|'reraise'
op|'='
name|'False'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'p'
op|'.'
name|'exists'
op|'('
op|')'
op|','
name|'False'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'p'
op|'.'
name|'islink'
op|'('
op|')'
op|','
name|'False'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'p'
op|'.'
name|'isdir'
op|'('
op|')'
op|','
name|'False'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'p'
op|'.'
name|'isfile'
op|'('
op|')'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testPersist
dedent|''
name|'def'
name|'testPersist'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'newpath'
op|'='
name|'pickle'
op|'.'
name|'loads'
op|'('
name|'pickle'
op|'.'
name|'dumps'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'__class__'
op|','
name|'newpath'
op|'.'
name|'__class__'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'path'
op|','
name|'newpath'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testInsecureUNIX
dedent|''
name|'def'
name|'testInsecureUNIX'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'filepath'
op|'.'
name|'InsecurePath'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|','
string|'".."'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'filepath'
op|'.'
name|'InsecurePath'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|','
string|'"/etc"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'filepath'
op|'.'
name|'InsecurePath'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|','
string|'"../.."'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testInsecureWin32
dedent|''
name|'def'
name|'testInsecureWin32'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'filepath'
op|'.'
name|'InsecurePath'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|','
string|'r"..\\.."'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'filepath'
op|'.'
name|'InsecurePath'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|','
string|'r"C:randomfile"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'platform'
op|'.'
name|'getType'
op|'('
op|')'
op|'!='
string|"'win32'"
op|':'
newline|'\n'
indent|'        '
name|'testInsecureWin32'
op|'.'
name|'skip'
op|'='
string|'"Consider yourself lucky."'
newline|'\n'
nl|'\n'
DECL|member|testInsecureWin32Whacky
dedent|''
name|'def'
name|'testInsecureWin32Whacky'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Windows has \'special\' filenames like NUL and CON and COM1 and LPR\n        and PRN and ... god knows what else.  They can be located anywhere in\n        the filesystem.  For obvious reasons, we do not wish to normally permit\n        access to these.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'filepath'
op|'.'
name|'InsecurePath'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|','
string|'"CON"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'filepath'
op|'.'
name|'InsecurePath'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|','
string|'"C:CON"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'filepath'
op|'.'
name|'InsecurePath'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|','
string|'r"C:\\CON"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'platform'
op|'.'
name|'getType'
op|'('
op|')'
op|'!='
string|"'win32'"
op|':'
newline|'\n'
indent|'        '
name|'testInsecureWin32Whacky'
op|'.'
name|'skip'
op|'='
string|'"Consider yourself lucky."'
newline|'\n'
nl|'\n'
DECL|member|testComparison
dedent|''
name|'def'
name|'testComparison'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'a'"
op|')'
op|','
nl|'\n'
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'a'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'z'"
op|')'
op|'>'
nl|'\n'
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'a'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'z'"
op|')'
op|'>='
nl|'\n'
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'a'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'a'"
op|')'
op|'>='
nl|'\n'
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'a'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'a'"
op|')'
op|'<='
nl|'\n'
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'a'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'a'"
op|')'
op|'<'
nl|'\n'
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'z'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'a'"
op|')'
op|'<='
nl|'\n'
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'z'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'a'"
op|')'
op|'!='
nl|'\n'
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'z'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'z'"
op|')'
op|'!='
nl|'\n'
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'a'"
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'z'"
op|')'
op|'!='
nl|'\n'
name|'filepath'
op|'.'
name|'FilePath'
op|'('
string|"'z'"
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testSibling
dedent|''
name|'def'
name|'testSibling'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'p'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'sibling_start'"
op|')'
newline|'\n'
name|'ts'
op|'='
name|'p'
op|'.'
name|'sibling'
op|'('
string|"'sibling_test'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'ts'
op|'.'
name|'dirname'
op|'('
op|')'
op|','
name|'p'
op|'.'
name|'dirname'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'ts'
op|'.'
name|'basename'
op|'('
op|')'
op|','
string|"'sibling_test'"
op|')'
newline|'\n'
name|'ts'
op|'.'
name|'createDirectory'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIn'
op|'('
name|'ts'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'children'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testTemporarySibling
dedent|''
name|'def'
name|'testTemporarySibling'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'ts'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'temporarySibling'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'ts'
op|'.'
name|'dirname'
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'dirname'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertNotIn'
op|'('
name|'ts'
op|'.'
name|'basename'
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'listdir'
op|'('
op|')'
op|')'
newline|'\n'
name|'ts'
op|'.'
name|'createDirectory'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIn'
op|'('
name|'ts'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'parent'
op|'('
op|')'
op|'.'
name|'children'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testRemove
dedent|''
name|'def'
name|'testRemove'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'path'
op|'.'
name|'remove'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_removeWithSymlink
dedent|''
name|'def'
name|'test_removeWithSymlink'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        For a path which is a symbolic link, L{FilePath.remove} just deletes\n        the link, not the target.\n        """'
newline|'\n'
name|'link'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"sub1.link"'
op|')'
newline|'\n'
comment|'# setUp creates the sub1 child'
nl|'\n'
name|'self'
op|'.'
name|'symlink'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"sub1"'
op|')'
op|'.'
name|'path'
op|','
name|'link'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'link'
op|'.'
name|'remove'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'link'
op|'.'
name|'exists'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"sub1"'
op|')'
op|'.'
name|'exists'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_copyTo
dedent|''
name|'def'
name|'test_copyTo'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'assertRaises'
op|'('
op|'('
name|'OSError'
op|','
name|'IOError'
op|')'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'copyTo'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'file1'"
op|')'
op|')'
newline|'\n'
name|'oldPaths'
op|'='
name|'list'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'walk'
op|'('
op|')'
op|')'
comment|'# Record initial state'
newline|'\n'
name|'fp'
op|'='
name|'filepath'
op|'.'
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'copyTo'
op|'('
name|'fp'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'remove'
op|'('
op|')'
newline|'\n'
name|'fp'
op|'.'
name|'copyTo'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'newPaths'
op|'='
name|'list'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'walk'
op|'('
op|')'
op|')'
comment|'# Record double-copy state'
newline|'\n'
name|'newPaths'
op|'.'
name|'sort'
op|'('
op|')'
newline|'\n'
name|'oldPaths'
op|'.'
name|'sort'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'newPaths'
op|','
name|'oldPaths'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_copyToWithSymlink
dedent|''
name|'def'
name|'test_copyToWithSymlink'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that copying with followLinks=True copies symlink targets\n        instead of symlinks\n        """'
newline|'\n'
name|'self'
op|'.'
name|'symlink'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"sub1"'
op|')'
op|'.'
name|'path'
op|','
nl|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"link1"'
op|')'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'fp'
op|'='
name|'filepath'
op|'.'
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'copyTo'
op|'('
name|'fp'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'fp'
op|'.'
name|'child'
op|'('
string|'"link1"'
op|')'
op|'.'
name|'islink'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
op|'['
name|'x'
op|'.'
name|'basename'
op|'('
op|')'
name|'for'
name|'x'
name|'in'
name|'fp'
op|'.'
name|'child'
op|'('
string|'"sub1"'
op|')'
op|'.'
name|'children'
op|'('
op|')'
op|']'
op|','
nl|'\n'
op|'['
name|'x'
op|'.'
name|'basename'
op|'('
op|')'
name|'for'
name|'x'
name|'in'
name|'fp'
op|'.'
name|'child'
op|'('
string|'"link1"'
op|')'
op|'.'
name|'children'
op|'('
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_copyToWithoutSymlink
dedent|''
name|'def'
name|'test_copyToWithoutSymlink'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that copying with followLinks=False copies symlinks as symlinks\n        """'
newline|'\n'
name|'self'
op|'.'
name|'symlink'
op|'('
string|'"sub1"'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"link1"'
op|')'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'fp'
op|'='
name|'filepath'
op|'.'
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'copyTo'
op|'('
name|'fp'
op|','
name|'followLinks'
op|'='
name|'False'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'fp'
op|'.'
name|'child'
op|'('
string|'"link1"'
op|')'
op|'.'
name|'islink'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'os'
op|'.'
name|'readlink'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|'"link1"'
op|')'
op|'.'
name|'path'
op|')'
op|','
nl|'\n'
name|'os'
op|'.'
name|'readlink'
op|'('
name|'fp'
op|'.'
name|'child'
op|'('
string|'"link1"'
op|')'
op|'.'
name|'path'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_moveTo
dedent|''
name|'def'
name|'test_moveTo'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that moving an entire directory results into another directory\n        with the same content.\n        """'
newline|'\n'
name|'oldPaths'
op|'='
name|'list'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'walk'
op|'('
op|')'
op|')'
comment|'# Record initial state'
newline|'\n'
name|'fp'
op|'='
name|'filepath'
op|'.'
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'path'
op|'.'
name|'moveTo'
op|'('
name|'fp'
op|')'
newline|'\n'
name|'fp'
op|'.'
name|'moveTo'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'newPaths'
op|'='
name|'list'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'walk'
op|'('
op|')'
op|')'
comment|'# Record double-move state'
newline|'\n'
name|'newPaths'
op|'.'
name|'sort'
op|'('
op|')'
newline|'\n'
name|'oldPaths'
op|'.'
name|'sort'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'newPaths'
op|','
name|'oldPaths'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_moveToError
dedent|''
name|'def'
name|'test_moveToError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify error behavior of moveTo: it should raises one of OSError or\n        IOError if you want to move a path into one of its child. It\'s simply\n        the error raised by the underlying rename system call.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
op|'('
name|'OSError'
op|','
name|'IOError'
op|')'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'moveTo'
op|','
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'file1'"
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|setUpFaultyRename
dedent|''
name|'def'
name|'setUpFaultyRename'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Set up a C{os.rename} that will fail with L{errno.EXDEV} on first call.\n        This is used to simulate a cross-device rename failure.\n\n        @return: a list of pair (src, dest) of calls to C{os.rename}\n        @rtype: C{list} of C{tuple}\n        """'
newline|'\n'
name|'invokedWith'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|faultyRename
name|'def'
name|'faultyRename'
op|'('
name|'src'
op|','
name|'dest'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'invokedWith'
op|'.'
name|'append'
op|'('
op|'('
name|'src'
op|','
name|'dest'
op|')'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'invokedWith'
op|')'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'OSError'
op|'('
name|'errno'
op|'.'
name|'EXDEV'
op|','
string|"'Test-induced failure simulating '"
nl|'\n'
string|"'cross-device rename failure'"
op|')'
newline|'\n'
dedent|''
name|'return'
name|'originalRename'
op|'('
name|'src'
op|','
name|'dest'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'originalRename'
op|'='
name|'os'
op|'.'
name|'rename'
newline|'\n'
name|'self'
op|'.'
name|'patch'
op|'('
name|'os'
op|','
string|'"rename"'
op|','
name|'faultyRename'
op|')'
newline|'\n'
name|'return'
name|'invokedWith'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_crossMountMoveTo
dedent|''
name|'def'
name|'test_crossMountMoveTo'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{moveTo} should be able to handle C{EXDEV} error raised by\n        C{os.rename} when trying to move a file on a different mounted\n        filesystem.\n        """'
newline|'\n'
name|'invokedWith'
op|'='
name|'self'
op|'.'
name|'setUpFaultyRename'
op|'('
op|')'
newline|'\n'
comment|'# Bit of a whitebox test - force os.rename, which moveTo tries'
nl|'\n'
comment|'# before falling back to a slower method, to fail, forcing moveTo to'
nl|'\n'
comment|'# use the slower behavior.'
nl|'\n'
name|'self'
op|'.'
name|'test_moveTo'
op|'('
op|')'
newline|'\n'
comment|'# A bit of a sanity check for this whitebox test - if our rename'
nl|'\n'
comment|'# was never invoked, the test has probably fallen into disrepair!'
nl|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'invokedWith'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_crossMountMoveToWithSymlink
dedent|''
name|'def'
name|'test_crossMountMoveToWithSymlink'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        By default, when moving a symlink, it should follow the link and\n        actually copy the content of the linked node.\n        """'
newline|'\n'
name|'invokedWith'
op|'='
name|'self'
op|'.'
name|'setUpFaultyRename'
op|'('
op|')'
newline|'\n'
name|'f2'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'file2'"
op|')'
newline|'\n'
name|'f3'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'file3'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'symlink'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'file1'"
op|')'
op|'.'
name|'path'
op|','
name|'f2'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'f2'
op|'.'
name|'moveTo'
op|'('
name|'f3'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'f3'
op|'.'
name|'islink'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'f3'
op|'.'
name|'getContent'
op|'('
op|')'
op|','
string|"'file 1'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'invokedWith'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_crossMountMoveToWithoutSymlink
dedent|''
name|'def'
name|'test_crossMountMoveToWithoutSymlink'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that moveTo called with followLinks=False actually create\n        another symlink.\n        """'
newline|'\n'
name|'invokedWith'
op|'='
name|'self'
op|'.'
name|'setUpFaultyRename'
op|'('
op|')'
newline|'\n'
name|'f2'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'file2'"
op|')'
newline|'\n'
name|'f3'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'file3'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'symlink'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'file1'"
op|')'
op|'.'
name|'path'
op|','
name|'f2'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'f2'
op|'.'
name|'moveTo'
op|'('
name|'f3'
op|','
name|'followLinks'
op|'='
name|'False'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'f3'
op|'.'
name|'islink'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'f3'
op|'.'
name|'getContent'
op|'('
op|')'
op|','
string|"'file 1'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'invokedWith'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testOpen
dedent|''
name|'def'
name|'testOpen'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# Opening a file for reading when it does not already exist is an error'
nl|'\n'
indent|'        '
name|'nonexistent'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'nonexistent'"
op|')'
newline|'\n'
name|'e'
op|'='
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'IOError'
op|','
name|'nonexistent'
op|'.'
name|'open'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'e'
op|'.'
name|'errno'
op|','
name|'errno'
op|'.'
name|'ENOENT'
op|')'
newline|'\n'
nl|'\n'
comment|'# Opening a file for writing when it does not exist is okay'
nl|'\n'
name|'writer'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'writer'"
op|')'
newline|'\n'
name|'f'
op|'='
name|'writer'
op|'.'
name|'open'
op|'('
string|"'w'"
op|')'
newline|'\n'
name|'f'
op|'.'
name|'write'
op|'('
string|"'abc\\ndef'"
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Make sure those bytes ended up there - and test opening a file for'
nl|'\n'
comment|'# reading when it does exist at the same time'
nl|'\n'
name|'f'
op|'='
name|'writer'
op|'.'
name|'open'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'f'
op|'.'
name|'read'
op|'('
op|')'
op|','
string|"'abc\\ndef'"
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Re-opening that file in write mode should erase whatever was there.'
nl|'\n'
name|'f'
op|'='
name|'writer'
op|'.'
name|'open'
op|'('
string|"'w'"
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'f'
op|'='
name|'writer'
op|'.'
name|'open'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'f'
op|'.'
name|'read'
op|'('
op|')'
op|','
string|"''"
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Put some bytes in a file so we can test that appending does not'
nl|'\n'
comment|'# destroy them.'
nl|'\n'
name|'appender'
op|'='
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'appender'"
op|')'
newline|'\n'
name|'f'
op|'='
name|'appender'
op|'.'
name|'open'
op|'('
string|"'w'"
op|')'
newline|'\n'
name|'f'
op|'.'
name|'write'
op|'('
string|"'abc'"
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'f'
op|'='
name|'appender'
op|'.'
name|'open'
op|'('
string|"'a'"
op|')'
newline|'\n'
name|'f'
op|'.'
name|'write'
op|'('
string|"'def'"
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'f'
op|'='
name|'appender'
op|'.'
name|'open'
op|'('
string|"'r'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'f'
op|'.'
name|'read'
op|'('
op|')'
op|','
string|"'abcdef'"
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# read/write should let us do both without erasing those bytes'
nl|'\n'
name|'f'
op|'='
name|'appender'
op|'.'
name|'open'
op|'('
string|"'r+'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'f'
op|'.'
name|'read'
op|'('
op|')'
op|','
string|"'abcdef'"
op|')'
newline|'\n'
comment|'# ANSI C *requires* an fseek or an fgetpos between an fread and an'
nl|'\n'
comment|"# fwrite or an fwrite and a fread.  We can't reliable get Python to"
nl|'\n'
comment|'# invoke fgetpos, so we seek to a 0 byte offset from the current'
nl|'\n'
comment|'# position instead.  Also, Python sucks for making this seek'
nl|'\n'
comment|'# relative to 1 instead of a symbolic constant representing the'
nl|'\n'
comment|'# current file position.'
nl|'\n'
name|'f'
op|'.'
name|'seek'
op|'('
number|'0'
op|','
number|'1'
op|')'
newline|'\n'
comment|'# Put in some new bytes for us to test for later.'
nl|'\n'
name|'f'
op|'.'
name|'write'
op|'('
string|"'ghi'"
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Make sure those new bytes really showed up'
nl|'\n'
name|'f'
op|'='
name|'appender'
op|'.'
name|'open'
op|'('
string|"'r'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'f'
op|'.'
name|'read'
op|'('
op|')'
op|','
string|"'abcdefghi'"
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|"# write/read should let us do both, but erase anything that's there"
nl|'\n'
comment|'# already.'
nl|'\n'
name|'f'
op|'='
name|'appender'
op|'.'
name|'open'
op|'('
string|"'w+'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'f'
op|'.'
name|'read'
op|'('
op|')'
op|','
string|"''"
op|')'
newline|'\n'
name|'f'
op|'.'
name|'seek'
op|'('
number|'0'
op|','
number|'1'
op|')'
comment|"# Don't forget this!"
newline|'\n'
name|'f'
op|'.'
name|'write'
op|'('
string|"'123'"
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# super append mode should let us read and write and also position the'
nl|'\n'
comment|'# cursor at the end of the file, without erasing everything.'
nl|'\n'
name|'f'
op|'='
name|'appender'
op|'.'
name|'open'
op|'('
string|"'a+'"
op|')'
newline|'\n'
nl|'\n'
comment|'# The order of these lines may seem surprising, but it is necessary.'
nl|'\n'
comment|'# The cursor is not at the end of the file until after the first write.'
nl|'\n'
name|'f'
op|'.'
name|'write'
op|'('
string|"'456'"
op|')'
newline|'\n'
name|'f'
op|'.'
name|'seek'
op|'('
number|'0'
op|','
number|'1'
op|')'
comment|'# Asinine.'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'f'
op|'.'
name|'read'
op|'('
op|')'
op|','
string|"''"
op|')'
newline|'\n'
nl|'\n'
name|'f'
op|'.'
name|'seek'
op|'('
number|'0'
op|','
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'f'
op|'.'
name|'read'
op|'('
op|')'
op|','
string|"'123456'"
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Opening a file exclusively must fail if that file exists already.'
nl|'\n'
name|'nonexistent'
op|'.'
name|'requireCreate'
op|'('
name|'True'
op|')'
newline|'\n'
name|'nonexistent'
op|'.'
name|'open'
op|'('
string|"'w'"
op|')'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'existent'
op|'='
name|'nonexistent'
newline|'\n'
name|'del'
name|'nonexistent'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
op|'('
name|'OSError'
op|','
name|'IOError'
op|')'
op|','
name|'existent'
op|'.'
name|'open'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_existsCache
dedent|''
name|'def'
name|'test_existsCache'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that C{filepath.FilePath.exists} correctly restat the object if\n        an operation has occurred in the mean time.\n        """'
newline|'\n'
name|'fp'
op|'='
name|'filepath'
op|'.'
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'fp'
op|'.'
name|'exists'
op|'('
op|')'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
name|'fp'
op|'.'
name|'makedirs'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'fp'
op|'.'
name|'exists'
op|'('
op|')'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'urlpath'
newline|'\n'
nl|'\n'
DECL|class|URLPathTestCase
name|'class'
name|'URLPathTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|setUp
indent|'    '
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'path'
op|'='
name|'urlpath'
op|'.'
name|'URLPath'
op|'.'
name|'fromString'
op|'('
string|'"http://example.com/foo/bar?yes=no&no=yes#footer"'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testStringConversion
dedent|''
name|'def'
name|'testStringConversion'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'str'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
op|','
string|'"http://example.com/foo/bar?yes=no&no=yes#footer"'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testChildString
dedent|''
name|'def'
name|'testChildString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'str'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'hello'"
op|')'
op|')'
op|','
string|'"http://example.com/foo/bar/hello"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'str'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'hello'"
op|')'
op|'.'
name|'child'
op|'('
string|"''"
op|')'
op|')'
op|','
string|'"http://example.com/foo/bar/hello/"'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testSiblingString
dedent|''
name|'def'
name|'testSiblingString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'str'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'sibling'
op|'('
string|"'baz'"
op|')'
op|')'
op|','
string|"'http://example.com/foo/baz'"
op|')'
newline|'\n'
nl|'\n'
comment|'# The sibling of http://example.com/foo/bar/'
nl|'\n'
comment|'#     is http://example.comf/foo/bar/baz'
nl|'\n'
comment|'# because really we are constructing a sibling of'
nl|'\n'
comment|'# http://example.com/foo/bar/index.html'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'str'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"''"
op|')'
op|'.'
name|'sibling'
op|'('
string|"'baz'"
op|')'
op|')'
op|','
string|"'http://example.com/foo/bar/baz'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|testParentString
dedent|''
name|'def'
name|'testParentString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|"# parent should be equivalent to '..'"
nl|'\n'
comment|"# 'foo' is the current directory, '/' is the parent directory"
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'str'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'parent'
op|'('
op|')'
op|')'
op|','
string|"'http://example.com/'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'str'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"''"
op|')'
op|'.'
name|'parent'
op|'('
op|')'
op|')'
op|','
string|"'http://example.com/foo/'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'str'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"'baz'"
op|')'
op|'.'
name|'parent'
op|'('
op|')'
op|')'
op|','
string|"'http://example.com/foo/'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'str'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'parent'
op|'('
op|')'
op|'.'
name|'parent'
op|'('
op|')'
op|'.'
name|'parent'
op|'('
op|')'
op|'.'
name|'parent'
op|'('
op|')'
op|'.'
name|'parent'
op|'('
op|')'
op|')'
op|','
string|"'http://example.com/'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|testHereString
dedent|''
name|'def'
name|'testHereString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|"# here should be equivalent to '.'"
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'str'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'here'
op|'('
op|')'
op|')'
op|','
string|"'http://example.com/foo/'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'str'
op|'('
name|'self'
op|'.'
name|'path'
op|'.'
name|'child'
op|'('
string|"''"
op|')'
op|'.'
name|'here'
op|'('
op|')'
op|')'
op|','
string|"'http://example.com/foo/bar/'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
