begin_unit
comment|'# Copyright (c) 2001-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTest cases for L{jelly} object serialization.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'datetime'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'import'
name|'decimal'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
DECL|variable|decimal
indent|'    '
name|'decimal'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'from'
name|'twisted'
op|'.'
name|'spread'
name|'import'
name|'jelly'
op|','
name|'pb'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'compat'
name|'import'
name|'set'
op|','
name|'frozenset'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestNode
name|'class'
name|'TestNode'
op|'('
name|'object'
op|','
name|'jelly'
op|'.'
name|'Jellyable'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    An object to test jellyfying of new style class instances.\n    """'
newline|'\n'
DECL|variable|classAttr
name|'classAttr'
op|'='
number|'4'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'parent'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'parent'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'id'
op|'='
name|'parent'
op|'.'
name|'id'
op|'+'
number|'1'
newline|'\n'
name|'parent'
op|'.'
name|'children'
op|'.'
name|'append'
op|'('
name|'self'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'id'
op|'='
number|'1'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'parent'
op|'='
name|'parent'
newline|'\n'
name|'self'
op|'.'
name|'children'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|A
dedent|''
dedent|''
name|'class'
name|'A'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Dummy class.\n    """'
newline|'\n'
nl|'\n'
DECL|member|amethod
name|'def'
name|'amethod'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Method tp be used in serialization tests.\n        """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|afunc
dedent|''
dedent|''
name|'def'
name|'afunc'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A dummy function to test function serialization.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|B
dedent|''
name|'class'
name|'B'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Dummy class.\n    """'
newline|'\n'
nl|'\n'
DECL|member|bmethod
name|'def'
name|'bmethod'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Method to be used in serialization tests.\n        """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|C
dedent|''
dedent|''
name|'class'
name|'C'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Dummy class.\n    """'
newline|'\n'
nl|'\n'
DECL|member|cmethod
name|'def'
name|'cmethod'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Method to be used in serialization tests.\n        """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|D
dedent|''
dedent|''
name|'class'
name|'D'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Dummy new-style class.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|SimpleJellyTest
dedent|''
name|'class'
name|'SimpleJellyTest'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'x'
op|','
name|'y'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'x'
op|'='
name|'x'
newline|'\n'
name|'self'
op|'.'
name|'y'
op|'='
name|'y'
newline|'\n'
nl|'\n'
DECL|member|isTheSameAs
dedent|''
name|'def'
name|'isTheSameAs'
op|'('
name|'self'
op|','
name|'other'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'__dict__'
op|'=='
name|'other'
op|'.'
name|'__dict__'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|JellyTestCase
dedent|''
dedent|''
name|'class'
name|'JellyTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Testcases for L{jelly} module serialization.\n\n    @cvar decimalData: serialized version of decimal data, to be used in tests.\n    @type decimalData: C{list}\n    """'
newline|'\n'
nl|'\n'
DECL|member|_testSecurity
name|'def'
name|'_testSecurity'
op|'('
name|'self'
op|','
name|'inputList'
op|','
name|'atom'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Helper test method to test security options for a type.\n\n        @param inputList: a sample input for the type.\n        @param inputList: C{list}\n\n        @param atom: atom identifier for the type.\n        @type atom: C{str}\n        """'
newline|'\n'
name|'c'
op|'='
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'inputList'
op|')'
newline|'\n'
name|'taster'
op|'='
name|'jelly'
op|'.'
name|'SecurityOptions'
op|'('
op|')'
newline|'\n'
name|'taster'
op|'.'
name|'allowBasicTypes'
op|'('
op|')'
newline|'\n'
comment|'# By default, it should succeed'
nl|'\n'
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'c'
op|','
name|'taster'
op|')'
newline|'\n'
name|'taster'
op|'.'
name|'allowedTypes'
op|'.'
name|'pop'
op|'('
name|'atom'
op|')'
newline|'\n'
comment|'# But it should raise an exception when disallowed'
nl|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'jelly'
op|'.'
name|'InsecureJelly'
op|','
name|'jelly'
op|'.'
name|'unjelly'
op|','
name|'c'
op|','
name|'taster'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_methodSelfIdentity
dedent|''
name|'def'
name|'test_methodSelfIdentity'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'a'
op|'='
name|'A'
op|'('
op|')'
newline|'\n'
name|'b'
op|'='
name|'B'
op|'('
op|')'
newline|'\n'
name|'a'
op|'.'
name|'bmethod'
op|'='
name|'b'
op|'.'
name|'bmethod'
newline|'\n'
name|'b'
op|'.'
name|'a'
op|'='
name|'a'
newline|'\n'
name|'im_'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'b'
op|')'
op|')'
op|'.'
name|'a'
op|'.'
name|'bmethod'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'im_'
op|'.'
name|'im_class'
op|','
name|'im_'
op|'.'
name|'im_self'
op|'.'
name|'__class__'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_methodsNotSelfIdentity
dedent|''
name|'def'
name|'test_methodsNotSelfIdentity'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a class change after an instance has been created, L{jelly.unjelly}\n        shoud raise a C{TypeError} when trying to unjelly the instance.\n        """'
newline|'\n'
name|'a'
op|'='
name|'A'
op|'('
op|')'
newline|'\n'
name|'b'
op|'='
name|'B'
op|'('
op|')'
newline|'\n'
name|'c'
op|'='
name|'C'
op|'('
op|')'
newline|'\n'
name|'a'
op|'.'
name|'bmethod'
op|'='
name|'c'
op|'.'
name|'cmethod'
newline|'\n'
name|'b'
op|'.'
name|'a'
op|'='
name|'a'
newline|'\n'
name|'savecmethod'
op|'='
name|'C'
op|'.'
name|'cmethod'
newline|'\n'
name|'del'
name|'C'
op|'.'
name|'cmethod'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'TypeError'
op|','
name|'jelly'
op|'.'
name|'unjelly'
op|','
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'b'
op|')'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'C'
op|'.'
name|'cmethod'
op|'='
name|'savecmethod'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_newStyle
dedent|''
dedent|''
name|'def'
name|'test_newStyle'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'n'
op|'='
name|'D'
op|'('
op|')'
newline|'\n'
name|'n'
op|'.'
name|'x'
op|'='
number|'1'
newline|'\n'
name|'n2'
op|'='
name|'D'
op|'('
op|')'
newline|'\n'
name|'n'
op|'.'
name|'n2'
op|'='
name|'n2'
newline|'\n'
name|'n'
op|'.'
name|'n3'
op|'='
name|'n2'
newline|'\n'
name|'c'
op|'='
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'n'
op|')'
newline|'\n'
name|'m'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'c'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'m'
op|','
name|'D'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'m'
op|'.'
name|'n2'
op|','
name|'m'
op|'.'
name|'n3'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_typeOldStyle
dedent|''
name|'def'
name|'test_typeOldStyle'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that an old style class type can be jellied and unjellied\n        to the original type.\n        """'
newline|'\n'
name|'t'
op|'='
op|'['
name|'C'
op|']'
newline|'\n'
name|'r'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'t'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'t'
op|','
name|'r'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_typeNewStyle
dedent|''
name|'def'
name|'test_typeNewStyle'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that a new style class type can be jellied and unjellied\n        to the original type.\n        """'
newline|'\n'
name|'t'
op|'='
op|'['
name|'D'
op|']'
newline|'\n'
name|'r'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'t'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'t'
op|','
name|'r'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_typeBuiltin
dedent|''
name|'def'
name|'test_typeBuiltin'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that a builtin type can be jellied and unjellied to the original\n        type.\n        """'
newline|'\n'
name|'t'
op|'='
op|'['
name|'str'
op|']'
newline|'\n'
name|'r'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'t'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'t'
op|','
name|'r'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_dateTime
dedent|''
name|'def'
name|'test_dateTime'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'dtn'
op|'='
name|'datetime'
op|'.'
name|'datetime'
op|'.'
name|'now'
op|'('
op|')'
newline|'\n'
name|'dtd'
op|'='
name|'datetime'
op|'.'
name|'datetime'
op|'.'
name|'now'
op|'('
op|')'
op|'-'
name|'dtn'
newline|'\n'
name|'input'
op|'='
op|'['
name|'dtn'
op|','
name|'dtd'
op|']'
newline|'\n'
name|'c'
op|'='
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'input'
op|')'
newline|'\n'
name|'output'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'c'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'input'
op|','
name|'output'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertNotIdentical'
op|'('
name|'input'
op|','
name|'output'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_decimal
dedent|''
name|'def'
name|'test_decimal'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Jellying L{decimal.Decimal} instances and then unjellying the result\n        should produce objects which represent the values of the original\n        inputs.\n        """'
newline|'\n'
name|'inputList'
op|'='
op|'['
name|'decimal'
op|'.'
name|'Decimal'
op|'('
string|"'9.95'"
op|')'
op|','
nl|'\n'
name|'decimal'
op|'.'
name|'Decimal'
op|'('
number|'0'
op|')'
op|','
nl|'\n'
name|'decimal'
op|'.'
name|'Decimal'
op|'('
number|'123456'
op|')'
op|','
nl|'\n'
name|'decimal'
op|'.'
name|'Decimal'
op|'('
string|"'-78.901'"
op|')'
op|']'
newline|'\n'
name|'c'
op|'='
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'inputList'
op|')'
newline|'\n'
name|'output'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'c'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'inputList'
op|','
name|'output'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertNotIdentical'
op|'('
name|'inputList'
op|','
name|'output'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|decimalData
dedent|''
name|'decimalData'
op|'='
op|'['
string|"'list'"
op|','
op|'['
string|"'decimal'"
op|','
number|'995'
op|','
op|'-'
number|'2'
op|']'
op|','
op|'['
string|"'decimal'"
op|','
number|'0'
op|','
number|'0'
op|']'
op|','
nl|'\n'
op|'['
string|"'decimal'"
op|','
number|'123456'
op|','
number|'0'
op|']'
op|','
op|'['
string|"'decimal'"
op|','
op|'-'
number|'78901'
op|','
op|'-'
number|'3'
op|']'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_decimalUnjelly
name|'def'
name|'test_decimalUnjelly'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Unjellying the s-expressions produced by jelly for L{decimal.Decimal}\n        instances should result in L{decimal.Decimal} instances with the values\n        represented by the s-expressions.\n\n        This test also verifies that C{self.decimalData} contains valid jellied\n        data.  This is important since L{test_decimalMissing} re-uses\n        C{self.decimalData} and is expected to be unable to produce\n        L{decimal.Decimal} instances even though the s-expression correctly\n        represents a list of them.\n        """'
newline|'\n'
name|'expected'
op|'='
op|'['
name|'decimal'
op|'.'
name|'Decimal'
op|'('
string|"'9.95'"
op|')'
op|','
nl|'\n'
name|'decimal'
op|'.'
name|'Decimal'
op|'('
number|'0'
op|')'
op|','
nl|'\n'
name|'decimal'
op|'.'
name|'Decimal'
op|'('
number|'123456'
op|')'
op|','
nl|'\n'
name|'decimal'
op|'.'
name|'Decimal'
op|'('
string|"'-78.901'"
op|')'
op|']'
newline|'\n'
name|'output'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'self'
op|'.'
name|'decimalData'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'output'
op|','
name|'expected'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_decimalMissing
dedent|''
name|'def'
name|'test_decimalMissing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If decimal is unavailable on the unjelly side, L{jelly.unjelly} should\n        gracefully return L{jelly.Unpersistable} objects.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'patch'
op|'('
name|'jelly'
op|','
string|"'decimal'"
op|','
name|'None'
op|')'
newline|'\n'
name|'output'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'self'
op|'.'
name|'decimalData'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'output'
op|')'
op|','
number|'4'
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
number|'4'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'output'
op|'['
name|'i'
op|']'
op|','
name|'jelly'
op|'.'
name|'Unpersistable'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'output'
op|'['
number|'0'
op|']'
op|'.'
name|'reason'
op|','
nl|'\n'
string|'"Could not unpersist decimal: 9.95"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'output'
op|'['
number|'1'
op|']'
op|'.'
name|'reason'
op|','
nl|'\n'
string|'"Could not unpersist decimal: 0"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'output'
op|'['
number|'2'
op|']'
op|'.'
name|'reason'
op|','
nl|'\n'
string|'"Could not unpersist decimal: 123456"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'output'
op|'['
number|'3'
op|']'
op|'.'
name|'reason'
op|','
nl|'\n'
string|'"Could not unpersist decimal: -78.901"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_decimalSecurity
dedent|''
name|'def'
name|'test_decimalSecurity'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        By default, C{decimal} objects should be allowed by\n        L{jelly.SecurityOptions}. If not allowed, L{jelly.unjelly} should raise\n        L{jelly.InsecureJelly} when trying to unjelly it.\n        """'
newline|'\n'
name|'inputList'
op|'='
op|'['
name|'decimal'
op|'.'
name|'Decimal'
op|'('
string|"'9.95'"
op|')'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_testSecurity'
op|'('
name|'inputList'
op|','
string|'"decimal"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'decimal'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'skipReason'
op|'='
string|'"decimal not available"'
newline|'\n'
name|'test_decimal'
op|'.'
name|'skip'
op|'='
name|'skipReason'
newline|'\n'
name|'test_decimalUnjelly'
op|'.'
name|'skip'
op|'='
name|'skipReason'
newline|'\n'
name|'test_decimalSecurity'
op|'.'
name|'skip'
op|'='
name|'skipReason'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_set
dedent|''
name|'def'
name|'test_set'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Jellying C{set} instances and then unjellying the result\n        should produce objects which represent the values of the original\n        inputs.\n        """'
newline|'\n'
name|'inputList'
op|'='
op|'['
name|'set'
op|'('
op|'['
number|'1'
op|','
number|'2'
op|','
number|'3'
op|']'
op|')'
op|']'
newline|'\n'
name|'output'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'inputList'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'inputList'
op|','
name|'output'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertNotIdentical'
op|'('
name|'inputList'
op|','
name|'output'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_frozenset
dedent|''
name|'def'
name|'test_frozenset'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Jellying C{frozenset} instances and then unjellying the result\n        should produce objects which represent the values of the original\n        inputs.\n        """'
newline|'\n'
name|'inputList'
op|'='
op|'['
name|'frozenset'
op|'('
op|'['
number|'1'
op|','
number|'2'
op|','
number|'3'
op|']'
op|')'
op|']'
newline|'\n'
name|'output'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'inputList'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'inputList'
op|','
name|'output'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertNotIdentical'
op|'('
name|'inputList'
op|','
name|'output'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_setSecurity
dedent|''
name|'def'
name|'test_setSecurity'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        By default, C{set} objects should be allowed by\n        L{jelly.SecurityOptions}. If not allowed, L{jelly.unjelly} should raise\n        L{jelly.InsecureJelly} when trying to unjelly it.\n        """'
newline|'\n'
name|'inputList'
op|'='
op|'['
name|'set'
op|'('
op|'['
number|'1'
op|','
number|'2'
op|','
number|'3'
op|']'
op|')'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_testSecurity'
op|'('
name|'inputList'
op|','
string|'"set"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_frozensetSecurity
dedent|''
name|'def'
name|'test_frozensetSecurity'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        By default, C{frozenset} objects should be allowed by\n        L{jelly.SecurityOptions}. If not allowed, L{jelly.unjelly} should raise\n        L{jelly.InsecureJelly} when trying to unjelly it.\n        """'
newline|'\n'
name|'inputList'
op|'='
op|'['
name|'frozenset'
op|'('
op|'['
number|'1'
op|','
number|'2'
op|','
number|'3'
op|']'
op|')'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_testSecurity'
op|'('
name|'inputList'
op|','
string|'"frozenset"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_oldSets
dedent|''
name|'def'
name|'test_oldSets'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test jellying C{sets.Set}: it should serialize to the same thing as\n        C{set} jelly, and be unjellied as C{set} if available.\n        """'
newline|'\n'
name|'inputList'
op|'='
op|'['
name|'jelly'
op|'.'
name|'_sets'
op|'.'
name|'Set'
op|'('
op|'['
number|'1'
op|','
number|'2'
op|','
number|'3'
op|']'
op|')'
op|']'
newline|'\n'
name|'inputJelly'
op|'='
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'inputList'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'inputJelly'
op|','
name|'jelly'
op|'.'
name|'jelly'
op|'('
op|'['
name|'set'
op|'('
op|'['
number|'1'
op|','
number|'2'
op|','
number|'3'
op|']'
op|')'
op|']'
op|')'
op|')'
newline|'\n'
name|'output'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'inputJelly'
op|')'
newline|'\n'
comment|'# Even if the class is different, it should coerce to the same list'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'list'
op|'('
name|'inputList'
op|'['
number|'0'
op|']'
op|')'
op|','
name|'list'
op|'('
name|'output'
op|'['
number|'0'
op|']'
op|')'
op|')'
newline|'\n'
name|'if'
name|'set'
name|'is'
name|'jelly'
op|'.'
name|'_sets'
op|'.'
name|'Set'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'output'
op|'['
number|'0'
op|']'
op|','
name|'jelly'
op|'.'
name|'_sets'
op|'.'
name|'Set'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'output'
op|'['
number|'0'
op|']'
op|','
name|'set'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_oldImmutableSets
dedent|''
dedent|''
name|'def'
name|'test_oldImmutableSets'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test jellying C{sets.ImmutableSet}: it should serialize to the same\n        thing as C{frozenset} jelly, and be unjellied as C{frozenset} if\n        available.\n        """'
newline|'\n'
name|'inputList'
op|'='
op|'['
name|'jelly'
op|'.'
name|'_sets'
op|'.'
name|'ImmutableSet'
op|'('
op|'['
number|'1'
op|','
number|'2'
op|','
number|'3'
op|']'
op|')'
op|']'
newline|'\n'
name|'inputJelly'
op|'='
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'inputList'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'inputJelly'
op|','
name|'jelly'
op|'.'
name|'jelly'
op|'('
op|'['
name|'frozenset'
op|'('
op|'['
number|'1'
op|','
number|'2'
op|','
number|'3'
op|']'
op|')'
op|']'
op|')'
op|')'
newline|'\n'
name|'output'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'inputJelly'
op|')'
newline|'\n'
comment|'# Even if the class is different, it should coerce to the same list'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'list'
op|'('
name|'inputList'
op|'['
number|'0'
op|']'
op|')'
op|','
name|'list'
op|'('
name|'output'
op|'['
number|'0'
op|']'
op|')'
op|')'
newline|'\n'
name|'if'
name|'frozenset'
name|'is'
name|'jelly'
op|'.'
name|'_sets'
op|'.'
name|'ImmutableSet'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'output'
op|'['
number|'0'
op|']'
op|','
name|'jelly'
op|'.'
name|'_sets'
op|'.'
name|'ImmutableSet'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'output'
op|'['
number|'0'
op|']'
op|','
name|'frozenset'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_simple
dedent|''
dedent|''
name|'def'
name|'test_simple'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Simplest test case.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'SimpleJellyTest'
op|'('
string|"'a'"
op|','
string|"'b'"
op|')'
op|'.'
name|'isTheSameAs'
op|'('
nl|'\n'
name|'SimpleJellyTest'
op|'('
string|"'a'"
op|','
string|"'b'"
op|')'
op|')'
op|')'
newline|'\n'
name|'a'
op|'='
name|'SimpleJellyTest'
op|'('
number|'1'
op|','
number|'2'
op|')'
newline|'\n'
name|'cereal'
op|'='
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'a'
op|')'
newline|'\n'
name|'b'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'cereal'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'a'
op|'.'
name|'isTheSameAs'
op|'('
name|'b'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_identity
dedent|''
name|'def'
name|'test_identity'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test to make sure that objects retain identity properly.\n        """'
newline|'\n'
name|'x'
op|'='
op|'['
op|']'
newline|'\n'
name|'y'
op|'='
op|'('
name|'x'
op|')'
newline|'\n'
name|'x'
op|'.'
name|'append'
op|'('
name|'y'
op|')'
newline|'\n'
name|'x'
op|'.'
name|'append'
op|'('
name|'y'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'x'
op|'['
number|'0'
op|']'
op|','
name|'x'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'x'
op|'['
number|'0'
op|']'
op|'['
number|'0'
op|']'
op|','
name|'x'
op|')'
newline|'\n'
name|'s'
op|'='
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'x'
op|')'
newline|'\n'
name|'z'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'s'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'z'
op|'['
number|'0'
op|']'
op|','
name|'z'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'z'
op|'['
number|'0'
op|']'
op|'['
number|'0'
op|']'
op|','
name|'z'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_unicode
dedent|''
name|'def'
name|'test_unicode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'x'
op|'='
name|'unicode'
op|'('
string|"'blah'"
op|')'
newline|'\n'
name|'y'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'x'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'x'
op|','
name|'y'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'type'
op|'('
name|'x'
op|')'
op|','
name|'type'
op|'('
name|'y'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_stressReferences
dedent|''
name|'def'
name|'test_stressReferences'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'reref'
op|'='
op|'['
op|']'
newline|'\n'
name|'toplevelTuple'
op|'='
op|'('
op|'{'
string|"'list'"
op|':'
name|'reref'
op|'}'
op|','
name|'reref'
op|')'
newline|'\n'
name|'reref'
op|'.'
name|'append'
op|'('
name|'toplevelTuple'
op|')'
newline|'\n'
name|'s'
op|'='
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'toplevelTuple'
op|')'
newline|'\n'
name|'z'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'s'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'z'
op|'['
number|'0'
op|']'
op|'['
string|"'list'"
op|']'
op|','
name|'z'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'z'
op|'['
number|'0'
op|']'
op|'['
string|"'list'"
op|']'
op|'['
number|'0'
op|']'
op|','
name|'z'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_moreReferences
dedent|''
name|'def'
name|'test_moreReferences'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'a'
op|'='
op|'['
op|']'
newline|'\n'
name|'t'
op|'='
op|'('
name|'a'
op|','
op|')'
newline|'\n'
name|'a'
op|'.'
name|'append'
op|'('
op|'('
name|'t'
op|','
op|')'
op|')'
newline|'\n'
name|'s'
op|'='
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'t'
op|')'
newline|'\n'
name|'z'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'s'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'z'
op|'['
number|'0'
op|']'
op|'['
number|'0'
op|']'
op|'['
number|'0'
op|']'
op|','
name|'z'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_typeSecurity
dedent|''
name|'def'
name|'test_typeSecurity'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test for type-level security of serialization.\n        """'
newline|'\n'
name|'taster'
op|'='
name|'jelly'
op|'.'
name|'SecurityOptions'
op|'('
op|')'
newline|'\n'
name|'dct'
op|'='
name|'jelly'
op|'.'
name|'jelly'
op|'('
op|'{'
op|'}'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'jelly'
op|'.'
name|'InsecureJelly'
op|','
name|'jelly'
op|'.'
name|'unjelly'
op|','
name|'dct'
op|','
name|'taster'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_newStyleClasses
dedent|''
name|'def'
name|'test_newStyleClasses'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'j'
op|'='
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'D'
op|')'
newline|'\n'
name|'uj'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'D'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'D'
op|','
name|'uj'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_lotsaTypes
dedent|''
name|'def'
name|'test_lotsaTypes'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test for all types currently supported in jelly\n        """'
newline|'\n'
name|'a'
op|'='
name|'A'
op|'('
op|')'
newline|'\n'
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'a'
op|')'
op|')'
newline|'\n'
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'a'
op|'.'
name|'amethod'
op|')'
op|')'
newline|'\n'
name|'items'
op|'='
op|'['
name|'afunc'
op|','
op|'['
number|'1'
op|','
number|'2'
op|','
number|'3'
op|']'
op|','
name|'not'
name|'bool'
op|'('
number|'1'
op|')'
op|','
name|'bool'
op|'('
number|'1'
op|')'
op|','
string|"'test'"
op|','
number|'20.3'
op|','
nl|'\n'
op|'('
number|'1'
op|','
number|'2'
op|','
number|'3'
op|')'
op|','
name|'None'
op|','
name|'A'
op|','
name|'unittest'
op|','
op|'{'
string|"'a'"
op|':'
number|'1'
op|'}'
op|','
name|'A'
op|'.'
name|'amethod'
op|']'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'items'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'i'
op|','
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'i'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_setState
dedent|''
dedent|''
name|'def'
name|'test_setState'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'global'
name|'TupleState'
newline|'\n'
DECL|class|TupleState
name|'class'
name|'TupleState'
op|':'
newline|'\n'
DECL|member|__init__
indent|'            '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'other'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'other'
op|'='
name|'other'
newline|'\n'
DECL|member|__getstate__
dedent|''
name|'def'
name|'__getstate__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
op|'('
name|'self'
op|'.'
name|'other'
op|','
op|')'
newline|'\n'
DECL|member|__setstate__
dedent|''
name|'def'
name|'__setstate__'
op|'('
name|'self'
op|','
name|'state'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'other'
op|'='
name|'state'
op|'['
number|'0'
op|']'
newline|'\n'
DECL|member|__hash__
dedent|''
name|'def'
name|'__hash__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'hash'
op|'('
name|'self'
op|'.'
name|'other'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'a'
op|'='
name|'A'
op|'('
op|')'
newline|'\n'
name|'t1'
op|'='
name|'TupleState'
op|'('
name|'a'
op|')'
newline|'\n'
name|'t2'
op|'='
name|'TupleState'
op|'('
name|'a'
op|')'
newline|'\n'
name|'t3'
op|'='
name|'TupleState'
op|'('
op|'('
name|'t1'
op|','
name|'t2'
op|')'
op|')'
newline|'\n'
name|'d'
op|'='
op|'{'
name|'t1'
op|':'
name|'t1'
op|','
name|'t2'
op|':'
name|'t2'
op|','
name|'t3'
op|':'
name|'t3'
op|','
string|'"t3"'
op|':'
name|'t3'
op|'}'
newline|'\n'
name|'t3prime'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'d'
op|')'
op|')'
op|'['
string|'"t3"'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'t3prime'
op|'.'
name|'other'
op|'['
number|'0'
op|']'
op|'.'
name|'other'
op|','
name|'t3prime'
op|'.'
name|'other'
op|'['
number|'1'
op|']'
op|'.'
name|'other'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_classSecurity
dedent|''
name|'def'
name|'test_classSecurity'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test for class-level security of serialization.\n        """'
newline|'\n'
name|'taster'
op|'='
name|'jelly'
op|'.'
name|'SecurityOptions'
op|'('
op|')'
newline|'\n'
name|'taster'
op|'.'
name|'allowInstancesOf'
op|'('
name|'A'
op|','
name|'B'
op|')'
newline|'\n'
name|'a'
op|'='
name|'A'
op|'('
op|')'
newline|'\n'
name|'b'
op|'='
name|'B'
op|'('
op|')'
newline|'\n'
name|'c'
op|'='
name|'C'
op|'('
op|')'
newline|'\n'
comment|'# add a little complexity to the data'
nl|'\n'
name|'a'
op|'.'
name|'b'
op|'='
name|'b'
newline|'\n'
name|'a'
op|'.'
name|'c'
op|'='
name|'c'
newline|'\n'
comment|'# and a backreference'
nl|'\n'
name|'a'
op|'.'
name|'x'
op|'='
name|'b'
newline|'\n'
name|'b'
op|'.'
name|'c'
op|'='
name|'c'
newline|'\n'
comment|'# first, a friendly insecure serialization'
nl|'\n'
name|'friendly'
op|'='
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'a'
op|','
name|'taster'
op|')'
newline|'\n'
name|'x'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'friendly'
op|','
name|'taster'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'x'
op|'.'
name|'c'
op|','
name|'jelly'
op|'.'
name|'Unpersistable'
op|')'
newline|'\n'
comment|'# now, a malicious one'
nl|'\n'
name|'mean'
op|'='
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'a'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'jelly'
op|'.'
name|'InsecureJelly'
op|','
name|'jelly'
op|'.'
name|'unjelly'
op|','
name|'mean'
op|','
name|'taster'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'x'
op|'.'
name|'x'
op|','
name|'x'
op|'.'
name|'b'
op|','
string|'"Identity mismatch"'
op|')'
newline|'\n'
comment|'# test class serialization'
nl|'\n'
name|'friendly'
op|'='
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'A'
op|','
name|'taster'
op|')'
newline|'\n'
name|'x'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'friendly'
op|','
name|'taster'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'x'
op|','
name|'A'
op|','
string|'"A came back: %s"'
op|'%'
name|'x'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_unjellyable
dedent|''
name|'def'
name|'test_unjellyable'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that if Unjellyable is used to deserialize a jellied object,\n        state comes out right.\n        """'
newline|'\n'
DECL|class|JellyableTestClass
name|'class'
name|'JellyableTestClass'
op|'('
name|'jelly'
op|'.'
name|'Jellyable'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'jelly'
op|'.'
name|'setUnjellyableForClass'
op|'('
name|'JellyableTestClass'
op|','
name|'jelly'
op|'.'
name|'Unjellyable'
op|')'
newline|'\n'
name|'input'
op|'='
name|'JellyableTestClass'
op|'('
op|')'
newline|'\n'
name|'input'
op|'.'
name|'attribute'
op|'='
string|"'value'"
newline|'\n'
name|'output'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'input'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'output'
op|'.'
name|'attribute'
op|','
string|"'value'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'output'
op|','
name|'jelly'
op|'.'
name|'Unjellyable'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_persistentStorage
dedent|''
name|'def'
name|'test_persistentStorage'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'perst'
op|'='
op|'['
op|'{'
op|'}'
op|','
number|'1'
op|']'
newline|'\n'
DECL|function|persistentStore
name|'def'
name|'persistentStore'
op|'('
name|'obj'
op|','
name|'jel'
op|','
name|'perst'
op|'='
name|'perst'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'perst'
op|'['
number|'1'
op|']'
op|'='
name|'perst'
op|'['
number|'1'
op|']'
op|'+'
number|'1'
newline|'\n'
name|'perst'
op|'['
number|'0'
op|']'
op|'['
name|'perst'
op|'['
number|'1'
op|']'
op|']'
op|'='
name|'obj'
newline|'\n'
name|'return'
name|'str'
op|'('
name|'perst'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|function|persistentLoad
dedent|''
name|'def'
name|'persistentLoad'
op|'('
name|'pidstr'
op|','
name|'unj'
op|','
name|'perst'
op|'='
name|'perst'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pid'
op|'='
name|'int'
op|'('
name|'pidstr'
op|')'
newline|'\n'
name|'return'
name|'perst'
op|'['
number|'0'
op|']'
op|'['
name|'pid'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'a'
op|'='
name|'SimpleJellyTest'
op|'('
number|'1'
op|','
number|'2'
op|')'
newline|'\n'
name|'b'
op|'='
name|'SimpleJellyTest'
op|'('
number|'3'
op|','
number|'4'
op|')'
newline|'\n'
name|'c'
op|'='
name|'SimpleJellyTest'
op|'('
number|'5'
op|','
number|'6'
op|')'
newline|'\n'
nl|'\n'
name|'a'
op|'.'
name|'b'
op|'='
name|'b'
newline|'\n'
name|'a'
op|'.'
name|'c'
op|'='
name|'c'
newline|'\n'
name|'c'
op|'.'
name|'b'
op|'='
name|'b'
newline|'\n'
nl|'\n'
name|'jel'
op|'='
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'a'
op|','
name|'persistentStore'
op|'='
name|'persistentStore'
op|')'
newline|'\n'
name|'x'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'jel'
op|','
name|'persistentLoad'
op|'='
name|'persistentLoad'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'x'
op|'.'
name|'b'
op|','
name|'x'
op|'.'
name|'c'
op|'.'
name|'b'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'perst'
op|'['
number|'0'
op|']'
op|','
string|'"persistentStore was not called."'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'x'
op|'.'
name|'b'
op|','
name|'a'
op|'.'
name|'b'
op|','
string|'"Persistent storage identity failure."'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_newStyleClassesAttributes
dedent|''
name|'def'
name|'test_newStyleClassesAttributes'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'n'
op|'='
name|'TestNode'
op|'('
op|')'
newline|'\n'
name|'n1'
op|'='
name|'TestNode'
op|'('
name|'n'
op|')'
newline|'\n'
name|'n11'
op|'='
name|'TestNode'
op|'('
name|'n1'
op|')'
newline|'\n'
name|'n2'
op|'='
name|'TestNode'
op|'('
name|'n'
op|')'
newline|'\n'
comment|'# Jelly it'
nl|'\n'
name|'jel'
op|'='
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'n'
op|')'
newline|'\n'
name|'m'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'jel'
op|')'
newline|'\n'
comment|'# Check that it has been restored ok'
nl|'\n'
name|'self'
op|'.'
name|'_check_newstyle'
op|'('
name|'n'
op|','
name|'m'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_check_newstyle
dedent|''
name|'def'
name|'_check_newstyle'
op|'('
name|'self'
op|','
name|'a'
op|','
name|'b'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'a'
op|'.'
name|'id'
op|','
name|'b'
op|'.'
name|'id'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'a'
op|'.'
name|'classAttr'
op|','
number|'4'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'b'
op|'.'
name|'classAttr'
op|','
number|'4'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'len'
op|'('
name|'a'
op|'.'
name|'children'
op|')'
op|','
name|'len'
op|'('
name|'b'
op|'.'
name|'children'
op|')'
op|')'
newline|'\n'
name|'for'
name|'x'
op|','
name|'y'
name|'in'
name|'zip'
op|'('
name|'a'
op|'.'
name|'children'
op|','
name|'b'
op|'.'
name|'children'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_check_newstyle'
op|'('
name|'x'
op|','
name|'y'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ClassA
dedent|''
dedent|''
dedent|''
name|'class'
name|'ClassA'
op|'('
name|'pb'
op|'.'
name|'Copyable'
op|','
name|'pb'
op|'.'
name|'RemoteCopy'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'ref'
op|'='
name|'ClassB'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ClassB
dedent|''
dedent|''
name|'class'
name|'ClassB'
op|'('
name|'pb'
op|'.'
name|'Copyable'
op|','
name|'pb'
op|'.'
name|'RemoteCopy'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'ref'
op|'='
name|'ref'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|CircularReferenceTestCase
dedent|''
dedent|''
name|'class'
name|'CircularReferenceTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for circular references handling in the jelly/unjelly process.\n    """'
newline|'\n'
nl|'\n'
DECL|member|test_simpleCircle
name|'def'
name|'test_simpleCircle'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'jelly'
op|'.'
name|'setUnjellyableForClass'
op|'('
name|'ClassA'
op|','
name|'ClassA'
op|')'
newline|'\n'
name|'jelly'
op|'.'
name|'setUnjellyableForClass'
op|'('
name|'ClassB'
op|','
name|'ClassB'
op|')'
newline|'\n'
name|'a'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'ClassA'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'a'
op|'.'
name|'ref'
op|'.'
name|'ref'
op|','
name|'a'
op|','
nl|'\n'
string|'"Identity not preserved in circular reference"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_circleWithInvoker
dedent|''
name|'def'
name|'test_circleWithInvoker'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
DECL|class|DummyInvokerClass
indent|'        '
name|'class'
name|'DummyInvokerClass'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'dummyInvoker'
op|'='
name|'DummyInvokerClass'
op|'('
op|')'
newline|'\n'
name|'dummyInvoker'
op|'.'
name|'serializingPerspective'
op|'='
name|'None'
newline|'\n'
name|'a0'
op|'='
name|'ClassA'
op|'('
op|')'
newline|'\n'
name|'jelly'
op|'.'
name|'setUnjellyableForClass'
op|'('
name|'ClassA'
op|','
name|'ClassA'
op|')'
newline|'\n'
name|'jelly'
op|'.'
name|'setUnjellyableForClass'
op|'('
name|'ClassB'
op|','
name|'ClassB'
op|')'
newline|'\n'
name|'j'
op|'='
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'a0'
op|','
name|'invoker'
op|'='
name|'dummyInvoker'
op|')'
newline|'\n'
name|'a1'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'j'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessIdentical'
op|'('
name|'a1'
op|'.'
name|'ref'
op|'.'
name|'ref'
op|','
name|'a1'
op|','
nl|'\n'
string|'"Identity not preserved in circular reference"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_set
dedent|''
name|'def'
name|'test_set'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that a C{set} can contain a circular reference and be serialized\n        and unserialized without losing the reference.\n        """'
newline|'\n'
name|'s'
op|'='
name|'set'
op|'('
op|')'
newline|'\n'
name|'a'
op|'='
name|'SimpleJellyTest'
op|'('
name|'s'
op|','
name|'None'
op|')'
newline|'\n'
name|'s'
op|'.'
name|'add'
op|'('
name|'a'
op|')'
newline|'\n'
name|'res'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'a'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'res'
op|'.'
name|'x'
op|','
name|'set'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'list'
op|'('
name|'res'
op|'.'
name|'x'
op|')'
op|','
op|'['
name|'res'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_frozenset
dedent|''
name|'def'
name|'test_frozenset'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that a C{frozenset} can contain a circular reference and be\n        serializeserialized without losing the reference.\n        """'
newline|'\n'
name|'a'
op|'='
name|'SimpleJellyTest'
op|'('
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
name|'s'
op|'='
name|'frozenset'
op|'('
op|'['
name|'a'
op|']'
op|')'
newline|'\n'
name|'a'
op|'.'
name|'x'
op|'='
name|'s'
newline|'\n'
name|'res'
op|'='
name|'jelly'
op|'.'
name|'unjelly'
op|'('
name|'jelly'
op|'.'
name|'jelly'
op|'('
name|'a'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'res'
op|'.'
name|'x'
op|','
name|'frozenset'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'list'
op|'('
name|'res'
op|'.'
name|'x'
op|')'
op|','
op|'['
name|'res'
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
