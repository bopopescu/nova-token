begin_unit
comment|'# Copyright (c) 2005 Divmod, Inc.'
nl|'\n'
comment|'# Copyright (c) 2007 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTests for Twisted plugin system.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'sys'
op|','
name|'errno'
op|','
name|'os'
op|','
name|'time'
newline|'\n'
name|'import'
name|'compileall'
newline|'\n'
nl|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'Interface'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'filepath'
name|'import'
name|'FilePath'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'util'
name|'import'
name|'mergeFunctionMetadata'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
name|'import'
name|'plugin'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ITestPlugin
name|'class'
name|'ITestPlugin'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A plugin for use by the plugin system\'s unit tests.\n\n    Do not use this.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ITestPlugin2
dedent|''
name|'class'
name|'ITestPlugin2'
op|'('
name|'Interface'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    See L{ITestPlugin}.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|PluginTestCase
dedent|''
name|'class'
name|'PluginTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests which verify the behavior of the current, active Twisted plugins\n    directory.\n    """'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Save C{sys.path} and C{sys.modules}, and create a package for tests.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'originalPath'
op|'='
name|'sys'
op|'.'
name|'path'
op|'['
op|':'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'savedModules'
op|'='
name|'sys'
op|'.'
name|'modules'
op|'.'
name|'copy'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'root'
op|'='
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'root'
op|'.'
name|'createDirectory'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'package'
op|'='
name|'self'
op|'.'
name|'root'
op|'.'
name|'child'
op|'('
string|"'mypackage'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'package'
op|'.'
name|'createDirectory'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'package'
op|'.'
name|'child'
op|'('
string|"'__init__.py'"
op|')'
op|'.'
name|'setContent'
op|'('
string|'""'
op|')'
newline|'\n'
nl|'\n'
name|'FilePath'
op|'('
name|'__file__'
op|')'
op|'.'
name|'sibling'
op|'('
string|"'plugin_basic.py'"
nl|'\n'
op|')'
op|'.'
name|'copyTo'
op|'('
name|'self'
op|'.'
name|'package'
op|'.'
name|'child'
op|'('
string|"'testplugin.py'"
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'originalPlugin'
op|'='
string|'"testplugin"'
newline|'\n'
nl|'\n'
name|'sys'
op|'.'
name|'path'
op|'.'
name|'insert'
op|'('
number|'0'
op|','
name|'self'
op|'.'
name|'root'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'import'
name|'mypackage'
newline|'\n'
name|'self'
op|'.'
name|'module'
op|'='
name|'mypackage'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tearDown
dedent|''
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Restore C{sys.path} and C{sys.modules} to their original values.\n        """'
newline|'\n'
name|'sys'
op|'.'
name|'path'
op|'['
op|':'
op|']'
op|'='
name|'self'
op|'.'
name|'originalPath'
newline|'\n'
name|'sys'
op|'.'
name|'modules'
op|'.'
name|'clear'
op|'('
op|')'
newline|'\n'
name|'sys'
op|'.'
name|'modules'
op|'.'
name|'update'
op|'('
name|'self'
op|'.'
name|'savedModules'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_unimportPythonModule
dedent|''
name|'def'
name|'_unimportPythonModule'
op|'('
name|'self'
op|','
name|'module'
op|','
name|'deleteSource'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'modulePath'
op|'='
name|'module'
op|'.'
name|'__name__'
op|'.'
name|'split'
op|'('
string|"'.'"
op|')'
newline|'\n'
name|'packageName'
op|'='
string|"'.'"
op|'.'
name|'join'
op|'('
name|'modulePath'
op|'['
op|':'
op|'-'
number|'1'
op|']'
op|')'
newline|'\n'
name|'moduleName'
op|'='
name|'modulePath'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
nl|'\n'
name|'delattr'
op|'('
name|'sys'
op|'.'
name|'modules'
op|'['
name|'packageName'
op|']'
op|','
name|'moduleName'
op|')'
newline|'\n'
name|'del'
name|'sys'
op|'.'
name|'modules'
op|'['
name|'module'
op|'.'
name|'__name__'
op|']'
newline|'\n'
name|'for'
name|'ext'
name|'in'
op|'['
string|"'c'"
op|','
string|"'o'"
op|']'
op|'+'
op|'('
name|'deleteSource'
name|'and'
op|'['
string|"''"
op|']'
name|'or'
op|'['
op|']'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'remove'
op|'('
name|'module'
op|'.'
name|'__file__'
op|'+'
name|'ext'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|','
name|'ose'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'ose'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_clearCache
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_clearCache'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Remove the plugins B{droping.cache} file.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'package'
op|'.'
name|'child'
op|'('
string|"'dropin.cache'"
op|')'
op|'.'
name|'remove'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_withCacheness
dedent|''
name|'def'
name|'_withCacheness'
op|'('
name|'meth'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        This is a paranoid test wrapper, that calls C{meth} 2 times, clear the\n        cache, and calls it 2 other times. It\'s supposed to ensure that the\n        plugin system behaves correctly no matter what the state of the cache\n        is.\n        """'
newline|'\n'
DECL|function|wrapped
name|'def'
name|'wrapped'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'meth'
op|'('
name|'self'
op|')'
newline|'\n'
name|'meth'
op|'('
name|'self'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_clearCache'
op|'('
op|')'
newline|'\n'
name|'meth'
op|'('
name|'self'
op|')'
newline|'\n'
name|'meth'
op|'('
name|'self'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'mergeFunctionMetadata'
op|'('
name|'meth'
op|','
name|'wrapped'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_cache
dedent|''
name|'def'
name|'test_cache'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that the cache returned by L{plugin.getCache} hold the plugin\n        B{testplugin}, and that this plugin has the properties we expect:\n        provide L{TestPlugin}, has the good name and description, and can be\n        loaded successfully.\n        """'
newline|'\n'
name|'cache'
op|'='
name|'plugin'
op|'.'
name|'getCache'
op|'('
name|'self'
op|'.'
name|'module'
op|')'
newline|'\n'
nl|'\n'
name|'dropin'
op|'='
name|'cache'
op|'['
name|'self'
op|'.'
name|'originalPlugin'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'dropin'
op|'.'
name|'moduleName'
op|','
nl|'\n'
string|"'mypackage.%s'"
op|'%'
op|'('
name|'self'
op|'.'
name|'originalPlugin'
op|','
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIn'
op|'('
string|'"I\'m a test drop-in."'
op|','
name|'dropin'
op|'.'
name|'description'
op|')'
newline|'\n'
nl|'\n'
comment|'# Note, not the preferred way to get a plugin by its interface.'
nl|'\n'
name|'p1'
op|'='
op|'['
name|'p'
name|'for'
name|'p'
name|'in'
name|'dropin'
op|'.'
name|'plugins'
name|'if'
name|'ITestPlugin'
name|'in'
name|'p'
op|'.'
name|'provided'
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'p1'
op|'.'
name|'dropin'
op|','
name|'dropin'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'p1'
op|'.'
name|'name'
op|','
string|'"TestPlugin"'
op|')'
newline|'\n'
nl|'\n'
comment|'# Check the content of the description comes from the plugin module'
nl|'\n'
comment|'# docstring'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'p1'
op|'.'
name|'description'
op|'.'
name|'strip'
op|'('
op|')'
op|','
nl|'\n'
string|'"A plugin used solely for testing purposes."'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'p1'
op|'.'
name|'provided'
op|','
op|'['
name|'ITestPlugin'
op|','
name|'plugin'
op|'.'
name|'IPlugin'
op|']'
op|')'
newline|'\n'
name|'realPlugin'
op|'='
name|'p1'
op|'.'
name|'load'
op|'('
op|')'
newline|'\n'
comment|'# The plugin should match the class present in sys.modules'
nl|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
nl|'\n'
name|'realPlugin'
op|','
nl|'\n'
name|'sys'
op|'.'
name|'modules'
op|'['
string|"'mypackage.%s'"
op|'%'
op|'('
name|'self'
op|'.'
name|'originalPlugin'
op|','
op|')'
op|']'
op|'.'
name|'TestPlugin'
op|')'
newline|'\n'
nl|'\n'
comment|'# And it should also match if we import it classicly'
nl|'\n'
name|'import'
name|'mypackage'
op|'.'
name|'testplugin'
name|'as'
name|'tp'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'realPlugin'
op|','
name|'tp'
op|'.'
name|'TestPlugin'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|test_cache
dedent|''
name|'test_cache'
op|'='
name|'_withCacheness'
op|'('
name|'test_cache'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_plugins
name|'def'
name|'test_plugins'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{plugin.getPlugins} should return the list of plugins matching the\n        specified interface (here, L{ITestPlugin2}), and these plugins\n        should be instances of classes with a C{test} method, to be sure\n        L{plugin.getPlugins} load classes correctly.\n        """'
newline|'\n'
name|'plugins'
op|'='
name|'list'
op|'('
name|'plugin'
op|'.'
name|'getPlugins'
op|'('
name|'ITestPlugin2'
op|','
name|'self'
op|'.'
name|'module'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'plugins'
op|')'
op|','
number|'2'
op|')'
newline|'\n'
nl|'\n'
name|'names'
op|'='
op|'['
string|"'AnotherTestPlugin'"
op|','
string|"'ThirdTestPlugin'"
op|']'
newline|'\n'
name|'for'
name|'p'
name|'in'
name|'plugins'
op|':'
newline|'\n'
indent|'            '
name|'names'
op|'.'
name|'remove'
op|'('
name|'p'
op|'.'
name|'__name__'
op|')'
newline|'\n'
name|'p'
op|'.'
name|'test'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|variable|test_plugins
dedent|''
dedent|''
name|'test_plugins'
op|'='
name|'_withCacheness'
op|'('
name|'test_plugins'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_detectNewFiles
name|'def'
name|'test_detectNewFiles'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that L{plugin.getPlugins} is able to detect plugins added at\n        runtime.\n        """'
newline|'\n'
name|'FilePath'
op|'('
name|'__file__'
op|')'
op|'.'
name|'sibling'
op|'('
string|"'plugin_extra1.py'"
nl|'\n'
op|')'
op|'.'
name|'copyTo'
op|'('
name|'self'
op|'.'
name|'package'
op|'.'
name|'child'
op|'('
string|"'pluginextra.py'"
op|')'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# Check that the current situation is clean'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'failIfIn'
op|'('
string|"'mypackage.pluginextra'"
op|','
name|'sys'
op|'.'
name|'modules'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'hasattr'
op|'('
name|'sys'
op|'.'
name|'modules'
op|'['
string|"'mypackage'"
op|']'
op|','
string|"'pluginextra'"
op|')'
op|','
nl|'\n'
string|'"mypackage still has pluginextra module"'
op|')'
newline|'\n'
nl|'\n'
name|'plgs'
op|'='
name|'list'
op|'('
name|'plugin'
op|'.'
name|'getPlugins'
op|'('
name|'ITestPlugin'
op|','
name|'self'
op|'.'
name|'module'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# We should find 2 plugins: the one in testplugin, and the one in'
nl|'\n'
comment|'# pluginextra'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'plgs'
op|')'
op|','
number|'2'
op|')'
newline|'\n'
nl|'\n'
name|'names'
op|'='
op|'['
string|"'TestPlugin'"
op|','
string|"'FourthTestPlugin'"
op|']'
newline|'\n'
name|'for'
name|'p'
name|'in'
name|'plgs'
op|':'
newline|'\n'
indent|'                '
name|'names'
op|'.'
name|'remove'
op|'('
name|'p'
op|'.'
name|'__name__'
op|')'
newline|'\n'
name|'p'
op|'.'
name|'test1'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_unimportPythonModule'
op|'('
nl|'\n'
name|'sys'
op|'.'
name|'modules'
op|'['
string|"'mypackage.pluginextra'"
op|']'
op|','
nl|'\n'
name|'True'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|test_detectNewFiles
dedent|''
dedent|''
name|'test_detectNewFiles'
op|'='
name|'_withCacheness'
op|'('
name|'test_detectNewFiles'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_detectFilesChanged
name|'def'
name|'test_detectFilesChanged'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that if the content of a plugin change, L{plugin.getPlugins} is\n        able to detect the new plugins added.\n        """'
newline|'\n'
name|'FilePath'
op|'('
name|'__file__'
op|')'
op|'.'
name|'sibling'
op|'('
string|"'plugin_extra1.py'"
nl|'\n'
op|')'
op|'.'
name|'copyTo'
op|'('
name|'self'
op|'.'
name|'package'
op|'.'
name|'child'
op|'('
string|"'pluginextra.py'"
op|')'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'plgs'
op|'='
name|'list'
op|'('
name|'plugin'
op|'.'
name|'getPlugins'
op|'('
name|'ITestPlugin'
op|','
name|'self'
op|'.'
name|'module'
op|')'
op|')'
newline|'\n'
comment|'# Sanity check'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'plgs'
op|')'
op|','
number|'2'
op|')'
newline|'\n'
nl|'\n'
name|'FilePath'
op|'('
name|'__file__'
op|')'
op|'.'
name|'sibling'
op|'('
string|"'plugin_extra2.py'"
nl|'\n'
op|')'
op|'.'
name|'copyTo'
op|'('
name|'self'
op|'.'
name|'package'
op|'.'
name|'child'
op|'('
string|"'pluginextra.py'"
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Fake out Python.'
nl|'\n'
name|'self'
op|'.'
name|'_unimportPythonModule'
op|'('
name|'sys'
op|'.'
name|'modules'
op|'['
string|"'mypackage.pluginextra'"
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Make sure additions are noticed'
nl|'\n'
name|'plgs'
op|'='
name|'list'
op|'('
name|'plugin'
op|'.'
name|'getPlugins'
op|'('
name|'ITestPlugin'
op|','
name|'self'
op|'.'
name|'module'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'plgs'
op|')'
op|','
number|'3'
op|')'
newline|'\n'
nl|'\n'
name|'names'
op|'='
op|'['
string|"'TestPlugin'"
op|','
string|"'FourthTestPlugin'"
op|','
string|"'FifthTestPlugin'"
op|']'
newline|'\n'
name|'for'
name|'p'
name|'in'
name|'plgs'
op|':'
newline|'\n'
indent|'                '
name|'names'
op|'.'
name|'remove'
op|'('
name|'p'
op|'.'
name|'__name__'
op|')'
newline|'\n'
name|'p'
op|'.'
name|'test1'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_unimportPythonModule'
op|'('
nl|'\n'
name|'sys'
op|'.'
name|'modules'
op|'['
string|"'mypackage.pluginextra'"
op|']'
op|','
nl|'\n'
name|'True'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|test_detectFilesChanged
dedent|''
dedent|''
name|'test_detectFilesChanged'
op|'='
name|'_withCacheness'
op|'('
name|'test_detectFilesChanged'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_detectFilesRemoved
name|'def'
name|'test_detectFilesRemoved'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that when a dropin file is removed, L{plugin.getPlugins} doesn\'t\n        return it anymore.\n        """'
newline|'\n'
name|'FilePath'
op|'('
name|'__file__'
op|')'
op|'.'
name|'sibling'
op|'('
string|"'plugin_extra1.py'"
nl|'\n'
op|')'
op|'.'
name|'copyTo'
op|'('
name|'self'
op|'.'
name|'package'
op|'.'
name|'child'
op|'('
string|"'pluginextra.py'"
op|')'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# Generate a cache with pluginextra in it.'
nl|'\n'
indent|'            '
name|'list'
op|'('
name|'plugin'
op|'.'
name|'getPlugins'
op|'('
name|'ITestPlugin'
op|','
name|'self'
op|'.'
name|'module'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_unimportPythonModule'
op|'('
nl|'\n'
name|'sys'
op|'.'
name|'modules'
op|'['
string|"'mypackage.pluginextra'"
op|']'
op|','
nl|'\n'
name|'True'
op|')'
newline|'\n'
dedent|''
name|'plgs'
op|'='
name|'list'
op|'('
name|'plugin'
op|'.'
name|'getPlugins'
op|'('
name|'ITestPlugin'
op|','
name|'self'
op|'.'
name|'module'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
number|'1'
op|','
name|'len'
op|'('
name|'plgs'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|test_detectFilesRemoved
dedent|''
name|'test_detectFilesRemoved'
op|'='
name|'_withCacheness'
op|'('
name|'test_detectFilesRemoved'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_nonexistentPathEntry
name|'def'
name|'test_nonexistentPathEntry'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that getCache skips over any entries in a plugin package\'s\n        C{__path__} which do not exist.\n        """'
newline|'\n'
name|'path'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'path'
op|')'
op|')'
newline|'\n'
comment|'# Add the test directory to the plugins path'
nl|'\n'
name|'self'
op|'.'
name|'module'
op|'.'
name|'__path__'
op|'.'
name|'append'
op|'('
name|'path'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'plgs'
op|'='
name|'list'
op|'('
name|'plugin'
op|'.'
name|'getPlugins'
op|'('
name|'ITestPlugin'
op|','
name|'self'
op|'.'
name|'module'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'len'
op|'('
name|'plgs'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'module'
op|'.'
name|'__path__'
op|'.'
name|'remove'
op|'('
name|'path'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|test_nonexistentPathEntry
dedent|''
dedent|''
name|'test_nonexistentPathEntry'
op|'='
name|'_withCacheness'
op|'('
name|'test_nonexistentPathEntry'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_nonDirectoryChildEntry
name|'def'
name|'test_nonDirectoryChildEntry'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that getCache skips over any entries in a plugin package\'s\n        C{__path__} which refer to children of paths which are not directories.\n        """'
newline|'\n'
name|'path'
op|'='
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'path'
op|'.'
name|'exists'
op|'('
op|')'
op|')'
newline|'\n'
name|'path'
op|'.'
name|'touch'
op|'('
op|')'
newline|'\n'
name|'child'
op|'='
name|'path'
op|'.'
name|'child'
op|'('
string|'"test_package"'
op|')'
op|'.'
name|'path'
newline|'\n'
name|'self'
op|'.'
name|'module'
op|'.'
name|'__path__'
op|'.'
name|'append'
op|'('
name|'child'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'plgs'
op|'='
name|'list'
op|'('
name|'plugin'
op|'.'
name|'getPlugins'
op|'('
name|'ITestPlugin'
op|','
name|'self'
op|'.'
name|'module'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'len'
op|'('
name|'plgs'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'module'
op|'.'
name|'__path__'
op|'.'
name|'remove'
op|'('
name|'child'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|test_nonDirectoryChildEntry
dedent|''
dedent|''
name|'test_nonDirectoryChildEntry'
op|'='
name|'_withCacheness'
op|'('
name|'test_nonDirectoryChildEntry'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_deployedMode
name|'def'
name|'test_deployedMode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The C{dropin.cache} file may not be writable: the cache should still be\n        attainable, but an error should be logged to show that the cache\n        couldn\'t be updated.\n        """'
newline|'\n'
comment|'# Generate the cache'
nl|'\n'
name|'plugin'
op|'.'
name|'getCache'
op|'('
name|'self'
op|'.'
name|'module'
op|')'
newline|'\n'
nl|'\n'
comment|'# Add a new plugin'
nl|'\n'
name|'FilePath'
op|'('
name|'__file__'
op|')'
op|'.'
name|'sibling'
op|'('
string|"'plugin_extra1.py'"
nl|'\n'
op|')'
op|'.'
name|'copyTo'
op|'('
name|'self'
op|'.'
name|'package'
op|'.'
name|'child'
op|'('
string|"'pluginextra.py'"
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'os'
op|'.'
name|'chmod'
op|'('
name|'self'
op|'.'
name|'package'
op|'.'
name|'path'
op|','
number|'0500'
op|')'
newline|'\n'
comment|'# Change the right of dropin.cache too for windows'
nl|'\n'
name|'os'
op|'.'
name|'chmod'
op|'('
name|'self'
op|'.'
name|'package'
op|'.'
name|'child'
op|'('
string|"'dropin.cache'"
op|')'
op|'.'
name|'path'
op|','
number|'0400'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addCleanup'
op|'('
name|'os'
op|'.'
name|'chmod'
op|','
name|'self'
op|'.'
name|'package'
op|'.'
name|'path'
op|','
number|'0700'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addCleanup'
op|'('
name|'os'
op|'.'
name|'chmod'
op|','
nl|'\n'
name|'self'
op|'.'
name|'package'
op|'.'
name|'child'
op|'('
string|"'dropin.cache'"
op|')'
op|'.'
name|'path'
op|','
number|'0700'
op|')'
newline|'\n'
nl|'\n'
name|'cache'
op|'='
name|'plugin'
op|'.'
name|'getCache'
op|'('
name|'self'
op|'.'
name|'module'
op|')'
newline|'\n'
comment|'# The new plugin should be reported'
nl|'\n'
name|'self'
op|'.'
name|'assertIn'
op|'('
string|"'pluginextra'"
op|','
name|'cache'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIn'
op|'('
name|'self'
op|'.'
name|'originalPlugin'
op|','
name|'cache'
op|')'
newline|'\n'
nl|'\n'
name|'errors'
op|'='
name|'self'
op|'.'
name|'flushLoggedErrors'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'errors'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
comment|'# Windows report OSError, others IOError'
nl|'\n'
name|'errors'
op|'['
number|'0'
op|']'
op|'.'
name|'trap'
op|'('
name|'OSError'
op|','
name|'IOError'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
comment|'# This is something like the Twisted plugins file.'
nl|'\n'
dedent|''
dedent|''
name|'pluginInitFile'
op|'='
string|'"""\nfrom twisted.plugin import pluginPackagePaths\n__path__.extend(pluginPackagePaths(__name__))\n__all__ = []\n"""'
newline|'\n'
nl|'\n'
DECL|function|pluginFileContents
name|'def'
name|'pluginFileContents'
op|'('
name|'name'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'return'
op|'('
nl|'\n'
string|'"from zope.interface import classProvides\\n"'
nl|'\n'
string|'"from twisted.plugin import IPlugin\\n"'
nl|'\n'
string|'"from twisted.test.test_plugin import ITestPlugin\\n"'
nl|'\n'
string|'"\\n"'
nl|'\n'
string|'"class %s(object):\\n"'
nl|'\n'
string|'"    classProvides(IPlugin, ITestPlugin)\\n"'
op|')'
op|'%'
op|'('
name|'name'
op|','
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_createPluginDummy
dedent|''
name|'def'
name|'_createPluginDummy'
op|'('
name|'entrypath'
op|','
name|'pluginContent'
op|','
name|'real'
op|','
name|'pluginModule'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Create a plugindummy package.\n    """'
newline|'\n'
name|'entrypath'
op|'.'
name|'createDirectory'
op|'('
op|')'
newline|'\n'
name|'pkg'
op|'='
name|'entrypath'
op|'.'
name|'child'
op|'('
string|"'plugindummy'"
op|')'
newline|'\n'
name|'pkg'
op|'.'
name|'createDirectory'
op|'('
op|')'
newline|'\n'
name|'if'
name|'real'
op|':'
newline|'\n'
indent|'        '
name|'pkg'
op|'.'
name|'child'
op|'('
string|"'__init__.py'"
op|')'
op|'.'
name|'setContent'
op|'('
string|"''"
op|')'
newline|'\n'
dedent|''
name|'plugs'
op|'='
name|'pkg'
op|'.'
name|'child'
op|'('
string|"'plugins'"
op|')'
newline|'\n'
name|'plugs'
op|'.'
name|'createDirectory'
op|'('
op|')'
newline|'\n'
name|'if'
name|'real'
op|':'
newline|'\n'
indent|'        '
name|'plugs'
op|'.'
name|'child'
op|'('
string|"'__init__.py'"
op|')'
op|'.'
name|'setContent'
op|'('
name|'pluginInitFile'
op|')'
newline|'\n'
dedent|''
name|'plugs'
op|'.'
name|'child'
op|'('
name|'pluginModule'
op|'+'
string|"'.py'"
op|')'
op|'.'
name|'setContent'
op|'('
name|'pluginContent'
op|')'
newline|'\n'
name|'return'
name|'plugs'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DeveloperSetupTests
dedent|''
name|'class'
name|'DeveloperSetupTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    These tests verify things about the plugin system without actually\n    interacting with the deployed \'twisted.plugins\' package, instead creating a\n    temporary package.\n    """'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a complex environment with multiple entries on sys.path, akin to\n        a developer\'s environment who has a development (trunk) checkout of\n        Twisted, a system installed version of Twisted (for their operating\n        system\'s tools) and a project which provides Twisted plugins.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'savedPath'
op|'='
name|'sys'
op|'.'
name|'path'
op|'['
op|':'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'savedModules'
op|'='
name|'sys'
op|'.'
name|'modules'
op|'.'
name|'copy'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'fakeRoot'
op|'='
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'fakeRoot'
op|'.'
name|'createDirectory'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'systemPath'
op|'='
name|'self'
op|'.'
name|'fakeRoot'
op|'.'
name|'child'
op|'('
string|"'system_path'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'devPath'
op|'='
name|'self'
op|'.'
name|'fakeRoot'
op|'.'
name|'child'
op|'('
string|"'development_path'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'appPath'
op|'='
name|'self'
op|'.'
name|'fakeRoot'
op|'.'
name|'child'
op|'('
string|"'application_path'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'systemPackage'
op|'='
name|'_createPluginDummy'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'systemPath'
op|','
name|'pluginFileContents'
op|'('
string|"'system'"
op|')'
op|','
nl|'\n'
name|'True'
op|','
string|"'plugindummy_builtin'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'devPackage'
op|'='
name|'_createPluginDummy'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'devPath'
op|','
name|'pluginFileContents'
op|'('
string|"'dev'"
op|')'
op|','
nl|'\n'
name|'True'
op|','
string|"'plugindummy_builtin'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'appPackage'
op|'='
name|'_createPluginDummy'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'appPath'
op|','
name|'pluginFileContents'
op|'('
string|"'app'"
op|')'
op|','
nl|'\n'
name|'False'
op|','
string|"'plugindummy_app'"
op|')'
newline|'\n'
nl|'\n'
comment|"# Now we're going to do the system installation."
nl|'\n'
name|'sys'
op|'.'
name|'path'
op|'.'
name|'extend'
op|'('
op|'['
name|'x'
op|'.'
name|'path'
name|'for'
name|'x'
name|'in'
op|'['
name|'self'
op|'.'
name|'systemPath'
op|','
nl|'\n'
name|'self'
op|'.'
name|'appPath'
op|']'
op|']'
op|')'
newline|'\n'
comment|'# Run all the way through the plugins list to cause the'
nl|'\n'
comment|'# L{plugin.getPlugins} generator to write cache files for the system'
nl|'\n'
comment|'# installation.'
nl|'\n'
name|'self'
op|'.'
name|'getAllPlugins'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'sysplug'
op|'='
name|'self'
op|'.'
name|'systemPath'
op|'.'
name|'child'
op|'('
string|"'plugindummy'"
op|')'
op|'.'
name|'child'
op|'('
string|"'plugins'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'syscache'
op|'='
name|'self'
op|'.'
name|'sysplug'
op|'.'
name|'child'
op|'('
string|"'dropin.cache'"
op|')'
newline|'\n'
comment|"# Make sure there's a nice big difference in modification times so that"
nl|'\n'
comment|"# we won't re-build the system cache."
nl|'\n'
name|'now'
op|'='
name|'time'
op|'.'
name|'time'
op|'('
op|')'
newline|'\n'
name|'os'
op|'.'
name|'utime'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'sysplug'
op|'.'
name|'child'
op|'('
string|"'plugindummy_builtin.py'"
op|')'
op|'.'
name|'path'
op|','
nl|'\n'
op|'('
name|'now'
op|'-'
number|'5000'
op|','
op|')'
op|'*'
number|'2'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'utime'
op|'('
name|'self'
op|'.'
name|'syscache'
op|'.'
name|'path'
op|','
op|'('
name|'now'
op|'-'
number|'2000'
op|','
op|')'
op|'*'
number|'2'
op|')'
newline|'\n'
comment|"# For extra realism, let's make sure that the system path is no longer"
nl|'\n'
comment|'# writable.'
nl|'\n'
name|'self'
op|'.'
name|'lockSystem'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'resetEnvironment'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|lockSystem
dedent|''
name|'def'
name|'lockSystem'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Lock the system directories, as if they were unwritable by this user.\n        """'
newline|'\n'
name|'os'
op|'.'
name|'chmod'
op|'('
name|'self'
op|'.'
name|'sysplug'
op|'.'
name|'path'
op|','
number|'0555'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'chmod'
op|'('
name|'self'
op|'.'
name|'syscache'
op|'.'
name|'path'
op|','
number|'0555'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|unlockSystem
dedent|''
name|'def'
name|'unlockSystem'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Unlock the system directories, as if they were writable by this user.\n        """'
newline|'\n'
name|'os'
op|'.'
name|'chmod'
op|'('
name|'self'
op|'.'
name|'sysplug'
op|'.'
name|'path'
op|','
number|'0777'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'chmod'
op|'('
name|'self'
op|'.'
name|'syscache'
op|'.'
name|'path'
op|','
number|'0777'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getAllPlugins
dedent|''
name|'def'
name|'getAllPlugins'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Get all the plugins loadable from our dummy package, and return their\n        short names.\n        """'
newline|'\n'
comment|'# Import the module we just added to our path.  (Local scope because'
nl|'\n'
comment|"# this package doesn't exist outside of this test.)"
nl|'\n'
name|'import'
name|'plugindummy'
op|'.'
name|'plugins'
newline|'\n'
name|'x'
op|'='
name|'list'
op|'('
name|'plugin'
op|'.'
name|'getPlugins'
op|'('
name|'ITestPlugin'
op|','
name|'plugindummy'
op|'.'
name|'plugins'
op|')'
op|')'
newline|'\n'
name|'return'
op|'['
name|'plug'
op|'.'
name|'__name__'
name|'for'
name|'plug'
name|'in'
name|'x'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|resetEnvironment
dedent|''
name|'def'
name|'resetEnvironment'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Change the environment to what it should be just as the test is\n        starting.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'unsetEnvironment'
op|'('
op|')'
newline|'\n'
name|'sys'
op|'.'
name|'path'
op|'.'
name|'extend'
op|'('
op|'['
name|'x'
op|'.'
name|'path'
name|'for'
name|'x'
name|'in'
op|'['
name|'self'
op|'.'
name|'devPath'
op|','
nl|'\n'
name|'self'
op|'.'
name|'systemPath'
op|','
nl|'\n'
name|'self'
op|'.'
name|'appPath'
op|']'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|unsetEnvironment
dedent|''
name|'def'
name|'unsetEnvironment'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Change the Python environment back to what it was before the test was\n        started.\n        """'
newline|'\n'
name|'sys'
op|'.'
name|'modules'
op|'.'
name|'clear'
op|'('
op|')'
newline|'\n'
name|'sys'
op|'.'
name|'modules'
op|'.'
name|'update'
op|'('
name|'self'
op|'.'
name|'savedModules'
op|')'
newline|'\n'
name|'sys'
op|'.'
name|'path'
op|'['
op|':'
op|']'
op|'='
name|'self'
op|'.'
name|'savedPath'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tearDown
dedent|''
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Reset the Python environment to what it was before this test ran, and\n        restore permissions on files which were marked read-only so that the\n        directory may be cleanly cleaned up.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'unsetEnvironment'
op|'('
op|')'
newline|'\n'
comment|'# Normally we wouldn\'t "clean up" the filesystem like this (leaving'
nl|'\n'
comment|'# things for post-test inspection), but if we left the permissions the'
nl|'\n'
comment|"# way they were, we'd be leaving files around that the buildbots"
nl|'\n'
comment|"# couldn't delete, and that would be bad."
nl|'\n'
name|'self'
op|'.'
name|'unlockSystem'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_developmentPluginAvailability
dedent|''
name|'def'
name|'test_developmentPluginAvailability'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Plugins added in the development path should be loadable, even when\n        the (now non-importable) system path contains its own idea of the\n        list of plugins for a package.  Inversely, plugins added in the\n        system path should not be available.\n        """'
newline|'\n'
comment|'# Run 3 times: uncached, cached, and then cached again to make sure we'
nl|'\n'
comment|"# didn't overwrite / corrupt the cache on the cached try."
nl|'\n'
name|'for'
name|'x'
name|'in'
name|'range'
op|'('
number|'3'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'names'
op|'='
name|'self'
op|'.'
name|'getAllPlugins'
op|'('
op|')'
newline|'\n'
name|'names'
op|'.'
name|'sort'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'names'
op|','
op|'['
string|"'app'"
op|','
string|"'dev'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_freshPyReplacesStalePyc
dedent|''
dedent|''
name|'def'
name|'test_freshPyReplacesStalePyc'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that if a stale .pyc file on the PYTHONPATH is replaced by a\n        fresh .py file, the plugins in the new .py are picked up rather than\n        the stale .pyc, even if the .pyc is still around.\n        """'
newline|'\n'
name|'mypath'
op|'='
name|'self'
op|'.'
name|'appPackage'
op|'.'
name|'child'
op|'('
string|'"stale.py"'
op|')'
newline|'\n'
name|'mypath'
op|'.'
name|'setContent'
op|'('
name|'pluginFileContents'
op|'('
string|"'one'"
op|')'
op|')'
newline|'\n'
comment|'# Make it super stale'
nl|'\n'
name|'x'
op|'='
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|'-'
number|'1000'
newline|'\n'
name|'os'
op|'.'
name|'utime'
op|'('
name|'mypath'
op|'.'
name|'path'
op|','
op|'('
name|'x'
op|','
name|'x'
op|')'
op|')'
newline|'\n'
name|'pyc'
op|'='
name|'mypath'
op|'.'
name|'sibling'
op|'('
string|"'stale.pyc'"
op|')'
newline|'\n'
comment|'# compile it'
nl|'\n'
name|'compileall'
op|'.'
name|'compile_dir'
op|'('
name|'self'
op|'.'
name|'appPackage'
op|'.'
name|'path'
op|','
name|'quiet'
op|'='
number|'1'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'utime'
op|'('
name|'pyc'
op|'.'
name|'path'
op|','
op|'('
name|'x'
op|','
name|'x'
op|')'
op|')'
newline|'\n'
comment|'# Eliminate the other option.'
nl|'\n'
name|'mypath'
op|'.'
name|'remove'
op|'('
op|')'
newline|'\n'
comment|"# Make sure it's the .pyc path getting cached."
nl|'\n'
name|'self'
op|'.'
name|'resetEnvironment'
op|'('
op|')'
newline|'\n'
comment|'# Sanity check.'
nl|'\n'
name|'self'
op|'.'
name|'assertIn'
op|'('
string|"'one'"
op|','
name|'self'
op|'.'
name|'getAllPlugins'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIfIn'
op|'('
string|"'two'"
op|','
name|'self'
op|'.'
name|'getAllPlugins'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'resetEnvironment'
op|'('
op|')'
newline|'\n'
name|'mypath'
op|'.'
name|'setContent'
op|'('
name|'pluginFileContents'
op|'('
string|"'two'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIfIn'
op|'('
string|"'one'"
op|','
name|'self'
op|'.'
name|'getAllPlugins'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIn'
op|'('
string|"'two'"
op|','
name|'self'
op|'.'
name|'getAllPlugins'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_newPluginsOnReadOnlyPath
dedent|''
name|'def'
name|'test_newPluginsOnReadOnlyPath'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that a failure to write the dropin.cache file on a read-only\n        path will not affect the list of plugins returned.\n\n        Note: this test should pass on both Linux and Windows, but may not\n        provide useful coverage on Windows due to the different meaning of\n        "read-only directory".\n        """'
newline|'\n'
name|'self'
op|'.'
name|'unlockSystem'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'sysplug'
op|'.'
name|'child'
op|'('
string|"'newstuff.py'"
op|')'
op|'.'
name|'setContent'
op|'('
name|'pluginFileContents'
op|'('
string|"'one'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'lockSystem'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Take the developer path out, so that the system plugins are actually'
nl|'\n'
comment|'# examined.'
nl|'\n'
name|'sys'
op|'.'
name|'path'
op|'.'
name|'remove'
op|'('
name|'self'
op|'.'
name|'devPath'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
comment|"# Sanity check to make sure we're only flushing the error logged"
nl|'\n'
comment|'# below...'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'flushLoggedErrors'
op|'('
op|')'
op|')'
op|','
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIn'
op|'('
string|"'one'"
op|','
name|'self'
op|'.'
name|'getAllPlugins'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'flushLoggedErrors'
op|'('
op|')'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|AdjacentPackageTests
dedent|''
dedent|''
name|'class'
name|'AdjacentPackageTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for the behavior of the plugin system when there are multiple\n    installed copies of the package containing the plugins being loaded.\n    """'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Save the elements of C{sys.path} and the items of C{sys.modules}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'originalPath'
op|'='
name|'sys'
op|'.'
name|'path'
op|'['
op|':'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'savedModules'
op|'='
name|'sys'
op|'.'
name|'modules'
op|'.'
name|'copy'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tearDown
dedent|''
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Restore C{sys.path} and C{sys.modules} to their original values.\n        """'
newline|'\n'
name|'sys'
op|'.'
name|'path'
op|'['
op|':'
op|']'
op|'='
name|'self'
op|'.'
name|'originalPath'
newline|'\n'
name|'sys'
op|'.'
name|'modules'
op|'.'
name|'clear'
op|'('
op|')'
newline|'\n'
name|'sys'
op|'.'
name|'modules'
op|'.'
name|'update'
op|'('
name|'self'
op|'.'
name|'savedModules'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|createDummyPackage
dedent|''
name|'def'
name|'createDummyPackage'
op|'('
name|'self'
op|','
name|'root'
op|','
name|'name'
op|','
name|'pluginName'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a directory containing a Python package named I{dummy} with a\n        I{plugins} subpackage.\n\n        @type root: L{FilePath}\n        @param root: The directory in which to create the hierarchy.\n\n        @type name: C{str}\n        @param name: The name of the directory to create which will contain\n            the package.\n\n        @type pluginName: C{str}\n        @param pluginName: The name of a module to create in the\n            I{dummy.plugins} package.\n\n        @rtype: L{FilePath}\n        @return: The directory which was created to contain the I{dummy}\n            package.\n        """'
newline|'\n'
name|'directory'
op|'='
name|'root'
op|'.'
name|'child'
op|'('
name|'name'
op|')'
newline|'\n'
name|'package'
op|'='
name|'directory'
op|'.'
name|'child'
op|'('
string|"'dummy'"
op|')'
newline|'\n'
name|'package'
op|'.'
name|'makedirs'
op|'('
op|')'
newline|'\n'
name|'package'
op|'.'
name|'child'
op|'('
string|"'__init__.py'"
op|')'
op|'.'
name|'setContent'
op|'('
string|"''"
op|')'
newline|'\n'
name|'plugins'
op|'='
name|'package'
op|'.'
name|'child'
op|'('
string|"'plugins'"
op|')'
newline|'\n'
name|'plugins'
op|'.'
name|'makedirs'
op|'('
op|')'
newline|'\n'
name|'plugins'
op|'.'
name|'child'
op|'('
string|"'__init__.py'"
op|')'
op|'.'
name|'setContent'
op|'('
name|'pluginInitFile'
op|')'
newline|'\n'
name|'pluginModule'
op|'='
name|'plugins'
op|'.'
name|'child'
op|'('
name|'pluginName'
op|'+'
string|"'.py'"
op|')'
newline|'\n'
name|'pluginModule'
op|'.'
name|'setContent'
op|'('
name|'pluginFileContents'
op|'('
name|'name'
op|')'
op|')'
newline|'\n'
name|'return'
name|'directory'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_hiddenPackageSamePluginModuleNameObscured
dedent|''
name|'def'
name|'test_hiddenPackageSamePluginModuleNameObscured'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Only plugins from the first package in sys.path should be returned by\n        getPlugins in the case where there are two Python packages by the same\n        name installed, each with a plugin module by a single name.\n        """'
newline|'\n'
name|'root'
op|'='
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'root'
op|'.'
name|'makedirs'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'firstDirectory'
op|'='
name|'self'
op|'.'
name|'createDummyPackage'
op|'('
name|'root'
op|','
string|"'first'"
op|','
string|"'someplugin'"
op|')'
newline|'\n'
name|'secondDirectory'
op|'='
name|'self'
op|'.'
name|'createDummyPackage'
op|'('
name|'root'
op|','
string|"'second'"
op|','
string|"'someplugin'"
op|')'
newline|'\n'
nl|'\n'
name|'sys'
op|'.'
name|'path'
op|'.'
name|'append'
op|'('
name|'firstDirectory'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'sys'
op|'.'
name|'path'
op|'.'
name|'append'
op|'('
name|'secondDirectory'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
name|'import'
name|'dummy'
op|'.'
name|'plugins'
newline|'\n'
nl|'\n'
name|'plugins'
op|'='
name|'list'
op|'('
name|'plugin'
op|'.'
name|'getPlugins'
op|'('
name|'ITestPlugin'
op|','
name|'dummy'
op|'.'
name|'plugins'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
op|'['
string|"'first'"
op|']'
op|','
op|'['
name|'p'
op|'.'
name|'__name__'
name|'for'
name|'p'
name|'in'
name|'plugins'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_hiddenPackageDifferentPluginModuleNameObscured
dedent|''
name|'def'
name|'test_hiddenPackageDifferentPluginModuleNameObscured'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Plugins from the first package in sys.path should be returned by\n        getPlugins in the case where there are two Python packages by the same\n        name installed, each with a plugin module by a different name.\n        """'
newline|'\n'
name|'root'
op|'='
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'root'
op|'.'
name|'makedirs'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'firstDirectory'
op|'='
name|'self'
op|'.'
name|'createDummyPackage'
op|'('
name|'root'
op|','
string|"'first'"
op|','
string|"'thisplugin'"
op|')'
newline|'\n'
name|'secondDirectory'
op|'='
name|'self'
op|'.'
name|'createDummyPackage'
op|'('
name|'root'
op|','
string|"'second'"
op|','
string|"'thatplugin'"
op|')'
newline|'\n'
nl|'\n'
name|'sys'
op|'.'
name|'path'
op|'.'
name|'append'
op|'('
name|'firstDirectory'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'sys'
op|'.'
name|'path'
op|'.'
name|'append'
op|'('
name|'secondDirectory'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
name|'import'
name|'dummy'
op|'.'
name|'plugins'
newline|'\n'
nl|'\n'
name|'plugins'
op|'='
name|'list'
op|'('
name|'plugin'
op|'.'
name|'getPlugins'
op|'('
name|'ITestPlugin'
op|','
name|'dummy'
op|'.'
name|'plugins'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
op|'['
string|"'first'"
op|']'
op|','
op|'['
name|'p'
op|'.'
name|'__name__'
name|'for'
name|'p'
name|'in'
name|'plugins'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|PackagePathTests
dedent|''
dedent|''
name|'class'
name|'PackagePathTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{plugin.pluginPackagePaths} which constructs search paths for\n    plugin packages.\n    """'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Save the elements of C{sys.path}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'originalPath'
op|'='
name|'sys'
op|'.'
name|'path'
op|'['
op|':'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tearDown
dedent|''
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Restore C{sys.path} to its original value.\n        """'
newline|'\n'
name|'sys'
op|'.'
name|'path'
op|'['
op|':'
op|']'
op|'='
name|'self'
op|'.'
name|'originalPath'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_pluginDirectories
dedent|''
name|'def'
name|'test_pluginDirectories'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{plugin.pluginPackagePaths} should return a list containing each\n        directory in C{sys.path} with a suffix based on the supplied package\n        name.\n        """'
newline|'\n'
name|'foo'
op|'='
name|'FilePath'
op|'('
string|"'foo'"
op|')'
newline|'\n'
name|'bar'
op|'='
name|'FilePath'
op|'('
string|"'bar'"
op|')'
newline|'\n'
name|'sys'
op|'.'
name|'path'
op|'='
op|'['
name|'foo'
op|'.'
name|'path'
op|','
name|'bar'
op|'.'
name|'path'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'plugin'
op|'.'
name|'pluginPackagePaths'
op|'('
string|"'dummy.plugins'"
op|')'
op|','
nl|'\n'
op|'['
name|'foo'
op|'.'
name|'child'
op|'('
string|"'dummy'"
op|')'
op|'.'
name|'child'
op|'('
string|"'plugins'"
op|')'
op|'.'
name|'path'
op|','
nl|'\n'
name|'bar'
op|'.'
name|'child'
op|'('
string|"'dummy'"
op|')'
op|'.'
name|'child'
op|'('
string|"'plugins'"
op|')'
op|'.'
name|'path'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_pluginPackagesExcluded
dedent|''
name|'def'
name|'test_pluginPackagesExcluded'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{plugin.pluginPackagePaths} should exclude directories which are\n        Python packages.  The only allowed plugin package (the only one\n        associated with a I{dummy} package which Python will allow to be\n        imported) will already be known to the caller of\n        L{plugin.pluginPackagePaths} and will most commonly already be in\n        the C{__path__} they are about to mutate.\n        """'
newline|'\n'
name|'root'
op|'='
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'foo'
op|'='
name|'root'
op|'.'
name|'child'
op|'('
string|"'foo'"
op|')'
op|'.'
name|'child'
op|'('
string|"'dummy'"
op|')'
op|'.'
name|'child'
op|'('
string|"'plugins'"
op|')'
newline|'\n'
name|'foo'
op|'.'
name|'makedirs'
op|'('
op|')'
newline|'\n'
name|'foo'
op|'.'
name|'child'
op|'('
string|"'__init__.py'"
op|')'
op|'.'
name|'setContent'
op|'('
string|"''"
op|')'
newline|'\n'
name|'sys'
op|'.'
name|'path'
op|'='
op|'['
name|'root'
op|'.'
name|'child'
op|'('
string|"'foo'"
op|')'
op|'.'
name|'path'
op|','
name|'root'
op|'.'
name|'child'
op|'('
string|"'bar'"
op|')'
op|'.'
name|'path'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'plugin'
op|'.'
name|'pluginPackagePaths'
op|'('
string|"'dummy.plugins'"
op|')'
op|','
nl|'\n'
op|'['
name|'root'
op|'.'
name|'child'
op|'('
string|"'bar'"
op|')'
op|'.'
name|'child'
op|'('
string|"'dummy'"
op|')'
op|'.'
name|'child'
op|'('
string|"'plugins'"
op|')'
op|'.'
name|'path'
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
