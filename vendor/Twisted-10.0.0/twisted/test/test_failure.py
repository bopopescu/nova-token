begin_unit
comment|'# Copyright (c) 2001-2008 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
nl|'\n'
string|'"""\nTest cases for failure module.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'sys'
newline|'\n'
name|'import'
name|'StringIO'
newline|'\n'
name|'import'
name|'traceback'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
op|','
name|'util'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'failure'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'from'
name|'twisted'
op|'.'
name|'test'
name|'import'
name|'raiser'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
DECL|variable|raiser
indent|'    '
name|'raiser'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|BrokenStr
dedent|''
name|'class'
name|'BrokenStr'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
DECL|member|__str__
indent|'    '
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'self'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|getDivisionFailure
dedent|''
dedent|''
name|'def'
name|'getDivisionFailure'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
name|'try'
op|':'
newline|'\n'
indent|'        '
number|'1'
op|'/'
number|'0'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'        '
name|'f'
op|'='
name|'failure'
op|'.'
name|'Failure'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'f'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|FailureTestCase
dedent|''
name|'class'
name|'FailureTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|testFailAndTrap
indent|'    '
name|'def'
name|'testFailAndTrap'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Trapping a failure."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'NotImplementedError'
op|'('
string|"'test'"
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'='
name|'failure'
op|'.'
name|'Failure'
op|'('
op|')'
newline|'\n'
dedent|''
name|'error'
op|'='
name|'f'
op|'.'
name|'trap'
op|'('
name|'SystemExit'
op|','
name|'RuntimeError'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'error'
op|','
name|'RuntimeError'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'f'
op|'.'
name|'type'
op|','
name|'NotImplementedError'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_notTrapped
dedent|''
name|'def'
name|'test_notTrapped'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Making sure trap doesn\'t trap what it shouldn\'t."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'='
name|'failure'
op|'.'
name|'Failure'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'failure'
op|'.'
name|'Failure'
op|','
name|'f'
op|'.'
name|'trap'
op|','
name|'OverflowError'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testPrinting
dedent|''
name|'def'
name|'testPrinting'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'out'
op|'='
name|'StringIO'
op|'.'
name|'StringIO'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
number|'1'
op|'/'
number|'0'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'='
name|'failure'
op|'.'
name|'Failure'
op|'('
op|')'
newline|'\n'
dedent|''
name|'f'
op|'.'
name|'printDetailedTraceback'
op|'('
name|'out'
op|')'
newline|'\n'
name|'f'
op|'.'
name|'printBriefTraceback'
op|'('
name|'out'
op|')'
newline|'\n'
name|'f'
op|'.'
name|'printTraceback'
op|'('
name|'out'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testExplictPass
dedent|''
name|'def'
name|'testExplictPass'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'e'
op|'='
name|'RuntimeError'
op|'('
op|')'
newline|'\n'
name|'f'
op|'='
name|'failure'
op|'.'
name|'Failure'
op|'('
name|'e'
op|')'
newline|'\n'
name|'f'
op|'.'
name|'trap'
op|'('
name|'RuntimeError'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'f'
op|'.'
name|'value'
op|','
name|'e'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_getInnermostFrameLine
dedent|''
name|'def'
name|'_getInnermostFrameLine'
op|'('
name|'self'
op|','
name|'f'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'.'
name|'raiseException'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ZeroDivisionError'
op|':'
newline|'\n'
indent|'            '
name|'tb'
op|'='
name|'traceback'
op|'.'
name|'extract_tb'
op|'('
name|'sys'
op|'.'
name|'exc_info'
op|'('
op|')'
op|'['
number|'2'
op|']'
op|')'
newline|'\n'
name|'return'
name|'tb'
op|'['
op|'-'
number|'1'
op|']'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'Exception'
op|'('
nl|'\n'
string|'"f.raiseException() didn\'t raise ZeroDivisionError!?"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testRaiseExceptionWithTB
dedent|''
dedent|''
name|'def'
name|'testRaiseExceptionWithTB'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'f'
op|'='
name|'getDivisionFailure'
op|'('
op|')'
newline|'\n'
name|'innerline'
op|'='
name|'self'
op|'.'
name|'_getInnermostFrameLine'
op|'('
name|'f'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'innerline'
op|','
string|"'1/0'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testLackOfTB
dedent|''
name|'def'
name|'testLackOfTB'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'f'
op|'='
name|'getDivisionFailure'
op|'('
op|')'
newline|'\n'
name|'f'
op|'.'
name|'cleanFailure'
op|'('
op|')'
newline|'\n'
name|'innerline'
op|'='
name|'self'
op|'.'
name|'_getInnermostFrameLine'
op|'('
name|'f'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'innerline'
op|','
string|"'1/0'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'testLackOfTB'
op|'.'
name|'todo'
op|'='
string|'"the traceback is not preserved, exarkun said he\'ll try to fix this! god knows how"'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|_stringException
name|'_stringException'
op|'='
string|'"bugger off"'
newline|'\n'
DECL|member|_getStringFailure
name|'def'
name|'_getStringFailure'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'self'
op|'.'
name|'_stringException'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'='
name|'failure'
op|'.'
name|'Failure'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'f'
newline|'\n'
nl|'\n'
DECL|member|test_raiseStringExceptions
dedent|''
name|'def'
name|'test_raiseStringExceptions'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# String exceptions used to totally bugged f.raiseException'
nl|'\n'
indent|'        '
name|'f'
op|'='
name|'self'
op|'.'
name|'_getStringFailure'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'.'
name|'raiseException'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'sys'
op|'.'
name|'exc_info'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|','
name|'self'
op|'.'
name|'_stringException'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'AssertionError'
op|'('
string|'"Should have raised"'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'test_raiseStringExceptions'
op|'.'
name|'suppress'
op|'='
op|'['
nl|'\n'
name|'util'
op|'.'
name|'suppress'
op|'('
name|'message'
op|'='
string|"'raising a string exception is deprecated'"
op|')'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_printStringExceptions
name|'def'
name|'test_printStringExceptions'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{Failure.printTraceback} should write out stack and exception\n        information, even for string exceptions.\n        """'
newline|'\n'
name|'failure'
op|'='
name|'self'
op|'.'
name|'_getStringFailure'
op|'('
op|')'
newline|'\n'
name|'output'
op|'='
name|'StringIO'
op|'.'
name|'StringIO'
op|'('
op|')'
newline|'\n'
name|'failure'
op|'.'
name|'printTraceback'
op|'('
name|'file'
op|'='
name|'output'
op|')'
newline|'\n'
name|'lines'
op|'='
name|'output'
op|'.'
name|'getvalue'
op|'('
op|')'
op|'.'
name|'splitlines'
op|'('
op|')'
newline|'\n'
comment|'# The last line should be the value of the raised string'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'lines'
op|'['
op|'-'
number|'1'
op|']'
op|','
name|'self'
op|'.'
name|'_stringException'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'test_printStringExceptions'
op|'.'
name|'suppress'
op|'='
op|'['
nl|'\n'
name|'util'
op|'.'
name|'suppress'
op|'('
name|'message'
op|'='
string|"'raising a string exception is deprecated'"
op|')'
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'sys'
op|'.'
name|'version_info'
op|'['
op|':'
number|'2'
op|']'
op|'>='
op|'('
number|'2'
op|','
number|'6'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'skipMsg'
op|'='
op|'('
string|'"String exceptions aren\'t supported anymore starting "'
nl|'\n'
string|'"Python 2.6"'
op|')'
newline|'\n'
name|'test_raiseStringExceptions'
op|'.'
name|'skip'
op|'='
name|'skipMsg'
newline|'\n'
name|'test_printStringExceptions'
op|'.'
name|'skip'
op|'='
name|'skipMsg'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testBrokenStr
dedent|''
name|'def'
name|'testBrokenStr'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Formatting a traceback of a Failure which refers to an object\n        that has a broken __str__ implementation should not cause\n        getTraceback to raise an exception.\n        """'
newline|'\n'
name|'x'
op|'='
name|'BrokenStr'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'str'
op|'('
name|'x'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'='
name|'failure'
op|'.'
name|'Failure'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'f'
op|'.'
name|'value'
op|','
name|'x'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'.'
name|'getTraceback'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'fail'
op|'('
string|'"getTraceback() shouldn\'t raise an exception"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testConstructionFails
dedent|''
dedent|''
name|'def'
name|'testConstructionFails'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Creating a Failure with no arguments causes it to try to discover the\n        current interpreter exception state.  If no such state exists, creating\n        the Failure should raise a synchronous exception.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'failure'
op|'.'
name|'NoCurrentExceptionError'
op|','
name|'failure'
op|'.'
name|'Failure'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_getTracebackObject
dedent|''
name|'def'
name|'test_getTracebackObject'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the C{Failure} has not been cleaned, then C{getTracebackObject}\n        should return the traceback object that it was given in the\n        constructor.\n        """'
newline|'\n'
name|'f'
op|'='
name|'getDivisionFailure'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'f'
op|'.'
name|'getTracebackObject'
op|'('
op|')'
op|','
name|'f'
op|'.'
name|'tb'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_getTracebackObjectFromClean
dedent|''
name|'def'
name|'test_getTracebackObjectFromClean'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the Failure has been cleaned, then C{getTracebackObject} should\n        return an object that looks the same to L{traceback.extract_tb}.\n        """'
newline|'\n'
name|'f'
op|'='
name|'getDivisionFailure'
op|'('
op|')'
newline|'\n'
name|'expected'
op|'='
name|'traceback'
op|'.'
name|'extract_tb'
op|'('
name|'f'
op|'.'
name|'getTracebackObject'
op|'('
op|')'
op|')'
newline|'\n'
name|'f'
op|'.'
name|'cleanFailure'
op|'('
op|')'
newline|'\n'
name|'observed'
op|'='
name|'traceback'
op|'.'
name|'extract_tb'
op|'('
name|'f'
op|'.'
name|'getTracebackObject'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'expected'
op|','
name|'observed'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_getTracebackObjectWithoutTraceback
dedent|''
name|'def'
name|'test_getTracebackObjectWithoutTraceback'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{failure.Failure}s need not be constructed with traceback objects. If\n        a C{Failure} has no traceback information at all, C{getTracebackObject}\n        should just return None.\n\n        None is a good value, because traceback.extract_tb(None) -> [].\n        """'
newline|'\n'
name|'f'
op|'='
name|'failure'
op|'.'
name|'Failure'
op|'('
name|'Exception'
op|'('
string|'"some error"'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'f'
op|'.'
name|'getTracebackObject'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
DECL|class|FindFailureTests
dedent|''
dedent|''
name|'class'
name|'FindFailureTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for functionality related to L{Failure._findFailure}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|test_findNoFailureInExceptionHandler
name|'def'
name|'test_findNoFailureInExceptionHandler'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Within an exception handler, _findFailure should return\n        C{None} in case no Failure is associated with the current\n        exception.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
number|'1'
op|'/'
number|'0'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'failure'
op|'.'
name|'Failure'
op|'.'
name|'_findFailure'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'fail'
op|'('
string|'"No exception raised from 1/0!?"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_findNoFailure
dedent|''
dedent|''
name|'def'
name|'test_findNoFailure'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Outside of an exception handler, _findFailure should return None.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'sys'
op|'.'
name|'exc_info'
op|'('
op|')'
op|'['
op|'-'
number|'1'
op|']'
op|','
name|'None'
op|')'
comment|'#environment sanity check'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'failure'
op|'.'
name|'Failure'
op|'.'
name|'_findFailure'
op|'('
op|')'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_findFailure
dedent|''
name|'def'
name|'test_findFailure'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Within an exception handler, it should be possible to find the\n        original Failure that caused the current exception (if it was\n        caused by raiseException).\n        """'
newline|'\n'
name|'f'
op|'='
name|'getDivisionFailure'
op|'('
op|')'
newline|'\n'
name|'f'
op|'.'
name|'cleanFailure'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'.'
name|'raiseException'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'failure'
op|'.'
name|'Failure'
op|'.'
name|'_findFailure'
op|'('
op|')'
op|','
name|'f'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'fail'
op|'('
string|'"No exception raised from raiseException!?"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_failureConstructionFindsOriginalFailure
dedent|''
dedent|''
name|'def'
name|'test_failureConstructionFindsOriginalFailure'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When a Failure is constructed in the context of an exception\n        handler that is handling an exception raised by\n        raiseException, the new Failure should be chained to that\n        original Failure.\n        """'
newline|'\n'
name|'f'
op|'='
name|'getDivisionFailure'
op|'('
op|')'
newline|'\n'
name|'f'
op|'.'
name|'cleanFailure'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'.'
name|'raiseException'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'newF'
op|'='
name|'failure'
op|'.'
name|'Failure'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'f'
op|'.'
name|'getTraceback'
op|'('
op|')'
op|','
name|'newF'
op|'.'
name|'getTraceback'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'fail'
op|'('
string|'"No exception raised from raiseException!?"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_failureConstructionWithMungedStackSucceeds
dedent|''
dedent|''
name|'def'
name|'test_failureConstructionWithMungedStackSucceeds'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Pyrex and Cython are known to insert fake stack frames so as to give\n        more Python-like tracebacks. These stack frames with empty code objects\n        should not break extraction of the exception.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'raiser'
op|'.'
name|'raiseException'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'raiser'
op|'.'
name|'RaiserException'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'='
name|'failure'
op|'.'
name|'Failure'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'f'
op|'.'
name|'check'
op|'('
name|'raiser'
op|'.'
name|'RaiserException'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'fail'
op|'('
string|'"No exception raised from extension?!"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'raiser'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'skipMsg'
op|'='
string|'"raiser extension not available"'
newline|'\n'
name|'test_failureConstructionWithMungedStackSucceeds'
op|'.'
name|'skip'
op|'='
name|'skipMsg'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestFormattableTraceback
dedent|''
dedent|''
name|'class'
name|'TestFormattableTraceback'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Whitebox tests that show that L{failure._Traceback} constructs objects that\n    can be used by L{traceback.extract_tb}.\n\n    If the objects can be used by L{traceback.extract_tb}, then they can be\n    formatted using L{traceback.format_tb} and friends.\n    """'
newline|'\n'
nl|'\n'
DECL|member|test_singleFrame
name|'def'
name|'test_singleFrame'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A C{_Traceback} object constructed with a single frame should be able\n        to be passed to L{traceback.extract_tb}, and we should get a singleton\n        list containing a (filename, lineno, methodname, line) tuple.\n        """'
newline|'\n'
name|'tb'
op|'='
name|'failure'
op|'.'
name|'_Traceback'
op|'('
op|'['
op|'['
string|"'method'"
op|','
string|"'filename.py'"
op|','
number|'123'
op|','
op|'{'
op|'}'
op|','
op|'{'
op|'}'
op|']'
op|']'
op|')'
newline|'\n'
comment|"# Note that we don't need to test that extract_tb correctly extracts"
nl|'\n'
comment|"# the line's contents. In this case, since filename.py doesn't exist,"
nl|'\n'
comment|'# it will just use None.'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'traceback'
op|'.'
name|'extract_tb'
op|'('
name|'tb'
op|')'
op|','
nl|'\n'
op|'['
op|'('
string|"'filename.py'"
op|','
number|'123'
op|','
string|"'method'"
op|','
name|'None'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_manyFrames
dedent|''
name|'def'
name|'test_manyFrames'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A C{_Traceback} object constructed with multiple frames should be able\n        to be passed to L{traceback.extract_tb}, and we should get a list\n        containing a tuple for each frame.\n        """'
newline|'\n'
name|'tb'
op|'='
name|'failure'
op|'.'
name|'_Traceback'
op|'('
op|'['
nl|'\n'
op|'['
string|"'method1'"
op|','
string|"'filename.py'"
op|','
number|'123'
op|','
op|'{'
op|'}'
op|','
op|'{'
op|'}'
op|']'
op|','
nl|'\n'
op|'['
string|"'method2'"
op|','
string|"'filename.py'"
op|','
number|'235'
op|','
op|'{'
op|'}'
op|','
op|'{'
op|'}'
op|']'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'traceback'
op|'.'
name|'extract_tb'
op|'('
name|'tb'
op|')'
op|','
nl|'\n'
op|'['
op|'('
string|"'filename.py'"
op|','
number|'123'
op|','
string|"'method1'"
op|','
name|'None'
op|')'
op|','
nl|'\n'
op|'('
string|"'filename.py'"
op|','
number|'235'
op|','
string|"'method2'"
op|','
name|'None'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'sys'
op|'.'
name|'version_info'
op|'['
op|':'
number|'2'
op|']'
op|'>='
op|'('
number|'2'
op|','
number|'5'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'from'
name|'twisted'
op|'.'
name|'test'
op|'.'
name|'generator_failure_tests'
name|'import'
name|'TwoPointFiveFailureTests'
newline|'\n'
dedent|''
endmarker|''
end_unit
