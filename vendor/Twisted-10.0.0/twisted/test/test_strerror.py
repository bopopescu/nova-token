begin_unit
comment|'# Copyright (c) 2007 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTest strerror\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'socket'
newline|'\n'
name|'import'
name|'os'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
op|'.'
name|'unittest'
name|'import'
name|'TestCase'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'tcp'
name|'import'
name|'ECONNABORTED'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'win32'
name|'import'
name|'_ErrorFormatter'
op|','
name|'formatError'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'runtime'
name|'import'
name|'platform'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ErrorFormatingTestCase
name|'class'
name|'ErrorFormatingTestCase'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for C{_ErrorFormatter.formatError}.\n    """'
newline|'\n'
DECL|variable|probeErrorCode
name|'probeErrorCode'
op|'='
name|'ECONNABORTED'
newline|'\n'
DECL|variable|probeMessage
name|'probeMessage'
op|'='
string|'"correct message value"'
newline|'\n'
nl|'\n'
DECL|member|test_strerrorFormatting
name|'def'
name|'test_strerrorFormatting'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ErrorFormatter.formatError} should use L{os.strerror} to format\n        error messages if it is constructed without any better mechanism.\n        """'
newline|'\n'
name|'formatter'
op|'='
name|'_ErrorFormatter'
op|'('
name|'None'
op|','
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
name|'message'
op|'='
name|'formatter'
op|'.'
name|'formatError'
op|'('
name|'self'
op|'.'
name|'probeErrorCode'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'message'
op|','
name|'os'
op|'.'
name|'strerror'
op|'('
name|'self'
op|'.'
name|'probeErrorCode'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_emptyErrorTab
dedent|''
name|'def'
name|'test_emptyErrorTab'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ErrorFormatter.formatError} should use L{os.strerror} to format\n        error messages if it is constructed with only an error tab which does\n        not contain the error code it is called with.\n        """'
newline|'\n'
name|'error'
op|'='
number|'1'
newline|'\n'
comment|'# Sanity check'
nl|'\n'
name|'self'
op|'.'
name|'assertNotEqual'
op|'('
name|'self'
op|'.'
name|'probeErrorCode'
op|','
name|'error'
op|')'
newline|'\n'
name|'formatter'
op|'='
name|'_ErrorFormatter'
op|'('
name|'None'
op|','
name|'None'
op|','
op|'{'
name|'error'
op|':'
string|"'wrong message'"
op|'}'
op|')'
newline|'\n'
name|'message'
op|'='
name|'formatter'
op|'.'
name|'formatError'
op|'('
name|'self'
op|'.'
name|'probeErrorCode'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'message'
op|','
name|'os'
op|'.'
name|'strerror'
op|'('
name|'self'
op|'.'
name|'probeErrorCode'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_errorTab
dedent|''
name|'def'
name|'test_errorTab'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ErrorFormatter.formatError} should use C{errorTab} if it is supplied\n        and contains the requested error code.\n        """'
newline|'\n'
name|'formatter'
op|'='
name|'_ErrorFormatter'
op|'('
nl|'\n'
name|'None'
op|','
name|'None'
op|','
op|'{'
name|'self'
op|'.'
name|'probeErrorCode'
op|':'
name|'self'
op|'.'
name|'probeMessage'
op|'}'
op|')'
newline|'\n'
name|'message'
op|'='
name|'formatter'
op|'.'
name|'formatError'
op|'('
name|'self'
op|'.'
name|'probeErrorCode'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'message'
op|','
name|'self'
op|'.'
name|'probeMessage'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_formatMessage
dedent|''
name|'def'
name|'test_formatMessage'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ErrorFormatter.formatError} should return the return value of\n        C{formatMessage} if it is supplied.\n        """'
newline|'\n'
name|'formatCalls'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|formatMessage
name|'def'
name|'formatMessage'
op|'('
name|'errorCode'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'formatCalls'
op|'.'
name|'append'
op|'('
name|'errorCode'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'probeMessage'
newline|'\n'
dedent|''
name|'formatter'
op|'='
name|'_ErrorFormatter'
op|'('
nl|'\n'
name|'None'
op|','
name|'formatMessage'
op|','
op|'{'
name|'self'
op|'.'
name|'probeErrorCode'
op|':'
string|"'wrong message'"
op|'}'
op|')'
newline|'\n'
name|'message'
op|'='
name|'formatter'
op|'.'
name|'formatError'
op|'('
name|'self'
op|'.'
name|'probeErrorCode'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'message'
op|','
name|'self'
op|'.'
name|'probeMessage'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'formatCalls'
op|','
op|'['
name|'self'
op|'.'
name|'probeErrorCode'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_winError
dedent|''
name|'def'
name|'test_winError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ErrorFormatter.formatError} should return the message argument from\n        the exception L{winError} returns, if L{winError} is supplied.\n        """'
newline|'\n'
name|'winCalls'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|winError
name|'def'
name|'winError'
op|'('
name|'errorCode'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'winCalls'
op|'.'
name|'append'
op|'('
name|'errorCode'
op|')'
newline|'\n'
name|'return'
op|'('
name|'errorCode'
op|','
name|'self'
op|'.'
name|'probeMessage'
op|')'
newline|'\n'
dedent|''
name|'formatter'
op|'='
name|'_ErrorFormatter'
op|'('
nl|'\n'
name|'winError'
op|','
nl|'\n'
name|'lambda'
name|'error'
op|':'
string|"'formatMessage: wrong message'"
op|','
nl|'\n'
op|'{'
name|'self'
op|'.'
name|'probeErrorCode'
op|':'
string|"'errorTab: wrong message'"
op|'}'
op|')'
newline|'\n'
name|'message'
op|'='
name|'formatter'
op|'.'
name|'formatError'
op|'('
name|'self'
op|'.'
name|'probeErrorCode'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'message'
op|','
name|'self'
op|'.'
name|'probeMessage'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_fromEnvironment
dedent|''
name|'def'
name|'test_fromEnvironment'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ErrorFormatter.fromEnvironment} should create an L{_ErrorFormatter}\n        instance with attributes populated from available modules.\n        """'
newline|'\n'
name|'formatter'
op|'='
name|'_ErrorFormatter'
op|'.'
name|'fromEnvironment'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'formatter'
op|'.'
name|'winError'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'from'
name|'ctypes'
name|'import'
name|'WinError'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'formatter'
op|'.'
name|'formatError'
op|'('
name|'self'
op|'.'
name|'probeErrorCode'
op|')'
op|','
nl|'\n'
name|'WinError'
op|'('
name|'self'
op|'.'
name|'probeErrorCode'
op|')'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
name|'formatter'
op|'.'
name|'winError'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'formatter'
op|'.'
name|'formatMessage'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'from'
name|'win32api'
name|'import'
name|'FormatMessage'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'formatter'
op|'.'
name|'formatError'
op|'('
name|'self'
op|'.'
name|'probeErrorCode'
op|')'
op|','
nl|'\n'
name|'FormatMessage'
op|'('
name|'self'
op|'.'
name|'probeErrorCode'
op|')'
op|')'
newline|'\n'
name|'formatter'
op|'.'
name|'formatMessage'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'formatter'
op|'.'
name|'errorTab'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'from'
name|'socket'
name|'import'
name|'errorTab'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'formatter'
op|'.'
name|'formatError'
op|'('
name|'self'
op|'.'
name|'probeErrorCode'
op|')'
op|','
nl|'\n'
name|'errorTab'
op|'['
name|'self'
op|'.'
name|'probeErrorCode'
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'platform'
op|'.'
name|'getType'
op|'('
op|')'
op|'!='
string|'"win32"'
op|':'
newline|'\n'
indent|'        '
name|'test_fromEnvironment'
op|'.'
name|'skip'
op|'='
string|'"This error lookup only works on Windows"'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_correctLookups
dedent|''
name|'def'
name|'test_correctLookups'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Given an known-good errno, make sure that formatMessage gives results\n        matching either C{socket.errorTab}, C{ctypes.WinError}, or\n        C{win32api.FormatMessage}.\n        """'
newline|'\n'
name|'acceptable'
op|'='
op|'['
name|'socket'
op|'.'
name|'errorTab'
op|'['
name|'ECONNABORTED'
op|']'
op|']'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'from'
name|'ctypes'
name|'import'
name|'WinError'
newline|'\n'
name|'acceptable'
op|'.'
name|'append'
op|'('
name|'WinError'
op|'('
name|'ECONNABORTED'
op|')'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'from'
name|'win32api'
name|'import'
name|'FormatMessage'
newline|'\n'
name|'acceptable'
op|'.'
name|'append'
op|'('
name|'FormatMessage'
op|'('
name|'ECONNABORTED'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'assertIn'
op|'('
name|'formatError'
op|'('
name|'ECONNABORTED'
op|')'
op|','
name|'acceptable'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'platform'
op|'.'
name|'getType'
op|'('
op|')'
op|'!='
string|'"win32"'
op|':'
newline|'\n'
indent|'        '
name|'test_correctLookups'
op|'.'
name|'skip'
op|'='
string|'"This error lookup only works on Windows"'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
