begin_unit
comment|'# Copyright (c) 2001-2007 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'compat'
name|'import'
name|'set'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'interfaces'
op|','
name|'task'
op|','
name|'reactor'
op|','
name|'defer'
op|','
name|'error'
newline|'\n'
nl|'\n'
comment|'# Be compatible with any jerks who used our private stuff'
nl|'\n'
DECL|variable|Clock
name|'Clock'
op|'='
name|'task'
op|'.'
name|'Clock'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'failure'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestableLoopingCall
name|'class'
name|'TestableLoopingCall'
op|'('
name|'task'
op|'.'
name|'LoopingCall'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'clock'
op|','
op|'*'
name|'a'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'super'
op|'('
name|'TestableLoopingCall'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
op|'*'
name|'a'
op|','
op|'**'
name|'kw'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'clock'
op|'='
name|'clock'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestException
dedent|''
dedent|''
name|'class'
name|'TestException'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ClockTestCase
dedent|''
name|'class'
name|'ClockTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test the non-wallclock based clock implementation.\n    """'
newline|'\n'
DECL|member|testSeconds
name|'def'
name|'testSeconds'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that the L{seconds} method of the fake clock returns fake time.\n        """'
newline|'\n'
name|'c'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'c'
op|'.'
name|'seconds'
op|'('
op|')'
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testCallLater
dedent|''
name|'def'
name|'testCallLater'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that calls can be scheduled for later with the fake clock and\n        hands back an L{IDelayedCall}.\n        """'
newline|'\n'
name|'c'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
name|'call'
op|'='
name|'c'
op|'.'
name|'callLater'
op|'('
number|'1'
op|','
name|'lambda'
name|'a'
op|','
name|'b'
op|':'
name|'None'
op|','
number|'1'
op|','
name|'b'
op|'='
number|'2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'interfaces'
op|'.'
name|'IDelayedCall'
op|'.'
name|'providedBy'
op|'('
name|'call'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'call'
op|'.'
name|'getTime'
op|'('
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'call'
op|'.'
name|'active'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testCallLaterCancelled
dedent|''
name|'def'
name|'testCallLaterCancelled'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that calls can be cancelled.\n        """'
newline|'\n'
name|'c'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
name|'call'
op|'='
name|'c'
op|'.'
name|'callLater'
op|'('
number|'1'
op|','
name|'lambda'
name|'a'
op|','
name|'b'
op|':'
name|'None'
op|','
number|'1'
op|','
name|'b'
op|'='
number|'2'
op|')'
newline|'\n'
name|'call'
op|'.'
name|'cancel'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'call'
op|'.'
name|'active'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_callLaterOrdering
dedent|''
name|'def'
name|'test_callLaterOrdering'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that the DelayedCall returned is not one previously\n        created.\n        """'
newline|'\n'
name|'c'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
name|'call1'
op|'='
name|'c'
op|'.'
name|'callLater'
op|'('
number|'10'
op|','
name|'lambda'
name|'a'
op|','
name|'b'
op|':'
name|'None'
op|','
number|'1'
op|','
name|'b'
op|'='
number|'2'
op|')'
newline|'\n'
name|'call2'
op|'='
name|'c'
op|'.'
name|'callLater'
op|'('
number|'1'
op|','
name|'lambda'
name|'a'
op|','
name|'b'
op|':'
name|'None'
op|','
number|'3'
op|','
name|'b'
op|'='
number|'4'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'call1'
name|'is'
name|'call2'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testAdvance
dedent|''
name|'def'
name|'testAdvance'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that advancing the clock will fire some calls.\n        """'
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
name|'c'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
name|'call'
op|'='
name|'c'
op|'.'
name|'callLater'
op|'('
number|'2'
op|','
name|'lambda'
op|':'
name|'events'
op|'.'
name|'append'
op|'('
name|'None'
op|')'
op|')'
newline|'\n'
name|'c'
op|'.'
name|'advance'
op|'('
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'events'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'c'
op|'.'
name|'advance'
op|'('
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'events'
op|','
op|'['
name|'None'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'call'
op|'.'
name|'active'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testAdvanceCancel
dedent|''
name|'def'
name|'testAdvanceCancel'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test attemping to cancel the call in a callback.\n\n        AlreadyCalled should be raised, not for example a ValueError from\n        removing the call from Clock.calls. This requires call.called to be\n        set before the callback is called.\n        """'
newline|'\n'
name|'c'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
DECL|function|cb
name|'def'
name|'cb'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'error'
op|'.'
name|'AlreadyCalled'
op|','
name|'call'
op|'.'
name|'cancel'
op|')'
newline|'\n'
dedent|''
name|'call'
op|'='
name|'c'
op|'.'
name|'callLater'
op|'('
number|'1'
op|','
name|'cb'
op|')'
newline|'\n'
name|'c'
op|'.'
name|'advance'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testCallLaterDelayed
dedent|''
name|'def'
name|'testCallLaterDelayed'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that calls can be delayed.\n        """'
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
name|'c'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
name|'call'
op|'='
name|'c'
op|'.'
name|'callLater'
op|'('
number|'1'
op|','
name|'lambda'
name|'a'
op|','
name|'b'
op|':'
name|'events'
op|'.'
name|'append'
op|'('
op|'('
name|'a'
op|','
name|'b'
op|')'
op|')'
op|','
number|'1'
op|','
name|'b'
op|'='
number|'2'
op|')'
newline|'\n'
name|'call'
op|'.'
name|'delay'
op|'('
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'call'
op|'.'
name|'getTime'
op|'('
op|')'
op|','
number|'2'
op|')'
newline|'\n'
name|'c'
op|'.'
name|'advance'
op|'('
number|'1.5'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'events'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'c'
op|'.'
name|'advance'
op|'('
number|'1.0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'events'
op|','
op|'['
op|'('
number|'1'
op|','
number|'2'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testCallLaterResetLater
dedent|''
name|'def'
name|'testCallLaterResetLater'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that calls can have their time reset to a later time.\n        """'
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
name|'c'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
name|'call'
op|'='
name|'c'
op|'.'
name|'callLater'
op|'('
number|'2'
op|','
name|'lambda'
name|'a'
op|','
name|'b'
op|':'
name|'events'
op|'.'
name|'append'
op|'('
op|'('
name|'a'
op|','
name|'b'
op|')'
op|')'
op|','
number|'1'
op|','
name|'b'
op|'='
number|'2'
op|')'
newline|'\n'
name|'c'
op|'.'
name|'advance'
op|'('
number|'1'
op|')'
newline|'\n'
name|'call'
op|'.'
name|'reset'
op|'('
number|'3'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'call'
op|'.'
name|'getTime'
op|'('
op|')'
op|','
number|'4'
op|')'
newline|'\n'
name|'c'
op|'.'
name|'advance'
op|'('
number|'2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'events'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'c'
op|'.'
name|'advance'
op|'('
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'events'
op|','
op|'['
op|'('
number|'1'
op|','
number|'2'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testCallLaterResetSooner
dedent|''
name|'def'
name|'testCallLaterResetSooner'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that calls can have their time reset to an earlier time.\n        """'
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
name|'c'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
name|'call'
op|'='
name|'c'
op|'.'
name|'callLater'
op|'('
number|'4'
op|','
name|'lambda'
name|'a'
op|','
name|'b'
op|':'
name|'events'
op|'.'
name|'append'
op|'('
op|'('
name|'a'
op|','
name|'b'
op|')'
op|')'
op|','
number|'1'
op|','
name|'b'
op|'='
number|'2'
op|')'
newline|'\n'
name|'call'
op|'.'
name|'reset'
op|'('
number|'3'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'call'
op|'.'
name|'getTime'
op|'('
op|')'
op|','
number|'3'
op|')'
newline|'\n'
name|'c'
op|'.'
name|'advance'
op|'('
number|'3'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'events'
op|','
op|'['
op|'('
number|'1'
op|','
number|'2'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getDelayedCalls
dedent|''
name|'def'
name|'test_getDelayedCalls'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that we can get a list of all delayed calls\n        """'
newline|'\n'
name|'c'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
name|'call'
op|'='
name|'c'
op|'.'
name|'callLater'
op|'('
number|'1'
op|','
name|'lambda'
name|'x'
op|':'
name|'None'
op|')'
newline|'\n'
name|'call2'
op|'='
name|'c'
op|'.'
name|'callLater'
op|'('
number|'2'
op|','
name|'lambda'
name|'x'
op|':'
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'calls'
op|'='
name|'c'
op|'.'
name|'getDelayedCalls'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'set'
op|'('
op|'['
name|'call'
op|','
name|'call2'
op|']'
op|')'
op|','
name|'set'
op|'('
name|'calls'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getDelayedCallsEmpty
dedent|''
name|'def'
name|'test_getDelayedCallsEmpty'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that we get an empty list from getDelayedCalls on a newly\n        constructed Clock.\n        """'
newline|'\n'
name|'c'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'c'
op|'.'
name|'getDelayedCalls'
op|'('
op|')'
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_providesIReactorTime
dedent|''
name|'def'
name|'test_providesIReactorTime'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'c'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'interfaces'
op|'.'
name|'IReactorTime'
op|'.'
name|'providedBy'
op|'('
name|'c'
op|')'
op|','
nl|'\n'
string|'"Clock does not provide IReactorTime"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|LoopTestCase
dedent|''
dedent|''
name|'class'
name|'LoopTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{task.LoopingCall} based on a fake L{IReactorTime}\n    implementation.\n    """'
newline|'\n'
DECL|member|test_defaultClock
name|'def'
name|'test_defaultClock'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{LoopingCall}\'s default clock should be the reactor.\n        """'
newline|'\n'
name|'call'
op|'='
name|'task'
op|'.'
name|'LoopingCall'
op|'('
name|'lambda'
op|':'
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'call'
op|'.'
name|'clock'
op|','
name|'reactor'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_callbackTimeSkips
dedent|''
name|'def'
name|'test_callbackTimeSkips'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When more time than the defined interval passes during the execution\n        of a callback, L{LoopingCall} should schedule the next call for the\n        next interval which is still in the future.\n        """'
newline|'\n'
name|'times'
op|'='
op|'['
op|']'
newline|'\n'
name|'callDuration'
op|'='
name|'None'
newline|'\n'
name|'clock'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
DECL|function|aCallback
name|'def'
name|'aCallback'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'times'
op|'.'
name|'append'
op|'('
name|'clock'
op|'.'
name|'seconds'
op|'('
op|')'
op|')'
newline|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
name|'callDuration'
op|')'
newline|'\n'
dedent|''
name|'call'
op|'='
name|'task'
op|'.'
name|'LoopingCall'
op|'('
name|'aCallback'
op|')'
newline|'\n'
name|'call'
op|'.'
name|'clock'
op|'='
name|'clock'
newline|'\n'
nl|'\n'
comment|'# Start a LoopingCall with a 0.5 second increment, and immediately call'
nl|'\n'
comment|'# the callable.'
nl|'\n'
name|'callDuration'
op|'='
number|'2'
newline|'\n'
name|'call'
op|'.'
name|'start'
op|'('
number|'0.5'
op|')'
newline|'\n'
nl|'\n'
comment|'# Verify that the callable was called, and since it was immediate, with'
nl|'\n'
comment|'# no skips.'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'times'
op|','
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# The callback should have advanced the clock by the callDuration.'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'clock'
op|'.'
name|'seconds'
op|'('
op|')'
op|','
name|'callDuration'
op|')'
newline|'\n'
nl|'\n'
comment|'# An iteration should have occurred at 2, but since 2 is the present'
nl|'\n'
comment|'# and not the future, it is skipped.'
nl|'\n'
nl|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'times'
op|','
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# 2.5 is in the future, and is not skipped.'
nl|'\n'
name|'callDuration'
op|'='
number|'1'
newline|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
number|'0.5'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'times'
op|','
op|'['
number|'0'
op|','
number|'2.5'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'clock'
op|'.'
name|'seconds'
op|'('
op|')'
op|','
number|'3.5'
op|')'
newline|'\n'
nl|'\n'
comment|'# Another iteration should have occurred, but it is again the'
nl|'\n'
comment|'# present and not the future, so it is skipped as well.'
nl|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'times'
op|','
op|'['
number|'0'
op|','
number|'2.5'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# 4 is in the future, and is not skipped.'
nl|'\n'
name|'callDuration'
op|'='
number|'0'
newline|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
number|'0.5'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'times'
op|','
op|'['
number|'0'
op|','
number|'2.5'
op|','
number|'4'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'clock'
op|'.'
name|'seconds'
op|'('
op|')'
op|','
number|'4'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_reactorTimeSkips
dedent|''
name|'def'
name|'test_reactorTimeSkips'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When more time than the defined interval passes between when\n        L{LoopingCall} schedules itself to run again and when it actually\n        runs again, it should schedule the next call for the next interval\n        which is still in the future.\n        """'
newline|'\n'
name|'times'
op|'='
op|'['
op|']'
newline|'\n'
name|'clock'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
DECL|function|aCallback
name|'def'
name|'aCallback'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'times'
op|'.'
name|'append'
op|'('
name|'clock'
op|'.'
name|'seconds'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Start a LoopingCall that tracks the time passed, with a 0.5 second'
nl|'\n'
comment|'# increment.'
nl|'\n'
dedent|''
name|'call'
op|'='
name|'task'
op|'.'
name|'LoopingCall'
op|'('
name|'aCallback'
op|')'
newline|'\n'
name|'call'
op|'.'
name|'clock'
op|'='
name|'clock'
newline|'\n'
name|'call'
op|'.'
name|'start'
op|'('
number|'0.5'
op|')'
newline|'\n'
nl|'\n'
comment|'# Initially, no time should have passed!'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'times'
op|','
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Advance the clock by 2 seconds (2 seconds should have passed)'
nl|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
number|'2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'times'
op|','
op|'['
number|'0'
op|','
number|'2'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Advance the clock by 1 second (3 total should have passed)'
nl|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'times'
op|','
op|'['
number|'0'
op|','
number|'2'
op|','
number|'3'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Advance the clock by 0 seconds (this should have no effect!)'
nl|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'times'
op|','
op|'['
number|'0'
op|','
number|'2'
op|','
number|'3'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_reactorTimeCountSkips
dedent|''
name|'def'
name|'test_reactorTimeCountSkips'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When L{LoopingCall} schedules itself to run again, if more than the\n        specified interval has passed, it should schedule the next call for the\n        next interval which is still in the future. If it was created\n        using L{LoopingCall.withCount}, a positional argument will be\n        inserted at the beginning of the argument list, indicating the number\n        of calls that should have been made. \n        """'
newline|'\n'
name|'times'
op|'='
op|'['
op|']'
newline|'\n'
name|'clock'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
DECL|function|aCallback
name|'def'
name|'aCallback'
op|'('
name|'numCalls'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'times'
op|'.'
name|'append'
op|'('
op|'('
name|'clock'
op|'.'
name|'seconds'
op|'('
op|')'
op|','
name|'numCalls'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Start a LoopingCall that tracks the time passed, and the number of'
nl|'\n'
comment|'# skips, with a 0.5 second increment.'
nl|'\n'
dedent|''
name|'call'
op|'='
name|'task'
op|'.'
name|'LoopingCall'
op|'.'
name|'withCount'
op|'('
name|'aCallback'
op|')'
newline|'\n'
name|'call'
op|'.'
name|'clock'
op|'='
name|'clock'
newline|'\n'
name|'INTERVAL'
op|'='
number|'0.5'
newline|'\n'
name|'REALISTIC_DELAY'
op|'='
number|'0.01'
newline|'\n'
name|'call'
op|'.'
name|'start'
op|'('
name|'INTERVAL'
op|')'
newline|'\n'
nl|'\n'
comment|'# Initially, no seconds should have passed, and one calls should have'
nl|'\n'
comment|'# been made.'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'times'
op|','
op|'['
op|'('
number|'0'
op|','
number|'1'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# After the interval (plus a small delay, to account for the time that'
nl|'\n'
comment|'# the reactor takes to wake up and process the LoopingCall), we should'
nl|'\n'
comment|'# still have only made one call.'
nl|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
name|'INTERVAL'
op|'+'
name|'REALISTIC_DELAY'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'times'
op|','
op|'['
op|'('
number|'0'
op|','
number|'1'
op|')'
op|','
op|'('
name|'INTERVAL'
op|'+'
name|'REALISTIC_DELAY'
op|','
number|'1'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# After advancing the clock by three intervals (plus a small delay to'
nl|'\n'
comment|'# account for the reactor), we should have skipped two calls; one less'
nl|'\n'
comment|'# than the number of intervals which have completely elapsed. Along'
nl|'\n'
comment|'# with the call we did actually make, the final number of calls is 3.'
nl|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
op|'('
number|'3'
op|'*'
name|'INTERVAL'
op|')'
op|'+'
name|'REALISTIC_DELAY'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'times'
op|','
nl|'\n'
op|'['
op|'('
number|'0'
op|','
number|'1'
op|')'
op|','
op|'('
name|'INTERVAL'
op|'+'
name|'REALISTIC_DELAY'
op|','
number|'1'
op|')'
op|','
nl|'\n'
op|'('
op|'('
number|'4'
op|'*'
name|'INTERVAL'
op|')'
op|'+'
op|'('
number|'2'
op|'*'
name|'REALISTIC_DELAY'
op|')'
op|','
number|'3'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Advancing the clock by 0 seconds should not cause any changes!'
nl|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'times'
op|','
nl|'\n'
op|'['
op|'('
number|'0'
op|','
number|'1'
op|')'
op|','
op|'('
name|'INTERVAL'
op|'+'
name|'REALISTIC_DELAY'
op|','
number|'1'
op|')'
op|','
nl|'\n'
op|'('
op|'('
number|'4'
op|'*'
name|'INTERVAL'
op|')'
op|'+'
op|'('
number|'2'
op|'*'
name|'REALISTIC_DELAY'
op|')'
op|','
number|'3'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_countLengthyIntervalCounts
dedent|''
name|'def'
name|'test_countLengthyIntervalCounts'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{LoopingCall.withCount} counts only calls that were expected to be\n        made.  So, if more than one, but less than two intervals pass between\n        invocations, it won\'t increase the count above 1.  For example, a\n        L{LoopingCall} with interval T expects to be invoked at T, 2T, 3T, etc.\n        However, the reactor takes some time to get around to calling it, so in\n        practice it will be called at T+something, 2T+something, 3T+something;\n        and due to other things going on in the reactor, "something" is\n        variable.  It won\'t increase the count unless "something" is greater\n        than T.  So if the L{LoopingCall} is invoked at T, 2.75T, and 3T,\n        the count has not increased, even though the distance between\n        invocation 1 and invocation 2 is 1.75T.\n        """'
newline|'\n'
name|'times'
op|'='
op|'['
op|']'
newline|'\n'
name|'clock'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
DECL|function|aCallback
name|'def'
name|'aCallback'
op|'('
name|'count'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'times'
op|'.'
name|'append'
op|'('
op|'('
name|'clock'
op|'.'
name|'seconds'
op|'('
op|')'
op|','
name|'count'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Start a LoopingCall that tracks the time passed, and the number of'
nl|'\n'
comment|'# calls, with a 0.5 second increment.'
nl|'\n'
dedent|''
name|'call'
op|'='
name|'task'
op|'.'
name|'LoopingCall'
op|'.'
name|'withCount'
op|'('
name|'aCallback'
op|')'
newline|'\n'
name|'call'
op|'.'
name|'clock'
op|'='
name|'clock'
newline|'\n'
name|'INTERVAL'
op|'='
number|'0.5'
newline|'\n'
name|'REALISTIC_DELAY'
op|'='
number|'0.01'
newline|'\n'
name|'call'
op|'.'
name|'start'
op|'('
name|'INTERVAL'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'times'
op|'.'
name|'pop'
op|'('
op|')'
op|','
op|'('
number|'0'
op|','
number|'1'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# About one interval... So far, so good'
nl|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
name|'INTERVAL'
op|'+'
name|'REALISTIC_DELAY'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'times'
op|'.'
name|'pop'
op|'('
op|')'
op|','
op|'('
name|'INTERVAL'
op|'+'
name|'REALISTIC_DELAY'
op|','
number|'1'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Oh no, something delayed us for a while.'
nl|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
name|'INTERVAL'
op|'*'
number|'1.75'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'times'
op|'.'
name|'pop'
op|'('
op|')'
op|','
op|'('
op|'('
number|'2.75'
op|'*'
name|'INTERVAL'
op|')'
op|'+'
name|'REALISTIC_DELAY'
op|','
number|'1'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Back on track!  We got invoked when we expected this time.'
nl|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
name|'INTERVAL'
op|'*'
number|'0.25'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'times'
op|'.'
name|'pop'
op|'('
op|')'
op|','
op|'('
op|'('
number|'3.0'
op|'*'
name|'INTERVAL'
op|')'
op|'+'
name|'REALISTIC_DELAY'
op|','
number|'1'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testBasicFunction
dedent|''
name|'def'
name|'testBasicFunction'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# Arrange to have time advanced enough so that our function is'
nl|'\n'
comment|'# called a few times.'
nl|'\n'
comment|'# Only need to go to 2.5 to get 3 calls, since the first call'
nl|'\n'
comment|'# happens before any time has elapsed.'
nl|'\n'
indent|'        '
name|'timings'
op|'='
op|'['
number|'0.05'
op|','
number|'0.1'
op|','
number|'0.1'
op|']'
newline|'\n'
nl|'\n'
name|'clock'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'L'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|foo
name|'def'
name|'foo'
op|'('
name|'a'
op|','
name|'b'
op|','
name|'c'
op|'='
name|'None'
op|','
name|'d'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'L'
op|'.'
name|'append'
op|'('
op|'('
name|'a'
op|','
name|'b'
op|','
name|'c'
op|','
name|'d'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'lc'
op|'='
name|'TestableLoopingCall'
op|'('
name|'clock'
op|','
name|'foo'
op|','
string|'"a"'
op|','
string|'"b"'
op|','
name|'d'
op|'='
string|'"d"'
op|')'
newline|'\n'
name|'D'
op|'='
name|'lc'
op|'.'
name|'start'
op|'('
number|'0.1'
op|')'
newline|'\n'
nl|'\n'
name|'theResult'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|saveResult
name|'def'
name|'saveResult'
op|'('
name|'result'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'theResult'
op|'.'
name|'append'
op|'('
name|'result'
op|')'
newline|'\n'
dedent|''
name|'D'
op|'.'
name|'addCallback'
op|'('
name|'saveResult'
op|')'
newline|'\n'
nl|'\n'
name|'clock'
op|'.'
name|'pump'
op|'('
name|'timings'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'L'
op|')'
op|','
number|'3'
op|','
nl|'\n'
string|'"got %d iterations, not 3"'
op|'%'
op|'('
name|'len'
op|'('
name|'L'
op|')'
op|','
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'for'
op|'('
name|'a'
op|','
name|'b'
op|','
name|'c'
op|','
name|'d'
op|')'
name|'in'
name|'L'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'a'
op|','
string|'"a"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'b'
op|','
string|'"b"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'c'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'d'
op|','
string|'"d"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'lc'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'theResult'
op|'['
number|'0'
op|']'
op|','
name|'lc'
op|')'
newline|'\n'
nl|'\n'
comment|"# Make sure it isn't planning to do anything further."
nl|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'clock'
op|'.'
name|'calls'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testDelayedStart
dedent|''
name|'def'
name|'testDelayedStart'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'timings'
op|'='
op|'['
number|'0.05'
op|','
number|'0.1'
op|','
number|'0.1'
op|']'
newline|'\n'
nl|'\n'
name|'clock'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'L'
op|'='
op|'['
op|']'
newline|'\n'
name|'lc'
op|'='
name|'TestableLoopingCall'
op|'('
name|'clock'
op|','
name|'L'
op|'.'
name|'append'
op|','
name|'None'
op|')'
newline|'\n'
name|'d'
op|'='
name|'lc'
op|'.'
name|'start'
op|'('
number|'0.1'
op|','
name|'now'
op|'='
name|'False'
op|')'
newline|'\n'
nl|'\n'
name|'theResult'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|saveResult
name|'def'
name|'saveResult'
op|'('
name|'result'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'theResult'
op|'.'
name|'append'
op|'('
name|'result'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'saveResult'
op|')'
newline|'\n'
nl|'\n'
name|'clock'
op|'.'
name|'pump'
op|'('
name|'timings'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'L'
op|')'
op|','
number|'2'
op|','
nl|'\n'
string|'"got %d iterations, not 2"'
op|'%'
op|'('
name|'len'
op|'('
name|'L'
op|')'
op|','
op|')'
op|')'
newline|'\n'
name|'lc'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'theResult'
op|'['
number|'0'
op|']'
op|','
name|'lc'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'clock'
op|'.'
name|'calls'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testBadDelay
dedent|''
name|'def'
name|'testBadDelay'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'lc'
op|'='
name|'task'
op|'.'
name|'LoopingCall'
op|'('
name|'lambda'
op|':'
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'ValueError'
op|','
name|'lc'
op|'.'
name|'start'
op|','
op|'-'
number|'1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# Make sure that LoopingCall.stop() prevents any subsequent calls.'
nl|'\n'
DECL|member|_stoppingTest
dedent|''
name|'def'
name|'_stoppingTest'
op|'('
name|'self'
op|','
name|'delay'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'ran'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|foo
name|'def'
name|'foo'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'ran'
op|'.'
name|'append'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'clock'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
name|'lc'
op|'='
name|'TestableLoopingCall'
op|'('
name|'clock'
op|','
name|'foo'
op|')'
newline|'\n'
name|'d'
op|'='
name|'lc'
op|'.'
name|'start'
op|'('
name|'delay'
op|','
name|'now'
op|'='
name|'False'
op|')'
newline|'\n'
name|'lc'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'ran'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'clock'
op|'.'
name|'calls'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testStopAtOnce
dedent|''
name|'def'
name|'testStopAtOnce'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_stoppingTest'
op|'('
number|'0'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testStoppingBeforeDelayedStart
dedent|''
name|'def'
name|'testStoppingBeforeDelayedStart'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_stoppingTest'
op|'('
number|'10'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ReactorLoopTestCase
dedent|''
dedent|''
name|'class'
name|'ReactorLoopTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
comment|'# Slightly inferior tests which exercise interactions with an actual'
nl|'\n'
comment|'# reactor.'
nl|'\n'
DECL|member|testFailure
indent|'    '
name|'def'
name|'testFailure'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
DECL|function|foo
indent|'        '
name|'def'
name|'foo'
op|'('
name|'x'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'TestException'
op|'('
name|'x'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'lc'
op|'='
name|'task'
op|'.'
name|'LoopingCall'
op|'('
name|'foo'
op|','
string|'"bar"'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'lc'
op|'.'
name|'start'
op|'('
number|'0.1'
op|')'
op|','
name|'TestException'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testFailAndStop
dedent|''
name|'def'
name|'testFailAndStop'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
DECL|function|foo
indent|'        '
name|'def'
name|'foo'
op|'('
name|'x'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'lc'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
name|'raise'
name|'TestException'
op|'('
name|'x'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'lc'
op|'='
name|'task'
op|'.'
name|'LoopingCall'
op|'('
name|'foo'
op|','
string|'"bar"'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'lc'
op|'.'
name|'start'
op|'('
number|'0.1'
op|')'
op|','
name|'TestException'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testEveryIteration
dedent|''
name|'def'
name|'testEveryIteration'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'ran'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|function|foo
name|'def'
name|'foo'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'ran'
op|'.'
name|'append'
op|'('
name|'None'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'ran'
op|')'
op|'>'
number|'5'
op|':'
newline|'\n'
indent|'                '
name|'lc'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'lc'
op|'='
name|'task'
op|'.'
name|'LoopingCall'
op|'('
name|'foo'
op|')'
newline|'\n'
name|'d'
op|'='
name|'lc'
op|'.'
name|'start'
op|'('
number|'0'
op|')'
newline|'\n'
DECL|function|stopped
name|'def'
name|'stopped'
op|'('
name|'ign'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'ran'
op|')'
op|','
number|'6'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'stopped'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testStopAtOnceLater
dedent|''
name|'def'
name|'testStopAtOnceLater'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# Ensure that even when LoopingCall.stop() is called from a'
nl|'\n'
comment|'# reactor callback, it still prevents any subsequent calls.'
nl|'\n'
indent|'        '
name|'d'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
DECL|function|foo
name|'def'
name|'foo'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'.'
name|'errback'
op|'('
name|'failure'
op|'.'
name|'DefaultException'
op|'('
nl|'\n'
string|'"This task also should never get called."'
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_lc'
op|'='
name|'task'
op|'.'
name|'LoopingCall'
op|'('
name|'foo'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_lc'
op|'.'
name|'start'
op|'('
number|'1'
op|','
name|'now'
op|'='
name|'False'
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'self'
op|'.'
name|'_callback_for_testStopAtOnceLater'
op|','
name|'d'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_callback_for_testStopAtOnceLater
dedent|''
name|'def'
name|'_callback_for_testStopAtOnceLater'
op|'('
name|'self'
op|','
name|'d'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_lc'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'d'
op|'.'
name|'callback'
op|','
string|'"success"'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testWaitDeferred
dedent|''
name|'def'
name|'testWaitDeferred'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|"# Tests if the callable isn't scheduled again before the returned"
nl|'\n'
comment|'# deferred has fired.'
nl|'\n'
indent|'        '
name|'timings'
op|'='
op|'['
number|'0.2'
op|','
number|'0.8'
op|']'
newline|'\n'
name|'clock'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|foo
name|'def'
name|'foo'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'lambda'
name|'_'
op|':'
name|'lc'
op|'.'
name|'stop'
op|'('
op|')'
op|')'
newline|'\n'
name|'clock'
op|'.'
name|'callLater'
op|'('
number|'1'
op|','
name|'d'
op|'.'
name|'callback'
op|','
name|'None'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
dedent|''
name|'lc'
op|'='
name|'TestableLoopingCall'
op|'('
name|'clock'
op|','
name|'foo'
op|')'
newline|'\n'
name|'d'
op|'='
name|'lc'
op|'.'
name|'start'
op|'('
number|'0.2'
op|')'
newline|'\n'
name|'clock'
op|'.'
name|'pump'
op|'('
name|'timings'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'clock'
op|'.'
name|'calls'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testFailurePropagation
dedent|''
name|'def'
name|'testFailurePropagation'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# Tests if the failure of the errback of the deferred returned by the'
nl|'\n'
comment|'# callable is propagated to the lc errback.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# To make sure this test does not hang trial when LoopingCall does not'
nl|'\n'
comment|"# wait for the callable's deferred, it also checks there are no"
nl|'\n'
comment|"# calls in the clock's callLater queue."
nl|'\n'
indent|'        '
name|'timings'
op|'='
op|'['
number|'0.3'
op|']'
newline|'\n'
name|'clock'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|foo
name|'def'
name|'foo'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'clock'
op|'.'
name|'callLater'
op|'('
number|'0.3'
op|','
name|'d'
op|'.'
name|'errback'
op|','
name|'TestException'
op|'('
op|')'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
dedent|''
name|'lc'
op|'='
name|'TestableLoopingCall'
op|'('
name|'clock'
op|','
name|'foo'
op|')'
newline|'\n'
name|'d'
op|'='
name|'lc'
op|'.'
name|'start'
op|'('
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'TestException'
op|')'
newline|'\n'
nl|'\n'
name|'clock'
op|'.'
name|'pump'
op|'('
name|'timings'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'clock'
op|'.'
name|'calls'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_deferredWithCount
dedent|''
name|'def'
name|'test_deferredWithCount'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        In the case that the function passed to L{LoopingCall.withCount}\n        returns a deferred, which does not fire before the next interval\n        elapses, the function should not be run again. And if a function call\n        is skipped in this fashion, the appropriate count should be\n        provided.\n        """'
newline|'\n'
name|'testClock'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
name|'d'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'deferredCounts'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|function|countTracker
name|'def'
name|'countTracker'
op|'('
name|'possibleCount'
op|')'
op|':'
newline|'\n'
comment|'# Keep a list of call counts'
nl|'\n'
indent|'            '
name|'deferredCounts'
op|'.'
name|'append'
op|'('
name|'possibleCount'
op|')'
newline|'\n'
comment|'# Return a deferred, but only on the first request'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'deferredCounts'
op|')'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'d'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
comment|'# Start a looping call for our countTracker function'
nl|'\n'
comment|'# Set the increment to 0.2, and do not call the function on startup.'
nl|'\n'
dedent|''
dedent|''
name|'lc'
op|'='
name|'task'
op|'.'
name|'LoopingCall'
op|'.'
name|'withCount'
op|'('
name|'countTracker'
op|')'
newline|'\n'
name|'lc'
op|'.'
name|'clock'
op|'='
name|'testClock'
newline|'\n'
name|'d'
op|'='
name|'lc'
op|'.'
name|'start'
op|'('
number|'0.2'
op|','
name|'now'
op|'='
name|'False'
op|')'
newline|'\n'
nl|'\n'
comment|'# Confirm that nothing has happened yet.'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'deferredCounts'
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Advance the clock by 0.2 and then 0.4;'
nl|'\n'
name|'testClock'
op|'.'
name|'pump'
op|'('
op|'['
number|'0.2'
op|','
number|'0.4'
op|']'
op|')'
newline|'\n'
comment|'# We should now have exactly one count (of 1 call)'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'deferredCounts'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
comment|'# Fire the deferred, and advance the clock by another 0.2'
nl|'\n'
name|'d'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
name|'testClock'
op|'.'
name|'pump'
op|'('
op|'['
number|'0.2'
op|']'
op|')'
newline|'\n'
comment|'# We should now have exactly 2 counts...'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'deferredCounts'
op|')'
op|','
number|'2'
op|')'
newline|'\n'
comment|'# The first count should be 1 (one call)'
nl|'\n'
comment|'# The second count should be 3 (calls were missed at about 0.6 and 0.8)'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'deferredCounts'
op|','
op|'['
number|'1'
op|','
number|'3'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DeferLaterTests
dedent|''
dedent|''
name|'class'
name|'DeferLaterTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{task.deferLater}.\n    """'
newline|'\n'
DECL|member|test_callback
name|'def'
name|'test_callback'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The L{Deferred} returned by L{task.deferLater} is called back after\n        the specified delay with the result of the function passed in.\n        """'
newline|'\n'
name|'results'
op|'='
op|'['
op|']'
newline|'\n'
name|'flag'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
DECL|function|callable
name|'def'
name|'callable'
op|'('
name|'foo'
op|','
name|'bar'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'results'
op|'.'
name|'append'
op|'('
op|'('
name|'foo'
op|','
name|'bar'
op|')'
op|')'
newline|'\n'
name|'return'
name|'flag'
newline|'\n'
nl|'\n'
dedent|''
name|'clock'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
name|'d'
op|'='
name|'task'
op|'.'
name|'deferLater'
op|'('
name|'clock'
op|','
number|'3'
op|','
name|'callable'
op|','
string|"'foo'"
op|','
name|'bar'
op|'='
string|"'bar'"
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'assertIdentical'
op|','
name|'flag'
op|')'
newline|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
number|'2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'results'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'results'
op|','
op|'['
op|'('
string|"'foo'"
op|','
string|"'bar'"
op|')'
op|']'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_errback
dedent|''
name|'def'
name|'test_errback'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The L{Deferred} returned by L{task.deferLater} is errbacked if the\n        supplied function raises an exception.\n        """'
newline|'\n'
DECL|function|callable
name|'def'
name|'callable'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'TestException'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'clock'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
name|'d'
op|'='
name|'task'
op|'.'
name|'deferLater'
op|'('
name|'clock'
op|','
number|'1'
op|','
name|'callable'
op|')'
newline|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
number|'1'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'TestException'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
