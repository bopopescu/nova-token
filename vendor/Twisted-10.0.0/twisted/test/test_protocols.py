begin_unit
comment|'# Copyright (c) 2001-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTest cases for twisted.protocols package.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'struct'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'protocols'
name|'import'
name|'basic'
op|','
name|'wire'
op|','
name|'portforward'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'reactor'
op|','
name|'protocol'
op|','
name|'defer'
op|','
name|'task'
op|','
name|'error'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'test'
name|'import'
name|'proto_helpers'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|LineTester
name|'class'
name|'LineTester'
op|'('
name|'basic'
op|'.'
name|'LineReceiver'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A line receiver that parses data received and make actions on some tokens.\n\n    @type delimiter: C{str}\n    @ivar delimiter: character used between received lines.\n    @type MAX_LENGTH: C{int}\n    @ivar MAX_LENGTH: size of a line when C{lineLengthExceeded} will be called.\n    @type clock: L{twisted.internet.task.Clock}\n    @ivar clock: clock simulating reactor callLater. Pass it to constructor if\n        you want to use the pause/rawpause functionalities.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|delimiter
name|'delimiter'
op|'='
string|"'\\n'"
newline|'\n'
DECL|variable|MAX_LENGTH
name|'MAX_LENGTH'
op|'='
number|'64'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'clock'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If given, use a clock to make callLater calls.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'clock'
op|'='
name|'clock'
newline|'\n'
nl|'\n'
DECL|member|connectionMade
dedent|''
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create/clean data received on connection.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'received'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|lineReceived
dedent|''
name|'def'
name|'lineReceived'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Receive line and make some action for some tokens: pause, rawpause,\n        stop, len, produce, unproduce.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'received'
op|'.'
name|'append'
op|'('
name|'line'
op|')'
newline|'\n'
name|'if'
name|'line'
op|'=='
string|"''"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'setRawMode'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'line'
op|'=='
string|"'pause'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'pauseProducing'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'clock'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'self'
op|'.'
name|'resumeProducing'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'line'
op|'=='
string|"'rawpause'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'pauseProducing'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'setRawMode'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'received'
op|'.'
name|'append'
op|'('
string|"''"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'clock'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'self'
op|'.'
name|'resumeProducing'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'line'
op|'=='
string|"'stop'"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'stopProducing'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'line'
op|'['
op|':'
number|'4'
op|']'
op|'=='
string|"'len '"
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'length'
op|'='
name|'int'
op|'('
name|'line'
op|'['
number|'4'
op|':'
op|']'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'line'
op|'.'
name|'startswith'
op|'('
string|"'produce'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'registerProducer'
op|'('
name|'self'
op|','
name|'False'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'line'
op|'.'
name|'startswith'
op|'('
string|"'unproduce'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'unregisterProducer'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|rawDataReceived
dedent|''
dedent|''
name|'def'
name|'rawDataReceived'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Read raw data, until the quantity specified by a previous \'len\' line is\n        reached.\n        """'
newline|'\n'
name|'data'
op|','
name|'rest'
op|'='
name|'data'
op|'['
op|':'
name|'self'
op|'.'
name|'length'
op|']'
op|','
name|'data'
op|'['
name|'self'
op|'.'
name|'length'
op|':'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'length'
op|'='
name|'self'
op|'.'
name|'length'
op|'-'
name|'len'
op|'('
name|'data'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'received'
op|'['
op|'-'
number|'1'
op|']'
op|'='
name|'self'
op|'.'
name|'received'
op|'['
op|'-'
number|'1'
op|']'
op|'+'
name|'data'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'length'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'setLineMode'
op|'('
name|'rest'
op|')'
newline|'\n'
nl|'\n'
DECL|member|lineLengthExceeded
dedent|''
dedent|''
name|'def'
name|'lineLengthExceeded'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Adjust line mode when long lines received.\n        """'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'line'
op|')'
op|'>'
name|'self'
op|'.'
name|'MAX_LENGTH'
op|'+'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'setLineMode'
op|'('
name|'line'
op|'['
name|'self'
op|'.'
name|'MAX_LENGTH'
op|'+'
number|'1'
op|':'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|LineOnlyTester
dedent|''
dedent|''
dedent|''
name|'class'
name|'LineOnlyTester'
op|'('
name|'basic'
op|'.'
name|'LineOnlyReceiver'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A buffering line only receiver.\n    """'
newline|'\n'
DECL|variable|delimiter
name|'delimiter'
op|'='
string|"'\\n'"
newline|'\n'
DECL|variable|MAX_LENGTH
name|'MAX_LENGTH'
op|'='
number|'64'
newline|'\n'
nl|'\n'
DECL|member|connectionMade
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create/clean data received on connection.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'received'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|lineReceived
dedent|''
name|'def'
name|'lineReceived'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Save received data.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'received'
op|'.'
name|'append'
op|'('
name|'line'
op|')'
newline|'\n'
nl|'\n'
DECL|class|WireTestCase
dedent|''
dedent|''
name|'class'
name|'WireTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test wire protocols.\n    """'
newline|'\n'
DECL|member|test_echo
name|'def'
name|'test_echo'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test wire.Echo protocol: send some data and check it send it back.\n        """'
newline|'\n'
name|'t'
op|'='
name|'proto_helpers'
op|'.'
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'a'
op|'='
name|'wire'
op|'.'
name|'Echo'
op|'('
op|')'
newline|'\n'
name|'a'
op|'.'
name|'makeConnection'
op|'('
name|'t'
op|')'
newline|'\n'
name|'a'
op|'.'
name|'dataReceived'
op|'('
string|'"hello"'
op|')'
newline|'\n'
name|'a'
op|'.'
name|'dataReceived'
op|'('
string|'"world"'
op|')'
newline|'\n'
name|'a'
op|'.'
name|'dataReceived'
op|'('
string|'"how"'
op|')'
newline|'\n'
name|'a'
op|'.'
name|'dataReceived'
op|'('
string|'"are"'
op|')'
newline|'\n'
name|'a'
op|'.'
name|'dataReceived'
op|'('
string|'"you"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'t'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|'"helloworldhowareyou"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_who
dedent|''
name|'def'
name|'test_who'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test wire.Who protocol.\n        """'
newline|'\n'
name|'t'
op|'='
name|'proto_helpers'
op|'.'
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'a'
op|'='
name|'wire'
op|'.'
name|'Who'
op|'('
op|')'
newline|'\n'
name|'a'
op|'.'
name|'makeConnection'
op|'('
name|'t'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'t'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|'"root\\r\\n"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_QOTD
dedent|''
name|'def'
name|'test_QOTD'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test wire.QOTD protocol.\n        """'
newline|'\n'
name|'t'
op|'='
name|'proto_helpers'
op|'.'
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'a'
op|'='
name|'wire'
op|'.'
name|'QOTD'
op|'('
op|')'
newline|'\n'
name|'a'
op|'.'
name|'makeConnection'
op|'('
name|'t'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'t'
op|'.'
name|'value'
op|'('
op|')'
op|','
nl|'\n'
string|'"An apple a day keeps the doctor away.\\r\\n"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_discard
dedent|''
name|'def'
name|'test_discard'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test wire.Discard protocol.\n        """'
newline|'\n'
name|'t'
op|'='
name|'proto_helpers'
op|'.'
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'a'
op|'='
name|'wire'
op|'.'
name|'Discard'
op|'('
op|')'
newline|'\n'
name|'a'
op|'.'
name|'makeConnection'
op|'('
name|'t'
op|')'
newline|'\n'
name|'a'
op|'.'
name|'dataReceived'
op|'('
string|'"hello"'
op|')'
newline|'\n'
name|'a'
op|'.'
name|'dataReceived'
op|'('
string|'"world"'
op|')'
newline|'\n'
name|'a'
op|'.'
name|'dataReceived'
op|'('
string|'"how"'
op|')'
newline|'\n'
name|'a'
op|'.'
name|'dataReceived'
op|'('
string|'"are"'
op|')'
newline|'\n'
name|'a'
op|'.'
name|'dataReceived'
op|'('
string|'"you"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'t'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|'""'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|LineReceiverTestCase
dedent|''
dedent|''
name|'class'
name|'LineReceiverTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test LineReceiver, using the C{LineTester} wrapper.\n    """'
newline|'\n'
name|'buffer'
op|'='
string|"'''\\\nlen 10\n\n0123456789len 5\n\n1234\nlen 20\nfoo 123\n\n0123456789\n012345678len 0\nfoo 5\n\n1234567890123456789012345678901234567890123456789012345678901234567890\nlen 1\n\na'''"
newline|'\n'
nl|'\n'
DECL|variable|output
name|'output'
op|'='
op|'['
string|"'len 10'"
op|','
string|"'0123456789'"
op|','
string|"'len 5'"
op|','
string|"'1234\\n'"
op|','
nl|'\n'
string|"'len 20'"
op|','
string|"'foo 123'"
op|','
string|"'0123456789\\n012345678'"
op|','
nl|'\n'
string|"'len 0'"
op|','
string|"'foo 5'"
op|','
string|"''"
op|','
string|"'67890'"
op|','
string|"'len 1'"
op|','
string|"'a'"
op|']'
newline|'\n'
nl|'\n'
DECL|member|testBuffer
name|'def'
name|'testBuffer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test buffering for different packet size, checking received matches\n        expected data.\n        """'
newline|'\n'
name|'for'
name|'packet_size'
name|'in'
name|'range'
op|'('
number|'1'
op|','
number|'10'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'t'
op|'='
name|'proto_helpers'
op|'.'
name|'StringIOWithoutClosing'
op|'('
op|')'
newline|'\n'
name|'a'
op|'='
name|'LineTester'
op|'('
op|')'
newline|'\n'
name|'a'
op|'.'
name|'makeConnection'
op|'('
name|'protocol'
op|'.'
name|'FileWrapper'
op|'('
name|'t'
op|')'
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'buffer'
op|')'
op|'/'
name|'packet_size'
op|'+'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'s'
op|'='
name|'self'
op|'.'
name|'buffer'
op|'['
name|'i'
op|'*'
name|'packet_size'
op|':'
op|'('
name|'i'
op|'+'
number|'1'
op|')'
op|'*'
name|'packet_size'
op|']'
newline|'\n'
name|'a'
op|'.'
name|'dataReceived'
op|'('
name|'s'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'self'
op|'.'
name|'output'
op|','
name|'a'
op|'.'
name|'received'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|pause_buf
dedent|''
dedent|''
name|'pause_buf'
op|'='
string|"'twiddle1\\ntwiddle2\\npause\\ntwiddle3\\n'"
newline|'\n'
nl|'\n'
DECL|variable|pause_output1
name|'pause_output1'
op|'='
op|'['
string|"'twiddle1'"
op|','
string|"'twiddle2'"
op|','
string|"'pause'"
op|']'
newline|'\n'
DECL|variable|pause_output2
name|'pause_output2'
op|'='
name|'pause_output1'
op|'+'
op|'['
string|"'twiddle3'"
op|']'
newline|'\n'
nl|'\n'
DECL|member|test_pausing
name|'def'
name|'test_pausing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test pause inside data receiving. It uses fake clock to see if\n        pausing/resuming work.\n        """'
newline|'\n'
name|'for'
name|'packet_size'
name|'in'
name|'range'
op|'('
number|'1'
op|','
number|'10'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'t'
op|'='
name|'proto_helpers'
op|'.'
name|'StringIOWithoutClosing'
op|'('
op|')'
newline|'\n'
name|'clock'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
name|'a'
op|'='
name|'LineTester'
op|'('
name|'clock'
op|')'
newline|'\n'
name|'a'
op|'.'
name|'makeConnection'
op|'('
name|'protocol'
op|'.'
name|'FileWrapper'
op|'('
name|'t'
op|')'
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'pause_buf'
op|')'
op|'/'
name|'packet_size'
op|'+'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'s'
op|'='
name|'self'
op|'.'
name|'pause_buf'
op|'['
name|'i'
op|'*'
name|'packet_size'
op|':'
op|'('
name|'i'
op|'+'
number|'1'
op|')'
op|'*'
name|'packet_size'
op|']'
newline|'\n'
name|'a'
op|'.'
name|'dataReceived'
op|'('
name|'s'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'pause_output1'
op|','
name|'a'
op|'.'
name|'received'
op|')'
newline|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'pause_output2'
op|','
name|'a'
op|'.'
name|'received'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|rawpause_buf
dedent|''
dedent|''
name|'rawpause_buf'
op|'='
string|"'twiddle1\\ntwiddle2\\nlen 5\\nrawpause\\n12345twiddle3\\n'"
newline|'\n'
nl|'\n'
DECL|variable|rawpause_output1
name|'rawpause_output1'
op|'='
op|'['
string|"'twiddle1'"
op|','
string|"'twiddle2'"
op|','
string|"'len 5'"
op|','
string|"'rawpause'"
op|','
string|"''"
op|']'
newline|'\n'
DECL|variable|rawpause_output2
name|'rawpause_output2'
op|'='
op|'['
string|"'twiddle1'"
op|','
string|"'twiddle2'"
op|','
string|"'len 5'"
op|','
string|"'rawpause'"
op|','
string|"'12345'"
op|','
nl|'\n'
string|"'twiddle3'"
op|']'
newline|'\n'
nl|'\n'
DECL|member|test_rawPausing
name|'def'
name|'test_rawPausing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test pause inside raw date receiving.\n        """'
newline|'\n'
name|'for'
name|'packet_size'
name|'in'
name|'range'
op|'('
number|'1'
op|','
number|'10'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'t'
op|'='
name|'proto_helpers'
op|'.'
name|'StringIOWithoutClosing'
op|'('
op|')'
newline|'\n'
name|'clock'
op|'='
name|'task'
op|'.'
name|'Clock'
op|'('
op|')'
newline|'\n'
name|'a'
op|'='
name|'LineTester'
op|'('
name|'clock'
op|')'
newline|'\n'
name|'a'
op|'.'
name|'makeConnection'
op|'('
name|'protocol'
op|'.'
name|'FileWrapper'
op|'('
name|'t'
op|')'
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'rawpause_buf'
op|')'
op|'/'
name|'packet_size'
op|'+'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'s'
op|'='
name|'self'
op|'.'
name|'rawpause_buf'
op|'['
name|'i'
op|'*'
name|'packet_size'
op|':'
op|'('
name|'i'
op|'+'
number|'1'
op|')'
op|'*'
name|'packet_size'
op|']'
newline|'\n'
name|'a'
op|'.'
name|'dataReceived'
op|'('
name|'s'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'rawpause_output1'
op|','
name|'a'
op|'.'
name|'received'
op|')'
newline|'\n'
name|'clock'
op|'.'
name|'advance'
op|'('
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'rawpause_output2'
op|','
name|'a'
op|'.'
name|'received'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|stop_buf
dedent|''
dedent|''
name|'stop_buf'
op|'='
string|"'twiddle1\\ntwiddle2\\nstop\\nmore\\nstuff\\n'"
newline|'\n'
nl|'\n'
DECL|variable|stop_output
name|'stop_output'
op|'='
op|'['
string|"'twiddle1'"
op|','
string|"'twiddle2'"
op|','
string|"'stop'"
op|']'
newline|'\n'
nl|'\n'
DECL|member|test_stopProducing
name|'def'
name|'test_stopProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test stop inside producing.\n        """'
newline|'\n'
name|'for'
name|'packet_size'
name|'in'
name|'range'
op|'('
number|'1'
op|','
number|'10'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'t'
op|'='
name|'proto_helpers'
op|'.'
name|'StringIOWithoutClosing'
op|'('
op|')'
newline|'\n'
name|'a'
op|'='
name|'LineTester'
op|'('
op|')'
newline|'\n'
name|'a'
op|'.'
name|'makeConnection'
op|'('
name|'protocol'
op|'.'
name|'FileWrapper'
op|'('
name|'t'
op|')'
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'stop_buf'
op|')'
op|'/'
name|'packet_size'
op|'+'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'s'
op|'='
name|'self'
op|'.'
name|'stop_buf'
op|'['
name|'i'
op|'*'
name|'packet_size'
op|':'
op|'('
name|'i'
op|'+'
number|'1'
op|')'
op|'*'
name|'packet_size'
op|']'
newline|'\n'
name|'a'
op|'.'
name|'dataReceived'
op|'('
name|'s'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'stop_output'
op|','
name|'a'
op|'.'
name|'received'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_lineReceiverAsProducer
dedent|''
dedent|''
name|'def'
name|'test_lineReceiverAsProducer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test produce/unproduce in receiving.\n        """'
newline|'\n'
name|'a'
op|'='
name|'LineTester'
op|'('
op|')'
newline|'\n'
name|'t'
op|'='
name|'proto_helpers'
op|'.'
name|'StringIOWithoutClosing'
op|'('
op|')'
newline|'\n'
name|'a'
op|'.'
name|'makeConnection'
op|'('
name|'protocol'
op|'.'
name|'FileWrapper'
op|'('
name|'t'
op|')'
op|')'
newline|'\n'
name|'a'
op|'.'
name|'dataReceived'
op|'('
string|"'produce\\nhello world\\nunproduce\\ngoodbye\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'a'
op|'.'
name|'received'
op|','
nl|'\n'
op|'['
string|"'produce'"
op|','
string|"'hello world'"
op|','
string|"'unproduce'"
op|','
string|"'goodbye'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_clearLineBuffer
dedent|''
name|'def'
name|'test_clearLineBuffer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{LineReceiver.clearLineBuffer} removes all buffered data and returns\n        it as a C{str} and can be called from beneath C{dataReceived}.\n        """'
newline|'\n'
DECL|class|ClearingReceiver
name|'class'
name|'ClearingReceiver'
op|'('
name|'basic'
op|'.'
name|'LineReceiver'
op|')'
op|':'
newline|'\n'
DECL|member|lineReceived
indent|'            '
name|'def'
name|'lineReceived'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'line'
op|'='
name|'line'
newline|'\n'
name|'self'
op|'.'
name|'rest'
op|'='
name|'self'
op|'.'
name|'clearLineBuffer'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'protocol'
op|'='
name|'ClearingReceiver'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'foo\\r\\nbar\\r\\nbaz'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'line'
op|','
string|"'foo'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'rest'
op|','
string|"'bar\\r\\nbaz'"
op|')'
newline|'\n'
nl|'\n'
comment|'# Deliver another line to make sure the previously buffered data is'
nl|'\n'
comment|'# really gone.'
nl|'\n'
name|'protocol'
op|'.'
name|'dataReceived'
op|'('
string|"'quux\\r\\n'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'line'
op|','
string|"'quux'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'protocol'
op|'.'
name|'rest'
op|','
string|"''"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|LineOnlyReceiverTestCase
dedent|''
dedent|''
name|'class'
name|'LineOnlyReceiverTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test line only receiveer.\n    """'
newline|'\n'
name|'buffer'
op|'='
string|'"""foo\n    bleakness\n    desolation\n    plastic forks\n    """'
newline|'\n'
nl|'\n'
DECL|member|test_buffer
name|'def'
name|'test_buffer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test buffering over line protocol: data received should match buffer.\n        """'
newline|'\n'
name|'t'
op|'='
name|'proto_helpers'
op|'.'
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'a'
op|'='
name|'LineOnlyTester'
op|'('
op|')'
newline|'\n'
name|'a'
op|'.'
name|'makeConnection'
op|'('
name|'t'
op|')'
newline|'\n'
name|'for'
name|'c'
name|'in'
name|'self'
op|'.'
name|'buffer'
op|':'
newline|'\n'
indent|'            '
name|'a'
op|'.'
name|'dataReceived'
op|'('
name|'c'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'a'
op|'.'
name|'received'
op|','
name|'self'
op|'.'
name|'buffer'
op|'.'
name|'split'
op|'('
string|"'\\n'"
op|')'
op|'['
op|':'
op|'-'
number|'1'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_lineTooLong
dedent|''
name|'def'
name|'test_lineTooLong'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test sending a line too long: it should close the connection.\n        """'
newline|'\n'
name|'t'
op|'='
name|'proto_helpers'
op|'.'
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'a'
op|'='
name|'LineOnlyTester'
op|'('
op|')'
newline|'\n'
name|'a'
op|'.'
name|'makeConnection'
op|'('
name|'t'
op|')'
newline|'\n'
name|'res'
op|'='
name|'a'
op|'.'
name|'dataReceived'
op|'('
string|"'x'"
op|'*'
number|'200'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'res'
op|','
name|'error'
op|'.'
name|'ConnectionLost'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestMixin
dedent|''
dedent|''
name|'class'
name|'TestMixin'
op|':'
newline|'\n'
nl|'\n'
DECL|member|connectionMade
indent|'    '
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'received'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|stringReceived
dedent|''
name|'def'
name|'stringReceived'
op|'('
name|'self'
op|','
name|'s'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'received'
op|'.'
name|'append'
op|'('
name|'s'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|MAX_LENGTH
dedent|''
name|'MAX_LENGTH'
op|'='
number|'50'
newline|'\n'
DECL|variable|closed
name|'closed'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|member|connectionLost
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'closed'
op|'='
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestNetstring
dedent|''
dedent|''
name|'class'
name|'TestNetstring'
op|'('
name|'TestMixin'
op|','
name|'basic'
op|'.'
name|'NetstringReceiver'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|LPTestCaseMixin
dedent|''
name|'class'
name|'LPTestCaseMixin'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|illegalStrings
indent|'    '
name|'illegalStrings'
op|'='
op|'['
op|']'
newline|'\n'
DECL|variable|protocol
name|'protocol'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|getProtocol
name|'def'
name|'getProtocol'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return a new instance of C{self.protocol} connected to a new instance\n        of L{proto_helpers.StringTransport}.\n        """'
newline|'\n'
name|'t'
op|'='
name|'proto_helpers'
op|'.'
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'a'
op|'='
name|'self'
op|'.'
name|'protocol'
op|'('
op|')'
newline|'\n'
name|'a'
op|'.'
name|'makeConnection'
op|'('
name|'t'
op|')'
newline|'\n'
name|'return'
name|'a'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_illegal
dedent|''
name|'def'
name|'test_illegal'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Assert that illegal strings cause the transport to be closed.\n        """'
newline|'\n'
name|'for'
name|'s'
name|'in'
name|'self'
op|'.'
name|'illegalStrings'
op|':'
newline|'\n'
indent|'            '
name|'r'
op|'='
name|'self'
op|'.'
name|'getProtocol'
op|'('
op|')'
newline|'\n'
name|'for'
name|'c'
name|'in'
name|'s'
op|':'
newline|'\n'
indent|'                '
name|'r'
op|'.'
name|'dataReceived'
op|'('
name|'c'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'r'
op|'.'
name|'transport'
op|'.'
name|'disconnecting'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|NetstringReceiverTestCase
dedent|''
dedent|''
dedent|''
name|'class'
name|'NetstringReceiverTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|','
name|'LPTestCaseMixin'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|strings
indent|'    '
name|'strings'
op|'='
op|'['
string|"'hello'"
op|','
string|"'world'"
op|','
string|"'how'"
op|','
string|"'are'"
op|','
string|"'you123'"
op|','
string|"':today'"
op|','
string|'"a"'
op|'*'
number|'515'
op|']'
newline|'\n'
nl|'\n'
DECL|variable|illegalStrings
name|'illegalStrings'
op|'='
op|'['
nl|'\n'
string|"'9999999999999999999999'"
op|','
string|"'abc'"
op|','
string|"'4:abcde'"
op|','
nl|'\n'
string|"'51:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab,'"
op|','
op|']'
newline|'\n'
nl|'\n'
DECL|variable|protocol
name|'protocol'
op|'='
name|'TestNetstring'
newline|'\n'
nl|'\n'
DECL|member|test_buffer
name|'def'
name|'test_buffer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that when strings are received in chunks of different lengths,\n        they are still parsed correctly.\n        """'
newline|'\n'
name|'for'
name|'packet_size'
name|'in'
name|'range'
op|'('
number|'1'
op|','
number|'10'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'t'
op|'='
name|'proto_helpers'
op|'.'
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'a'
op|'='
name|'TestNetstring'
op|'('
op|')'
newline|'\n'
name|'a'
op|'.'
name|'MAX_LENGTH'
op|'='
number|'699'
newline|'\n'
name|'a'
op|'.'
name|'makeConnection'
op|'('
name|'t'
op|')'
newline|'\n'
name|'for'
name|'s'
name|'in'
name|'self'
op|'.'
name|'strings'
op|':'
newline|'\n'
indent|'                '
name|'a'
op|'.'
name|'sendString'
op|'('
name|'s'
op|')'
newline|'\n'
dedent|''
name|'out'
op|'='
name|'t'
op|'.'
name|'value'
op|'('
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'len'
op|'('
name|'out'
op|')'
op|'/'
name|'packet_size'
op|'+'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'s'
op|'='
name|'out'
op|'['
name|'i'
op|'*'
name|'packet_size'
op|':'
op|'('
name|'i'
op|'+'
number|'1'
op|')'
op|'*'
name|'packet_size'
op|']'
newline|'\n'
name|'if'
name|'s'
op|':'
newline|'\n'
indent|'                    '
name|'a'
op|'.'
name|'dataReceived'
op|'('
name|'s'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'a'
op|'.'
name|'received'
op|','
name|'self'
op|'.'
name|'strings'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_sendNonStrings
dedent|''
dedent|''
name|'def'
name|'test_sendNonStrings'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{basic.NetstringReceiver.sendString} will send objects that are not\n        strings by sending their string representation according to str().\n        """'
newline|'\n'
name|'nonStrings'
op|'='
op|'['
op|'['
op|']'
op|','
op|'{'
number|'1'
op|':'
string|"'a'"
op|','
number|'2'
op|':'
string|"'b'"
op|'}'
op|','
op|'['
string|"'a'"
op|','
string|"'b'"
op|','
string|"'c'"
op|']'
op|','
number|'673'
op|','
nl|'\n'
op|'('
number|'12'
op|','
string|'"fine"'
op|','
string|'"and"'
op|','
string|'"you?"'
op|')'
op|']'
newline|'\n'
name|'a'
op|'='
name|'TestNetstring'
op|'('
op|')'
newline|'\n'
name|'t'
op|'='
name|'proto_helpers'
op|'.'
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'a'
op|'.'
name|'MAX_LENGTH'
op|'='
number|'100'
newline|'\n'
name|'a'
op|'.'
name|'makeConnection'
op|'('
name|'t'
op|')'
newline|'\n'
name|'for'
name|'s'
name|'in'
name|'nonStrings'
op|':'
newline|'\n'
indent|'            '
name|'a'
op|'.'
name|'sendString'
op|'('
name|'s'
op|')'
newline|'\n'
name|'out'
op|'='
name|'t'
op|'.'
name|'value'
op|'('
op|')'
newline|'\n'
name|'t'
op|'.'
name|'clear'
op|'('
op|')'
newline|'\n'
name|'length'
op|'='
name|'out'
op|'['
op|':'
name|'out'
op|'.'
name|'find'
op|'('
string|'":"'
op|')'
op|']'
newline|'\n'
name|'data'
op|'='
name|'out'
op|'['
name|'out'
op|'.'
name|'find'
op|'('
string|'":"'
op|')'
op|'+'
number|'1'
op|':'
op|'-'
number|'1'
op|']'
comment|'#[:-1] to ignore the trailing ","'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'int'
op|'('
name|'length'
op|')'
op|','
name|'len'
op|'('
name|'str'
op|'('
name|'s'
op|')'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'data'
op|','
name|'str'
op|'('
name|'s'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'warnings'
op|'='
name|'self'
op|'.'
name|'flushWarnings'
op|'('
nl|'\n'
name|'offendingFunctions'
op|'='
op|'['
name|'self'
op|'.'
name|'test_sendNonStrings'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'len'
op|'('
name|'warnings'
op|')'
op|','
number|'5'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'warnings'
op|'['
number|'0'
op|']'
op|'['
string|'"message"'
op|']'
op|','
nl|'\n'
string|'"data passed to sendString() must be a string. Non-string support "'
nl|'\n'
string|'"is deprecated since Twisted 10.0"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'warnings'
op|'['
number|'0'
op|']'
op|'['
string|"'category'"
op|']'
op|','
nl|'\n'
name|'DeprecationWarning'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|IntNTestCaseMixin
dedent|''
dedent|''
name|'class'
name|'IntNTestCaseMixin'
op|'('
name|'LPTestCaseMixin'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    TestCase mixin for int-prefixed protocols.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|protocol
name|'protocol'
op|'='
name|'None'
newline|'\n'
DECL|variable|strings
name|'strings'
op|'='
name|'None'
newline|'\n'
DECL|variable|illegalStrings
name|'illegalStrings'
op|'='
name|'None'
newline|'\n'
DECL|variable|partialStrings
name|'partialStrings'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|test_receive
name|'def'
name|'test_receive'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test receiving data find the same data send.\n        """'
newline|'\n'
name|'r'
op|'='
name|'self'
op|'.'
name|'getProtocol'
op|'('
op|')'
newline|'\n'
name|'for'
name|'s'
name|'in'
name|'self'
op|'.'
name|'strings'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'c'
name|'in'
name|'struct'
op|'.'
name|'pack'
op|'('
name|'r'
op|'.'
name|'structFormat'
op|','
name|'len'
op|'('
name|'s'
op|')'
op|')'
op|'+'
name|'s'
op|':'
newline|'\n'
indent|'                '
name|'r'
op|'.'
name|'dataReceived'
op|'('
name|'c'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'r'
op|'.'
name|'received'
op|','
name|'self'
op|'.'
name|'strings'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_partial
dedent|''
name|'def'
name|'test_partial'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send partial data, nothing should be definitely received.\n        """'
newline|'\n'
name|'for'
name|'s'
name|'in'
name|'self'
op|'.'
name|'partialStrings'
op|':'
newline|'\n'
indent|'            '
name|'r'
op|'='
name|'self'
op|'.'
name|'getProtocol'
op|'('
op|')'
newline|'\n'
name|'for'
name|'c'
name|'in'
name|'s'
op|':'
newline|'\n'
indent|'                '
name|'r'
op|'.'
name|'dataReceived'
op|'('
name|'c'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'r'
op|'.'
name|'received'
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_send
dedent|''
dedent|''
name|'def'
name|'test_send'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test sending data over protocol.\n        """'
newline|'\n'
name|'r'
op|'='
name|'self'
op|'.'
name|'getProtocol'
op|'('
op|')'
newline|'\n'
name|'r'
op|'.'
name|'sendString'
op|'('
string|'"b"'
op|'*'
number|'16'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'r'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
nl|'\n'
name|'struct'
op|'.'
name|'pack'
op|'('
name|'r'
op|'.'
name|'structFormat'
op|','
number|'16'
op|')'
op|'+'
string|'"b"'
op|'*'
number|'16'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_lengthLimitExceeded
dedent|''
name|'def'
name|'test_lengthLimitExceeded'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When a length prefix is received which is greater than the protocol\'s\n        C{MAX_LENGTH} attribute, the C{lengthLimitExceeded} method is called\n        with the received length prefix.\n        """'
newline|'\n'
name|'length'
op|'='
op|'['
op|']'
newline|'\n'
name|'r'
op|'='
name|'self'
op|'.'
name|'getProtocol'
op|'('
op|')'
newline|'\n'
name|'r'
op|'.'
name|'lengthLimitExceeded'
op|'='
name|'length'
op|'.'
name|'append'
newline|'\n'
name|'r'
op|'.'
name|'MAX_LENGTH'
op|'='
number|'10'
newline|'\n'
name|'r'
op|'.'
name|'dataReceived'
op|'('
name|'struct'
op|'.'
name|'pack'
op|'('
name|'r'
op|'.'
name|'structFormat'
op|','
number|'11'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'length'
op|','
op|'['
number|'11'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_longStringNotDelivered
dedent|''
name|'def'
name|'test_longStringNotDelivered'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a length prefix for a string longer than C{MAX_LENGTH} is delivered\n        to C{dataReceived} at the same time as the entire string, the string is\n        not passed to C{stringReceived}.\n        """'
newline|'\n'
name|'r'
op|'='
name|'self'
op|'.'
name|'getProtocol'
op|'('
op|')'
newline|'\n'
name|'r'
op|'.'
name|'MAX_LENGTH'
op|'='
number|'10'
newline|'\n'
name|'r'
op|'.'
name|'dataReceived'
op|'('
nl|'\n'
name|'struct'
op|'.'
name|'pack'
op|'('
name|'r'
op|'.'
name|'structFormat'
op|','
number|'11'
op|')'
op|'+'
string|"'x'"
op|'*'
number|'11'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'r'
op|'.'
name|'received'
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestInt32
dedent|''
dedent|''
name|'class'
name|'TestInt32'
op|'('
name|'TestMixin'
op|','
name|'basic'
op|'.'
name|'Int32StringReceiver'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A L{basic.Int32StringReceiver} storing received strings in an array.\n\n    @ivar received: array holding received strings.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Int32TestCase
dedent|''
name|'class'
name|'Int32TestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|','
name|'IntNTestCaseMixin'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test case for int32-prefixed protocol\n    """'
newline|'\n'
DECL|variable|protocol
name|'protocol'
op|'='
name|'TestInt32'
newline|'\n'
DECL|variable|strings
name|'strings'
op|'='
op|'['
string|'"a"'
op|','
string|'"b"'
op|'*'
number|'16'
op|']'
newline|'\n'
DECL|variable|illegalStrings
name|'illegalStrings'
op|'='
op|'['
string|'"\\x10\\x00\\x00\\x00aaaaaa"'
op|']'
newline|'\n'
DECL|variable|partialStrings
name|'partialStrings'
op|'='
op|'['
string|'"\\x00\\x00\\x00"'
op|','
string|'"hello there"'
op|','
string|'""'
op|']'
newline|'\n'
nl|'\n'
DECL|member|test_data
name|'def'
name|'test_data'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test specific behavior of the 32-bits length.\n        """'
newline|'\n'
name|'r'
op|'='
name|'self'
op|'.'
name|'getProtocol'
op|'('
op|')'
newline|'\n'
name|'r'
op|'.'
name|'sendString'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'r'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|'"\\x00\\x00\\x00\\x03foo"'
op|')'
newline|'\n'
name|'r'
op|'.'
name|'dataReceived'
op|'('
string|'"\\x00\\x00\\x00\\x04ubar"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'r'
op|'.'
name|'received'
op|','
op|'['
string|'"ubar"'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestInt16
dedent|''
dedent|''
name|'class'
name|'TestInt16'
op|'('
name|'TestMixin'
op|','
name|'basic'
op|'.'
name|'Int16StringReceiver'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A L{basic.Int16StringReceiver} storing received strings in an array.\n\n    @ivar received: array holding received strings.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Int16TestCase
dedent|''
name|'class'
name|'Int16TestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|','
name|'IntNTestCaseMixin'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test case for int16-prefixed protocol\n    """'
newline|'\n'
DECL|variable|protocol
name|'protocol'
op|'='
name|'TestInt16'
newline|'\n'
DECL|variable|strings
name|'strings'
op|'='
op|'['
string|'"a"'
op|','
string|'"b"'
op|'*'
number|'16'
op|']'
newline|'\n'
DECL|variable|illegalStrings
name|'illegalStrings'
op|'='
op|'['
string|'"\\x10\\x00aaaaaa"'
op|']'
newline|'\n'
DECL|variable|partialStrings
name|'partialStrings'
op|'='
op|'['
string|'"\\x00"'
op|','
string|'"hello there"'
op|','
string|'""'
op|']'
newline|'\n'
nl|'\n'
DECL|member|test_data
name|'def'
name|'test_data'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test specific behavior of the 16-bits length.\n        """'
newline|'\n'
name|'r'
op|'='
name|'self'
op|'.'
name|'getProtocol'
op|'('
op|')'
newline|'\n'
name|'r'
op|'.'
name|'sendString'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'r'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|'"\\x00\\x03foo"'
op|')'
newline|'\n'
name|'r'
op|'.'
name|'dataReceived'
op|'('
string|'"\\x00\\x04ubar"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'r'
op|'.'
name|'received'
op|','
op|'['
string|'"ubar"'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_tooLongSend
dedent|''
name|'def'
name|'test_tooLongSend'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send too much data: that should cause an error.\n        """'
newline|'\n'
name|'r'
op|'='
name|'self'
op|'.'
name|'getProtocol'
op|'('
op|')'
newline|'\n'
name|'tooSend'
op|'='
string|'"b"'
op|'*'
op|'('
number|'2'
op|'**'
op|'('
name|'r'
op|'.'
name|'prefixLength'
op|'*'
number|'8'
op|')'
op|'+'
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'AssertionError'
op|','
name|'r'
op|'.'
name|'sendString'
op|','
name|'tooSend'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestInt8
dedent|''
dedent|''
name|'class'
name|'TestInt8'
op|'('
name|'TestMixin'
op|','
name|'basic'
op|'.'
name|'Int8StringReceiver'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A L{basic.Int8StringReceiver} storing received strings in an array.\n\n    @ivar received: array holding received strings.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Int8TestCase
dedent|''
name|'class'
name|'Int8TestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|','
name|'IntNTestCaseMixin'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test case for int8-prefixed protocol\n    """'
newline|'\n'
DECL|variable|protocol
name|'protocol'
op|'='
name|'TestInt8'
newline|'\n'
DECL|variable|strings
name|'strings'
op|'='
op|'['
string|'"a"'
op|','
string|'"b"'
op|'*'
number|'16'
op|']'
newline|'\n'
DECL|variable|illegalStrings
name|'illegalStrings'
op|'='
op|'['
string|'"\\x00\\x00aaaaaa"'
op|']'
newline|'\n'
DECL|variable|partialStrings
name|'partialStrings'
op|'='
op|'['
string|'"\\x08"'
op|','
string|'"dzadz"'
op|','
string|'""'
op|']'
newline|'\n'
nl|'\n'
DECL|member|test_data
name|'def'
name|'test_data'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test specific behavior of the 8-bits length.\n        """'
newline|'\n'
name|'r'
op|'='
name|'self'
op|'.'
name|'getProtocol'
op|'('
op|')'
newline|'\n'
name|'r'
op|'.'
name|'sendString'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'r'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|'"\\x03foo"'
op|')'
newline|'\n'
name|'r'
op|'.'
name|'dataReceived'
op|'('
string|'"\\x04ubar"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'r'
op|'.'
name|'received'
op|','
op|'['
string|'"ubar"'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test_tooLongSend
dedent|''
name|'def'
name|'test_tooLongSend'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send too much data: that should cause an error.\n        """'
newline|'\n'
name|'r'
op|'='
name|'self'
op|'.'
name|'getProtocol'
op|'('
op|')'
newline|'\n'
name|'tooSend'
op|'='
string|'"b"'
op|'*'
op|'('
number|'2'
op|'**'
op|'('
name|'r'
op|'.'
name|'prefixLength'
op|'*'
number|'8'
op|')'
op|'+'
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'AssertionError'
op|','
name|'r'
op|'.'
name|'sendString'
op|','
name|'tooSend'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|OnlyProducerTransport
dedent|''
dedent|''
name|'class'
name|'OnlyProducerTransport'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
comment|"# Transport which isn't really a transport, just looks like one to"
nl|'\n'
comment|'# someone not looking very hard.'
nl|'\n'
nl|'\n'
DECL|variable|paused
indent|'    '
name|'paused'
op|'='
name|'False'
newline|'\n'
DECL|variable|disconnecting
name|'disconnecting'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'data'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|pauseProducing
dedent|''
name|'def'
name|'pauseProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'paused'
op|'='
name|'True'
newline|'\n'
nl|'\n'
DECL|member|resumeProducing
dedent|''
name|'def'
name|'resumeProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'paused'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|member|write
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'bytes'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'data'
op|'.'
name|'append'
op|'('
name|'bytes'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ConsumingProtocol
dedent|''
dedent|''
name|'class'
name|'ConsumingProtocol'
op|'('
name|'basic'
op|'.'
name|'LineReceiver'
op|')'
op|':'
newline|'\n'
comment|"# Protocol that really, really doesn't want any more bytes."
nl|'\n'
nl|'\n'
DECL|member|lineReceived
indent|'    '
name|'def'
name|'lineReceived'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
name|'line'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'pauseProducing'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ProducerTestCase
dedent|''
dedent|''
name|'class'
name|'ProducerTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|testPauseResume
indent|'    '
name|'def'
name|'testPauseResume'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'p'
op|'='
name|'ConsumingProtocol'
op|'('
op|')'
newline|'\n'
name|'t'
op|'='
name|'OnlyProducerTransport'
op|'('
op|')'
newline|'\n'
name|'p'
op|'.'
name|'makeConnection'
op|'('
name|'t'
op|')'
newline|'\n'
nl|'\n'
name|'p'
op|'.'
name|'dataReceived'
op|'('
string|"'hello, '"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'t'
op|'.'
name|'data'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'t'
op|'.'
name|'paused'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'p'
op|'.'
name|'paused'
op|')'
newline|'\n'
nl|'\n'
name|'p'
op|'.'
name|'dataReceived'
op|'('
string|"'world\\r\\n'"
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'t'
op|'.'
name|'data'
op|','
op|'['
string|"'hello, world'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'t'
op|'.'
name|'paused'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'p'
op|'.'
name|'paused'
op|')'
newline|'\n'
nl|'\n'
name|'p'
op|'.'
name|'resumeProducing'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'t'
op|'.'
name|'paused'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'p'
op|'.'
name|'paused'
op|')'
newline|'\n'
nl|'\n'
name|'p'
op|'.'
name|'dataReceived'
op|'('
string|"'hello\\r\\nworld\\r\\n'"
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'t'
op|'.'
name|'data'
op|','
op|'['
string|"'hello, world'"
op|','
string|"'hello'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'t'
op|'.'
name|'paused'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'p'
op|'.'
name|'paused'
op|')'
newline|'\n'
nl|'\n'
name|'p'
op|'.'
name|'resumeProducing'
op|'('
op|')'
newline|'\n'
name|'p'
op|'.'
name|'dataReceived'
op|'('
string|"'goodbye\\r\\n'"
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'t'
op|'.'
name|'data'
op|','
op|'['
string|"'hello, world'"
op|','
string|"'hello'"
op|','
string|"'world'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'t'
op|'.'
name|'paused'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'p'
op|'.'
name|'paused'
op|')'
newline|'\n'
nl|'\n'
name|'p'
op|'.'
name|'resumeProducing'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'t'
op|'.'
name|'data'
op|','
op|'['
string|"'hello, world'"
op|','
string|"'hello'"
op|','
string|"'world'"
op|','
string|"'goodbye'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'t'
op|'.'
name|'paused'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'p'
op|'.'
name|'paused'
op|')'
newline|'\n'
nl|'\n'
name|'p'
op|'.'
name|'resumeProducing'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'t'
op|'.'
name|'data'
op|','
op|'['
string|"'hello, world'"
op|','
string|"'hello'"
op|','
string|"'world'"
op|','
string|"'goodbye'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'t'
op|'.'
name|'paused'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'p'
op|'.'
name|'paused'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestableProxyClientFactory
dedent|''
dedent|''
name|'class'
name|'TestableProxyClientFactory'
op|'('
name|'portforward'
op|'.'
name|'ProxyClientFactory'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test proxy client factory that keeps the last created protocol instance.\n\n    @ivar protoInstance: the last instance of the protocol.\n    @type protoInstance: L{portforward.ProxyClient}\n    """'
newline|'\n'
nl|'\n'
DECL|member|buildProtocol
name|'def'
name|'buildProtocol'
op|'('
name|'self'
op|','
name|'addr'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create the protocol instance and keeps track of it.\n        """'
newline|'\n'
name|'proto'
op|'='
name|'portforward'
op|'.'
name|'ProxyClientFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'self'
op|','
name|'addr'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'protoInstance'
op|'='
name|'proto'
newline|'\n'
name|'return'
name|'proto'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestableProxyFactory
dedent|''
dedent|''
name|'class'
name|'TestableProxyFactory'
op|'('
name|'portforward'
op|'.'
name|'ProxyFactory'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test proxy factory that keeps the last created protocol instance.\n\n    @ivar protoInstance: the last instance of the protocol.\n    @type protoInstance: L{portforward.ProxyServer}\n\n    @ivar clientFactoryInstance: client factory used by C{protoInstance} to\n        create forward connections.\n    @type clientFactoryInstance: L{TestableProxyClientFactory}\n    """'
newline|'\n'
nl|'\n'
DECL|member|buildProtocol
name|'def'
name|'buildProtocol'
op|'('
name|'self'
op|','
name|'addr'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create the protocol instance, keeps track of it, and makes it use\n        C{clientFactoryInstance} as client factory.\n        """'
newline|'\n'
name|'proto'
op|'='
name|'portforward'
op|'.'
name|'ProxyFactory'
op|'.'
name|'buildProtocol'
op|'('
name|'self'
op|','
name|'addr'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'clientFactoryInstance'
op|'='
name|'TestableProxyClientFactory'
op|'('
op|')'
newline|'\n'
comment|'# Force the use of this specific instance'
nl|'\n'
name|'proto'
op|'.'
name|'clientProtocolFactory'
op|'='
name|'lambda'
op|':'
name|'self'
op|'.'
name|'clientFactoryInstance'
newline|'\n'
name|'self'
op|'.'
name|'protoInstance'
op|'='
name|'proto'
newline|'\n'
name|'return'
name|'proto'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|Portforwarding
dedent|''
dedent|''
name|'class'
name|'Portforwarding'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test port forwarding.\n    """'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'serverProtocol'
op|'='
name|'wire'
op|'.'
name|'Echo'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'clientProtocol'
op|'='
name|'protocol'
op|'.'
name|'Protocol'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'openPorts'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tearDown
dedent|''
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'proxyServerFactory'
op|'.'
name|'protoInstance'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'proxyServerFactory'
op|'.'
name|'clientFactoryInstance'
op|'.'
name|'protoInstance'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'clientProtocol'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'serverProtocol'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'return'
name|'defer'
op|'.'
name|'gatherResults'
op|'('
nl|'\n'
op|'['
name|'defer'
op|'.'
name|'maybeDeferred'
op|'('
name|'p'
op|'.'
name|'stopListening'
op|')'
name|'for'
name|'p'
name|'in'
name|'self'
op|'.'
name|'openPorts'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_portforward
dedent|''
name|'def'
name|'test_portforward'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test port forwarding through Echo protocol.\n        """'
newline|'\n'
name|'realServerFactory'
op|'='
name|'protocol'
op|'.'
name|'ServerFactory'
op|'('
op|')'
newline|'\n'
name|'realServerFactory'
op|'.'
name|'protocol'
op|'='
name|'lambda'
op|':'
name|'self'
op|'.'
name|'serverProtocol'
newline|'\n'
name|'realServerPort'
op|'='
name|'reactor'
op|'.'
name|'listenTCP'
op|'('
number|'0'
op|','
name|'realServerFactory'
op|','
nl|'\n'
name|'interface'
op|'='
string|"'127.0.0.1'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'openPorts'
op|'.'
name|'append'
op|'('
name|'realServerPort'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proxyServerFactory'
op|'='
name|'TestableProxyFactory'
op|'('
string|"'127.0.0.1'"
op|','
nl|'\n'
name|'realServerPort'
op|'.'
name|'getHost'
op|'('
op|')'
op|'.'
name|'port'
op|')'
newline|'\n'
name|'proxyServerPort'
op|'='
name|'reactor'
op|'.'
name|'listenTCP'
op|'('
number|'0'
op|','
name|'self'
op|'.'
name|'proxyServerFactory'
op|','
nl|'\n'
name|'interface'
op|'='
string|"'127.0.0.1'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'openPorts'
op|'.'
name|'append'
op|'('
name|'proxyServerPort'
op|')'
newline|'\n'
nl|'\n'
name|'nBytes'
op|'='
number|'1000'
newline|'\n'
name|'received'
op|'='
op|'['
op|']'
newline|'\n'
name|'d'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
DECL|function|testDataReceived
name|'def'
name|'testDataReceived'
op|'('
name|'data'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'received'
op|'.'
name|'extend'
op|'('
name|'data'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'received'
op|')'
op|'>='
name|'nBytes'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'assertEquals'
op|'('
string|"''"
op|'.'
name|'join'
op|'('
name|'received'
op|')'
op|','
string|"'x'"
op|'*'
name|'nBytes'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'clientProtocol'
op|'.'
name|'dataReceived'
op|'='
name|'testDataReceived'
newline|'\n'
nl|'\n'
DECL|function|testConnectionMade
name|'def'
name|'testConnectionMade'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'clientProtocol'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
string|"'x'"
op|'*'
name|'nBytes'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'clientProtocol'
op|'.'
name|'connectionMade'
op|'='
name|'testConnectionMade'
newline|'\n'
nl|'\n'
name|'clientFactory'
op|'='
name|'protocol'
op|'.'
name|'ClientFactory'
op|'('
op|')'
newline|'\n'
name|'clientFactory'
op|'.'
name|'protocol'
op|'='
name|'lambda'
op|':'
name|'self'
op|'.'
name|'clientProtocol'
newline|'\n'
nl|'\n'
name|'reactor'
op|'.'
name|'connectTCP'
op|'('
nl|'\n'
string|"'127.0.0.1'"
op|','
name|'proxyServerPort'
op|'.'
name|'getHost'
op|'('
op|')'
op|'.'
name|'port'
op|','
name|'clientFactory'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|StringTransportTestCase
dedent|''
dedent|''
name|'class'
name|'StringTransportTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test L{proto_helpers.StringTransport} helper behaviour.\n    """'
newline|'\n'
nl|'\n'
DECL|member|test_noUnicode
name|'def'
name|'test_noUnicode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that L{proto_helpers.StringTransport} doesn\'t accept unicode data.\n        """'
newline|'\n'
name|'s'
op|'='
name|'proto_helpers'
op|'.'
name|'StringTransport'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'TypeError'
op|','
name|'s'
op|'.'
name|'write'
op|','
string|"u'foo'"
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
