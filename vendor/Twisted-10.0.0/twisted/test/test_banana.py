begin_unit
comment|'# Copyright (c) 2001-2010 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
name|'import'
name|'StringIO'
newline|'\n'
name|'import'
name|'sys'
newline|'\n'
nl|'\n'
comment|'# Twisted Imports'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'spread'
name|'import'
name|'banana'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'failure'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'protocol'
op|','
name|'main'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|MathTestCase
name|'class'
name|'MathTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|testInt2b128
indent|'    '
name|'def'
name|'testInt2b128'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'funkylist'
op|'='
name|'range'
op|'('
number|'0'
op|','
number|'100'
op|')'
op|'+'
name|'range'
op|'('
number|'1000'
op|','
number|'1100'
op|')'
op|'+'
name|'range'
op|'('
number|'1000000'
op|','
number|'1000100'
op|')'
op|'+'
op|'['
number|'1024'
op|'**'
number|'10l'
op|']'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'funkylist'
op|':'
newline|'\n'
indent|'            '
name|'x'
op|'='
name|'StringIO'
op|'.'
name|'StringIO'
op|'('
op|')'
newline|'\n'
name|'banana'
op|'.'
name|'int2b128'
op|'('
name|'i'
op|','
name|'x'
op|'.'
name|'write'
op|')'
newline|'\n'
name|'v'
op|'='
name|'x'
op|'.'
name|'getvalue'
op|'('
op|')'
newline|'\n'
name|'y'
op|'='
name|'banana'
op|'.'
name|'b1282int'
op|'('
name|'v'
op|')'
newline|'\n'
name|'assert'
name|'y'
op|'=='
name|'i'
op|','
string|'"y = %s; i = %s"'
op|'%'
op|'('
name|'y'
op|','
name|'i'
op|')'
newline|'\n'
nl|'\n'
DECL|class|BananaTestCase
dedent|''
dedent|''
dedent|''
name|'class'
name|'BananaTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|encClass
indent|'    '
name|'encClass'
op|'='
name|'banana'
op|'.'
name|'Banana'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'io'
op|'='
name|'StringIO'
op|'.'
name|'StringIO'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'='
name|'self'
op|'.'
name|'encClass'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'makeConnection'
op|'('
name|'protocol'
op|'.'
name|'FileWrapper'
op|'('
name|'self'
op|'.'
name|'io'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'_selectDialect'
op|'('
string|'"none"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'expressionReceived'
op|'='
name|'self'
op|'.'
name|'putResult'
newline|'\n'
nl|'\n'
DECL|member|putResult
dedent|''
name|'def'
name|'putResult'
op|'('
name|'self'
op|','
name|'result'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'result'
op|'='
name|'result'
newline|'\n'
nl|'\n'
DECL|member|tearDown
dedent|''
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'enc'
op|'.'
name|'connectionLost'
op|'('
name|'failure'
op|'.'
name|'Failure'
op|'('
name|'main'
op|'.'
name|'CONNECTION_DONE'
op|')'
op|')'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'enc'
newline|'\n'
nl|'\n'
DECL|member|testString
dedent|''
name|'def'
name|'testString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'enc'
op|'.'
name|'sendEncoded'
op|'('
string|'"hello"'
op|')'
newline|'\n'
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'dataReceived'
op|'('
name|'self'
op|'.'
name|'io'
op|'.'
name|'getvalue'
op|'('
op|')'
op|')'
newline|'\n'
name|'assert'
name|'self'
op|'.'
name|'result'
op|'=='
string|"'hello'"
newline|'\n'
nl|'\n'
DECL|member|test_int
dedent|''
name|'def'
name|'test_int'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A positive integer less than 2 ** 32 should round-trip through\n        banana without changing value and should come out represented\n        as an C{int} (regardless of the type which was encoded).\n        """'
newline|'\n'
name|'for'
name|'value'
name|'in'
op|'('
number|'10151'
op|','
number|'10151L'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'enc'
op|'.'
name|'sendEncoded'
op|'('
name|'value'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'dataReceived'
op|'('
name|'self'
op|'.'
name|'io'
op|'.'
name|'getvalue'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'result'
op|','
number|'10151'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'self'
op|'.'
name|'result'
op|','
name|'int'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_largeLong
dedent|''
dedent|''
name|'def'
name|'test_largeLong'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Integers greater than 2 ** 32 and less than -2 ** 32 should\n        round-trip through banana without changing value and should\n        come out represented as C{int} instances if the value fits\n        into that type on the receiving platform.\n        """'
newline|'\n'
name|'for'
name|'exp'
name|'in'
op|'('
number|'32'
op|','
number|'64'
op|','
number|'128'
op|','
number|'256'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'add'
name|'in'
op|'('
number|'0'
op|','
number|'1'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'m'
op|'='
number|'2'
op|'**'
name|'exp'
op|'+'
name|'add'
newline|'\n'
name|'for'
name|'n'
name|'in'
op|'('
name|'m'
op|','
op|'-'
name|'m'
op|'-'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'io'
op|'.'
name|'truncate'
op|'('
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'sendEncoded'
op|'('
name|'n'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'dataReceived'
op|'('
name|'self'
op|'.'
name|'io'
op|'.'
name|'getvalue'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'result'
op|','
name|'n'
op|')'
newline|'\n'
name|'if'
name|'n'
op|'>'
name|'sys'
op|'.'
name|'maxint'
name|'or'
name|'n'
op|'<'
op|'-'
name|'sys'
op|'.'
name|'maxint'
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'self'
op|'.'
name|'result'
op|','
name|'long'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'assertIsInstance'
op|'('
name|'self'
op|'.'
name|'result'
op|','
name|'int'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_getSmallest
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_getSmallest'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# How many bytes of prefix our implementation allows'
nl|'\n'
indent|'        '
name|'bytes'
op|'='
name|'self'
op|'.'
name|'enc'
op|'.'
name|'prefixLimit'
newline|'\n'
comment|"# How many useful bits we can extract from that based on Banana's"
nl|'\n'
comment|'# base-128 representation.'
nl|'\n'
name|'bits'
op|'='
name|'bytes'
op|'*'
number|'7'
newline|'\n'
comment|'# The largest number we _should_ be able to encode'
nl|'\n'
name|'largest'
op|'='
number|'2'
op|'**'
name|'bits'
op|'-'
number|'1'
newline|'\n'
comment|"# The smallest number we _shouldn't_ be able to encode"
nl|'\n'
name|'smallest'
op|'='
name|'largest'
op|'+'
number|'1'
newline|'\n'
name|'return'
name|'smallest'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_encodeTooLargeLong
dedent|''
name|'def'
name|'test_encodeTooLargeLong'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that a long above the implementation-specific limit is rejected\n        as too large to be encoded.\n        """'
newline|'\n'
name|'smallest'
op|'='
name|'self'
op|'.'
name|'_getSmallest'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'banana'
op|'.'
name|'BananaError'
op|','
name|'self'
op|'.'
name|'enc'
op|'.'
name|'sendEncoded'
op|','
name|'smallest'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_decodeTooLargeLong
dedent|''
name|'def'
name|'test_decodeTooLargeLong'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that a long above the implementation specific limit is rejected\n        as too large to be decoded.\n        """'
newline|'\n'
name|'smallest'
op|'='
name|'self'
op|'.'
name|'_getSmallest'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'setPrefixLimit'
op|'('
name|'self'
op|'.'
name|'enc'
op|'.'
name|'prefixLimit'
op|'*'
number|'2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'sendEncoded'
op|'('
name|'smallest'
op|')'
newline|'\n'
name|'encoded'
op|'='
name|'self'
op|'.'
name|'io'
op|'.'
name|'getvalue'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'io'
op|'.'
name|'truncate'
op|'('
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'setPrefixLimit'
op|'('
name|'self'
op|'.'
name|'enc'
op|'.'
name|'prefixLimit'
op|'/'
number|'2'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'banana'
op|'.'
name|'BananaError'
op|','
name|'self'
op|'.'
name|'enc'
op|'.'
name|'dataReceived'
op|','
name|'encoded'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_getLargest
dedent|''
name|'def'
name|'_getLargest'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'-'
name|'self'
op|'.'
name|'_getSmallest'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_encodeTooSmallLong
dedent|''
name|'def'
name|'test_encodeTooSmallLong'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that a negative long below the implementation-specific limit is\n        rejected as too small to be encoded.\n        """'
newline|'\n'
name|'largest'
op|'='
name|'self'
op|'.'
name|'_getLargest'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'banana'
op|'.'
name|'BananaError'
op|','
name|'self'
op|'.'
name|'enc'
op|'.'
name|'sendEncoded'
op|','
name|'largest'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_decodeTooSmallLong
dedent|''
name|'def'
name|'test_decodeTooSmallLong'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that a negative long below the implementation specific limit is\n        rejected as too small to be decoded.\n        """'
newline|'\n'
name|'largest'
op|'='
name|'self'
op|'.'
name|'_getLargest'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'setPrefixLimit'
op|'('
name|'self'
op|'.'
name|'enc'
op|'.'
name|'prefixLimit'
op|'*'
number|'2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'sendEncoded'
op|'('
name|'largest'
op|')'
newline|'\n'
name|'encoded'
op|'='
name|'self'
op|'.'
name|'io'
op|'.'
name|'getvalue'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'io'
op|'.'
name|'truncate'
op|'('
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'setPrefixLimit'
op|'('
name|'self'
op|'.'
name|'enc'
op|'.'
name|'prefixLimit'
op|'/'
number|'2'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'banana'
op|'.'
name|'BananaError'
op|','
name|'self'
op|'.'
name|'enc'
op|'.'
name|'dataReceived'
op|','
name|'encoded'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testNegativeLong
dedent|''
name|'def'
name|'testNegativeLong'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'enc'
op|'.'
name|'sendEncoded'
op|'('
op|'-'
number|'1015l'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'dataReceived'
op|'('
name|'self'
op|'.'
name|'io'
op|'.'
name|'getvalue'
op|'('
op|')'
op|')'
newline|'\n'
name|'assert'
name|'self'
op|'.'
name|'result'
op|'=='
op|'-'
number|'1015l'
op|','
string|'"should be -1015l, got %s"'
op|'%'
name|'self'
op|'.'
name|'result'
newline|'\n'
nl|'\n'
DECL|member|testInteger
dedent|''
name|'def'
name|'testInteger'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'enc'
op|'.'
name|'sendEncoded'
op|'('
number|'1015'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'dataReceived'
op|'('
name|'self'
op|'.'
name|'io'
op|'.'
name|'getvalue'
op|'('
op|')'
op|')'
newline|'\n'
name|'assert'
name|'self'
op|'.'
name|'result'
op|'=='
number|'1015'
op|','
string|'"should be 1015, got %s"'
op|'%'
name|'self'
op|'.'
name|'result'
newline|'\n'
nl|'\n'
DECL|member|testNegative
dedent|''
name|'def'
name|'testNegative'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'enc'
op|'.'
name|'sendEncoded'
op|'('
op|'-'
number|'1015'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'dataReceived'
op|'('
name|'self'
op|'.'
name|'io'
op|'.'
name|'getvalue'
op|'('
op|')'
op|')'
newline|'\n'
name|'assert'
name|'self'
op|'.'
name|'result'
op|'=='
op|'-'
number|'1015'
op|','
string|'"should be -1015, got %s"'
op|'%'
name|'self'
op|'.'
name|'result'
newline|'\n'
nl|'\n'
DECL|member|testFloat
dedent|''
name|'def'
name|'testFloat'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'enc'
op|'.'
name|'sendEncoded'
op|'('
number|'1015.'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'dataReceived'
op|'('
name|'self'
op|'.'
name|'io'
op|'.'
name|'getvalue'
op|'('
op|')'
op|')'
newline|'\n'
name|'assert'
name|'self'
op|'.'
name|'result'
op|'=='
number|'1015.'
newline|'\n'
nl|'\n'
DECL|member|testList
dedent|''
name|'def'
name|'testList'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'foo'
op|'='
op|'['
number|'1'
op|','
number|'2'
op|','
op|'['
number|'3'
op|','
number|'4'
op|']'
op|','
op|'['
number|'30.5'
op|','
number|'40.2'
op|']'
op|','
number|'5'
op|','
op|'['
string|'"six"'
op|','
string|'"seven"'
op|','
op|'['
string|'"eight"'
op|','
number|'9'
op|']'
op|']'
op|','
op|'['
number|'10'
op|']'
op|','
op|'['
op|']'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'sendEncoded'
op|'('
name|'foo'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'dataReceived'
op|'('
name|'self'
op|'.'
name|'io'
op|'.'
name|'getvalue'
op|'('
op|')'
op|')'
newline|'\n'
name|'assert'
name|'self'
op|'.'
name|'result'
op|'=='
name|'foo'
op|','
string|'"%s!=%s"'
op|'%'
op|'('
name|'repr'
op|'('
name|'self'
op|'.'
name|'result'
op|')'
op|','
name|'repr'
op|'('
name|'self'
op|'.'
name|'result'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testPartial
dedent|''
name|'def'
name|'testPartial'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'foo'
op|'='
op|'['
number|'1'
op|','
number|'2'
op|','
op|'['
number|'3'
op|','
number|'4'
op|']'
op|','
op|'['
number|'30.5'
op|','
number|'40.2'
op|']'
op|','
number|'5'
op|','
nl|'\n'
op|'['
string|'"six"'
op|','
string|'"seven"'
op|','
op|'['
string|'"eight"'
op|','
number|'9'
op|']'
op|']'
op|','
op|'['
number|'10'
op|']'
op|','
nl|'\n'
comment|"# TODO: currently the C implementation's a bit buggy..."
nl|'\n'
name|'sys'
op|'.'
name|'maxint'
op|'*'
number|'3l'
op|','
name|'sys'
op|'.'
name|'maxint'
op|'*'
number|'2l'
op|','
name|'sys'
op|'.'
name|'maxint'
op|'*'
op|'-'
number|'2l'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'sendEncoded'
op|'('
name|'foo'
op|')'
newline|'\n'
name|'for'
name|'byte'
name|'in'
name|'self'
op|'.'
name|'io'
op|'.'
name|'getvalue'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'enc'
op|'.'
name|'dataReceived'
op|'('
name|'byte'
op|')'
newline|'\n'
dedent|''
name|'assert'
name|'self'
op|'.'
name|'result'
op|'=='
name|'foo'
op|','
string|'"%s!=%s"'
op|'%'
op|'('
name|'repr'
op|'('
name|'self'
op|'.'
name|'result'
op|')'
op|','
name|'repr'
op|'('
name|'foo'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|feed
dedent|''
name|'def'
name|'feed'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'byte'
name|'in'
name|'data'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'enc'
op|'.'
name|'dataReceived'
op|'('
name|'byte'
op|')'
newline|'\n'
DECL|member|testOversizedList
dedent|''
dedent|''
name|'def'
name|'testOversizedList'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'data'
op|'='
string|"'\\x02\\x01\\x01\\x01\\x01\\x80'"
newline|'\n'
comment|'# list(size=0x0101010102, about 4.3e9)'
nl|'\n'
name|'self'
op|'.'
name|'failUnlessRaises'
op|'('
name|'banana'
op|'.'
name|'BananaError'
op|','
name|'self'
op|'.'
name|'feed'
op|','
name|'data'
op|')'
newline|'\n'
DECL|member|testOversizedString
dedent|''
name|'def'
name|'testOversizedString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'data'
op|'='
string|"'\\x02\\x01\\x01\\x01\\x01\\x82'"
newline|'\n'
comment|'# string(size=0x0101010102, about 4.3e9)'
nl|'\n'
name|'self'
op|'.'
name|'failUnlessRaises'
op|'('
name|'banana'
op|'.'
name|'BananaError'
op|','
name|'self'
op|'.'
name|'feed'
op|','
name|'data'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testCrashString
dedent|''
name|'def'
name|'testCrashString'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'crashString'
op|'='
string|"'\\x00\\x00\\x00\\x00\\x04\\x80'"
newline|'\n'
comment|'# string(size=0x0400000000, about 17.2e9)'
nl|'\n'
nl|'\n'
comment|"#  cBanana would fold that into a 32-bit 'int', then try to allocate"
nl|'\n'
comment|'#  a list with PyList_New(). cBanana ignored the NULL return value,'
nl|'\n'
comment|'#  so it would segfault when trying to free the imaginary list.'
nl|'\n'
nl|'\n'
comment|"# This variant doesn't segfault straight out in my environment."
nl|'\n'
comment|'# Instead, it takes up large amounts of CPU and memory...'
nl|'\n'
comment|"#crashString = '\\x00\\x00\\x00\\x00\\x01\\x80'"
nl|'\n'
comment|'# print repr(crashString)'
nl|'\n'
comment|'#self.failUnlessRaises(Exception, self.enc.dataReceived, crashString)'
nl|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# should now raise MemoryError'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'enc'
op|'.'
name|'dataReceived'
op|'('
name|'crashString'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'banana'
op|'.'
name|'BananaError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|testCrashNegativeLong
dedent|''
dedent|''
name|'def'
name|'testCrashNegativeLong'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# There was a bug in cBanana which relied on negating a negative integer'
nl|'\n'
comment|'# always giving a postive result, but for the lowest possible number in'
nl|'\n'
comment|"# 2s-complement arithmetic, that's not true, i.e."
nl|'\n'
comment|'#     long x = -2147483648;'
nl|'\n'
comment|'#     long y = -x;'
nl|'\n'
comment|'#     x == y;  /* true! */'
nl|'\n'
comment|'# (assuming 32-bit longs)'
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'enc'
op|'.'
name|'sendEncoded'
op|'('
op|'-'
number|'2147483648'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'dataReceived'
op|'('
name|'self'
op|'.'
name|'io'
op|'.'
name|'getvalue'
op|'('
op|')'
op|')'
newline|'\n'
name|'assert'
name|'self'
op|'.'
name|'result'
op|'=='
op|'-'
number|'2147483648'
op|','
string|'"should be -2147483648, got %s"'
op|'%'
name|'self'
op|'.'
name|'result'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_sizedIntegerTypes
dedent|''
name|'def'
name|'test_sizedIntegerTypes'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that integers below the maximum C{INT} token size cutoff are\n        serialized as C{INT} or C{NEG} and that larger integers are\n        serialized as C{LONGINT} or C{LONGNEG}.\n        """'
newline|'\n'
DECL|function|encoded
name|'def'
name|'encoded'
op|'('
name|'n'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'io'
op|'.'
name|'seek'
op|'('
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'io'
op|'.'
name|'truncate'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'enc'
op|'.'
name|'sendEncoded'
op|'('
name|'n'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'io'
op|'.'
name|'getvalue'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'baseIntIn'
op|'='
op|'+'
number|'2147483647'
newline|'\n'
name|'baseNegIn'
op|'='
op|'-'
number|'2147483648'
newline|'\n'
nl|'\n'
name|'baseIntOut'
op|'='
string|"'\\x7f\\x7f\\x7f\\x07\\x81'"
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'encoded'
op|'('
name|'baseIntIn'
op|'-'
number|'2'
op|')'
op|','
string|"'\\x7d'"
op|'+'
name|'baseIntOut'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'encoded'
op|'('
name|'baseIntIn'
op|'-'
number|'1'
op|')'
op|','
string|"'\\x7e'"
op|'+'
name|'baseIntOut'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'encoded'
op|'('
name|'baseIntIn'
op|'-'
number|'0'
op|')'
op|','
string|"'\\x7f'"
op|'+'
name|'baseIntOut'
op|')'
newline|'\n'
nl|'\n'
name|'baseLongIntOut'
op|'='
string|"'\\x00\\x00\\x00\\x08\\x85'"
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'encoded'
op|'('
name|'baseIntIn'
op|'+'
number|'1'
op|')'
op|','
string|"'\\x00'"
op|'+'
name|'baseLongIntOut'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'encoded'
op|'('
name|'baseIntIn'
op|'+'
number|'2'
op|')'
op|','
string|"'\\x01'"
op|'+'
name|'baseLongIntOut'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'encoded'
op|'('
name|'baseIntIn'
op|'+'
number|'3'
op|')'
op|','
string|"'\\x02'"
op|'+'
name|'baseLongIntOut'
op|')'
newline|'\n'
nl|'\n'
name|'baseNegOut'
op|'='
string|"'\\x7f\\x7f\\x7f\\x07\\x83'"
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'encoded'
op|'('
name|'baseNegIn'
op|'+'
number|'2'
op|')'
op|','
string|"'\\x7e'"
op|'+'
name|'baseNegOut'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'encoded'
op|'('
name|'baseNegIn'
op|'+'
number|'1'
op|')'
op|','
string|"'\\x7f'"
op|'+'
name|'baseNegOut'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'encoded'
op|'('
name|'baseNegIn'
op|'+'
number|'0'
op|')'
op|','
string|"'\\x00\\x00\\x00\\x00\\x08\\x83'"
op|')'
newline|'\n'
nl|'\n'
name|'baseLongNegOut'
op|'='
string|"'\\x00\\x00\\x00\\x08\\x86'"
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'encoded'
op|'('
name|'baseNegIn'
op|'-'
number|'1'
op|')'
op|','
string|"'\\x01'"
op|'+'
name|'baseLongNegOut'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'encoded'
op|'('
name|'baseNegIn'
op|'-'
number|'2'
op|')'
op|','
string|"'\\x02'"
op|'+'
name|'baseLongNegOut'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'encoded'
op|'('
name|'baseNegIn'
op|'-'
number|'3'
op|')'
op|','
string|"'\\x03'"
op|'+'
name|'baseLongNegOut'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|GlobalCoderTests
dedent|''
dedent|''
name|'class'
name|'GlobalCoderTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for the free functions L{banana.encode} and L{banana.decode}.\n    """'
newline|'\n'
DECL|member|test_statelessDecode
name|'def'
name|'test_statelessDecode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that state doesn\'t carry over between calls to L{banana.decode}.\n        """'
newline|'\n'
comment|'# Banana encoding of 2 ** 449'
nl|'\n'
name|'undecodable'
op|'='
string|"'\\x7f'"
op|'*'
number|'65'
op|'+'
string|"'\\x85'"
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'banana'
op|'.'
name|'BananaError'
op|','
name|'banana'
op|'.'
name|'decode'
op|','
name|'undecodable'
op|')'
newline|'\n'
nl|'\n'
comment|'# Banana encoding of 1'
nl|'\n'
name|'decodable'
op|'='
string|"'\\x01\\x81'"
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'banana'
op|'.'
name|'decode'
op|'('
name|'decodable'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
