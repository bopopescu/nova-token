begin_unit
comment|'# Copyright (c) 2001-2010 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTests for lots of functionality provided by L{twisted.internet}.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'sys'
newline|'\n'
name|'import'
name|'time'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'reactor'
op|','
name|'protocol'
op|','
name|'error'
op|','
name|'abstract'
op|','
name|'defer'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'interfaces'
op|','
name|'base'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'ssl'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
DECL|variable|ssl
indent|'    '
name|'ssl'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'if'
name|'ssl'
name|'and'
name|'not'
name|'ssl'
op|'.'
name|'supported'
op|':'
newline|'\n'
DECL|variable|ssl
indent|'    '
name|'ssl'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'defer'
name|'import'
name|'Deferred'
op|','
name|'maybeDeferred'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'util'
op|','
name|'runtime'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ThreePhaseEventTests
name|'class'
name|'ThreePhaseEventTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for the private implementation helpers for system event triggers.\n    """'
newline|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a trigger, an argument, and an event to be used by tests.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'trigger'
op|'='
name|'lambda'
name|'x'
op|':'
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'arg'
op|'='
name|'object'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'='
name|'base'
op|'.'
name|'_ThreePhaseEvent'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_addInvalidPhase
dedent|''
name|'def'
name|'test_addInvalidPhase'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ThreePhaseEvent.addTrigger} should raise L{KeyError} when called\n        with an invalid phase.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
nl|'\n'
name|'KeyError'
op|','
nl|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|','
string|"'xxx'"
op|','
name|'self'
op|'.'
name|'trigger'
op|','
name|'self'
op|'.'
name|'arg'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_addBeforeTrigger
dedent|''
name|'def'
name|'test_addBeforeTrigger'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ThreePhaseEvent.addTrigger} should accept C{\'before\'} as a phase, a\n        callable, and some arguments and add the callable with the arguments to\n        the before list.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'self'
op|'.'
name|'trigger'
op|','
name|'self'
op|'.'
name|'arg'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'before'
op|','
nl|'\n'
op|'['
op|'('
name|'self'
op|'.'
name|'trigger'
op|','
op|'('
name|'self'
op|'.'
name|'arg'
op|','
op|')'
op|','
op|'{'
op|'}'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_addDuringTrigger
dedent|''
name|'def'
name|'test_addDuringTrigger'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ThreePhaseEvent.addTrigger} should accept C{\'during\'} as a phase, a\n        callable, and some arguments and add the callable with the arguments to\n        the during list.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'during'"
op|','
name|'self'
op|'.'
name|'trigger'
op|','
name|'self'
op|'.'
name|'arg'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'during'
op|','
nl|'\n'
op|'['
op|'('
name|'self'
op|'.'
name|'trigger'
op|','
op|'('
name|'self'
op|'.'
name|'arg'
op|','
op|')'
op|','
op|'{'
op|'}'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_addAfterTrigger
dedent|''
name|'def'
name|'test_addAfterTrigger'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ThreePhaseEvent.addTrigger} should accept C{\'after\'} as a phase, a\n        callable, and some arguments and add the callable with the arguments to\n        the after list.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'after'"
op|','
name|'self'
op|'.'
name|'trigger'
op|','
name|'self'
op|'.'
name|'arg'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'after'
op|','
nl|'\n'
op|'['
op|'('
name|'self'
op|'.'
name|'trigger'
op|','
op|'('
name|'self'
op|'.'
name|'arg'
op|','
op|')'
op|','
op|'{'
op|'}'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_removeTrigger
dedent|''
name|'def'
name|'test_removeTrigger'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ThreePhaseEvent.removeTrigger} should accept an opaque object\n        previously returned by L{_ThreePhaseEvent.addTrigger} and remove the\n        associated trigger.\n        """'
newline|'\n'
name|'handle'
op|'='
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'self'
op|'.'
name|'trigger'
op|','
name|'self'
op|'.'
name|'arg'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'removeTrigger'
op|'('
name|'handle'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'event'
op|'.'
name|'before'
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_removeNonexistentTrigger
dedent|''
name|'def'
name|'test_removeNonexistentTrigger'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ThreePhaseEvent.removeTrigger} should raise L{ValueError} when given\n        an object not previously returned by L{_ThreePhaseEvent.addTrigger}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'ValueError'
op|','
name|'self'
op|'.'
name|'event'
op|'.'
name|'removeTrigger'
op|','
name|'object'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_removeRemovedTrigger
dedent|''
name|'def'
name|'test_removeRemovedTrigger'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ThreePhaseEvent.removeTrigger} should raise L{ValueError} the second\n        time it is called with an object returned by\n        L{_ThreePhaseEvent.addTrigger}.\n        """'
newline|'\n'
name|'handle'
op|'='
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'self'
op|'.'
name|'trigger'
op|','
name|'self'
op|'.'
name|'arg'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'removeTrigger'
op|'('
name|'handle'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'ValueError'
op|','
name|'self'
op|'.'
name|'event'
op|'.'
name|'removeTrigger'
op|','
name|'handle'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_removeAlmostValidTrigger
dedent|''
name|'def'
name|'test_removeAlmostValidTrigger'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ThreePhaseEvent.removeTrigger} should raise L{ValueError} if it is\n        given a trigger handle which resembles a valid trigger handle aside\n        from its phase being incorrect.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
nl|'\n'
name|'KeyError'
op|','
nl|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'removeTrigger'
op|','
op|'('
string|"'xxx'"
op|','
name|'self'
op|'.'
name|'trigger'
op|','
op|'('
name|'self'
op|'.'
name|'arg'
op|','
op|')'
op|','
op|'{'
op|'}'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_fireEvent
dedent|''
name|'def'
name|'test_fireEvent'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ThreePhaseEvent.fireEvent} should call I{before}, I{during}, and\n        I{after} phase triggers in that order.\n        """'
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'after'"
op|','
name|'events'
op|'.'
name|'append'
op|','
op|'('
string|"'first'"
op|','
string|"'after'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'during'"
op|','
name|'events'
op|'.'
name|'append'
op|','
op|'('
string|"'first'"
op|','
string|"'during'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'events'
op|'.'
name|'append'
op|','
op|'('
string|"'first'"
op|','
string|"'before'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'events'
op|'.'
name|'append'
op|','
op|'('
string|"'second'"
op|','
string|"'before'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'during'"
op|','
name|'events'
op|'.'
name|'append'
op|','
op|'('
string|"'second'"
op|','
string|"'during'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'after'"
op|','
name|'events'
op|'.'
name|'append'
op|','
op|'('
string|"'second'"
op|','
string|"'after'"
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'fireEvent'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
nl|'\n'
op|'['
op|'('
string|"'first'"
op|','
string|"'before'"
op|')'
op|','
op|'('
string|"'second'"
op|','
string|"'before'"
op|')'
op|','
nl|'\n'
op|'('
string|"'first'"
op|','
string|"'during'"
op|')'
op|','
op|'('
string|"'second'"
op|','
string|"'during'"
op|')'
op|','
nl|'\n'
op|'('
string|"'first'"
op|','
string|"'after'"
op|')'
op|','
op|'('
string|"'second'"
op|','
string|"'after'"
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_asynchronousBefore
dedent|''
name|'def'
name|'test_asynchronousBefore'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{_ThreePhaseEvent.fireEvent} should wait for any L{Deferred} returned\n        by a I{before} phase trigger before proceeding to I{during} events.\n        """'
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
name|'beforeResult'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'lambda'
op|':'
name|'beforeResult'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'during'"
op|','
name|'events'
op|'.'
name|'append'
op|','
string|"'during'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'after'"
op|','
name|'events'
op|'.'
name|'append'
op|','
string|"'after'"
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'fireEvent'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'beforeResult'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
string|"'during'"
op|','
string|"'after'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_beforeTriggerException
dedent|''
name|'def'
name|'test_beforeTriggerException'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a before-phase trigger raises a synchronous exception, it should be\n        logged and the remaining triggers should be run.\n        """'
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|class|DummyException
name|'class'
name|'DummyException'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
DECL|function|raisingTrigger
dedent|''
name|'def'
name|'raisingTrigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DummyException'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'raisingTrigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'events'
op|'.'
name|'append'
op|','
string|"'before'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'during'"
op|','
name|'events'
op|'.'
name|'append'
op|','
string|"'during'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'fireEvent'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
string|"'before'"
op|','
string|"'during'"
op|']'
op|')'
newline|'\n'
name|'errors'
op|'='
name|'self'
op|'.'
name|'flushLoggedErrors'
op|'('
name|'DummyException'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'len'
op|'('
name|'errors'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_duringTriggerException
dedent|''
name|'def'
name|'test_duringTriggerException'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a during-phase trigger raises a synchronous exception, it should be\n        logged and the remaining triggers should be run.\n        """'
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|class|DummyException
name|'class'
name|'DummyException'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
DECL|function|raisingTrigger
dedent|''
name|'def'
name|'raisingTrigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'DummyException'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'during'"
op|','
name|'raisingTrigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'during'"
op|','
name|'events'
op|'.'
name|'append'
op|','
string|"'during'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'after'"
op|','
name|'events'
op|'.'
name|'append'
op|','
string|"'after'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'fireEvent'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
string|"'during'"
op|','
string|"'after'"
op|']'
op|')'
newline|'\n'
name|'errors'
op|'='
name|'self'
op|'.'
name|'flushLoggedErrors'
op|'('
name|'DummyException'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'len'
op|'('
name|'errors'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_synchronousRemoveAlreadyExecutedBefore
dedent|''
name|'def'
name|'test_synchronousRemoveAlreadyExecutedBefore'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a before-phase trigger tries to remove another before-phase trigger\n        which has already run, a warning should be emitted.\n        """'
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|function|removeTrigger
name|'def'
name|'removeTrigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'event'
op|'.'
name|'removeTrigger'
op|'('
name|'beforeHandle'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'beforeHandle'
op|'='
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'events'
op|'.'
name|'append'
op|','
op|'('
string|"'first'"
op|','
string|"'before'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'removeTrigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'events'
op|'.'
name|'append'
op|','
op|'('
string|"'second'"
op|','
string|"'before'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertWarns'
op|'('
nl|'\n'
name|'DeprecationWarning'
op|','
nl|'\n'
string|'"Removing already-fired system event triggers will raise an "'
nl|'\n'
string|'"exception in a future version of Twisted."'
op|','
nl|'\n'
name|'__file__'
op|','
nl|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'fireEvent'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|'('
string|"'first'"
op|','
string|"'before'"
op|')'
op|','
op|'('
string|"'second'"
op|','
string|"'before'"
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_synchronousRemovePendingBefore
dedent|''
name|'def'
name|'test_synchronousRemovePendingBefore'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a before-phase trigger removes another before-phase trigger which\n        has not yet run, the removed trigger should not be run.\n        """'
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
nl|'\n'
string|"'before'"
op|','
name|'lambda'
op|':'
name|'self'
op|'.'
name|'event'
op|'.'
name|'removeTrigger'
op|'('
name|'beforeHandle'
op|')'
op|')'
newline|'\n'
name|'beforeHandle'
op|'='
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
nl|'\n'
string|"'before'"
op|','
name|'events'
op|'.'
name|'append'
op|','
op|'('
string|"'first'"
op|','
string|"'before'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'events'
op|'.'
name|'append'
op|','
op|'('
string|"'second'"
op|','
string|"'before'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'fireEvent'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|'('
string|"'second'"
op|','
string|"'before'"
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_synchronousBeforeRemovesDuring
dedent|''
name|'def'
name|'test_synchronousBeforeRemovesDuring'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a before-phase trigger removes a during-phase trigger, the\n        during-phase trigger should not be run.\n        """'
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
nl|'\n'
string|"'before'"
op|','
name|'lambda'
op|':'
name|'self'
op|'.'
name|'event'
op|'.'
name|'removeTrigger'
op|'('
name|'duringHandle'
op|')'
op|')'
newline|'\n'
name|'duringHandle'
op|'='
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'during'"
op|','
name|'events'
op|'.'
name|'append'
op|','
string|"'during'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'after'"
op|','
name|'events'
op|'.'
name|'append'
op|','
string|"'after'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'fireEvent'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
string|"'after'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_asynchronousBeforeRemovesDuring
dedent|''
name|'def'
name|'test_asynchronousBeforeRemovesDuring'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a before-phase trigger returns a L{Deferred} and later removes a\n        during-phase trigger before the L{Deferred} fires, the during-phase\n        trigger should not be run.\n        """'
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
name|'beforeResult'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'lambda'
op|':'
name|'beforeResult'
op|')'
newline|'\n'
name|'duringHandle'
op|'='
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'during'"
op|','
name|'events'
op|'.'
name|'append'
op|','
string|"'during'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'after'"
op|','
name|'events'
op|'.'
name|'append'
op|','
string|"'after'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'fireEvent'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'removeTrigger'
op|'('
name|'duringHandle'
op|')'
newline|'\n'
name|'beforeResult'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
string|"'after'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_synchronousBeforeRemovesConspicuouslySimilarDuring
dedent|''
name|'def'
name|'test_synchronousBeforeRemovesConspicuouslySimilarDuring'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a before-phase trigger removes a during-phase trigger which is\n        identical to an already-executed before-phase trigger aside from their\n        phases, no warning should be emitted and the during-phase trigger\n        should not be run.\n        """'
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|trigger
name|'def'
name|'trigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'.'
name|'append'
op|'('
string|"'trigger'"
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'trigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
nl|'\n'
string|"'before'"
op|','
name|'lambda'
op|':'
name|'self'
op|'.'
name|'event'
op|'.'
name|'removeTrigger'
op|'('
name|'duringTrigger'
op|')'
op|')'
newline|'\n'
name|'duringTrigger'
op|'='
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'during'"
op|','
name|'trigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'fireEvent'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
string|"'trigger'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_synchronousRemovePendingDuring
dedent|''
name|'def'
name|'test_synchronousRemovePendingDuring'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a during-phase trigger removes another during-phase trigger which\n        has not yet run, the removed trigger should not be run.\n        """'
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
nl|'\n'
string|"'during'"
op|','
name|'lambda'
op|':'
name|'self'
op|'.'
name|'event'
op|'.'
name|'removeTrigger'
op|'('
name|'duringHandle'
op|')'
op|')'
newline|'\n'
name|'duringHandle'
op|'='
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
nl|'\n'
string|"'during'"
op|','
name|'events'
op|'.'
name|'append'
op|','
op|'('
string|"'first'"
op|','
string|"'during'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
nl|'\n'
string|"'during'"
op|','
name|'events'
op|'.'
name|'append'
op|','
op|'('
string|"'second'"
op|','
string|"'during'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'fireEvent'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|'('
string|"'second'"
op|','
string|"'during'"
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_triggersRunOnce
dedent|''
name|'def'
name|'test_triggersRunOnce'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A trigger should only be called on the first call to\n        L{_ThreePhaseEvent.fireEvent}.\n        """'
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'events'
op|'.'
name|'append'
op|','
string|"'before'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'during'"
op|','
name|'events'
op|'.'
name|'append'
op|','
string|"'during'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'after'"
op|','
name|'events'
op|'.'
name|'append'
op|','
string|"'after'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'fireEvent'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'fireEvent'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
string|"'before'"
op|','
string|"'during'"
op|','
string|"'after'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_finishedBeforeTriggersCleared
dedent|''
name|'def'
name|'test_finishedBeforeTriggersCleared'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The temporary list L{_ThreePhaseEvent.finishedBefore} should be emptied\n        and the state reset to C{\'BASE\'} before the first during-phase trigger\n        executes.\n        """'
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|duringTrigger
name|'def'
name|'duringTrigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'.'
name|'append'
op|'('
string|"'during'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'event'
op|'.'
name|'finishedBefore'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'event'
op|'.'
name|'state'
op|','
string|"'BASE'"
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'events'
op|'.'
name|'append'
op|','
string|"'before'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'addTrigger'
op|'('
string|"'during'"
op|','
name|'duringTrigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'event'
op|'.'
name|'fireEvent'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
string|"'before'"
op|','
string|"'during'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|SystemEventTestCase
dedent|''
dedent|''
name|'class'
name|'SystemEventTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for the reactor\'s implementation of the C{fireSystemEvent},\n    C{addSystemEventTrigger}, and C{removeSystemEventTrigger} methods of the\n    L{IReactorCore} interface.\n\n    @ivar triggers: A list of the handles to triggers which have been added to\n        the reactor.\n    """'
newline|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create an empty list in which to store trigger handles.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'triggers'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tearDown
dedent|''
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Remove all remaining triggers from the reactor.\n        """'
newline|'\n'
name|'while'
name|'self'
op|'.'
name|'triggers'
op|':'
newline|'\n'
indent|'            '
name|'trigger'
op|'='
name|'self'
op|'.'
name|'triggers'
op|'.'
name|'pop'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'reactor'
op|'.'
name|'removeSystemEventTrigger'
op|'('
name|'trigger'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'ValueError'
op|','
name|'KeyError'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|addTrigger
dedent|''
dedent|''
dedent|''
name|'def'
name|'addTrigger'
op|'('
name|'self'
op|','
name|'event'
op|','
name|'phase'
op|','
name|'func'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Add a trigger to the reactor and remember it in C{self.triggers}.\n        """'
newline|'\n'
name|'t'
op|'='
name|'reactor'
op|'.'
name|'addSystemEventTrigger'
op|'('
name|'event'
op|','
name|'phase'
op|','
name|'func'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'triggers'
op|'.'
name|'append'
op|'('
name|'t'
op|')'
newline|'\n'
name|'return'
name|'t'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|removeTrigger
dedent|''
name|'def'
name|'removeTrigger'
op|'('
name|'self'
op|','
name|'trigger'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Remove a trigger by its handle from the reactor and from\n        C{self.triggers}.\n        """'
newline|'\n'
name|'reactor'
op|'.'
name|'removeSystemEventTrigger'
op|'('
name|'trigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'triggers'
op|'.'
name|'remove'
op|'('
name|'trigger'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_addSystemEventTriggerTest
dedent|''
name|'def'
name|'_addSystemEventTriggerTest'
op|'('
name|'self'
op|','
name|'phase'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'eventType'
op|'='
string|"'test'"
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|trigger
name|'def'
name|'trigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'.'
name|'append'
op|'('
name|'None'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'addTrigger'
op|'('
name|'phase'
op|','
name|'eventType'
op|','
name|'trigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'fireSystemEvent'
op|'('
name|'eventType'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
name|'None'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_beforePhase
dedent|''
name|'def'
name|'test_beforePhase'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{IReactorCore.addSystemEventTrigger} should accept the C{\'before\'}\n        phase and not call the given object until the right event is fired.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_addSystemEventTriggerTest'
op|'('
string|"'before'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_duringPhase
dedent|''
name|'def'
name|'test_duringPhase'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{IReactorCore.addSystemEventTrigger} should accept the C{\'during\'}\n        phase and not call the given object until the right event is fired.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_addSystemEventTriggerTest'
op|'('
string|"'during'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_afterPhase
dedent|''
name|'def'
name|'test_afterPhase'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{IReactorCore.addSystemEventTrigger} should accept the C{\'after\'}\n        phase and not call the given object until the right event is fired.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_addSystemEventTriggerTest'
op|'('
string|"'after'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_unknownPhase
dedent|''
name|'def'
name|'test_unknownPhase'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{IReactorCore.addSystemEventTrigger} should reject phases other than\n        C{\'before\'}, C{\'during\'}, or C{\'after\'}.\n        """'
newline|'\n'
name|'eventType'
op|'='
string|"'test'"
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
nl|'\n'
name|'KeyError'
op|','
name|'self'
op|'.'
name|'addTrigger'
op|','
string|"'xxx'"
op|','
name|'eventType'
op|','
name|'lambda'
op|':'
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_beforePreceedsDuring
dedent|''
name|'def'
name|'test_beforePreceedsDuring'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{IReactorCore.addSystemEventTrigger} should call triggers added to the\n        C{\'before\'} phase before it calls triggers added to the C{\'during\'}\n        phase.\n        """'
newline|'\n'
name|'eventType'
op|'='
string|"'test'"
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|beforeTrigger
name|'def'
name|'beforeTrigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'.'
name|'append'
op|'('
string|"'before'"
op|')'
newline|'\n'
DECL|function|duringTrigger
dedent|''
name|'def'
name|'duringTrigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'.'
name|'append'
op|'('
string|"'during'"
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'eventType'
op|','
name|'beforeTrigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addTrigger'
op|'('
string|"'during'"
op|','
name|'eventType'
op|','
name|'duringTrigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'fireSystemEvent'
op|'('
name|'eventType'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
string|"'before'"
op|','
string|"'during'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_duringPreceedsAfter
dedent|''
name|'def'
name|'test_duringPreceedsAfter'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{IReactorCore.addSystemEventTrigger} should call triggers added to the\n        C{\'during\'} phase before it calls triggers added to the C{\'after\'}\n        phase.\n        """'
newline|'\n'
name|'eventType'
op|'='
string|"'test'"
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|duringTrigger
name|'def'
name|'duringTrigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'.'
name|'append'
op|'('
string|"'during'"
op|')'
newline|'\n'
DECL|function|afterTrigger
dedent|''
name|'def'
name|'afterTrigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'.'
name|'append'
op|'('
string|"'after'"
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'addTrigger'
op|'('
string|"'during'"
op|','
name|'eventType'
op|','
name|'duringTrigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addTrigger'
op|'('
string|"'after'"
op|','
name|'eventType'
op|','
name|'afterTrigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'fireSystemEvent'
op|'('
name|'eventType'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
string|"'during'"
op|','
string|"'after'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_beforeReturnsDeferred
dedent|''
name|'def'
name|'test_beforeReturnsDeferred'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a trigger added to the C{\'before\'} phase of an event returns a\n        L{Deferred}, the C{\'during\'} phase should be delayed until it is called\n        back.\n        """'
newline|'\n'
name|'triggerDeferred'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'eventType'
op|'='
string|"'test'"
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|beforeTrigger
name|'def'
name|'beforeTrigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'triggerDeferred'
newline|'\n'
DECL|function|duringTrigger
dedent|''
name|'def'
name|'duringTrigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'.'
name|'append'
op|'('
string|"'during'"
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'eventType'
op|','
name|'beforeTrigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addTrigger'
op|'('
string|"'during'"
op|','
name|'eventType'
op|','
name|'duringTrigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'fireSystemEvent'
op|'('
name|'eventType'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'triggerDeferred'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
string|"'during'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_multipleBeforeReturnDeferred
dedent|''
name|'def'
name|'test_multipleBeforeReturnDeferred'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If more than one trigger added to the C{\'before\'} phase of an event\n        return L{Deferred}s, the C{\'during\'} phase should be delayed until they\n        are all called back.\n        """'
newline|'\n'
name|'firstDeferred'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'secondDeferred'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'eventType'
op|'='
string|"'test'"
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|firstBeforeTrigger
name|'def'
name|'firstBeforeTrigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'firstDeferred'
newline|'\n'
DECL|function|secondBeforeTrigger
dedent|''
name|'def'
name|'secondBeforeTrigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'secondDeferred'
newline|'\n'
DECL|function|duringTrigger
dedent|''
name|'def'
name|'duringTrigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'.'
name|'append'
op|'('
string|"'during'"
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'eventType'
op|','
name|'firstBeforeTrigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'eventType'
op|','
name|'secondBeforeTrigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addTrigger'
op|'('
string|"'during'"
op|','
name|'eventType'
op|','
name|'duringTrigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'fireSystemEvent'
op|'('
name|'eventType'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'firstDeferred'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'secondDeferred'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
string|"'during'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_subsequentBeforeTriggerFiresPriorBeforeDeferred
dedent|''
name|'def'
name|'test_subsequentBeforeTriggerFiresPriorBeforeDeferred'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a trigger added to the C{\'before\'} phase of an event calls back a\n        L{Deferred} returned by an earlier trigger in the C{\'before\'} phase of\n        the same event, the remaining C{\'before\'} triggers for that event\n        should be run and any further L{Deferred}s waited on before proceeding\n        to the C{\'during\'} events.\n        """'
newline|'\n'
name|'eventType'
op|'='
string|"'test'"
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
name|'firstDeferred'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'secondDeferred'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
DECL|function|firstBeforeTrigger
name|'def'
name|'firstBeforeTrigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'firstDeferred'
newline|'\n'
DECL|function|secondBeforeTrigger
dedent|''
name|'def'
name|'secondBeforeTrigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'firstDeferred'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
DECL|function|thirdBeforeTrigger
dedent|''
name|'def'
name|'thirdBeforeTrigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'.'
name|'append'
op|'('
string|"'before'"
op|')'
newline|'\n'
name|'return'
name|'secondDeferred'
newline|'\n'
DECL|function|duringTrigger
dedent|''
name|'def'
name|'duringTrigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'.'
name|'append'
op|'('
string|"'during'"
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'eventType'
op|','
name|'firstBeforeTrigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'eventType'
op|','
name|'secondBeforeTrigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'eventType'
op|','
name|'thirdBeforeTrigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addTrigger'
op|'('
string|"'during'"
op|','
name|'eventType'
op|','
name|'duringTrigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'fireSystemEvent'
op|'('
name|'eventType'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
string|"'before'"
op|']'
op|')'
newline|'\n'
name|'secondDeferred'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
string|"'before'"
op|','
string|"'during'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_removeSystemEventTrigger
dedent|''
name|'def'
name|'test_removeSystemEventTrigger'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A trigger removed with L{IReactorCore.removeSystemEventTrigger} should\n        not be called when the event fires.\n        """'
newline|'\n'
name|'eventType'
op|'='
string|"'test'"
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|firstBeforeTrigger
name|'def'
name|'firstBeforeTrigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'.'
name|'append'
op|'('
string|"'first'"
op|')'
newline|'\n'
DECL|function|secondBeforeTrigger
dedent|''
name|'def'
name|'secondBeforeTrigger'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'.'
name|'append'
op|'('
string|"'second'"
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'eventType'
op|','
name|'firstBeforeTrigger'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'removeTrigger'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'eventType'
op|','
name|'secondBeforeTrigger'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'fireSystemEvent'
op|'('
name|'eventType'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
string|"'first'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_removeNonExistentSystemEventTrigger
dedent|''
name|'def'
name|'test_removeNonExistentSystemEventTrigger'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Passing an object to L{IReactorCore.removeSystemEventTrigger} which was\n        not returned by a previous call to\n        L{IReactorCore.addSystemEventTrigger} or which has already been passed\n        to C{removeSystemEventTrigger} should result in L{TypeError},\n        L{KeyError}, or L{ValueError} being raised.\n        """'
newline|'\n'
name|'b'
op|'='
name|'self'
op|'.'
name|'addTrigger'
op|'('
string|"'during'"
op|','
string|"'test'"
op|','
name|'lambda'
op|':'
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'removeTrigger'
op|'('
name|'b'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
nl|'\n'
name|'TypeError'
op|','
name|'reactor'
op|'.'
name|'removeSystemEventTrigger'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
nl|'\n'
name|'ValueError'
op|','
name|'reactor'
op|'.'
name|'removeSystemEventTrigger'
op|','
name|'b'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
nl|'\n'
name|'KeyError'
op|','
nl|'\n'
name|'reactor'
op|'.'
name|'removeSystemEventTrigger'
op|','
nl|'\n'
op|'('
name|'b'
op|'['
number|'0'
op|']'
op|','
op|'('
string|"'xxx'"
op|','
op|')'
op|'+'
name|'b'
op|'['
number|'1'
op|']'
op|'['
number|'1'
op|':'
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_interactionBetweenDifferentEvents
dedent|''
name|'def'
name|'test_interactionBetweenDifferentEvents'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{IReactorCore.fireSystemEvent} should behave the same way for a\n        particular system event regardless of whether Deferreds are being\n        waited on for a different system event.\n        """'
newline|'\n'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'firstEvent'
op|'='
string|"'first-event'"
newline|'\n'
name|'firstDeferred'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
DECL|function|beforeFirstEvent
name|'def'
name|'beforeFirstEvent'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'.'
name|'append'
op|'('
op|'('
string|"'before'"
op|','
string|"'first'"
op|')'
op|')'
newline|'\n'
name|'return'
name|'firstDeferred'
newline|'\n'
DECL|function|afterFirstEvent
dedent|''
name|'def'
name|'afterFirstEvent'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'.'
name|'append'
op|'('
op|'('
string|"'after'"
op|','
string|"'first'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'secondEvent'
op|'='
string|"'second-event'"
newline|'\n'
name|'secondDeferred'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
DECL|function|beforeSecondEvent
name|'def'
name|'beforeSecondEvent'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'.'
name|'append'
op|'('
op|'('
string|"'before'"
op|','
string|"'second'"
op|')'
op|')'
newline|'\n'
name|'return'
name|'secondDeferred'
newline|'\n'
DECL|function|afterSecondEvent
dedent|''
name|'def'
name|'afterSecondEvent'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'.'
name|'append'
op|'('
op|'('
string|"'after'"
op|','
string|"'second'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'firstEvent'
op|','
name|'beforeFirstEvent'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addTrigger'
op|'('
string|"'after'"
op|','
name|'firstEvent'
op|','
name|'afterFirstEvent'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addTrigger'
op|'('
string|"'before'"
op|','
name|'secondEvent'
op|','
name|'beforeSecondEvent'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addTrigger'
op|'('
string|"'after'"
op|','
name|'secondEvent'
op|','
name|'afterSecondEvent'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|"# After this, firstEvent should be stuck before 'during' waiting for"
nl|'\n'
comment|'# firstDeferred.'
nl|'\n'
name|'reactor'
op|'.'
name|'fireSystemEvent'
op|'('
name|'firstEvent'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|'('
string|"'before'"
op|','
string|"'first'"
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|"# After this, secondEvent should be stuck before 'during' waiting for"
nl|'\n'
comment|'# secondDeferred.'
nl|'\n'
name|'reactor'
op|'.'
name|'fireSystemEvent'
op|'('
name|'secondEvent'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|'('
string|"'before'"
op|','
string|"'first'"
op|')'
op|','
op|'('
string|"'before'"
op|','
string|"'second'"
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# After this, firstEvent should have finished completely, but'
nl|'\n'
comment|'# secondEvent should be at the same place.'
nl|'\n'
name|'firstDeferred'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|'('
string|"'before'"
op|','
string|"'first'"
op|')'
op|','
op|'('
string|"'before'"
op|','
string|"'second'"
op|')'
op|','
nl|'\n'
op|'('
string|"'after'"
op|','
string|"'first'"
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# After this, secondEvent should have finished completely.'
nl|'\n'
name|'secondDeferred'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'events'
op|','
op|'['
op|'('
string|"'before'"
op|','
string|"'first'"
op|')'
op|','
op|'('
string|"'before'"
op|','
string|"'second'"
op|')'
op|','
nl|'\n'
op|'('
string|"'after'"
op|','
string|"'first'"
op|')'
op|','
op|'('
string|"'after'"
op|','
string|"'second'"
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TimeTestCase
dedent|''
dedent|''
name|'class'
name|'TimeTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for the IReactorTime part of the reactor.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_seconds
name|'def'
name|'test_seconds'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{twisted.internet.reactor.seconds} should return something\n        like a number.\n\n        1. This test specifically does not assert any relation to the\n           "system time" as returned by L{time.time} or\n           L{twisted.python.runtime.seconds}, because at some point we\n           may find a better option for scheduling calls than\n           wallclock-time.\n        2. This test *also* does not assert anything about the type of\n           the result, because operations may not return ints or\n           floats: For example, datetime-datetime == timedelta(0).\n        """'
newline|'\n'
name|'now'
op|'='
name|'reactor'
op|'.'
name|'seconds'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'now'
op|'-'
name|'now'
op|'+'
name|'now'
op|','
name|'now'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_callLaterUsesReactorSecondsInDelayedCall
dedent|''
name|'def'
name|'test_callLaterUsesReactorSecondsInDelayedCall'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{reactor.callLater} should use the reactor\'s seconds factory\n        to produce the time at which the DelayedCall will be called.\n        """'
newline|'\n'
name|'oseconds'
op|'='
name|'reactor'
op|'.'
name|'seconds'
newline|'\n'
name|'reactor'
op|'.'
name|'seconds'
op|'='
name|'lambda'
op|':'
number|'100'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'call'
op|'='
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'5'
op|','
name|'lambda'
op|':'
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'call'
op|'.'
name|'getTime'
op|'('
op|')'
op|','
number|'105'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'reactor'
op|'.'
name|'seconds'
op|'='
name|'oseconds'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_callLaterUsesReactorSecondsAsDelayedCallSecondsFactory
dedent|''
dedent|''
name|'def'
name|'test_callLaterUsesReactorSecondsAsDelayedCallSecondsFactory'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{reactor.callLater} should propagate its own seconds factory\n        to the DelayedCall to use as its own seconds factory.\n        """'
newline|'\n'
name|'oseconds'
op|'='
name|'reactor'
op|'.'
name|'seconds'
newline|'\n'
name|'reactor'
op|'.'
name|'seconds'
op|'='
name|'lambda'
op|':'
number|'100'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'call'
op|'='
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'5'
op|','
name|'lambda'
op|':'
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'call'
op|'.'
name|'seconds'
op|'('
op|')'
op|','
number|'100'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'reactor'
op|'.'
name|'seconds'
op|'='
name|'oseconds'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_callLater
dedent|''
dedent|''
name|'def'
name|'test_callLater'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that a DelayedCall really calls the function it is\n        supposed to call.\n        """'
newline|'\n'
name|'d'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'d'
op|'.'
name|'callback'
op|','
name|'None'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'assertEqual'
op|','
name|'None'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_cancelDelayedCall
dedent|''
name|'def'
name|'test_cancelDelayedCall'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that when a DelayedCall is cancelled it does not run.\n        """'
newline|'\n'
name|'called'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|function
name|'def'
name|'function'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'called'
op|'.'
name|'append'
op|'('
name|'None'
op|')'
newline|'\n'
dedent|''
name|'call'
op|'='
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'function'
op|')'
newline|'\n'
name|'call'
op|'.'
name|'cancel'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Schedule a call in two "iterations" to check to make sure that the'
nl|'\n'
comment|'# above call never ran.'
nl|'\n'
name|'d'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'called'
op|','
op|'['
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'                '
name|'d'
op|'.'
name|'errback'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'d'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'reactor'
op|'.'
name|'callLater'
op|','
number|'0'
op|','
name|'check'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_cancelCancelledDelayedCall
dedent|''
name|'def'
name|'test_cancelCancelledDelayedCall'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that cancelling a DelayedCall which has already been cancelled\n        raises the appropriate exception.\n        """'
newline|'\n'
name|'call'
op|'='
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'lambda'
op|':'
name|'None'
op|')'
newline|'\n'
name|'call'
op|'.'
name|'cancel'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'error'
op|'.'
name|'AlreadyCancelled'
op|','
name|'call'
op|'.'
name|'cancel'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_cancelCalledDelayedCallSynchronous
dedent|''
name|'def'
name|'test_cancelCalledDelayedCallSynchronous'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that cancelling a DelayedCall in the DelayedCall\'s function as\n        that function is being invoked by the DelayedCall raises the\n        appropriate exception.\n        """'
newline|'\n'
name|'d'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
DECL|function|later
name|'def'
name|'later'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'error'
op|'.'
name|'AlreadyCalled'
op|','
name|'call'
op|'.'
name|'cancel'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'                '
name|'d'
op|'.'
name|'errback'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'d'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'call'
op|'='
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'later'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_cancelCalledDelayedCallAsynchronous
dedent|''
name|'def'
name|'test_cancelCalledDelayedCallAsynchronous'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that cancelling a DelayedCall after it has run its function\n        raises the appropriate exception.\n        """'
newline|'\n'
name|'d'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'error'
op|'.'
name|'AlreadyCalled'
op|','
name|'call'
op|'.'
name|'cancel'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'                '
name|'d'
op|'.'
name|'errback'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'d'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
DECL|function|later
dedent|''
dedent|''
name|'def'
name|'later'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'check'
op|')'
newline|'\n'
dedent|''
name|'call'
op|'='
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'later'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testCallLaterTime
dedent|''
name|'def'
name|'testCallLaterTime'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'d'
op|'='
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'10'
op|','
name|'lambda'
op|':'
name|'None'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'d'
op|'.'
name|'getTime'
op|'('
op|')'
op|'-'
op|'('
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|'+'
number|'10'
op|')'
op|'<'
number|'1'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'.'
name|'cancel'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|testCallLaterOrder
dedent|''
dedent|''
name|'def'
name|'testCallLaterOrder'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'l2'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|f
name|'def'
name|'f'
op|'('
name|'x'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'l'
op|'.'
name|'append'
op|'('
name|'x'
op|')'
newline|'\n'
DECL|function|f2
dedent|''
name|'def'
name|'f2'
op|'('
name|'x'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'l2'
op|'.'
name|'append'
op|'('
name|'x'
op|')'
newline|'\n'
DECL|function|done
dedent|''
name|'def'
name|'done'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'l'
op|','
name|'range'
op|'('
number|'20'
op|')'
op|')'
newline|'\n'
DECL|function|done2
dedent|''
name|'def'
name|'done2'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'l2'
op|','
name|'range'
op|'('
number|'10'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'n'
name|'in'
name|'range'
op|'('
number|'10'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'f'
op|','
name|'n'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'n'
name|'in'
name|'range'
op|'('
number|'10'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'f'
op|','
name|'n'
op|'+'
number|'10'
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0.1'
op|','
name|'f2'
op|','
name|'n'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'done'
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0.1'
op|','
name|'done2'
op|')'
newline|'\n'
name|'d'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0.2'
op|','
name|'d'
op|'.'
name|'callback'
op|','
name|'None'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
dedent|''
name|'testCallLaterOrder'
op|'.'
name|'todo'
op|'='
string|'"See bug 1396"'
newline|'\n'
name|'testCallLaterOrder'
op|'.'
name|'skip'
op|'='
string|'"Trial bug, todo doesn\'t work! See bug 1397"'
newline|'\n'
DECL|member|testCallLaterOrder2
name|'def'
name|'testCallLaterOrder2'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# This time destroy the clock resolution so that it fails reliably'
nl|'\n'
comment|"# even on systems that don't have a crappy clock resolution."
nl|'\n'
nl|'\n'
DECL|function|seconds
indent|'        '
name|'def'
name|'seconds'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'int'
op|'('
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'base_original'
op|'='
name|'base'
op|'.'
name|'seconds'
newline|'\n'
name|'runtime_original'
op|'='
name|'runtime'
op|'.'
name|'seconds'
newline|'\n'
name|'base'
op|'.'
name|'seconds'
op|'='
name|'seconds'
newline|'\n'
name|'runtime'
op|'.'
name|'seconds'
op|'='
name|'seconds'
newline|'\n'
nl|'\n'
DECL|function|cleanup
name|'def'
name|'cleanup'
op|'('
name|'x'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'runtime'
op|'.'
name|'seconds'
op|'='
name|'runtime_original'
newline|'\n'
name|'base'
op|'.'
name|'seconds'
op|'='
name|'base_original'
newline|'\n'
name|'return'
name|'x'
newline|'\n'
dedent|''
name|'return'
name|'maybeDeferred'
op|'('
name|'self'
op|'.'
name|'testCallLaterOrder'
op|')'
op|'.'
name|'addBoth'
op|'('
name|'cleanup'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'testCallLaterOrder2'
op|'.'
name|'todo'
op|'='
string|'"See bug 1396"'
newline|'\n'
name|'testCallLaterOrder2'
op|'.'
name|'skip'
op|'='
string|'"Trial bug, todo doesn\'t work! See bug 1397"'
newline|'\n'
nl|'\n'
DECL|member|testDelayedCallStringification
name|'def'
name|'testDelayedCallStringification'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|"# Mostly just make sure str() isn't going to raise anything for"
nl|'\n'
comment|'# DelayedCalls within reason.'
nl|'\n'
indent|'        '
name|'dc'
op|'='
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'lambda'
name|'x'
op|','
name|'y'
op|':'
name|'None'
op|','
string|"'x'"
op|','
name|'y'
op|'='
number|'10'
op|')'
newline|'\n'
name|'str'
op|'('
name|'dc'
op|')'
newline|'\n'
name|'dc'
op|'.'
name|'reset'
op|'('
number|'5'
op|')'
newline|'\n'
name|'str'
op|'('
name|'dc'
op|')'
newline|'\n'
name|'dc'
op|'.'
name|'cancel'
op|'('
op|')'
newline|'\n'
name|'str'
op|'('
name|'dc'
op|')'
newline|'\n'
nl|'\n'
name|'dc'
op|'='
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'lambda'
op|':'
name|'None'
op|','
name|'x'
op|'='
op|'['
op|'('
op|'{'
string|"'hello'"
op|':'
string|"u'world'"
op|'}'
op|','
number|'10j'
op|')'
op|','
name|'reactor'
op|']'
op|','
op|'*'
name|'range'
op|'('
number|'10'
op|')'
op|')'
newline|'\n'
name|'str'
op|'('
name|'dc'
op|')'
newline|'\n'
name|'dc'
op|'.'
name|'cancel'
op|'('
op|')'
newline|'\n'
name|'str'
op|'('
name|'dc'
op|')'
newline|'\n'
nl|'\n'
DECL|function|calledBack
name|'def'
name|'calledBack'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'str'
op|'('
name|'dc'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'='
name|'Deferred'
op|'('
op|')'
op|'.'
name|'addCallback'
op|'('
name|'calledBack'
op|')'
newline|'\n'
name|'dc'
op|'='
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'d'
op|'.'
name|'callback'
op|','
name|'None'
op|')'
newline|'\n'
name|'str'
op|'('
name|'dc'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testDelayedCallSecondsOverride
dedent|''
name|'def'
name|'testDelayedCallSecondsOverride'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that the C{seconds} argument to DelayedCall gets used instead of\n        the default timing function, if it is not None.\n        """'
newline|'\n'
DECL|function|seconds
name|'def'
name|'seconds'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
number|'10'
newline|'\n'
dedent|''
name|'dc'
op|'='
name|'base'
op|'.'
name|'DelayedCall'
op|'('
number|'5'
op|','
name|'lambda'
op|':'
name|'None'
op|','
op|'('
op|')'
op|','
op|'{'
op|'}'
op|','
name|'lambda'
name|'dc'
op|':'
name|'None'
op|','
nl|'\n'
name|'lambda'
name|'dc'
op|':'
name|'None'
op|','
name|'seconds'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'dc'
op|'.'
name|'getTime'
op|'('
op|')'
op|','
number|'5'
op|')'
newline|'\n'
name|'dc'
op|'.'
name|'reset'
op|'('
number|'3'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'dc'
op|'.'
name|'getTime'
op|'('
op|')'
op|','
number|'13'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|CallFromThreadTests
dedent|''
dedent|''
name|'class'
name|'CallFromThreadTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|testWakeUp
indent|'    '
name|'def'
name|'testWakeUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# Make sure other threads can wake up the reactor'
nl|'\n'
indent|'        '
name|'d'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
DECL|function|wake
name|'def'
name|'wake'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'time'
op|'.'
name|'sleep'
op|'('
number|'0.1'
op|')'
newline|'\n'
comment|'# callFromThread will call wakeUp for us'
nl|'\n'
name|'reactor'
op|'.'
name|'callFromThread'
op|'('
name|'d'
op|'.'
name|'callback'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'reactor'
op|'.'
name|'callInThread'
op|'('
name|'wake'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'interfaces'
op|'.'
name|'IReactorThreads'
op|'('
name|'reactor'
op|','
name|'None'
op|')'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'testWakeUp'
op|'.'
name|'skip'
op|'='
string|'"Nothing to wake up for without thread support"'
newline|'\n'
nl|'\n'
DECL|member|_stopCallFromThreadCallback
dedent|''
name|'def'
name|'_stopCallFromThreadCallback'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'stopped'
op|'='
name|'True'
newline|'\n'
nl|'\n'
DECL|member|_callFromThreadCallback
dedent|''
name|'def'
name|'_callFromThreadCallback'
op|'('
name|'self'
op|','
name|'d'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'reactor'
op|'.'
name|'callFromThread'
op|'('
name|'self'
op|'.'
name|'_callFromThreadCallback2'
op|','
name|'d'
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'self'
op|'.'
name|'_stopCallFromThreadCallback'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_callFromThreadCallback2
dedent|''
name|'def'
name|'_callFromThreadCallback2'
op|'('
name|'self'
op|','
name|'d'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assert_'
op|'('
name|'self'
op|'.'
name|'stopped'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
comment|'# Send the error to the deferred'
nl|'\n'
indent|'            '
name|'d'
op|'.'
name|'errback'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testCallFromThreadStops
dedent|''
dedent|''
name|'def'
name|'testCallFromThreadStops'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Ensure that callFromThread from inside a callFromThread\n        callback doesn\'t sit in an infinite loop and lets other\n        things happen too.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'stopped'
op|'='
name|'False'
newline|'\n'
name|'d'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'callFromThread'
op|'('
name|'self'
op|'.'
name|'_callFromThreadCallback'
op|','
name|'d'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DelayedTestCase
dedent|''
dedent|''
name|'class'
name|'DelayedTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|setUp
indent|'    '
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'finished'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'counter'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'timers'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'deferred'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|tearDown
dedent|''
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'t'
name|'in'
name|'self'
op|'.'
name|'timers'
op|'.'
name|'values'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'t'
op|'.'
name|'cancel'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|checkTimers
dedent|''
dedent|''
name|'def'
name|'checkTimers'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'l1'
op|'='
name|'self'
op|'.'
name|'timers'
op|'.'
name|'values'
op|'('
op|')'
newline|'\n'
name|'l2'
op|'='
name|'list'
op|'('
name|'reactor'
op|'.'
name|'getDelayedCalls'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# There should be at least the calls we put in.  There may be other'
nl|'\n'
comment|'# calls that are none of our business and that we should ignore,'
nl|'\n'
comment|'# though.'
nl|'\n'
nl|'\n'
name|'missing'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'dc'
name|'in'
name|'l1'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'dc'
name|'not'
name|'in'
name|'l2'
op|':'
newline|'\n'
indent|'                '
name|'missing'
op|'.'
name|'append'
op|'('
name|'dc'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'missing'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'finished'
op|'='
number|'1'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'failIf'
op|'('
name|'missing'
op|','
string|'"Should have been missing no calls, instead was missing "'
op|'+'
name|'repr'
op|'('
name|'missing'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|callback
dedent|''
name|'def'
name|'callback'
op|'('
name|'self'
op|','
name|'tag'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'del'
name|'self'
op|'.'
name|'timers'
op|'['
name|'tag'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'checkTimers'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|addCallback
dedent|''
name|'def'
name|'addCallback'
op|'('
name|'self'
op|','
name|'tag'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'callback'
op|'('
name|'tag'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addTimer'
op|'('
number|'15'
op|','
name|'self'
op|'.'
name|'callback'
op|')'
newline|'\n'
nl|'\n'
DECL|member|done
dedent|''
name|'def'
name|'done'
op|'('
name|'self'
op|','
name|'tag'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'finished'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'callback'
op|'('
name|'tag'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'deferred'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
DECL|member|addTimer
dedent|''
name|'def'
name|'addTimer'
op|'('
name|'self'
op|','
name|'when'
op|','
name|'callback'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'timers'
op|'['
name|'self'
op|'.'
name|'counter'
op|']'
op|'='
name|'reactor'
op|'.'
name|'callLater'
op|'('
name|'when'
op|'*'
number|'0.01'
op|','
name|'callback'
op|','
nl|'\n'
name|'self'
op|'.'
name|'counter'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'counter'
op|'+='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'checkTimers'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|testGetDelayedCalls
dedent|''
name|'def'
name|'testGetDelayedCalls'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'hasattr'
op|'('
name|'reactor'
op|','
string|'"getDelayedCalls"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
comment|"# This is not a race because we don't do anything which might call"
nl|'\n'
comment|'# the reactor until we have all the timers set up. If we did, this'
nl|'\n'
comment|'# test might fail on slow systems.'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'checkTimers'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addTimer'
op|'('
number|'35'
op|','
name|'self'
op|'.'
name|'done'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addTimer'
op|'('
number|'20'
op|','
name|'self'
op|'.'
name|'callback'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addTimer'
op|'('
number|'30'
op|','
name|'self'
op|'.'
name|'callback'
op|')'
newline|'\n'
name|'which'
op|'='
name|'self'
op|'.'
name|'counter'
newline|'\n'
name|'self'
op|'.'
name|'addTimer'
op|'('
number|'29'
op|','
name|'self'
op|'.'
name|'callback'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addTimer'
op|'('
number|'25'
op|','
name|'self'
op|'.'
name|'addCallback'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addTimer'
op|'('
number|'26'
op|','
name|'self'
op|'.'
name|'callback'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'timers'
op|'['
name|'which'
op|']'
op|'.'
name|'cancel'
op|'('
op|')'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'timers'
op|'['
name|'which'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'checkTimers'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'deferred'
op|'.'
name|'addCallback'
op|'('
name|'lambda'
name|'x'
op|':'
name|'self'
op|'.'
name|'checkTimers'
op|'('
op|')'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'deferred'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_active
dedent|''
name|'def'
name|'test_active'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{IDelayedCall.active} returns False once the call has run.\n        """'
newline|'\n'
name|'dcall'
op|'='
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0.01'
op|','
name|'self'
op|'.'
name|'deferred'
op|'.'
name|'callback'
op|','
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'dcall'
op|'.'
name|'active'
op|'('
op|')'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
DECL|function|checkDeferredCall
name|'def'
name|'checkDeferredCall'
op|'('
name|'success'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'dcall'
op|'.'
name|'active'
op|'('
op|')'
op|','
name|'False'
op|')'
newline|'\n'
name|'return'
name|'success'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'deferred'
op|'.'
name|'addCallback'
op|'('
name|'checkDeferredCall'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'deferred'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'resolve_helper'
op|'='
string|'"""\nimport %(reactor)s\n%(reactor)s.install()\nfrom twisted.internet import reactor\n\nclass Foo:\n    def __init__(self):\n        reactor.callWhenRunning(self.start)\n        self.timer = reactor.callLater(3, self.failed)\n    def start(self):\n        reactor.resolve(\'localhost\').addBoth(self.done)\n    def done(self, res):\n        print \'done\', res\n        reactor.stop()\n    def failed(self):\n        print \'failed\'\n        self.timer = None\n        reactor.stop()\nf = Foo()\nreactor.run()\n"""'
newline|'\n'
nl|'\n'
DECL|class|ChildResolveProtocol
name|'class'
name|'ChildResolveProtocol'
op|'('
name|'protocol'
op|'.'
name|'ProcessProtocol'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'onCompletion'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'onCompletion'
op|'='
name|'onCompletion'
newline|'\n'
nl|'\n'
DECL|member|connectionMade
dedent|''
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'output'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'error'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|outReceived
dedent|''
name|'def'
name|'outReceived'
op|'('
name|'self'
op|','
name|'out'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'output'
op|'.'
name|'append'
op|'('
name|'out'
op|')'
newline|'\n'
nl|'\n'
DECL|member|errReceived
dedent|''
name|'def'
name|'errReceived'
op|'('
name|'self'
op|','
name|'err'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'error'
op|'.'
name|'append'
op|'('
name|'err'
op|')'
newline|'\n'
nl|'\n'
DECL|member|processEnded
dedent|''
name|'def'
name|'processEnded'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'onCompletion'
op|'.'
name|'callback'
op|'('
op|'('
name|'reason'
op|','
name|'self'
op|'.'
name|'output'
op|','
name|'self'
op|'.'
name|'error'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'onCompletion'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Resolve
dedent|''
dedent|''
name|'class'
name|'Resolve'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|testChildResolve
indent|'    '
name|'def'
name|'testChildResolve'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|"# I've seen problems with reactor.run under gtk2reactor. Spawn a"
nl|'\n'
comment|'# child which just does reactor.resolve after the reactor has'
nl|'\n'
comment|'# started, fail if it does not complete in a timely fashion.'
nl|'\n'
indent|'        '
name|'helperPath'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'abspath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'helperFile'
op|'='
name|'open'
op|'('
name|'helperPath'
op|','
string|"'w'"
op|')'
newline|'\n'
nl|'\n'
comment|'# Eeueuuggg'
nl|'\n'
name|'reactorName'
op|'='
name|'reactor'
op|'.'
name|'__module__'
newline|'\n'
nl|'\n'
name|'helperFile'
op|'.'
name|'write'
op|'('
name|'resolve_helper'
op|'%'
op|'{'
string|"'reactor'"
op|':'
name|'reactorName'
op|'}'
op|')'
newline|'\n'
name|'helperFile'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'env'
op|'='
name|'os'
op|'.'
name|'environ'
op|'.'
name|'copy'
op|'('
op|')'
newline|'\n'
name|'env'
op|'['
string|"'PYTHONPATH'"
op|']'
op|'='
name|'os'
op|'.'
name|'pathsep'
op|'.'
name|'join'
op|'('
name|'sys'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
name|'helperDeferred'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'helperProto'
op|'='
name|'ChildResolveProtocol'
op|'('
name|'helperDeferred'
op|')'
newline|'\n'
nl|'\n'
name|'reactor'
op|'.'
name|'spawnProcess'
op|'('
name|'helperProto'
op|','
name|'sys'
op|'.'
name|'executable'
op|','
op|'('
string|'"python"'
op|','
string|'"-u"'
op|','
name|'helperPath'
op|')'
op|','
name|'env'
op|')'
newline|'\n'
nl|'\n'
DECL|function|cbFinished
name|'def'
name|'cbFinished'
op|'('
op|'('
name|'reason'
op|','
name|'output'
op|','
name|'error'
op|')'
op|')'
op|':'
newline|'\n'
comment|'# If the output is "done 127.0.0.1\\n" we don\'t really care what'
nl|'\n'
comment|'# else happened.'
nl|'\n'
indent|'            '
name|'output'
op|'='
string|"''"
op|'.'
name|'join'
op|'('
name|'output'
op|')'
newline|'\n'
name|'if'
name|'output'
op|'!='
string|"'done 127.0.0.1\\n'"
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'fail'
op|'('
op|'('
nl|'\n'
string|'"The child process failed to produce the desired results:\\n"'
nl|'\n'
string|'"   Reason for termination was: %r\\n"'
nl|'\n'
string|'"   Output stream was: %r\\n"'
nl|'\n'
string|'"   Error stream was: %r\\n"'
op|')'
op|'%'
op|'('
name|'reason'
op|'.'
name|'getErrorMessage'
op|'('
op|')'
op|','
name|'output'
op|','
string|"''"
op|'.'
name|'join'
op|'('
name|'error'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'helperDeferred'
op|'.'
name|'addCallback'
op|'('
name|'cbFinished'
op|')'
newline|'\n'
name|'return'
name|'helperDeferred'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'interfaces'
op|'.'
name|'IReactorProcess'
op|'('
name|'reactor'
op|','
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'Resolve'
op|'.'
name|'skip'
op|'='
string|'"cannot run test: reactor doesn\'t support IReactorProcess"'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|CallFromThreadTestCase
dedent|''
name|'class'
name|'CallFromThreadTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Task scheduling from threads tests.\n    """'
newline|'\n'
name|'if'
name|'interfaces'
op|'.'
name|'IReactorThreads'
op|'('
name|'reactor'
op|','
name|'None'
op|')'
name|'is'
name|'None'
op|':'
newline|'\n'
DECL|variable|skip
indent|'        '
name|'skip'
op|'='
string|'"Nothing to test without thread support"'
newline|'\n'
nl|'\n'
DECL|member|setUp
dedent|''
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'counter'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'deferred'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|schedule
dedent|''
name|'def'
name|'schedule'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Override in subclasses.\n        """'
newline|'\n'
name|'reactor'
op|'.'
name|'callFromThread'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_lotsOfThreadsAreScheduledCorrectly
dedent|''
name|'def'
name|'test_lotsOfThreadsAreScheduledCorrectly'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{IReactorThreads.callFromThread} can be used to schedule a large\n        number of calls in the reactor thread.\n        """'
newline|'\n'
DECL|function|addAndMaybeFinish
name|'def'
name|'addAndMaybeFinish'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'counter'
op|'+='
number|'1'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'counter'
op|'=='
number|'100'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'deferred'
op|'.'
name|'callback'
op|'('
name|'True'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'for'
name|'i'
name|'in'
name|'xrange'
op|'('
number|'100'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'schedule'
op|'('
name|'addAndMaybeFinish'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'deferred'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_threadsAreRunInScheduledOrder
dedent|''
name|'def'
name|'test_threadsAreRunInScheduledOrder'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Callbacks should be invoked in the order they were scheduled.\n        """'
newline|'\n'
name|'order'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
name|'_'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'order'
op|','
op|'['
number|'1'
op|','
number|'2'
op|','
number|'3'
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'deferred'
op|'.'
name|'addCallback'
op|'('
name|'check'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'schedule'
op|'('
name|'order'
op|'.'
name|'append'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'schedule'
op|'('
name|'order'
op|'.'
name|'append'
op|','
number|'2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'schedule'
op|'('
name|'order'
op|'.'
name|'append'
op|','
number|'3'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'schedule'
op|'('
name|'reactor'
op|'.'
name|'callFromThread'
op|','
name|'self'
op|'.'
name|'deferred'
op|'.'
name|'callback'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'deferred'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_scheduledThreadsNotRunUntilReactorRuns
dedent|''
name|'def'
name|'test_scheduledThreadsNotRunUntilReactorRuns'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Scheduled tasks should not be run until the reactor starts running.\n        """'
newline|'\n'
DECL|function|incAndFinish
name|'def'
name|'incAndFinish'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'counter'
op|'='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'deferred'
op|'.'
name|'callback'
op|'('
name|'True'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'schedule'
op|'('
name|'incAndFinish'
op|')'
newline|'\n'
nl|'\n'
comment|"# Callback shouldn't have fired yet."
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'counter'
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'deferred'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|MyProtocol
dedent|''
dedent|''
name|'class'
name|'MyProtocol'
op|'('
name|'protocol'
op|'.'
name|'Protocol'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Sample protocol.\n    """'
newline|'\n'
nl|'\n'
DECL|class|MyFactory
dedent|''
name|'class'
name|'MyFactory'
op|'('
name|'protocol'
op|'.'
name|'Factory'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Sample factory.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|protocol
name|'protocol'
op|'='
name|'MyProtocol'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ProtocolTestCase
dedent|''
name|'class'
name|'ProtocolTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|testFactory
indent|'    '
name|'def'
name|'testFactory'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'factory'
op|'='
name|'MyFactory'
op|'('
op|')'
newline|'\n'
name|'protocol'
op|'='
name|'factory'
op|'.'
name|'buildProtocol'
op|'('
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'protocol'
op|'.'
name|'factory'
op|','
name|'factory'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assert_'
op|'('
name|'isinstance'
op|'('
name|'protocol'
op|','
name|'factory'
op|'.'
name|'protocol'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DummyProducer
dedent|''
dedent|''
name|'class'
name|'DummyProducer'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Very uninteresting producer implementation used by tests to ensure the\n    right methods are called by the consumer with which it is registered.\n\n    @type events: C{list} of C{str}\n    @ivar events: The producer/consumer related events which have happened to\n    this producer.  Strings in this list may be C{\'resume\'}, C{\'stop\'}, or\n    C{\'pause\'}.  Elements are added as they occur.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|resumeProducing
dedent|''
name|'def'
name|'resumeProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'events'
op|'.'
name|'append'
op|'('
string|"'resume'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|stopProducing
dedent|''
name|'def'
name|'stopProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'events'
op|'.'
name|'append'
op|'('
string|"'stop'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|pauseProducing
dedent|''
name|'def'
name|'pauseProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'events'
op|'.'
name|'append'
op|'('
string|"'pause'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|SillyDescriptor
dedent|''
dedent|''
name|'class'
name|'SillyDescriptor'
op|'('
name|'abstract'
op|'.'
name|'FileDescriptor'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A descriptor whose data buffer gets filled very fast.\n\n    Useful for testing FileDescriptor\'s IConsumer interface, since\n    the data buffer fills as soon as at least four characters are\n    written to it, and gets emptied in a single doWrite() cycle.\n    """'
newline|'\n'
DECL|variable|bufferSize
name|'bufferSize'
op|'='
number|'3'
newline|'\n'
DECL|variable|connected
name|'connected'
op|'='
name|'True'
newline|'\n'
nl|'\n'
DECL|member|writeSomeData
name|'def'
name|'writeSomeData'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Always write all data.\n        """'
newline|'\n'
name|'return'
name|'len'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|startWriting
dedent|''
name|'def'
name|'startWriting'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Do nothing: bypass the reactor.\n        """'
newline|'\n'
DECL|variable|stopWriting
dedent|''
name|'stopWriting'
op|'='
name|'startWriting'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ReentrantProducer
dedent|''
name|'class'
name|'ReentrantProducer'
op|'('
name|'DummyProducer'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Similar to L{DummyProducer}, but with a resumeProducing method which calls\n    back into an L{IConsumer} method of the consumer against which it is\n    registered.\n\n    @ivar consumer: The consumer with which this producer has been or will\n    be registered.\n\n    @ivar methodName: The name of the method to call on the consumer inside\n    C{resumeProducing}.\n\n    @ivar methodArgs: The arguments to pass to the consumer method invoked in\n    C{resumeProducing}.\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'consumer'
op|','
name|'methodName'
op|','
op|'*'
name|'methodArgs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'super'
op|'('
name|'ReentrantProducer'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'consumer'
op|'='
name|'consumer'
newline|'\n'
name|'self'
op|'.'
name|'methodName'
op|'='
name|'methodName'
newline|'\n'
name|'self'
op|'.'
name|'methodArgs'
op|'='
name|'methodArgs'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|resumeProducing
dedent|''
name|'def'
name|'resumeProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'super'
op|'('
name|'ReentrantProducer'
op|','
name|'self'
op|')'
op|'.'
name|'resumeProducing'
op|'('
op|')'
newline|'\n'
name|'getattr'
op|'('
name|'self'
op|'.'
name|'consumer'
op|','
name|'self'
op|'.'
name|'methodName'
op|')'
op|'('
op|'*'
name|'self'
op|'.'
name|'methodArgs'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestProducer
dedent|''
dedent|''
name|'class'
name|'TestProducer'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test abstract.FileDescriptor\'s consumer interface.\n    """'
newline|'\n'
DECL|member|test_doubleProducer
name|'def'
name|'test_doubleProducer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that registering a non-streaming producer invokes its\n        resumeProducing() method and that you can only register one producer\n        at a time.\n        """'
newline|'\n'
name|'fd'
op|'='
name|'abstract'
op|'.'
name|'FileDescriptor'
op|'('
op|')'
newline|'\n'
name|'fd'
op|'.'
name|'connected'
op|'='
number|'1'
newline|'\n'
name|'dp'
op|'='
name|'DummyProducer'
op|'('
op|')'
newline|'\n'
name|'fd'
op|'.'
name|'registerProducer'
op|'('
name|'dp'
op|','
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'dp'
op|'.'
name|'events'
op|','
op|'['
string|"'resume'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'RuntimeError'
op|','
name|'fd'
op|'.'
name|'registerProducer'
op|','
name|'DummyProducer'
op|'('
op|')'
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_unconnectedFileDescriptor
dedent|''
name|'def'
name|'test_unconnectedFileDescriptor'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that registering a producer when the connection has already\n        been closed invokes its stopProducing() method.\n        """'
newline|'\n'
name|'fd'
op|'='
name|'abstract'
op|'.'
name|'FileDescriptor'
op|'('
op|')'
newline|'\n'
name|'fd'
op|'.'
name|'disconnected'
op|'='
number|'1'
newline|'\n'
name|'dp'
op|'='
name|'DummyProducer'
op|'('
op|')'
newline|'\n'
name|'fd'
op|'.'
name|'registerProducer'
op|'('
name|'dp'
op|','
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'dp'
op|'.'
name|'events'
op|','
op|'['
string|"'stop'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_dontPausePullConsumerTest
dedent|''
name|'def'
name|'_dontPausePullConsumerTest'
op|'('
name|'self'
op|','
name|'methodName'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'descriptor'
op|'='
name|'SillyDescriptor'
op|'('
op|')'
newline|'\n'
name|'producer'
op|'='
name|'DummyProducer'
op|'('
op|')'
newline|'\n'
name|'descriptor'
op|'.'
name|'registerProducer'
op|'('
name|'producer'
op|','
name|'streaming'
op|'='
name|'False'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'producer'
op|'.'
name|'events'
op|','
op|'['
string|"'resume'"
op|']'
op|')'
newline|'\n'
name|'del'
name|'producer'
op|'.'
name|'events'
op|'['
op|':'
op|']'
newline|'\n'
nl|'\n'
comment|"# Fill up the descriptor's write buffer so we can observe whether or"
nl|'\n'
comment|'# not it pauses its producer in that case.'
nl|'\n'
name|'getattr'
op|'('
name|'descriptor'
op|','
name|'methodName'
op|')'
op|'('
string|"'1234'"
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'producer'
op|'.'
name|'events'
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_dontPausePullConsumerOnWrite
dedent|''
name|'def'
name|'test_dontPausePullConsumerOnWrite'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that FileDescriptor does not call producer.pauseProducing() on a\n        non-streaming pull producer in response to a L{IConsumer.write} call\n        which results in a full write buffer. Issue #2286.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_dontPausePullConsumerTest'
op|'('
string|"'write'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_dontPausePullConsumerOnWriteSequence
dedent|''
name|'def'
name|'test_dontPausePullConsumerOnWriteSequence'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Like L{test_dontPausePullConsumerOnWrite}, but for a call to\n        C{writeSequence} rather than L{IConsumer.write}.\n\n        C{writeSequence} is not part of L{IConsumer}, but\n        L{abstract.FileDescriptor} has supported consumery behavior in response\n        to calls to L{writeSequence} forever.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_dontPausePullConsumerTest'
op|'('
string|"'writeSequence'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_reentrantStreamingProducerTest
dedent|''
name|'def'
name|'_reentrantStreamingProducerTest'
op|'('
name|'self'
op|','
name|'methodName'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'descriptor'
op|'='
name|'SillyDescriptor'
op|'('
op|')'
newline|'\n'
name|'producer'
op|'='
name|'ReentrantProducer'
op|'('
name|'descriptor'
op|','
name|'methodName'
op|','
string|"'spam'"
op|')'
newline|'\n'
name|'descriptor'
op|'.'
name|'registerProducer'
op|'('
name|'producer'
op|','
name|'streaming'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
comment|"# Start things off by filling up the descriptor's buffer so it will"
nl|'\n'
comment|'# pause its producer.'
nl|'\n'
name|'getattr'
op|'('
name|'descriptor'
op|','
name|'methodName'
op|')'
op|'('
string|"'spam'"
op|')'
newline|'\n'
nl|'\n'
comment|'# Sanity check - make sure that worked.'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'producer'
op|'.'
name|'events'
op|','
op|'['
string|"'pause'"
op|']'
op|')'
newline|'\n'
name|'del'
name|'producer'
op|'.'
name|'events'
op|'['
op|':'
op|']'
newline|'\n'
nl|'\n'
comment|'# After one call to doWrite, the buffer has been emptied so the'
nl|'\n'
comment|'# FileDescriptor should resume its producer.  That will result in an'
nl|'\n'
comment|'# immediate call to FileDescriptor.write which will again fill the'
nl|'\n'
comment|'# buffer and result in the producer being paused.'
nl|'\n'
name|'descriptor'
op|'.'
name|'doWrite'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'producer'
op|'.'
name|'events'
op|','
op|'['
string|"'resume'"
op|','
string|"'pause'"
op|']'
op|')'
newline|'\n'
name|'del'
name|'producer'
op|'.'
name|'events'
op|'['
op|':'
op|']'
newline|'\n'
nl|'\n'
comment|'# After a second call to doWrite, the exact same thing should have'
nl|'\n'
comment|'# happened.  Prior to the bugfix for which this test was written,'
nl|'\n'
comment|'# FileDescriptor would have incorrectly believed its producer was'
nl|'\n'
comment|'# already resumed (it was paused) and so not resume it again.'
nl|'\n'
name|'descriptor'
op|'.'
name|'doWrite'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'producer'
op|'.'
name|'events'
op|','
op|'['
string|"'resume'"
op|','
string|"'pause'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_reentrantStreamingProducerUsingWrite
dedent|''
name|'def'
name|'test_reentrantStreamingProducerUsingWrite'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that FileDescriptor tracks producer\'s paused state correctly.\n        Issue #811, fixed in revision r12857.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_reentrantStreamingProducerTest'
op|'('
string|"'write'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_reentrantStreamingProducerUsingWriteSequence
dedent|''
name|'def'
name|'test_reentrantStreamingProducerUsingWriteSequence'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Like L{test_reentrantStreamingProducerUsingWrite}, but for calls to\n        C{writeSequence}.\n\n        C{writeSequence} is B{not} part of L{IConsumer}, however\n        C{abstract.FileDescriptor} has supported consumery behavior in response\n        to calls to C{writeSequence} forever.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_reentrantStreamingProducerTest'
op|'('
string|"'writeSequence'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|PortStringification
dedent|''
dedent|''
name|'class'
name|'PortStringification'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'interfaces'
op|'.'
name|'IReactorTCP'
op|'('
name|'reactor'
op|','
name|'None'
op|')'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
DECL|member|testTCP
indent|'        '
name|'def'
name|'testTCP'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'p'
op|'='
name|'reactor'
op|'.'
name|'listenTCP'
op|'('
number|'0'
op|','
name|'protocol'
op|'.'
name|'ServerFactory'
op|'('
op|')'
op|')'
newline|'\n'
name|'portNo'
op|'='
name|'p'
op|'.'
name|'getHost'
op|'('
op|')'
op|'.'
name|'port'
newline|'\n'
name|'self'
op|'.'
name|'assertNotEqual'
op|'('
name|'str'
op|'('
name|'p'
op|')'
op|'.'
name|'find'
op|'('
name|'str'
op|'('
name|'portNo'
op|')'
op|')'
op|','
op|'-'
number|'1'
op|','
nl|'\n'
string|'"%d not found in %s"'
op|'%'
op|'('
name|'portNo'
op|','
name|'p'
op|')'
op|')'
newline|'\n'
name|'return'
name|'p'
op|'.'
name|'stopListening'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'interfaces'
op|'.'
name|'IReactorUDP'
op|'('
name|'reactor'
op|','
name|'None'
op|')'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
DECL|member|testUDP
indent|'        '
name|'def'
name|'testUDP'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'p'
op|'='
name|'reactor'
op|'.'
name|'listenUDP'
op|'('
number|'0'
op|','
name|'protocol'
op|'.'
name|'DatagramProtocol'
op|'('
op|')'
op|')'
newline|'\n'
name|'portNo'
op|'='
name|'p'
op|'.'
name|'getHost'
op|'('
op|')'
op|'.'
name|'port'
newline|'\n'
name|'self'
op|'.'
name|'assertNotEqual'
op|'('
name|'str'
op|'('
name|'p'
op|')'
op|'.'
name|'find'
op|'('
name|'str'
op|'('
name|'portNo'
op|')'
op|')'
op|','
op|'-'
number|'1'
op|','
nl|'\n'
string|'"%d not found in %s"'
op|'%'
op|'('
name|'portNo'
op|','
name|'p'
op|')'
op|')'
newline|'\n'
name|'return'
name|'p'
op|'.'
name|'stopListening'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'interfaces'
op|'.'
name|'IReactorSSL'
op|'('
name|'reactor'
op|','
name|'None'
op|')'
name|'is'
name|'not'
name|'None'
name|'and'
name|'ssl'
op|':'
newline|'\n'
DECL|member|testSSL
indent|'        '
name|'def'
name|'testSSL'
op|'('
name|'self'
op|','
name|'ssl'
op|'='
name|'ssl'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pem'
op|'='
name|'util'
op|'.'
name|'sibpath'
op|'('
name|'__file__'
op|','
string|"'server.pem'"
op|')'
newline|'\n'
name|'p'
op|'='
name|'reactor'
op|'.'
name|'listenSSL'
op|'('
number|'0'
op|','
name|'protocol'
op|'.'
name|'ServerFactory'
op|'('
op|')'
op|','
name|'ssl'
op|'.'
name|'DefaultOpenSSLContextFactory'
op|'('
name|'pem'
op|','
name|'pem'
op|')'
op|')'
newline|'\n'
name|'portNo'
op|'='
name|'p'
op|'.'
name|'getHost'
op|'('
op|')'
op|'.'
name|'port'
newline|'\n'
name|'self'
op|'.'
name|'assertNotEqual'
op|'('
name|'str'
op|'('
name|'p'
op|')'
op|'.'
name|'find'
op|'('
name|'str'
op|'('
name|'portNo'
op|')'
op|')'
op|','
op|'-'
number|'1'
op|','
nl|'\n'
string|'"%d not found in %s"'
op|'%'
op|'('
name|'portNo'
op|','
name|'p'
op|')'
op|')'
newline|'\n'
name|'return'
name|'p'
op|'.'
name|'stopListening'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
