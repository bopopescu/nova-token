begin_unit
comment|'# Copyright (c) 2007-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTests for L{twisted.internet.fdesc}.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'os'
op|','
name|'sys'
newline|'\n'
name|'import'
name|'errno'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'import'
name|'fcntl'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
DECL|variable|skip
indent|'    '
name|'skip'
op|'='
string|'"not supported on this platform"'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'    '
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'fdesc'
newline|'\n'
nl|'\n'
dedent|''
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'util'
name|'import'
name|'untilConcludes'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ReadWriteTestCase
name|'class'
name|'ReadWriteTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for fdesc.readFromFD, fdesc.writeToFD.\n    """'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create two non-blocking pipes that can be used in tests.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'r'
op|','
name|'self'
op|'.'
name|'w'
op|'='
name|'os'
op|'.'
name|'pipe'
op|'('
op|')'
newline|'\n'
name|'fdesc'
op|'.'
name|'setNonBlocking'
op|'('
name|'self'
op|'.'
name|'r'
op|')'
newline|'\n'
name|'fdesc'
op|'.'
name|'setNonBlocking'
op|'('
name|'self'
op|'.'
name|'w'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tearDown
dedent|''
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Close pipes.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'os'
op|'.'
name|'close'
op|'('
name|'self'
op|'.'
name|'w'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'os'
op|'.'
name|'close'
op|'('
name|'self'
op|'.'
name|'r'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|write
dedent|''
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'d'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write data to the pipe.\n        """'
newline|'\n'
name|'return'
name|'fdesc'
op|'.'
name|'writeToFD'
op|'('
name|'self'
op|'.'
name|'w'
op|','
name|'d'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|read
dedent|''
name|'def'
name|'read'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Read data from the pipe.\n        """'
newline|'\n'
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'res'
op|'='
name|'fdesc'
op|'.'
name|'readFromFD'
op|'('
name|'self'
op|'.'
name|'r'
op|','
name|'l'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'if'
name|'res'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'l'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'l'
op|'['
number|'0'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'return'
string|'""'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'res'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_writeAndRead
dedent|''
dedent|''
name|'def'
name|'test_writeAndRead'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that the number of bytes L{fdesc.writeToFD} reports as written\n        with its return value are seen by L{fdesc.readFromFD}.\n        """'
newline|'\n'
name|'n'
op|'='
name|'self'
op|'.'
name|'write'
op|'('
string|'"hello"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'n'
op|'>'
number|'0'
op|')'
newline|'\n'
name|'s'
op|'='
name|'self'
op|'.'
name|'read'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'s'
op|')'
op|','
name|'n'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
string|'"hello"'
op|'['
op|':'
name|'n'
op|']'
op|','
name|'s'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_writeAndReadLarge
dedent|''
name|'def'
name|'test_writeAndReadLarge'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Similar to L{test_writeAndRead}, but use a much larger string to verify\n        the behavior for that case.\n        """'
newline|'\n'
name|'orig'
op|'='
string|'"0123456879"'
op|'*'
number|'10000'
newline|'\n'
name|'written'
op|'='
name|'self'
op|'.'
name|'write'
op|'('
name|'orig'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'written'
op|'>'
number|'0'
op|')'
newline|'\n'
name|'result'
op|'='
op|'['
op|']'
newline|'\n'
name|'resultlength'
op|'='
number|'0'
newline|'\n'
name|'i'
op|'='
number|'0'
newline|'\n'
name|'while'
name|'resultlength'
op|'<'
name|'written'
name|'or'
name|'i'
op|'<'
number|'50'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'.'
name|'append'
op|'('
name|'self'
op|'.'
name|'read'
op|'('
op|')'
op|')'
newline|'\n'
name|'resultlength'
op|'+='
name|'len'
op|'('
name|'result'
op|'['
op|'-'
number|'1'
op|']'
op|')'
newline|'\n'
comment|"# Increment a counter to be sure we'll exit at some point"
nl|'\n'
name|'i'
op|'+='
number|'1'
newline|'\n'
dedent|''
name|'result'
op|'='
string|'""'
op|'.'
name|'join'
op|'('
name|'result'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'result'
op|')'
op|','
name|'written'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'orig'
op|'['
op|':'
name|'written'
op|']'
op|','
name|'result'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_readFromEmpty
dedent|''
name|'def'
name|'test_readFromEmpty'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that reading from a file descriptor with no data does not raise\n        an exception and does not result in the callback function being called.\n        """'
newline|'\n'
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'result'
op|'='
name|'fdesc'
op|'.'
name|'readFromFD'
op|'('
name|'self'
op|'.'
name|'r'
op|','
name|'l'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'l'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'result'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_readFromCleanClose
dedent|''
name|'def'
name|'test_readFromCleanClose'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that using L{fdesc.readFromFD} on a cleanly closed file descriptor\n        returns a connection done indicator.\n        """'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'self'
op|'.'
name|'w'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'read'
op|'('
op|')'
op|','
name|'fdesc'
op|'.'
name|'CONNECTION_DONE'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_writeToClosed
dedent|''
name|'def'
name|'test_writeToClosed'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that writing with L{fdesc.writeToFD} when the read end is closed\n        results in a connection lost indicator.\n        """'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'self'
op|'.'
name|'r'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'write'
op|'('
string|'"s"'
op|')'
op|','
name|'fdesc'
op|'.'
name|'CONNECTION_LOST'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_readFromInvalid
dedent|''
name|'def'
name|'test_readFromInvalid'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that reading with L{fdesc.readFromFD} when the read end is\n        closed results in a connection lost indicator.\n        """'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'self'
op|'.'
name|'r'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'read'
op|'('
op|')'
op|','
name|'fdesc'
op|'.'
name|'CONNECTION_LOST'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_writeToInvalid
dedent|''
name|'def'
name|'test_writeToInvalid'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that writing with L{fdesc.writeToFD} when the write end is\n        closed results in a connection lost indicator.\n        """'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'self'
op|'.'
name|'w'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'write'
op|'('
string|'"s"'
op|')'
op|','
name|'fdesc'
op|'.'
name|'CONNECTION_LOST'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_writeErrors
dedent|''
name|'def'
name|'test_writeErrors'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test error path for L{fdesc.writeTod}.\n        """'
newline|'\n'
name|'oldOsWrite'
op|'='
name|'os'
op|'.'
name|'write'
newline|'\n'
DECL|function|eagainWrite
name|'def'
name|'eagainWrite'
op|'('
name|'fd'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'err'
op|'='
name|'OSError'
op|'('
op|')'
newline|'\n'
name|'err'
op|'.'
name|'errno'
op|'='
name|'errno'
op|'.'
name|'EAGAIN'
newline|'\n'
name|'raise'
name|'err'
newline|'\n'
dedent|''
name|'os'
op|'.'
name|'write'
op|'='
name|'eagainWrite'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'write'
op|'('
string|'"s"'
op|')'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'os'
op|'.'
name|'write'
op|'='
name|'oldOsWrite'
newline|'\n'
nl|'\n'
DECL|function|eintrWrite
dedent|''
name|'def'
name|'eintrWrite'
op|'('
name|'fd'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'err'
op|'='
name|'OSError'
op|'('
op|')'
newline|'\n'
name|'err'
op|'.'
name|'errno'
op|'='
name|'errno'
op|'.'
name|'EINTR'
newline|'\n'
name|'raise'
name|'err'
newline|'\n'
dedent|''
name|'os'
op|'.'
name|'write'
op|'='
name|'eintrWrite'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'write'
op|'('
string|'"s"'
op|')'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'os'
op|'.'
name|'write'
op|'='
name|'oldOsWrite'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|CloseOnExecTests
dedent|''
dedent|''
dedent|''
name|'class'
name|'CloseOnExecTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{fdesc._setCloseOnExec} and L{fdesc._unsetCloseOnExec}.\n    """'
newline|'\n'
name|'program'
op|'='
string|"'''\nimport os, errno\ntry:\n    os.write(%d, 'lul')\nexcept OSError, e:\n    if e.errno == errno.EBADF:\n        os._exit(0)\n    os._exit(5)\nexcept:\n    os._exit(10)\nelse:\n    os._exit(20)\n'''"
newline|'\n'
nl|'\n'
DECL|member|_execWithFileDescriptor
name|'def'
name|'_execWithFileDescriptor'
op|'('
name|'self'
op|','
name|'fObj'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pid'
op|'='
name|'os'
op|'.'
name|'fork'
op|'('
op|')'
newline|'\n'
name|'if'
name|'pid'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'execv'
op|'('
name|'sys'
op|'.'
name|'executable'
op|','
op|'['
name|'sys'
op|'.'
name|'executable'
op|','
string|"'-c'"
op|','
name|'self'
op|'.'
name|'program'
op|'%'
op|'('
name|'fObj'
op|'.'
name|'fileno'
op|'('
op|')'
op|','
op|')'
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'                '
name|'import'
name|'traceback'
newline|'\n'
name|'traceback'
op|'.'
name|'print_exc'
op|'('
op|')'
newline|'\n'
name|'os'
op|'.'
name|'_exit'
op|'('
number|'30'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|"# On Linux wait(2) doesn't seem ever able to fail with EINTR but"
nl|'\n'
comment|'# POSIX seems to allow it and on OS X it happens quite a lot.'
nl|'\n'
indent|'            '
name|'return'
name|'untilConcludes'
op|'('
name|'os'
op|'.'
name|'waitpid'
op|','
name|'pid'
op|','
number|'0'
op|')'
op|'['
number|'1'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_setCloseOnExec
dedent|''
dedent|''
name|'def'
name|'test_setCloseOnExec'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A file descriptor passed to L{fdesc._setCloseOnExec} is not inherited\n        by a new process image created with one of the exec family of\n        functions.\n        """'
newline|'\n'
name|'fObj'
op|'='
name|'file'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|','
string|"'w'"
op|')'
newline|'\n'
name|'fdesc'
op|'.'
name|'_setCloseOnExec'
op|'('
name|'fObj'
op|'.'
name|'fileno'
op|'('
op|')'
op|')'
newline|'\n'
name|'status'
op|'='
name|'self'
op|'.'
name|'_execWithFileDescriptor'
op|'('
name|'fObj'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'os'
op|'.'
name|'WIFEXITED'
op|'('
name|'status'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'os'
op|'.'
name|'WEXITSTATUS'
op|'('
name|'status'
op|')'
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_unsetCloseOnExec
dedent|''
name|'def'
name|'test_unsetCloseOnExec'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A file descriptor passed to L{fdesc._unsetCloseOnExec} is inherited by\n        a new process image created with one of the exec family of functions.\n        """'
newline|'\n'
name|'fObj'
op|'='
name|'file'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|','
string|"'w'"
op|')'
newline|'\n'
name|'fdesc'
op|'.'
name|'_setCloseOnExec'
op|'('
name|'fObj'
op|'.'
name|'fileno'
op|'('
op|')'
op|')'
newline|'\n'
name|'fdesc'
op|'.'
name|'_unsetCloseOnExec'
op|'('
name|'fObj'
op|'.'
name|'fileno'
op|'('
op|')'
op|')'
newline|'\n'
name|'status'
op|'='
name|'self'
op|'.'
name|'_execWithFileDescriptor'
op|'('
name|'fObj'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'os'
op|'.'
name|'WIFEXITED'
op|'('
name|'status'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'os'
op|'.'
name|'WEXITSTATUS'
op|'('
name|'status'
op|')'
op|','
number|'20'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
