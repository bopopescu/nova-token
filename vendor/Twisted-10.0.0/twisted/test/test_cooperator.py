begin_unit
comment|'# Copyright (c) 2001-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nThis module contains tests for L{twisted.internet.task.Cooperator} and\nrelated functionality.\n"""'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'reactor'
op|','
name|'defer'
op|','
name|'task'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|FakeDelayedCall
name|'class'
name|'FakeDelayedCall'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Fake delayed call which lets us simulate the scheduler.\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'func'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A function to run, later.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'func'
op|'='
name|'func'
newline|'\n'
name|'self'
op|'.'
name|'cancelled'
op|'='
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|cancel
dedent|''
name|'def'
name|'cancel'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Don\'t run my function later.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'cancelled'
op|'='
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|FakeScheduler
dedent|''
dedent|''
name|'class'
name|'FakeScheduler'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A fake scheduler for testing against.\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a fake scheduler with a list of work to do.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'work'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__call__
dedent|''
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'thunk'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Schedule a unit of work to be done later.\n        """'
newline|'\n'
name|'unit'
op|'='
name|'FakeDelayedCall'
op|'('
name|'thunk'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'work'
op|'.'
name|'append'
op|'('
name|'unit'
op|')'
newline|'\n'
name|'return'
name|'unit'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|pump
dedent|''
name|'def'
name|'pump'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Do all of the work that is currently available to be done.\n        """'
newline|'\n'
name|'work'
op|','
name|'self'
op|'.'
name|'work'
op|'='
name|'self'
op|'.'
name|'work'
op|','
op|'['
op|']'
newline|'\n'
name|'for'
name|'unit'
name|'in'
name|'work'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'unit'
op|'.'
name|'cancelled'
op|':'
newline|'\n'
indent|'                '
name|'unit'
op|'.'
name|'func'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TestCooperator
dedent|''
dedent|''
dedent|''
dedent|''
name|'class'
name|'TestCooperator'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|variable|RESULT
indent|'    '
name|'RESULT'
op|'='
string|"'done'"
newline|'\n'
nl|'\n'
DECL|member|ebIter
name|'def'
name|'ebIter'
op|'('
name|'self'
op|','
name|'err'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'err'
op|'.'
name|'trap'
op|'('
name|'task'
op|'.'
name|'SchedulerStopped'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'RESULT'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|cbIter
dedent|''
name|'def'
name|'cbIter'
op|'('
name|'self'
op|','
name|'ign'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'fail'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testStoppedRejectsNewTasks
dedent|''
name|'def'
name|'testStoppedRejectsNewTasks'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that Cooperators refuse new tasks when they have been stopped.\n        """'
newline|'\n'
DECL|function|testwith
name|'def'
name|'testwith'
op|'('
name|'stuff'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'c'
op|'='
name|'task'
op|'.'
name|'Cooperator'
op|'('
op|')'
newline|'\n'
name|'c'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
name|'d'
op|'='
name|'c'
op|'.'
name|'coiterate'
op|'('
name|'iter'
op|'('
op|'('
op|')'
op|')'
op|','
name|'stuff'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'cbIter'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addErrback'
op|'('
name|'self'
op|'.'
name|'ebIter'
op|')'
newline|'\n'
name|'return'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'lambda'
name|'result'
op|':'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'result'
op|','
name|'self'
op|'.'
name|'RESULT'
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'testwith'
op|'('
name|'None'
op|')'
op|'.'
name|'addCallback'
op|'('
name|'lambda'
name|'ign'
op|':'
name|'testwith'
op|'('
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testStopRunning
dedent|''
name|'def'
name|'testStopRunning'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that a running iterator will not run to completion when the\n        cooperator is stopped.\n        """'
newline|'\n'
name|'c'
op|'='
name|'task'
op|'.'
name|'Cooperator'
op|'('
op|')'
newline|'\n'
DECL|function|myiter
name|'def'
name|'myiter'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'myiter'
op|'.'
name|'value'
name|'in'
name|'range'
op|'('
number|'3'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'yield'
name|'myiter'
op|'.'
name|'value'
newline|'\n'
dedent|''
dedent|''
name|'myiter'
op|'.'
name|'value'
op|'='
op|'-'
number|'1'
newline|'\n'
name|'d'
op|'='
name|'c'
op|'.'
name|'coiterate'
op|'('
name|'myiter'
op|'('
op|')'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'cbIter'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addErrback'
op|'('
name|'self'
op|'.'
name|'ebIter'
op|')'
newline|'\n'
name|'c'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
DECL|function|doasserts
name|'def'
name|'doasserts'
op|'('
name|'result'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'result'
op|','
name|'self'
op|'.'
name|'RESULT'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'myiter'
op|'.'
name|'value'
op|','
op|'-'
number|'1'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'doasserts'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testStopOutstanding
dedent|''
name|'def'
name|'testStopOutstanding'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        An iterator run with L{Cooperator.coiterate} paused on a L{Deferred}\n        yielded by that iterator will fire its own L{Deferred} (the one\n        returned by C{coiterate}) when L{Cooperator.stop} is called.\n        """'
newline|'\n'
name|'testControlD'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'outstandingD'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
DECL|function|myiter
name|'def'
name|'myiter'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'testControlD'
op|'.'
name|'callback'
op|','
name|'None'
op|')'
newline|'\n'
name|'yield'
name|'outstandingD'
newline|'\n'
name|'self'
op|'.'
name|'fail'
op|'('
op|')'
newline|'\n'
dedent|''
name|'c'
op|'='
name|'task'
op|'.'
name|'Cooperator'
op|'('
op|')'
newline|'\n'
name|'d'
op|'='
name|'c'
op|'.'
name|'coiterate'
op|'('
name|'myiter'
op|'('
op|')'
op|')'
newline|'\n'
DECL|function|stopAndGo
name|'def'
name|'stopAndGo'
op|'('
name|'ign'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'c'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
name|'outstandingD'
op|'.'
name|'callback'
op|'('
string|"'arglebargle'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'testControlD'
op|'.'
name|'addCallback'
op|'('
name|'stopAndGo'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'cbIter'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addErrback'
op|'('
name|'self'
op|'.'
name|'ebIter'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'d'
op|'.'
name|'addCallback'
op|'('
nl|'\n'
name|'lambda'
name|'result'
op|':'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'result'
op|','
name|'self'
op|'.'
name|'RESULT'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testUnexpectedError
dedent|''
name|'def'
name|'testUnexpectedError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'c'
op|'='
name|'task'
op|'.'
name|'Cooperator'
op|'('
op|')'
newline|'\n'
DECL|function|myiter
name|'def'
name|'myiter'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'yield'
name|'None'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'RuntimeError'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'d'
op|'='
name|'c'
op|'.'
name|'coiterate'
op|'('
name|'myiter'
op|'('
op|')'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'RuntimeError'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testUnexpectedErrorActuallyLater
dedent|''
name|'def'
name|'testUnexpectedErrorActuallyLater'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
DECL|function|myiter
indent|'        '
name|'def'
name|'myiter'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'D'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'D'
op|'.'
name|'errback'
op|','
name|'RuntimeError'
op|'('
op|')'
op|')'
newline|'\n'
name|'yield'
name|'D'
newline|'\n'
nl|'\n'
dedent|''
name|'c'
op|'='
name|'task'
op|'.'
name|'Cooperator'
op|'('
op|')'
newline|'\n'
name|'d'
op|'='
name|'c'
op|'.'
name|'coiterate'
op|'('
name|'myiter'
op|'('
op|')'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'RuntimeError'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testUnexpectedErrorNotActuallyLater
dedent|''
name|'def'
name|'testUnexpectedErrorNotActuallyLater'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
DECL|function|myiter
indent|'        '
name|'def'
name|'myiter'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'yield'
name|'defer'
op|'.'
name|'fail'
op|'('
name|'RuntimeError'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'c'
op|'='
name|'task'
op|'.'
name|'Cooperator'
op|'('
op|')'
newline|'\n'
name|'d'
op|'='
name|'c'
op|'.'
name|'coiterate'
op|'('
name|'myiter'
op|'('
op|')'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'RuntimeError'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testCooperation
dedent|''
name|'def'
name|'testCooperation'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'L'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|myiter
name|'def'
name|'myiter'
op|'('
name|'things'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'th'
name|'in'
name|'things'
op|':'
newline|'\n'
indent|'                '
name|'L'
op|'.'
name|'append'
op|'('
name|'th'
op|')'
newline|'\n'
name|'yield'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'groupsOfThings'
op|'='
op|'['
string|"'abc'"
op|','
op|'('
number|'1'
op|','
number|'2'
op|','
number|'3'
op|')'
op|','
string|"'def'"
op|','
op|'('
number|'4'
op|','
number|'5'
op|','
number|'6'
op|')'
op|']'
newline|'\n'
nl|'\n'
name|'c'
op|'='
name|'task'
op|'.'
name|'Cooperator'
op|'('
op|')'
newline|'\n'
name|'tasks'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'stuff'
name|'in'
name|'groupsOfThings'
op|':'
newline|'\n'
indent|'            '
name|'tasks'
op|'.'
name|'append'
op|'('
name|'c'
op|'.'
name|'coiterate'
op|'('
name|'myiter'
op|'('
name|'stuff'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'defer'
op|'.'
name|'DeferredList'
op|'('
name|'tasks'
op|')'
op|'.'
name|'addCallback'
op|'('
nl|'\n'
name|'lambda'
name|'ign'
op|':'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'tuple'
op|'('
name|'L'
op|')'
op|','
name|'sum'
op|'('
name|'zip'
op|'('
op|'*'
name|'groupsOfThings'
op|')'
op|','
op|'('
op|')'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testResourceExhaustion
dedent|''
name|'def'
name|'testResourceExhaustion'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'output'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|myiter
name|'def'
name|'myiter'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
number|'100'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'output'
op|'.'
name|'append'
op|'('
name|'i'
op|')'
newline|'\n'
name|'if'
name|'i'
op|'=='
number|'9'
op|':'
newline|'\n'
indent|'                    '
name|'_TPF'
op|'.'
name|'stopped'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'yield'
name|'i'
newline|'\n'
nl|'\n'
DECL|class|_TPF
dedent|''
dedent|''
name|'class'
name|'_TPF'
op|':'
newline|'\n'
DECL|variable|stopped
indent|'            '
name|'stopped'
op|'='
name|'False'
newline|'\n'
DECL|member|__call__
name|'def'
name|'__call__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'self'
op|'.'
name|'stopped'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'c'
op|'='
name|'task'
op|'.'
name|'Cooperator'
op|'('
name|'terminationPredicateFactory'
op|'='
name|'_TPF'
op|')'
newline|'\n'
name|'c'
op|'.'
name|'coiterate'
op|'('
name|'myiter'
op|'('
op|')'
op|')'
op|'.'
name|'addErrback'
op|'('
name|'self'
op|'.'
name|'ebIter'
op|')'
newline|'\n'
name|'c'
op|'.'
name|'_delayedCall'
op|'.'
name|'cancel'
op|'('
op|')'
newline|'\n'
comment|'# testing a private method because only the test case will ever care'
nl|'\n'
comment|'# about this, so we have to carefully clean up after ourselves.'
nl|'\n'
name|'c'
op|'.'
name|'_tick'
op|'('
op|')'
newline|'\n'
name|'c'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'_TPF'
op|'.'
name|'stopped'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'output'
op|','
name|'range'
op|'('
number|'10'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testCallbackReCoiterate
dedent|''
name|'def'
name|'testCallbackReCoiterate'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a callback to a deferred returned by coiterate calls coiterate on\n        the same Cooperator, we should make sure to only do the minimal amount\n        of scheduling work.  (This test was added to demonstrate a specific bug\n        that was found while writing the scheduler.)\n        """'
newline|'\n'
name|'calls'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|class|FakeCall
name|'class'
name|'FakeCall'
op|':'
newline|'\n'
DECL|member|__init__
indent|'            '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'func'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'func'
op|'='
name|'func'
newline|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
string|"'<FakeCall %r>'"
op|'%'
op|'('
name|'self'
op|'.'
name|'func'
op|','
op|')'
newline|'\n'
nl|'\n'
DECL|function|sched
dedent|''
dedent|''
name|'def'
name|'sched'
op|'('
name|'f'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'failIf'
op|'('
name|'calls'
op|','
name|'repr'
op|'('
name|'calls'
op|')'
op|')'
newline|'\n'
name|'calls'
op|'.'
name|'append'
op|'('
name|'FakeCall'
op|'('
name|'f'
op|')'
op|')'
newline|'\n'
name|'return'
name|'calls'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'c'
op|'='
name|'task'
op|'.'
name|'Cooperator'
op|'('
name|'scheduler'
op|'='
name|'sched'
op|','
name|'terminationPredicateFactory'
op|'='
name|'lambda'
op|':'
name|'lambda'
op|':'
name|'True'
op|')'
newline|'\n'
name|'d'
op|'='
name|'c'
op|'.'
name|'coiterate'
op|'('
name|'iter'
op|'('
op|'('
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'done'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|anotherTask
name|'def'
name|'anotherTask'
op|'('
name|'ign'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'c'
op|'.'
name|'coiterate'
op|'('
name|'iter'
op|'('
op|'('
op|')'
op|')'
op|')'
op|'.'
name|'addBoth'
op|'('
name|'done'
op|'.'
name|'append'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'anotherTask'
op|')'
newline|'\n'
nl|'\n'
name|'work'
op|'='
number|'0'
newline|'\n'
name|'while'
name|'not'
name|'done'
op|':'
newline|'\n'
indent|'            '
name|'work'
op|'+='
number|'1'
newline|'\n'
name|'while'
name|'calls'
op|':'
newline|'\n'
indent|'                '
name|'calls'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
op|'.'
name|'func'
op|'('
op|')'
newline|'\n'
name|'work'
op|'+='
number|'1'
newline|'\n'
dedent|''
name|'if'
name|'work'
op|'>'
number|'50'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'fail'
op|'('
string|'"Cooperator took too long"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|UnhandledException
dedent|''
dedent|''
dedent|''
dedent|''
name|'class'
name|'UnhandledException'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    An exception that should go unhandled.\n    """'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|AliasTests
dedent|''
name|'class'
name|'AliasTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Integration test to verify that the global singleton aliases do what\n    they\'re supposed to.\n    """'
newline|'\n'
nl|'\n'
DECL|member|test_cooperate
name|'def'
name|'test_cooperate'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{twisted.internet.task.cooperate} ought to run the generator that it is\n        """'
newline|'\n'
name|'d'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
DECL|function|doit
name|'def'
name|'doit'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'yield'
number|'1'
newline|'\n'
name|'yield'
number|'2'
newline|'\n'
name|'yield'
number|'3'
newline|'\n'
name|'d'
op|'.'
name|'callback'
op|'('
string|'"yay"'
op|')'
newline|'\n'
dedent|''
name|'it'
op|'='
name|'doit'
op|'('
op|')'
newline|'\n'
name|'theTask'
op|'='
name|'task'
op|'.'
name|'cooperate'
op|'('
name|'it'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIn'
op|'('
name|'theTask'
op|','
name|'task'
op|'.'
name|'_theCooperator'
op|'.'
name|'_tasks'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|RunStateTests
dedent|''
dedent|''
name|'class'
name|'RunStateTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests to verify the behavior of L{CooperativeTask.pause},\n    L{CooperativeTask.resume}, L{CooperativeTask.stop}, exhausting the\n    underlying iterator, and their interactions with each other.\n    """'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a cooperator with a fake scheduler and a termination predicate\n        that ensures only one unit of work will take place per tick.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_doDeferNext'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_doStopNext'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_doDieNext'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'work'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'='
name|'FakeScheduler'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'cooperator'
op|'='
name|'task'
op|'.'
name|'Cooperator'
op|'('
nl|'\n'
name|'scheduler'
op|'='
name|'self'
op|'.'
name|'scheduler'
op|','
nl|'\n'
comment|'# Always stop after one iteration of work (return a function which'
nl|'\n'
comment|'# returns a function which always returns True)'
nl|'\n'
name|'terminationPredicateFactory'
op|'='
name|'lambda'
op|':'
name|'lambda'
op|':'
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'task'
op|'='
name|'self'
op|'.'
name|'cooperator'
op|'.'
name|'cooperate'
op|'('
name|'self'
op|'.'
name|'worker'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'cooperator'
op|'.'
name|'start'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|worker
dedent|''
name|'def'
name|'worker'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        This is a sample generator which yields Deferreds when we are testing\n        deferral and an ascending integer count otherwise.\n        """'
newline|'\n'
name|'i'
op|'='
number|'0'
newline|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'i'
op|'+='
number|'1'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_doDeferNext'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_doDeferNext'
op|'='
name|'False'
newline|'\n'
name|'d'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'work'
op|'.'
name|'append'
op|'('
name|'d'
op|')'
newline|'\n'
name|'yield'
name|'d'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_doStopNext'
op|':'
newline|'\n'
indent|'                '
name|'return'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_doDieNext'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'UnhandledException'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'work'
op|'.'
name|'append'
op|'('
name|'i'
op|')'
newline|'\n'
name|'yield'
name|'i'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tearDown
dedent|''
dedent|''
dedent|''
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Drop references to interesting parts of the fixture to allow Deferred\n        errors to be noticed when things start failing.\n        """'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'task'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'scheduler'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|deferNext
dedent|''
name|'def'
name|'deferNext'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Defer the next result from my worker iterator.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_doDeferNext'
op|'='
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|stopNext
dedent|''
name|'def'
name|'stopNext'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Make the next result from my worker iterator be completion (raising\n        StopIteration).\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_doStopNext'
op|'='
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|dieNext
dedent|''
name|'def'
name|'dieNext'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Make the next result from my worker iterator be raising an\n        L{UnhandledException}.\n        """'
newline|'\n'
DECL|function|ignoreUnhandled
name|'def'
name|'ignoreUnhandled'
op|'('
name|'failure'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'failure'
op|'.'
name|'trap'
op|'('
name|'UnhandledException'
op|')'
newline|'\n'
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_doDieNext'
op|'='
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_pauseResume
dedent|''
name|'def'
name|'test_pauseResume'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Cooperators should stop running their tasks when they\'re paused, and\n        start again when they\'re resumed.\n        """'
newline|'\n'
comment|'# first, sanity check'
nl|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'work'
op|','
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'work'
op|','
op|'['
number|'1'
op|','
number|'2'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# OK, now for real'
nl|'\n'
name|'self'
op|'.'
name|'task'
op|'.'
name|'pause'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'work'
op|','
op|'['
number|'1'
op|','
number|'2'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'task'
op|'.'
name|'resume'
op|'('
op|')'
newline|'\n'
comment|'# Resuming itself shoult not do any work'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'work'
op|','
op|'['
number|'1'
op|','
number|'2'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
comment|'# But when the scheduler rolls around again...'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'work'
op|','
op|'['
number|'1'
op|','
number|'2'
op|','
number|'3'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_resumeNotPaused
dedent|''
name|'def'
name|'test_resumeNotPaused'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{CooperativeTask.resume} should raise a L{TaskNotPaused} exception if\n        it was not paused; e.g. if L{CooperativeTask.pause} was not invoked\n        more times than L{CooperativeTask.resume} on that object.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'task'
op|'.'
name|'NotPaused'
op|','
name|'self'
op|'.'
name|'task'
op|'.'
name|'resume'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'task'
op|'.'
name|'pause'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'task'
op|'.'
name|'resume'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'task'
op|'.'
name|'NotPaused'
op|','
name|'self'
op|'.'
name|'task'
op|'.'
name|'resume'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_pauseTwice
dedent|''
name|'def'
name|'test_pauseTwice'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Pauses on tasks should behave like a stack. If a task is paused twice,\n        it needs to be resumed twice.\n        """'
newline|'\n'
comment|'# pause once'
nl|'\n'
name|'self'
op|'.'
name|'task'
op|'.'
name|'pause'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'work'
op|','
op|'['
op|']'
op|')'
newline|'\n'
comment|'# pause twice'
nl|'\n'
name|'self'
op|'.'
name|'task'
op|'.'
name|'pause'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'work'
op|','
op|'['
op|']'
op|')'
newline|'\n'
comment|"# resume once (it shouldn't)"
nl|'\n'
name|'self'
op|'.'
name|'task'
op|'.'
name|'resume'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'work'
op|','
op|'['
op|']'
op|')'
newline|'\n'
comment|'# resume twice (now it should go)'
nl|'\n'
name|'self'
op|'.'
name|'task'
op|'.'
name|'resume'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'work'
op|','
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_pauseWhileDeferred
dedent|''
name|'def'
name|'test_pauseWhileDeferred'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{pause()}ing a task while it is waiting on an outstanding\n        L{defer.Deferred} should put the task into a state where the\n        outstanding L{defer.Deferred} must be called back I{and} the task is\n        C{resume}d before it will continue processing.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'deferNext'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'work'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'isinstance'
op|'('
name|'self'
op|'.'
name|'work'
op|'['
number|'0'
op|']'
op|','
name|'defer'
op|'.'
name|'Deferred'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'work'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'task'
op|'.'
name|'pause'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'work'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'task'
op|'.'
name|'resume'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'work'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'work'
op|'['
number|'0'
op|']'
op|'.'
name|'callback'
op|'('
string|'"STUFF!"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'work'
op|')'
op|','
number|'2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'work'
op|'['
number|'1'
op|']'
op|','
number|'2'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_whenDone
dedent|''
name|'def'
name|'test_whenDone'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{CooperativeTask.whenDone} returns a Deferred which fires when the\n        Cooperator\'s iterator is exhausted.  It returns a new Deferred each\n        time it is called; callbacks added to other invocations will not modify\n        the value that subsequent invocations will fire with.\n        """'
newline|'\n'
nl|'\n'
name|'deferred1'
op|'='
name|'self'
op|'.'
name|'task'
op|'.'
name|'whenDone'
op|'('
op|')'
newline|'\n'
name|'deferred2'
op|'='
name|'self'
op|'.'
name|'task'
op|'.'
name|'whenDone'
op|'('
op|')'
newline|'\n'
name|'results1'
op|'='
op|'['
op|']'
newline|'\n'
name|'results2'
op|'='
op|'['
op|']'
newline|'\n'
name|'final1'
op|'='
op|'['
op|']'
newline|'\n'
name|'final2'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|function|callbackOne
name|'def'
name|'callbackOne'
op|'('
name|'result'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'results1'
op|'.'
name|'append'
op|'('
name|'result'
op|')'
newline|'\n'
name|'return'
number|'1'
newline|'\n'
nl|'\n'
DECL|function|callbackTwo
dedent|''
name|'def'
name|'callbackTwo'
op|'('
name|'result'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'results2'
op|'.'
name|'append'
op|'('
name|'result'
op|')'
newline|'\n'
name|'return'
number|'2'
newline|'\n'
nl|'\n'
dedent|''
name|'deferred1'
op|'.'
name|'addCallback'
op|'('
name|'callbackOne'
op|')'
newline|'\n'
name|'deferred2'
op|'.'
name|'addCallback'
op|'('
name|'callbackTwo'
op|')'
newline|'\n'
nl|'\n'
name|'deferred1'
op|'.'
name|'addCallback'
op|'('
name|'final1'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'deferred2'
op|'.'
name|'addCallback'
op|'('
name|'final2'
op|'.'
name|'append'
op|')'
newline|'\n'
nl|'\n'
comment|'# exhaust the task iterator'
nl|'\n'
comment|'# callbacks fire'
nl|'\n'
name|'self'
op|'.'
name|'stopNext'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'results1'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'results2'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'results1'
op|'['
number|'0'
op|']'
op|','
name|'self'
op|'.'
name|'task'
op|'.'
name|'_iterator'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIdentical'
op|'('
name|'results2'
op|'['
number|'0'
op|']'
op|','
name|'self'
op|'.'
name|'task'
op|'.'
name|'_iterator'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'final1'
op|','
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'final2'
op|','
op|'['
number|'2'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_whenDoneError
dedent|''
name|'def'
name|'test_whenDoneError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{CooperativeTask.whenDone} returns a L{defer.Deferred} that will fail\n        when the iterable\'s C{next} method raises an exception, with that\n        exception.\n        """'
newline|'\n'
name|'deferred1'
op|'='
name|'self'
op|'.'
name|'task'
op|'.'
name|'whenDone'
op|'('
op|')'
newline|'\n'
name|'results'
op|'='
op|'['
op|']'
newline|'\n'
name|'deferred1'
op|'.'
name|'addErrback'
op|'('
name|'results'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'dieNext'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'results'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'results'
op|'['
number|'0'
op|']'
op|'.'
name|'check'
op|'('
name|'UnhandledException'
op|')'
op|','
name|'UnhandledException'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_whenDoneStop
dedent|''
name|'def'
name|'test_whenDoneStop'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{CooperativeTask.whenDone} returns a L{defer.Deferred} that fails with\n        L{TaskStopped} when the C{stop} method is called on that\n        L{CooperativeTask}.\n        """'
newline|'\n'
name|'deferred1'
op|'='
name|'self'
op|'.'
name|'task'
op|'.'
name|'whenDone'
op|'('
op|')'
newline|'\n'
name|'errors'
op|'='
op|'['
op|']'
newline|'\n'
name|'deferred1'
op|'.'
name|'addErrback'
op|'('
name|'errors'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'task'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'errors'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'errors'
op|'['
number|'0'
op|']'
op|'.'
name|'check'
op|'('
name|'task'
op|'.'
name|'TaskStopped'
op|')'
op|','
name|'task'
op|'.'
name|'TaskStopped'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_whenDoneAlreadyDone
dedent|''
name|'def'
name|'test_whenDoneAlreadyDone'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{CooperativeTask.whenDone} will return a L{defer.Deferred} that will\n        succeed immediately if its iterator has already completed.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'stopNext'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'results'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'task'
op|'.'
name|'whenDone'
op|'('
op|')'
op|'.'
name|'addCallback'
op|'('
name|'results'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'results'
op|','
op|'['
name|'self'
op|'.'
name|'task'
op|'.'
name|'_iterator'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_stopStops
dedent|''
name|'def'
name|'test_stopStops'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{stop()}ping a task should cause it to be removed from the run just as\n        C{pause()}ing, with the distinction that C{resume()} will raise a\n        L{TaskStopped} exception.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'task'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'work'
op|')'
op|','
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'task'
op|'.'
name|'TaskStopped'
op|','
name|'self'
op|'.'
name|'task'
op|'.'
name|'stop'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'task'
op|'.'
name|'TaskStopped'
op|','
name|'self'
op|'.'
name|'task'
op|'.'
name|'pause'
op|')'
newline|'\n'
comment|"# Sanity check - it's still not scheduled, is it?"
nl|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'work'
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_pauseStopResume
dedent|''
name|'def'
name|'test_pauseStopResume'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{resume()}ing a paused, stopped task should be a no-op; it should not\n        raise an exception, because it\'s paused, but neither should it actually\n        do more work from the task.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'task'
op|'.'
name|'pause'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'task'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'task'
op|'.'
name|'resume'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'work'
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_stopDeferred
dedent|''
name|'def'
name|'test_stopDeferred'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        As a corrolary of the interaction of C{pause()} and C{unpause()},\n        C{stop()}ping a task which is waiting on a L{Deferred} should cause the\n        task to gracefully shut down, meaning that it should not be unpaused\n        when the deferred fires.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'deferNext'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'work'
op|'.'
name|'pop'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'task'
op|'.'
name|'_pauseCount'
op|','
number|'1'
op|')'
newline|'\n'
name|'results'
op|'='
op|'['
op|']'
newline|'\n'
name|'d'
op|'.'
name|'addBoth'
op|'('
name|'results'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'task'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'d'
op|'.'
name|'callback'
op|'('
number|'7'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
comment|"# Let's make sure that Deferred doesn't come out fried with an"
nl|'\n'
comment|'# unhandled error that will be logged.  The value is None, rather than'
nl|'\n'
comment|'# our test value, 7, because this Deferred is returned to and consumed'
nl|'\n'
comment|'# by the cooperator code.  Its callback therefore has no contract.'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'results'
op|','
op|'['
name|'None'
op|']'
op|')'
newline|'\n'
comment|'# But more importantly, no further work should have happened.'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'work'
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_stopExhausted
dedent|''
name|'def'
name|'test_stopExhausted'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{stop()}ping a L{CooperativeTask} whose iterator has been exhausted\n        should raise L{TaskDone}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'stopNext'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'task'
op|'.'
name|'TaskDone'
op|','
name|'self'
op|'.'
name|'task'
op|'.'
name|'stop'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_stopErrored
dedent|''
name|'def'
name|'test_stopErrored'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{stop()}ping a L{CooperativeTask} whose iterator has encountered an\n        error should raise L{TaskFailed}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'dieNext'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'task'
op|'.'
name|'TaskFailed'
op|','
name|'self'
op|'.'
name|'task'
op|'.'
name|'stop'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_stopCooperatorReentrancy
dedent|''
name|'def'
name|'test_stopCooperatorReentrancy'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a callback of a L{Deferred} from L{CooperativeTask.whenDone} calls\n        C{Cooperator.stop} on its L{CooperativeTask._cooperator}, the\n        L{Cooperator} will stop, but the L{CooperativeTask} whose callback is\n        calling C{stop} should already be considered \'stopped\' by the time the\n        callback is running, and therefore removed from the\n        L{CoooperativeTask}.\n        """'
newline|'\n'
name|'callbackPhases'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|stopit
name|'def'
name|'stopit'
op|'('
name|'result'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'callbackPhases'
op|'.'
name|'append'
op|'('
name|'result'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'cooperator'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
comment|'# "done" here is a sanity check to make sure that we get all the'
nl|'\n'
comment|"# way through the callback; i.e. stop() shouldn't be raising an"
nl|'\n'
comment|'# exception due to the stopped-ness of our main task.'
nl|'\n'
name|'callbackPhases'
op|'.'
name|'append'
op|'('
string|'"done"'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'task'
op|'.'
name|'whenDone'
op|'('
op|')'
op|'.'
name|'addCallback'
op|'('
name|'stopit'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'stopNext'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'scheduler'
op|'.'
name|'pump'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'callbackPhases'
op|','
op|'['
name|'self'
op|'.'
name|'task'
op|'.'
name|'_iterator'
op|','
string|'"done"'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
