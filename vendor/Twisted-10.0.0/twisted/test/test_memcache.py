begin_unit
comment|'# Copyright (c) 2007-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTest the memcache client protocol.\n"""'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'error'
name|'import'
name|'ConnectionDone'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'protocols'
op|'.'
name|'memcache'
name|'import'
name|'MemCacheProtocol'
op|','
name|'NoSuchCommand'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'protocols'
op|'.'
name|'memcache'
name|'import'
name|'ClientError'
op|','
name|'ServerError'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
op|'.'
name|'unittest'
name|'import'
name|'TestCase'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'test'
op|'.'
name|'proto_helpers'
name|'import'
name|'StringTransportWithDisconnection'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'task'
name|'import'
name|'Clock'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'defer'
name|'import'
name|'Deferred'
op|','
name|'gatherResults'
op|','
name|'TimeoutError'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'defer'
name|'import'
name|'DeferredList'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|CommandMixin
name|'class'
name|'CommandMixin'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Setup and tests for basic invocation of L{MemCacheProtocol} commands.\n    """'
newline|'\n'
nl|'\n'
DECL|member|_test
name|'def'
name|'_test'
op|'('
name|'self'
op|','
name|'d'
op|','
name|'send'
op|','
name|'recv'
op|','
name|'result'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Helper test method to test the resulting C{Deferred} of a\n        L{MemCacheProtocol} command.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_get
dedent|''
name|'def'
name|'test_get'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{MemCacheProtocol.get} returns a L{Deferred} which is called back with\n        the value and the flag associated with the given key if the server\n        returns a successful result.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"foo"'
op|')'
op|','
string|'"get foo\\r\\n"'
op|','
nl|'\n'
string|'"VALUE foo 0 3\\r\\nbar\\r\\nEND\\r\\n"'
op|','
op|'('
number|'0'
op|','
string|'"bar"'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_emptyGet
dedent|''
name|'def'
name|'test_emptyGet'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test getting a non-available key: it succeeds but return C{None} as\n        value and C{0} as flag.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"foo"'
op|')'
op|','
string|'"get foo\\r\\n"'
op|','
nl|'\n'
string|'"END\\r\\n"'
op|','
op|'('
number|'0'
op|','
name|'None'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getMultiple
dedent|''
name|'def'
name|'test_getMultiple'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{MemCacheProtocol.getMultiple} returns a L{Deferred} which is called\n        back with a dictionary of flag, value for each given key.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'getMultiple'
op|'('
op|'['
string|"'foo'"
op|','
string|"'cow'"
op|']'
op|')'
op|','
nl|'\n'
string|'"get foo cow\\r\\n"'
op|','
nl|'\n'
string|'"VALUE foo 0 3\\r\\nbar\\r\\nVALUE cow 0 7\\r\\nchicken\\r\\nEND\\r\\n"'
op|','
nl|'\n'
op|'{'
string|"'cow'"
op|':'
op|'('
number|'0'
op|','
string|"'chicken'"
op|')'
op|','
string|"'foo'"
op|':'
op|'('
number|'0'
op|','
string|"'bar'"
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getMultipleWithEmpty
dedent|''
name|'def'
name|'test_getMultipleWithEmpty'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When L{MemCacheProtocol.getMultiple} is called with non-available keys,\n        the corresponding tuples are (0, None).\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'getMultiple'
op|'('
op|'['
string|"'foo'"
op|','
string|"'cow'"
op|']'
op|')'
op|','
nl|'\n'
string|'"get foo cow\\r\\n"'
op|','
nl|'\n'
string|'"VALUE cow 1 3\\r\\nbar\\r\\nEND\\r\\n"'
op|','
nl|'\n'
op|'{'
string|"'cow'"
op|':'
op|'('
number|'1'
op|','
string|"'bar'"
op|')'
op|','
string|"'foo'"
op|':'
op|'('
number|'0'
op|','
name|'None'
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_set
dedent|''
name|'def'
name|'test_set'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{MemCacheProtocol.set} returns a L{Deferred} which is called back with\n        C{True} when the operation succeeds.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'set'
op|'('
string|'"foo"'
op|','
string|'"bar"'
op|')'
op|','
nl|'\n'
string|'"set foo 0 0 3\\r\\nbar\\r\\n"'
op|','
string|'"STORED\\r\\n"'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_add
dedent|''
name|'def'
name|'test_add'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{MemCacheProtocol.add} returns a L{Deferred} which is called back with\n        C{True} when the operation succeeds.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'add'
op|'('
string|'"foo"'
op|','
string|'"bar"'
op|')'
op|','
nl|'\n'
string|'"add foo 0 0 3\\r\\nbar\\r\\n"'
op|','
string|'"STORED\\r\\n"'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_replace
dedent|''
name|'def'
name|'test_replace'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{MemCacheProtocol.replace} returns a L{Deferred} which is called back\n        with C{True} when the operation succeeds.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'replace'
op|'('
string|'"foo"'
op|','
string|'"bar"'
op|')'
op|','
nl|'\n'
string|'"replace foo 0 0 3\\r\\nbar\\r\\n"'
op|','
string|'"STORED\\r\\n"'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_errorAdd
dedent|''
name|'def'
name|'test_errorAdd'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test an erroneous add: if a L{MemCacheProtocol.add} is called but the\n        key already exists on the server, it returns a B{NOT STORED} answer,\n        which calls back the resulting L{Deferred} with C{False}.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'add'
op|'('
string|'"foo"'
op|','
string|'"bar"'
op|')'
op|','
nl|'\n'
string|'"add foo 0 0 3\\r\\nbar\\r\\n"'
op|','
string|'"NOT STORED\\r\\n"'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_errorReplace
dedent|''
name|'def'
name|'test_errorReplace'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test an erroneous replace: if a L{MemCacheProtocol.replace} is called\n        but the key doesn\'t exist on the server, it returns a B{NOT STORED}\n        answer, which calls back the resulting L{Deferred} with C{False}.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'replace'
op|'('
string|'"foo"'
op|','
string|'"bar"'
op|')'
op|','
nl|'\n'
string|'"replace foo 0 0 3\\r\\nbar\\r\\n"'
op|','
string|'"NOT STORED\\r\\n"'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_delete
dedent|''
name|'def'
name|'test_delete'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{MemCacheProtocol.delete} returns a L{Deferred} which is called back\n        with C{True} when the server notifies a success.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'delete'
op|'('
string|'"bar"'
op|')'
op|','
string|'"delete bar\\r\\n"'
op|','
nl|'\n'
string|'"DELETED\\r\\n"'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_errorDelete
dedent|''
name|'def'
name|'test_errorDelete'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test a error during a delete: if key doesn\'t exist on the server, it\n        returns a B{NOT FOUND} answer which calls back the resulting L{Deferred}\n        with C{False}.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'delete'
op|'('
string|'"bar"'
op|')'
op|','
string|'"delete bar\\r\\n"'
op|','
nl|'\n'
string|'"NOT FOUND\\r\\n"'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_increment
dedent|''
name|'def'
name|'test_increment'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test incrementing a variable: L{MemCacheProtocol.increment} returns a\n        L{Deferred} which is called back with the incremented value of the\n        given key.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'increment'
op|'('
string|'"foo"'
op|')'
op|','
string|'"incr foo 1\\r\\n"'
op|','
nl|'\n'
string|'"4\\r\\n"'
op|','
number|'4'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_decrement
dedent|''
name|'def'
name|'test_decrement'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test decrementing a variable: L{MemCacheProtocol.decrement} returns a\n        L{Deferred} which is called back with the decremented value of the\n        given key.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'decrement'
op|'('
string|'"foo"'
op|')'
op|','
string|'"decr foo 1\\r\\n"'
op|','
string|'"5\\r\\n"'
op|','
number|'5'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_incrementVal
dedent|''
name|'def'
name|'test_incrementVal'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{MemCacheProtocol.increment} takes an optional argument C{value} which\n        replaces the default value of 1 when specified.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'increment'
op|'('
string|'"foo"'
op|','
number|'8'
op|')'
op|','
string|'"incr foo 8\\r\\n"'
op|','
nl|'\n'
string|'"4\\r\\n"'
op|','
number|'4'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_decrementVal
dedent|''
name|'def'
name|'test_decrementVal'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{MemCacheProtocol.decrement} takes an optional argument C{value} which\n        replaces the default value of 1 when specified.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'decrement'
op|'('
string|'"foo"'
op|','
number|'3'
op|')'
op|','
string|'"decr foo 3\\r\\n"'
op|','
nl|'\n'
string|'"5\\r\\n"'
op|','
number|'5'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_stats
dedent|''
name|'def'
name|'test_stats'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test retrieving server statistics via the L{MemCacheProtocol.stats}\n        command: it parses the data sent by the server and calls back the\n        resulting L{Deferred} with a dictionary of the received statistics.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'stats'
op|'('
op|')'
op|','
string|'"stats\\r\\n"'
op|','
nl|'\n'
string|'"STAT foo bar\\r\\nSTAT egg spam\\r\\nEND\\r\\n"'
op|','
nl|'\n'
op|'{'
string|'"foo"'
op|':'
string|'"bar"'
op|','
string|'"egg"'
op|':'
string|'"spam"'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_statsWithArgument
dedent|''
name|'def'
name|'test_statsWithArgument'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{MemCacheProtocol.stats} takes an optional C{str} argument which,\n        if specified, is sent along with the I{STAT} command.  The I{STAT}\n        responses from the server are parsed as key/value pairs and returned\n        as a C{dict} (as in the case where the argument is not specified).\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'stats'
op|'('
string|'"blah"'
op|')'
op|','
string|'"stats blah\\r\\n"'
op|','
nl|'\n'
string|'"STAT foo bar\\r\\nSTAT egg spam\\r\\nEND\\r\\n"'
op|','
nl|'\n'
op|'{'
string|'"foo"'
op|':'
string|'"bar"'
op|','
string|'"egg"'
op|':'
string|'"spam"'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_version
dedent|''
name|'def'
name|'test_version'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test version retrieval via the L{MemCacheProtocol.version} command: it\n        returns a L{Deferred} which is called back with the version sent by the\n        server.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'version'
op|'('
op|')'
op|','
string|'"version\\r\\n"'
op|','
nl|'\n'
string|'"VERSION 1.1\\r\\n"'
op|','
string|'"1.1"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_flushAll
dedent|''
name|'def'
name|'test_flushAll'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{MemCacheProtocol.flushAll} returns a L{Deferred} which is called back\n        with C{True} if the server acknowledges success.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'flushAll'
op|'('
op|')'
op|','
string|'"flush_all\\r\\n"'
op|','
nl|'\n'
string|'"OK\\r\\n"'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|MemCacheTestCase
dedent|''
dedent|''
name|'class'
name|'MemCacheTestCase'
op|'('
name|'CommandMixin'
op|','
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test client protocol class L{MemCacheProtocol}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a memcache client, connect it to a string protocol, and make it\n        use a deterministic clock.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'='
name|'MemCacheProtocol'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'clock'
op|'='
name|'Clock'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'callLater'
op|'='
name|'self'
op|'.'
name|'clock'
op|'.'
name|'callLater'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'='
name|'StringTransportWithDisconnection'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'protocol'
op|'='
name|'self'
op|'.'
name|'proto'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'makeConnection'
op|'('
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_test
dedent|''
name|'def'
name|'_test'
op|'('
name|'self'
op|','
name|'d'
op|','
name|'send'
op|','
name|'recv'
op|','
name|'result'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Implementation of C{_test} which checks that the command sends C{send}\n        data, and that upon reception of C{recv} the result is C{result}.\n\n        @param d: the resulting deferred from the memcache command.\n        @type d: C{Deferred}\n\n        @param send: the expected data to be sent.\n        @type send: C{str}\n\n        @param recv: the data to simulate as reception.\n        @type recv: C{str}\n\n        @param result: the expected result.\n        @type result: C{any}\n        """'
newline|'\n'
DECL|function|cb
name|'def'
name|'cb'
op|'('
name|'res'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'res'
op|','
name|'result'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
name|'send'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'cb'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'dataReceived'
op|'('
name|'recv'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_invalidGetResponse
dedent|''
name|'def'
name|'test_invalidGetResponse'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the value returned doesn\'t match the expected key of the current\n        C{get} command, an error is raised in L{MemCacheProtocol.dataReceived}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'s'
op|'='
string|'"spamegg"'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'RuntimeError'
op|','
nl|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'dataReceived'
op|','
nl|'\n'
string|'"VALUE bar 0 %s\\r\\n%s\\r\\nEND\\r\\n"'
op|'%'
op|'('
name|'len'
op|'('
name|'s'
op|')'
op|','
name|'s'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_invalidMultipleGetResponse
dedent|''
name|'def'
name|'test_invalidMultipleGetResponse'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the value returned doesn\'t match one the expected keys of the\n        current multiple C{get} command, an error is raised error in\n        L{MemCacheProtocol.dataReceived}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'getMultiple'
op|'('
op|'['
string|'"foo"'
op|','
string|'"bar"'
op|']'
op|')'
newline|'\n'
name|'s'
op|'='
string|'"spamegg"'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'RuntimeError'
op|','
nl|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'dataReceived'
op|','
nl|'\n'
string|'"VALUE egg 0 %s\\r\\n%s\\r\\nEND\\r\\n"'
op|'%'
op|'('
name|'len'
op|'('
name|'s'
op|')'
op|','
name|'s'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_timeOut
dedent|''
name|'def'
name|'test_timeOut'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test the timeout on outgoing requests: when timeout is detected, all\n        current commands fail with a L{TimeoutError}, and the connection is\n        closed.\n        """'
newline|'\n'
name|'d1'
op|'='
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'d2'
op|'='
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"bar"'
op|')'
newline|'\n'
name|'d3'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'connectionLost'
op|'='
name|'d3'
op|'.'
name|'callback'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'clock'
op|'.'
name|'advance'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'persistentTimeOut'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d1'
op|','
name|'TimeoutError'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d2'
op|','
name|'TimeoutError'
op|')'
newline|'\n'
DECL|function|checkMessage
name|'def'
name|'checkMessage'
op|'('
name|'error'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'str'
op|'('
name|'error'
op|')'
op|','
string|'"Connection timeout"'
op|')'
newline|'\n'
dedent|''
name|'d1'
op|'.'
name|'addCallback'
op|'('
name|'checkMessage'
op|')'
newline|'\n'
name|'return'
name|'gatherResults'
op|'('
op|'['
name|'d1'
op|','
name|'d2'
op|','
name|'d3'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_timeoutRemoved
dedent|''
name|'def'
name|'test_timeoutRemoved'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When a request gets a response, no pending timeout call remains around.\n        """'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"foo"'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'clock'
op|'.'
name|'advance'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'persistentTimeOut'
op|'-'
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'dataReceived'
op|'('
string|'"VALUE foo 0 3\\r\\nbar\\r\\nEND\\r\\n"'
op|')'
newline|'\n'
nl|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
name|'result'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'result'
op|','
op|'('
number|'0'
op|','
string|'"bar"'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'clock'
op|'.'
name|'calls'
op|')'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'check'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_timeOutRaw
dedent|''
name|'def'
name|'test_timeOutRaw'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test the timeout when raw mode was started: the timeout is not reset\n        until all the data has been received, so we can have a L{TimeoutError}\n        when waiting for raw data.\n        """'
newline|'\n'
name|'d1'
op|'='
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'d2'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'connectionLost'
op|'='
name|'d2'
op|'.'
name|'callback'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'dataReceived'
op|'('
string|'"VALUE foo 0 10\\r\\n12345"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'clock'
op|'.'
name|'advance'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'persistentTimeOut'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d1'
op|','
name|'TimeoutError'
op|')'
newline|'\n'
name|'return'
name|'gatherResults'
op|'('
op|'['
name|'d1'
op|','
name|'d2'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_timeOutStat
dedent|''
name|'def'
name|'test_timeOutStat'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test the timeout when stat command has started: the timeout is not\n        reset until the final B{END} is received.\n        """'
newline|'\n'
name|'d1'
op|'='
name|'self'
op|'.'
name|'proto'
op|'.'
name|'stats'
op|'('
op|')'
newline|'\n'
name|'d2'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'connectionLost'
op|'='
name|'d2'
op|'.'
name|'callback'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'dataReceived'
op|'('
string|'"STAT foo bar\\r\\n"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'clock'
op|'.'
name|'advance'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'persistentTimeOut'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d1'
op|','
name|'TimeoutError'
op|')'
newline|'\n'
name|'return'
name|'gatherResults'
op|'('
op|'['
name|'d1'
op|','
name|'d2'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_timeoutPipelining
dedent|''
name|'def'
name|'test_timeoutPipelining'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When two requests are sent, a timeout call remains around for the\n        second request, and its timeout time is correct.\n        """'
newline|'\n'
name|'d1'
op|'='
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'d2'
op|'='
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"bar"'
op|')'
newline|'\n'
name|'d3'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'connectionLost'
op|'='
name|'d3'
op|'.'
name|'callback'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'clock'
op|'.'
name|'advance'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'persistentTimeOut'
op|'-'
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'dataReceived'
op|'('
string|'"VALUE foo 0 3\\r\\nbar\\r\\nEND\\r\\n"'
op|')'
newline|'\n'
nl|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
name|'result'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'result'
op|','
op|'('
number|'0'
op|','
string|'"bar"'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'clock'
op|'.'
name|'calls'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'persistentTimeOut'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'clock'
op|'.'
name|'advance'
op|'('
number|'1'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d2'
op|','
name|'TimeoutError'
op|')'
op|'.'
name|'addCallback'
op|'('
name|'checkTime'
op|')'
newline|'\n'
DECL|function|checkTime
dedent|''
name|'def'
name|'checkTime'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
comment|'# Check that the timeout happened C{self.proto.persistentTimeOut}'
nl|'\n'
comment|'# after the last response'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'clock'
op|'.'
name|'seconds'
op|'('
op|')'
op|','
number|'2'
op|'*'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'persistentTimeOut'
op|'-'
number|'1'
op|')'
newline|'\n'
dedent|''
name|'d1'
op|'.'
name|'addCallback'
op|'('
name|'check'
op|')'
newline|'\n'
name|'return'
name|'d1'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_timeoutNotReset
dedent|''
name|'def'
name|'test_timeoutNotReset'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check that timeout is not resetted for every command, but keep the\n        timeout from the first command without response.\n        """'
newline|'\n'
name|'d1'
op|'='
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'d3'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'connectionLost'
op|'='
name|'d3'
op|'.'
name|'callback'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'clock'
op|'.'
name|'advance'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'persistentTimeOut'
op|'-'
number|'1'
op|')'
newline|'\n'
name|'d2'
op|'='
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"bar"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'clock'
op|'.'
name|'advance'
op|'('
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d1'
op|','
name|'TimeoutError'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d2'
op|','
name|'TimeoutError'
op|')'
newline|'\n'
name|'return'
name|'gatherResults'
op|'('
op|'['
name|'d1'
op|','
name|'d2'
op|','
name|'d3'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_timeoutCleanDeferreds
dedent|''
name|'def'
name|'test_timeoutCleanDeferreds'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{timeoutConnection} cleans the list of commands that it fires with\n        C{TimeoutError}: C{connectionLost} doesn\'t try to fire them again, but\n        sets the disconnected state so that future commands fail with a\n        C{RuntimeError}.\n        """'
newline|'\n'
name|'d1'
op|'='
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'clock'
op|'.'
name|'advance'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'persistentTimeOut'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d1'
op|','
name|'TimeoutError'
op|')'
newline|'\n'
name|'d2'
op|'='
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"bar"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d2'
op|','
name|'RuntimeError'
op|')'
newline|'\n'
name|'return'
name|'gatherResults'
op|'('
op|'['
name|'d1'
op|','
name|'d2'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_connectionLost
dedent|''
name|'def'
name|'test_connectionLost'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When disconnection occurs while commands are still outstanding, the\n        commands fail.\n        """'
newline|'\n'
name|'d1'
op|'='
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'d2'
op|'='
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"bar"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
name|'done'
op|'='
name|'DeferredList'
op|'('
op|'['
name|'d1'
op|','
name|'d2'
op|']'
op|','
name|'consumeErrors'
op|'='
name|'True'
op|')'
newline|'\n'
DECL|function|checkFailures
name|'def'
name|'checkFailures'
op|'('
name|'results'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'success'
op|','
name|'result'
name|'in'
name|'results'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'success'
op|')'
newline|'\n'
name|'result'
op|'.'
name|'trap'
op|'('
name|'ConnectionDone'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'done'
op|'.'
name|'addCallback'
op|'('
name|'checkFailures'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_tooLongKey
dedent|''
name|'def'
name|'test_tooLongKey'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        An error is raised when trying to use a too long key: the called\n        command returns a L{Deferred} which fails with a L{ClientError}.\n        """'
newline|'\n'
name|'d1'
op|'='
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'set'
op|'('
string|'"a"'
op|'*'
number|'500'
op|','
string|'"bar"'
op|')'
op|','
name|'ClientError'
op|')'
newline|'\n'
name|'d2'
op|'='
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'increment'
op|'('
string|'"a"'
op|'*'
number|'500'
op|')'
op|','
name|'ClientError'
op|')'
newline|'\n'
name|'d3'
op|'='
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"a"'
op|'*'
number|'500'
op|')'
op|','
name|'ClientError'
op|')'
newline|'\n'
name|'d4'
op|'='
name|'self'
op|'.'
name|'assertFailure'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'append'
op|'('
string|'"a"'
op|'*'
number|'500'
op|','
string|'"bar"'
op|')'
op|','
name|'ClientError'
op|')'
newline|'\n'
name|'d5'
op|'='
name|'self'
op|'.'
name|'assertFailure'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'prepend'
op|'('
string|'"a"'
op|'*'
number|'500'
op|','
string|'"bar"'
op|')'
op|','
name|'ClientError'
op|')'
newline|'\n'
name|'d6'
op|'='
name|'self'
op|'.'
name|'assertFailure'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'getMultiple'
op|'('
op|'['
string|'"foo"'
op|','
string|'"a"'
op|'*'
number|'500'
op|']'
op|')'
op|','
name|'ClientError'
op|')'
newline|'\n'
name|'return'
name|'gatherResults'
op|'('
op|'['
name|'d1'
op|','
name|'d2'
op|','
name|'d3'
op|','
name|'d4'
op|','
name|'d5'
op|','
name|'d6'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_invalidCommand
dedent|''
name|'def'
name|'test_invalidCommand'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When an unknown command is sent directly (not through public API), the\n        server answers with an B{ERROR} token, and the command fails with\n        L{NoSuchCommand}.\n        """'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'proto'
op|'.'
name|'_set'
op|'('
string|'"egg"'
op|','
string|'"foo"'
op|','
string|'"bar"'
op|','
number|'0'
op|','
number|'0'
op|','
string|'""'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|'"egg foo 0 0 3\\r\\nbar\\r\\n"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'NoSuchCommand'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'dataReceived'
op|'('
string|'"ERROR\\r\\n"'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_clientError
dedent|''
name|'def'
name|'test_clientError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test the L{ClientError} error: when the server sends a B{CLIENT_ERROR}\n        token, the originating command fails with L{ClientError}, and the error\n        contains the text sent by the server.\n        """'
newline|'\n'
name|'a'
op|'='
string|'"eggspamm"'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'proto'
op|'.'
name|'set'
op|'('
string|'"foo"'
op|','
name|'a'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
nl|'\n'
string|'"set foo 0 0 8\\r\\neggspamm\\r\\n"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'ClientError'
op|')'
newline|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
name|'err'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'str'
op|'('
name|'err'
op|')'
op|','
string|'"We don\'t like egg and spam"'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'check'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'dataReceived'
op|'('
string|'"CLIENT_ERROR We don\'t like egg and spam\\r\\n"'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_serverError
dedent|''
name|'def'
name|'test_serverError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test the L{ServerError} error: when the server sends a B{SERVER_ERROR}\n        token, the originating command fails with L{ServerError}, and the error\n        contains the text sent by the server.\n        """'
newline|'\n'
name|'a'
op|'='
string|'"eggspamm"'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'proto'
op|'.'
name|'set'
op|'('
string|'"foo"'
op|','
name|'a'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
nl|'\n'
string|'"set foo 0 0 8\\r\\neggspamm\\r\\n"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'ServerError'
op|')'
newline|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
name|'err'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'str'
op|'('
name|'err'
op|')'
op|','
string|'"zomg"'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'check'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'dataReceived'
op|'('
string|'"SERVER_ERROR zomg\\r\\n"'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_unicodeKey
dedent|''
name|'def'
name|'test_unicodeKey'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Using a non-string key as argument to commands raises an error.\n        """'
newline|'\n'
name|'d1'
op|'='
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'set'
op|'('
string|'u"foo"'
op|','
string|'"bar"'
op|')'
op|','
name|'ClientError'
op|')'
newline|'\n'
name|'d2'
op|'='
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'increment'
op|'('
string|'u"egg"'
op|')'
op|','
name|'ClientError'
op|')'
newline|'\n'
name|'d3'
op|'='
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
number|'1'
op|')'
op|','
name|'ClientError'
op|')'
newline|'\n'
name|'d4'
op|'='
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'delete'
op|'('
string|'u"bar"'
op|')'
op|','
name|'ClientError'
op|')'
newline|'\n'
name|'d5'
op|'='
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'append'
op|'('
string|'u"foo"'
op|','
string|'"bar"'
op|')'
op|','
name|'ClientError'
op|')'
newline|'\n'
name|'d6'
op|'='
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'prepend'
op|'('
string|'u"foo"'
op|','
string|'"bar"'
op|')'
op|','
name|'ClientError'
op|')'
newline|'\n'
name|'d7'
op|'='
name|'self'
op|'.'
name|'assertFailure'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'getMultiple'
op|'('
op|'['
string|'"egg"'
op|','
number|'1'
op|']'
op|')'
op|','
name|'ClientError'
op|')'
newline|'\n'
name|'return'
name|'gatherResults'
op|'('
op|'['
name|'d1'
op|','
name|'d2'
op|','
name|'d3'
op|','
name|'d4'
op|','
name|'d5'
op|','
name|'d6'
op|','
name|'d7'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_unicodeValue
dedent|''
name|'def'
name|'test_unicodeValue'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Using a non-string value raises an error.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'set'
op|'('
string|'"foo"'
op|','
string|'u"bar"'
op|')'
op|','
name|'ClientError'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_pipelining
dedent|''
name|'def'
name|'test_pipelining'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Multiple requests can be sent subsequently to the server, and the\n        protocol orders the responses correctly and dispatch to the\n        corresponding client command.\n        """'
newline|'\n'
name|'d1'
op|'='
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'d1'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'assertEquals'
op|','
op|'('
number|'0'
op|','
string|'"bar"'
op|')'
op|')'
newline|'\n'
name|'d2'
op|'='
name|'self'
op|'.'
name|'proto'
op|'.'
name|'set'
op|'('
string|'"bar"'
op|','
string|'"spamspamspam"'
op|')'
newline|'\n'
name|'d2'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'assertEquals'
op|','
name|'True'
op|')'
newline|'\n'
name|'d3'
op|'='
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"egg"'
op|')'
newline|'\n'
name|'d3'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'assertEquals'
op|','
op|'('
number|'0'
op|','
string|'"spam"'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
nl|'\n'
string|'"get foo\\r\\nset bar 0 0 12\\r\\nspamspamspam\\r\\nget egg\\r\\n"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'dataReceived'
op|'('
string|'"VALUE foo 0 3\\r\\nbar\\r\\nEND\\r\\n"'
nl|'\n'
string|'"STORED\\r\\n"'
nl|'\n'
string|'"VALUE egg 0 4\\r\\nspam\\r\\nEND\\r\\n"'
op|')'
newline|'\n'
name|'return'
name|'gatherResults'
op|'('
op|'['
name|'d1'
op|','
name|'d2'
op|','
name|'d3'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getInChunks
dedent|''
name|'def'
name|'test_getInChunks'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the value retrieved by a C{get} arrive in chunks, the protocol\n        is able to reconstruct it and to produce the good value.\n        """'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'assertEquals'
op|','
op|'('
number|'0'
op|','
string|'"0123456789"'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'self'
op|'.'
name|'transport'
op|'.'
name|'value'
op|'('
op|')'
op|','
string|'"get foo\\r\\n"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'dataReceived'
op|'('
string|'"VALUE foo 0 10\\r\\n0123456"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'dataReceived'
op|'('
string|'"789"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'dataReceived'
op|'('
string|'"\\r\\nEND"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'dataReceived'
op|'('
string|'"\\r\\n"'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_append
dedent|''
name|'def'
name|'test_append'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{MemCacheProtocol.append} behaves like a L{MemCacheProtocol.set}\n        method: it returns a L{Deferred} which is called back with C{True} when\n        the operation succeeds.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'append'
op|'('
string|'"foo"'
op|','
string|'"bar"'
op|')'
op|','
nl|'\n'
string|'"append foo 0 0 3\\r\\nbar\\r\\n"'
op|','
string|'"STORED\\r\\n"'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_prepend
dedent|''
name|'def'
name|'test_prepend'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{MemCacheProtocol.prepend} behaves like a L{MemCacheProtocol.set}\n        method: it returns a L{Deferred} which is called back with C{True} when\n        the operation succeeds.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'prepend'
op|'('
string|'"foo"'
op|','
string|'"bar"'
op|')'
op|','
nl|'\n'
string|'"prepend foo 0 0 3\\r\\nbar\\r\\n"'
op|','
string|'"STORED\\r\\n"'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_gets
dedent|''
name|'def'
name|'test_gets'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{MemCacheProtocol.get} handles an additional cas result when\n        C{withIdentifier} is C{True} and forward it in the resulting\n        L{Deferred}.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"foo"'
op|','
name|'True'
op|')'
op|','
string|'"gets foo\\r\\n"'
op|','
nl|'\n'
string|'"VALUE foo 0 3 1234\\r\\nbar\\r\\nEND\\r\\n"'
op|','
op|'('
number|'0'
op|','
string|'"1234"'
op|','
string|'"bar"'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_emptyGets
dedent|''
name|'def'
name|'test_emptyGets'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test getting a non-available key with gets: it succeeds but return\n        C{None} as value, C{0} as flag and an empty cas value.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'get'
op|'('
string|'"foo"'
op|','
name|'True'
op|')'
op|','
string|'"gets foo\\r\\n"'
op|','
nl|'\n'
string|'"END\\r\\n"'
op|','
op|'('
number|'0'
op|','
string|'""'
op|','
name|'None'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getsMultiple
dedent|''
name|'def'
name|'test_getsMultiple'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{MemCacheProtocol.getMultiple} handles an additional cas field in the\n        returned tuples if C{withIdentifier} is C{True}.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'getMultiple'
op|'('
op|'['
string|'"foo"'
op|','
string|'"bar"'
op|']'
op|','
name|'True'
op|')'
op|','
nl|'\n'
string|'"gets foo bar\\r\\n"'
op|','
nl|'\n'
string|'"VALUE foo 0 3 1234\\r\\negg\\r\\nVALUE bar 0 4 2345\\r\\nspam\\r\\nEND\\r\\n"'
op|','
nl|'\n'
op|'{'
string|"'bar'"
op|':'
op|'('
number|'0'
op|','
string|"'2345'"
op|','
string|"'spam'"
op|')'
op|','
string|"'foo'"
op|':'
op|'('
number|'0'
op|','
string|"'1234'"
op|','
string|"'egg'"
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getsMultipleWithEmpty
dedent|''
name|'def'
name|'test_getsMultipleWithEmpty'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When getting a non-available key with L{MemCacheProtocol.getMultiple}\n        when C{withIdentifier} is C{True}, the other keys are retrieved\n        correctly, and the non-available key gets a tuple of C{0} as flag,\n        C{None} as value, and an empty cas value.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'getMultiple'
op|'('
op|'['
string|'"foo"'
op|','
string|'"bar"'
op|']'
op|','
name|'True'
op|')'
op|','
nl|'\n'
string|'"gets foo bar\\r\\n"'
op|','
nl|'\n'
string|'"VALUE foo 0 3 1234\\r\\negg\\r\\nEND\\r\\n"'
op|','
nl|'\n'
op|'{'
string|"'bar'"
op|':'
op|'('
number|'0'
op|','
string|"''"
op|','
name|'None'
op|')'
op|','
string|"'foo'"
op|':'
op|'('
number|'0'
op|','
string|"'1234'"
op|','
string|"'egg'"
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_checkAndSet
dedent|''
name|'def'
name|'test_checkAndSet'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{MemCacheProtocol.checkAndSet} passes an additional cas identifier\n        that the server handles to check if the data has to be updated.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'checkAndSet'
op|'('
string|'"foo"'
op|','
string|'"bar"'
op|','
name|'cas'
op|'='
string|'"1234"'
op|')'
op|','
nl|'\n'
string|'"cas foo 0 0 3 1234\\r\\nbar\\r\\n"'
op|','
string|'"STORED\\r\\n"'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_casUnknowKey
dedent|''
name|'def'
name|'test_casUnknowKey'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        When L{MemCacheProtocol.checkAndSet} response is C{EXISTS}, the\n        resulting L{Deferred} fires with C{False}.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_test'
op|'('
name|'self'
op|'.'
name|'proto'
op|'.'
name|'checkAndSet'
op|'('
string|'"foo"'
op|','
string|'"bar"'
op|','
name|'cas'
op|'='
string|'"1234"'
op|')'
op|','
nl|'\n'
string|'"cas foo 0 0 3 1234\\r\\nbar\\r\\n"'
op|','
string|'"EXISTS\\r\\n"'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|CommandFailureTests
dedent|''
dedent|''
name|'class'
name|'CommandFailureTests'
op|'('
name|'CommandMixin'
op|','
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for correct failure of commands on a disconnected\n    L{MemCacheProtocol}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a disconnected memcache client, using a deterministic clock.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'='
name|'MemCacheProtocol'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'clock'
op|'='
name|'Clock'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'callLater'
op|'='
name|'self'
op|'.'
name|'clock'
op|'.'
name|'callLater'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'='
name|'StringTransportWithDisconnection'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'protocol'
op|'='
name|'self'
op|'.'
name|'proto'
newline|'\n'
name|'self'
op|'.'
name|'proto'
op|'.'
name|'makeConnection'
op|'('
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_test
dedent|''
name|'def'
name|'_test'
op|'('
name|'self'
op|','
name|'d'
op|','
name|'send'
op|','
name|'recv'
op|','
name|'result'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Implementation of C{_test} which checks that the command fails with\n        C{RuntimeError} because the transport is disconnected. All the\n        parameters except C{d} are ignored.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'RuntimeError'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
