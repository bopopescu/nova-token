begin_unit
comment|'# Copyright (c) 2006-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTests for twisted.python.modules, abstract access to imported or importable\nobjects.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'sys'
newline|'\n'
name|'import'
name|'itertools'
newline|'\n'
name|'import'
name|'zipfile'
newline|'\n'
name|'import'
name|'compileall'
newline|'\n'
nl|'\n'
name|'import'
name|'twisted'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
op|'.'
name|'unittest'
name|'import'
name|'TestCase'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'modules'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'filepath'
name|'import'
name|'FilePath'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'reflect'
name|'import'
name|'namedAny'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'test'
op|'.'
name|'test_paths'
name|'import'
name|'zipit'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|PySpaceTestCase
name|'class'
name|'PySpaceTestCase'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|findByIteration
indent|'    '
name|'def'
name|'findByIteration'
op|'('
name|'self'
op|','
name|'modname'
op|','
name|'where'
op|'='
name|'modules'
op|','
name|'importPackages'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        You don\'t ever actually want to do this, so it\'s not in the public API, but\n        sometimes we want to compare the result of an iterative call with a\n        lookup call and make sure they\'re the same for test purposes.\n        """'
newline|'\n'
name|'for'
name|'modinfo'
name|'in'
name|'where'
op|'.'
name|'walkModules'
op|'('
name|'importPackages'
op|'='
name|'importPackages'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'modinfo'
op|'.'
name|'name'
op|'=='
name|'modname'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'modinfo'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'fail'
op|'('
string|'"Unable to find module %r through iteration."'
op|'%'
op|'('
name|'modname'
op|','
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|BasicTests
dedent|''
dedent|''
name|'class'
name|'BasicTests'
op|'('
name|'PySpaceTestCase'
op|')'
op|':'
newline|'\n'
DECL|member|test_nonexistentPaths
indent|'    '
name|'def'
name|'test_nonexistentPaths'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that L{modules.walkModules} ignores entries in sys.path which\n        do not exist in the filesystem.\n        """'
newline|'\n'
name|'existentPath'
op|'='
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'makedirs'
op|'('
name|'existentPath'
op|'.'
name|'child'
op|'('
string|'"test_package"'
op|')'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'existentPath'
op|'.'
name|'child'
op|'('
string|'"test_package"'
op|')'
op|'.'
name|'child'
op|'('
string|'"__init__.py"'
op|')'
op|'.'
name|'setContent'
op|'('
string|'""'
op|')'
newline|'\n'
nl|'\n'
name|'nonexistentPath'
op|'='
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'nonexistentPath'
op|'.'
name|'exists'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'originalSearchPaths'
op|'='
name|'sys'
op|'.'
name|'path'
op|'['
op|':'
op|']'
newline|'\n'
name|'sys'
op|'.'
name|'path'
op|'['
op|':'
op|']'
op|'='
op|'['
name|'existentPath'
op|'.'
name|'path'
op|']'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'expected'
op|'='
op|'['
name|'modules'
op|'.'
name|'getModule'
op|'('
string|'"test_package"'
op|')'
op|']'
newline|'\n'
nl|'\n'
name|'beforeModules'
op|'='
name|'list'
op|'('
name|'modules'
op|'.'
name|'walkModules'
op|'('
op|')'
op|')'
newline|'\n'
name|'sys'
op|'.'
name|'path'
op|'.'
name|'append'
op|'('
name|'nonexistentPath'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'afterModules'
op|'='
name|'list'
op|'('
name|'modules'
op|'.'
name|'walkModules'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'sys'
op|'.'
name|'path'
op|'['
op|':'
op|']'
op|'='
name|'originalSearchPaths'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'beforeModules'
op|','
name|'expected'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'afterModules'
op|','
name|'expected'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_nonDirectoryPaths
dedent|''
name|'def'
name|'test_nonDirectoryPaths'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that L{modules.walkModules} ignores entries in sys.path which\n        refer to regular files in the filesystem.\n        """'
newline|'\n'
name|'existentPath'
op|'='
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'makedirs'
op|'('
name|'existentPath'
op|'.'
name|'child'
op|'('
string|'"test_package"'
op|')'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'existentPath'
op|'.'
name|'child'
op|'('
string|'"test_package"'
op|')'
op|'.'
name|'child'
op|'('
string|'"__init__.py"'
op|')'
op|'.'
name|'setContent'
op|'('
string|'""'
op|')'
newline|'\n'
nl|'\n'
name|'nonDirectoryPath'
op|'='
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'nonDirectoryPath'
op|'.'
name|'exists'
op|'('
op|')'
op|')'
newline|'\n'
name|'nonDirectoryPath'
op|'.'
name|'setContent'
op|'('
string|'"zip file or whatever\\n"'
op|')'
newline|'\n'
nl|'\n'
name|'originalSearchPaths'
op|'='
name|'sys'
op|'.'
name|'path'
op|'['
op|':'
op|']'
newline|'\n'
name|'sys'
op|'.'
name|'path'
op|'['
op|':'
op|']'
op|'='
op|'['
name|'existentPath'
op|'.'
name|'path'
op|']'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'beforeModules'
op|'='
name|'list'
op|'('
name|'modules'
op|'.'
name|'walkModules'
op|'('
op|')'
op|')'
newline|'\n'
name|'sys'
op|'.'
name|'path'
op|'.'
name|'append'
op|'('
name|'nonDirectoryPath'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'afterModules'
op|'='
name|'list'
op|'('
name|'modules'
op|'.'
name|'walkModules'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'sys'
op|'.'
name|'path'
op|'['
op|':'
op|']'
op|'='
name|'originalSearchPaths'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'beforeModules'
op|','
name|'afterModules'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_twistedShowsUp
dedent|''
name|'def'
name|'test_twistedShowsUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Scrounge around in the top-level module namespace and make sure that\n        Twisted shows up, and that the module thusly obtained is the same as\n        the module that we find when we look for it explicitly by name.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'modules'
op|'.'
name|'getModule'
op|'('
string|"'twisted'"
op|')'
op|','
nl|'\n'
name|'self'
op|'.'
name|'findByIteration'
op|'('
string|'"twisted"'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_dottedNames
dedent|''
name|'def'
name|'test_dottedNames'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that the walkModules APIs will give us back subpackages, not just\n        subpackages.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'modules'
op|'.'
name|'getModule'
op|'('
string|"'twisted.python'"
op|')'
op|','
nl|'\n'
name|'self'
op|'.'
name|'findByIteration'
op|'('
string|'"twisted.python"'
op|','
nl|'\n'
name|'where'
op|'='
name|'modules'
op|'.'
name|'getModule'
op|'('
string|"'twisted'"
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_onlyTopModules
dedent|''
name|'def'
name|'test_onlyTopModules'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that the iterModules API will only return top-level modules and\n        packages, not submodules or subpackages.\n        """'
newline|'\n'
name|'for'
name|'module'
name|'in'
name|'modules'
op|'.'
name|'iterModules'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'failIf'
op|'('
nl|'\n'
string|"'.'"
name|'in'
name|'module'
op|'.'
name|'name'
op|','
nl|'\n'
string|'"no nested modules should be returned from iterModules: %r"'
nl|'\n'
op|'%'
op|'('
name|'module'
op|'.'
name|'filePath'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_loadPackagesAndModules
dedent|''
dedent|''
name|'def'
name|'test_loadPackagesAndModules'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that we can locate and load packages, modules, submodules, and\n        subpackages.\n        """'
newline|'\n'
name|'for'
name|'n'
name|'in'
op|'['
string|"'os'"
op|','
nl|'\n'
string|"'twisted'"
op|','
nl|'\n'
string|"'twisted.python'"
op|','
nl|'\n'
string|"'twisted.python.reflect'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'m'
op|'='
name|'namedAny'
op|'('
name|'n'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessIdentical'
op|'('
nl|'\n'
name|'modules'
op|'.'
name|'getModule'
op|'('
name|'n'
op|')'
op|'.'
name|'load'
op|'('
op|')'
op|','
nl|'\n'
name|'m'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessIdentical'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'findByIteration'
op|'('
name|'n'
op|')'
op|'.'
name|'load'
op|'('
op|')'
op|','
nl|'\n'
name|'m'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_pathEntriesOnPath
dedent|''
dedent|''
name|'def'
name|'test_pathEntriesOnPath'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that path entries discovered via module loading are, in fact, on\n        sys.path somewhere.\n        """'
newline|'\n'
name|'for'
name|'n'
name|'in'
op|'['
string|"'os'"
op|','
nl|'\n'
string|"'twisted'"
op|','
nl|'\n'
string|"'twisted.python'"
op|','
nl|'\n'
string|"'twisted.python.reflect'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'failUnlessIn'
op|'('
nl|'\n'
name|'modules'
op|'.'
name|'getModule'
op|'('
name|'n'
op|')'
op|'.'
name|'pathEntry'
op|'.'
name|'filePath'
op|'.'
name|'path'
op|','
nl|'\n'
name|'sys'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_alwaysPreferPy
dedent|''
dedent|''
name|'def'
name|'test_alwaysPreferPy'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that .py files will always be preferred to .pyc files, regardless of\n        directory listing order.\n        """'
newline|'\n'
name|'mypath'
op|'='
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'mypath'
op|'.'
name|'createDirectory'
op|'('
op|')'
newline|'\n'
name|'pp'
op|'='
name|'modules'
op|'.'
name|'PythonPath'
op|'('
name|'sysPath'
op|'='
op|'['
name|'mypath'
op|'.'
name|'path'
op|']'
op|')'
newline|'\n'
name|'originalSmartPath'
op|'='
name|'pp'
op|'.'
name|'_smartPath'
newline|'\n'
DECL|function|_evilSmartPath
name|'def'
name|'_evilSmartPath'
op|'('
name|'pathName'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'o'
op|'='
name|'originalSmartPath'
op|'('
name|'pathName'
op|')'
newline|'\n'
name|'originalChildren'
op|'='
name|'o'
op|'.'
name|'children'
newline|'\n'
DECL|function|evilChildren
name|'def'
name|'evilChildren'
op|'('
op|')'
op|':'
newline|'\n'
comment|"# normally this order is random; let's make sure it always"
nl|'\n'
comment|'# comes up .pyc-first.'
nl|'\n'
indent|'                '
name|'x'
op|'='
name|'originalChildren'
op|'('
op|')'
newline|'\n'
name|'x'
op|'.'
name|'sort'
op|'('
op|')'
newline|'\n'
name|'x'
op|'.'
name|'reverse'
op|'('
op|')'
newline|'\n'
name|'return'
name|'x'
newline|'\n'
dedent|''
name|'o'
op|'.'
name|'children'
op|'='
name|'evilChildren'
newline|'\n'
name|'return'
name|'o'
newline|'\n'
dedent|''
name|'mypath'
op|'.'
name|'child'
op|'('
string|'"abcd.py"'
op|')'
op|'.'
name|'setContent'
op|'('
string|"'\\n'"
op|')'
newline|'\n'
name|'compileall'
op|'.'
name|'compile_dir'
op|'('
name|'mypath'
op|'.'
name|'path'
op|','
name|'quiet'
op|'='
name|'True'
op|')'
newline|'\n'
comment|'# sanity check'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'mypath'
op|'.'
name|'children'
op|'('
op|')'
op|')'
op|','
number|'2'
op|')'
newline|'\n'
name|'pp'
op|'.'
name|'_smartPath'
op|'='
name|'_evilSmartPath'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'pp'
op|'['
string|"'abcd'"
op|']'
op|'.'
name|'filePath'
op|','
nl|'\n'
name|'mypath'
op|'.'
name|'child'
op|'('
string|"'abcd.py'"
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_packageMissingPath
dedent|''
name|'def'
name|'test_packageMissingPath'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A package can delete its __path__ for some reasons,\n        C{modules.PythonPath} should be able to deal with it.\n        """'
newline|'\n'
name|'mypath'
op|'='
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'mypath'
op|'.'
name|'createDirectory'
op|'('
op|')'
newline|'\n'
name|'pp'
op|'='
name|'modules'
op|'.'
name|'PythonPath'
op|'('
name|'sysPath'
op|'='
op|'['
name|'mypath'
op|'.'
name|'path'
op|']'
op|')'
newline|'\n'
name|'subpath'
op|'='
name|'mypath'
op|'.'
name|'child'
op|'('
string|'"abcd"'
op|')'
newline|'\n'
name|'subpath'
op|'.'
name|'createDirectory'
op|'('
op|')'
newline|'\n'
name|'subpath'
op|'.'
name|'child'
op|'('
string|'"__init__.py"'
op|')'
op|'.'
name|'setContent'
op|'('
string|"'del __path__\\n'"
op|')'
newline|'\n'
name|'sys'
op|'.'
name|'path'
op|'.'
name|'append'
op|'('
name|'mypath'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'import'
name|'abcd'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'l'
op|'='
name|'list'
op|'('
name|'pp'
op|'.'
name|'walkModules'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'l'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'l'
op|'['
number|'0'
op|']'
op|'.'
name|'name'
op|','
string|"'abcd'"
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'del'
name|'abcd'
newline|'\n'
name|'del'
name|'sys'
op|'.'
name|'modules'
op|'['
string|"'abcd'"
op|']'
newline|'\n'
name|'sys'
op|'.'
name|'path'
op|'.'
name|'remove'
op|'('
name|'mypath'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|PathModificationTest
dedent|''
dedent|''
dedent|''
name|'class'
name|'PathModificationTest'
op|'('
name|'PySpaceTestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    These tests share setup/cleanup behavior of creating a dummy package and\n    stuffing some code in it.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|_serialnum
name|'_serialnum'
op|'='
name|'itertools'
op|'.'
name|'count'
op|'('
op|')'
op|'.'
name|'next'
comment|'# used to generate serial numbers for'
newline|'\n'
comment|'# package names.'
nl|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'pathExtensionName'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'pathExtension'
op|'='
name|'FilePath'
op|'('
name|'self'
op|'.'
name|'pathExtensionName'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'pathExtension'
op|'.'
name|'createDirectory'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'packageName'
op|'='
string|'"pyspacetests%d"'
op|'%'
op|'('
name|'self'
op|'.'
name|'_serialnum'
op|'('
op|')'
op|','
op|')'
newline|'\n'
name|'self'
op|'.'
name|'packagePath'
op|'='
name|'self'
op|'.'
name|'pathExtension'
op|'.'
name|'child'
op|'('
name|'self'
op|'.'
name|'packageName'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'packagePath'
op|'.'
name|'createDirectory'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'packagePath'
op|'.'
name|'child'
op|'('
string|'"__init__.py"'
op|')'
op|'.'
name|'setContent'
op|'('
string|'""'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'packagePath'
op|'.'
name|'child'
op|'('
string|'"a.py"'
op|')'
op|'.'
name|'setContent'
op|'('
string|'""'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'packagePath'
op|'.'
name|'child'
op|'('
string|'"b.py"'
op|')'
op|'.'
name|'setContent'
op|'('
string|'""'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'packagePath'
op|'.'
name|'child'
op|'('
string|'"c__init__.py"'
op|')'
op|'.'
name|'setContent'
op|'('
string|'""'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'pathSetUp'
op|'='
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_setupSysPath
dedent|''
name|'def'
name|'_setupSysPath'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'assert'
name|'not'
name|'self'
op|'.'
name|'pathSetUp'
newline|'\n'
name|'self'
op|'.'
name|'pathSetUp'
op|'='
name|'True'
newline|'\n'
name|'sys'
op|'.'
name|'path'
op|'.'
name|'append'
op|'('
name|'self'
op|'.'
name|'pathExtensionName'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_underUnderPathTest
dedent|''
name|'def'
name|'_underUnderPathTest'
op|'('
name|'self'
op|','
name|'doImport'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'moddir2'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'fpmd'
op|'='
name|'FilePath'
op|'('
name|'moddir2'
op|')'
newline|'\n'
name|'fpmd'
op|'.'
name|'createDirectory'
op|'('
op|')'
newline|'\n'
name|'fpmd'
op|'.'
name|'child'
op|'('
string|'"foozle.py"'
op|')'
op|'.'
name|'setContent'
op|'('
string|'"x = 123\\n"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'packagePath'
op|'.'
name|'child'
op|'('
string|'"__init__.py"'
op|')'
op|'.'
name|'setContent'
op|'('
nl|'\n'
string|'"__path__.append(%r)\\n"'
op|'%'
op|'('
name|'moddir2'
op|','
op|')'
op|')'
newline|'\n'
comment|'# Cut here'
nl|'\n'
name|'self'
op|'.'
name|'_setupSysPath'
op|'('
op|')'
newline|'\n'
name|'modinfo'
op|'='
name|'modules'
op|'.'
name|'getModule'
op|'('
name|'self'
op|'.'
name|'packageName'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'findByIteration'
op|'('
name|'self'
op|'.'
name|'packageName'
op|'+'
string|'".foozle"'
op|','
name|'modinfo'
op|','
nl|'\n'
name|'importPackages'
op|'='
name|'doImport'
op|')'
op|','
nl|'\n'
name|'modinfo'
op|'['
string|"'foozle'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'modinfo'
op|'['
string|"'foozle'"
op|']'
op|'.'
name|'load'
op|'('
op|')'
op|'.'
name|'x'
op|','
number|'123'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_underUnderPathAlreadyImported
dedent|''
name|'def'
name|'test_underUnderPathAlreadyImported'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that iterModules will honor the __path__ of already-loaded packages.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_underUnderPathTest'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_underUnderPathNotAlreadyImported
dedent|''
name|'def'
name|'test_underUnderPathNotAlreadyImported'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that iterModules will honor the __path__ of already-loaded packages.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_underUnderPathTest'
op|'('
name|'False'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
name|'test_underUnderPathNotAlreadyImported'
op|'.'
name|'todo'
op|'='
op|'('
nl|'\n'
string|'"This may be impossible but it sure would be nice."'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_listModules
name|'def'
name|'_listModules'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pkginfo'
op|'='
name|'modules'
op|'.'
name|'getModule'
op|'('
name|'self'
op|'.'
name|'packageName'
op|')'
newline|'\n'
name|'nfni'
op|'='
op|'['
name|'modinfo'
op|'.'
name|'name'
op|'.'
name|'split'
op|'('
string|'"."'
op|')'
op|'['
op|'-'
number|'1'
op|']'
name|'for'
name|'modinfo'
name|'in'
nl|'\n'
name|'pkginfo'
op|'.'
name|'iterModules'
op|'('
op|')'
op|']'
newline|'\n'
name|'nfni'
op|'.'
name|'sort'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnlessEqual'
op|'('
name|'nfni'
op|','
op|'['
string|"'a'"
op|','
string|"'b'"
op|','
string|"'c__init__'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_listingModules
dedent|''
name|'def'
name|'test_listingModules'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Make sure the module list comes back as we expect from iterModules on a\n        package, whether zipped or not.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_setupSysPath'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_listModules'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_listingModulesAlreadyImported
dedent|''
name|'def'
name|'test_listingModulesAlreadyImported'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Make sure the module list comes back as we expect from iterModules on a\n        package, whether zipped or not, even if the package has already been\n        imported.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_setupSysPath'
op|'('
op|')'
newline|'\n'
name|'namedAny'
op|'('
name|'self'
op|'.'
name|'packageName'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_listModules'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tearDown
dedent|''
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|"# Intentionally using 'assert' here, this is not a test assertion, this"
nl|'\n'
comment|'# is just an "oh fuck what is going ON" assertion. -glyph'
nl|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'pathSetUp'
op|':'
newline|'\n'
indent|'            '
name|'HORK'
op|'='
string|'"path cleanup failed: don\'t be surprised if other tests break"'
newline|'\n'
name|'assert'
name|'sys'
op|'.'
name|'path'
op|'.'
name|'pop'
op|'('
op|')'
name|'is'
name|'self'
op|'.'
name|'pathExtensionName'
op|','
name|'HORK'
op|'+'
string|'", 1"'
newline|'\n'
name|'assert'
name|'self'
op|'.'
name|'pathExtensionName'
name|'not'
name|'in'
name|'sys'
op|'.'
name|'path'
op|','
name|'HORK'
op|'+'
string|'", 2"'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|RebindingTest
dedent|''
dedent|''
dedent|''
name|'class'
name|'RebindingTest'
op|'('
name|'PathModificationTest'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    These tests verify that the default path interrogation API works properly\n    even when sys.path has been rebound to a different object.\n    """'
newline|'\n'
DECL|member|_setupSysPath
name|'def'
name|'_setupSysPath'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'assert'
name|'not'
name|'self'
op|'.'
name|'pathSetUp'
newline|'\n'
name|'self'
op|'.'
name|'pathSetUp'
op|'='
name|'True'
newline|'\n'
name|'self'
op|'.'
name|'savedSysPath'
op|'='
name|'sys'
op|'.'
name|'path'
newline|'\n'
name|'sys'
op|'.'
name|'path'
op|'='
name|'sys'
op|'.'
name|'path'
op|'['
op|':'
op|']'
newline|'\n'
name|'sys'
op|'.'
name|'path'
op|'.'
name|'append'
op|'('
name|'self'
op|'.'
name|'pathExtensionName'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tearDown
dedent|''
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Clean up sys.path by re-binding our original object.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'pathSetUp'
op|':'
newline|'\n'
indent|'            '
name|'sys'
op|'.'
name|'path'
op|'='
name|'self'
op|'.'
name|'savedSysPath'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ZipPathModificationTest
dedent|''
dedent|''
dedent|''
name|'class'
name|'ZipPathModificationTest'
op|'('
name|'PathModificationTest'
op|')'
op|':'
newline|'\n'
DECL|member|_setupSysPath
indent|'    '
name|'def'
name|'_setupSysPath'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'assert'
name|'not'
name|'self'
op|'.'
name|'pathSetUp'
newline|'\n'
name|'zipit'
op|'('
name|'self'
op|'.'
name|'pathExtensionName'
op|','
name|'self'
op|'.'
name|'pathExtensionName'
op|'+'
string|"'.zip'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'pathExtensionName'
op|'+='
string|"'.zip'"
newline|'\n'
name|'assert'
name|'zipfile'
op|'.'
name|'is_zipfile'
op|'('
name|'self'
op|'.'
name|'pathExtensionName'
op|')'
newline|'\n'
name|'PathModificationTest'
op|'.'
name|'_setupSysPath'
op|'('
name|'self'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|PythonPathTestCase
dedent|''
dedent|''
name|'class'
name|'PythonPathTestCase'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for the class which provides the implementation for all of the\n    public API of L{twisted.python.modules}, L{PythonPath}.\n    """'
newline|'\n'
DECL|member|test_unhandledImporter
name|'def'
name|'test_unhandledImporter'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Make sure that the behavior when encountering an unknown importer\n        type is not catastrophic failure.\n        """'
newline|'\n'
DECL|class|SecretImporter
name|'class'
name|'SecretImporter'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
DECL|function|hook
dedent|''
name|'def'
name|'hook'
op|'('
name|'name'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'SecretImporter'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'syspath'
op|'='
op|'['
string|"'example/path'"
op|']'
newline|'\n'
name|'sysmodules'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'syshooks'
op|'='
op|'['
name|'hook'
op|']'
newline|'\n'
name|'syscache'
op|'='
op|'{'
op|'}'
newline|'\n'
DECL|function|sysloader
name|'def'
name|'sysloader'
op|'('
name|'name'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'space'
op|'='
name|'modules'
op|'.'
name|'PythonPath'
op|'('
nl|'\n'
name|'syspath'
op|','
name|'sysmodules'
op|','
name|'syshooks'
op|','
name|'syscache'
op|','
name|'sysloader'
op|')'
newline|'\n'
name|'entries'
op|'='
name|'list'
op|'('
name|'space'
op|'.'
name|'iterEntries'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'entries'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'KeyError'
op|','
name|'lambda'
op|':'
name|'entries'
op|'['
number|'0'
op|']'
op|'['
string|"'module'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_inconsistentImporterCache
dedent|''
name|'def'
name|'test_inconsistentImporterCache'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the path a module loaded with L{PythonPath.__getitem__} is not\n        present in the path importer cache, a warning is emitted, but the\n        L{PythonModule} is returned as usual.\n        """'
newline|'\n'
name|'space'
op|'='
name|'modules'
op|'.'
name|'PythonPath'
op|'('
op|'['
op|']'
op|','
name|'sys'
op|'.'
name|'modules'
op|','
op|'['
op|']'
op|','
op|'{'
op|'}'
op|')'
newline|'\n'
name|'thisModule'
op|'='
name|'space'
op|'['
name|'__name__'
op|']'
newline|'\n'
name|'warnings'
op|'='
name|'self'
op|'.'
name|'flushWarnings'
op|'('
op|'['
name|'self'
op|'.'
name|'test_inconsistentImporterCache'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'warnings'
op|'['
number|'0'
op|']'
op|'['
string|"'category'"
op|']'
op|','
name|'UserWarning'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'warnings'
op|'['
number|'0'
op|']'
op|'['
string|"'message'"
op|']'
op|','
nl|'\n'
name|'FilePath'
op|'('
name|'twisted'
op|'.'
name|'__file__'
op|')'
op|'.'
name|'parent'
op|'('
op|')'
op|'.'
name|'dirname'
op|'('
op|')'
op|'+'
nl|'\n'
string|'" (for module "'
op|'+'
name|'__name__'
op|'+'
string|'") not in path importer cache "'
nl|'\n'
string|'"(PEP 302 violation - check your local configuration)."'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'warnings'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'thisModule'
op|'.'
name|'name'
op|','
name|'__name__'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
