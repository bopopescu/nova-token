begin_unit
comment|'# Copyright (c) 2001-2008 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTest running processes with the APIs in L{twisted.internet.utils}.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'warnings'
op|','
name|'os'
op|','
name|'stat'
op|','
name|'sys'
op|','
name|'signal'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'runtime'
name|'import'
name|'platform'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'error'
op|','
name|'reactor'
op|','
name|'utils'
op|','
name|'interfaces'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ProcessUtilsTests
name|'class'
name|'ProcessUtilsTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test running a process using L{getProcessOutput}, L{getProcessValue}, and\n    L{getProcessOutputAndValue}.\n    """'
newline|'\n'
nl|'\n'
name|'if'
name|'interfaces'
op|'.'
name|'IReactorProcess'
op|'('
name|'reactor'
op|','
name|'None'
op|')'
name|'is'
name|'None'
op|':'
newline|'\n'
DECL|variable|skip
indent|'        '
name|'skip'
op|'='
string|'"reactor doesn\'t implement IReactorProcess"'
newline|'\n'
nl|'\n'
DECL|variable|output
dedent|''
name|'output'
op|'='
name|'None'
newline|'\n'
DECL|variable|value
name|'value'
op|'='
name|'None'
newline|'\n'
DECL|variable|exe
name|'exe'
op|'='
name|'sys'
op|'.'
name|'executable'
newline|'\n'
nl|'\n'
DECL|member|makeSourceFile
name|'def'
name|'makeSourceFile'
op|'('
name|'self'
op|','
name|'sourceLines'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write the given list of lines to a text file and return the absolute\n        path to it.\n        """'
newline|'\n'
name|'script'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'scriptFile'
op|'='
name|'file'
op|'('
name|'script'
op|','
string|"'wt'"
op|')'
newline|'\n'
name|'scriptFile'
op|'.'
name|'write'
op|'('
name|'os'
op|'.'
name|'linesep'
op|'.'
name|'join'
op|'('
name|'sourceLines'
op|')'
op|'+'
name|'os'
op|'.'
name|'linesep'
op|')'
newline|'\n'
name|'scriptFile'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'abspath'
op|'('
name|'script'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_output
dedent|''
name|'def'
name|'test_output'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{getProcessOutput} returns a L{Deferred} which fires with the complete\n        output of the process it runs after that process exits.\n        """'
newline|'\n'
name|'scriptFile'
op|'='
name|'self'
op|'.'
name|'makeSourceFile'
op|'('
op|'['
nl|'\n'
string|'"import sys"'
op|','
nl|'\n'
string|'"for s in \'hello world\\\\n\':"'
op|','
nl|'\n'
string|'"    sys.stdout.write(s)"'
op|','
nl|'\n'
string|'"    sys.stdout.flush()"'
op|']'
op|')'
newline|'\n'
name|'d'
op|'='
name|'utils'
op|'.'
name|'getProcessOutput'
op|'('
name|'self'
op|'.'
name|'exe'
op|','
op|'['
string|"'-u'"
op|','
name|'scriptFile'
op|']'
op|')'
newline|'\n'
name|'return'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'assertEquals'
op|','
string|'"hello world\\n"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_outputWithErrorIgnored
dedent|''
name|'def'
name|'test_outputWithErrorIgnored'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The L{Deferred} returned by L{getProcessOutput} is fired with an\n        L{IOError} L{Failure} if the child process writes to stderr.\n        """'
newline|'\n'
comment|'# make sure stderr raises an error normally'
nl|'\n'
name|'scriptFile'
op|'='
name|'self'
op|'.'
name|'makeSourceFile'
op|'('
op|'['
nl|'\n'
string|"'import sys'"
op|','
nl|'\n'
string|'\'sys.stderr.write("hello world\\\\n")\''
nl|'\n'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'d'
op|'='
name|'utils'
op|'.'
name|'getProcessOutput'
op|'('
name|'self'
op|'.'
name|'exe'
op|','
op|'['
string|"'-u'"
op|','
name|'scriptFile'
op|']'
op|')'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'IOError'
op|')'
newline|'\n'
DECL|function|cbFailed
name|'def'
name|'cbFailed'
op|'('
name|'err'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'err'
op|'.'
name|'processEnded'
op|','
name|'error'
op|'.'
name|'ProcessDone'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'cbFailed'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_outputWithErrorCollected
dedent|''
name|'def'
name|'test_outputWithErrorCollected'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a C{True} value is supplied for the C{errortoo} parameter to\n        L{getProcessOutput}, the returned L{Deferred} fires with the child\'s\n        stderr output as well as its stdout output.\n        """'
newline|'\n'
name|'scriptFile'
op|'='
name|'self'
op|'.'
name|'makeSourceFile'
op|'('
op|'['
nl|'\n'
string|"'import sys'"
op|','
nl|'\n'
comment|"# Write the same value to both because ordering isn't guaranteed so"
nl|'\n'
comment|'# this simplifies the test.'
nl|'\n'
string|'\'sys.stdout.write("foo")\''
op|','
nl|'\n'
string|"'sys.stdout.flush()'"
op|','
nl|'\n'
string|'\'sys.stderr.write("foo")\''
op|','
nl|'\n'
string|"'sys.stderr.flush()'"
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'d'
op|'='
name|'utils'
op|'.'
name|'getProcessOutput'
op|'('
name|'self'
op|'.'
name|'exe'
op|','
op|'['
string|"'-u'"
op|','
name|'scriptFile'
op|']'
op|','
name|'errortoo'
op|'='
name|'True'
op|')'
newline|'\n'
name|'return'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'assertEqual'
op|','
string|'"foofoo"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_value
dedent|''
name|'def'
name|'test_value'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The L{Deferred} returned by L{getProcessValue} is fired with the exit\n        status of the child process.\n        """'
newline|'\n'
name|'scriptFile'
op|'='
name|'self'
op|'.'
name|'makeSourceFile'
op|'('
op|'['
string|'"raise SystemExit(1)"'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'d'
op|'='
name|'utils'
op|'.'
name|'getProcessValue'
op|'('
name|'self'
op|'.'
name|'exe'
op|','
op|'['
string|"'-u'"
op|','
name|'scriptFile'
op|']'
op|')'
newline|'\n'
name|'return'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'assertEqual'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_outputAndValue
dedent|''
name|'def'
name|'test_outputAndValue'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The L{Deferred} returned by L{getProcessOutputAndValue} fires with a\n        three-tuple, the elements of which give the data written to the child\'s\n        stdout, the data written to the child\'s stderr, and the exit status of\n        the child.\n        """'
newline|'\n'
name|'exe'
op|'='
name|'sys'
op|'.'
name|'executable'
newline|'\n'
name|'scriptFile'
op|'='
name|'self'
op|'.'
name|'makeSourceFile'
op|'('
op|'['
nl|'\n'
string|'"import sys"'
op|','
nl|'\n'
string|'"sys.stdout.write(\'hello world!\\\\n\')"'
op|','
nl|'\n'
string|'"sys.stderr.write(\'goodbye world!\\\\n\')"'
op|','
nl|'\n'
string|'"sys.exit(1)"'
nl|'\n'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|function|gotOutputAndValue
name|'def'
name|'gotOutputAndValue'
op|'('
op|'('
name|'out'
op|','
name|'err'
op|','
name|'code'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'out'
op|','
string|'"hello world!\\n"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'err'
op|','
string|'"goodbye world!"'
op|'+'
name|'os'
op|'.'
name|'linesep'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'code'
op|','
number|'1'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'='
name|'utils'
op|'.'
name|'getProcessOutputAndValue'
op|'('
name|'self'
op|'.'
name|'exe'
op|','
op|'['
string|'"-u"'
op|','
name|'scriptFile'
op|']'
op|')'
newline|'\n'
name|'return'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'gotOutputAndValue'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_outputSignal
dedent|''
name|'def'
name|'test_outputSignal'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the child process exits because of a signal, the L{Deferred}\n        returned by L{getProcessOutputAndValue} fires a L{Failure} of a tuple\n        containing the the child\'s stdout, stderr, and the signal which caused\n        it to exit.\n        """'
newline|'\n'
comment|"# Use SIGKILL here because it's guaranteed to be delivered. Using"
nl|'\n'
comment|'# SIGHUP might not work in, e.g., a buildbot slave run under the'
nl|'\n'
comment|"# 'nohup' command."
nl|'\n'
name|'scriptFile'
op|'='
name|'self'
op|'.'
name|'makeSourceFile'
op|'('
op|'['
nl|'\n'
string|'"import sys, os, signal"'
op|','
nl|'\n'
string|'"sys.stdout.write(\'stdout bytes\\\\n\')"'
op|','
nl|'\n'
string|'"sys.stderr.write(\'stderr bytes\\\\n\')"'
op|','
nl|'\n'
string|'"sys.stdout.flush()"'
op|','
nl|'\n'
string|'"sys.stderr.flush()"'
op|','
nl|'\n'
string|'"os.kill(os.getpid(), signal.SIGKILL)"'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|function|gotOutputAndValue
name|'def'
name|'gotOutputAndValue'
op|'('
op|'('
name|'out'
op|','
name|'err'
op|','
name|'sig'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'out'
op|','
string|'"stdout bytes\\n"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'err'
op|','
string|'"stderr bytes\\n"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'sig'
op|','
name|'signal'
op|'.'
name|'SIGKILL'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'d'
op|'='
name|'utils'
op|'.'
name|'getProcessOutputAndValue'
op|'('
name|'self'
op|'.'
name|'exe'
op|','
op|'['
string|"'-u'"
op|','
name|'scriptFile'
op|']'
op|')'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'assertFailure'
op|'('
name|'d'
op|','
name|'tuple'
op|')'
newline|'\n'
name|'return'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'gotOutputAndValue'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'platform'
op|'.'
name|'isWindows'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'test_outputSignal'
op|'.'
name|'skip'
op|'='
string|'"Windows doesn\'t have real signals."'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_pathTest
dedent|''
name|'def'
name|'_pathTest'
op|'('
name|'self'
op|','
name|'utilFunc'
op|','
name|'check'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'dir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'abspath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'makedirs'
op|'('
name|'dir'
op|')'
newline|'\n'
name|'scriptFile'
op|'='
name|'self'
op|'.'
name|'makeSourceFile'
op|'('
op|'['
nl|'\n'
string|'"import os, sys"'
op|','
nl|'\n'
string|'"sys.stdout.write(os.getcwd())"'
op|']'
op|')'
newline|'\n'
name|'d'
op|'='
name|'utilFunc'
op|'('
name|'self'
op|'.'
name|'exe'
op|','
op|'['
string|"'-u'"
op|','
name|'scriptFile'
op|']'
op|','
name|'path'
op|'='
name|'dir'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'check'
op|','
name|'dir'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getProcessOutputPath
dedent|''
name|'def'
name|'test_getProcessOutputPath'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{getProcessOutput} runs the given command with the working directory\n        given by the C{path} parameter.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_pathTest'
op|'('
name|'utils'
op|'.'
name|'getProcessOutput'
op|','
name|'self'
op|'.'
name|'assertEqual'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getProcessValuePath
dedent|''
name|'def'
name|'test_getProcessValuePath'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{getProcessValue} runs the given command with the working directory\n        given by the C{path} parameter.\n        """'
newline|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
name|'result'
op|','
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'result'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_pathTest'
op|'('
name|'utils'
op|'.'
name|'getProcessValue'
op|','
name|'check'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getProcessOutputAndValuePath
dedent|''
name|'def'
name|'test_getProcessOutputAndValuePath'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{getProcessOutputAndValue} runs the given command with the working\n        directory given by the C{path} parameter.\n        """'
newline|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
op|'('
name|'out'
op|','
name|'err'
op|','
name|'status'
op|')'
op|','
name|'dir'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'out'
op|','
name|'dir'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'status'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_pathTest'
op|'('
name|'utils'
op|'.'
name|'getProcessOutputAndValue'
op|','
name|'check'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_defaultPathTest
dedent|''
name|'def'
name|'_defaultPathTest'
op|'('
name|'self'
op|','
name|'utilFunc'
op|','
name|'check'
op|')'
op|':'
newline|'\n'
comment|'# Make another directory to mess around with.'
nl|'\n'
indent|'        '
name|'dir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'abspath'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'makedirs'
op|'('
name|'dir'
op|')'
newline|'\n'
nl|'\n'
name|'scriptFile'
op|'='
name|'self'
op|'.'
name|'makeSourceFile'
op|'('
op|'['
nl|'\n'
string|'"import os, sys, stat"'
op|','
nl|'\n'
comment|'# Fix the permissions so we can report the working directory.'
nl|'\n'
comment|'# On OS X (and maybe elsewhere), os.getcwd() fails with EACCES'
nl|'\n'
comment|'# if +x is missing from the working directory.'
nl|'\n'
string|'"os.chmod(%r, stat.S_IXUSR)"'
op|'%'
op|'('
name|'dir'
op|','
op|')'
op|','
nl|'\n'
string|'"sys.stdout.write(os.getcwd())"'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Switch to it, but make sure we switch back'
nl|'\n'
name|'self'
op|'.'
name|'addCleanup'
op|'('
name|'os'
op|'.'
name|'chdir'
op|','
name|'os'
op|'.'
name|'getcwd'
op|'('
op|')'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'chdir'
op|'('
name|'dir'
op|')'
newline|'\n'
nl|'\n'
comment|'# Get rid of all its permissions, but make sure they get cleaned up'
nl|'\n'
comment|'# later, because otherwise it might be hard to delete the trial'
nl|'\n'
comment|'# temporary directory.'
nl|'\n'
name|'self'
op|'.'
name|'addCleanup'
op|'('
nl|'\n'
name|'os'
op|'.'
name|'chmod'
op|','
name|'dir'
op|','
name|'stat'
op|'.'
name|'S_IMODE'
op|'('
name|'os'
op|'.'
name|'stat'
op|'('
string|"'.'"
op|')'
op|'.'
name|'st_mode'
op|')'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'chmod'
op|'('
name|'dir'
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
name|'d'
op|'='
name|'utilFunc'
op|'('
name|'self'
op|'.'
name|'exe'
op|','
op|'['
string|"'-u'"
op|','
name|'scriptFile'
op|']'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'check'
op|','
name|'dir'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getProcessOutputDefaultPath
dedent|''
name|'def'
name|'test_getProcessOutputDefaultPath'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If no value is supplied for the C{path} parameter, L{getProcessOutput}\n        runs the given command in the same working directory as the parent\n        process and succeeds even if the current working directory is not\n        accessible.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_defaultPathTest'
op|'('
name|'utils'
op|'.'
name|'getProcessOutput'
op|','
name|'self'
op|'.'
name|'assertEqual'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getProcessValueDefaultPath
dedent|''
name|'def'
name|'test_getProcessValueDefaultPath'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If no value is supplied for the C{path} parameter, L{getProcessValue}\n        runs the given command in the same working directory as the parent\n        process and succeeds even if the current working directory is not\n        accessible.\n        """'
newline|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
name|'result'
op|','
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'result'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_defaultPathTest'
op|'('
name|'utils'
op|'.'
name|'getProcessValue'
op|','
name|'check'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_getProcessOutputAndValueDefaultPath
dedent|''
name|'def'
name|'test_getProcessOutputAndValueDefaultPath'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If no value is supplied for the C{path} parameter,\n        L{getProcessOutputAndValue} runs the given command in the same working\n        directory as the parent process and succeeds even if the current\n        working directory is not accessible.\n        """'
newline|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
op|'('
name|'out'
op|','
name|'err'
op|','
name|'status'
op|')'
op|','
name|'dir'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'out'
op|','
name|'dir'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'status'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_defaultPathTest'
op|'('
nl|'\n'
name|'utils'
op|'.'
name|'getProcessOutputAndValue'
op|','
name|'check'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|WarningSuppression
dedent|''
dedent|''
name|'class'
name|'WarningSuppression'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|setUp
indent|'    '
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'warnings'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'originalshow'
op|'='
name|'warnings'
op|'.'
name|'showwarning'
newline|'\n'
name|'warnings'
op|'.'
name|'showwarning'
op|'='
name|'self'
op|'.'
name|'showwarning'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tearDown
dedent|''
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'warnings'
op|'.'
name|'showwarning'
op|'='
name|'self'
op|'.'
name|'originalshow'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|showwarning
dedent|''
name|'def'
name|'showwarning'
op|'('
name|'self'
op|','
op|'*'
name|'a'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'warnings'
op|'.'
name|'append'
op|'('
op|'('
name|'a'
op|','
name|'kw'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testSuppressWarnings
dedent|''
name|'def'
name|'testSuppressWarnings'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
DECL|function|f
indent|'        '
name|'def'
name|'f'
op|'('
name|'msg'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'warnings'
op|'.'
name|'warn'
op|'('
name|'msg'
op|')'
newline|'\n'
dedent|''
name|'g'
op|'='
name|'utils'
op|'.'
name|'suppressWarnings'
op|'('
name|'f'
op|','
op|'('
op|'('
string|"'ignore'"
op|','
op|')'
op|','
name|'dict'
op|'('
name|'message'
op|'='
string|'"This is message"'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Start off with a sanity check - calling the original function'
nl|'\n'
comment|'# should emit the warning.'
nl|'\n'
name|'f'
op|'('
string|'"Sanity check message"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'warnings'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
comment|"# Now that that's out of the way, call the wrapped function, and"
nl|'\n'
comment|'# make sure no new warnings show up.'
nl|'\n'
name|'g'
op|'('
string|'"This is message"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'warnings'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
comment|'# Finally, emit another warning which should not be ignored, and'
nl|'\n'
comment|'# make sure it is not.'
nl|'\n'
name|'g'
op|'('
string|'"Unignored message"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'warnings'
op|')'
op|','
number|'2'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
