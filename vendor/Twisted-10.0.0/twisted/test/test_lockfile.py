begin_unit
comment|'# Copyright (c) 2005 Divmod, Inc.'
nl|'\n'
comment|'# Copyright (c) 2008 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTests for L{twisted.python.lockfile}.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'os'
op|','
name|'errno'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'lockfile'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'runtime'
name|'import'
name|'platform'
newline|'\n'
nl|'\n'
DECL|variable|skipKill
name|'skipKill'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'platform'
op|'.'
name|'isWindows'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'from'
name|'win32api'
name|'import'
name|'OpenProcess'
newline|'\n'
name|'import'
name|'pywintypes'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
DECL|variable|skipKill
indent|'        '
name|'skipKill'
op|'='
op|'('
string|'"On windows, lockfile.kill is not implemented in the "'
nl|'\n'
string|'"absence of win32api and/or pywintypes."'
op|')'
newline|'\n'
nl|'\n'
DECL|class|UtilTests
dedent|''
dedent|''
name|'class'
name|'UtilTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for the helper functions used to implement L{FilesystemLock}.\n    """'
newline|'\n'
DECL|member|test_symlinkEEXIST
name|'def'
name|'test_symlinkEEXIST'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{lockfile.symlink} raises L{OSError} with C{errno} set to L{EEXIST}\n        when an attempt is made to create a symlink which already exists.\n        """'
newline|'\n'
name|'name'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'lockfile'
op|'.'
name|'symlink'
op|'('
string|"'foo'"
op|','
name|'name'
op|')'
newline|'\n'
name|'exc'
op|'='
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'OSError'
op|','
name|'lockfile'
op|'.'
name|'symlink'
op|','
string|"'foo'"
op|','
name|'name'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'exc'
op|'.'
name|'errno'
op|','
name|'errno'
op|'.'
name|'EEXIST'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_symlinkEIOWindows
dedent|''
name|'def'
name|'test_symlinkEIOWindows'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{lockfile.symlink} raises L{OSError} with C{errno} set to L{EIO} when\n        the underlying L{rename} call fails with L{EIO}.\n\n        Renaming a file on Windows may fail if the target of the rename is in\n        the process of being deleted (directory deletion appears not to be\n        atomic).\n        """'
newline|'\n'
name|'name'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
DECL|function|fakeRename
name|'def'
name|'fakeRename'
op|'('
name|'src'
op|','
name|'dst'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'IOError'
op|'('
name|'errno'
op|'.'
name|'EIO'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'patch'
op|'('
name|'lockfile'
op|','
string|"'rename'"
op|','
name|'fakeRename'
op|')'
newline|'\n'
name|'exc'
op|'='
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'IOError'
op|','
name|'lockfile'
op|'.'
name|'symlink'
op|','
name|'name'
op|','
string|'"foo"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'exc'
op|'.'
name|'errno'
op|','
name|'errno'
op|'.'
name|'EIO'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'platform'
op|'.'
name|'isWindows'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'test_symlinkEIOWindows'
op|'.'
name|'skip'
op|'='
op|'('
nl|'\n'
string|'"special rename EIO handling only necessary and correct on "'
nl|'\n'
string|'"Windows."'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_readlinkENOENT
dedent|''
name|'def'
name|'test_readlinkENOENT'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{lockfile.readlink} raises L{OSError} with C{errno} set to L{ENOENT}\n        when an attempt is made to read a symlink which does not exist.\n        """'
newline|'\n'
name|'name'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'exc'
op|'='
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'OSError'
op|','
name|'lockfile'
op|'.'
name|'readlink'
op|','
name|'name'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'exc'
op|'.'
name|'errno'
op|','
name|'errno'
op|'.'
name|'ENOENT'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_readlinkEACCESWindows
dedent|''
name|'def'
name|'test_readlinkEACCESWindows'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{lockfile.readlink} raises L{OSError} with C{errno} set to L{EACCES}\n        on Windows when the underlying file open attempt fails with C{EACCES}.\n\n        Opening a file on Windows may fail if the path is inside a directory\n        which is in the process of being deleted (directory deletion appears\n        not to be atomic).\n        """'
newline|'\n'
name|'name'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
DECL|function|fakeOpen
name|'def'
name|'fakeOpen'
op|'('
name|'path'
op|','
name|'mode'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'IOError'
op|'('
name|'errno'
op|'.'
name|'EACCES'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'patch'
op|'('
name|'lockfile'
op|','
string|"'_open'"
op|','
name|'fakeOpen'
op|')'
newline|'\n'
name|'exc'
op|'='
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'IOError'
op|','
name|'lockfile'
op|'.'
name|'readlink'
op|','
name|'name'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'exc'
op|'.'
name|'errno'
op|','
name|'errno'
op|'.'
name|'EACCES'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'platform'
op|'.'
name|'isWindows'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'test_readlinkEACCESWindows'
op|'.'
name|'skip'
op|'='
op|'('
nl|'\n'
string|'"special readlink EACCES handling only necessary and correct on "'
nl|'\n'
string|'"Windows."'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_kill
dedent|''
name|'def'
name|'test_kill'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{lockfile.kill} returns without error if passed the PID of a\n        process which exists and signal C{0}.\n        """'
newline|'\n'
name|'lockfile'
op|'.'
name|'kill'
op|'('
name|'os'
op|'.'
name|'getpid'
op|'('
op|')'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'test_kill'
op|'.'
name|'skip'
op|'='
name|'skipKill'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_killESRCH
name|'def'
name|'test_killESRCH'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{lockfile.kill} raises L{OSError} with errno of L{ESRCH} if\n        passed a PID which does not correspond to any process.\n        """'
newline|'\n'
comment|'# Hopefully there is no process with PID 2 ** 31 - 1'
nl|'\n'
name|'exc'
op|'='
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'OSError'
op|','
name|'lockfile'
op|'.'
name|'kill'
op|','
number|'2'
op|'**'
number|'31'
op|'-'
number|'1'
op|','
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'exc'
op|'.'
name|'errno'
op|','
name|'errno'
op|'.'
name|'ESRCH'
op|')'
newline|'\n'
dedent|''
name|'test_killESRCH'
op|'.'
name|'skip'
op|'='
name|'skipKill'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_noKillCall
name|'def'
name|'test_noKillCall'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Verify that when L{lockfile.kill} does end up as None (e.g. on Windows\n        without pywin32), it doesn\'t end up being called and raising a\n        L{TypeError}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'patch'
op|'('
name|'lockfile'
op|','
string|'"kill"'
op|','
name|'None'
op|')'
newline|'\n'
name|'fl'
op|'='
name|'lockfile'
op|'.'
name|'FilesystemLock'
op|'('
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
name|'fl'
op|'.'
name|'lock'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'fl'
op|'.'
name|'lock'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|LockingTestCase
dedent|''
dedent|''
name|'class'
name|'LockingTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|member|_symlinkErrorTest
indent|'    '
name|'def'
name|'_symlinkErrorTest'
op|'('
name|'self'
op|','
name|'errno'
op|')'
op|':'
newline|'\n'
DECL|function|fakeSymlink
indent|'        '
name|'def'
name|'fakeSymlink'
op|'('
name|'source'
op|','
name|'dest'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'OSError'
op|'('
name|'errno'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'patch'
op|'('
name|'lockfile'
op|','
string|"'symlink'"
op|','
name|'fakeSymlink'
op|')'
newline|'\n'
nl|'\n'
name|'lockf'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'lock'
op|'='
name|'lockfile'
op|'.'
name|'FilesystemLock'
op|'('
name|'lockf'
op|')'
newline|'\n'
name|'exc'
op|'='
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'OSError'
op|','
name|'lock'
op|'.'
name|'lock'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'exc'
op|'.'
name|'errno'
op|','
name|'errno'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_symlinkError
dedent|''
name|'def'
name|'test_symlinkError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        An exception raised by C{symlink} other than C{EEXIST} is passed up to\n        the caller of L{FilesystemLock.lock}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_symlinkErrorTest'
op|'('
name|'errno'
op|'.'
name|'ENOSYS'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_symlinkErrorPOSIX
dedent|''
name|'def'
name|'test_symlinkErrorPOSIX'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        An L{OSError} raised by C{symlink} on a POSIX platform with an errno of\n        C{EACCES} or C{EIO} is passed to the caller of L{FilesystemLock.lock}.\n\n        On POSIX, unlike on Windows, these are unexpected errors which cannot\n        be handled by L{FilesystemLock}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_symlinkErrorTest'
op|'('
name|'errno'
op|'.'
name|'EACCES'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_symlinkErrorTest'
op|'('
name|'errno'
op|'.'
name|'EIO'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'platform'
op|'.'
name|'isWindows'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'test_symlinkErrorPOSIX'
op|'.'
name|'skip'
op|'='
op|'('
nl|'\n'
string|'"POSIX-specific error propagation not expected on Windows."'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_cleanlyAcquire
dedent|''
name|'def'
name|'test_cleanlyAcquire'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the lock has never been held, it can be acquired and the C{clean}\n        and C{locked} attributes are set to C{True}.\n        """'
newline|'\n'
name|'lockf'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'lock'
op|'='
name|'lockfile'
op|'.'
name|'FilesystemLock'
op|'('
name|'lockf'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'lock'
op|'.'
name|'lock'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'lock'
op|'.'
name|'clean'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'lock'
op|'.'
name|'locked'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_cleanlyRelease
dedent|''
name|'def'
name|'test_cleanlyRelease'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a lock is released cleanly, it can be re-acquired and the C{clean}\n        and C{locked} attributes are set to C{True}.\n        """'
newline|'\n'
name|'lockf'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'lock'
op|'='
name|'lockfile'
op|'.'
name|'FilesystemLock'
op|'('
name|'lockf'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'lock'
op|'.'
name|'lock'
op|'('
op|')'
op|')'
newline|'\n'
name|'lock'
op|'.'
name|'unlock'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'lock'
op|'.'
name|'locked'
op|')'
newline|'\n'
nl|'\n'
name|'lock'
op|'='
name|'lockfile'
op|'.'
name|'FilesystemLock'
op|'('
name|'lockf'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'lock'
op|'.'
name|'lock'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'lock'
op|'.'
name|'clean'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'lock'
op|'.'
name|'locked'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_cannotLockLocked
dedent|''
name|'def'
name|'test_cannotLockLocked'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a lock is currently locked, it cannot be locked again.\n        """'
newline|'\n'
name|'lockf'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'firstLock'
op|'='
name|'lockfile'
op|'.'
name|'FilesystemLock'
op|'('
name|'lockf'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'firstLock'
op|'.'
name|'lock'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'secondLock'
op|'='
name|'lockfile'
op|'.'
name|'FilesystemLock'
op|'('
name|'lockf'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'secondLock'
op|'.'
name|'lock'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'secondLock'
op|'.'
name|'locked'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_uncleanlyAcquire
dedent|''
name|'def'
name|'test_uncleanlyAcquire'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a lock was held by a process which no longer exists, it can be\n        acquired, the C{clean} attribute is set to C{False}, and the\n        C{locked} attribute is set to C{True}.\n        """'
newline|'\n'
name|'owner'
op|'='
number|'12345'
newline|'\n'
nl|'\n'
DECL|function|fakeKill
name|'def'
name|'fakeKill'
op|'('
name|'pid'
op|','
name|'signal'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'signal'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'OSError'
op|'('
name|'errno'
op|'.'
name|'EPERM'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'pid'
op|'=='
name|'owner'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'OSError'
op|'('
name|'errno'
op|'.'
name|'ESRCH'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'lockf'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'patch'
op|'('
name|'lockfile'
op|','
string|"'kill'"
op|','
name|'fakeKill'
op|')'
newline|'\n'
name|'lockfile'
op|'.'
name|'symlink'
op|'('
name|'str'
op|'('
name|'owner'
op|')'
op|','
name|'lockf'
op|')'
newline|'\n'
nl|'\n'
name|'lock'
op|'='
name|'lockfile'
op|'.'
name|'FilesystemLock'
op|'('
name|'lockf'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'lock'
op|'.'
name|'lock'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'lock'
op|'.'
name|'clean'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'lock'
op|'.'
name|'locked'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'lockfile'
op|'.'
name|'readlink'
op|'('
name|'lockf'
op|')'
op|','
name|'str'
op|'('
name|'os'
op|'.'
name|'getpid'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_lockReleasedBeforeCheck
dedent|''
name|'def'
name|'test_lockReleasedBeforeCheck'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the lock is initially held but then released before it can be\n        examined to determine if the process which held it still exists, it is\n        acquired and the C{clean} and C{locked} attributes are set to C{True}.\n        """'
newline|'\n'
DECL|function|fakeReadlink
name|'def'
name|'fakeReadlink'
op|'('
name|'name'
op|')'
op|':'
newline|'\n'
comment|'# Pretend to be another process releasing the lock.'
nl|'\n'
indent|'            '
name|'lockfile'
op|'.'
name|'rmlink'
op|'('
name|'lockf'
op|')'
newline|'\n'
comment|'# Fall back to the real implementation of readlink.'
nl|'\n'
name|'readlinkPatch'
op|'.'
name|'restore'
op|'('
op|')'
newline|'\n'
name|'return'
name|'lockfile'
op|'.'
name|'readlink'
op|'('
name|'name'
op|')'
newline|'\n'
dedent|''
name|'readlinkPatch'
op|'='
name|'self'
op|'.'
name|'patch'
op|'('
name|'lockfile'
op|','
string|"'readlink'"
op|','
name|'fakeReadlink'
op|')'
newline|'\n'
nl|'\n'
DECL|function|fakeKill
name|'def'
name|'fakeKill'
op|'('
name|'pid'
op|','
name|'signal'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'signal'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'OSError'
op|'('
name|'errno'
op|'.'
name|'EPERM'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'pid'
op|'=='
number|'43125'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'OSError'
op|'('
name|'errno'
op|'.'
name|'ESRCH'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'patch'
op|'('
name|'lockfile'
op|','
string|"'kill'"
op|','
name|'fakeKill'
op|')'
newline|'\n'
nl|'\n'
name|'lockf'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'lock'
op|'='
name|'lockfile'
op|'.'
name|'FilesystemLock'
op|'('
name|'lockf'
op|')'
newline|'\n'
name|'lockfile'
op|'.'
name|'symlink'
op|'('
name|'str'
op|'('
number|'43125'
op|')'
op|','
name|'lockf'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'lock'
op|'.'
name|'lock'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'lock'
op|'.'
name|'clean'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'lock'
op|'.'
name|'locked'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_lockReleasedDuringAcquireSymlink
dedent|''
name|'def'
name|'test_lockReleasedDuringAcquireSymlink'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the lock is released while an attempt is made to acquire\n        it, the lock attempt fails and C{FilesystemLock.lock} returns\n        C{False}.  This can happen on Windows when L{lockfile.symlink}\n        fails with L{IOError} of C{EIO} because another process is in\n        the middle of a call to L{os.rmdir} (implemented in terms of\n        RemoveDirectory) which is not atomic.\n        """'
newline|'\n'
DECL|function|fakeSymlink
name|'def'
name|'fakeSymlink'
op|'('
name|'src'
op|','
name|'dst'
op|')'
op|':'
newline|'\n'
comment|'# While another process id doing os.rmdir which the Windows'
nl|'\n'
comment|'# implementation of rmlink does, a rename call will fail with EIO.'
nl|'\n'
indent|'            '
name|'raise'
name|'OSError'
op|'('
name|'errno'
op|'.'
name|'EIO'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'patch'
op|'('
name|'lockfile'
op|','
string|"'symlink'"
op|','
name|'fakeSymlink'
op|')'
newline|'\n'
nl|'\n'
name|'lockf'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'lock'
op|'='
name|'lockfile'
op|'.'
name|'FilesystemLock'
op|'('
name|'lockf'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'lock'
op|'.'
name|'lock'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'lock'
op|'.'
name|'locked'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'platform'
op|'.'
name|'isWindows'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'test_lockReleasedDuringAcquireSymlink'
op|'.'
name|'skip'
op|'='
op|'('
nl|'\n'
string|'"special rename EIO handling only necessary and correct on "'
nl|'\n'
string|'"Windows."'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_lockReleasedDuringAcquireReadlink
dedent|''
name|'def'
name|'test_lockReleasedDuringAcquireReadlink'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If the lock is initially held but is released while an attempt\n        is made to acquire it, the lock attempt fails and\n        L{FilesystemLock.lock} returns C{False}.\n        """'
newline|'\n'
DECL|function|fakeReadlink
name|'def'
name|'fakeReadlink'
op|'('
name|'name'
op|')'
op|':'
newline|'\n'
comment|'# While another process is doing os.rmdir which the'
nl|'\n'
comment|'# Windows implementation of rmlink does, a readlink call'
nl|'\n'
comment|'# will fail with EACCES.'
nl|'\n'
indent|'            '
name|'raise'
name|'IOError'
op|'('
name|'errno'
op|'.'
name|'EACCES'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'readlinkPatch'
op|'='
name|'self'
op|'.'
name|'patch'
op|'('
name|'lockfile'
op|','
string|"'readlink'"
op|','
name|'fakeReadlink'
op|')'
newline|'\n'
nl|'\n'
name|'lockf'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'lock'
op|'='
name|'lockfile'
op|'.'
name|'FilesystemLock'
op|'('
name|'lockf'
op|')'
newline|'\n'
name|'lockfile'
op|'.'
name|'symlink'
op|'('
name|'str'
op|'('
number|'43125'
op|')'
op|','
name|'lockf'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'lock'
op|'.'
name|'lock'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'lock'
op|'.'
name|'locked'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'platform'
op|'.'
name|'isWindows'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'test_lockReleasedDuringAcquireReadlink'
op|'.'
name|'skip'
op|'='
op|'('
nl|'\n'
string|'"special readlink EACCES handling only necessary and correct on "'
nl|'\n'
string|'"Windows."'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_readlinkErrorTest
dedent|''
name|'def'
name|'_readlinkErrorTest'
op|'('
name|'self'
op|','
name|'exceptionType'
op|','
name|'errno'
op|')'
op|':'
newline|'\n'
DECL|function|fakeReadlink
indent|'        '
name|'def'
name|'fakeReadlink'
op|'('
name|'name'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exceptionType'
op|'('
name|'errno'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'patch'
op|'('
name|'lockfile'
op|','
string|"'readlink'"
op|','
name|'fakeReadlink'
op|')'
newline|'\n'
nl|'\n'
name|'lockf'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Make it appear locked so it has to use readlink'
nl|'\n'
name|'lockfile'
op|'.'
name|'symlink'
op|'('
name|'str'
op|'('
number|'43125'
op|')'
op|','
name|'lockf'
op|')'
newline|'\n'
nl|'\n'
name|'lock'
op|'='
name|'lockfile'
op|'.'
name|'FilesystemLock'
op|'('
name|'lockf'
op|')'
newline|'\n'
name|'exc'
op|'='
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'exceptionType'
op|','
name|'lock'
op|'.'
name|'lock'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'exc'
op|'.'
name|'errno'
op|','
name|'errno'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'lock'
op|'.'
name|'locked'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_readlinkError
dedent|''
name|'def'
name|'test_readlinkError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        An exception raised by C{readlink} other than C{ENOENT} is passed up to\n        the caller of L{FilesystemLock.lock}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_readlinkErrorTest'
op|'('
name|'OSError'
op|','
name|'errno'
op|'.'
name|'ENOSYS'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_readlinkErrorTest'
op|'('
name|'IOError'
op|','
name|'errno'
op|'.'
name|'ENOSYS'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_readlinkErrorPOSIX
dedent|''
name|'def'
name|'test_readlinkErrorPOSIX'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Any L{IOError} raised by C{readlink} on a POSIX platform passed to the\n        caller of L{FilesystemLock.lock}.\n\n        On POSIX, unlike on Windows, these are unexpected errors which cannot\n        be handled by L{FilesystemLock}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_readlinkErrorTest'
op|'('
name|'IOError'
op|','
name|'errno'
op|'.'
name|'ENOSYS'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_readlinkErrorTest'
op|'('
name|'IOError'
op|','
name|'errno'
op|'.'
name|'EACCES'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'platform'
op|'.'
name|'isWindows'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'test_readlinkErrorPOSIX'
op|'.'
name|'skip'
op|'='
op|'('
nl|'\n'
string|'"POSIX-specific error propagation not expected on Windows."'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_lockCleanedUpConcurrently
dedent|''
name|'def'
name|'test_lockCleanedUpConcurrently'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If a second process cleans up the lock after a first one checks the\n        lock and finds that no process is holding it, the first process does\n        not fail when it tries to clean up the lock.\n        """'
newline|'\n'
DECL|function|fakeRmlink
name|'def'
name|'fakeRmlink'
op|'('
name|'name'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'rmlinkPatch'
op|'.'
name|'restore'
op|'('
op|')'
newline|'\n'
comment|'# Pretend to be another process cleaning up the lock.'
nl|'\n'
name|'lockfile'
op|'.'
name|'rmlink'
op|'('
name|'lockf'
op|')'
newline|'\n'
comment|'# Fall back to the real implementation of rmlink.'
nl|'\n'
name|'return'
name|'lockfile'
op|'.'
name|'rmlink'
op|'('
name|'name'
op|')'
newline|'\n'
dedent|''
name|'rmlinkPatch'
op|'='
name|'self'
op|'.'
name|'patch'
op|'('
name|'lockfile'
op|','
string|"'rmlink'"
op|','
name|'fakeRmlink'
op|')'
newline|'\n'
nl|'\n'
DECL|function|fakeKill
name|'def'
name|'fakeKill'
op|'('
name|'pid'
op|','
name|'signal'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'signal'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'OSError'
op|'('
name|'errno'
op|'.'
name|'EPERM'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'pid'
op|'=='
number|'43125'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'OSError'
op|'('
name|'errno'
op|'.'
name|'ESRCH'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'patch'
op|'('
name|'lockfile'
op|','
string|"'kill'"
op|','
name|'fakeKill'
op|')'
newline|'\n'
nl|'\n'
name|'lockf'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'lock'
op|'='
name|'lockfile'
op|'.'
name|'FilesystemLock'
op|'('
name|'lockf'
op|')'
newline|'\n'
name|'lockfile'
op|'.'
name|'symlink'
op|'('
name|'str'
op|'('
number|'43125'
op|')'
op|','
name|'lockf'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'lock'
op|'.'
name|'lock'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'lock'
op|'.'
name|'clean'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'lock'
op|'.'
name|'locked'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_rmlinkError
dedent|''
name|'def'
name|'test_rmlinkError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        An exception raised by L{rmlink} other than C{ENOENT} is passed up\n        to the caller of L{FilesystemLock.lock}.\n        """'
newline|'\n'
DECL|function|fakeRmlink
name|'def'
name|'fakeRmlink'
op|'('
name|'name'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'OSError'
op|'('
name|'errno'
op|'.'
name|'ENOSYS'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'patch'
op|'('
name|'lockfile'
op|','
string|"'rmlink'"
op|','
name|'fakeRmlink'
op|')'
newline|'\n'
nl|'\n'
DECL|function|fakeKill
name|'def'
name|'fakeKill'
op|'('
name|'pid'
op|','
name|'signal'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'signal'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'OSError'
op|'('
name|'errno'
op|'.'
name|'EPERM'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'pid'
op|'=='
number|'43125'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'OSError'
op|'('
name|'errno'
op|'.'
name|'ESRCH'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'patch'
op|'('
name|'lockfile'
op|','
string|"'kill'"
op|','
name|'fakeKill'
op|')'
newline|'\n'
nl|'\n'
name|'lockf'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Make it appear locked so it has to use readlink'
nl|'\n'
name|'lockfile'
op|'.'
name|'symlink'
op|'('
name|'str'
op|'('
number|'43125'
op|')'
op|','
name|'lockf'
op|')'
newline|'\n'
nl|'\n'
name|'lock'
op|'='
name|'lockfile'
op|'.'
name|'FilesystemLock'
op|'('
name|'lockf'
op|')'
newline|'\n'
name|'exc'
op|'='
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'OSError'
op|','
name|'lock'
op|'.'
name|'lock'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'exc'
op|'.'
name|'errno'
op|','
name|'errno'
op|'.'
name|'ENOSYS'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'lock'
op|'.'
name|'locked'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_killError
dedent|''
name|'def'
name|'test_killError'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        If L{kill} raises an exception other than L{OSError} with errno set to\n        C{ESRCH}, the exception is passed up to the caller of\n        L{FilesystemLock.lock}.\n        """'
newline|'\n'
DECL|function|fakeKill
name|'def'
name|'fakeKill'
op|'('
name|'pid'
op|','
name|'signal'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'OSError'
op|'('
name|'errno'
op|'.'
name|'EPERM'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'patch'
op|'('
name|'lockfile'
op|','
string|"'kill'"
op|','
name|'fakeKill'
op|')'
newline|'\n'
nl|'\n'
name|'lockf'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Make it appear locked so it has to use readlink'
nl|'\n'
name|'lockfile'
op|'.'
name|'symlink'
op|'('
name|'str'
op|'('
number|'43125'
op|')'
op|','
name|'lockf'
op|')'
newline|'\n'
nl|'\n'
name|'lock'
op|'='
name|'lockfile'
op|'.'
name|'FilesystemLock'
op|'('
name|'lockf'
op|')'
newline|'\n'
name|'exc'
op|'='
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'OSError'
op|','
name|'lock'
op|'.'
name|'lock'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'exc'
op|'.'
name|'errno'
op|','
name|'errno'
op|'.'
name|'EPERM'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'lock'
op|'.'
name|'locked'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_unlockOther
dedent|''
name|'def'
name|'test_unlockOther'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{FilesystemLock.unlock} raises L{ValueError} if called for a lock\n        which is held by a different process.\n        """'
newline|'\n'
name|'lockf'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'lockfile'
op|'.'
name|'symlink'
op|'('
name|'str'
op|'('
name|'os'
op|'.'
name|'getpid'
op|'('
op|')'
op|'+'
number|'1'
op|')'
op|','
name|'lockf'
op|')'
newline|'\n'
name|'lock'
op|'='
name|'lockfile'
op|'.'
name|'FilesystemLock'
op|'('
name|'lockf'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'ValueError'
op|','
name|'lock'
op|'.'
name|'unlock'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_isLocked
dedent|''
name|'def'
name|'test_isLocked'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{isLocked} returns C{True} if the named lock is currently locked,\n        C{False} otherwise.\n        """'
newline|'\n'
name|'lockf'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'lockfile'
op|'.'
name|'isLocked'
op|'('
name|'lockf'
op|')'
op|')'
newline|'\n'
name|'lock'
op|'='
name|'lockfile'
op|'.'
name|'FilesystemLock'
op|'('
name|'lockf'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'lock'
op|'.'
name|'lock'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'lockfile'
op|'.'
name|'isLocked'
op|'('
name|'lockf'
op|')'
op|')'
newline|'\n'
name|'lock'
op|'.'
name|'unlock'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'lockfile'
op|'.'
name|'isLocked'
op|'('
name|'lockf'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
