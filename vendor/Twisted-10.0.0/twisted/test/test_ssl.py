begin_unit
comment|'# Copyright (c) 2001-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTests for twisted SSL support.\n"""'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'protocol'
op|','
name|'reactor'
op|','
name|'interfaces'
op|','
name|'defer'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'protocols'
name|'import'
name|'basic'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'util'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'reflect'
name|'import'
name|'getClass'
op|','
name|'fullyQualifiedName'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'runtime'
name|'import'
name|'platform'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'test'
op|'.'
name|'test_tcp'
name|'import'
name|'WriteDataTestCase'
op|','
name|'ProperlyCloseFilesMixin'
newline|'\n'
nl|'\n'
name|'import'
name|'os'
op|','
name|'errno'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'from'
name|'OpenSSL'
name|'import'
name|'SSL'
op|','
name|'crypto'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'ssl'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'test'
op|'.'
name|'ssl_helpers'
name|'import'
name|'ClientTLSContext'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
DECL|function|_noSSL
indent|'    '
name|'def'
name|'_noSSL'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# ugh, make pyflakes happy.'
nl|'\n'
indent|'        '
name|'global'
name|'SSL'
newline|'\n'
name|'global'
name|'ssl'
newline|'\n'
name|'SSL'
op|'='
name|'ssl'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'_noSSL'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|variable|certPath
dedent|''
name|'certPath'
op|'='
name|'util'
op|'.'
name|'sibpath'
op|'('
name|'__file__'
op|','
string|'"server.pem"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|UnintelligentProtocol
name|'class'
name|'UnintelligentProtocol'
op|'('
name|'basic'
op|'.'
name|'LineReceiver'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    @ivar deferred: a deferred that will fire at connection lost.\n    @type deferred: L{defer.Deferred}\n\n    @cvar pretext: text sent before TLS is set up.\n    @type pretext: C{str}\n\n    @cvar posttext: text sent after TLS is set up.\n    @type posttext: C{str}\n    """'
newline|'\n'
DECL|variable|pretext
name|'pretext'
op|'='
op|'['
nl|'\n'
string|'"first line"'
op|','
nl|'\n'
string|'"last thing before tls starts"'
op|','
nl|'\n'
string|'"STARTTLS"'
op|']'
newline|'\n'
nl|'\n'
DECL|variable|posttext
name|'posttext'
op|'='
op|'['
nl|'\n'
string|'"first thing after tls started"'
op|','
nl|'\n'
string|'"last thing ever"'
op|']'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'deferred'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionMade
dedent|''
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'l'
name|'in'
name|'self'
op|'.'
name|'pretext'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sendLine'
op|'('
name|'l'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|lineReceived
dedent|''
dedent|''
name|'def'
name|'lineReceived'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'line'
op|'=='
string|'"READY"'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'startTLS'
op|'('
name|'ClientTLSContext'
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'factory'
op|'.'
name|'client'
op|')'
newline|'\n'
name|'for'
name|'l'
name|'in'
name|'self'
op|'.'
name|'posttext'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'sendLine'
op|'('
name|'l'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionLost
dedent|''
dedent|''
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'deferred'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|LineCollector
dedent|''
dedent|''
name|'class'
name|'LineCollector'
op|'('
name|'basic'
op|'.'
name|'LineReceiver'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    @ivar deferred: a deferred that will fire at connection lost.\n    @type deferred: L{defer.Deferred}\n\n    @ivar doTLS: whether the protocol is initiate TLS or not.\n    @type doTLS: C{bool}\n\n    @ivar fillBuffer: if set to True, it will send lots of data once\n        C{STARTTLS} is received.\n    @type fillBuffer: C{bool}\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'doTLS'
op|','
name|'fillBuffer'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'doTLS'
op|'='
name|'doTLS'
newline|'\n'
name|'self'
op|'.'
name|'fillBuffer'
op|'='
name|'fillBuffer'
newline|'\n'
name|'self'
op|'.'
name|'deferred'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionMade
dedent|''
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'factory'
op|'.'
name|'rawdata'
op|'='
string|"''"
newline|'\n'
name|'self'
op|'.'
name|'factory'
op|'.'
name|'lines'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|lineReceived
dedent|''
name|'def'
name|'lineReceived'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'factory'
op|'.'
name|'lines'
op|'.'
name|'append'
op|'('
name|'line'
op|')'
newline|'\n'
name|'if'
name|'line'
op|'=='
string|"'STARTTLS'"
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'fillBuffer'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'x'
name|'in'
name|'range'
op|'('
number|'500'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'sendLine'
op|'('
string|"'X'"
op|'*'
number|'1000'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'sendLine'
op|'('
string|"'READY'"
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'doTLS'
op|':'
newline|'\n'
indent|'                '
name|'ctx'
op|'='
name|'ServerTLSContext'
op|'('
nl|'\n'
name|'privateKeyFileName'
op|'='
name|'certPath'
op|','
nl|'\n'
name|'certificateFileName'
op|'='
name|'certPath'
op|','
nl|'\n'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'startTLS'
op|'('
name|'ctx'
op|','
name|'self'
op|'.'
name|'factory'
op|'.'
name|'server'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'setRawMode'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|rawDataReceived
dedent|''
dedent|''
dedent|''
name|'def'
name|'rawDataReceived'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'factory'
op|'.'
name|'rawdata'
op|'+='
name|'data'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionLost
dedent|''
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'deferred'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|SingleLineServerProtocol
dedent|''
dedent|''
name|'class'
name|'SingleLineServerProtocol'
op|'('
name|'protocol'
op|'.'
name|'Protocol'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A protocol that sends a single line of data at C{connectionMade}.\n    """'
newline|'\n'
nl|'\n'
DECL|member|connectionMade
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
string|'"+OK <some crap>\\r\\n"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'getPeerCertificate'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|RecordingClientProtocol
dedent|''
dedent|''
name|'class'
name|'RecordingClientProtocol'
op|'('
name|'protocol'
op|'.'
name|'Protocol'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    @ivar deferred: a deferred that will fire with first received content.\n    @type deferred: L{defer.Deferred}\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'deferred'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionMade
dedent|''
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'getPeerCertificate'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|dataReceived
dedent|''
name|'def'
name|'dataReceived'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'deferred'
op|'.'
name|'callback'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ImmediatelyDisconnectingProtocol
dedent|''
dedent|''
name|'class'
name|'ImmediatelyDisconnectingProtocol'
op|'('
name|'protocol'
op|'.'
name|'Protocol'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A protocol that disconnect immediately on connection. It fires the\n    C{connectionDisconnected} deferred of its factory on connetion lost.\n    """'
newline|'\n'
nl|'\n'
DECL|member|connectionMade
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectionLost
dedent|''
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'factory'
op|'.'
name|'connectionDisconnected'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|generateCertificateObjects
dedent|''
dedent|''
name|'def'
name|'generateCertificateObjects'
op|'('
name|'organization'
op|','
name|'organizationalUnit'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Create a certificate for given C{organization} and C{organizationalUnit}.\n\n    @return: a tuple of (key, request, certificate) objects.\n    """'
newline|'\n'
name|'pkey'
op|'='
name|'crypto'
op|'.'
name|'PKey'
op|'('
op|')'
newline|'\n'
name|'pkey'
op|'.'
name|'generate_key'
op|'('
name|'crypto'
op|'.'
name|'TYPE_RSA'
op|','
number|'512'
op|')'
newline|'\n'
name|'req'
op|'='
name|'crypto'
op|'.'
name|'X509Req'
op|'('
op|')'
newline|'\n'
name|'subject'
op|'='
name|'req'
op|'.'
name|'get_subject'
op|'('
op|')'
newline|'\n'
name|'subject'
op|'.'
name|'O'
op|'='
name|'organization'
newline|'\n'
name|'subject'
op|'.'
name|'OU'
op|'='
name|'organizationalUnit'
newline|'\n'
name|'req'
op|'.'
name|'set_pubkey'
op|'('
name|'pkey'
op|')'
newline|'\n'
name|'req'
op|'.'
name|'sign'
op|'('
name|'pkey'
op|','
string|'"md5"'
op|')'
newline|'\n'
nl|'\n'
comment|'# Here comes the actual certificate'
nl|'\n'
name|'cert'
op|'='
name|'crypto'
op|'.'
name|'X509'
op|'('
op|')'
newline|'\n'
name|'cert'
op|'.'
name|'set_serial_number'
op|'('
number|'1'
op|')'
newline|'\n'
name|'cert'
op|'.'
name|'gmtime_adj_notBefore'
op|'('
number|'0'
op|')'
newline|'\n'
name|'cert'
op|'.'
name|'gmtime_adj_notAfter'
op|'('
number|'60'
op|')'
comment|'# Testing certificates need not be long lived'
newline|'\n'
name|'cert'
op|'.'
name|'set_issuer'
op|'('
name|'req'
op|'.'
name|'get_subject'
op|'('
op|')'
op|')'
newline|'\n'
name|'cert'
op|'.'
name|'set_subject'
op|'('
name|'req'
op|'.'
name|'get_subject'
op|'('
op|')'
op|')'
newline|'\n'
name|'cert'
op|'.'
name|'set_pubkey'
op|'('
name|'req'
op|'.'
name|'get_pubkey'
op|'('
op|')'
op|')'
newline|'\n'
name|'cert'
op|'.'
name|'sign'
op|'('
name|'pkey'
op|','
string|'"md5"'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'pkey'
op|','
name|'req'
op|','
name|'cert'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|generateCertificateFiles
dedent|''
name|'def'
name|'generateCertificateFiles'
op|'('
name|'basename'
op|','
name|'organization'
op|','
name|'organizationalUnit'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Create certificate files key, req and cert prefixed by C{basename} for\n    given C{organization} and C{organizationalUnit}.\n    """'
newline|'\n'
name|'pkey'
op|','
name|'req'
op|','
name|'cert'
op|'='
name|'generateCertificateObjects'
op|'('
name|'organization'
op|','
name|'organizationalUnit'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'ext'
op|','
name|'obj'
op|','
name|'dumpFunc'
name|'in'
op|'['
nl|'\n'
op|'('
string|"'key'"
op|','
name|'pkey'
op|','
name|'crypto'
op|'.'
name|'dump_privatekey'
op|')'
op|','
nl|'\n'
op|'('
string|"'req'"
op|','
name|'req'
op|','
name|'crypto'
op|'.'
name|'dump_certificate_request'
op|')'
op|','
nl|'\n'
op|'('
string|"'cert'"
op|','
name|'cert'
op|','
name|'crypto'
op|'.'
name|'dump_certificate'
op|')'
op|']'
op|':'
newline|'\n'
indent|'        '
name|'fName'
op|'='
name|'os'
op|'.'
name|'extsep'
op|'.'
name|'join'
op|'('
op|'('
name|'basename'
op|','
name|'ext'
op|')'
op|')'
newline|'\n'
name|'fObj'
op|'='
name|'file'
op|'('
name|'fName'
op|','
string|"'w'"
op|')'
newline|'\n'
name|'fObj'
op|'.'
name|'write'
op|'('
name|'dumpFunc'
op|'('
name|'crypto'
op|'.'
name|'FILETYPE_PEM'
op|','
name|'obj'
op|')'
op|')'
newline|'\n'
name|'fObj'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ContextGeneratingMixin
dedent|''
dedent|''
name|'class'
name|'ContextGeneratingMixin'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Offer methods to create L{ssl.DefaultOpenSSLContextFactory} for both client\n    and server.\n\n    @ivar clientBase: prefix of client certificate files.\n    @type clientBase: C{str}\n\n    @ivar serverBase: prefix of server certificate files.\n    @type serverBase: C{str}\n\n    @ivar clientCtxFactory: a generated context factory to be used in\n        C{reactor.connectSSL}.\n    @type clientCtxFactory: L{ssl.DefaultOpenSSLContextFactory}\n\n    @ivar serverCtxFactory: a generated context factory to be used in\n        C{reactor.listenSSL}.\n    @type serverCtxFactory: L{ssl.DefaultOpenSSLContextFactory}\n    """'
newline|'\n'
nl|'\n'
DECL|member|makeContextFactory
name|'def'
name|'makeContextFactory'
op|'('
name|'self'
op|','
name|'org'
op|','
name|'orgUnit'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwArgs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'base'
op|'='
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
newline|'\n'
name|'generateCertificateFiles'
op|'('
name|'base'
op|','
name|'org'
op|','
name|'orgUnit'
op|')'
newline|'\n'
name|'serverCtxFactory'
op|'='
name|'ssl'
op|'.'
name|'DefaultOpenSSLContextFactory'
op|'('
nl|'\n'
name|'os'
op|'.'
name|'extsep'
op|'.'
name|'join'
op|'('
op|'('
name|'base'
op|','
string|"'key'"
op|')'
op|')'
op|','
nl|'\n'
name|'os'
op|'.'
name|'extsep'
op|'.'
name|'join'
op|'('
op|'('
name|'base'
op|','
string|"'cert'"
op|')'
op|')'
op|','
nl|'\n'
op|'*'
name|'args'
op|','
op|'**'
name|'kwArgs'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'base'
op|','
name|'serverCtxFactory'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|setupServerAndClient
dedent|''
name|'def'
name|'setupServerAndClient'
op|'('
name|'self'
op|','
name|'clientArgs'
op|','
name|'clientKwArgs'
op|','
name|'serverArgs'
op|','
nl|'\n'
name|'serverKwArgs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'clientBase'
op|','
name|'self'
op|'.'
name|'clientCtxFactory'
op|'='
name|'self'
op|'.'
name|'makeContextFactory'
op|'('
nl|'\n'
op|'*'
name|'clientArgs'
op|','
op|'**'
name|'clientKwArgs'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'serverBase'
op|','
name|'self'
op|'.'
name|'serverCtxFactory'
op|'='
name|'self'
op|'.'
name|'makeContextFactory'
op|'('
nl|'\n'
op|'*'
name|'serverArgs'
op|','
op|'**'
name|'serverKwArgs'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'SSL'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
DECL|class|ServerTLSContext
indent|'    '
name|'class'
name|'ServerTLSContext'
op|'('
name|'ssl'
op|'.'
name|'DefaultOpenSSLContextFactory'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        A context factory with a default method set to L{SSL.TLSv1_METHOD}.\n        """'
newline|'\n'
DECL|variable|isClient
name|'isClient'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'kw'
op|'['
string|"'sslmethod'"
op|']'
op|'='
name|'SSL'
op|'.'
name|'TLSv1_METHOD'
newline|'\n'
name|'ssl'
op|'.'
name|'DefaultOpenSSLContextFactory'
op|'.'
name|'__init__'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kw'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|StolenTCPTestCase
dedent|''
dedent|''
dedent|''
name|'class'
name|'StolenTCPTestCase'
op|'('
name|'ProperlyCloseFilesMixin'
op|','
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    For SSL transports, test many of the same things which are tested for\n    TCP transports.\n    """'
newline|'\n'
nl|'\n'
DECL|member|createServer
name|'def'
name|'createServer'
op|'('
name|'self'
op|','
name|'address'
op|','
name|'portNumber'
op|','
name|'factory'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create an SSL server with a certificate using L{IReactorSSL.listenSSL}.\n        """'
newline|'\n'
name|'cert'
op|'='
name|'ssl'
op|'.'
name|'PrivateCertificate'
op|'.'
name|'loadPEM'
op|'('
name|'file'
op|'('
name|'certPath'
op|')'
op|'.'
name|'read'
op|'('
op|')'
op|')'
newline|'\n'
name|'contextFactory'
op|'='
name|'cert'
op|'.'
name|'options'
op|'('
op|')'
newline|'\n'
name|'return'
name|'reactor'
op|'.'
name|'listenSSL'
op|'('
nl|'\n'
name|'portNumber'
op|','
name|'factory'
op|','
name|'contextFactory'
op|','
name|'interface'
op|'='
name|'address'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|connectClient
dedent|''
name|'def'
name|'connectClient'
op|'('
name|'self'
op|','
name|'address'
op|','
name|'portNumber'
op|','
name|'clientCreator'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create an SSL client using L{IReactorSSL.connectSSL}.\n        """'
newline|'\n'
name|'contextFactory'
op|'='
name|'ssl'
op|'.'
name|'CertificateOptions'
op|'('
op|')'
newline|'\n'
name|'return'
name|'clientCreator'
op|'.'
name|'connectSSL'
op|'('
name|'address'
op|','
name|'portNumber'
op|','
name|'contextFactory'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getHandleExceptionType
dedent|''
name|'def'
name|'getHandleExceptionType'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return L{SSL.Error} as the expected error type which will be raised by\n        a write to the L{OpenSSL.SSL.Connection} object after it has been\n        closed.\n        """'
newline|'\n'
name|'return'
name|'SSL'
op|'.'
name|'Error'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|_iocp
dedent|''
name|'_iocp'
op|'='
string|"'twisted.internet.iocpreactor.reactor.IOCPReactor'"
newline|'\n'
nl|'\n'
DECL|member|getHandleErrorCode
name|'def'
name|'getHandleErrorCode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the argument L{SSL.Error} will be constructed with for this\n        case.  This is basically just a random OpenSSL implementation detail.\n        It would be better if this test worked in a way which did not require\n        this.\n        """'
newline|'\n'
comment|'# Windows 2000 SP 4 and Windows XP SP 2 give back WSAENOTSOCK for'
nl|'\n'
comment|'# SSL.Connection.write for some reason.  The twisted.protocols.tls'
nl|'\n'
comment|"# implementation of IReactorSSL doesn't suffer from this imprecation,"
nl|'\n'
comment|'# though, since it is isolated from the Windows I/O layer (I suppose?).'
nl|'\n'
nl|'\n'
comment|'# If test_properlyCloseFiles waited for the SSL handshake to complete'
nl|'\n'
comment|'# and performed an orderly shutdown, then this would probably be a'
nl|'\n'
comment|'# little less weird: writing to a shutdown SSL connection has a more'
nl|'\n'
comment|'# well-defined failure mode (or at least it should).'
nl|'\n'
name|'name'
op|'='
name|'fullyQualifiedName'
op|'('
name|'getClass'
op|'('
name|'reactor'
op|')'
op|')'
newline|'\n'
name|'if'
name|'platform'
op|'.'
name|'getType'
op|'('
op|')'
op|'=='
string|"'win32'"
name|'and'
name|'name'
op|'!='
name|'self'
op|'.'
name|'_iocp'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'errno'
op|'.'
name|'WSAENOTSOCK'
newline|'\n'
comment|'# This is terribly implementation-specific.'
nl|'\n'
dedent|''
name|'return'
op|'['
op|'('
string|"'SSL routines'"
op|','
string|"'SSL_write'"
op|','
string|"'protocol is shutdown'"
op|')'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TLSTestCase
dedent|''
dedent|''
name|'class'
name|'TLSTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for startTLS support.\n\n    @ivar fillBuffer: forwarded to L{LineCollector.fillBuffer}\n    @type fillBuffer: C{bool}\n    """'
newline|'\n'
DECL|variable|fillBuffer
name|'fillBuffer'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|variable|clientProto
name|'clientProto'
op|'='
name|'None'
newline|'\n'
DECL|variable|serverProto
name|'serverProto'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tearDown
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'clientProto'
op|'.'
name|'transport'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'clientProto'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'serverProto'
op|'.'
name|'transport'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'serverProto'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_runTest
dedent|''
dedent|''
name|'def'
name|'_runTest'
op|'('
name|'self'
op|','
name|'clientProto'
op|','
name|'serverProto'
op|','
name|'clientIsServer'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Helper method to run TLS tests.\n\n        @param clientProto: protocol instance attached to the client\n            connection.\n        @param serverProto: protocol instance attached to the server\n            connection.\n        @param clientIsServer: flag indicated if client should initiate\n            startTLS instead of server.\n\n        @return: a L{defer.Deferred} that will fire when both connections are\n            lost.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'clientProto'
op|'='
name|'clientProto'
newline|'\n'
name|'cf'
op|'='
name|'self'
op|'.'
name|'clientFactory'
op|'='
name|'protocol'
op|'.'
name|'ClientFactory'
op|'('
op|')'
newline|'\n'
name|'cf'
op|'.'
name|'protocol'
op|'='
name|'lambda'
op|':'
name|'clientProto'
newline|'\n'
name|'if'
name|'clientIsServer'
op|':'
newline|'\n'
indent|'            '
name|'cf'
op|'.'
name|'server'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'cf'
op|'.'
name|'client'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'serverProto'
op|'='
name|'serverProto'
newline|'\n'
name|'sf'
op|'='
name|'self'
op|'.'
name|'serverFactory'
op|'='
name|'protocol'
op|'.'
name|'ServerFactory'
op|'('
op|')'
newline|'\n'
name|'sf'
op|'.'
name|'protocol'
op|'='
name|'lambda'
op|':'
name|'serverProto'
newline|'\n'
name|'if'
name|'clientIsServer'
op|':'
newline|'\n'
indent|'            '
name|'sf'
op|'.'
name|'client'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'sf'
op|'.'
name|'server'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'port'
op|'='
name|'reactor'
op|'.'
name|'listenTCP'
op|'('
number|'0'
op|','
name|'sf'
op|','
name|'interface'
op|'='
string|'"127.0.0.1"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addCleanup'
op|'('
name|'port'
op|'.'
name|'stopListening'
op|')'
newline|'\n'
nl|'\n'
name|'reactor'
op|'.'
name|'connectTCP'
op|'('
string|"'127.0.0.1'"
op|','
name|'port'
op|'.'
name|'getHost'
op|'('
op|')'
op|'.'
name|'port'
op|','
name|'cf'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'defer'
op|'.'
name|'gatherResults'
op|'('
op|'['
name|'clientProto'
op|'.'
name|'deferred'
op|','
name|'serverProto'
op|'.'
name|'deferred'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_TLS
dedent|''
name|'def'
name|'test_TLS'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test for server and client startTLS: client should received data both\n        before and after the startTLS.\n        """'
newline|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
name|'ignore'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'serverFactory'
op|'.'
name|'lines'
op|','
nl|'\n'
name|'UnintelligentProtocol'
op|'.'
name|'pretext'
op|'+'
name|'UnintelligentProtocol'
op|'.'
name|'posttext'
nl|'\n'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'='
name|'self'
op|'.'
name|'_runTest'
op|'('
name|'UnintelligentProtocol'
op|'('
op|')'
op|','
nl|'\n'
name|'LineCollector'
op|'('
name|'True'
op|','
name|'self'
op|'.'
name|'fillBuffer'
op|')'
op|')'
newline|'\n'
name|'return'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'check'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_unTLS
dedent|''
name|'def'
name|'test_unTLS'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test for server startTLS not followed by a startTLS in client: the data\n        received after server startTLS should be received as raw.\n        """'
newline|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'serverFactory'
op|'.'
name|'lines'
op|','
nl|'\n'
name|'UnintelligentProtocol'
op|'.'
name|'pretext'
nl|'\n'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'self'
op|'.'
name|'serverFactory'
op|'.'
name|'rawdata'
op|','
nl|'\n'
string|'"No encrypted bytes received"'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'='
name|'self'
op|'.'
name|'_runTest'
op|'('
name|'UnintelligentProtocol'
op|'('
op|')'
op|','
nl|'\n'
name|'LineCollector'
op|'('
name|'False'
op|','
name|'self'
op|'.'
name|'fillBuffer'
op|')'
op|')'
newline|'\n'
name|'return'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'check'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_backwardsTLS
dedent|''
name|'def'
name|'test_backwardsTLS'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test startTLS first initiated by client.\n        """'
newline|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'clientFactory'
op|'.'
name|'lines'
op|','
nl|'\n'
name|'UnintelligentProtocol'
op|'.'
name|'pretext'
op|'+'
name|'UnintelligentProtocol'
op|'.'
name|'posttext'
nl|'\n'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'='
name|'self'
op|'.'
name|'_runTest'
op|'('
name|'LineCollector'
op|'('
name|'True'
op|','
name|'self'
op|'.'
name|'fillBuffer'
op|')'
op|','
nl|'\n'
name|'UnintelligentProtocol'
op|'('
op|')'
op|','
name|'True'
op|')'
newline|'\n'
name|'return'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'check'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|SpammyTLSTestCase
dedent|''
dedent|''
name|'class'
name|'SpammyTLSTestCase'
op|'('
name|'TLSTestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test TLS features with bytes sitting in the out buffer.\n    """'
newline|'\n'
DECL|variable|fillBuffer
name|'fillBuffer'
op|'='
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|BufferingTestCase
dedent|''
name|'class'
name|'BufferingTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|variable|serverProto
indent|'    '
name|'serverProto'
op|'='
name|'None'
newline|'\n'
DECL|variable|clientProto
name|'clientProto'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tearDown
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'serverProto'
op|'.'
name|'transport'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'serverProto'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'clientProto'
op|'.'
name|'transport'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'clientProto'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_openSSLBuffering
dedent|''
dedent|''
name|'def'
name|'test_openSSLBuffering'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'serverProto'
op|'='
name|'self'
op|'.'
name|'serverProto'
op|'='
name|'SingleLineServerProtocol'
op|'('
op|')'
newline|'\n'
name|'clientProto'
op|'='
name|'self'
op|'.'
name|'clientProto'
op|'='
name|'RecordingClientProtocol'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'server'
op|'='
name|'protocol'
op|'.'
name|'ServerFactory'
op|'('
op|')'
newline|'\n'
name|'client'
op|'='
name|'self'
op|'.'
name|'client'
op|'='
name|'protocol'
op|'.'
name|'ClientFactory'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'server'
op|'.'
name|'protocol'
op|'='
name|'lambda'
op|':'
name|'serverProto'
newline|'\n'
name|'client'
op|'.'
name|'protocol'
op|'='
name|'lambda'
op|':'
name|'clientProto'
newline|'\n'
nl|'\n'
name|'sCTX'
op|'='
name|'ssl'
op|'.'
name|'DefaultOpenSSLContextFactory'
op|'('
name|'certPath'
op|','
name|'certPath'
op|')'
newline|'\n'
name|'cCTX'
op|'='
name|'ssl'
op|'.'
name|'ClientContextFactory'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'port'
op|'='
name|'reactor'
op|'.'
name|'listenSSL'
op|'('
number|'0'
op|','
name|'server'
op|','
name|'sCTX'
op|','
name|'interface'
op|'='
string|"'127.0.0.1'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'addCleanup'
op|'('
name|'port'
op|'.'
name|'stopListening'
op|')'
newline|'\n'
nl|'\n'
name|'reactor'
op|'.'
name|'connectSSL'
op|'('
string|"'127.0.0.1'"
op|','
name|'port'
op|'.'
name|'getHost'
op|'('
op|')'
op|'.'
name|'port'
op|','
name|'client'
op|','
name|'cCTX'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'clientProto'
op|'.'
name|'deferred'
op|'.'
name|'addCallback'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|','
string|'"+OK <some crap>\\r\\n"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ConnectionLostTestCase
dedent|''
dedent|''
name|'class'
name|'ConnectionLostTestCase'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|','
name|'ContextGeneratingMixin'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|testImmediateDisconnect
indent|'    '
name|'def'
name|'testImmediateDisconnect'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'org'
op|'='
string|'"twisted.test.test_ssl"'
newline|'\n'
name|'self'
op|'.'
name|'setupServerAndClient'
op|'('
nl|'\n'
op|'('
name|'org'
op|','
name|'org'
op|'+'
string|'", client"'
op|')'
op|','
op|'{'
op|'}'
op|','
nl|'\n'
op|'('
name|'org'
op|','
name|'org'
op|'+'
string|'", server"'
op|')'
op|','
op|'{'
op|'}'
op|')'
newline|'\n'
nl|'\n'
comment|'# Set up a server, connect to it with a client, which should work since our verifiers'
nl|'\n'
comment|'# allow anything, then disconnect.'
nl|'\n'
name|'serverProtocolFactory'
op|'='
name|'protocol'
op|'.'
name|'ServerFactory'
op|'('
op|')'
newline|'\n'
name|'serverProtocolFactory'
op|'.'
name|'protocol'
op|'='
name|'protocol'
op|'.'
name|'Protocol'
newline|'\n'
name|'self'
op|'.'
name|'serverPort'
op|'='
name|'serverPort'
op|'='
name|'reactor'
op|'.'
name|'listenSSL'
op|'('
number|'0'
op|','
nl|'\n'
name|'serverProtocolFactory'
op|','
name|'self'
op|'.'
name|'serverCtxFactory'
op|')'
newline|'\n'
nl|'\n'
name|'clientProtocolFactory'
op|'='
name|'protocol'
op|'.'
name|'ClientFactory'
op|'('
op|')'
newline|'\n'
name|'clientProtocolFactory'
op|'.'
name|'protocol'
op|'='
name|'ImmediatelyDisconnectingProtocol'
newline|'\n'
name|'clientProtocolFactory'
op|'.'
name|'connectionDisconnected'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'clientConnector'
op|'='
name|'reactor'
op|'.'
name|'connectSSL'
op|'('
string|"'127.0.0.1'"
op|','
nl|'\n'
name|'serverPort'
op|'.'
name|'getHost'
op|'('
op|')'
op|'.'
name|'port'
op|','
name|'clientProtocolFactory'
op|','
name|'self'
op|'.'
name|'clientCtxFactory'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'clientProtocolFactory'
op|'.'
name|'connectionDisconnected'
op|'.'
name|'addCallback'
op|'('
nl|'\n'
name|'lambda'
name|'ignoredResult'
op|':'
name|'self'
op|'.'
name|'serverPort'
op|'.'
name|'stopListening'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|testFailedVerify
dedent|''
name|'def'
name|'testFailedVerify'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'org'
op|'='
string|'"twisted.test.test_ssl"'
newline|'\n'
name|'self'
op|'.'
name|'setupServerAndClient'
op|'('
nl|'\n'
op|'('
name|'org'
op|','
name|'org'
op|'+'
string|'", client"'
op|')'
op|','
op|'{'
op|'}'
op|','
nl|'\n'
op|'('
name|'org'
op|','
name|'org'
op|'+'
string|'", server"'
op|')'
op|','
op|'{'
op|'}'
op|')'
newline|'\n'
nl|'\n'
DECL|function|verify
name|'def'
name|'verify'
op|'('
op|'*'
name|'a'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'clientCtxFactory'
op|'.'
name|'getContext'
op|'('
op|')'
op|'.'
name|'set_verify'
op|'('
name|'SSL'
op|'.'
name|'VERIFY_PEER'
op|','
name|'verify'
op|')'
newline|'\n'
nl|'\n'
name|'serverConnLost'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'serverProtocol'
op|'='
name|'protocol'
op|'.'
name|'Protocol'
op|'('
op|')'
newline|'\n'
name|'serverProtocol'
op|'.'
name|'connectionLost'
op|'='
name|'serverConnLost'
op|'.'
name|'callback'
newline|'\n'
name|'serverProtocolFactory'
op|'='
name|'protocol'
op|'.'
name|'ServerFactory'
op|'('
op|')'
newline|'\n'
name|'serverProtocolFactory'
op|'.'
name|'protocol'
op|'='
name|'lambda'
op|':'
name|'serverProtocol'
newline|'\n'
name|'self'
op|'.'
name|'serverPort'
op|'='
name|'serverPort'
op|'='
name|'reactor'
op|'.'
name|'listenSSL'
op|'('
number|'0'
op|','
nl|'\n'
name|'serverProtocolFactory'
op|','
name|'self'
op|'.'
name|'serverCtxFactory'
op|')'
newline|'\n'
nl|'\n'
name|'clientConnLost'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'clientProtocol'
op|'='
name|'protocol'
op|'.'
name|'Protocol'
op|'('
op|')'
newline|'\n'
name|'clientProtocol'
op|'.'
name|'connectionLost'
op|'='
name|'clientConnLost'
op|'.'
name|'callback'
newline|'\n'
name|'clientProtocolFactory'
op|'='
name|'protocol'
op|'.'
name|'ClientFactory'
op|'('
op|')'
newline|'\n'
name|'clientProtocolFactory'
op|'.'
name|'protocol'
op|'='
name|'lambda'
op|':'
name|'clientProtocol'
newline|'\n'
name|'clientConnector'
op|'='
name|'reactor'
op|'.'
name|'connectSSL'
op|'('
string|"'127.0.0.1'"
op|','
nl|'\n'
name|'serverPort'
op|'.'
name|'getHost'
op|'('
op|')'
op|'.'
name|'port'
op|','
name|'clientProtocolFactory'
op|','
name|'self'
op|'.'
name|'clientCtxFactory'
op|')'
newline|'\n'
nl|'\n'
name|'dl'
op|'='
name|'defer'
op|'.'
name|'DeferredList'
op|'('
op|'['
name|'serverConnLost'
op|','
name|'clientConnLost'
op|']'
op|','
name|'consumeErrors'
op|'='
name|'True'
op|')'
newline|'\n'
name|'return'
name|'dl'
op|'.'
name|'addCallback'
op|'('
name|'self'
op|'.'
name|'_cbLostConns'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_cbLostConns
dedent|''
name|'def'
name|'_cbLostConns'
op|'('
name|'self'
op|','
name|'results'
op|')'
op|':'
newline|'\n'
indent|'        '
op|'('
name|'sSuccess'
op|','
name|'sResult'
op|')'
op|','
op|'('
name|'cSuccess'
op|','
name|'cResult'
op|')'
op|'='
name|'results'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'sSuccess'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIf'
op|'('
name|'cSuccess'
op|')'
newline|'\n'
nl|'\n'
name|'acceptableErrors'
op|'='
op|'['
name|'SSL'
op|'.'
name|'Error'
op|']'
newline|'\n'
nl|'\n'
comment|'# Rather than getting a verification failure on Windows, we are getting'
nl|'\n'
comment|'# a connection failure.  Without something like sslverify proxying'
nl|'\n'
comment|"# in-between we can't fix up the platform's errors, so let's just"
nl|'\n'
comment|'# specifically say it is only OK in this one case to keep the tests'
nl|'\n'
comment|"# passing.  Normally we'd like to be as strict as possible here, so"
nl|'\n'
comment|"# we're not going to allow this to report errors incorrectly on any"
nl|'\n'
comment|'# other platforms.'
nl|'\n'
nl|'\n'
name|'if'
name|'platform'
op|'.'
name|'isWindows'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'error'
name|'import'
name|'ConnectionLost'
newline|'\n'
name|'acceptableErrors'
op|'.'
name|'append'
op|'('
name|'ConnectionLost'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'sResult'
op|'.'
name|'trap'
op|'('
op|'*'
name|'acceptableErrors'
op|')'
newline|'\n'
name|'cResult'
op|'.'
name|'trap'
op|'('
op|'*'
name|'acceptableErrors'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'serverPort'
op|'.'
name|'stopListening'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|FakeContext
dedent|''
dedent|''
name|'class'
name|'FakeContext'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    L{OpenSSL.SSL.Context} double which can more easily be inspected.\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'method'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_method'
op|'='
name|'method'
newline|'\n'
name|'self'
op|'.'
name|'_options'
op|'='
number|'0'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|set_options
dedent|''
name|'def'
name|'set_options'
op|'('
name|'self'
op|','
name|'options'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_options'
op|'|='
name|'options'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|use_certificate_file
dedent|''
name|'def'
name|'use_certificate_file'
op|'('
name|'self'
op|','
name|'fileName'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|use_privatekey_file
dedent|''
name|'def'
name|'use_privatekey_file'
op|'('
name|'self'
op|','
name|'fileName'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|DefaultOpenSSLContextFactoryTests
dedent|''
dedent|''
name|'class'
name|'DefaultOpenSSLContextFactoryTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{ssl.DefaultOpenSSLContextFactory}.\n    """'
newline|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|"# pyOpenSSL Context objects aren't introspectable enough.  Pass in"
nl|'\n'
comment|'# an alternate context factory so we can inspect what is done to it.'
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'contextFactory'
op|'='
name|'ssl'
op|'.'
name|'DefaultOpenSSLContextFactory'
op|'('
nl|'\n'
name|'certPath'
op|','
name|'certPath'
op|','
name|'_contextFactory'
op|'='
name|'FakeContext'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'context'
op|'='
name|'self'
op|'.'
name|'contextFactory'
op|'.'
name|'getContext'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_method
dedent|''
name|'def'
name|'test_method'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{ssl.DefaultOpenSSLContextFactory.getContext} returns an SSL context\n        which can use SSLv3 or TLSv1 but not SSLv2.\n        """'
newline|'\n'
comment|'# SSLv23_METHOD allows SSLv2, SSLv3, or TLSv1'
nl|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'context'
op|'.'
name|'_method'
op|','
name|'SSL'
op|'.'
name|'SSLv23_METHOD'
op|')'
newline|'\n'
nl|'\n'
comment|'# And OP_NO_SSLv2 disables the SSLv2 support.'
nl|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'context'
op|'.'
name|'_options'
op|'&'
name|'SSL'
op|'.'
name|'OP_NO_SSLv2'
op|')'
newline|'\n'
nl|'\n'
comment|"# Make sure SSLv3 and TLSv1 aren't disabled though."
nl|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'self'
op|'.'
name|'context'
op|'.'
name|'_options'
op|'&'
name|'SSL'
op|'.'
name|'OP_NO_SSLv3'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'self'
op|'.'
name|'context'
op|'.'
name|'_options'
op|'&'
name|'SSL'
op|'.'
name|'OP_NO_TLSv1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_missingCertificateFile
dedent|''
name|'def'
name|'test_missingCertificateFile'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Instantiating L{ssl.DefaultOpenSSLContextFactory} with a certificate\n        filename which does not identify an existing file results in the\n        initializer raising L{OpenSSL.SSL.Error}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
nl|'\n'
name|'SSL'
op|'.'
name|'Error'
op|','
nl|'\n'
name|'ssl'
op|'.'
name|'DefaultOpenSSLContextFactory'
op|','
name|'certPath'
op|','
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_missingPrivateKeyFile
dedent|''
name|'def'
name|'test_missingPrivateKeyFile'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Instantiating L{ssl.DefaultOpenSSLContextFactory} with a private key\n        filename which does not identify an existing file results in the\n        initializer raising L{OpenSSL.SSL.Error}.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertRaises'
op|'('
nl|'\n'
name|'SSL'
op|'.'
name|'Error'
op|','
nl|'\n'
name|'ssl'
op|'.'
name|'DefaultOpenSSLContextFactory'
op|','
name|'self'
op|'.'
name|'mktemp'
op|'('
op|')'
op|','
name|'certPath'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|ClientContextFactoryTests
dedent|''
dedent|''
name|'class'
name|'ClientContextFactoryTests'
op|'('
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for L{ssl.ClientContextFactory}.\n    """'
newline|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'contextFactory'
op|'='
name|'ssl'
op|'.'
name|'ClientContextFactory'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'contextFactory'
op|'.'
name|'_contextFactory'
op|'='
name|'FakeContext'
newline|'\n'
name|'self'
op|'.'
name|'context'
op|'='
name|'self'
op|'.'
name|'contextFactory'
op|'.'
name|'getContext'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_method
dedent|''
name|'def'
name|'test_method'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{ssl.ClientContextFactory.getContext} returns a context which can use\n        SSLv3 or TLSv1 but not SSLv2.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'assertEqual'
op|'('
name|'self'
op|'.'
name|'context'
op|'.'
name|'_method'
op|','
name|'SSL'
op|'.'
name|'SSLv23_METHOD'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'self'
op|'.'
name|'context'
op|'.'
name|'_options'
op|'&'
name|'SSL'
op|'.'
name|'OP_NO_SSLv2'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'self'
op|'.'
name|'context'
op|'.'
name|'_options'
op|'&'
name|'SSL'
op|'.'
name|'OP_NO_SSLv3'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertFalse'
op|'('
name|'self'
op|'.'
name|'context'
op|'.'
name|'_options'
op|'&'
name|'SSL'
op|'.'
name|'OP_NO_TLSv1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'interfaces'
op|'.'
name|'IReactorSSL'
op|'('
name|'reactor'
op|','
name|'None'
op|')'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'    '
name|'for'
name|'tCase'
name|'in'
op|'['
name|'StolenTCPTestCase'
op|','
name|'TLSTestCase'
op|','
name|'SpammyTLSTestCase'
op|','
nl|'\n'
name|'BufferingTestCase'
op|','
name|'ConnectionLostTestCase'
op|','
nl|'\n'
name|'DefaultOpenSSLContextFactoryTests'
op|','
nl|'\n'
name|'ClientContextFactoryTests'
op|']'
op|':'
newline|'\n'
indent|'        '
name|'tCase'
op|'.'
name|'skip'
op|'='
string|'"Reactor does not support SSL, cannot run SSL tests"'
newline|'\n'
nl|'\n'
comment|'# Otherwise trial will run this test here'
nl|'\n'
dedent|''
dedent|''
name|'del'
name|'WriteDataTestCase'
newline|'\n'
endmarker|''
end_unit
