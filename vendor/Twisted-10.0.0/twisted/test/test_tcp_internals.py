begin_unit
comment|'# Copyright (c) 2006 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nWhitebox tests for TCP APIs.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'errno'
op|','
name|'socket'
op|','
name|'os'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'import'
name|'resource'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
DECL|variable|resource
indent|'    '
name|'resource'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'from'
name|'twisted'
op|'.'
name|'trial'
op|'.'
name|'unittest'
name|'import'
name|'TestCase'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'log'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'tcp'
name|'import'
name|'ECONNABORTED'
op|','
name|'ENOMEM'
op|','
name|'ENFILE'
op|','
name|'EMFILE'
op|','
name|'ENOBUFS'
op|','
name|'EINPROGRESS'
op|','
name|'Port'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'protocol'
name|'import'
name|'ServerFactory'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
op|'.'
name|'runtime'
name|'import'
name|'platform'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'defer'
name|'import'
name|'maybeDeferred'
op|','
name|'gatherResults'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'reactor'
op|','
name|'interfaces'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|PlatformAssumptionsTestCase
name|'class'
name|'PlatformAssumptionsTestCase'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Test assumptions about platform behaviors.\n    """'
newline|'\n'
DECL|variable|socketLimit
name|'socketLimit'
op|'='
number|'8192'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'openSockets'
op|'='
op|'['
op|']'
newline|'\n'
name|'if'
name|'resource'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'originalFileLimit'
op|'='
name|'resource'
op|'.'
name|'getrlimit'
op|'('
name|'resource'
op|'.'
name|'RLIMIT_NOFILE'
op|')'
newline|'\n'
name|'resource'
op|'.'
name|'setrlimit'
op|'('
name|'resource'
op|'.'
name|'RLIMIT_NOFILE'
op|','
op|'('
number|'128'
op|','
name|'self'
op|'.'
name|'originalFileLimit'
op|'['
number|'1'
op|']'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'socketLimit'
op|'='
number|'256'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tearDown
dedent|''
dedent|''
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'while'
name|'self'
op|'.'
name|'openSockets'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'openSockets'
op|'.'
name|'pop'
op|'('
op|')'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'resource'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
comment|'# OS X implicitly lowers the hard limit in the setrlimit call'
nl|'\n'
comment|'# above.  Retrieve the new hard limit to pass in to this'
nl|'\n'
comment|"# setrlimit call, so that it doesn't give us a permission denied"
nl|'\n'
comment|'# error.'
nl|'\n'
indent|'            '
name|'currentHardLimit'
op|'='
name|'resource'
op|'.'
name|'getrlimit'
op|'('
name|'resource'
op|'.'
name|'RLIMIT_NOFILE'
op|')'
op|'['
number|'1'
op|']'
newline|'\n'
name|'newSoftLimit'
op|'='
name|'min'
op|'('
name|'self'
op|'.'
name|'originalFileLimit'
op|'['
number|'0'
op|']'
op|','
name|'currentHardLimit'
op|')'
newline|'\n'
name|'resource'
op|'.'
name|'setrlimit'
op|'('
name|'resource'
op|'.'
name|'RLIMIT_NOFILE'
op|','
op|'('
name|'newSoftLimit'
op|','
name|'currentHardLimit'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|socket
dedent|''
dedent|''
name|'def'
name|'socket'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create and return a new socket object, also tracking it so it can be\n        closed in the test tear down.\n        """'
newline|'\n'
name|'s'
op|'='
name|'socket'
op|'.'
name|'socket'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'openSockets'
op|'.'
name|'append'
op|'('
name|'s'
op|')'
newline|'\n'
name|'return'
name|'s'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_acceptOutOfFiles
dedent|''
name|'def'
name|'test_acceptOutOfFiles'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that the platform accept(2) call fails with either L{EMFILE} or\n        L{ENOBUFS} when there are too many file descriptors open.\n        """'
newline|'\n'
comment|'# Make a server to which to connect'
nl|'\n'
name|'port'
op|'='
name|'self'
op|'.'
name|'socket'
op|'('
op|')'
newline|'\n'
name|'port'
op|'.'
name|'bind'
op|'('
op|'('
string|"'127.0.0.1'"
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'serverPortNumber'
op|'='
name|'port'
op|'.'
name|'getsockname'
op|'('
op|')'
op|'['
number|'1'
op|']'
newline|'\n'
name|'port'
op|'.'
name|'listen'
op|'('
number|'5'
op|')'
newline|'\n'
nl|'\n'
comment|'# Use up all the file descriptors'
nl|'\n'
name|'for'
name|'i'
name|'in'
name|'xrange'
op|'('
name|'self'
op|'.'
name|'socketLimit'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'socket'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'socket'
op|'.'
name|'error'
op|','
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'e'
op|'.'
name|'args'
op|'['
number|'0'
op|']'
name|'in'
op|'('
name|'EMFILE'
op|','
name|'ENOBUFS'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'openSockets'
op|'.'
name|'pop'
op|'('
op|')'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'fail'
op|'('
string|'"Could provoke neither EMFILE nor ENOBUFS from platform."'
op|')'
newline|'\n'
nl|'\n'
comment|'# Make a client to use to connect to the server'
nl|'\n'
dedent|''
name|'client'
op|'='
name|'self'
op|'.'
name|'socket'
op|'('
op|')'
newline|'\n'
name|'client'
op|'.'
name|'setblocking'
op|'('
name|'False'
op|')'
newline|'\n'
nl|'\n'
comment|'# Non-blocking connect is supposed to fail, but this is not true'
nl|'\n'
comment|'# everywhere (e.g. freeBSD)'
nl|'\n'
name|'self'
op|'.'
name|'assertIn'
op|'('
name|'client'
op|'.'
name|'connect_ex'
op|'('
op|'('
string|"'127.0.0.1'"
op|','
name|'serverPortNumber'
op|')'
op|')'
op|','
nl|'\n'
op|'('
number|'0'
op|','
name|'EINPROGRESS'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Make sure that the accept call fails in the way we expect.'
nl|'\n'
name|'exc'
op|'='
name|'self'
op|'.'
name|'assertRaises'
op|'('
name|'socket'
op|'.'
name|'error'
op|','
name|'port'
op|'.'
name|'accept'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertIn'
op|'('
name|'exc'
op|'.'
name|'args'
op|'['
number|'0'
op|']'
op|','
op|'('
name|'EMFILE'
op|','
name|'ENOBUFS'
op|')'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'platform'
op|'.'
name|'getType'
op|'('
op|')'
op|'=='
string|'"win32"'
op|':'
newline|'\n'
indent|'        '
name|'test_acceptOutOfFiles'
op|'.'
name|'skip'
op|'='
op|'('
nl|'\n'
string|'"Windows requires an unacceptably large amount of resources to "'
nl|'\n'
string|'"provoke this behavior in the naive manner."'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|SelectReactorTestCase
dedent|''
dedent|''
name|'class'
name|'SelectReactorTestCase'
op|'('
name|'TestCase'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tests for select-specific failure conditions.\n    """'
newline|'\n'
nl|'\n'
DECL|member|setUp
name|'def'
name|'setUp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'ports'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'messages'
op|'='
op|'['
op|']'
newline|'\n'
name|'log'
op|'.'
name|'addObserver'
op|'('
name|'self'
op|'.'
name|'messages'
op|'.'
name|'append'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tearDown
dedent|''
name|'def'
name|'tearDown'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'log'
op|'.'
name|'removeObserver'
op|'('
name|'self'
op|'.'
name|'messages'
op|'.'
name|'append'
op|')'
newline|'\n'
name|'return'
name|'gatherResults'
op|'('
op|'['
nl|'\n'
name|'maybeDeferred'
op|'('
name|'p'
op|'.'
name|'stopListening'
op|')'
nl|'\n'
name|'for'
name|'p'
name|'in'
name|'self'
op|'.'
name|'ports'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|port
dedent|''
name|'def'
name|'port'
op|'('
name|'self'
op|','
name|'portNumber'
op|','
name|'factory'
op|','
name|'interface'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create, start, and return a new L{Port}, also tracking it so it can\n        be stopped in the test tear down.\n        """'
newline|'\n'
name|'p'
op|'='
name|'Port'
op|'('
name|'portNumber'
op|','
name|'factory'
op|','
name|'interface'
op|'='
name|'interface'
op|')'
newline|'\n'
name|'p'
op|'.'
name|'startListening'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'ports'
op|'.'
name|'append'
op|'('
name|'p'
op|')'
newline|'\n'
name|'return'
name|'p'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_acceptFailureTest
dedent|''
name|'def'
name|'_acceptFailureTest'
op|'('
name|'self'
op|','
name|'socketErrorNumber'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test behavior in the face of an exception from C{accept(2)}.\n\n        On any exception which indicates the platform is unable or unwilling\n        to allocate further resources to us, the existing port should remain\n        listening, a message should be logged, and the exception should not\n        propagate outward from doRead.\n\n        @param socketErrorNumber: The errno to simulate from accept.\n        """'
newline|'\n'
DECL|class|FakeSocket
name|'class'
name|'FakeSocket'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""\n            Pretend to be a socket in an overloaded system.\n            """'
newline|'\n'
DECL|member|accept
name|'def'
name|'accept'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'socket'
op|'.'
name|'error'
op|'('
nl|'\n'
name|'socketErrorNumber'
op|','
name|'os'
op|'.'
name|'strerror'
op|'('
name|'socketErrorNumber'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'factory'
op|'='
name|'ServerFactory'
op|'('
op|')'
newline|'\n'
name|'port'
op|'='
name|'self'
op|'.'
name|'port'
op|'('
number|'0'
op|','
name|'factory'
op|','
name|'interface'
op|'='
string|"'127.0.0.1'"
op|')'
newline|'\n'
name|'originalSocket'
op|'='
name|'port'
op|'.'
name|'socket'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'port'
op|'.'
name|'socket'
op|'='
name|'FakeSocket'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'port'
op|'.'
name|'doRead'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|variable|expectedFormat
name|'expectedFormat'
op|'='
string|'"Could not accept new connection (%s)"'
newline|'\n'
DECL|variable|expectedErrorCode
name|'expectedErrorCode'
op|'='
name|'errno'
op|'.'
name|'errorcode'
op|'['
name|'socketErrorNumber'
op|']'
newline|'\n'
DECL|variable|expectedMessage
name|'expectedMessage'
op|'='
name|'expectedFormat'
op|'%'
op|'('
name|'expectedErrorCode'
op|','
op|')'
newline|'\n'
name|'for'
name|'msg'
name|'in'
name|'self'
op|'.'
name|'messages'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'msg'
op|'.'
name|'get'
op|'('
string|"'message'"
op|')'
op|'=='
op|'('
name|'expectedMessage'
op|','
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'fail'
op|'('
string|'"Log event for failed accept not found in "'
nl|'\n'
string|'"%r"'
op|'%'
op|'('
name|'self'
op|'.'
name|'messages'
op|','
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'port'
op|'.'
name|'socket'
op|'='
name|'originalSocket'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_tooManyFilesFromAccept
dedent|''
dedent|''
name|'def'
name|'test_tooManyFilesFromAccept'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{accept(2)} can fail with C{EMFILE} when there are too many open file\n        descriptors in the process.  Test that this doesn\'t negatively impact\n        any other existing connections.\n\n        C{EMFILE} mainly occurs on Linux when the open file rlimit is\n        encountered.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_acceptFailureTest'
op|'('
name|'EMFILE'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_noBufferSpaceFromAccept
dedent|''
name|'def'
name|'test_noBufferSpaceFromAccept'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Similar to L{test_tooManyFilesFromAccept}, but test the case where\n        C{accept(2)} fails with C{ENOBUFS}.\n\n        This mainly occurs on Windows and FreeBSD, but may be possible on\n        Linux and other platforms as well.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_acceptFailureTest'
op|'('
name|'ENOBUFS'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_connectionAbortedFromAccept
dedent|''
name|'def'
name|'test_connectionAbortedFromAccept'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Similar to L{test_tooManyFilesFromAccept}, but test the case where\n        C{accept(2)} fails with C{ECONNABORTED}.\n\n        It is not clear whether this is actually possible for TCP\n        connections on modern versions of Linux.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_acceptFailureTest'
op|'('
name|'ECONNABORTED'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_noFilesFromAccept
dedent|''
name|'def'
name|'test_noFilesFromAccept'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Similar to L{test_tooManyFilesFromAccept}, but test the case where\n        C{accept(2)} fails with C{ENFILE}.\n\n        This can occur on Linux when the system has exhausted (!) its supply\n        of inodes.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_acceptFailureTest'
op|'('
name|'ENFILE'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'platform'
op|'.'
name|'getType'
op|'('
op|')'
op|'=='
string|"'win32'"
op|':'
newline|'\n'
indent|'        '
name|'test_noFilesFromAccept'
op|'.'
name|'skip'
op|'='
string|'"Windows accept(2) cannot generate ENFILE"'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_noMemoryFromAccept
dedent|''
name|'def'
name|'test_noMemoryFromAccept'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Similar to L{test_tooManyFilesFromAccept}, but test the case where\n        C{accept(2)} fails with C{ENOMEM}.\n\n        On Linux at least, this can sensibly occur, even in a Python program\n        (which eats memory like no ones business), when memory has become\n        fragmented or low memory has been filled (d_alloc calls\n        kmem_cache_alloc calls kmalloc - kmalloc only allocates out of low\n        memory).\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_acceptFailureTest'
op|'('
name|'ENOMEM'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'platform'
op|'.'
name|'getType'
op|'('
op|')'
op|'=='
string|"'win32'"
op|':'
newline|'\n'
indent|'        '
name|'test_noMemoryFromAccept'
op|'.'
name|'skip'
op|'='
string|'"Windows accept(2) cannot generate ENOMEM"'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'interfaces'
op|'.'
name|'IReactorFDSet'
op|'.'
name|'providedBy'
op|'('
name|'reactor'
op|')'
op|':'
newline|'\n'
DECL|variable|skipMsg
indent|'    '
name|'skipMsg'
op|'='
string|"'This test only applies to reactors that implement IReactorFDset'"
newline|'\n'
name|'PlatformAssumptionsTestCase'
op|'.'
name|'skip'
op|'='
name|'skipMsg'
newline|'\n'
name|'SelectReactorTestCase'
op|'.'
name|'skip'
op|'='
name|'skipMsg'
newline|'\n'
nl|'\n'
dedent|''
endmarker|''
end_unit
