begin_unit
comment|'# Copyright (c) 2001-2009 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
string|'"""\nTest case for L{twisted.protocols.loopback}.\n"""'
newline|'\n'
nl|'\n'
name|'from'
name|'zope'
op|'.'
name|'interface'
name|'import'
name|'implements'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
name|'import'
name|'unittest'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'trial'
op|'.'
name|'util'
name|'import'
name|'suppress'
name|'as'
name|'SUPPRESS'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'protocols'
name|'import'
name|'basic'
op|','
name|'loopback'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'defer'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'protocol'
name|'import'
name|'Protocol'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'defer'
name|'import'
name|'Deferred'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
op|'.'
name|'interfaces'
name|'import'
name|'IAddress'
op|','
name|'IPushProducer'
op|','
name|'IPullProducer'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'internet'
name|'import'
name|'reactor'
op|','
name|'interfaces'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|SimpleProtocol
name|'class'
name|'SimpleProtocol'
op|'('
name|'basic'
op|'.'
name|'LineReceiver'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'conn'
op|'='
name|'defer'
op|'.'
name|'Deferred'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'lines'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'connLost'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|connectionMade
dedent|''
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'conn'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
DECL|member|lineReceived
dedent|''
name|'def'
name|'lineReceived'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'lines'
op|'.'
name|'append'
op|'('
name|'line'
op|')'
newline|'\n'
nl|'\n'
DECL|member|connectionLost
dedent|''
name|'def'
name|'connectionLost'
op|'('
name|'self'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'connLost'
op|'.'
name|'append'
op|'('
name|'reason'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DoomProtocol
dedent|''
dedent|''
name|'class'
name|'DoomProtocol'
op|'('
name|'SimpleProtocol'
op|')'
op|':'
newline|'\n'
DECL|variable|i
indent|'    '
name|'i'
op|'='
number|'0'
newline|'\n'
DECL|member|lineReceived
name|'def'
name|'lineReceived'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'i'
op|'+='
number|'1'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'i'
op|'<'
number|'4'
op|':'
newline|'\n'
comment|'# by this point we should have connection closed,'
nl|'\n'
comment|"# but just in case we didn't we won't ever send 'Hello 4'"
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'sendLine'
op|'('
string|'"Hello %d"'
op|'%'
name|'self'
op|'.'
name|'i'
op|')'
newline|'\n'
dedent|''
name|'SimpleProtocol'
op|'.'
name|'lineReceived'
op|'('
name|'self'
op|','
name|'line'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'lines'
op|'['
op|'-'
number|'1'
op|']'
op|'=='
string|'"Hello 3"'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|LoopbackTestCaseMixin
dedent|''
dedent|''
dedent|''
name|'class'
name|'LoopbackTestCaseMixin'
op|':'
newline|'\n'
DECL|member|testRegularFunction
indent|'    '
name|'def'
name|'testRegularFunction'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
name|'SimpleProtocol'
op|'('
op|')'
newline|'\n'
name|'c'
op|'='
name|'SimpleProtocol'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|sendALine
name|'def'
name|'sendALine'
op|'('
name|'result'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'s'
op|'.'
name|'sendLine'
op|'('
string|'"THIS IS LINE ONE!"'
op|')'
newline|'\n'
name|'s'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
dedent|''
name|'s'
op|'.'
name|'conn'
op|'.'
name|'addCallback'
op|'('
name|'sendALine'
op|')'
newline|'\n'
nl|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'c'
op|'.'
name|'lines'
op|','
op|'['
string|'"THIS IS LINE ONE!"'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'s'
op|'.'
name|'connLost'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'c'
op|'.'
name|'connLost'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'='
name|'defer'
op|'.'
name|'maybeDeferred'
op|'('
name|'self'
op|'.'
name|'loopbackFunc'
op|','
name|'s'
op|','
name|'c'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'check'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
DECL|member|testSneakyHiddenDoom
dedent|''
name|'def'
name|'testSneakyHiddenDoom'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
name|'DoomProtocol'
op|'('
op|')'
newline|'\n'
name|'c'
op|'='
name|'DoomProtocol'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|sendALine
name|'def'
name|'sendALine'
op|'('
name|'result'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'s'
op|'.'
name|'sendLine'
op|'('
string|'"DOOM LINE"'
op|')'
newline|'\n'
dedent|''
name|'s'
op|'.'
name|'conn'
op|'.'
name|'addCallback'
op|'('
name|'sendALine'
op|')'
newline|'\n'
nl|'\n'
DECL|function|check
name|'def'
name|'check'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'s'
op|'.'
name|'lines'
op|','
op|'['
string|"'Hello 1'"
op|','
string|"'Hello 2'"
op|','
string|"'Hello 3'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'c'
op|'.'
name|'lines'
op|','
op|'['
string|"'DOOM LINE'"
op|','
string|"'Hello 1'"
op|','
string|"'Hello 2'"
op|','
string|"'Hello 3'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'s'
op|'.'
name|'connLost'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'len'
op|'('
name|'c'
op|'.'
name|'connLost'
op|')'
op|','
number|'1'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'='
name|'defer'
op|'.'
name|'maybeDeferred'
op|'('
name|'self'
op|'.'
name|'loopbackFunc'
op|','
name|'s'
op|','
name|'c'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'check'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|LoopbackTestCase
dedent|''
dedent|''
name|'class'
name|'LoopbackTestCase'
op|'('
name|'LoopbackTestCaseMixin'
op|','
name|'unittest'
op|'.'
name|'TestCase'
op|')'
op|':'
newline|'\n'
DECL|variable|loopbackFunc
indent|'    '
name|'loopbackFunc'
op|'='
name|'staticmethod'
op|'('
name|'loopback'
op|'.'
name|'loopback'
op|')'
newline|'\n'
nl|'\n'
DECL|member|testRegularFunction
name|'def'
name|'testRegularFunction'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Suppress loopback deprecation warning.\n        """'
newline|'\n'
name|'return'
name|'LoopbackTestCaseMixin'
op|'.'
name|'testRegularFunction'
op|'('
name|'self'
op|')'
newline|'\n'
dedent|''
name|'testRegularFunction'
op|'.'
name|'suppress'
op|'='
op|'['
nl|'\n'
name|'SUPPRESS'
op|'('
name|'message'
op|'='
string|'"loopback\\(\\) is deprecated"'
op|','
nl|'\n'
name|'category'
op|'='
name|'DeprecationWarning'
op|')'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|LoopbackAsyncTestCase
dedent|''
name|'class'
name|'LoopbackAsyncTestCase'
op|'('
name|'LoopbackTestCase'
op|')'
op|':'
newline|'\n'
DECL|variable|loopbackFunc
indent|'    '
name|'loopbackFunc'
op|'='
name|'staticmethod'
op|'('
name|'loopback'
op|'.'
name|'loopbackAsync'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_makeConnection
name|'def'
name|'test_makeConnection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that the client and server protocol both have makeConnection\n        invoked on them by loopbackAsync.\n        """'
newline|'\n'
DECL|class|TestProtocol
name|'class'
name|'TestProtocol'
op|'('
name|'Protocol'
op|')'
op|':'
newline|'\n'
DECL|variable|transport
indent|'            '
name|'transport'
op|'='
name|'None'
newline|'\n'
DECL|member|makeConnection
name|'def'
name|'makeConnection'
op|'('
name|'self'
op|','
name|'transport'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'transport'
op|'='
name|'transport'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'server'
op|'='
name|'TestProtocol'
op|'('
op|')'
newline|'\n'
name|'client'
op|'='
name|'TestProtocol'
op|'('
op|')'
newline|'\n'
name|'loopback'
op|'.'
name|'loopbackAsync'
op|'('
name|'server'
op|','
name|'client'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIfEqual'
op|'('
name|'client'
op|'.'
name|'transport'
op|','
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failIfEqual'
op|'('
name|'server'
op|'.'
name|'transport'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_hostpeertest
dedent|''
name|'def'
name|'_hostpeertest'
op|'('
name|'self'
op|','
name|'get'
op|','
name|'testServer'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test one of the permutations of client/server host/peer.\n        """'
newline|'\n'
DECL|class|TestProtocol
name|'class'
name|'TestProtocol'
op|'('
name|'Protocol'
op|')'
op|':'
newline|'\n'
DECL|member|makeConnection
indent|'            '
name|'def'
name|'makeConnection'
op|'('
name|'self'
op|','
name|'transport'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'Protocol'
op|'.'
name|'makeConnection'
op|'('
name|'self'
op|','
name|'transport'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'onConnection'
op|'.'
name|'callback'
op|'('
name|'transport'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'testServer'
op|':'
newline|'\n'
DECL|variable|server
indent|'            '
name|'server'
op|'='
name|'TestProtocol'
op|'('
op|')'
newline|'\n'
name|'d'
op|'='
name|'server'
op|'.'
name|'onConnection'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
DECL|variable|client
name|'client'
op|'='
name|'Protocol'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
DECL|variable|server
indent|'            '
name|'server'
op|'='
name|'Protocol'
op|'('
op|')'
newline|'\n'
DECL|variable|client
name|'client'
op|'='
name|'TestProtocol'
op|'('
op|')'
newline|'\n'
name|'d'
op|'='
name|'client'
op|'.'
name|'onConnection'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'loopback'
op|'.'
name|'loopbackAsync'
op|'('
name|'server'
op|','
name|'client'
op|')'
newline|'\n'
nl|'\n'
DECL|function|connected
name|'def'
name|'connected'
op|'('
name|'transport'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'host'
op|'='
name|'getattr'
op|'('
name|'transport'
op|','
name|'get'
op|')'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'failUnless'
op|'('
name|'IAddress'
op|'.'
name|'providedBy'
op|'('
name|'host'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'connected'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_serverHost
dedent|''
name|'def'
name|'test_serverHost'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that the server gets a transport with a properly functioning\n        implementation of L{ITransport.getHost}.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_hostpeertest'
op|'('
string|'"getHost"'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_serverPeer
dedent|''
name|'def'
name|'test_serverPeer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Like C{test_serverHost} but for L{ITransport.getPeer}\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_hostpeertest'
op|'('
string|'"getPeer"'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_clientHost
dedent|''
name|'def'
name|'test_clientHost'
op|'('
name|'self'
op|','
name|'get'
op|'='
string|'"getHost"'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that the client gets a transport with a properly functioning\n        implementation of L{ITransport.getHost}.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_hostpeertest'
op|'('
string|'"getHost"'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_clientPeer
dedent|''
name|'def'
name|'test_clientPeer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Like C{test_clientHost} but for L{ITransport.getPeer}.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_hostpeertest'
op|'('
string|'"getPeer"'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_greetingtest
dedent|''
name|'def'
name|'_greetingtest'
op|'('
name|'self'
op|','
name|'write'
op|','
name|'testServer'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test one of the permutations of write/writeSequence client/server.\n        """'
newline|'\n'
DECL|class|GreeteeProtocol
name|'class'
name|'GreeteeProtocol'
op|'('
name|'Protocol'
op|')'
op|':'
newline|'\n'
DECL|variable|bytes
indent|'            '
name|'bytes'
op|'='
string|'""'
newline|'\n'
DECL|member|dataReceived
name|'def'
name|'dataReceived'
op|'('
name|'self'
op|','
name|'bytes'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'bytes'
op|'+='
name|'bytes'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'bytes'
op|'=='
string|'"bytes"'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'received'
op|'.'
name|'callback'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
DECL|class|GreeterProtocol
dedent|''
dedent|''
dedent|''
name|'class'
name|'GreeterProtocol'
op|'('
name|'Protocol'
op|')'
op|':'
newline|'\n'
DECL|member|connectionMade
indent|'            '
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'getattr'
op|'('
name|'self'
op|'.'
name|'transport'
op|','
name|'write'
op|')'
op|'('
string|'"bytes"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'testServer'
op|':'
newline|'\n'
DECL|variable|server
indent|'            '
name|'server'
op|'='
name|'GreeterProtocol'
op|'('
op|')'
newline|'\n'
DECL|variable|client
name|'client'
op|'='
name|'GreeteeProtocol'
op|'('
op|')'
newline|'\n'
name|'d'
op|'='
name|'client'
op|'.'
name|'received'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
DECL|variable|server
indent|'            '
name|'server'
op|'='
name|'GreeteeProtocol'
op|'('
op|')'
newline|'\n'
name|'d'
op|'='
name|'server'
op|'.'
name|'received'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
DECL|variable|client
name|'client'
op|'='
name|'GreeterProtocol'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'loopback'
op|'.'
name|'loopbackAsync'
op|'('
name|'server'
op|','
name|'client'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_clientGreeting
dedent|''
name|'def'
name|'test_clientGreeting'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that on a connection where the client speaks first, the server\n        receives the bytes sent by the client.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_greetingtest'
op|'('
string|'"write"'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_clientGreetingSequence
dedent|''
name|'def'
name|'test_clientGreetingSequence'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Like C{test_clientGreeting}, but use C{writeSequence} instead of\n        C{write} to issue the greeting.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_greetingtest'
op|'('
string|'"writeSequence"'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_serverGreeting
dedent|''
name|'def'
name|'test_serverGreeting'
op|'('
name|'self'
op|','
name|'write'
op|'='
string|'"write"'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test that on a connection where the server speaks first, the client\n        receives the bytes sent by the server.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_greetingtest'
op|'('
string|'"write"'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_serverGreetingSequence
dedent|''
name|'def'
name|'test_serverGreetingSequence'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Like C{test_serverGreeting}, but use C{writeSequence} instead of\n        C{write} to issue the greeting.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_greetingtest'
op|'('
string|'"writeSequence"'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_producertest
dedent|''
name|'def'
name|'_producertest'
op|'('
name|'self'
op|','
name|'producerClass'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'toProduce'
op|'='
name|'map'
op|'('
name|'str'
op|','
name|'range'
op|'('
number|'0'
op|','
number|'10'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|class|ProducingProtocol
name|'class'
name|'ProducingProtocol'
op|'('
name|'Protocol'
op|')'
op|':'
newline|'\n'
DECL|member|connectionMade
indent|'            '
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'producer'
op|'='
name|'producerClass'
op|'('
name|'list'
op|'('
name|'toProduce'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'producer'
op|'.'
name|'start'
op|'('
name|'self'
op|'.'
name|'transport'
op|')'
newline|'\n'
nl|'\n'
DECL|class|ReceivingProtocol
dedent|''
dedent|''
name|'class'
name|'ReceivingProtocol'
op|'('
name|'Protocol'
op|')'
op|':'
newline|'\n'
DECL|variable|bytes
indent|'            '
name|'bytes'
op|'='
string|'""'
newline|'\n'
DECL|member|dataReceived
name|'def'
name|'dataReceived'
op|'('
name|'self'
op|','
name|'bytes'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'bytes'
op|'+='
name|'bytes'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'bytes'
op|'=='
string|"''"
op|'.'
name|'join'
op|'('
name|'toProduce'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'received'
op|'.'
name|'callback'
op|'('
op|'('
name|'client'
op|','
name|'server'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'server'
op|'='
name|'ProducingProtocol'
op|'('
op|')'
newline|'\n'
name|'client'
op|'='
name|'ReceivingProtocol'
op|'('
op|')'
newline|'\n'
name|'client'
op|'.'
name|'received'
op|'='
name|'Deferred'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'loopback'
op|'.'
name|'loopbackAsync'
op|'('
name|'server'
op|','
name|'client'
op|')'
newline|'\n'
name|'return'
name|'client'
op|'.'
name|'received'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_pushProducer
dedent|''
name|'def'
name|'test_pushProducer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test a push producer registered against a loopback transport.\n        """'
newline|'\n'
DECL|class|PushProducer
name|'class'
name|'PushProducer'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'implements'
op|'('
name|'IPushProducer'
op|')'
newline|'\n'
DECL|variable|resumed
name|'resumed'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'toProduce'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'toProduce'
op|'='
name|'toProduce'
newline|'\n'
nl|'\n'
DECL|member|resumeProducing
dedent|''
name|'def'
name|'resumeProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'resumed'
op|'='
name|'True'
newline|'\n'
nl|'\n'
DECL|member|start
dedent|''
name|'def'
name|'start'
op|'('
name|'self'
op|','
name|'consumer'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'consumer'
op|'='
name|'consumer'
newline|'\n'
name|'consumer'
op|'.'
name|'registerProducer'
op|'('
name|'self'
op|','
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_produceAndSchedule'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_produceAndSchedule
dedent|''
name|'def'
name|'_produceAndSchedule'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'toProduce'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'consumer'
op|'.'
name|'write'
op|'('
name|'self'
op|'.'
name|'toProduce'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
op|')'
newline|'\n'
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'self'
op|'.'
name|'_produceAndSchedule'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'consumer'
op|'.'
name|'unregisterProducer'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'d'
op|'='
name|'self'
op|'.'
name|'_producertest'
op|'('
name|'PushProducer'
op|')'
newline|'\n'
nl|'\n'
DECL|function|finished
name|'def'
name|'finished'
op|'('
op|'('
name|'client'
op|','
name|'server'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'failIf'
op|'('
nl|'\n'
name|'server'
op|'.'
name|'producer'
op|'.'
name|'resumed'
op|','
nl|'\n'
string|'"Streaming producer should not have been resumed."'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'finished'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_pullProducer
dedent|''
name|'def'
name|'test_pullProducer'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Test a pull producer registered against a loopback transport.\n        """'
newline|'\n'
DECL|class|PullProducer
name|'class'
name|'PullProducer'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'implements'
op|'('
name|'IPullProducer'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'toProduce'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'toProduce'
op|'='
name|'toProduce'
newline|'\n'
nl|'\n'
DECL|member|start
dedent|''
name|'def'
name|'start'
op|'('
name|'self'
op|','
name|'consumer'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'consumer'
op|'='
name|'consumer'
newline|'\n'
name|'self'
op|'.'
name|'consumer'
op|'.'
name|'registerProducer'
op|'('
name|'self'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
DECL|member|resumeProducing
dedent|''
name|'def'
name|'resumeProducing'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'consumer'
op|'.'
name|'write'
op|'('
name|'self'
op|'.'
name|'toProduce'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'toProduce'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'consumer'
op|'.'
name|'unregisterProducer'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'_producertest'
op|'('
name|'PullProducer'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_writeNotReentrant
dedent|''
name|'def'
name|'test_writeNotReentrant'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{loopback.loopbackAsync} does not call a protocol\'s C{dataReceived}\n        method while that protocol\'s transport\'s C{write} method is higher up\n        on the stack.\n        """'
newline|'\n'
DECL|class|Server
name|'class'
name|'Server'
op|'('
name|'Protocol'
op|')'
op|':'
newline|'\n'
DECL|member|dataReceived
indent|'            '
name|'def'
name|'dataReceived'
op|'('
name|'self'
op|','
name|'bytes'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
string|'"bytes"'
op|')'
newline|'\n'
nl|'\n'
DECL|class|Client
dedent|''
dedent|''
name|'class'
name|'Client'
op|'('
name|'Protocol'
op|')'
op|':'
newline|'\n'
DECL|variable|ready
indent|'            '
name|'ready'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|member|connectionMade
name|'def'
name|'connectionMade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'reactor'
op|'.'
name|'callLater'
op|'('
number|'0'
op|','
name|'self'
op|'.'
name|'go'
op|')'
newline|'\n'
nl|'\n'
DECL|member|go
dedent|''
name|'def'
name|'go'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'ready'
op|'='
name|'True'
newline|'\n'
nl|'\n'
DECL|member|dataReceived
dedent|''
name|'def'
name|'dataReceived'
op|'('
name|'self'
op|','
name|'bytes'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'wasReady'
op|'='
name|'self'
op|'.'
name|'ready'
newline|'\n'
name|'self'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'server'
op|'='
name|'Server'
op|'('
op|')'
newline|'\n'
name|'client'
op|'='
name|'Client'
op|'('
op|')'
newline|'\n'
name|'d'
op|'='
name|'loopback'
op|'.'
name|'loopbackAsync'
op|'('
name|'client'
op|','
name|'server'
op|')'
newline|'\n'
DECL|function|cbFinished
name|'def'
name|'cbFinished'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertTrue'
op|'('
name|'client'
op|'.'
name|'wasReady'
op|')'
newline|'\n'
dedent|''
name|'d'
op|'.'
name|'addCallback'
op|'('
name|'cbFinished'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_pumpPolicy
dedent|''
name|'def'
name|'test_pumpPolicy'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        The callable passed as the value for the C{pumpPolicy} parameter to\n        L{loopbackAsync} is called with a L{_LoopbackQueue} of pending bytes\n        and a protocol to which they should be delivered.\n        """'
newline|'\n'
name|'pumpCalls'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|dummyPolicy
name|'def'
name|'dummyPolicy'
op|'('
name|'queue'
op|','
name|'target'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'bytes'
op|'='
op|'['
op|']'
newline|'\n'
name|'while'
name|'queue'
op|':'
newline|'\n'
indent|'                '
name|'bytes'
op|'.'
name|'append'
op|'('
name|'queue'
op|'.'
name|'get'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'pumpCalls'
op|'.'
name|'append'
op|'('
op|'('
name|'target'
op|','
name|'bytes'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'client'
op|'='
name|'Protocol'
op|'('
op|')'
newline|'\n'
name|'server'
op|'='
name|'Protocol'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'finished'
op|'='
name|'loopback'
op|'.'
name|'loopbackAsync'
op|'('
name|'server'
op|','
name|'client'
op|','
name|'dummyPolicy'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'pumpCalls'
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'client'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'client'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
string|'"bar"'
op|')'
newline|'\n'
name|'server'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
string|'"baz"'
op|')'
newline|'\n'
name|'server'
op|'.'
name|'transport'
op|'.'
name|'write'
op|'('
string|'"quux"'
op|')'
newline|'\n'
name|'server'
op|'.'
name|'transport'
op|'.'
name|'loseConnection'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|cbComplete
name|'def'
name|'cbComplete'
op|'('
name|'ignored'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'assertEquals'
op|'('
nl|'\n'
name|'pumpCalls'
op|','
nl|'\n'
comment|'# The order here is somewhat arbitrary.  The implementation'
nl|'\n'
comment|'# happens to always deliver data to the client first.'
nl|'\n'
op|'['
op|'('
name|'client'
op|','
op|'['
string|'"baz"'
op|','
string|'"quux"'
op|','
name|'None'
op|']'
op|')'
op|','
nl|'\n'
op|'('
name|'server'
op|','
op|'['
string|'"foo"'
op|','
string|'"bar"'
op|']'
op|')'
op|']'
op|')'
newline|'\n'
dedent|''
name|'finished'
op|'.'
name|'addCallback'
op|'('
name|'cbComplete'
op|')'
newline|'\n'
name|'return'
name|'finished'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_identityPumpPolicy
dedent|''
name|'def'
name|'test_identityPumpPolicy'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{identityPumpPolicy} is a pump policy which calls the target\'s\n        C{dataReceived} method one for each string in the queue passed to it.\n        """'
newline|'\n'
name|'bytes'
op|'='
op|'['
op|']'
newline|'\n'
name|'client'
op|'='
name|'Protocol'
op|'('
op|')'
newline|'\n'
name|'client'
op|'.'
name|'dataReceived'
op|'='
name|'bytes'
op|'.'
name|'append'
newline|'\n'
name|'queue'
op|'='
name|'loopback'
op|'.'
name|'_LoopbackQueue'
op|'('
op|')'
newline|'\n'
name|'queue'
op|'.'
name|'put'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'queue'
op|'.'
name|'put'
op|'('
string|'"bar"'
op|')'
newline|'\n'
name|'queue'
op|'.'
name|'put'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'loopback'
op|'.'
name|'identityPumpPolicy'
op|'('
name|'queue'
op|','
name|'client'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'bytes'
op|','
op|'['
string|'"foo"'
op|','
string|'"bar"'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|test_collapsingPumpPolicy
dedent|''
name|'def'
name|'test_collapsingPumpPolicy'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        L{collapsingPumpPolicy} is a pump policy which calls the target\'s\n        C{dataReceived} only once with all of the strings in the queue passed\n        to it joined together.\n        """'
newline|'\n'
name|'bytes'
op|'='
op|'['
op|']'
newline|'\n'
name|'client'
op|'='
name|'Protocol'
op|'('
op|')'
newline|'\n'
name|'client'
op|'.'
name|'dataReceived'
op|'='
name|'bytes'
op|'.'
name|'append'
newline|'\n'
name|'queue'
op|'='
name|'loopback'
op|'.'
name|'_LoopbackQueue'
op|'('
op|')'
newline|'\n'
name|'queue'
op|'.'
name|'put'
op|'('
string|'"foo"'
op|')'
newline|'\n'
name|'queue'
op|'.'
name|'put'
op|'('
string|'"bar"'
op|')'
newline|'\n'
name|'queue'
op|'.'
name|'put'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'loopback'
op|'.'
name|'collapsingPumpPolicy'
op|'('
name|'queue'
op|','
name|'client'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'assertEquals'
op|'('
name|'bytes'
op|','
op|'['
string|'"foobar"'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|LoopbackTCPTestCase
dedent|''
dedent|''
name|'class'
name|'LoopbackTCPTestCase'
op|'('
name|'LoopbackTestCase'
op|')'
op|':'
newline|'\n'
DECL|variable|loopbackFunc
indent|'    '
name|'loopbackFunc'
op|'='
name|'staticmethod'
op|'('
name|'loopback'
op|'.'
name|'loopbackTCP'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|LoopbackUNIXTestCase
dedent|''
name|'class'
name|'LoopbackUNIXTestCase'
op|'('
name|'LoopbackTestCase'
op|')'
op|':'
newline|'\n'
DECL|variable|loopbackFunc
indent|'    '
name|'loopbackFunc'
op|'='
name|'staticmethod'
op|'('
name|'loopback'
op|'.'
name|'loopbackUNIX'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'interfaces'
op|'.'
name|'IReactorUNIX'
op|'('
name|'reactor'
op|','
name|'None'
op|')'
name|'is'
name|'None'
op|':'
newline|'\n'
DECL|variable|skip
indent|'        '
name|'skip'
op|'='
string|'"Current reactor does not support UNIX sockets"'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
