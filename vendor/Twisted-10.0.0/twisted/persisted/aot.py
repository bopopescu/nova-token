begin_unit
comment|'# -*- test-case-name: twisted.test.test_persisted -*-'
nl|'\n'
nl|'\n'
comment|'# Copyright (c) 2001-2004 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
string|'"""\nAOT: Abstract Object Trees\nThe source-code-marshallin\'est abstract-object-serializin\'est persister\nthis side of Marmalade!\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'types'
op|','
name|'new'
op|','
name|'string'
op|','
name|'copy_reg'
op|','
name|'tokenize'
op|','
name|'re'
newline|'\n'
nl|'\n'
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'reflect'
op|','
name|'log'
newline|'\n'
name|'from'
name|'twisted'
op|'.'
name|'persisted'
name|'import'
name|'crefutil'
newline|'\n'
nl|'\n'
comment|'###########################'
nl|'\n'
comment|'# Abstract Object Classes #'
nl|'\n'
comment|'###########################'
nl|'\n'
nl|'\n'
comment|'#"\\0" in a getSource means "insert variable-width indention here".'
nl|'\n'
comment|"#see `indentify'."
nl|'\n'
nl|'\n'
DECL|class|Named
name|'class'
name|'Named'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'name'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'name'
op|'='
name|'name'
newline|'\n'
nl|'\n'
DECL|class|Class
dedent|''
dedent|''
name|'class'
name|'Class'
op|'('
name|'Named'
op|')'
op|':'
newline|'\n'
DECL|member|getSource
indent|'    '
name|'def'
name|'getSource'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|'"Class(%r)"'
op|'%'
name|'self'
op|'.'
name|'name'
newline|'\n'
nl|'\n'
DECL|class|Function
dedent|''
dedent|''
name|'class'
name|'Function'
op|'('
name|'Named'
op|')'
op|':'
newline|'\n'
DECL|member|getSource
indent|'    '
name|'def'
name|'getSource'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|'"Function(%r)"'
op|'%'
name|'self'
op|'.'
name|'name'
newline|'\n'
nl|'\n'
DECL|class|Module
dedent|''
dedent|''
name|'class'
name|'Module'
op|'('
name|'Named'
op|')'
op|':'
newline|'\n'
DECL|member|getSource
indent|'    '
name|'def'
name|'getSource'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|'"Module(%r)"'
op|'%'
name|'self'
op|'.'
name|'name'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|InstanceMethod
dedent|''
dedent|''
name|'class'
name|'InstanceMethod'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'name'
op|','
name|'klass'
op|','
name|'inst'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
op|'('
name|'isinstance'
op|'('
name|'inst'
op|','
name|'Ref'
op|')'
name|'or'
name|'isinstance'
op|'('
name|'inst'
op|','
name|'Instance'
op|')'
name|'or'
name|'isinstance'
op|'('
name|'inst'
op|','
name|'Deref'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'TypeError'
op|'('
string|'"%s isn\'t an Instance, Ref, or Deref!"'
op|'%'
name|'inst'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'name'
op|'='
name|'name'
newline|'\n'
name|'self'
op|'.'
name|'klass'
op|'='
name|'klass'
newline|'\n'
name|'self'
op|'.'
name|'instance'
op|'='
name|'inst'
newline|'\n'
nl|'\n'
DECL|member|getSource
dedent|''
name|'def'
name|'getSource'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|'"InstanceMethod(%r, %r, \\n\\0%s)"'
op|'%'
op|'('
name|'self'
op|'.'
name|'name'
op|','
name|'self'
op|'.'
name|'klass'
op|','
name|'prettify'
op|'('
name|'self'
op|'.'
name|'instance'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|_NoStateObj
dedent|''
dedent|''
name|'class'
name|'_NoStateObj'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
DECL|variable|NoStateObj
dedent|''
name|'NoStateObj'
op|'='
name|'_NoStateObj'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|variable|_SIMPLE_BUILTINS
name|'_SIMPLE_BUILTINS'
op|'='
op|'['
nl|'\n'
name|'types'
op|'.'
name|'StringType'
op|','
name|'types'
op|'.'
name|'UnicodeType'
op|','
name|'types'
op|'.'
name|'IntType'
op|','
name|'types'
op|'.'
name|'FloatType'
op|','
nl|'\n'
name|'types'
op|'.'
name|'ComplexType'
op|','
name|'types'
op|'.'
name|'LongType'
op|','
name|'types'
op|'.'
name|'NoneType'
op|','
name|'types'
op|'.'
name|'SliceType'
op|','
nl|'\n'
name|'types'
op|'.'
name|'EllipsisType'
op|']'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'_SIMPLE_BUILTINS'
op|'.'
name|'append'
op|'('
name|'types'
op|'.'
name|'BooleanType'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
nl|'\n'
DECL|class|Instance
dedent|''
name|'class'
name|'Instance'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'className'
op|','
name|'__stateObj__'
op|'='
name|'NoStateObj'
op|','
op|'**'
name|'state'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'className'
op|','
name|'types'
op|'.'
name|'StringType'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'TypeError'
op|'('
string|'"%s isn\'t a string!"'
op|'%'
name|'className'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'klass'
op|'='
name|'className'
newline|'\n'
name|'if'
name|'__stateObj__'
name|'is'
name|'not'
name|'NoStateObj'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'state'
op|'='
name|'__stateObj__'
newline|'\n'
name|'self'
op|'.'
name|'stateIsDict'
op|'='
number|'0'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'state'
op|'='
name|'state'
newline|'\n'
name|'self'
op|'.'
name|'stateIsDict'
op|'='
number|'1'
newline|'\n'
nl|'\n'
DECL|member|getSource
dedent|''
dedent|''
name|'def'
name|'getSource'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'#XXX make state be foo=bar instead of a dict.'
nl|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'stateIsDict'
op|':'
newline|'\n'
indent|'            '
name|'stateDict'
op|'='
name|'self'
op|'.'
name|'state'
newline|'\n'
dedent|''
name|'elif'
name|'isinstance'
op|'('
name|'self'
op|'.'
name|'state'
op|','
name|'Ref'
op|')'
name|'and'
name|'isinstance'
op|'('
name|'self'
op|'.'
name|'state'
op|'.'
name|'obj'
op|','
name|'types'
op|'.'
name|'DictType'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'stateDict'
op|'='
name|'self'
op|'.'
name|'state'
op|'.'
name|'obj'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'stateDict'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'if'
name|'stateDict'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'return'
string|'"Instance(%r, %s)"'
op|'%'
op|'('
name|'self'
op|'.'
name|'klass'
op|','
name|'dictToKW'
op|'('
name|'stateDict'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'NonFormattableDict'
op|':'
newline|'\n'
indent|'                '
name|'return'
string|'"Instance(%r, %s)"'
op|'%'
op|'('
name|'self'
op|'.'
name|'klass'
op|','
name|'prettify'
op|'('
name|'stateDict'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
string|'"Instance(%r, %s)"'
op|'%'
op|'('
name|'self'
op|'.'
name|'klass'
op|','
name|'prettify'
op|'('
name|'self'
op|'.'
name|'state'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|class|Ref
dedent|''
dedent|''
name|'class'
name|'Ref'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|')'
op|':'
newline|'\n'
comment|'#blargh, lame.'
nl|'\n'
indent|'        '
name|'if'
name|'len'
op|'('
name|'args'
op|')'
op|'=='
number|'2'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'refnum'
op|'='
name|'args'
op|'['
number|'0'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'obj'
op|'='
name|'args'
op|'['
number|'1'
op|']'
newline|'\n'
dedent|''
name|'elif'
name|'not'
name|'args'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'refnum'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'obj'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|setRef
dedent|''
dedent|''
name|'def'
name|'setRef'
op|'('
name|'self'
op|','
name|'num'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'refnum'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|'"Error setting id %s, I already have %s"'
op|'%'
op|'('
name|'num'
op|','
name|'self'
op|'.'
name|'refnum'
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'refnum'
op|'='
name|'num'
newline|'\n'
nl|'\n'
DECL|member|setObj
dedent|''
name|'def'
name|'setObj'
op|'('
name|'self'
op|','
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'obj'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|'"Error setting obj %s, I already have %s"'
op|'%'
op|'('
name|'obj'
op|','
name|'self'
op|'.'
name|'obj'
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'obj'
op|'='
name|'obj'
newline|'\n'
nl|'\n'
DECL|member|getSource
dedent|''
name|'def'
name|'getSource'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'obj'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'RuntimeError'
op|'('
string|'"Don\'t try to display me before setting an object on me!"'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'refnum'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|'"Ref(%d, \\n\\0%s)"'
op|'%'
op|'('
name|'self'
op|'.'
name|'refnum'
op|','
name|'prettify'
op|'('
name|'self'
op|'.'
name|'obj'
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'prettify'
op|'('
name|'self'
op|'.'
name|'obj'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Deref
dedent|''
dedent|''
name|'class'
name|'Deref'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'num'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'refnum'
op|'='
name|'num'
newline|'\n'
nl|'\n'
DECL|member|getSource
dedent|''
name|'def'
name|'getSource'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|'"Deref(%d)"'
op|'%'
name|'self'
op|'.'
name|'refnum'
newline|'\n'
nl|'\n'
DECL|variable|__repr__
dedent|''
name|'__repr__'
op|'='
name|'getSource'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Copyreg
dedent|''
name|'class'
name|'Copyreg'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'loadfunc'
op|','
name|'state'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'loadfunc'
op|'='
name|'loadfunc'
newline|'\n'
name|'self'
op|'.'
name|'state'
op|'='
name|'state'
newline|'\n'
nl|'\n'
DECL|member|getSource
dedent|''
name|'def'
name|'getSource'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|'"Copyreg(%r, %s)"'
op|'%'
op|'('
name|'self'
op|'.'
name|'loadfunc'
op|','
name|'prettify'
op|'('
name|'self'
op|'.'
name|'state'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
comment|'###############'
nl|'\n'
comment|'# Marshalling #'
nl|'\n'
comment|'###############'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|getSource
dedent|''
dedent|''
name|'def'
name|'getSource'
op|'('
name|'ao'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Pass me an AO, I\'ll return a nicely-formatted source representation."""'
newline|'\n'
name|'return'
name|'indentify'
op|'('
string|'"app = "'
op|'+'
name|'prettify'
op|'('
name|'ao'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|NonFormattableDict
dedent|''
name|'class'
name|'NonFormattableDict'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""A dictionary was not formattable.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|r
dedent|''
name|'r'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"'[a-zA-Z_][a-zA-Z0-9_]*$'"
op|')'
newline|'\n'
nl|'\n'
DECL|function|dictToKW
name|'def'
name|'dictToKW'
op|'('
name|'d'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'out'
op|'='
op|'['
op|']'
newline|'\n'
name|'items'
op|'='
name|'d'
op|'.'
name|'items'
op|'('
op|')'
newline|'\n'
name|'items'
op|'.'
name|'sort'
op|'('
op|')'
newline|'\n'
name|'for'
name|'k'
op|','
name|'v'
name|'in'
name|'items'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'k'
op|','
name|'types'
op|'.'
name|'StringType'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'NonFormattableDict'
op|'('
string|'"%r ain\'t a string"'
op|'%'
name|'k'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'r'
op|'.'
name|'match'
op|'('
name|'k'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'NonFormattableDict'
op|'('
string|'"%r ain\'t an identifier"'
op|'%'
name|'k'
op|')'
newline|'\n'
dedent|''
name|'out'
op|'.'
name|'append'
op|'('
nl|'\n'
string|'"\\n\\0%s=%s,"'
op|'%'
op|'('
name|'k'
op|','
name|'prettify'
op|'('
name|'v'
op|')'
op|')'
nl|'\n'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'string'
op|'.'
name|'join'
op|'('
name|'out'
op|','
string|"''"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|prettify
dedent|''
name|'def'
name|'prettify'
op|'('
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'hasattr'
op|'('
name|'obj'
op|','
string|"'getSource'"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'obj'
op|'.'
name|'getSource'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'#basic type'
nl|'\n'
indent|'        '
name|'t'
op|'='
name|'type'
op|'('
name|'obj'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'t'
name|'in'
name|'_SIMPLE_BUILTINS'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'repr'
op|'('
name|'obj'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'t'
name|'is'
name|'types'
op|'.'
name|'DictType'
op|':'
newline|'\n'
indent|'            '
name|'out'
op|'='
op|'['
string|"'{'"
op|']'
newline|'\n'
name|'for'
name|'k'
op|','
name|'v'
name|'in'
name|'obj'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'out'
op|'.'
name|'append'
op|'('
string|"'\\n\\0%s: %s,'"
op|'%'
op|'('
name|'prettify'
op|'('
name|'k'
op|')'
op|','
name|'prettify'
op|'('
name|'v'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'out'
op|'.'
name|'append'
op|'('
name|'len'
op|'('
name|'obj'
op|')'
name|'and'
string|"'\\n\\0}'"
name|'or'
string|"'}'"
op|')'
newline|'\n'
name|'return'
name|'string'
op|'.'
name|'join'
op|'('
name|'out'
op|','
string|"''"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'t'
name|'is'
name|'types'
op|'.'
name|'ListType'
op|':'
newline|'\n'
indent|'            '
name|'out'
op|'='
op|'['
string|'"["'
op|']'
newline|'\n'
name|'for'
name|'x'
name|'in'
name|'obj'
op|':'
newline|'\n'
indent|'                '
name|'out'
op|'.'
name|'append'
op|'('
string|"'\\n\\0%s,'"
op|'%'
name|'prettify'
op|'('
name|'x'
op|')'
op|')'
newline|'\n'
dedent|''
name|'out'
op|'.'
name|'append'
op|'('
name|'len'
op|'('
name|'obj'
op|')'
name|'and'
string|"'\\n\\0]'"
name|'or'
string|"']'"
op|')'
newline|'\n'
name|'return'
name|'string'
op|'.'
name|'join'
op|'('
name|'out'
op|','
string|"''"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'t'
name|'is'
name|'types'
op|'.'
name|'TupleType'
op|':'
newline|'\n'
indent|'            '
name|'out'
op|'='
op|'['
string|'"("'
op|']'
newline|'\n'
name|'for'
name|'x'
name|'in'
name|'obj'
op|':'
newline|'\n'
indent|'                '
name|'out'
op|'.'
name|'append'
op|'('
string|"'\\n\\0%s,'"
op|'%'
name|'prettify'
op|'('
name|'x'
op|')'
op|')'
newline|'\n'
dedent|''
name|'out'
op|'.'
name|'append'
op|'('
name|'len'
op|'('
name|'obj'
op|')'
name|'and'
string|"'\\n\\0)'"
name|'or'
string|"')'"
op|')'
newline|'\n'
name|'return'
name|'string'
op|'.'
name|'join'
op|'('
name|'out'
op|','
string|"''"
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'TypeError'
op|'('
string|'"Unsupported type %s when trying to prettify %s."'
op|'%'
op|'('
name|'t'
op|','
name|'obj'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|indentify
dedent|''
dedent|''
dedent|''
name|'def'
name|'indentify'
op|'('
name|'s'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'out'
op|'='
op|'['
op|']'
newline|'\n'
name|'stack'
op|'='
op|'['
op|']'
newline|'\n'
DECL|function|eater
name|'def'
name|'eater'
op|'('
name|'type'
op|','
name|'val'
op|','
name|'r'
op|','
name|'c'
op|','
name|'l'
op|','
name|'out'
op|'='
name|'out'
op|','
name|'stack'
op|'='
name|'stack'
op|')'
op|':'
newline|'\n'
comment|'#import sys'
nl|'\n'
comment|'#sys.stdout.write(val)'
nl|'\n'
indent|'        '
name|'if'
name|'val'
name|'in'
op|'['
string|"'['"
op|','
string|"'('"
op|','
string|"'{'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'stack'
op|'.'
name|'append'
op|'('
name|'val'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'val'
name|'in'
op|'['
string|"']'"
op|','
string|"')'"
op|','
string|"'}'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'stack'
op|'.'
name|'pop'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'val'
op|'=='
string|"'\\0'"
op|':'
newline|'\n'
indent|'            '
name|'out'
op|'.'
name|'append'
op|'('
string|"'  '"
op|'*'
name|'len'
op|'('
name|'stack'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'out'
op|'.'
name|'append'
op|'('
name|'val'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'l'
op|'='
op|'['
string|"''"
op|','
name|'s'
op|']'
newline|'\n'
name|'tokenize'
op|'.'
name|'tokenize'
op|'('
name|'l'
op|'.'
name|'pop'
op|','
name|'eater'
op|')'
newline|'\n'
name|'return'
name|'string'
op|'.'
name|'join'
op|'('
name|'out'
op|','
string|"''"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
comment|'###########'
nl|'\n'
comment|'# Unjelly #'
nl|'\n'
comment|'###########'
nl|'\n'
nl|'\n'
DECL|function|unjellyFromAOT
dedent|''
name|'def'
name|'unjellyFromAOT'
op|'('
name|'aot'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Pass me an Abstract Object Tree, and I\'ll unjelly it for you.\n    """'
newline|'\n'
name|'return'
name|'AOTUnjellier'
op|'('
op|')'
op|'.'
name|'unjelly'
op|'('
name|'aot'
op|')'
newline|'\n'
nl|'\n'
DECL|function|unjellyFromSource
dedent|''
name|'def'
name|'unjellyFromSource'
op|'('
name|'stringOrFile'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Pass me a string of code or a filename that defines an \'app\' variable (in\n    terms of Abstract Objects!), and I\'ll execute it and unjelly the resulting\n    AOT for you, returning a newly unpersisted Application object!\n    """'
newline|'\n'
nl|'\n'
name|'ns'
op|'='
op|'{'
string|'"Instance"'
op|':'
name|'Instance'
op|','
nl|'\n'
string|'"InstanceMethod"'
op|':'
name|'InstanceMethod'
op|','
nl|'\n'
string|'"Class"'
op|':'
name|'Class'
op|','
nl|'\n'
string|'"Function"'
op|':'
name|'Function'
op|','
nl|'\n'
string|'"Module"'
op|':'
name|'Module'
op|','
nl|'\n'
string|'"Ref"'
op|':'
name|'Ref'
op|','
nl|'\n'
string|'"Deref"'
op|':'
name|'Deref'
op|','
nl|'\n'
string|'"Copyreg"'
op|':'
name|'Copyreg'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
name|'if'
name|'hasattr'
op|'('
name|'stringOrFile'
op|','
string|'"read"'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'exec'
name|'stringOrFile'
op|'.'
name|'read'
op|'('
op|')'
name|'in'
name|'ns'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'exec'
name|'stringOrFile'
name|'in'
name|'ns'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'ns'
op|'.'
name|'has_key'
op|'('
string|"'app'"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'unjellyFromAOT'
op|'('
name|'ns'
op|'['
string|"'app'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'ValueError'
op|'('
string|'"%s needs to define an \'app\', it didn\'t!"'
op|'%'
name|'stringOrFile'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|AOTUnjellier
dedent|''
dedent|''
name|'class'
name|'AOTUnjellier'
op|':'
newline|'\n'
indent|'    '
string|'"""I handle the unjellying of an Abstract Object Tree.\n    See AOTUnjellier.unjellyAO\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'references'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'stack'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'afterUnjelly'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
comment|'##'
nl|'\n'
comment|'# unjelly helpers (copied pretty much directly from (now deleted) marmalade)'
nl|'\n'
comment|'##'
nl|'\n'
DECL|member|unjellyLater
dedent|''
name|'def'
name|'unjellyLater'
op|'('
name|'self'
op|','
name|'node'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Unjelly a node, later.\n        """'
newline|'\n'
name|'d'
op|'='
name|'crefutil'
op|'.'
name|'_Defer'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'unjellyInto'
op|'('
name|'d'
op|','
number|'0'
op|','
name|'node'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
DECL|member|unjellyInto
dedent|''
name|'def'
name|'unjellyInto'
op|'('
name|'self'
op|','
name|'obj'
op|','
name|'loc'
op|','
name|'ao'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Utility method for unjellying one object into another.\n        This automates the handling of backreferences.\n        """'
newline|'\n'
name|'o'
op|'='
name|'self'
op|'.'
name|'unjellyAO'
op|'('
name|'ao'
op|')'
newline|'\n'
name|'obj'
op|'['
name|'loc'
op|']'
op|'='
name|'o'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'o'
op|','
name|'crefutil'
op|'.'
name|'NotKnown'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'o'
op|'.'
name|'addDependant'
op|'('
name|'obj'
op|','
name|'loc'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'o'
newline|'\n'
nl|'\n'
DECL|member|callAfter
dedent|''
name|'def'
name|'callAfter'
op|'('
name|'self'
op|','
name|'callable'
op|','
name|'result'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'isinstance'
op|'('
name|'result'
op|','
name|'crefutil'
op|'.'
name|'NotKnown'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'l'
op|'='
op|'['
name|'None'
op|']'
newline|'\n'
name|'result'
op|'.'
name|'addDependant'
op|'('
name|'l'
op|','
number|'1'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'l'
op|'='
op|'['
name|'result'
op|']'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'afterUnjelly'
op|'.'
name|'append'
op|'('
op|'('
name|'callable'
op|','
name|'l'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|unjellyAttribute
dedent|''
name|'def'
name|'unjellyAttribute'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'attrName'
op|','
name|'ao'
op|')'
op|':'
newline|'\n'
comment|'#XXX this is unused????'
nl|'\n'
indent|'        '
string|'"""Utility method for unjellying into instances of attributes.\n        \n        Use this rather than unjellyAO unless you like surprising bugs!\n        Alternatively, you can use unjellyInto on your instance\'s __dict__.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'unjellyInto'
op|'('
name|'instance'
op|'.'
name|'__dict__'
op|','
name|'attrName'
op|','
name|'ao'
op|')'
newline|'\n'
nl|'\n'
DECL|member|unjellyAO
dedent|''
name|'def'
name|'unjellyAO'
op|'('
name|'self'
op|','
name|'ao'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Unjelly an Abstract Object and everything it contains.\n        I return the real object.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'stack'
op|'.'
name|'append'
op|'('
name|'ao'
op|')'
newline|'\n'
name|'t'
op|'='
name|'type'
op|'('
name|'ao'
op|')'
newline|'\n'
name|'if'
name|'t'
name|'is'
name|'types'
op|'.'
name|'InstanceType'
op|':'
newline|'\n'
comment|'#Abstract Objects'
nl|'\n'
indent|'            '
name|'c'
op|'='
name|'ao'
op|'.'
name|'__class__'
newline|'\n'
name|'if'
name|'c'
name|'is'
name|'Module'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'reflect'
op|'.'
name|'namedModule'
op|'('
name|'ao'
op|'.'
name|'name'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'c'
name|'in'
op|'['
name|'Class'
op|','
name|'Function'
op|']'
name|'or'
name|'issubclass'
op|'('
name|'c'
op|','
name|'type'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'reflect'
op|'.'
name|'namedObject'
op|'('
name|'ao'
op|'.'
name|'name'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'c'
name|'is'
name|'InstanceMethod'
op|':'
newline|'\n'
indent|'                '
name|'im_name'
op|'='
name|'ao'
op|'.'
name|'name'
newline|'\n'
name|'im_class'
op|'='
name|'reflect'
op|'.'
name|'namedObject'
op|'('
name|'ao'
op|'.'
name|'klass'
op|')'
newline|'\n'
name|'im_self'
op|'='
name|'self'
op|'.'
name|'unjellyAO'
op|'('
name|'ao'
op|'.'
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'im_name'
name|'in'
name|'im_class'
op|'.'
name|'__dict__'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'im_self'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                        '
name|'return'
name|'getattr'
op|'('
name|'im_class'
op|','
name|'im_name'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'isinstance'
op|'('
name|'im_self'
op|','
name|'crefutil'
op|'.'
name|'NotKnown'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'return'
name|'crefutil'
op|'.'
name|'_InstanceMethod'
op|'('
name|'im_name'
op|','
name|'im_self'
op|','
name|'im_class'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'return'
name|'new'
op|'.'
name|'instancemethod'
op|'('
name|'im_class'
op|'.'
name|'__dict__'
op|'['
name|'im_name'
op|']'
op|','
nl|'\n'
name|'im_self'
op|','
nl|'\n'
name|'im_class'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'TypeError'
op|'('
string|'"instance method changed"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'elif'
name|'c'
name|'is'
name|'Instance'
op|':'
newline|'\n'
indent|'                '
name|'klass'
op|'='
name|'reflect'
op|'.'
name|'namedObject'
op|'('
name|'ao'
op|'.'
name|'klass'
op|')'
newline|'\n'
name|'state'
op|'='
name|'self'
op|'.'
name|'unjellyAO'
op|'('
name|'ao'
op|'.'
name|'state'
op|')'
newline|'\n'
name|'if'
name|'hasattr'
op|'('
name|'klass'
op|','
string|'"__setstate__"'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'inst'
op|'='
name|'new'
op|'.'
name|'instance'
op|'('
name|'klass'
op|','
op|'{'
op|'}'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'callAfter'
op|'('
name|'inst'
op|'.'
name|'__setstate__'
op|','
name|'state'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'inst'
op|'='
name|'new'
op|'.'
name|'instance'
op|'('
name|'klass'
op|','
name|'state'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'inst'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'c'
name|'is'
name|'Ref'
op|':'
newline|'\n'
indent|'                '
name|'o'
op|'='
name|'self'
op|'.'
name|'unjellyAO'
op|'('
name|'ao'
op|'.'
name|'obj'
op|')'
comment|'#THIS IS CHANGING THE REF OMG'
newline|'\n'
name|'refkey'
op|'='
name|'ao'
op|'.'
name|'refnum'
newline|'\n'
name|'ref'
op|'='
name|'self'
op|'.'
name|'references'
op|'.'
name|'get'
op|'('
name|'refkey'
op|')'
newline|'\n'
name|'if'
name|'ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'references'
op|'['
name|'refkey'
op|']'
op|'='
name|'o'
newline|'\n'
dedent|''
name|'elif'
name|'isinstance'
op|'('
name|'ref'
op|','
name|'crefutil'
op|'.'
name|'NotKnown'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'ref'
op|'.'
name|'resolveDependants'
op|'('
name|'o'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'references'
op|'['
name|'refkey'
op|']'
op|'='
name|'o'
newline|'\n'
dedent|''
name|'elif'
name|'refkey'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|"# This happens when you're unjellying from an AOT not read from source"
nl|'\n'
indent|'                    '
name|'pass'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'ValueError'
op|'('
string|'"Multiple references with the same ID: %s, %s, %s!"'
op|'%'
op|'('
name|'ref'
op|','
name|'refkey'
op|','
name|'ao'
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'o'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'c'
name|'is'
name|'Deref'
op|':'
newline|'\n'
indent|'                '
name|'num'
op|'='
name|'ao'
op|'.'
name|'refnum'
newline|'\n'
name|'ref'
op|'='
name|'self'
op|'.'
name|'references'
op|'.'
name|'get'
op|'('
name|'num'
op|')'
newline|'\n'
name|'if'
name|'ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'der'
op|'='
name|'crefutil'
op|'.'
name|'_Dereference'
op|'('
name|'num'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'references'
op|'['
name|'num'
op|']'
op|'='
name|'der'
newline|'\n'
name|'return'
name|'der'
newline|'\n'
dedent|''
name|'return'
name|'ref'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'c'
name|'is'
name|'Copyreg'
op|':'
newline|'\n'
indent|'                '
name|'loadfunc'
op|'='
name|'reflect'
op|'.'
name|'namedObject'
op|'('
name|'ao'
op|'.'
name|'loadfunc'
op|')'
newline|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'unjellyLater'
op|'('
name|'ao'
op|'.'
name|'state'
op|')'
op|'.'
name|'addCallback'
op|'('
nl|'\n'
name|'lambda'
name|'result'
op|','
name|'_l'
op|':'
name|'apply'
op|'('
name|'_l'
op|','
name|'result'
op|')'
op|','
name|'loadfunc'
op|')'
newline|'\n'
name|'return'
name|'d'
newline|'\n'
nl|'\n'
comment|'#Types'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'elif'
name|'t'
name|'in'
name|'_SIMPLE_BUILTINS'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'ao'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'t'
name|'is'
name|'types'
op|'.'
name|'ListType'
op|':'
newline|'\n'
indent|'            '
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'x'
name|'in'
name|'ao'
op|':'
newline|'\n'
indent|'                '
name|'l'
op|'.'
name|'append'
op|'('
name|'None'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'unjellyInto'
op|'('
name|'l'
op|','
name|'len'
op|'('
name|'l'
op|')'
op|'-'
number|'1'
op|','
name|'x'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'l'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'t'
name|'is'
name|'types'
op|'.'
name|'TupleType'
op|':'
newline|'\n'
indent|'            '
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'tuple_'
op|'='
name|'tuple'
newline|'\n'
name|'for'
name|'x'
name|'in'
name|'ao'
op|':'
newline|'\n'
indent|'                '
name|'l'
op|'.'
name|'append'
op|'('
name|'None'
op|')'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'self'
op|'.'
name|'unjellyInto'
op|'('
name|'l'
op|','
name|'len'
op|'('
name|'l'
op|')'
op|'-'
number|'1'
op|','
name|'x'
op|')'
op|','
name|'crefutil'
op|'.'
name|'NotKnown'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'tuple_'
op|'='
name|'crefutil'
op|'.'
name|'_Tuple'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'tuple_'
op|'('
name|'l'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'t'
name|'is'
name|'types'
op|'.'
name|'DictType'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'k'
op|','
name|'v'
name|'in'
name|'ao'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'kvd'
op|'='
name|'crefutil'
op|'.'
name|'_DictKeyAndValue'
op|'('
name|'d'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'unjellyInto'
op|'('
name|'kvd'
op|','
number|'0'
op|','
name|'k'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'unjellyInto'
op|'('
name|'kvd'
op|','
number|'1'
op|','
name|'v'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'d'
newline|'\n'
nl|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'TypeError'
op|'('
string|'"Unsupported AOT type: %s"'
op|'%'
name|'t'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'del'
name|'self'
op|'.'
name|'stack'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|unjelly
dedent|''
name|'def'
name|'unjelly'
op|'('
name|'self'
op|','
name|'ao'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'l'
op|'='
op|'['
name|'None'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'unjellyInto'
op|'('
name|'l'
op|','
number|'0'
op|','
name|'ao'
op|')'
newline|'\n'
name|'for'
name|'callable'
op|','
name|'v'
name|'in'
name|'self'
op|'.'
name|'afterUnjelly'
op|':'
newline|'\n'
indent|'                '
name|'callable'
op|'('
name|'v'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'l'
op|'['
number|'0'
op|']'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'log'
op|'.'
name|'msg'
op|'('
string|'"Error jellying object! Stacktrace follows::"'
op|')'
newline|'\n'
name|'log'
op|'.'
name|'msg'
op|'('
name|'string'
op|'.'
name|'join'
op|'('
name|'map'
op|'('
name|'repr'
op|','
name|'self'
op|'.'
name|'stack'
op|')'
op|','
string|'"\\n"'
op|')'
op|')'
newline|'\n'
name|'raise'
newline|'\n'
comment|'#########'
nl|'\n'
comment|'# Jelly #'
nl|'\n'
comment|'#########'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|jellyToAOT
dedent|''
dedent|''
dedent|''
name|'def'
name|'jellyToAOT'
op|'('
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Convert an object to an Abstract Object Tree."""'
newline|'\n'
name|'return'
name|'AOTJellier'
op|'('
op|')'
op|'.'
name|'jelly'
op|'('
name|'obj'
op|')'
newline|'\n'
nl|'\n'
DECL|function|jellyToSource
dedent|''
name|'def'
name|'jellyToSource'
op|'('
name|'obj'
op|','
name|'file'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Pass me an object and, optionally, a file object.\n    I\'ll convert the object to an AOT either return it (if no file was\n    specified) or write it to the file.\n    """'
newline|'\n'
nl|'\n'
name|'aot'
op|'='
name|'jellyToAOT'
op|'('
name|'obj'
op|')'
newline|'\n'
name|'if'
name|'file'
op|':'
newline|'\n'
indent|'        '
name|'file'
op|'.'
name|'write'
op|'('
name|'getSource'
op|'('
name|'aot'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'getSource'
op|'('
name|'aot'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|AOTJellier
dedent|''
dedent|''
name|'class'
name|'AOTJellier'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# dict of {id(obj): (obj, node)}'
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'prepared'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'_ref_id'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'stack'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|prepareForRef
dedent|''
name|'def'
name|'prepareForRef'
op|'('
name|'self'
op|','
name|'aoref'
op|','
name|'object'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""I prepare an object for later referencing, by storing its id()\n        and its _AORef in a cache."""'
newline|'\n'
name|'self'
op|'.'
name|'prepared'
op|'['
name|'id'
op|'('
name|'object'
op|')'
op|']'
op|'='
name|'aoref'
newline|'\n'
nl|'\n'
DECL|member|jellyToAO
dedent|''
name|'def'
name|'jellyToAO'
op|'('
name|'self'
op|','
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""I turn an object into an AOT and return it."""'
newline|'\n'
name|'objType'
op|'='
name|'type'
op|'('
name|'obj'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'stack'
op|'.'
name|'append'
op|'('
name|'repr'
op|'('
name|'obj'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|"#immutable: We don't care if these have multiple refs!"
nl|'\n'
name|'if'
name|'objType'
name|'in'
name|'_SIMPLE_BUILTINS'
op|':'
newline|'\n'
indent|'            '
name|'retval'
op|'='
name|'obj'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'objType'
name|'is'
name|'types'
op|'.'
name|'MethodType'
op|':'
newline|'\n'
comment|"# TODO: make methods 'prefer' not to jelly the object internally,"
nl|'\n'
comment|"# so that the object will show up where it's referenced first NOT"
nl|'\n'
comment|'# by a method.'
nl|'\n'
indent|'            '
name|'retval'
op|'='
name|'InstanceMethod'
op|'('
name|'obj'
op|'.'
name|'im_func'
op|'.'
name|'__name__'
op|','
name|'reflect'
op|'.'
name|'qual'
op|'('
name|'obj'
op|'.'
name|'im_class'
op|')'
op|','
nl|'\n'
name|'self'
op|'.'
name|'jellyToAO'
op|'('
name|'obj'
op|'.'
name|'im_self'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'objType'
name|'is'
name|'types'
op|'.'
name|'ModuleType'
op|':'
newline|'\n'
indent|'            '
name|'retval'
op|'='
name|'Module'
op|'('
name|'obj'
op|'.'
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'objType'
name|'is'
name|'types'
op|'.'
name|'ClassType'
op|':'
newline|'\n'
indent|'            '
name|'retval'
op|'='
name|'Class'
op|'('
name|'reflect'
op|'.'
name|'qual'
op|'('
name|'obj'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'issubclass'
op|'('
name|'objType'
op|','
name|'type'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'retval'
op|'='
name|'Class'
op|'('
name|'reflect'
op|'.'
name|'qual'
op|'('
name|'obj'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'objType'
name|'is'
name|'types'
op|'.'
name|'FunctionType'
op|':'
newline|'\n'
indent|'            '
name|'retval'
op|'='
name|'Function'
op|'('
name|'reflect'
op|'.'
name|'fullFuncName'
op|'('
name|'obj'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'else'
op|':'
comment|'#mutable! gotta watch for refs.'
newline|'\n'
nl|'\n'
comment|"#Marmalade had the nicety of being able to just stick a 'reference' attribute"
nl|'\n'
comment|'#on any Node object that was referenced, but in AOT, the referenced object'
nl|'\n'
comment|'#is *inside* of a Ref call (Ref(num, obj) instead of'
nl|'\n'
comment|'#<objtype ... reference="1">). The problem is, especially for built-in types,'
nl|'\n'
comment|"#I can't just assign some attribute to them to give them a refnum. So, I have"
nl|'\n'
comment|'#to "wrap" a Ref(..) around them later -- that\'s why I put *everything* that\'s'
nl|'\n'
comment|'#mutable inside one. The Ref() class will only print the "Ref(..)" around an'
nl|'\n'
comment|'#object if it has a Reference explicitly attached.'
nl|'\n'
nl|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'prepared'
op|'.'
name|'has_key'
op|'('
name|'id'
op|'('
name|'obj'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'oldRef'
op|'='
name|'self'
op|'.'
name|'prepared'
op|'['
name|'id'
op|'('
name|'obj'
op|')'
op|']'
newline|'\n'
name|'if'
name|'oldRef'
op|'.'
name|'refnum'
op|':'
newline|'\n'
comment|"# it's been referenced already"
nl|'\n'
indent|'                    '
name|'key'
op|'='
name|'oldRef'
op|'.'
name|'refnum'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|"# it hasn't been referenced yet"
nl|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_ref_id'
op|'='
name|'self'
op|'.'
name|'_ref_id'
op|'+'
number|'1'
newline|'\n'
name|'key'
op|'='
name|'self'
op|'.'
name|'_ref_id'
newline|'\n'
name|'oldRef'
op|'.'
name|'setRef'
op|'('
name|'key'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'Deref'
op|'('
name|'key'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'retval'
op|'='
name|'Ref'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'prepareForRef'
op|'('
name|'retval'
op|','
name|'obj'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'objType'
name|'is'
name|'types'
op|'.'
name|'ListType'
op|':'
newline|'\n'
indent|'                '
name|'retval'
op|'.'
name|'setObj'
op|'('
name|'map'
op|'('
name|'self'
op|'.'
name|'jellyToAO'
op|','
name|'obj'
op|')'
op|')'
comment|'#hah!'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'objType'
name|'is'
name|'types'
op|'.'
name|'TupleType'
op|':'
newline|'\n'
indent|'                '
name|'retval'
op|'.'
name|'setObj'
op|'('
name|'tuple'
op|'('
name|'map'
op|'('
name|'self'
op|'.'
name|'jellyToAO'
op|','
name|'obj'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'objType'
name|'is'
name|'types'
op|'.'
name|'DictionaryType'
op|':'
newline|'\n'
indent|'                '
name|'d'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'k'
op|','
name|'v'
name|'in'
name|'obj'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'d'
op|'['
name|'self'
op|'.'
name|'jellyToAO'
op|'('
name|'k'
op|')'
op|']'
op|'='
name|'self'
op|'.'
name|'jellyToAO'
op|'('
name|'v'
op|')'
newline|'\n'
dedent|''
name|'retval'
op|'.'
name|'setObj'
op|'('
name|'d'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'objType'
name|'is'
name|'types'
op|'.'
name|'InstanceType'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'hasattr'
op|'('
name|'obj'
op|','
string|'"__getstate__"'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'state'
op|'='
name|'self'
op|'.'
name|'jellyToAO'
op|'('
name|'obj'
op|'.'
name|'__getstate__'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'state'
op|'='
name|'self'
op|'.'
name|'jellyToAO'
op|'('
name|'obj'
op|'.'
name|'__dict__'
op|')'
newline|'\n'
dedent|''
name|'retval'
op|'.'
name|'setObj'
op|'('
name|'Instance'
op|'('
name|'reflect'
op|'.'
name|'qual'
op|'('
name|'obj'
op|'.'
name|'__class__'
op|')'
op|','
name|'state'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'copy_reg'
op|'.'
name|'dispatch_table'
op|'.'
name|'has_key'
op|'('
name|'objType'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'unpickleFunc'
op|','
name|'state'
op|'='
name|'copy_reg'
op|'.'
name|'dispatch_table'
op|'['
name|'objType'
op|']'
op|'('
name|'obj'
op|')'
newline|'\n'
nl|'\n'
name|'retval'
op|'.'
name|'setObj'
op|'('
name|'Copyreg'
op|'('
name|'reflect'
op|'.'
name|'fullFuncName'
op|'('
name|'unpickleFunc'
op|')'
op|','
nl|'\n'
name|'self'
op|'.'
name|'jellyToAO'
op|'('
name|'state'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'TypeError'
op|'('
string|'"Unsupported type: %s"'
op|'%'
name|'objType'
op|'.'
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'del'
name|'self'
op|'.'
name|'stack'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
name|'return'
name|'retval'
newline|'\n'
nl|'\n'
DECL|member|jelly
dedent|''
name|'def'
name|'jelly'
op|'('
name|'self'
op|','
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'ao'
op|'='
name|'self'
op|'.'
name|'jellyToAO'
op|'('
name|'obj'
op|')'
newline|'\n'
name|'return'
name|'ao'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'log'
op|'.'
name|'msg'
op|'('
string|'"Error jellying object! Stacktrace follows::"'
op|')'
newline|'\n'
name|'log'
op|'.'
name|'msg'
op|'('
name|'string'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'stack'
op|','
string|"'\\n'"
op|')'
op|')'
newline|'\n'
name|'raise'
newline|'\n'
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
