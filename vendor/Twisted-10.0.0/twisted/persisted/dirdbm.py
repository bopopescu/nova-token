begin_unit
comment|'# -*- test-case-name: twisted.test.test_dirdbm -*-'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Copyright (c) 2001-2004 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
string|'"""\nDBM-style interface to a directory.\n\nEach key is stored as a single file.  This is not expected to be very fast or\nefficient, but it\'s good for easy debugging.\n\nDirDBMs are *not* thread-safe, they should only be accessed by one thread at\na time.\n\nNo files should be placed in the working directory of a DirDBM save those\ncreated by the DirDBM itself!\n\nMaintainer: Itamar Shtull-Trauring\n"""'
newline|'\n'
nl|'\n'
nl|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'types'
newline|'\n'
name|'import'
name|'base64'
newline|'\n'
name|'import'
name|'glob'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'import'
name|'cPickle'
name|'as'
name|'pickle'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
indent|'    '
name|'import'
name|'pickle'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'_open'
newline|'\n'
dedent|''
name|'except'
name|'NameError'
op|':'
newline|'\n'
DECL|variable|_open
indent|'    '
name|'_open'
op|'='
name|'open'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DirDBM
dedent|''
name|'class'
name|'DirDBM'
op|':'
newline|'\n'
indent|'    '
string|'"""A directory with a DBM interface.\n    \n    This class presents a hash-like interface to a directory of small,\n    flat files. It can only use strings as keys or values.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'name'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @type name: str\n        @param name: Base path to use for the directory storage.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'dname'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'abspath'
op|'('
name|'name'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'isdir'
op|'('
name|'self'
op|'.'
name|'dname'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'os'
op|'.'
name|'mkdir'
op|'('
name|'self'
op|'.'
name|'dname'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Run recovery, in case we crashed. we delete all files ending'
nl|'\n'
comment|'# with ".new". Then we find all files who end with ".rpl". If a'
nl|'\n'
comment|'# corresponding file exists without ".rpl", we assume the write'
nl|'\n'
comment|'# failed and delete the ".rpl" file. If only a ".rpl" exist we'
nl|'\n'
comment|'# assume the program crashed right after deleting the old entry'
nl|'\n'
comment|'# but before renaming the replacement entry.'
nl|'\n'
comment|'#'
nl|'\n'
comment|"# NOTE: '.' is NOT in the base64 alphabet!"
nl|'\n'
indent|'            '
name|'for'
name|'f'
name|'in'
name|'glob'
op|'.'
name|'glob'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'dname'
op|','
string|'"*.new"'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'remove'
op|'('
name|'f'
op|')'
newline|'\n'
dedent|''
name|'replacements'
op|'='
name|'glob'
op|'.'
name|'glob'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'dname'
op|','
string|'"*.rpl"'
op|')'
op|')'
newline|'\n'
name|'for'
name|'f'
name|'in'
name|'replacements'
op|':'
newline|'\n'
indent|'                '
name|'old'
op|'='
name|'f'
op|'['
op|':'
op|'-'
number|'4'
op|']'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'old'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'os'
op|'.'
name|'remove'
op|'('
name|'f'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'os'
op|'.'
name|'rename'
op|'('
name|'f'
op|','
name|'old'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_encode
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_encode'
op|'('
name|'self'
op|','
name|'k'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Encode a key so it can be used as a filename.\n        """'
newline|'\n'
comment|"# NOTE: '_' is NOT in the base64 alphabet!"
nl|'\n'
name|'return'
name|'base64'
op|'.'
name|'encodestring'
op|'('
name|'k'
op|')'
op|'.'
name|'replace'
op|'('
string|"'\\n'"
op|','
string|"'_'"
op|')'
op|'.'
name|'replace'
op|'('
string|'"/"'
op|','
string|'"-"'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_decode
dedent|''
name|'def'
name|'_decode'
op|'('
name|'self'
op|','
name|'k'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Decode a filename to get the key.\n        """'
newline|'\n'
name|'return'
name|'base64'
op|'.'
name|'decodestring'
op|'('
name|'k'
op|'.'
name|'replace'
op|'('
string|"'_'"
op|','
string|"'\\n'"
op|')'
op|'.'
name|'replace'
op|'('
string|'"-"'
op|','
string|'"/"'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_readFile
dedent|''
name|'def'
name|'_readFile'
op|'('
name|'self'
op|','
name|'path'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Read in the contents of a file.\n        \n        Override in subclasses to e.g. provide transparently encrypted dirdbm.\n        """'
newline|'\n'
name|'f'
op|'='
name|'_open'
op|'('
name|'path'
op|','
string|'"rb"'
op|')'
newline|'\n'
name|'s'
op|'='
name|'f'
op|'.'
name|'read'
op|'('
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'return'
name|'s'
newline|'\n'
nl|'\n'
DECL|member|_writeFile
dedent|''
name|'def'
name|'_writeFile'
op|'('
name|'self'
op|','
name|'path'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Write data to a file.\n        \n        Override in subclasses to e.g. provide transparently encrypted dirdbm.\n        """'
newline|'\n'
name|'f'
op|'='
name|'_open'
op|'('
name|'path'
op|','
string|'"wb"'
op|')'
newline|'\n'
name|'f'
op|'.'
name|'write'
op|'('
name|'data'
op|')'
newline|'\n'
name|'f'
op|'.'
name|'flush'
op|'('
op|')'
newline|'\n'
name|'f'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|__len__
dedent|''
name|'def'
name|'__len__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @return: The number of key/value pairs in this Shelf\n        """'
newline|'\n'
name|'return'
name|'len'
op|'('
name|'os'
op|'.'
name|'listdir'
op|'('
name|'self'
op|'.'
name|'dname'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__setitem__
dedent|''
name|'def'
name|'__setitem__'
op|'('
name|'self'
op|','
name|'k'
op|','
name|'v'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{dirdbm[k] = v}\n        Create or modify a textfile in this directory\n\n        @type k: str\n        @param k: key to set\n        \n        @type v: str\n        @param v: value to associate with C{k}\n        """'
newline|'\n'
name|'assert'
name|'type'
op|'('
name|'k'
op|')'
op|'=='
name|'types'
op|'.'
name|'StringType'
op|','
string|'"DirDBM key must be a string"'
newline|'\n'
name|'assert'
name|'type'
op|'('
name|'v'
op|')'
op|'=='
name|'types'
op|'.'
name|'StringType'
op|','
string|'"DirDBM value must be a string"'
newline|'\n'
name|'k'
op|'='
name|'self'
op|'.'
name|'_encode'
op|'('
name|'k'
op|')'
newline|'\n'
nl|'\n'
comment|'# we create a new file with extension .new, write the data to it, and'
nl|'\n'
comment|'# if the write succeeds delete the old file and rename the new one.'
nl|'\n'
name|'old'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'dname'
op|','
name|'k'
op|')'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'old'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'new'
op|'='
name|'old'
op|'+'
string|'".rpl"'
comment|'# replacement entry'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'new'
op|'='
name|'old'
op|'+'
string|'".new"'
comment|'# new entry'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_writeFile'
op|'('
name|'new'
op|','
name|'v'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'os'
op|'.'
name|'remove'
op|'('
name|'new'
op|')'
newline|'\n'
name|'raise'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'old'
op|')'
op|':'
name|'os'
op|'.'
name|'remove'
op|'('
name|'old'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'rename'
op|'('
name|'new'
op|','
name|'old'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__getitem__
dedent|''
dedent|''
name|'def'
name|'__getitem__'
op|'('
name|'self'
op|','
name|'k'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{dirdbm[k]}\n        Get the contents of a file in this directory as a string.\n        \n        @type k: str\n        @param k: key to lookup\n        \n        @return: The value associated with C{k}\n        @raise KeyError: Raised when there is no such key\n        """'
newline|'\n'
name|'assert'
name|'type'
op|'('
name|'k'
op|')'
op|'=='
name|'types'
op|'.'
name|'StringType'
op|','
string|'"DirDBM key must be a string"'
newline|'\n'
name|'path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'dname'
op|','
name|'self'
op|'.'
name|'_encode'
op|'('
name|'k'
op|')'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'_readFile'
op|'('
name|'path'
op|')'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'KeyError'
op|','
name|'k'
newline|'\n'
nl|'\n'
DECL|member|__delitem__
dedent|''
dedent|''
name|'def'
name|'__delitem__'
op|'('
name|'self'
op|','
name|'k'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{del dirdbm[foo]}\n        Delete a file in this directory.\n        \n        @type k: str\n        @param k: key to delete\n        \n        @raise KeyError: Raised when there is no such key\n        """'
newline|'\n'
name|'assert'
name|'type'
op|'('
name|'k'
op|')'
op|'=='
name|'types'
op|'.'
name|'StringType'
op|','
string|'"DirDBM key must be a string"'
newline|'\n'
name|'k'
op|'='
name|'self'
op|'.'
name|'_encode'
op|'('
name|'k'
op|')'
newline|'\n'
name|'try'
op|':'
name|'os'
op|'.'
name|'remove'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'dname'
op|','
name|'k'
op|')'
op|')'
newline|'\n'
name|'except'
op|'('
name|'OSError'
op|','
name|'IOError'
op|')'
op|':'
name|'raise'
name|'KeyError'
op|'('
name|'self'
op|'.'
name|'_decode'
op|'('
name|'k'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|keys
dedent|''
name|'def'
name|'keys'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @return: a C{list} of filenames (keys).\n        """'
newline|'\n'
name|'return'
name|'map'
op|'('
name|'self'
op|'.'
name|'_decode'
op|','
name|'os'
op|'.'
name|'listdir'
op|'('
name|'self'
op|'.'
name|'dname'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|values
dedent|''
name|'def'
name|'values'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @return: a C{list} of file-contents (values).\n        """'
newline|'\n'
name|'vals'
op|'='
op|'['
op|']'
newline|'\n'
name|'keys'
op|'='
name|'self'
op|'.'
name|'keys'
op|'('
op|')'
newline|'\n'
name|'for'
name|'key'
name|'in'
name|'keys'
op|':'
newline|'\n'
indent|'            '
name|'vals'
op|'.'
name|'append'
op|'('
name|'self'
op|'['
name|'key'
op|']'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'vals'
newline|'\n'
nl|'\n'
DECL|member|items
dedent|''
name|'def'
name|'items'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @return: a C{list} of 2-tuples containing key/value pairs.\n        """'
newline|'\n'
name|'items'
op|'='
op|'['
op|']'
newline|'\n'
name|'keys'
op|'='
name|'self'
op|'.'
name|'keys'
op|'('
op|')'
newline|'\n'
name|'for'
name|'key'
name|'in'
name|'keys'
op|':'
newline|'\n'
indent|'            '
name|'items'
op|'.'
name|'append'
op|'('
op|'('
name|'key'
op|','
name|'self'
op|'['
name|'key'
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'items'
newline|'\n'
nl|'\n'
DECL|member|has_key
dedent|''
name|'def'
name|'has_key'
op|'('
name|'self'
op|','
name|'key'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @type key: str\n        @param key: The key to test\n        \n        @return: A true value if this dirdbm has the specified key, a faluse\n        value otherwise.\n        """'
newline|'\n'
name|'assert'
name|'type'
op|'('
name|'key'
op|')'
op|'=='
name|'types'
op|'.'
name|'StringType'
op|','
string|'"DirDBM key must be a string"'
newline|'\n'
name|'key'
op|'='
name|'self'
op|'.'
name|'_encode'
op|'('
name|'key'
op|')'
newline|'\n'
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'isfile'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'dname'
op|','
name|'key'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|setdefault
dedent|''
name|'def'
name|'setdefault'
op|'('
name|'self'
op|','
name|'key'
op|','
name|'value'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @type key: str\n        @param key: The key to lookup\n        \n        @param value: The value to associate with key if key is not already\n        associated with a value.\n        """'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'has_key'
op|'('
name|'key'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'['
name|'key'
op|']'
op|'='
name|'value'
newline|'\n'
name|'return'
name|'value'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'['
name|'key'
op|']'
newline|'\n'
nl|'\n'
DECL|member|get
dedent|''
name|'def'
name|'get'
op|'('
name|'self'
op|','
name|'key'
op|','
name|'default'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        @type key: str\n        @param key: The key to lookup\n        \n        @param default: The value to return if the given key does not exist\n        \n        @return: The value associated with C{key} or C{default} if not\n        C{self.has_key(key)}\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'has_key'
op|'('
name|'key'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'['
name|'key'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'default'
newline|'\n'
nl|'\n'
DECL|member|__contains__
dedent|''
dedent|''
name|'def'
name|'__contains__'
op|'('
name|'self'
op|','
name|'key'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{key in dirdbm}\n\n        @type key: str\n        @param key: The key to test\n                \n        @return: A true value if C{self.has_key(key)}, a false value otherwise.\n        """'
newline|'\n'
name|'assert'
name|'type'
op|'('
name|'key'
op|')'
op|'=='
name|'types'
op|'.'
name|'StringType'
op|','
string|'"DirDBM key must be a string"'
newline|'\n'
name|'key'
op|'='
name|'self'
op|'.'
name|'_encode'
op|'('
name|'key'
op|')'
newline|'\n'
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'isfile'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'dname'
op|','
name|'key'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|update
dedent|''
name|'def'
name|'update'
op|'('
name|'self'
op|','
name|'dict'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Add all the key/value pairs in C{dict} to this dirdbm.  Any conflicting\n        keys will be overwritten with the values from C{dict}.\n\n        @type dict: mapping\n        @param dict: A mapping of key/value pairs to add to this dirdbm.\n        """'
newline|'\n'
name|'for'
name|'key'
op|','
name|'val'
name|'in'
name|'dict'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'['
name|'key'
op|']'
op|'='
name|'val'
newline|'\n'
nl|'\n'
DECL|member|copyTo
dedent|''
dedent|''
name|'def'
name|'copyTo'
op|'('
name|'self'
op|','
name|'path'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Copy the contents of this dirdbm to the dirdbm at C{path}.\n        \n        @type path: C{str}\n        @param path: The path of the dirdbm to copy to.  If a dirdbm\n        exists at the destination path, it is cleared first.\n        \n        @rtype: C{DirDBM}\n        @return: The dirdbm this dirdbm was copied to.\n        """'
newline|'\n'
name|'path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'abspath'
op|'('
name|'path'
op|')'
newline|'\n'
name|'assert'
name|'path'
op|'!='
name|'self'
op|'.'
name|'dname'
newline|'\n'
nl|'\n'
name|'d'
op|'='
name|'self'
op|'.'
name|'__class__'
op|'('
name|'path'
op|')'
newline|'\n'
name|'d'
op|'.'
name|'clear'
op|'('
op|')'
newline|'\n'
name|'for'
name|'k'
name|'in'
name|'self'
op|'.'
name|'keys'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'d'
op|'['
name|'k'
op|']'
op|'='
name|'self'
op|'['
name|'k'
op|']'
newline|'\n'
dedent|''
name|'return'
name|'d'
newline|'\n'
nl|'\n'
DECL|member|clear
dedent|''
name|'def'
name|'clear'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Delete all key/value pairs in this dirdbm.\n        """'
newline|'\n'
name|'for'
name|'k'
name|'in'
name|'self'
op|'.'
name|'keys'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'del'
name|'self'
op|'['
name|'k'
op|']'
newline|'\n'
nl|'\n'
DECL|member|close
dedent|''
dedent|''
name|'def'
name|'close'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Close this dbm: no-op, for dbm-style interface compliance.\n        """'
newline|'\n'
nl|'\n'
DECL|member|getModificationTime
dedent|''
name|'def'
name|'getModificationTime'
op|'('
name|'self'
op|','
name|'key'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Returns modification time of an entry.\n        \n        @return: Last modification date (seconds since epoch) of entry C{key}\n        @raise KeyError: Raised when there is no such key\n        """'
newline|'\n'
name|'assert'
name|'type'
op|'('
name|'key'
op|')'
op|'=='
name|'types'
op|'.'
name|'StringType'
op|','
string|'"DirDBM key must be a string"'
newline|'\n'
name|'path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'dname'
op|','
name|'self'
op|'.'
name|'_encode'
op|'('
name|'key'
op|')'
op|')'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'isfile'
op|'('
name|'path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'getmtime'
op|'('
name|'path'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'KeyError'
op|','
name|'key'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Shelf
dedent|''
dedent|''
dedent|''
name|'class'
name|'Shelf'
op|'('
name|'DirDBM'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""A directory with a DBM shelf interface.\n    \n    This class presents a hash-like interface to a directory of small,\n    flat files. Keys must be strings, but values can be any given object.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__setitem__
name|'def'
name|'__setitem__'
op|'('
name|'self'
op|','
name|'k'
op|','
name|'v'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{shelf[foo] = bar}\n        Create or modify a textfile in this directory.\n\n        @type k: str\n        @param k: The key to set\n\n        @param v: The value to associate with C{key}\n        """'
newline|'\n'
name|'v'
op|'='
name|'pickle'
op|'.'
name|'dumps'
op|'('
name|'v'
op|')'
newline|'\n'
name|'DirDBM'
op|'.'
name|'__setitem__'
op|'('
name|'self'
op|','
name|'k'
op|','
name|'v'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__getitem__
dedent|''
name|'def'
name|'__getitem__'
op|'('
name|'self'
op|','
name|'k'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        C{dirdbm[foo]}\n        Get and unpickle the contents of a file in this directory.\n        \n        @type k: str\n        @param k: The key to lookup\n        \n        @return: The value associated with the given key\n        @raise KeyError: Raised if the given key does not exist\n        """'
newline|'\n'
name|'return'
name|'pickle'
op|'.'
name|'loads'
op|'('
name|'DirDBM'
op|'.'
name|'__getitem__'
op|'('
name|'self'
op|','
name|'k'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|open
dedent|''
dedent|''
name|'def'
name|'open'
op|'('
name|'file'
op|','
name|'flag'
op|'='
name|'None'
op|','
name|'mode'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    This is for \'anydbm\' compatibility.\n    \n    @param file: The parameter to pass to the DirDBM constructor.\n\n    @param flag: ignored\n    @param mode: ignored\n    """'
newline|'\n'
name|'return'
name|'DirDBM'
op|'('
name|'file'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|__all__
dedent|''
name|'__all__'
op|'='
op|'['
string|'"open"'
op|','
string|'"DirDBM"'
op|','
string|'"Shelf"'
op|']'
newline|'\n'
endmarker|''
end_unit
