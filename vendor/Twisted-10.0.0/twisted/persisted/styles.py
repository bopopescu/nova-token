begin_unit
comment|'# -*- test-case-name: twisted.test.test_persisted -*-'
nl|'\n'
comment|'# Copyright (c) 2001-2004 Twisted Matrix Laboratories.'
nl|'\n'
comment|'# See LICENSE for details.'
nl|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
string|'"""\nDifferent styles of persisted objects.\n"""'
newline|'\n'
nl|'\n'
comment|'# System Imports'
nl|'\n'
name|'import'
name|'types'
newline|'\n'
name|'import'
name|'copy_reg'
newline|'\n'
name|'import'
name|'copy'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'import'
name|'cStringIO'
name|'as'
name|'StringIO'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
indent|'    '
name|'import'
name|'StringIO'
newline|'\n'
nl|'\n'
comment|'# Twisted Imports'
nl|'\n'
dedent|''
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'log'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'from'
name|'new'
name|'import'
name|'instancemethod'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'    '
name|'from'
name|'org'
op|'.'
name|'python'
op|'.'
name|'core'
name|'import'
name|'PyMethod'
newline|'\n'
DECL|variable|instancemethod
name|'instancemethod'
op|'='
name|'PyMethod'
newline|'\n'
nl|'\n'
DECL|variable|oldModules
dedent|''
name|'oldModules'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
comment|"## First, let's register support for some stuff that really ought to"
nl|'\n'
comment|'## be registerable...'
nl|'\n'
nl|'\n'
DECL|function|pickleMethod
name|'def'
name|'pickleMethod'
op|'('
name|'method'
op|')'
op|':'
newline|'\n'
indent|'    '
string|"'support function for copy_reg to pickle method refs'"
newline|'\n'
name|'return'
name|'unpickleMethod'
op|','
op|'('
name|'method'
op|'.'
name|'im_func'
op|'.'
name|'__name__'
op|','
nl|'\n'
name|'method'
op|'.'
name|'im_self'
op|','
nl|'\n'
name|'method'
op|'.'
name|'im_class'
op|')'
newline|'\n'
nl|'\n'
DECL|function|unpickleMethod
dedent|''
name|'def'
name|'unpickleMethod'
op|'('
name|'im_name'
op|','
nl|'\n'
name|'im_self'
op|','
nl|'\n'
name|'im_class'
op|')'
op|':'
newline|'\n'
indent|'    '
string|"'support function for copy_reg to unpickle method refs'"
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'unbound'
op|'='
name|'getattr'
op|'('
name|'im_class'
op|','
name|'im_name'
op|')'
newline|'\n'
name|'if'
name|'im_self'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'unbound'
newline|'\n'
dedent|''
name|'bound'
op|'='
name|'instancemethod'
op|'('
name|'unbound'
op|'.'
name|'im_func'
op|','
nl|'\n'
name|'im_self'
op|','
nl|'\n'
name|'im_class'
op|')'
newline|'\n'
name|'return'
name|'bound'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'        '
name|'log'
op|'.'
name|'msg'
op|'('
string|'"Method"'
op|','
name|'im_name'
op|','
string|'"not on class"'
op|','
name|'im_class'
op|')'
newline|'\n'
name|'assert'
name|'im_self'
name|'is'
name|'not'
name|'None'
op|','
string|'"No recourse: no instance to guess from."'
newline|'\n'
comment|'# Attempt a common fix before bailing -- if classes have'
nl|'\n'
comment|'# changed around since we pickled this method, we may still be'
nl|'\n'
comment|"# able to get it by looking on the instance's current class."
nl|'\n'
name|'unbound'
op|'='
name|'getattr'
op|'('
name|'im_self'
op|'.'
name|'__class__'
op|','
name|'im_name'
op|')'
newline|'\n'
name|'log'
op|'.'
name|'msg'
op|'('
string|'"Attempting fixup with"'
op|','
name|'unbound'
op|')'
newline|'\n'
name|'if'
name|'im_self'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'unbound'
newline|'\n'
dedent|''
name|'bound'
op|'='
name|'instancemethod'
op|'('
name|'unbound'
op|'.'
name|'im_func'
op|','
nl|'\n'
name|'im_self'
op|','
nl|'\n'
name|'im_self'
op|'.'
name|'__class__'
op|')'
newline|'\n'
name|'return'
name|'bound'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'copy_reg'
op|'.'
name|'pickle'
op|'('
name|'types'
op|'.'
name|'MethodType'
op|','
nl|'\n'
name|'pickleMethod'
op|','
nl|'\n'
name|'unpickleMethod'
op|')'
newline|'\n'
nl|'\n'
DECL|function|pickleModule
name|'def'
name|'pickleModule'
op|'('
name|'module'
op|')'
op|':'
newline|'\n'
indent|'    '
string|"'support function for copy_reg to pickle module refs'"
newline|'\n'
name|'return'
name|'unpickleModule'
op|','
op|'('
name|'module'
op|'.'
name|'__name__'
op|','
op|')'
newline|'\n'
nl|'\n'
DECL|function|unpickleModule
dedent|''
name|'def'
name|'unpickleModule'
op|'('
name|'name'
op|')'
op|':'
newline|'\n'
indent|'    '
string|"'support function for copy_reg to unpickle module refs'"
newline|'\n'
name|'if'
name|'oldModules'
op|'.'
name|'has_key'
op|'('
name|'name'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'log'
op|'.'
name|'msg'
op|'('
string|'"Module has moved: %s"'
op|'%'
name|'name'
op|')'
newline|'\n'
name|'name'
op|'='
name|'oldModules'
op|'['
name|'name'
op|']'
newline|'\n'
name|'log'
op|'.'
name|'msg'
op|'('
name|'name'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'__import__'
op|'('
name|'name'
op|','
op|'{'
op|'}'
op|','
op|'{'
op|'}'
op|','
string|"'x'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
name|'copy_reg'
op|'.'
name|'pickle'
op|'('
name|'types'
op|'.'
name|'ModuleType'
op|','
nl|'\n'
name|'pickleModule'
op|','
nl|'\n'
name|'unpickleModule'
op|')'
newline|'\n'
nl|'\n'
DECL|function|pickleStringO
name|'def'
name|'pickleStringO'
op|'('
name|'stringo'
op|')'
op|':'
newline|'\n'
indent|'    '
string|"'support function for copy_reg to pickle StringIO.OutputTypes'"
newline|'\n'
name|'return'
name|'unpickleStringO'
op|','
op|'('
name|'stringo'
op|'.'
name|'getvalue'
op|'('
op|')'
op|','
name|'stringo'
op|'.'
name|'tell'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|unpickleStringO
dedent|''
name|'def'
name|'unpickleStringO'
op|'('
name|'val'
op|','
name|'sek'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'x'
op|'='
name|'StringIO'
op|'.'
name|'StringIO'
op|'('
op|')'
newline|'\n'
name|'x'
op|'.'
name|'write'
op|'('
name|'val'
op|')'
newline|'\n'
name|'x'
op|'.'
name|'seek'
op|'('
name|'sek'
op|')'
newline|'\n'
name|'return'
name|'x'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'hasattr'
op|'('
name|'StringIO'
op|','
string|"'OutputType'"
op|')'
op|':'
newline|'\n'
indent|'    '
name|'copy_reg'
op|'.'
name|'pickle'
op|'('
name|'StringIO'
op|'.'
name|'OutputType'
op|','
nl|'\n'
name|'pickleStringO'
op|','
nl|'\n'
name|'unpickleStringO'
op|')'
newline|'\n'
nl|'\n'
DECL|function|pickleStringI
dedent|''
name|'def'
name|'pickleStringI'
op|'('
name|'stringi'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'return'
name|'unpickleStringI'
op|','
op|'('
name|'stringi'
op|'.'
name|'getvalue'
op|'('
op|')'
op|','
name|'stringi'
op|'.'
name|'tell'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|unpickleStringI
dedent|''
name|'def'
name|'unpickleStringI'
op|'('
name|'val'
op|','
name|'sek'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'x'
op|'='
name|'StringIO'
op|'.'
name|'StringIO'
op|'('
name|'val'
op|')'
newline|'\n'
name|'x'
op|'.'
name|'seek'
op|'('
name|'sek'
op|')'
newline|'\n'
name|'return'
name|'x'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
name|'if'
name|'hasattr'
op|'('
name|'StringIO'
op|','
string|"'InputType'"
op|')'
op|':'
newline|'\n'
indent|'    '
name|'copy_reg'
op|'.'
name|'pickle'
op|'('
name|'StringIO'
op|'.'
name|'InputType'
op|','
nl|'\n'
name|'pickleStringI'
op|','
nl|'\n'
name|'unpickleStringI'
op|')'
newline|'\n'
nl|'\n'
DECL|class|Ephemeral
dedent|''
name|'class'
name|'Ephemeral'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    This type of object is never persisted; if possible, even references to it\n    are eliminated.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__getstate__
name|'def'
name|'__getstate__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'log'
op|'.'
name|'msg'
op|'('
string|'"WARNING: serializing ephemeral %s"'
op|'%'
name|'self'
op|')'
newline|'\n'
name|'import'
name|'gc'
newline|'\n'
name|'if'
name|'getattr'
op|'('
name|'gc'
op|','
string|"'get_referrers'"
op|','
name|'None'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'r'
name|'in'
name|'gc'
op|'.'
name|'get_referrers'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'log'
op|'.'
name|'msg'
op|'('
string|'" referred to by %s"'
op|'%'
op|'('
name|'r'
op|','
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'None'
newline|'\n'
nl|'\n'
DECL|member|__setstate__
dedent|''
name|'def'
name|'__setstate__'
op|'('
name|'self'
op|','
name|'state'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'log'
op|'.'
name|'msg'
op|'('
string|'"WARNING: unserializing ephemeral %s"'
op|'%'
name|'self'
op|'.'
name|'__class__'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'__class__'
op|'='
name|'Ephemeral'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|versionedsToUpgrade
dedent|''
dedent|''
name|'versionedsToUpgrade'
op|'='
op|'{'
op|'}'
newline|'\n'
DECL|variable|upgraded
name|'upgraded'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
DECL|function|doUpgrade
name|'def'
name|'doUpgrade'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
name|'global'
name|'versionedsToUpgrade'
op|','
name|'upgraded'
newline|'\n'
name|'for'
name|'versioned'
name|'in'
name|'versionedsToUpgrade'
op|'.'
name|'values'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'requireUpgrade'
op|'('
name|'versioned'
op|')'
newline|'\n'
dedent|''
name|'versionedsToUpgrade'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'upgraded'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
DECL|function|requireUpgrade
dedent|''
name|'def'
name|'requireUpgrade'
op|'('
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Require that a Versioned instance be upgraded completely first.\n    """'
newline|'\n'
name|'objID'
op|'='
name|'id'
op|'('
name|'obj'
op|')'
newline|'\n'
name|'if'
name|'objID'
name|'in'
name|'versionedsToUpgrade'
name|'and'
name|'objID'
name|'not'
name|'in'
name|'upgraded'
op|':'
newline|'\n'
indent|'        '
name|'upgraded'
op|'['
name|'objID'
op|']'
op|'='
number|'1'
newline|'\n'
name|'obj'
op|'.'
name|'versionUpgrade'
op|'('
op|')'
newline|'\n'
name|'return'
name|'obj'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'from'
name|'twisted'
op|'.'
name|'python'
name|'import'
name|'reflect'
newline|'\n'
nl|'\n'
DECL|function|_aybabtu
name|'def'
name|'_aybabtu'
op|'('
name|'c'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'l'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'b'
name|'in'
name|'reflect'
op|'.'
name|'allYourBase'
op|'('
name|'c'
op|','
name|'Versioned'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'b'
name|'not'
name|'in'
name|'l'
name|'and'
name|'b'
name|'is'
name|'not'
name|'Versioned'
op|':'
newline|'\n'
indent|'            '
name|'l'
op|'.'
name|'append'
op|'('
name|'b'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'l'
newline|'\n'
nl|'\n'
DECL|class|Versioned
dedent|''
name|'class'
name|'Versioned'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    This type of object is persisted with versioning information.\n\n    I have a single class attribute, the int persistenceVersion.  After I am\n    unserialized (and styles.doUpgrade() is called), self.upgradeToVersionX()\n    will be called for each version upgrade I must undergo.\n\n    For example, if I serialize an instance of a Foo(Versioned) at version 4\n    and then unserialize it when the code is at version 9, the calls::\n\n      self.upgradeToVersion5()\n      self.upgradeToVersion6()\n      self.upgradeToVersion7()\n      self.upgradeToVersion8()\n      self.upgradeToVersion9()\n\n    will be made.  If any of these methods are undefined, a warning message\n    will be printed.\n    """'
newline|'\n'
DECL|variable|persistenceVersion
name|'persistenceVersion'
op|'='
number|'0'
newline|'\n'
DECL|variable|persistenceForgets
name|'persistenceForgets'
op|'='
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|__setstate__
name|'def'
name|'__setstate__'
op|'('
name|'self'
op|','
name|'state'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'versionedsToUpgrade'
op|'['
name|'id'
op|'('
name|'self'
op|')'
op|']'
op|'='
name|'self'
newline|'\n'
name|'self'
op|'.'
name|'__dict__'
op|'='
name|'state'
newline|'\n'
nl|'\n'
DECL|member|__getstate__
dedent|''
name|'def'
name|'__getstate__'
op|'('
name|'self'
op|','
name|'dict'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get state, adding a version number to it on its way out.\n        """'
newline|'\n'
name|'dct'
op|'='
name|'copy'
op|'.'
name|'copy'
op|'('
name|'dict'
name|'or'
name|'self'
op|'.'
name|'__dict__'
op|')'
newline|'\n'
name|'bases'
op|'='
name|'_aybabtu'
op|'('
name|'self'
op|'.'
name|'__class__'
op|')'
newline|'\n'
name|'bases'
op|'.'
name|'reverse'
op|'('
op|')'
newline|'\n'
name|'bases'
op|'.'
name|'append'
op|'('
name|'self'
op|'.'
name|'__class__'
op|')'
comment|"# don't forget me!!"
newline|'\n'
name|'for'
name|'base'
name|'in'
name|'bases'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'base'
op|'.'
name|'__dict__'
op|'.'
name|'has_key'
op|'('
string|"'persistenceForgets'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'slot'
name|'in'
name|'base'
op|'.'
name|'persistenceForgets'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'dct'
op|'.'
name|'has_key'
op|'('
name|'slot'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'del'
name|'dct'
op|'['
name|'slot'
op|']'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'base'
op|'.'
name|'__dict__'
op|'.'
name|'has_key'
op|'('
string|"'persistenceVersion'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'dct'
op|'['
string|"'%s.persistenceVersion'"
op|'%'
name|'reflect'
op|'.'
name|'qual'
op|'('
name|'base'
op|')'
op|']'
op|'='
name|'base'
op|'.'
name|'persistenceVersion'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'dct'
newline|'\n'
nl|'\n'
DECL|member|versionUpgrade
dedent|''
name|'def'
name|'versionUpgrade'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""(internal) Do a version upgrade.\n        """'
newline|'\n'
name|'bases'
op|'='
name|'_aybabtu'
op|'('
name|'self'
op|'.'
name|'__class__'
op|')'
newline|'\n'
comment|"# put the bases in order so superclasses' persistenceVersion methods"
nl|'\n'
comment|'# will be called first.'
nl|'\n'
name|'bases'
op|'.'
name|'reverse'
op|'('
op|')'
newline|'\n'
name|'bases'
op|'.'
name|'append'
op|'('
name|'self'
op|'.'
name|'__class__'
op|')'
comment|"# don't forget me!!"
newline|'\n'
comment|"# first let's look for old-skool versioned's"
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'__dict__'
op|'.'
name|'has_key'
op|'('
string|'"persistenceVersion"'
op|')'
op|':'
newline|'\n'
nl|'\n'
comment|'# Hacky heuristic: if more than one class subclasses Versioned,'
nl|'\n'
comment|"# we'll assume that the higher version number wins for the older"
nl|'\n'
comment|"# class, so we'll consider the attribute the version of the older"
nl|'\n'
comment|'# class.  There are obviously possibly times when this will'
nl|'\n'
comment|'# eventually be an incorrect assumption, but hopefully old-school'
nl|'\n'
comment|"# persistenceVersion stuff won't make it that far into multiple"
nl|'\n'
comment|'# classes inheriting from Versioned.'
nl|'\n'
nl|'\n'
indent|'            '
name|'pver'
op|'='
name|'self'
op|'.'
name|'__dict__'
op|'['
string|"'persistenceVersion'"
op|']'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'__dict__'
op|'['
string|"'persistenceVersion'"
op|']'
newline|'\n'
name|'highestVersion'
op|'='
number|'0'
newline|'\n'
name|'highestBase'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'base'
name|'in'
name|'bases'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'not'
name|'base'
op|'.'
name|'__dict__'
op|'.'
name|'has_key'
op|'('
string|"'persistenceVersion'"
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'if'
name|'base'
op|'.'
name|'persistenceVersion'
op|'>'
name|'highestVersion'
op|':'
newline|'\n'
indent|'                    '
name|'highestBase'
op|'='
name|'base'
newline|'\n'
name|'highestVersion'
op|'='
name|'base'
op|'.'
name|'persistenceVersion'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'highestBase'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'__dict__'
op|'['
string|"'%s.persistenceVersion'"
op|'%'
name|'reflect'
op|'.'
name|'qual'
op|'('
name|'highestBase'
op|')'
op|']'
op|'='
name|'pver'
newline|'\n'
dedent|''
dedent|''
name|'for'
name|'base'
name|'in'
name|'bases'
op|':'
newline|'\n'
comment|"# ugly hack, but it's what the user expects, really"
nl|'\n'
indent|'            '
name|'if'
op|'('
name|'Versioned'
name|'not'
name|'in'
name|'base'
op|'.'
name|'__bases__'
name|'and'
nl|'\n'
name|'not'
name|'base'
op|'.'
name|'__dict__'
op|'.'
name|'has_key'
op|'('
string|"'persistenceVersion'"
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'currentVers'
op|'='
name|'base'
op|'.'
name|'persistenceVersion'
newline|'\n'
name|'pverName'
op|'='
string|"'%s.persistenceVersion'"
op|'%'
name|'reflect'
op|'.'
name|'qual'
op|'('
name|'base'
op|')'
newline|'\n'
name|'persistVers'
op|'='
op|'('
name|'self'
op|'.'
name|'__dict__'
op|'.'
name|'get'
op|'('
name|'pverName'
op|')'
name|'or'
number|'0'
op|')'
newline|'\n'
name|'if'
name|'persistVers'
op|':'
newline|'\n'
indent|'                '
name|'del'
name|'self'
op|'.'
name|'__dict__'
op|'['
name|'pverName'
op|']'
newline|'\n'
dedent|''
name|'assert'
name|'persistVers'
op|'<='
name|'currentVers'
op|','
string|'"Sorry, can\'t go backwards in time."'
newline|'\n'
name|'while'
name|'persistVers'
op|'<'
name|'currentVers'
op|':'
newline|'\n'
indent|'                '
name|'persistVers'
op|'='
name|'persistVers'
op|'+'
number|'1'
newline|'\n'
name|'method'
op|'='
name|'base'
op|'.'
name|'__dict__'
op|'.'
name|'get'
op|'('
string|"'upgradeToVersion%s'"
op|'%'
name|'persistVers'
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'method'
op|':'
newline|'\n'
indent|'                    '
name|'log'
op|'.'
name|'msg'
op|'('
string|'"Upgrading %s (of %s @ %s) to version %s"'
op|'%'
op|'('
name|'reflect'
op|'.'
name|'qual'
op|'('
name|'base'
op|')'
op|','
name|'reflect'
op|'.'
name|'qual'
op|'('
name|'self'
op|'.'
name|'__class__'
op|')'
op|','
name|'id'
op|'('
name|'self'
op|')'
op|','
name|'persistVers'
op|')'
op|')'
newline|'\n'
name|'method'
op|'('
name|'self'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'log'
op|'.'
name|'msg'
op|'('
string|"'Warning: cannot upgrade %s to version %s'"
op|'%'
op|'('
name|'base'
op|','
name|'persistVers'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
