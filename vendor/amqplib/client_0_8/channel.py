begin_unit
string|'"""\nAMQP 0-8 Channels\n\n"""'
newline|'\n'
comment|'# Copyright (C) 2007-2008 Barry Pederson <bp@barryp.org>'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# This library is free software; you can redistribute it and/or'
nl|'\n'
comment|'# modify it under the terms of the GNU Lesser General Public'
nl|'\n'
comment|'# License as published by the Free Software Foundation; either'
nl|'\n'
comment|'# version 2.1 of the License, or (at your option) any later version.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# This library is distributed in the hope that it will be useful,'
nl|'\n'
comment|'# but WITHOUT ANY WARRANTY; without even the implied warranty of'
nl|'\n'
comment|'# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU'
nl|'\n'
comment|'# Lesser General Public License for more details.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# You should have received a copy of the GNU Lesser General Public'
nl|'\n'
comment|'# License along with this library; if not, write to the Free Software'
nl|'\n'
comment|'# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301'
nl|'\n'
nl|'\n'
name|'import'
name|'logging'
newline|'\n'
name|'from'
name|'Queue'
name|'import'
name|'Queue'
newline|'\n'
nl|'\n'
name|'from'
name|'abstract_channel'
name|'import'
name|'AbstractChannel'
newline|'\n'
name|'from'
name|'exceptions'
name|'import'
op|'*'
newline|'\n'
name|'from'
name|'serialization'
name|'import'
name|'AMQPWriter'
newline|'\n'
nl|'\n'
DECL|variable|__all__
name|'__all__'
op|'='
op|'['
nl|'\n'
string|"'Channel'"
op|','
comment|'# here mainly so it shows in in pydoc'
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
DECL|variable|AMQP_LOGGER
name|'AMQP_LOGGER'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
string|"'amqplib'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Channel
name|'class'
name|'Channel'
op|'('
name|'AbstractChannel'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    work with channels\n\n    The channel class provides methods for a client to establish a\n    virtual connection - a channel - to a server and for both peers to\n    operate the virtual connection thereafter.\n\n    GRAMMAR:\n\n        channel             = open-channel *use-channel close-channel\n        open-channel        = C:OPEN S:OPEN-OK\n        use-channel         = C:FLOW S:FLOW-OK\n                            / S:FLOW C:FLOW-OK\n                            / S:ALERT\n                            / functional-class\n        close-channel       = C:CLOSE S:CLOSE-OK\n                            / S:CLOSE C:CLOSE-OK\n\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'connection'
op|','
name|'channel_id'
op|'='
name|'None'
op|','
name|'auto_decode'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create a channel bound to a connection and using the specified\n        numeric channel_id, and open on the server.\n\n        The \'auto_decode\' parameter (defaults to True), indicates\n        whether the library should attempt to decode the body\n        of Messages to a Unicode string if there\'s a \'content_encoding\'\n        property for the message.  If there\'s no \'content_encoding\'\n        property, or the decode raises an Exception, the plain string\n        is left as the message body.\n\n        """'
newline|'\n'
name|'if'
name|'channel_id'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'channel_id'
op|'='
name|'connection'
op|'.'
name|'_get_free_channel_id'
op|'('
op|')'
newline|'\n'
dedent|''
name|'AMQP_LOGGER'
op|'.'
name|'debug'
op|'('
string|"'using channel_id: %d'"
op|'%'
name|'channel_id'
op|')'
newline|'\n'
nl|'\n'
name|'super'
op|'('
name|'Channel'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'connection'
op|','
name|'channel_id'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'default_ticket'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'is_open'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'active'
op|'='
name|'True'
comment|'# Flow control'
newline|'\n'
name|'self'
op|'.'
name|'alerts'
op|'='
name|'Queue'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'returned_messages'
op|'='
name|'Queue'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'callbacks'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'auto_decode'
op|'='
name|'auto_decode'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_x_open'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_do_close
dedent|''
name|'def'
name|'_do_close'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Tear down this object, after we\'ve agreed to close with the server.\n\n        """'
newline|'\n'
name|'AMQP_LOGGER'
op|'.'
name|'debug'
op|'('
string|"'Closed channel #%d'"
op|'%'
name|'self'
op|'.'
name|'channel_id'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'is_open'
op|'='
name|'False'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'connection'
op|'.'
name|'channels'
op|'['
name|'self'
op|'.'
name|'channel_id'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'channel_id'
op|'='
name|'self'
op|'.'
name|'connection'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'callbacks'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'#################'
nl|'\n'
nl|'\n'
DECL|member|_alert
dedent|''
name|'def'
name|'_alert'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        This method allows the server to send a non-fatal warning to\n        the client.  This is used for methods that are normally\n        asynchronous and thus do not have confirmations, and for which\n        the server may detect errors that need to be reported.  Fatal\n        errors are handled as channel or connection exceptions; non-\n        fatal errors are sent through this method.\n\n        PARAMETERS:\n            reply_code: short\n\n                The reply code. The AMQ reply codes are defined in AMQ\n                RFC 011.\n\n            reply_text: shortstr\n\n                The localised reply text.  This text can be logged as an\n                aid to resolving issues.\n\n            details: table\n\n                detailed information for warning\n\n                A set of fields that provide more information about\n                the problem.  The meaning of these fields are defined\n                on a per-reply-code basis (TO BE DEFINED).\n\n        """'
newline|'\n'
name|'reply_code'
op|'='
name|'args'
op|'.'
name|'read_short'
op|'('
op|')'
newline|'\n'
name|'reply_text'
op|'='
name|'args'
op|'.'
name|'read_shortstr'
op|'('
op|')'
newline|'\n'
name|'details'
op|'='
name|'args'
op|'.'
name|'read_table'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'alerts'
op|'.'
name|'put'
op|'('
op|'('
name|'reply_code'
op|','
name|'reply_text'
op|','
name|'details'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|close
dedent|''
name|'def'
name|'close'
op|'('
name|'self'
op|','
name|'reply_code'
op|'='
number|'0'
op|','
name|'reply_text'
op|'='
string|"''"
op|','
name|'method_sig'
op|'='
op|'('
number|'0'
op|','
number|'0'
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        request a channel close\n\n        This method indicates that the sender wants to close the\n        channel. This may be due to internal conditions (e.g. a forced\n        shut-down) or due to an error handling a specific method, i.e.\n        an exception.  When a close is due to an exception, the sender\n        provides the class and method id of the method which caused\n        the exception.\n\n        RULE:\n\n            After sending this method any received method except\n            Channel.Close-OK MUST be discarded.\n\n        RULE:\n\n            The peer sending this method MAY use a counter or timeout\n            to detect failure of the other peer to respond correctly\n            with Channel.Close-OK..\n\n        PARAMETERS:\n            reply_code: short\n\n                The reply code. The AMQ reply codes are defined in AMQ\n                RFC 011.\n\n            reply_text: shortstr\n\n                The localised reply text.  This text can be logged as an\n                aid to resolving issues.\n\n            class_id: short\n\n                failing method class\n\n                When the close is provoked by a method exception, this\n                is the class of the method.\n\n            method_id: short\n\n                failing method ID\n\n                When the close is provoked by a method exception, this\n                is the ID of the method.\n\n        """'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'is_open'
op|':'
newline|'\n'
comment|'# already closed'
nl|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'args'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_short'
op|'('
name|'reply_code'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_shortstr'
op|'('
name|'reply_text'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_short'
op|'('
name|'method_sig'
op|'['
number|'0'
op|']'
op|')'
comment|'# class_id'
newline|'\n'
name|'args'
op|'.'
name|'write_short'
op|'('
name|'method_sig'
op|'['
number|'1'
op|']'
op|')'
comment|'# method_id'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'20'
op|','
number|'40'
op|')'
op|','
name|'args'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'wait'
op|'('
name|'allowed_methods'
op|'='
op|'['
nl|'\n'
op|'('
number|'20'
op|','
number|'41'
op|')'
op|','
comment|'# Channel.close_ok'
nl|'\n'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_close
dedent|''
name|'def'
name|'_close'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        request a channel close\n\n        This method indicates that the sender wants to close the\n        channel. This may be due to internal conditions (e.g. a forced\n        shut-down) or due to an error handling a specific method, i.e.\n        an exception.  When a close is due to an exception, the sender\n        provides the class and method id of the method which caused\n        the exception.\n\n        RULE:\n\n            After sending this method any received method except\n            Channel.Close-OK MUST be discarded.\n\n        RULE:\n\n            The peer sending this method MAY use a counter or timeout\n            to detect failure of the other peer to respond correctly\n            with Channel.Close-OK..\n\n        PARAMETERS:\n            reply_code: short\n\n                The reply code. The AMQ reply codes are defined in AMQ\n                RFC 011.\n\n            reply_text: shortstr\n\n                The localised reply text.  This text can be logged as an\n                aid to resolving issues.\n\n            class_id: short\n\n                failing method class\n\n                When the close is provoked by a method exception, this\n                is the class of the method.\n\n            method_id: short\n\n                failing method ID\n\n                When the close is provoked by a method exception, this\n                is the ID of the method.\n\n        """'
newline|'\n'
name|'reply_code'
op|'='
name|'args'
op|'.'
name|'read_short'
op|'('
op|')'
newline|'\n'
name|'reply_text'
op|'='
name|'args'
op|'.'
name|'read_shortstr'
op|'('
op|')'
newline|'\n'
name|'class_id'
op|'='
name|'args'
op|'.'
name|'read_short'
op|'('
op|')'
newline|'\n'
name|'method_id'
op|'='
name|'args'
op|'.'
name|'read_short'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'#        self.close_ok()'
nl|'\n'
nl|'\n'
nl|'\n'
comment|'#    def close_ok(self):'
nl|'\n'
comment|'#        """'
nl|'\n'
comment|'#        confirm a channel close'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#        This method confirms a Channel.Close method and tells the'
nl|'\n'
comment|'#        recipient that it is safe to release resources for the channel'
nl|'\n'
comment|'#        and close the socket.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#        RULE:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#            A peer that detects a socket closure without having'
nl|'\n'
comment|'#            received a Channel.Close-Ok handshake method SHOULD log'
nl|'\n'
comment|'#            the error.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#        """'
nl|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'20'
op|','
number|'41'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_do_close'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'raise'
name|'AMQPChannelException'
op|'('
name|'reply_code'
op|','
name|'reply_text'
op|','
nl|'\n'
op|'('
name|'class_id'
op|','
name|'method_id'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_close_ok
dedent|''
name|'def'
name|'_close_ok'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        confirm a channel close\n\n        This method confirms a Channel.Close method and tells the\n        recipient that it is safe to release resources for the channel\n        and close the socket.\n\n        RULE:\n\n            A peer that detects a socket closure without having\n            received a Channel.Close-Ok handshake method SHOULD log\n            the error.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_do_close'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|flow
dedent|''
name|'def'
name|'flow'
op|'('
name|'self'
op|','
name|'active'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        enable/disable flow from peer\n\n        This method asks the peer to pause or restart the flow of\n        content data. This is a simple flow-control mechanism that a\n        peer can use to avoid oveflowing its queues or otherwise\n        finding itself receiving more messages than it can process.\n        Note that this method is not intended for window control.  The\n        peer that receives a request to stop sending content should\n        finish sending the current content, if any, and then wait\n        until it receives a Flow restart method.\n\n        RULE:\n\n            When a new channel is opened, it is active.  Some\n            applications assume that channels are inactive until\n            started.  To emulate this behaviour a client MAY open the\n            channel, then pause it.\n\n        RULE:\n\n            When sending content data in multiple frames, a peer\n            SHOULD monitor the channel for incoming methods and\n            respond to a Channel.Flow as rapidly as possible.\n\n        RULE:\n\n            A peer MAY use the Channel.Flow method to throttle\n            incoming content data for internal reasons, for example,\n            when exchangeing data over a slower connection.\n\n        RULE:\n\n            The peer that requests a Channel.Flow method MAY\n            disconnect and/or ban a peer that does not respect the\n            request.\n\n        PARAMETERS:\n            active: boolean\n\n                start/stop content frames\n\n                If True, the peer starts sending content frames.  If\n                False, the peer stops sending content frames.\n\n        """'
newline|'\n'
name|'args'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'active'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'20'
op|','
number|'20'
op|')'
op|','
name|'args'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'wait'
op|'('
name|'allowed_methods'
op|'='
op|'['
nl|'\n'
op|'('
number|'20'
op|','
number|'21'
op|')'
op|','
comment|'# Channel.flow_ok'
nl|'\n'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_flow
dedent|''
name|'def'
name|'_flow'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        enable/disable flow from peer\n\n        This method asks the peer to pause or restart the flow of\n        content data. This is a simple flow-control mechanism that a\n        peer can use to avoid oveflowing its queues or otherwise\n        finding itself receiving more messages than it can process.\n        Note that this method is not intended for window control.  The\n        peer that receives a request to stop sending content should\n        finish sending the current content, if any, and then wait\n        until it receives a Flow restart method.\n\n        RULE:\n\n            When a new channel is opened, it is active.  Some\n            applications assume that channels are inactive until\n            started.  To emulate this behaviour a client MAY open the\n            channel, then pause it.\n\n        RULE:\n\n            When sending content data in multiple frames, a peer\n            SHOULD monitor the channel for incoming methods and\n            respond to a Channel.Flow as rapidly as possible.\n\n        RULE:\n\n            A peer MAY use the Channel.Flow method to throttle\n            incoming content data for internal reasons, for example,\n            when exchangeing data over a slower connection.\n\n        RULE:\n\n            The peer that requests a Channel.Flow method MAY\n            disconnect and/or ban a peer that does not respect the\n            request.\n\n        PARAMETERS:\n            active: boolean\n\n                start/stop content frames\n\n                If True, the peer starts sending content frames.  If\n                False, the peer stops sending content frames.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'active'
op|'='
name|'args'
op|'.'
name|'read_bit'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_x_flow_ok'
op|'('
name|'self'
op|'.'
name|'active'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_x_flow_ok
dedent|''
name|'def'
name|'_x_flow_ok'
op|'('
name|'self'
op|','
name|'active'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        confirm a flow method\n\n        Confirms to the peer that a flow command was received and\n        processed.\n\n        PARAMETERS:\n            active: boolean\n\n                current flow setting\n\n                Confirms the setting of the processed flow method:\n                True means the peer will start sending or continue\n                to send content frames; False means it will not.\n\n        """'
newline|'\n'
name|'args'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'active'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'20'
op|','
number|'21'
op|')'
op|','
name|'args'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_flow_ok
dedent|''
name|'def'
name|'_flow_ok'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        confirm a flow method\n\n        Confirms to the peer that a flow command was received and\n        processed.\n\n        PARAMETERS:\n            active: boolean\n\n                current flow setting\n\n                Confirms the setting of the processed flow method:\n                True means the peer will start sending or continue\n                to send content frames; False means it will not.\n\n        """'
newline|'\n'
name|'return'
name|'args'
op|'.'
name|'read_bit'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_x_open
dedent|''
name|'def'
name|'_x_open'
op|'('
name|'self'
op|','
name|'out_of_band'
op|'='
string|"''"
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        open a channel for use\n\n        This method opens a virtual connection (a channel).\n\n        RULE:\n\n            This method MUST NOT be called when the channel is already\n            open.\n\n        PARAMETERS:\n            out_of_band: shortstr\n\n                out-of-band settings\n\n                Configures out-of-band transfers on this channel.  The\n                syntax and meaning of this field will be formally\n                defined at a later date.\n\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'is_open'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'args'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_shortstr'
op|'('
name|'out_of_band'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'20'
op|','
number|'10'
op|')'
op|','
name|'args'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'wait'
op|'('
name|'allowed_methods'
op|'='
op|'['
nl|'\n'
op|'('
number|'20'
op|','
number|'11'
op|')'
op|','
comment|'# Channel.open_ok'
nl|'\n'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_open_ok
dedent|''
name|'def'
name|'_open_ok'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        signal that the channel is ready\n\n        This method signals to the client that the channel is ready\n        for use.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'is_open'
op|'='
name|'True'
newline|'\n'
name|'AMQP_LOGGER'
op|'.'
name|'debug'
op|'('
string|"'Channel open'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'#############'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#  Access'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# work with access tickets'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# The protocol control access to server resources using access'
nl|'\n'
comment|'# tickets. A client must explicitly request access tickets before'
nl|'\n'
comment|'# doing work. An access ticket grants a client the right to use a'
nl|'\n'
comment|'# specific set of resources - called a "realm" - in specific ways.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# GRAMMAR:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     access              = C:REQUEST S:REQUEST-OK'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#'
nl|'\n'
nl|'\n'
DECL|member|access_request
dedent|''
name|'def'
name|'access_request'
op|'('
name|'self'
op|','
name|'realm'
op|','
name|'exclusive'
op|'='
name|'False'
op|','
nl|'\n'
name|'passive'
op|'='
name|'False'
op|','
name|'active'
op|'='
name|'False'
op|','
name|'write'
op|'='
name|'False'
op|','
name|'read'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        request an access ticket\n\n        This method requests an access ticket for an access realm. The\n        server responds by granting the access ticket.  If the client\n        does not have access rights to the requested realm this causes\n        a connection exception.  Access tickets are a per-channel\n        resource.\n\n        RULE:\n\n            The realm name MUST start with either "/data" (for\n            application resources) or "/admin" (for server\n            administration resources). If the realm starts with any\n            other path, the server MUST raise a connection exception\n            with reply code 403 (access refused).\n\n        RULE:\n\n            The server MUST implement the /data realm and MAY\n            implement the /admin realm.  The mapping of resources to\n            realms is not defined in the protocol - this is a server-\n            side configuration issue.\n\n        PARAMETERS:\n            realm: shortstr\n\n                name of requested realm\n\n                RULE:\n\n                    If the specified realm is not known to the server,\n                    the server must raise a channel exception with\n                    reply code 402 (invalid path).\n\n            exclusive: boolean\n\n                request exclusive access\n\n                Request exclusive access to the realm. If the server\n                cannot grant this - because there are other active\n                tickets for the realm - it raises a channel exception.\n\n            passive: boolean\n\n                request passive access\n\n                Request message passive access to the specified access\n                realm. Passive access lets a client get information\n                about resources in the realm but not to make any\n                changes to them.\n\n            active: boolean\n\n                request active access\n\n                Request message active access to the specified access\n                realm. Acvtive access lets a client get create and\n                delete resources in the realm.\n\n            write: boolean\n\n                request write access\n\n                Request write access to the specified access realm.\n                Write access lets a client publish messages to all\n                exchanges in the realm.\n\n            read: boolean\n\n                request read access\n\n                Request read access to the specified access realm.\n                Read access lets a client consume messages from queues\n                in the realm.\n\n        The most recently requested ticket is used as the channel\'s\n        default ticket for any method that requires a ticket.\n\n        """'
newline|'\n'
name|'args'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_shortstr'
op|'('
name|'realm'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'exclusive'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'passive'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'active'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'write'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'read'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'30'
op|','
number|'10'
op|')'
op|','
name|'args'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'wait'
op|'('
name|'allowed_methods'
op|'='
op|'['
nl|'\n'
op|'('
number|'30'
op|','
number|'11'
op|')'
op|','
comment|'# Channel.access_request_ok'
nl|'\n'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_access_request_ok
dedent|''
name|'def'
name|'_access_request_ok'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        grant access to server resources\n\n        This method provides the client with an access ticket. The\n        access ticket is valid within the current channel and for the\n        lifespan of the channel.\n\n        RULE:\n\n            The client MUST NOT use access tickets except within the\n            same channel as originally granted.\n\n        RULE:\n\n            The server MUST isolate access tickets per channel and\n            treat an attempt by a client to mix these as a connection\n            exception.\n\n        PARAMETERS:\n            ticket: short\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'default_ticket'
op|'='
name|'args'
op|'.'
name|'read_short'
op|'('
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'default_ticket'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'#############'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#  Exchange'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# work with exchanges'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Exchanges match and distribute messages across queues.'
nl|'\n'
comment|'# Exchanges can be configured in the server or created at runtime.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# GRAMMAR:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     exchange            = C:DECLARE  S:DECLARE-OK'
nl|'\n'
comment|'#                         / C:DELETE   S:DELETE-OK'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# RULE:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     The server MUST implement the direct and fanout exchange'
nl|'\n'
comment|'#     types, and predeclare the corresponding exchanges named'
nl|'\n'
comment|'#     amq.direct and amq.fanout in each virtual host. The server'
nl|'\n'
comment|'#     MUST also predeclare a direct exchange to act as the default'
nl|'\n'
comment|'#     exchange for content Publish methods and for default queue'
nl|'\n'
comment|'#     bindings.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# RULE:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     The server SHOULD implement the topic exchange type, and'
nl|'\n'
comment|'#     predeclare the corresponding exchange named amq.topic in'
nl|'\n'
comment|'#     each virtual host.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# RULE:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     The server MAY implement the system exchange type, and'
nl|'\n'
comment|'#     predeclare the corresponding exchanges named amq.system in'
nl|'\n'
comment|'#     each virtual host. If the client attempts to bind a queue to'
nl|'\n'
comment|'#     the system exchange, the server MUST raise a connection'
nl|'\n'
comment|'#     exception with reply code 507 (not allowed).'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# RULE:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     The default exchange MUST be defined as internal, and be'
nl|'\n'
comment|'#     inaccessible to the client except by specifying an empty'
nl|'\n'
comment|'#     exchange name in a content Publish method. That is, the'
nl|'\n'
comment|'#     server MUST NOT let clients make explicit bindings to this'
nl|'\n'
comment|'#     exchange.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#'
nl|'\n'
nl|'\n'
DECL|member|exchange_declare
dedent|''
name|'def'
name|'exchange_declare'
op|'('
name|'self'
op|','
name|'exchange'
op|','
name|'type'
op|','
name|'passive'
op|'='
name|'False'
op|','
name|'durable'
op|'='
name|'False'
op|','
nl|'\n'
name|'auto_delete'
op|'='
name|'True'
op|','
name|'internal'
op|'='
name|'False'
op|','
name|'nowait'
op|'='
name|'False'
op|','
nl|'\n'
name|'arguments'
op|'='
name|'None'
op|','
name|'ticket'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        declare exchange, create if needed\n\n        This method creates an exchange if it does not already exist,\n        and if the exchange exists, verifies that it is of the correct\n        and expected class.\n\n        RULE:\n\n            The server SHOULD support a minimum of 16 exchanges per\n            virtual host and ideally, impose no limit except as\n            defined by available resources.\n\n        PARAMETERS:\n            exchange: shortstr\n\n                RULE:\n\n                    Exchange names starting with "amq." are reserved\n                    for predeclared and standardised exchanges.  If\n                    the client attempts to create an exchange starting\n                    with "amq.", the server MUST raise a channel\n                    exception with reply code 403 (access refused).\n\n            type: shortstr\n\n                exchange type\n\n                Each exchange belongs to one of a set of exchange\n                types implemented by the server.  The exchange types\n                define the functionality of the exchange - i.e. how\n                messages are routed through it.  It is not valid or\n                meaningful to attempt to change the type of an\n                existing exchange.\n\n                RULE:\n\n                    If the exchange already exists with a different\n                    type, the server MUST raise a connection exception\n                    with a reply code 507 (not allowed).\n\n                RULE:\n\n                    If the server does not support the requested\n                    exchange type it MUST raise a connection exception\n                    with a reply code 503 (command invalid).\n\n            passive: boolean\n\n                do not create exchange\n\n                If set, the server will not create the exchange.  The\n                client can use this to check whether an exchange\n                exists without modifying the server state.\n\n                RULE:\n\n                    If set, and the exchange does not already exist,\n                    the server MUST raise a channel exception with\n                    reply code 404 (not found).\n\n            durable: boolean\n\n                request a durable exchange\n\n                If set when creating a new exchange, the exchange will\n                be marked as durable.  Durable exchanges remain active\n                when a server restarts. Non-durable exchanges\n                (transient exchanges) are purged if/when a server\n                restarts.\n\n                RULE:\n\n                    The server MUST support both durable and transient\n                    exchanges.\n\n                RULE:\n\n                    The server MUST ignore the durable field if the\n                    exchange already exists.\n\n            auto_delete: boolean\n\n                auto-delete when unused\n\n                If set, the exchange is deleted when all queues have\n                finished using it.\n\n                RULE:\n\n                    The server SHOULD allow for a reasonable delay\n                    between the point when it determines that an\n                    exchange is not being used (or no longer used),\n                    and the point when it deletes the exchange.  At\n                    the least it must allow a client to create an\n                    exchange and then bind a queue to it, with a small\n                    but non-zero delay between these two actions.\n\n                RULE:\n\n                    The server MUST ignore the auto-delete field if\n                    the exchange already exists.\n\n            internal: boolean\n\n                create internal exchange\n\n                If set, the exchange may not be used directly by\n                publishers, but only when bound to other exchanges.\n                Internal exchanges are used to construct wiring that\n                is not visible to applications.\n\n            nowait: boolean\n\n                do not send a reply method\n\n                If set, the server will not respond to the method. The\n                client should not wait for a reply method.  If the\n                server could not complete the method it will raise a\n                channel or connection exception.\n\n            arguments: table\n\n                arguments for declaration\n\n                A set of arguments for the declaration. The syntax and\n                semantics of these arguments depends on the server\n                implementation.  This field is ignored if passive is\n                True.\n\n            ticket: short\n\n                When a client defines a new exchange, this belongs to\n                the access realm of the ticket used.  All further work\n                done with that exchange must be done with an access\n                ticket for the same realm.\n\n                RULE:\n\n                    The client MUST provide a valid access ticket\n                    giving "active" access to the realm in which the\n                    exchange exists or will be created, or "passive"\n                    access if the if-exists flag is set.\n\n        """'
newline|'\n'
name|'if'
name|'arguments'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'arguments'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
dedent|''
name|'args'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'if'
name|'ticket'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'args'
op|'.'
name|'write_short'
op|'('
name|'ticket'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'args'
op|'.'
name|'write_short'
op|'('
name|'self'
op|'.'
name|'default_ticket'
op|')'
newline|'\n'
dedent|''
name|'args'
op|'.'
name|'write_shortstr'
op|'('
name|'exchange'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_shortstr'
op|'('
name|'type'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'passive'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'durable'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'auto_delete'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'internal'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'nowait'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_table'
op|'('
name|'arguments'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'40'
op|','
number|'10'
op|')'
op|','
name|'args'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'nowait'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'wait'
op|'('
name|'allowed_methods'
op|'='
op|'['
nl|'\n'
op|'('
number|'40'
op|','
number|'11'
op|')'
op|','
comment|'# Channel.exchange_declare_ok'
nl|'\n'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_exchange_declare_ok
dedent|''
dedent|''
name|'def'
name|'_exchange_declare_ok'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        confirms an exchange declaration\n\n        This method confirms a Declare method and confirms the name of\n        the exchange, essential for automatically-named exchanges.\n\n        """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|exchange_delete
dedent|''
name|'def'
name|'exchange_delete'
op|'('
name|'self'
op|','
name|'exchange'
op|','
name|'if_unused'
op|'='
name|'False'
op|','
nl|'\n'
name|'nowait'
op|'='
name|'False'
op|','
name|'ticket'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        delete an exchange\n\n        This method deletes an exchange.  When an exchange is deleted\n        all queue bindings on the exchange are cancelled.\n\n        PARAMETERS:\n            exchange: shortstr\n\n                RULE:\n\n                    The exchange MUST exist. Attempting to delete a\n                    non-existing exchange causes a channel exception.\n\n            if_unused: boolean\n\n                delete only if unused\n\n                If set, the server will only delete the exchange if it\n                has no queue bindings. If the exchange has queue\n                bindings the server does not delete it but raises a\n                channel exception instead.\n\n                RULE:\n\n                    If set, the server SHOULD delete the exchange but\n                    only if it has no queue bindings.\n\n                RULE:\n\n                    If set, the server SHOULD raise a channel\n                    exception if the exchange is in use.\n\n            nowait: boolean\n\n                do not send a reply method\n\n                If set, the server will not respond to the method. The\n                client should not wait for a reply method.  If the\n                server could not complete the method it will raise a\n                channel or connection exception.\n\n            ticket: short\n\n                RULE:\n\n                    The client MUST provide a valid access ticket\n                    giving "active" access rights to the exchange\'s\n                    access realm.\n\n        """'
newline|'\n'
name|'args'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'if'
name|'ticket'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'args'
op|'.'
name|'write_short'
op|'('
name|'ticket'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'args'
op|'.'
name|'write_short'
op|'('
name|'self'
op|'.'
name|'default_ticket'
op|')'
newline|'\n'
dedent|''
name|'args'
op|'.'
name|'write_shortstr'
op|'('
name|'exchange'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'if_unused'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'nowait'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'40'
op|','
number|'20'
op|')'
op|','
name|'args'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'nowait'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'wait'
op|'('
name|'allowed_methods'
op|'='
op|'['
nl|'\n'
op|'('
number|'40'
op|','
number|'21'
op|')'
op|','
comment|'# Channel.exchange_delete_ok'
nl|'\n'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_exchange_delete_ok
dedent|''
dedent|''
name|'def'
name|'_exchange_delete_ok'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        confirm deletion of an exchange\n\n        This method confirms the deletion of an exchange.\n\n        """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'#############'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#  Queue'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# work with queues'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Queues store and forward messages.  Queues can be configured in'
nl|'\n'
comment|'# the server or created at runtime.  Queues must be attached to at'
nl|'\n'
comment|'# least one exchange in order to receive messages from publishers.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# GRAMMAR:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     queue               = C:DECLARE  S:DECLARE-OK'
nl|'\n'
comment|'#                         / C:BIND     S:BIND-OK'
nl|'\n'
comment|'#                         / C:PURGE    S:PURGE-OK'
nl|'\n'
comment|'#                         / C:DELETE   S:DELETE-OK'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# RULE:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     A server MUST allow any content class to be sent to any'
nl|'\n'
comment|'#     queue, in any mix, and queue and delivery these content'
nl|'\n'
comment|'#     classes independently. Note that all methods that fetch'
nl|'\n'
comment|'#     content off queues are specific to a given content class.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#'
nl|'\n'
nl|'\n'
DECL|member|queue_bind
dedent|''
name|'def'
name|'queue_bind'
op|'('
name|'self'
op|','
name|'queue'
op|','
name|'exchange'
op|','
name|'routing_key'
op|'='
string|"''"
op|','
nl|'\n'
name|'nowait'
op|'='
name|'False'
op|','
name|'arguments'
op|'='
name|'None'
op|','
name|'ticket'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        bind queue to an exchange\n\n        This method binds a queue to an exchange.  Until a queue is\n        bound it will not receive any messages.  In a classic\n        messaging model, store-and-forward queues are bound to a dest\n        exchange and subscription queues are bound to a dest_wild\n        exchange.\n\n        RULE:\n\n            A server MUST allow ignore duplicate bindings - that is,\n            two or more bind methods for a specific queue, with\n            identical arguments - without treating these as an error.\n\n        RULE:\n\n            If a bind fails, the server MUST raise a connection\n            exception.\n\n        RULE:\n\n            The server MUST NOT allow a durable queue to bind to a\n            transient exchange. If the client attempts this the server\n            MUST raise a channel exception.\n\n        RULE:\n\n            Bindings for durable queues are automatically durable and\n            the server SHOULD restore such bindings after a server\n            restart.\n\n        RULE:\n\n            If the client attempts to an exchange that was declared as\n            internal, the server MUST raise a connection exception\n            with reply code 530 (not allowed).\n\n        RULE:\n\n            The server SHOULD support at least 4 bindings per queue,\n            and ideally, impose no limit except as defined by\n            available resources.\n\n        PARAMETERS:\n            queue: shortstr\n\n                Specifies the name of the queue to bind.  If the queue\n                name is empty, refers to the current queue for the\n                channel, which is the last declared queue.\n\n                RULE:\n\n                    If the client did not previously declare a queue,\n                    and the queue name in this method is empty, the\n                    server MUST raise a connection exception with\n                    reply code 530 (not allowed).\n\n                RULE:\n\n                    If the queue does not exist the server MUST raise\n                    a channel exception with reply code 404 (not\n                    found).\n\n            exchange: shortstr\n\n                The name of the exchange to bind to.\n\n                RULE:\n\n                    If the exchange does not exist the server MUST\n                    raise a channel exception with reply code 404 (not\n                    found).\n\n            routing_key: shortstr\n\n                message routing key\n\n                Specifies the routing key for the binding.  The\n                routing key is used for routing messages depending on\n                the exchange configuration. Not all exchanges use a\n                routing key - refer to the specific exchange\n                documentation.  If the routing key is empty and the\n                queue name is empty, the routing key will be the\n                current queue for the channel, which is the last\n                declared queue.\n\n            nowait: boolean\n\n                do not send a reply method\n\n                If set, the server will not respond to the method. The\n                client should not wait for a reply method.  If the\n                server could not complete the method it will raise a\n                channel or connection exception.\n\n            arguments: table\n\n                arguments for binding\n\n                A set of arguments for the binding.  The syntax and\n                semantics of these arguments depends on the exchange\n                class.\n\n            ticket: short\n\n                The client provides a valid access ticket giving\n                "active" access rights to the queue\'s access realm.\n\n        """'
newline|'\n'
name|'if'
name|'arguments'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'arguments'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
dedent|''
name|'args'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'if'
name|'ticket'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'args'
op|'.'
name|'write_short'
op|'('
name|'ticket'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'args'
op|'.'
name|'write_short'
op|'('
name|'self'
op|'.'
name|'default_ticket'
op|')'
newline|'\n'
dedent|''
name|'args'
op|'.'
name|'write_shortstr'
op|'('
name|'queue'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_shortstr'
op|'('
name|'exchange'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_shortstr'
op|'('
name|'routing_key'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'nowait'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_table'
op|'('
name|'arguments'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'50'
op|','
number|'20'
op|')'
op|','
name|'args'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'nowait'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'wait'
op|'('
name|'allowed_methods'
op|'='
op|'['
nl|'\n'
op|'('
number|'50'
op|','
number|'21'
op|')'
op|','
comment|'# Channel.queue_bind_ok'
nl|'\n'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_queue_bind_ok
dedent|''
dedent|''
name|'def'
name|'_queue_bind_ok'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        confirm bind successful\n\n        This method confirms that the bind was successful.\n\n        """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|queue_declare
dedent|''
name|'def'
name|'queue_declare'
op|'('
name|'self'
op|','
name|'queue'
op|'='
string|"''"
op|','
name|'passive'
op|'='
name|'False'
op|','
name|'durable'
op|'='
name|'False'
op|','
nl|'\n'
name|'exclusive'
op|'='
name|'False'
op|','
name|'auto_delete'
op|'='
name|'True'
op|','
name|'nowait'
op|'='
name|'False'
op|','
nl|'\n'
name|'arguments'
op|'='
name|'None'
op|','
name|'ticket'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        declare queue, create if needed\n\n        This method creates or checks a queue.  When creating a new\n        queue the client can specify various properties that control\n        the durability of the queue and its contents, and the level of\n        sharing for the queue.\n\n        RULE:\n\n            The server MUST create a default binding for a newly-\n            created queue to the default exchange, which is an\n            exchange of type \'direct\'.\n\n        RULE:\n\n            The server SHOULD support a minimum of 256 queues per\n            virtual host and ideally, impose no limit except as\n            defined by available resources.\n\n        PARAMETERS:\n            queue: shortstr\n\n                RULE:\n\n                    The queue name MAY be empty, in which case the\n                    server MUST create a new queue with a unique\n                    generated name and return this to the client in\n                    the Declare-Ok method.\n\n                RULE:\n\n                    Queue names starting with "amq." are reserved for\n                    predeclared and standardised server queues.  If\n                    the queue name starts with "amq." and the passive\n                    option is False, the server MUST raise a connection\n                    exception with reply code 403 (access refused).\n\n            passive: boolean\n\n                do not create queue\n\n                If set, the server will not create the queue.  The\n                client can use this to check whether a queue exists\n                without modifying the server state.\n\n                RULE:\n\n                    If set, and the queue does not already exist, the\n                    server MUST respond with a reply code 404 (not\n                    found) and raise a channel exception.\n\n            durable: boolean\n\n                request a durable queue\n\n                If set when creating a new queue, the queue will be\n                marked as durable.  Durable queues remain active when\n                a server restarts. Non-durable queues (transient\n                queues) are purged if/when a server restarts.  Note\n                that durable queues do not necessarily hold persistent\n                messages, although it does not make sense to send\n                persistent messages to a transient queue.\n\n                RULE:\n\n                    The server MUST recreate the durable queue after a\n                    restart.\n\n                RULE:\n\n                    The server MUST support both durable and transient\n                    queues.\n\n                RULE:\n\n                    The server MUST ignore the durable field if the\n                    queue already exists.\n\n            exclusive: boolean\n\n                request an exclusive queue\n\n                Exclusive queues may only be consumed from by the\n                current connection. Setting the \'exclusive\' flag\n                always implies \'auto-delete\'.\n\n                RULE:\n\n                    The server MUST support both exclusive (private)\n                    and non-exclusive (shared) queues.\n\n                RULE:\n\n                    The server MUST raise a channel exception if\n                    \'exclusive\' is specified and the queue already\n                    exists and is owned by a different connection.\n\n            auto_delete: boolean\n\n                auto-delete queue when unused\n\n                If set, the queue is deleted when all consumers have\n                finished using it. Last consumer can be cancelled\n                either explicitly or because its channel is closed. If\n                there was no consumer ever on the queue, it won\'t be\n                deleted.\n\n                RULE:\n\n                    The server SHOULD allow for a reasonable delay\n                    between the point when it determines that a queue\n                    is not being used (or no longer used), and the\n                    point when it deletes the queue.  At the least it\n                    must allow a client to create a queue and then\n                    create a consumer to read from it, with a small\n                    but non-zero delay between these two actions.  The\n                    server should equally allow for clients that may\n                    be disconnected prematurely, and wish to re-\n                    consume from the same queue without losing\n                    messages.  We would recommend a configurable\n                    timeout, with a suitable default value being one\n                    minute.\n\n                RULE:\n\n                    The server MUST ignore the auto-delete field if\n                    the queue already exists.\n\n            nowait: boolean\n\n                do not send a reply method\n\n                If set, the server will not respond to the method. The\n                client should not wait for a reply method.  If the\n                server could not complete the method it will raise a\n                channel or connection exception.\n\n            arguments: table\n\n                arguments for declaration\n\n                A set of arguments for the declaration. The syntax and\n                semantics of these arguments depends on the server\n                implementation.  This field is ignored if passive is\n                True.\n\n            ticket: short\n\n                When a client defines a new queue, this belongs to the\n                access realm of the ticket used.  All further work\n                done with that queue must be done with an access\n                ticket for the same realm.\n\n                The client provides a valid access ticket giving\n                "active" access to the realm in which the queue exists\n                or will be created, or "passive" access if the if-\n                exists flag is set.\n\n        Returns a tuple containing 3 items:\n            the name of the queue (essential for automatically-named queues)\n            message count\n            consumer count\n\n        """'
newline|'\n'
name|'if'
name|'arguments'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'arguments'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
dedent|''
name|'args'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'if'
name|'ticket'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'args'
op|'.'
name|'write_short'
op|'('
name|'ticket'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'args'
op|'.'
name|'write_short'
op|'('
name|'self'
op|'.'
name|'default_ticket'
op|')'
newline|'\n'
dedent|''
name|'args'
op|'.'
name|'write_shortstr'
op|'('
name|'queue'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'passive'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'durable'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'exclusive'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'auto_delete'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'nowait'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_table'
op|'('
name|'arguments'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'50'
op|','
number|'10'
op|')'
op|','
name|'args'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'nowait'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'wait'
op|'('
name|'allowed_methods'
op|'='
op|'['
nl|'\n'
op|'('
number|'50'
op|','
number|'11'
op|')'
op|','
comment|'# Channel.queue_declare_ok'
nl|'\n'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_queue_declare_ok
dedent|''
dedent|''
name|'def'
name|'_queue_declare_ok'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        confirms a queue definition\n\n        This method confirms a Declare method and confirms the name of\n        the queue, essential for automatically-named queues.\n\n        PARAMETERS:\n            queue: shortstr\n\n                Reports the name of the queue. If the server generated\n                a queue name, this field contains that name.\n\n            message_count: long\n\n                number of messages in queue\n\n                Reports the number of messages in the queue, which\n                will be zero for newly-created queues.\n\n            consumer_count: long\n\n                number of consumers\n\n                Reports the number of active consumers for the queue.\n                Note that consumers can suspend activity\n                (Channel.Flow) in which case they do not appear in\n                this count.\n\n        """'
newline|'\n'
name|'queue'
op|'='
name|'args'
op|'.'
name|'read_shortstr'
op|'('
op|')'
newline|'\n'
name|'message_count'
op|'='
name|'args'
op|'.'
name|'read_long'
op|'('
op|')'
newline|'\n'
name|'consumer_count'
op|'='
name|'args'
op|'.'
name|'read_long'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'queue'
op|','
name|'message_count'
op|','
name|'consumer_count'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|queue_delete
dedent|''
name|'def'
name|'queue_delete'
op|'('
name|'self'
op|','
name|'queue'
op|'='
string|"''"
op|','
name|'if_unused'
op|'='
name|'False'
op|','
name|'if_empty'
op|'='
name|'False'
op|','
nl|'\n'
name|'nowait'
op|'='
name|'False'
op|','
name|'ticket'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        delete a queue\n\n        This method deletes a queue.  When a queue is deleted any\n        pending messages are sent to a dead-letter queue if this is\n        defined in the server configuration, and all consumers on the\n        queue are cancelled.\n\n        RULE:\n\n            The server SHOULD use a dead-letter queue to hold messages\n            that were pending on a deleted queue, and MAY provide\n            facilities for a system administrator to move these\n            messages back to an active queue.\n\n        PARAMETERS:\n            queue: shortstr\n\n                Specifies the name of the queue to delete. If the\n                queue name is empty, refers to the current queue for\n                the channel, which is the last declared queue.\n\n                RULE:\n\n                    If the client did not previously declare a queue,\n                    and the queue name in this method is empty, the\n                    server MUST raise a connection exception with\n                    reply code 530 (not allowed).\n\n                RULE:\n\n                    The queue must exist. Attempting to delete a non-\n                    existing queue causes a channel exception.\n\n            if_unused: boolean\n\n                delete only if unused\n\n                If set, the server will only delete the queue if it\n                has no consumers. If the queue has consumers the\n                server does does not delete it but raises a channel\n                exception instead.\n\n                RULE:\n\n                    The server MUST respect the if-unused flag when\n                    deleting a queue.\n\n            if_empty: boolean\n\n                delete only if empty\n\n                If set, the server will only delete the queue if it\n                has no messages. If the queue is not empty the server\n                raises a channel exception.\n\n            nowait: boolean\n\n                do not send a reply method\n\n                If set, the server will not respond to the method. The\n                client should not wait for a reply method.  If the\n                server could not complete the method it will raise a\n                channel or connection exception.\n\n            ticket: short\n\n                The client provides a valid access ticket giving\n                "active" access rights to the queue\'s access realm.\n\n        """'
newline|'\n'
name|'args'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'if'
name|'ticket'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'args'
op|'.'
name|'write_short'
op|'('
name|'ticket'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'args'
op|'.'
name|'write_short'
op|'('
name|'self'
op|'.'
name|'default_ticket'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'args'
op|'.'
name|'write_shortstr'
op|'('
name|'queue'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'if_unused'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'if_empty'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'nowait'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'50'
op|','
number|'40'
op|')'
op|','
name|'args'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'nowait'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'wait'
op|'('
name|'allowed_methods'
op|'='
op|'['
nl|'\n'
op|'('
number|'50'
op|','
number|'41'
op|')'
op|','
comment|'# Channel.queue_delete_ok'
nl|'\n'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_queue_delete_ok
dedent|''
dedent|''
name|'def'
name|'_queue_delete_ok'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        confirm deletion of a queue\n\n        This method confirms the deletion of a queue.\n\n        PARAMETERS:\n            message_count: long\n\n                number of messages purged\n\n                Reports the number of messages purged.\n\n        """'
newline|'\n'
name|'return'
name|'args'
op|'.'
name|'read_long'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|queue_purge
dedent|''
name|'def'
name|'queue_purge'
op|'('
name|'self'
op|','
name|'queue'
op|'='
string|"''"
op|','
name|'nowait'
op|'='
name|'False'
op|','
name|'ticket'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        purge a queue\n\n        This method removes all messages from a queue.  It does not\n        cancel consumers.  Purged messages are deleted without any\n        formal "undo" mechanism.\n\n        RULE:\n\n            A call to purge MUST result in an empty queue.\n\n        RULE:\n\n            On transacted channels the server MUST not purge messages\n            that have already been sent to a client but not yet\n            acknowledged.\n\n        RULE:\n\n            The server MAY implement a purge queue or log that allows\n            system administrators to recover accidentally-purged\n            messages.  The server SHOULD NOT keep purged messages in\n            the same storage spaces as the live messages since the\n            volumes of purged messages may get very large.\n\n        PARAMETERS:\n            queue: shortstr\n\n                Specifies the name of the queue to purge.  If the\n                queue name is empty, refers to the current queue for\n                the channel, which is the last declared queue.\n\n                RULE:\n\n                    If the client did not previously declare a queue,\n                    and the queue name in this method is empty, the\n                    server MUST raise a connection exception with\n                    reply code 530 (not allowed).\n\n                RULE:\n\n                    The queue must exist. Attempting to purge a non-\n                    existing queue causes a channel exception.\n\n            nowait: boolean\n\n                do not send a reply method\n\n                If set, the server will not respond to the method. The\n                client should not wait for a reply method.  If the\n                server could not complete the method it will raise a\n                channel or connection exception.\n\n            ticket: short\n\n                The access ticket must be for the access realm that\n                holds the queue.\n\n                RULE:\n\n                    The client MUST provide a valid access ticket\n                    giving "read" access rights to the queue\'s access\n                    realm.  Note that purging a queue is equivalent to\n                    reading all messages and discarding them.\n\n        if nowait is False, returns a message_count\n\n        """'
newline|'\n'
name|'args'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'if'
name|'ticket'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'args'
op|'.'
name|'write_short'
op|'('
name|'ticket'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'args'
op|'.'
name|'write_short'
op|'('
name|'self'
op|'.'
name|'default_ticket'
op|')'
newline|'\n'
dedent|''
name|'args'
op|'.'
name|'write_shortstr'
op|'('
name|'queue'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'nowait'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'50'
op|','
number|'30'
op|')'
op|','
name|'args'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'nowait'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'wait'
op|'('
name|'allowed_methods'
op|'='
op|'['
nl|'\n'
op|'('
number|'50'
op|','
number|'31'
op|')'
op|','
comment|'# Channel.queue_purge_ok'
nl|'\n'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_queue_purge_ok
dedent|''
dedent|''
name|'def'
name|'_queue_purge_ok'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        confirms a queue purge\n\n        This method confirms the purge of a queue.\n\n        PARAMETERS:\n            message_count: long\n\n                number of messages purged\n\n                Reports the number of messages purged.\n\n        """'
newline|'\n'
name|'return'
name|'args'
op|'.'
name|'read_long'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'#############'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#  Basic'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# work with basic content'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# The Basic class provides methods that support an industry-'
nl|'\n'
comment|'# standard messaging model.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# GRAMMAR:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     basic               = C:QOS S:QOS-OK'
nl|'\n'
comment|'#                         / C:CONSUME S:CONSUME-OK'
nl|'\n'
comment|'#                         / C:CANCEL S:CANCEL-OK'
nl|'\n'
comment|'#                         / C:PUBLISH content'
nl|'\n'
comment|'#                         / S:RETURN content'
nl|'\n'
comment|'#                         / S:DELIVER content'
nl|'\n'
comment|'#                         / C:GET ( S:GET-OK content / S:GET-EMPTY )'
nl|'\n'
comment|'#                         / C:ACK'
nl|'\n'
comment|'#                         / C:REJECT'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# RULE:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     The server SHOULD respect the persistent property of basic'
nl|'\n'
comment|'#     messages and SHOULD make a best-effort to hold persistent'
nl|'\n'
comment|'#     basic messages on a reliable storage mechanism.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# RULE:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     The server MUST NOT discard a persistent basic message in'
nl|'\n'
comment|'#     case of a queue overflow. The server MAY use the'
nl|'\n'
comment|'#     Channel.Flow method to slow or stop a basic message'
nl|'\n'
comment|'#     publisher when necessary.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# RULE:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     The server MAY overflow non-persistent basic messages to'
nl|'\n'
comment|'#     persistent storage and MAY discard or dead-letter non-'
nl|'\n'
comment|'#     persistent basic messages on a priority basis if the queue'
nl|'\n'
comment|'#     size exceeds some configured limit.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# RULE:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     The server MUST implement at least 2 priority levels for'
nl|'\n'
comment|'#     basic messages, where priorities 0-4 and 5-9 are treated as'
nl|'\n'
comment|'#     two distinct levels. The server MAY implement up to 10'
nl|'\n'
comment|'#     priority levels.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# RULE:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     The server MUST deliver messages of the same priority in'
nl|'\n'
comment|'#     order irrespective of their individual persistence.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# RULE:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     The server MUST support both automatic and explicit'
nl|'\n'
comment|'#     acknowledgements on Basic content.'
nl|'\n'
comment|'#'
nl|'\n'
nl|'\n'
DECL|member|basic_ack
dedent|''
name|'def'
name|'basic_ack'
op|'('
name|'self'
op|','
name|'delivery_tag'
op|','
name|'multiple'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        acknowledge one or more messages\n\n        This method acknowledges one or more messages delivered via\n        the Deliver or Get-Ok methods.  The client can ask to confirm\n        a single message or a set of messages up to and including a\n        specific message.\n\n        PARAMETERS:\n            delivery_tag: longlong\n\n                server-assigned delivery tag\n\n                The server-assigned and channel-specific delivery tag\n\n                RULE:\n\n                    The delivery tag is valid only within the channel\n                    from which the message was received.  I.e. a client\n                    MUST NOT receive a message on one channel and then\n                    acknowledge it on another.\n\n                RULE:\n\n                    The server MUST NOT use a zero value for delivery\n                    tags.  Zero is reserved for client use, meaning "all\n                    messages so far received".\n\n            multiple: boolean\n\n                acknowledge multiple messages\n\n                If set to True, the delivery tag is treated as "up to\n                and including", so that the client can acknowledge\n                multiple messages with a single method.  If set to\n                False, the delivery tag refers to a single message.\n                If the multiple field is True, and the delivery tag\n                is zero, tells the server to acknowledge all\n                outstanding mesages.\n\n                RULE:\n\n                    The server MUST validate that a non-zero delivery-\n                    tag refers to an delivered message, and raise a\n                    channel exception if this is not the case.\n\n        """'
newline|'\n'
name|'args'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_longlong'
op|'('
name|'delivery_tag'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'multiple'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'60'
op|','
number|'80'
op|')'
op|','
name|'args'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|basic_cancel
dedent|''
name|'def'
name|'basic_cancel'
op|'('
name|'self'
op|','
name|'consumer_tag'
op|','
name|'nowait'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        end a queue consumer\n\n        This method cancels a consumer. This does not affect already\n        delivered messages, but it does mean the server will not send\n        any more messages for that consumer.  The client may receive\n        an abitrary number of messages in between sending the cancel\n        method and receiving the cancel-ok reply.\n\n        RULE:\n\n            If the queue no longer exists when the client sends a\n            cancel command, or the consumer has been cancelled for\n            other reasons, this command has no effect.\n\n        PARAMETERS:\n            consumer_tag: shortstr\n\n                consumer tag\n\n                Identifier for the consumer, valid within the current\n                connection.\n\n                RULE:\n\n                    The consumer tag is valid only within the channel\n                    from which the consumer was created. I.e. a client\n                    MUST NOT create a consumer in one channel and then\n                    use it in another.\n\n            nowait: boolean\n\n                do not send a reply method\n\n                If set, the server will not respond to the method. The\n                client should not wait for a reply method.  If the\n                server could not complete the method it will raise a\n                channel or connection exception.\n\n        """'
newline|'\n'
name|'args'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_shortstr'
op|'('
name|'consumer_tag'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'nowait'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'60'
op|','
number|'30'
op|')'
op|','
name|'args'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'wait'
op|'('
name|'allowed_methods'
op|'='
op|'['
nl|'\n'
op|'('
number|'60'
op|','
number|'31'
op|')'
op|','
comment|'# Channel.basic_cancel_ok'
nl|'\n'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_basic_cancel_ok
dedent|''
name|'def'
name|'_basic_cancel_ok'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        confirm a cancelled consumer\n\n        This method confirms that the cancellation was completed.\n\n        PARAMETERS:\n            consumer_tag: shortstr\n\n                consumer tag\n\n                Identifier for the consumer, valid within the current\n                connection.\n\n                RULE:\n\n                    The consumer tag is valid only within the channel\n                    from which the consumer was created. I.e. a client\n                    MUST NOT create a consumer in one channel and then\n                    use it in another.\n\n        """'
newline|'\n'
name|'consumer_tag'
op|'='
name|'args'
op|'.'
name|'read_shortstr'
op|'('
op|')'
newline|'\n'
name|'del'
name|'self'
op|'.'
name|'callbacks'
op|'['
name|'consumer_tag'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|basic_consume
dedent|''
name|'def'
name|'basic_consume'
op|'('
name|'self'
op|','
name|'queue'
op|'='
string|"''"
op|','
name|'consumer_tag'
op|'='
string|"''"
op|','
name|'no_local'
op|'='
name|'False'
op|','
nl|'\n'
name|'no_ack'
op|'='
name|'False'
op|','
name|'exclusive'
op|'='
name|'False'
op|','
name|'nowait'
op|'='
name|'False'
op|','
nl|'\n'
name|'callback'
op|'='
name|'None'
op|','
name|'ticket'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        start a queue consumer\n\n        This method asks the server to start a "consumer", which is a\n        transient request for messages from a specific queue.\n        Consumers last as long as the channel they were created on, or\n        until the client cancels them.\n\n        RULE:\n\n            The server SHOULD support at least 16 consumers per queue,\n            unless the queue was declared as private, and ideally,\n            impose no limit except as defined by available resources.\n\n        PARAMETERS:\n            queue: shortstr\n\n                Specifies the name of the queue to consume from.  If\n                the queue name is null, refers to the current queue\n                for the channel, which is the last declared queue.\n\n                RULE:\n\n                    If the client did not previously declare a queue,\n                    and the queue name in this method is empty, the\n                    server MUST raise a connection exception with\n                    reply code 530 (not allowed).\n\n            consumer_tag: shortstr\n\n                Specifies the identifier for the consumer. The\n                consumer tag is local to a connection, so two clients\n                can use the same consumer tags. If this field is empty\n                the server will generate a unique tag.\n\n                RULE:\n\n                    The tag MUST NOT refer to an existing consumer. If\n                    the client attempts to create two consumers with\n                    the same non-empty tag the server MUST raise a\n                    connection exception with reply code 530 (not\n                    allowed).\n\n            no_local: boolean\n\n                do not deliver own messages\n\n                If the no-local field is set the server will not send\n                messages to the client that published them.\n\n            no_ack: boolean\n\n                no acknowledgement needed\n\n                If this field is set the server does not expect\n                acknowledgments for messages.  That is, when a message\n                is delivered to the client the server automatically and\n                silently acknowledges it on behalf of the client.  This\n                functionality increases performance but at the cost of\n                reliability.  Messages can get lost if a client dies\n                before it can deliver them to the application.\n\n            exclusive: boolean\n\n                request exclusive access\n\n                Request exclusive consumer access, meaning only this\n                consumer can access the queue.\n\n                RULE:\n\n                    If the server cannot grant exclusive access to the\n                    queue when asked, - because there are other\n                    consumers active - it MUST raise a channel\n                    exception with return code 403 (access refused).\n\n            nowait: boolean\n\n                do not send a reply method\n\n                If set, the server will not respond to the method. The\n                client should not wait for a reply method.  If the\n                server could not complete the method it will raise a\n                channel or connection exception.\n\n            callback: Python callable\n\n                function/method called with each delivered message\n\n                For each message delivered by the broker, the\n                callable will be called with a Message object\n                as the single argument.  If no callable is specified,\n                messages are quietly discarded, no_ack should probably\n                be set to True in that case.\n\n            ticket: short\n\n                RULE:\n\n                    The client MUST provide a valid access ticket\n                    giving "read" access rights to the realm for the\n                    queue.\n\n        """'
newline|'\n'
name|'args'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'if'
name|'ticket'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'args'
op|'.'
name|'write_short'
op|'('
name|'ticket'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'args'
op|'.'
name|'write_short'
op|'('
name|'self'
op|'.'
name|'default_ticket'
op|')'
newline|'\n'
dedent|''
name|'args'
op|'.'
name|'write_shortstr'
op|'('
name|'queue'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_shortstr'
op|'('
name|'consumer_tag'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'no_local'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'no_ack'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'exclusive'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'nowait'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'60'
op|','
number|'20'
op|')'
op|','
name|'args'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'nowait'
op|':'
newline|'\n'
indent|'            '
name|'consumer_tag'
op|'='
name|'self'
op|'.'
name|'wait'
op|'('
name|'allowed_methods'
op|'='
op|'['
nl|'\n'
op|'('
number|'60'
op|','
number|'21'
op|')'
op|','
comment|'# Channel.basic_consume_ok'
nl|'\n'
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'callbacks'
op|'['
name|'consumer_tag'
op|']'
op|'='
name|'callback'
newline|'\n'
nl|'\n'
name|'return'
name|'consumer_tag'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_basic_consume_ok
dedent|''
name|'def'
name|'_basic_consume_ok'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        confirm a new consumer\n\n        The server provides the client with a consumer tag, which is\n        used by the client for methods called on the consumer at a\n        later stage.\n\n        PARAMETERS:\n            consumer_tag: shortstr\n\n                Holds the consumer tag specified by the client or\n                provided by the server.\n\n        """'
newline|'\n'
name|'return'
name|'args'
op|'.'
name|'read_shortstr'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_basic_deliver
dedent|''
name|'def'
name|'_basic_deliver'
op|'('
name|'self'
op|','
name|'args'
op|','
name|'msg'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        notify the client of a consumer message\n\n        This method delivers a message to the client, via a consumer.\n        In the asynchronous message delivery model, the client starts\n        a consumer using the Consume method, then the server responds\n        with Deliver methods as and when messages arrive for that\n        consumer.\n\n        RULE:\n\n            The server SHOULD track the number of times a message has\n            been delivered to clients and when a message is\n            redelivered a certain number of times - e.g. 5 times -\n            without being acknowledged, the server SHOULD consider the\n            message to be unprocessable (possibly causing client\n            applications to abort), and move the message to a dead\n            letter queue.\n\n        PARAMETERS:\n            consumer_tag: shortstr\n\n                consumer tag\n\n                Identifier for the consumer, valid within the current\n                connection.\n\n                RULE:\n\n                    The consumer tag is valid only within the channel\n                    from which the consumer was created. I.e. a client\n                    MUST NOT create a consumer in one channel and then\n                    use it in another.\n\n            delivery_tag: longlong\n\n                server-assigned delivery tag\n\n                The server-assigned and channel-specific delivery tag\n\n                RULE:\n\n                    The delivery tag is valid only within the channel\n                    from which the message was received.  I.e. a client\n                    MUST NOT receive a message on one channel and then\n                    acknowledge it on another.\n\n                RULE:\n\n                    The server MUST NOT use a zero value for delivery\n                    tags.  Zero is reserved for client use, meaning "all\n                    messages so far received".\n\n            redelivered: boolean\n\n                message is being redelivered\n\n                This indicates that the message has been previously\n                delivered to this or another client.\n\n            exchange: shortstr\n\n                Specifies the name of the exchange that the message\n                was originally published to.\n\n            routing_key: shortstr\n\n                Message routing key\n\n                Specifies the routing key name specified when the\n                message was published.\n\n        """'
newline|'\n'
name|'consumer_tag'
op|'='
name|'args'
op|'.'
name|'read_shortstr'
op|'('
op|')'
newline|'\n'
name|'delivery_tag'
op|'='
name|'args'
op|'.'
name|'read_longlong'
op|'('
op|')'
newline|'\n'
name|'redelivered'
op|'='
name|'args'
op|'.'
name|'read_bit'
op|'('
op|')'
newline|'\n'
name|'exchange'
op|'='
name|'args'
op|'.'
name|'read_shortstr'
op|'('
op|')'
newline|'\n'
name|'routing_key'
op|'='
name|'args'
op|'.'
name|'read_shortstr'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'msg'
op|'.'
name|'delivery_info'
op|'='
op|'{'
nl|'\n'
string|"'channel'"
op|':'
name|'self'
op|','
nl|'\n'
string|"'consumer_tag'"
op|':'
name|'consumer_tag'
op|','
nl|'\n'
string|"'delivery_tag'"
op|':'
name|'delivery_tag'
op|','
nl|'\n'
string|"'redelivered'"
op|':'
name|'redelivered'
op|','
nl|'\n'
string|"'exchange'"
op|':'
name|'exchange'
op|','
nl|'\n'
string|"'routing_key'"
op|':'
name|'routing_key'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
name|'func'
op|'='
name|'self'
op|'.'
name|'callbacks'
op|'.'
name|'get'
op|'('
name|'consumer_tag'
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'func'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'func'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|basic_get
dedent|''
dedent|''
name|'def'
name|'basic_get'
op|'('
name|'self'
op|','
name|'queue'
op|'='
string|"''"
op|','
name|'no_ack'
op|'='
name|'False'
op|','
name|'ticket'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        direct access to a queue\n\n        This method provides a direct access to the messages in a\n        queue using a synchronous dialogue that is designed for\n        specific types of application where synchronous functionality\n        is more important than performance.\n\n        PARAMETERS:\n            queue: shortstr\n\n                Specifies the name of the queue to consume from.  If\n                the queue name is null, refers to the current queue\n                for the channel, which is the last declared queue.\n\n                RULE:\n\n                    If the client did not previously declare a queue,\n                    and the queue name in this method is empty, the\n                    server MUST raise a connection exception with\n                    reply code 530 (not allowed).\n\n            no_ack: boolean\n\n                no acknowledgement needed\n\n                If this field is set the server does not expect\n                acknowledgments for messages.  That is, when a message\n                is delivered to the client the server automatically and\n                silently acknowledges it on behalf of the client.  This\n                functionality increases performance but at the cost of\n                reliability.  Messages can get lost if a client dies\n                before it can deliver them to the application.\n\n            ticket: short\n\n                RULE:\n\n                    The client MUST provide a valid access ticket\n                    giving "read" access rights to the realm for the\n                    queue.\n\n        Non-blocking, returns a message object, or None.\n\n        """'
newline|'\n'
name|'args'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'if'
name|'ticket'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'args'
op|'.'
name|'write_short'
op|'('
name|'ticket'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'args'
op|'.'
name|'write_short'
op|'('
name|'self'
op|'.'
name|'default_ticket'
op|')'
newline|'\n'
dedent|''
name|'args'
op|'.'
name|'write_shortstr'
op|'('
name|'queue'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'no_ack'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'60'
op|','
number|'70'
op|')'
op|','
name|'args'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'wait'
op|'('
name|'allowed_methods'
op|'='
op|'['
nl|'\n'
op|'('
number|'60'
op|','
number|'71'
op|')'
op|','
comment|'# Channel.basic_get_ok'
nl|'\n'
op|'('
number|'60'
op|','
number|'72'
op|')'
op|','
comment|'# Channel.basic_get_empty'
nl|'\n'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_basic_get_empty
dedent|''
name|'def'
name|'_basic_get_empty'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        indicate no messages available\n\n        This method tells the client that the queue has no messages\n        available for the client.\n\n        PARAMETERS:\n            cluster_id: shortstr\n\n                Cluster id\n\n                For use by cluster applications, should not be used by\n                client applications.\n\n        """'
newline|'\n'
name|'cluster_id'
op|'='
name|'args'
op|'.'
name|'read_shortstr'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_basic_get_ok
dedent|''
name|'def'
name|'_basic_get_ok'
op|'('
name|'self'
op|','
name|'args'
op|','
name|'msg'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        provide client with a message\n\n        This method delivers a message to the client following a get\n        method.  A message delivered by \'get-ok\' must be acknowledged\n        unless the no-ack option was set in the get method.\n\n        PARAMETERS:\n            delivery_tag: longlong\n\n                server-assigned delivery tag\n\n                The server-assigned and channel-specific delivery tag\n\n                RULE:\n\n                    The delivery tag is valid only within the channel\n                    from which the message was received.  I.e. a client\n                    MUST NOT receive a message on one channel and then\n                    acknowledge it on another.\n\n                RULE:\n\n                    The server MUST NOT use a zero value for delivery\n                    tags.  Zero is reserved for client use, meaning "all\n                    messages so far received".\n\n            redelivered: boolean\n\n                message is being redelivered\n\n                This indicates that the message has been previously\n                delivered to this or another client.\n\n            exchange: shortstr\n\n                Specifies the name of the exchange that the message\n                was originally published to.  If empty, the message\n                was published to the default exchange.\n\n            routing_key: shortstr\n\n                Message routing key\n\n                Specifies the routing key name specified when the\n                message was published.\n\n            message_count: long\n\n                number of messages pending\n\n                This field reports the number of messages pending on\n                the queue, excluding the message being delivered.\n                Note that this figure is indicative, not reliable, and\n                can change arbitrarily as messages are added to the\n                queue and removed by other clients.\n\n        """'
newline|'\n'
name|'delivery_tag'
op|'='
name|'args'
op|'.'
name|'read_longlong'
op|'('
op|')'
newline|'\n'
name|'redelivered'
op|'='
name|'args'
op|'.'
name|'read_bit'
op|'('
op|')'
newline|'\n'
name|'exchange'
op|'='
name|'args'
op|'.'
name|'read_shortstr'
op|'('
op|')'
newline|'\n'
name|'routing_key'
op|'='
name|'args'
op|'.'
name|'read_shortstr'
op|'('
op|')'
newline|'\n'
name|'message_count'
op|'='
name|'args'
op|'.'
name|'read_long'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'msg'
op|'.'
name|'delivery_info'
op|'='
op|'{'
nl|'\n'
string|"'delivery_tag'"
op|':'
name|'delivery_tag'
op|','
nl|'\n'
string|"'redelivered'"
op|':'
name|'redelivered'
op|','
nl|'\n'
string|"'exchange'"
op|':'
name|'exchange'
op|','
nl|'\n'
string|"'routing_key'"
op|':'
name|'routing_key'
op|','
nl|'\n'
string|"'message_count'"
op|':'
name|'message_count'
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
name|'return'
name|'msg'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|basic_publish
dedent|''
name|'def'
name|'basic_publish'
op|'('
name|'self'
op|','
name|'msg'
op|','
name|'exchange'
op|'='
string|"''"
op|','
name|'routing_key'
op|'='
string|"''"
op|','
nl|'\n'
name|'mandatory'
op|'='
name|'False'
op|','
name|'immediate'
op|'='
name|'False'
op|','
name|'ticket'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        publish a message\n\n        This method publishes a message to a specific exchange. The\n        message will be routed to queues as defined by the exchange\n        configuration and distributed to any active consumers when the\n        transaction, if any, is committed.\n\n        PARAMETERS:\n            exchange: shortstr\n\n                Specifies the name of the exchange to publish to.  The\n                exchange name can be empty, meaning the default\n                exchange.  If the exchange name is specified, and that\n                exchange does not exist, the server will raise a\n                channel exception.\n\n                RULE:\n\n                    The server MUST accept a blank exchange name to\n                    mean the default exchange.\n\n                RULE:\n\n                    If the exchange was declared as an internal\n                    exchange, the server MUST raise a channel\n                    exception with a reply code 403 (access refused).\n\n                RULE:\n\n                    The exchange MAY refuse basic content in which\n                    case it MUST raise a channel exception with reply\n                    code 540 (not implemented).\n\n            routing_key: shortstr\n\n                Message routing key\n\n                Specifies the routing key for the message.  The\n                routing key is used for routing messages depending on\n                the exchange configuration.\n\n            mandatory: boolean\n\n                indicate mandatory routing\n\n                This flag tells the server how to react if the message\n                cannot be routed to a queue.  If this flag is True, the\n                server will return an unroutable message with a Return\n                method.  If this flag is False, the server silently\n                drops the message.\n\n                RULE:\n\n                    The server SHOULD implement the mandatory flag.\n\n            immediate: boolean\n\n                request immediate delivery\n\n                This flag tells the server how to react if the message\n                cannot be routed to a queue consumer immediately.  If\n                this flag is set, the server will return an\n                undeliverable message with a Return method. If this\n                flag is zero, the server will queue the message, but\n                with no guarantee that it will ever be consumed.\n\n                RULE:\n\n                    The server SHOULD implement the immediate flag.\n\n            ticket: short\n\n                RULE:\n\n                    The client MUST provide a valid access ticket\n                    giving "write" access rights to the access realm\n                    for the exchange.\n\n        """'
newline|'\n'
name|'args'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'if'
name|'ticket'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'args'
op|'.'
name|'write_short'
op|'('
name|'ticket'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'args'
op|'.'
name|'write_short'
op|'('
name|'self'
op|'.'
name|'default_ticket'
op|')'
newline|'\n'
dedent|''
name|'args'
op|'.'
name|'write_shortstr'
op|'('
name|'exchange'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_shortstr'
op|'('
name|'routing_key'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'mandatory'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'immediate'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'60'
op|','
number|'40'
op|')'
op|','
name|'args'
op|','
name|'msg'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|basic_qos
dedent|''
name|'def'
name|'basic_qos'
op|'('
name|'self'
op|','
name|'prefetch_size'
op|','
name|'prefetch_count'
op|','
name|'a_global'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        specify quality of service\n\n        This method requests a specific quality of service.  The QoS\n        can be specified for the current channel or for all channels\n        on the connection.  The particular properties and semantics of\n        a qos method always depend on the content class semantics.\n        Though the qos method could in principle apply to both peers,\n        it is currently meaningful only for the server.\n\n        PARAMETERS:\n            prefetch_size: long\n\n                prefetch window in octets\n\n                The client can request that messages be sent in\n                advance so that when the client finishes processing a\n                message, the following message is already held\n                locally, rather than needing to be sent down the\n                channel.  Prefetching gives a performance improvement.\n                This field specifies the prefetch window size in\n                octets.  The server will send a message in advance if\n                it is equal to or smaller in size than the available\n                prefetch size (and also falls into other prefetch\n                limits). May be set to zero, meaning "no specific\n                limit", although other prefetch limits may still\n                apply. The prefetch-size is ignored if the no-ack\n                option is set.\n\n                RULE:\n\n                    The server MUST ignore this setting when the\n                    client is not processing any messages - i.e. the\n                    prefetch size does not limit the transfer of\n                    single messages to a client, only the sending in\n                    advance of more messages while the client still\n                    has one or more unacknowledged messages.\n\n            prefetch_count: short\n\n                prefetch window in messages\n\n                Specifies a prefetch window in terms of whole\n                messages.  This field may be used in combination with\n                the prefetch-size field; a message will only be sent\n                in advance if both prefetch windows (and those at the\n                channel and connection level) allow it. The prefetch-\n                count is ignored if the no-ack option is set.\n\n                RULE:\n\n                    The server MAY send less data in advance than\n                    allowed by the client\'s specified prefetch windows\n                    but it MUST NOT send more.\n\n            a_global: boolean\n\n                apply to entire connection\n\n                By default the QoS settings apply to the current\n                channel only.  If this field is set, they are applied\n                to the entire connection.\n\n        """'
newline|'\n'
name|'args'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_long'
op|'('
name|'prefetch_size'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_short'
op|'('
name|'prefetch_count'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'a_global'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'60'
op|','
number|'10'
op|')'
op|','
name|'args'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'wait'
op|'('
name|'allowed_methods'
op|'='
op|'['
nl|'\n'
op|'('
number|'60'
op|','
number|'11'
op|')'
op|','
comment|'# Channel.basic_qos_ok'
nl|'\n'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_basic_qos_ok
dedent|''
name|'def'
name|'_basic_qos_ok'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        confirm the requested qos\n\n        This method tells the client that the requested QoS levels\n        could be handled by the server.  The requested QoS applies to\n        all active consumers until a new QoS is defined.\n\n        """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|basic_recover
dedent|''
name|'def'
name|'basic_recover'
op|'('
name|'self'
op|','
name|'requeue'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        redeliver unacknowledged messages\n\n        This method asks the broker to redeliver all unacknowledged\n        messages on a specified channel. Zero or more messages may be\n        redelivered.  This method is only allowed on non-transacted\n        channels.\n\n        RULE:\n\n            The server MUST set the redelivered flag on all messages\n            that are resent.\n\n        RULE:\n\n            The server MUST raise a channel exception if this is\n            called on a transacted channel.\n\n        PARAMETERS:\n            requeue: boolean\n\n                requeue the message\n\n                If this field is False, the message will be redelivered\n                to the original recipient.  If this field is True, the\n                server will attempt to requeue the message,\n                potentially then delivering it to an alternative\n                subscriber.\n\n        """'
newline|'\n'
name|'args'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'requeue'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'60'
op|','
number|'100'
op|')'
op|','
name|'args'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|basic_reject
dedent|''
name|'def'
name|'basic_reject'
op|'('
name|'self'
op|','
name|'delivery_tag'
op|','
name|'requeue'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        reject an incoming message\n\n        This method allows a client to reject a message.  It can be\n        used to interrupt and cancel large incoming messages, or\n        return untreatable messages to their original queue.\n\n        RULE:\n\n            The server SHOULD be capable of accepting and process the\n            Reject method while sending message content with a Deliver\n            or Get-Ok method.  I.e. the server should read and process\n            incoming methods while sending output frames.  To cancel a\n            partially-send content, the server sends a content body\n            frame of size 1 (i.e. with no data except the frame-end\n            octet).\n\n        RULE:\n\n            The server SHOULD interpret this method as meaning that\n            the client is unable to process the message at this time.\n\n        RULE:\n\n            A client MUST NOT use this method as a means of selecting\n            messages to process.  A rejected message MAY be discarded\n            or dead-lettered, not necessarily passed to another\n            client.\n\n        PARAMETERS:\n            delivery_tag: longlong\n\n                server-assigned delivery tag\n\n                The server-assigned and channel-specific delivery tag\n\n                RULE:\n\n                    The delivery tag is valid only within the channel\n                    from which the message was received.  I.e. a client\n                    MUST NOT receive a message on one channel and then\n                    acknowledge it on another.\n\n                RULE:\n\n                    The server MUST NOT use a zero value for delivery\n                    tags.  Zero is reserved for client use, meaning "all\n                    messages so far received".\n\n            requeue: boolean\n\n                requeue the message\n\n                If this field is False, the message will be discarded.\n                If this field is True, the server will attempt to\n                requeue the message.\n\n                RULE:\n\n                    The server MUST NOT deliver the message to the\n                    same client within the context of the current\n                    channel.  The recommended strategy is to attempt\n                    to deliver the message to an alternative consumer,\n                    and if that is not possible, to move the message\n                    to a dead-letter queue.  The server MAY use more\n                    sophisticated tracking to hold the message on the\n                    queue and redeliver it to the same client at a\n                    later stage.\n\n        """'
newline|'\n'
name|'args'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_longlong'
op|'('
name|'delivery_tag'
op|')'
newline|'\n'
name|'args'
op|'.'
name|'write_bit'
op|'('
name|'requeue'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'60'
op|','
number|'90'
op|')'
op|','
name|'args'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_basic_return
dedent|''
name|'def'
name|'_basic_return'
op|'('
name|'self'
op|','
name|'args'
op|','
name|'msg'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        return a failed message\n\n        This method returns an undeliverable message that was\n        published with the "immediate" flag set, or an unroutable\n        message published with the "mandatory" flag set. The reply\n        code and text provide information about the reason that the\n        message was undeliverable.\n\n        PARAMETERS:\n            reply_code: short\n\n                The reply code. The AMQ reply codes are defined in AMQ\n                RFC 011.\n\n            reply_text: shortstr\n\n                The localised reply text.  This text can be logged as an\n                aid to resolving issues.\n\n            exchange: shortstr\n\n                Specifies the name of the exchange that the message\n                was originally published to.\n\n            routing_key: shortstr\n\n                Message routing key\n\n                Specifies the routing key name specified when the\n                message was published.\n\n        """'
newline|'\n'
name|'reply_code'
op|'='
name|'args'
op|'.'
name|'read_short'
op|'('
op|')'
newline|'\n'
name|'reply_text'
op|'='
name|'args'
op|'.'
name|'read_shortstr'
op|'('
op|')'
newline|'\n'
name|'exchange'
op|'='
name|'args'
op|'.'
name|'read_shortstr'
op|'('
op|')'
newline|'\n'
name|'routing_key'
op|'='
name|'args'
op|'.'
name|'read_shortstr'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'returned_messages'
op|'.'
name|'put'
op|'('
nl|'\n'
op|'('
name|'reply_code'
op|','
name|'reply_text'
op|','
name|'exchange'
op|','
name|'routing_key'
op|','
name|'msg'
op|')'
nl|'\n'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'#############'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#  Tx'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# work with standard transactions'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Standard transactions provide so-called "1.5 phase commit".  We'
nl|'\n'
comment|'# can ensure that work is never lost, but there is a chance of'
nl|'\n'
comment|'# confirmations being lost, so that messages may be resent.'
nl|'\n'
comment|'# Applications that use standard transactions must be able to'
nl|'\n'
comment|'# detect and ignore duplicate messages.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# GRAMMAR:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     tx                  = C:SELECT S:SELECT-OK'
nl|'\n'
comment|'#                         / C:COMMIT S:COMMIT-OK'
nl|'\n'
comment|'#                         / C:ROLLBACK S:ROLLBACK-OK'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# RULE:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     An client using standard transactions SHOULD be able to'
nl|'\n'
comment|'#     track all messages received within a reasonable period, and'
nl|'\n'
comment|'#     thus detect and reject duplicates of the same message. It'
nl|'\n'
comment|'#     SHOULD NOT pass these to the application layer.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#'
nl|'\n'
nl|'\n'
DECL|member|tx_commit
dedent|''
name|'def'
name|'tx_commit'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        commit the current transaction\n\n        This method commits all messages published and acknowledged in\n        the current transaction.  A new transaction starts immediately\n        after a commit.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'90'
op|','
number|'20'
op|')'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'wait'
op|'('
name|'allowed_methods'
op|'='
op|'['
nl|'\n'
op|'('
number|'90'
op|','
number|'21'
op|')'
op|','
comment|'# Channel.tx_commit_ok'
nl|'\n'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_tx_commit_ok
dedent|''
name|'def'
name|'_tx_commit_ok'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        confirm a successful commit\n\n        This method confirms to the client that the commit succeeded.\n        Note that if a commit fails, the server raises a channel\n        exception.\n\n        """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tx_rollback
dedent|''
name|'def'
name|'tx_rollback'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        abandon the current transaction\n\n        This method abandons all messages published and acknowledged\n        in the current transaction.  A new transaction starts\n        immediately after a rollback.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'90'
op|','
number|'30'
op|')'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'wait'
op|'('
name|'allowed_methods'
op|'='
op|'['
nl|'\n'
op|'('
number|'90'
op|','
number|'31'
op|')'
op|','
comment|'# Channel.tx_rollback_ok'
nl|'\n'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_tx_rollback_ok
dedent|''
name|'def'
name|'_tx_rollback_ok'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        confirm a successful rollback\n\n        This method confirms to the client that the rollback\n        succeeded. Note that if an rollback fails, the server raises a\n        channel exception.\n\n        """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|tx_select
dedent|''
name|'def'
name|'tx_select'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        select standard transaction mode\n\n        This method sets the channel to use standard transactions.\n        The client must use this method at least once on a channel\n        before using the Commit or Rollback methods.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_send_method'
op|'('
op|'('
number|'90'
op|','
number|'10'
op|')'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'wait'
op|'('
name|'allowed_methods'
op|'='
op|'['
nl|'\n'
op|'('
number|'90'
op|','
number|'11'
op|')'
op|','
comment|'# Channel.tx_select_ok'
nl|'\n'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_tx_select_ok
dedent|''
name|'def'
name|'_tx_select_ok'
op|'('
name|'self'
op|','
name|'args'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        confirm transaction mode\n\n        This method confirms to the client that the channel was\n        successfully set to use standard transactions.\n\n        """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|_METHOD_MAP
dedent|''
name|'_METHOD_MAP'
op|'='
op|'{'
nl|'\n'
op|'('
number|'20'
op|','
number|'11'
op|')'
op|':'
name|'_open_ok'
op|','
nl|'\n'
op|'('
number|'20'
op|','
number|'20'
op|')'
op|':'
name|'_flow'
op|','
nl|'\n'
op|'('
number|'20'
op|','
number|'21'
op|')'
op|':'
name|'_flow_ok'
op|','
nl|'\n'
op|'('
number|'20'
op|','
number|'30'
op|')'
op|':'
name|'_alert'
op|','
nl|'\n'
op|'('
number|'20'
op|','
number|'40'
op|')'
op|':'
name|'_close'
op|','
nl|'\n'
op|'('
number|'20'
op|','
number|'41'
op|')'
op|':'
name|'_close_ok'
op|','
nl|'\n'
op|'('
number|'30'
op|','
number|'11'
op|')'
op|':'
name|'_access_request_ok'
op|','
nl|'\n'
op|'('
number|'40'
op|','
number|'11'
op|')'
op|':'
name|'_exchange_declare_ok'
op|','
nl|'\n'
op|'('
number|'40'
op|','
number|'21'
op|')'
op|':'
name|'_exchange_delete_ok'
op|','
nl|'\n'
op|'('
number|'50'
op|','
number|'11'
op|')'
op|':'
name|'_queue_declare_ok'
op|','
nl|'\n'
op|'('
number|'50'
op|','
number|'21'
op|')'
op|':'
name|'_queue_bind_ok'
op|','
nl|'\n'
op|'('
number|'50'
op|','
number|'31'
op|')'
op|':'
name|'_queue_purge_ok'
op|','
nl|'\n'
op|'('
number|'50'
op|','
number|'41'
op|')'
op|':'
name|'_queue_delete_ok'
op|','
nl|'\n'
op|'('
number|'60'
op|','
number|'11'
op|')'
op|':'
name|'_basic_qos_ok'
op|','
nl|'\n'
op|'('
number|'60'
op|','
number|'21'
op|')'
op|':'
name|'_basic_consume_ok'
op|','
nl|'\n'
op|'('
number|'60'
op|','
number|'31'
op|')'
op|':'
name|'_basic_cancel_ok'
op|','
nl|'\n'
op|'('
number|'60'
op|','
number|'50'
op|')'
op|':'
name|'_basic_return'
op|','
nl|'\n'
op|'('
number|'60'
op|','
number|'60'
op|')'
op|':'
name|'_basic_deliver'
op|','
nl|'\n'
op|'('
number|'60'
op|','
number|'71'
op|')'
op|':'
name|'_basic_get_ok'
op|','
nl|'\n'
op|'('
number|'60'
op|','
number|'72'
op|')'
op|':'
name|'_basic_get_empty'
op|','
nl|'\n'
op|'('
number|'90'
op|','
number|'11'
op|')'
op|':'
name|'_tx_select_ok'
op|','
nl|'\n'
op|'('
number|'90'
op|','
number|'21'
op|')'
op|':'
name|'_tx_commit_ok'
op|','
nl|'\n'
op|'('
number|'90'
op|','
number|'31'
op|')'
op|':'
name|'_tx_rollback_ok'
op|','
nl|'\n'
op|'}'
newline|'\n'
dedent|''
endmarker|''
end_unit
