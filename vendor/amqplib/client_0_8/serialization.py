begin_unit
string|'"""\nConvert between bytestreams and higher-level AMQP types.\n\n2007-11-05 Barry Pederson <bp@barryp.org>\n\n"""'
newline|'\n'
comment|'# Copyright (C) 2007 Barry Pederson <bp@barryp.org>'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# This library is free software; you can redistribute it and/or'
nl|'\n'
comment|'# modify it under the terms of the GNU Lesser General Public'
nl|'\n'
comment|'# License as published by the Free Software Foundation; either'
nl|'\n'
comment|'# version 2.1 of the License, or (at your option) any later version.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# This library is distributed in the hope that it will be useful,'
nl|'\n'
comment|'# but WITHOUT ANY WARRANTY; without even the implied warranty of'
nl|'\n'
comment|'# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU'
nl|'\n'
comment|'# Lesser General Public License for more details.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# You should have received a copy of the GNU Lesser General Public'
nl|'\n'
comment|'# License along with this library; if not, write to the Free Software'
nl|'\n'
comment|'# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301'
nl|'\n'
nl|'\n'
name|'import'
name|'string'
newline|'\n'
name|'from'
name|'datetime'
name|'import'
name|'datetime'
newline|'\n'
name|'from'
name|'decimal'
name|'import'
name|'Decimal'
newline|'\n'
name|'from'
name|'struct'
name|'import'
name|'pack'
op|','
name|'unpack'
newline|'\n'
name|'from'
name|'time'
name|'import'
name|'mktime'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'from'
name|'cStringIO'
name|'import'
name|'StringIO'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
indent|'    '
name|'from'
name|'StringIO'
name|'import'
name|'StringIO'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|DUMP_CHARS
dedent|''
name|'DUMP_CHARS'
op|'='
name|'string'
op|'.'
name|'letters'
op|'+'
name|'string'
op|'.'
name|'digits'
op|'+'
name|'string'
op|'.'
name|'punctuation'
newline|'\n'
nl|'\n'
DECL|function|_hexdump
name|'def'
name|'_hexdump'
op|'('
name|'s'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Present just for debugging help.\n\n    """'
newline|'\n'
name|'while'
name|'s'
op|':'
newline|'\n'
indent|'        '
name|'x'
op|','
name|'s'
op|'='
name|'s'
op|'['
op|':'
number|'16'
op|']'
op|','
name|'s'
op|'['
number|'16'
op|':'
op|']'
newline|'\n'
nl|'\n'
name|'hex'
op|'='
op|'['
string|"'%02x'"
op|'%'
name|'ord'
op|'('
name|'ch'
op|')'
name|'for'
name|'ch'
name|'in'
name|'x'
op|']'
newline|'\n'
name|'hex'
op|'='
string|"' '"
op|'.'
name|'join'
op|'('
name|'hex'
op|')'
op|'.'
name|'ljust'
op|'('
number|'50'
op|')'
newline|'\n'
nl|'\n'
name|'char_dump'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'ch'
name|'in'
name|'x'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'ch'
name|'in'
name|'DUMP_CHARS'
op|':'
newline|'\n'
indent|'                '
name|'char_dump'
op|'.'
name|'append'
op|'('
name|'ch'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'char_dump'
op|'.'
name|'append'
op|'('
string|"'.'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'print'
name|'hex'
op|'+'
string|"''"
op|'.'
name|'join'
op|'('
name|'char_dump'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|AMQPReader
dedent|''
dedent|''
name|'class'
name|'AMQPReader'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Read higher-level AMQP types from a bytestream.\n\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'source'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Source should be either a file-like object with a read() method, or\n        a plain (non-unicode) string.\n\n        """'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'source'
op|','
name|'str'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'input'
op|'='
name|'StringIO'
op|'('
name|'source'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'hasattr'
op|'('
name|'source'
op|','
string|"'read'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'input'
op|'='
name|'source'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|"'AMQPReader needs a file-like object or plain string'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'bitcount'
op|'='
name|'self'
op|'.'
name|'bits'
op|'='
number|'0'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|close
dedent|''
name|'def'
name|'close'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'input'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|read
dedent|''
name|'def'
name|'read'
op|'('
name|'self'
op|','
name|'n'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Read n bytes.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'bitcount'
op|'='
name|'self'
op|'.'
name|'bits'
op|'='
number|'0'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'input'
op|'.'
name|'read'
op|'('
name|'n'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|read_bit
dedent|''
name|'def'
name|'read_bit'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Read a single boolean value.\n\n        """'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'bitcount'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'bits'
op|'='
name|'ord'
op|'('
name|'self'
op|'.'
name|'input'
op|'.'
name|'read'
op|'('
number|'1'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'bitcount'
op|'='
number|'8'
newline|'\n'
dedent|''
name|'result'
op|'='
op|'('
name|'self'
op|'.'
name|'bits'
op|'&'
number|'1'
op|')'
op|'=='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'bits'
op|'>>='
number|'1'
newline|'\n'
name|'self'
op|'.'
name|'bitcount'
op|'-='
number|'1'
newline|'\n'
name|'return'
name|'result'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|read_octet
dedent|''
name|'def'
name|'read_octet'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Read one byte, return as an integer\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'bitcount'
op|'='
name|'self'
op|'.'
name|'bits'
op|'='
number|'0'
newline|'\n'
name|'return'
name|'unpack'
op|'('
string|"'B'"
op|','
name|'self'
op|'.'
name|'input'
op|'.'
name|'read'
op|'('
number|'1'
op|')'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|read_short
dedent|''
name|'def'
name|'read_short'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Read an unsigned 16-bit integer\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'bitcount'
op|'='
name|'self'
op|'.'
name|'bits'
op|'='
number|'0'
newline|'\n'
name|'return'
name|'unpack'
op|'('
string|"'>H'"
op|','
name|'self'
op|'.'
name|'input'
op|'.'
name|'read'
op|'('
number|'2'
op|')'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|read_long
dedent|''
name|'def'
name|'read_long'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Read an unsigned 32-bit integer\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'bitcount'
op|'='
name|'self'
op|'.'
name|'bits'
op|'='
number|'0'
newline|'\n'
name|'return'
name|'unpack'
op|'('
string|"'>I'"
op|','
name|'self'
op|'.'
name|'input'
op|'.'
name|'read'
op|'('
number|'4'
op|')'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|read_longlong
dedent|''
name|'def'
name|'read_longlong'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Read an unsigned 64-bit integer\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'bitcount'
op|'='
name|'self'
op|'.'
name|'bits'
op|'='
number|'0'
newline|'\n'
name|'return'
name|'unpack'
op|'('
string|"'>Q'"
op|','
name|'self'
op|'.'
name|'input'
op|'.'
name|'read'
op|'('
number|'8'
op|')'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|read_shortstr
dedent|''
name|'def'
name|'read_shortstr'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Read a utf-8 encoded string that\'s stored in up to\n        255 bytes.  Return it decoded as a Python unicode object.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'bitcount'
op|'='
name|'self'
op|'.'
name|'bits'
op|'='
number|'0'
newline|'\n'
name|'slen'
op|'='
name|'unpack'
op|'('
string|"'B'"
op|','
name|'self'
op|'.'
name|'input'
op|'.'
name|'read'
op|'('
number|'1'
op|')'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'input'
op|'.'
name|'read'
op|'('
name|'slen'
op|')'
op|'.'
name|'decode'
op|'('
string|"'utf-8'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|read_longstr
dedent|''
name|'def'
name|'read_longstr'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Read a string that\'s up to 2**32 bytes, the encoding\n        isn\'t specified in the AMQP spec, so just return it as\n        a plain Python string.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'bitcount'
op|'='
name|'self'
op|'.'
name|'bits'
op|'='
number|'0'
newline|'\n'
name|'slen'
op|'='
name|'unpack'
op|'('
string|"'>I'"
op|','
name|'self'
op|'.'
name|'input'
op|'.'
name|'read'
op|'('
number|'4'
op|')'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'input'
op|'.'
name|'read'
op|'('
name|'slen'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|read_table
dedent|''
name|'def'
name|'read_table'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Read an AMQP table, and return as a Python dictionary.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'bitcount'
op|'='
name|'self'
op|'.'
name|'bits'
op|'='
number|'0'
newline|'\n'
name|'tlen'
op|'='
name|'unpack'
op|'('
string|"'>I'"
op|','
name|'self'
op|'.'
name|'input'
op|'.'
name|'read'
op|'('
number|'4'
op|')'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'table_data'
op|'='
name|'AMQPReader'
op|'('
name|'self'
op|'.'
name|'input'
op|'.'
name|'read'
op|'('
name|'tlen'
op|')'
op|')'
newline|'\n'
name|'result'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'while'
name|'table_data'
op|'.'
name|'input'
op|'.'
name|'tell'
op|'('
op|')'
op|'<'
name|'tlen'
op|':'
newline|'\n'
indent|'            '
name|'name'
op|'='
name|'table_data'
op|'.'
name|'read_shortstr'
op|'('
op|')'
newline|'\n'
name|'ftype'
op|'='
name|'table_data'
op|'.'
name|'input'
op|'.'
name|'read'
op|'('
number|'1'
op|')'
newline|'\n'
name|'if'
name|'ftype'
op|'=='
string|"'S'"
op|':'
newline|'\n'
indent|'                '
name|'val'
op|'='
name|'table_data'
op|'.'
name|'read_longstr'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'ftype'
op|'=='
string|"'I'"
op|':'
newline|'\n'
indent|'                '
name|'val'
op|'='
name|'unpack'
op|'('
string|"'>i'"
op|','
name|'table_data'
op|'.'
name|'input'
op|'.'
name|'read'
op|'('
number|'4'
op|')'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
dedent|''
name|'elif'
name|'ftype'
op|'=='
string|"'D'"
op|':'
newline|'\n'
indent|'                '
name|'d'
op|'='
name|'table_data'
op|'.'
name|'read_octet'
op|'('
op|')'
newline|'\n'
name|'n'
op|'='
name|'unpack'
op|'('
string|"'>i'"
op|','
name|'table_data'
op|'.'
name|'input'
op|'.'
name|'read'
op|'('
number|'4'
op|')'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'val'
op|'='
name|'Decimal'
op|'('
name|'n'
op|')'
op|'/'
name|'Decimal'
op|'('
number|'10'
op|'**'
name|'d'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'ftype'
op|'=='
string|"'T'"
op|':'
newline|'\n'
indent|'                '
name|'val'
op|'='
name|'table_data'
op|'.'
name|'read_timestamp'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'ftype'
op|'=='
string|"'F'"
op|':'
newline|'\n'
indent|'                '
name|'val'
op|'='
name|'table_data'
op|'.'
name|'read_table'
op|'('
op|')'
comment|'# recurse'
newline|'\n'
dedent|''
name|'result'
op|'['
name|'name'
op|']'
op|'='
name|'val'
newline|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|read_timestamp
dedent|''
name|'def'
name|'read_timestamp'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Read and AMQP timestamp, which is a 64-bit integer representing\n        seconds since the Unix epoch in 1-second resolution.  Return as\n        a Python datetime.datetime object, expressed as localtime.\n\n        """'
newline|'\n'
name|'return'
name|'datetime'
op|'.'
name|'fromtimestamp'
op|'('
name|'self'
op|'.'
name|'read_longlong'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|AMQPWriter
dedent|''
dedent|''
name|'class'
name|'AMQPWriter'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Convert higher-level AMQP types to bytestreams.\n\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'dest'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        dest may be a file-type object (with a write() method).  If None\n        then a StringIO is created, and the contents can be accessed with\n        this class\'s getvalue() method.\n\n        """'
newline|'\n'
name|'if'
name|'dest'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'out'
op|'='
name|'StringIO'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'out'
op|'='
name|'dest'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'bits'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'bitcount'
op|'='
number|'0'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_flushbits
dedent|''
name|'def'
name|'_flushbits'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'bits'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'b'
name|'in'
name|'self'
op|'.'
name|'bits'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'out'
op|'.'
name|'write'
op|'('
name|'pack'
op|'('
string|"'B'"
op|','
name|'b'
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'bits'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'bitcount'
op|'='
number|'0'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|close
dedent|''
dedent|''
name|'def'
name|'close'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Pass through if possible to any file-like destinations.\n\n        """'
newline|'\n'
name|'if'
name|'hasattr'
op|'('
name|'self'
op|'.'
name|'out'
op|','
string|"'close'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'out'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|flush
dedent|''
dedent|''
name|'def'
name|'flush'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Pass through if possible to any file-like destinations.\n\n        """'
newline|'\n'
name|'if'
name|'hasattr'
op|'('
name|'self'
op|'.'
name|'out'
op|','
string|"'flush'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'out'
op|'.'
name|'flush'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|getvalue
dedent|''
dedent|''
name|'def'
name|'getvalue'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Get what\'s been encoded so far if we\'re working with a StringIO.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_flushbits'
op|'('
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'out'
op|'.'
name|'getvalue'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|write
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'s'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write a plain Python string, with no special encoding.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_flushbits'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'out'
op|'.'
name|'write'
op|'('
name|'s'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|write_bit
dedent|''
name|'def'
name|'write_bit'
op|'('
name|'self'
op|','
name|'b'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write a boolean value.\n\n        """'
newline|'\n'
name|'if'
name|'b'
op|':'
newline|'\n'
indent|'            '
name|'b'
op|'='
number|'1'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'b'
op|'='
number|'0'
newline|'\n'
dedent|''
name|'shift'
op|'='
name|'self'
op|'.'
name|'bitcount'
op|'%'
number|'8'
newline|'\n'
name|'if'
name|'shift'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'bits'
op|'.'
name|'append'
op|'('
number|'0'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'bits'
op|'['
op|'-'
number|'1'
op|']'
op|'|='
op|'('
name|'b'
op|'<<'
name|'shift'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'bitcount'
op|'+='
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|write_octet
dedent|''
name|'def'
name|'write_octet'
op|'('
name|'self'
op|','
name|'n'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write an integer as an unsigned 8-bit value.\n\n        """'
newline|'\n'
name|'if'
op|'('
name|'n'
op|'<'
number|'0'
op|')'
name|'or'
op|'('
name|'n'
op|'>'
number|'255'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|"'Octet out of range 0..255'"
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_flushbits'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'out'
op|'.'
name|'write'
op|'('
name|'pack'
op|'('
string|"'B'"
op|','
name|'n'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|write_short
dedent|''
name|'def'
name|'write_short'
op|'('
name|'self'
op|','
name|'n'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write an integer as an unsigned 16-bit value.\n\n        """'
newline|'\n'
name|'if'
op|'('
name|'n'
op|'<'
number|'0'
op|')'
name|'or'
op|'('
name|'n'
op|'>'
number|'65535'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|"'Octet out of range 0..65535'"
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_flushbits'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'out'
op|'.'
name|'write'
op|'('
name|'pack'
op|'('
string|"'>H'"
op|','
name|'n'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|write_long
dedent|''
name|'def'
name|'write_long'
op|'('
name|'self'
op|','
name|'n'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write an integer as an unsigned2 32-bit value.\n\n        """'
newline|'\n'
name|'if'
op|'('
name|'n'
op|'<'
number|'0'
op|')'
name|'or'
op|'('
name|'n'
op|'>='
op|'('
number|'2'
op|'**'
number|'32'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|"'Octet out of range 0..2**31-1'"
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_flushbits'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'out'
op|'.'
name|'write'
op|'('
name|'pack'
op|'('
string|"'>I'"
op|','
name|'n'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|write_longlong
dedent|''
name|'def'
name|'write_longlong'
op|'('
name|'self'
op|','
name|'n'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write an integer as an unsigned 64-bit value.\n\n        """'
newline|'\n'
name|'if'
op|'('
name|'n'
op|'<'
number|'0'
op|')'
name|'or'
op|'('
name|'n'
op|'>='
op|'('
number|'2'
op|'**'
number|'64'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|"'Octet out of range 0..2**64-1'"
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_flushbits'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'out'
op|'.'
name|'write'
op|'('
name|'pack'
op|'('
string|"'>Q'"
op|','
name|'n'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|write_shortstr
dedent|''
name|'def'
name|'write_shortstr'
op|'('
name|'self'
op|','
name|'s'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write a string up to 255 bytes long after encoding.  If passed\n        a unicode string, encode as UTF-8.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_flushbits'
op|'('
op|')'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'s'
op|','
name|'unicode'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'s'
op|'='
name|'s'
op|'.'
name|'encode'
op|'('
string|"'utf-8'"
op|')'
newline|'\n'
dedent|''
name|'if'
name|'len'
op|'('
name|'s'
op|')'
op|'>'
number|'255'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|"'String too long'"
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'write_octet'
op|'('
name|'len'
op|'('
name|'s'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'out'
op|'.'
name|'write'
op|'('
name|'s'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|write_longstr
dedent|''
name|'def'
name|'write_longstr'
op|'('
name|'self'
op|','
name|'s'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write a string up to 2**32 bytes long after encoding.  If passed\n        a unicode string, encode as UTF-8.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_flushbits'
op|'('
op|')'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'s'
op|','
name|'unicode'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'s'
op|'='
name|'s'
op|'.'
name|'encode'
op|'('
string|"'utf-8'"
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'write_long'
op|'('
name|'len'
op|'('
name|'s'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'out'
op|'.'
name|'write'
op|'('
name|'s'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|write_table
dedent|''
name|'def'
name|'write_table'
op|'('
name|'self'
op|','
name|'d'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write out a Python dictionary made of up string keys, and values\n        that are strings, signed integers, Decimal, datetime.datetime, or\n        sub-dictionaries following the same constraints.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_flushbits'
op|'('
op|')'
newline|'\n'
name|'table_data'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'for'
name|'k'
op|','
name|'v'
name|'in'
name|'d'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'table_data'
op|'.'
name|'write_shortstr'
op|'('
name|'k'
op|')'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'v'
op|','
name|'basestring'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'isinstance'
op|'('
name|'v'
op|','
name|'unicode'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'v'
op|'='
name|'v'
op|'.'
name|'encode'
op|'('
string|"'utf-8'"
op|')'
newline|'\n'
dedent|''
name|'table_data'
op|'.'
name|'write'
op|'('
string|"'S'"
op|')'
newline|'\n'
name|'table_data'
op|'.'
name|'write_longstr'
op|'('
name|'v'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'isinstance'
op|'('
name|'v'
op|','
op|'('
name|'int'
op|','
name|'long'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'table_data'
op|'.'
name|'write'
op|'('
string|"'I'"
op|')'
newline|'\n'
name|'table_data'
op|'.'
name|'write'
op|'('
name|'pack'
op|'('
string|"'>i'"
op|','
name|'v'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'isinstance'
op|'('
name|'v'
op|','
name|'Decimal'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'table_data'
op|'.'
name|'write'
op|'('
string|"'D'"
op|')'
newline|'\n'
name|'sign'
op|','
name|'digits'
op|','
name|'exponent'
op|'='
name|'v'
op|'.'
name|'as_tuple'
op|'('
op|')'
newline|'\n'
name|'v'
op|'='
number|'0'
newline|'\n'
name|'for'
name|'d'
name|'in'
name|'digits'
op|':'
newline|'\n'
indent|'                    '
name|'v'
op|'='
op|'('
name|'v'
op|'*'
number|'10'
op|')'
op|'+'
name|'d'
newline|'\n'
dedent|''
name|'if'
name|'sign'
op|':'
newline|'\n'
indent|'                    '
name|'v'
op|'='
op|'-'
name|'v'
newline|'\n'
dedent|''
name|'table_data'
op|'.'
name|'write_octet'
op|'('
op|'-'
name|'exponent'
op|')'
newline|'\n'
name|'table_data'
op|'.'
name|'write'
op|'('
name|'pack'
op|'('
string|"'>i'"
op|','
name|'v'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'isinstance'
op|'('
name|'v'
op|','
name|'datetime'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'table_data'
op|'.'
name|'write'
op|'('
string|"'T'"
op|')'
newline|'\n'
name|'table_data'
op|'.'
name|'write_timestamp'
op|'('
name|'v'
op|')'
newline|'\n'
comment|'## FIXME: timezone ?'
nl|'\n'
dedent|''
name|'elif'
name|'isinstance'
op|'('
name|'v'
op|','
name|'dict'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'table_data'
op|'.'
name|'write'
op|'('
string|"'F'"
op|')'
newline|'\n'
name|'table_data'
op|'.'
name|'write_table'
op|'('
name|'v'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'table_data'
op|'='
name|'table_data'
op|'.'
name|'getvalue'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'write_long'
op|'('
name|'len'
op|'('
name|'table_data'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'out'
op|'.'
name|'write'
op|'('
name|'table_data'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|write_timestamp
dedent|''
name|'def'
name|'write_timestamp'
op|'('
name|'self'
op|','
name|'v'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write out a Python datetime.datetime object as a 64-bit integer\n        representing seconds since the Unix epoch.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'out'
op|'.'
name|'write'
op|'('
name|'pack'
op|'('
string|"'>q'"
op|','
name|'long'
op|'('
name|'mktime'
op|'('
name|'v'
op|'.'
name|'timetuple'
op|'('
op|')'
op|')'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|GenericContent
dedent|''
dedent|''
name|'class'
name|'GenericContent'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Abstract base class for AMQP content.  Subclasses should\n    override the PROPERTIES attribute.\n\n    """'
newline|'\n'
DECL|variable|PROPERTIES
name|'PROPERTIES'
op|'='
op|'['
nl|'\n'
op|'('
string|"'dummy'"
op|','
string|"'shortstr'"
op|')'
op|','
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
op|'**'
name|'props'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Save the properties appropriate to this AMQP content type\n        in a \'properties\' dictionary.\n\n        """'
newline|'\n'
name|'d'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'propname'
op|','
name|'_'
name|'in'
name|'self'
op|'.'
name|'PROPERTIES'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'propname'
name|'in'
name|'props'
op|':'
newline|'\n'
indent|'                '
name|'d'
op|'['
name|'propname'
op|']'
op|'='
name|'props'
op|'['
name|'propname'
op|']'
newline|'\n'
comment|'# FIXME: should we ignore unknown properties?'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'properties'
op|'='
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__eq__
dedent|''
name|'def'
name|'__eq__'
op|'('
name|'self'
op|','
name|'other'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check if this object has the same properties as another\n        content object.\n\n        """'
newline|'\n'
name|'return'
op|'('
name|'self'
op|'.'
name|'properties'
op|'=='
name|'other'
op|'.'
name|'properties'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__getattr__
dedent|''
name|'def'
name|'__getattr__'
op|'('
name|'self'
op|','
name|'name'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Look for additional properties in the \'properties\'\n        dictionary, and if present - the \'delivery_info\'\n        dictionary.\n\n        """'
newline|'\n'
name|'if'
name|'name'
name|'in'
name|'self'
op|'.'
name|'properties'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'properties'
op|'['
name|'name'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
string|"'delivery_info'"
name|'in'
name|'self'
op|'.'
name|'__dict__'
op|')'
name|'and'
op|'('
name|'name'
name|'in'
name|'self'
op|'.'
name|'delivery_info'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'delivery_info'
op|'['
name|'name'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'raise'
name|'AttributeError'
op|'('
name|'name'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__ne__
dedent|''
name|'def'
name|'__ne__'
op|'('
name|'self'
op|','
name|'other'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Just return the opposite of __eq__\n\n        """'
newline|'\n'
name|'return'
name|'not'
name|'self'
op|'.'
name|'__eq__'
op|'('
name|'other'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_load_properties
dedent|''
name|'def'
name|'_load_properties'
op|'('
name|'self'
op|','
name|'raw_bytes'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Given the raw bytes containing the property-flags and property-list\n        from a content-frame-header, parse and insert into a dictionary\n        stored in this object as an attribute named \'properties\'.\n\n        """'
newline|'\n'
name|'r'
op|'='
name|'AMQPReader'
op|'('
name|'raw_bytes'
op|')'
newline|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Read 16-bit shorts until we get one with a low bit set to zero'
nl|'\n'
comment|'#'
nl|'\n'
name|'flags'
op|'='
op|'['
op|']'
newline|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'flag_bits'
op|'='
name|'r'
op|'.'
name|'read_short'
op|'('
op|')'
newline|'\n'
name|'flags'
op|'.'
name|'append'
op|'('
name|'flag_bits'
op|')'
newline|'\n'
name|'if'
name|'flag_bits'
op|'&'
number|'1'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'break'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'shift'
op|'='
number|'0'
newline|'\n'
name|'d'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'key'
op|','
name|'proptype'
name|'in'
name|'self'
op|'.'
name|'PROPERTIES'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'shift'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'not'
name|'flags'
op|':'
newline|'\n'
indent|'                    '
name|'break'
newline|'\n'
dedent|''
name|'flag_bits'
op|','
name|'flags'
op|'='
name|'flags'
op|'['
number|'0'
op|']'
op|','
name|'flags'
op|'['
number|'1'
op|':'
op|']'
newline|'\n'
name|'shift'
op|'='
number|'15'
newline|'\n'
dedent|''
name|'if'
name|'flag_bits'
op|'&'
op|'('
number|'1'
op|'<<'
name|'shift'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'d'
op|'['
name|'key'
op|']'
op|'='
name|'getattr'
op|'('
name|'r'
op|','
string|"'read_'"
op|'+'
name|'proptype'
op|')'
op|'('
op|')'
newline|'\n'
dedent|''
name|'shift'
op|'-='
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'properties'
op|'='
name|'d'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_serialize_properties
dedent|''
name|'def'
name|'_serialize_properties'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        serialize the \'properties\' attribute (a dictionary) into\n        the raw bytes making up a set of property flags and a\n        property list, suitable for putting into a content frame header.\n\n        """'
newline|'\n'
name|'shift'
op|'='
number|'15'
newline|'\n'
name|'flag_bits'
op|'='
number|'0'
newline|'\n'
name|'flags'
op|'='
op|'['
op|']'
newline|'\n'
name|'raw_bytes'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'for'
name|'key'
op|','
name|'proptype'
name|'in'
name|'self'
op|'.'
name|'PROPERTIES'
op|':'
newline|'\n'
indent|'            '
name|'val'
op|'='
name|'self'
op|'.'
name|'properties'
op|'.'
name|'get'
op|'('
name|'key'
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'val'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'shift'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'flags'
op|'.'
name|'append'
op|'('
name|'flag_bits'
op|')'
newline|'\n'
name|'flag_bits'
op|'='
number|'0'
newline|'\n'
name|'shift'
op|'='
number|'15'
newline|'\n'
nl|'\n'
dedent|''
name|'flag_bits'
op|'|='
op|'('
number|'1'
op|'<<'
name|'shift'
op|')'
newline|'\n'
name|'if'
name|'proptype'
op|'!='
string|"'bit'"
op|':'
newline|'\n'
indent|'                    '
name|'getattr'
op|'('
name|'raw_bytes'
op|','
string|"'write_'"
op|'+'
name|'proptype'
op|')'
op|'('
name|'val'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'shift'
op|'-='
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'flags'
op|'.'
name|'append'
op|'('
name|'flag_bits'
op|')'
newline|'\n'
name|'result'
op|'='
name|'AMQPWriter'
op|'('
op|')'
newline|'\n'
name|'for'
name|'flag_bits'
name|'in'
name|'flags'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'.'
name|'write_short'
op|'('
name|'flag_bits'
op|')'
newline|'\n'
dedent|''
name|'result'
op|'.'
name|'write'
op|'('
name|'raw_bytes'
op|'.'
name|'getvalue'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'result'
op|'.'
name|'getvalue'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
