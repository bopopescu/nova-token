begin_unit
string|'"""\nRead/Write AMQP frames over network transports.\n\n2009-01-14 Barry Pederson <bp@barryp.org>\n\n"""'
newline|'\n'
comment|'# Copyright (C) 2009 Barry Pederson <bp@barryp.org>'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# This library is free software; you can redistribute it and/or'
nl|'\n'
comment|'# modify it under the terms of the GNU Lesser General Public'
nl|'\n'
comment|'# License as published by the Free Software Foundation; either'
nl|'\n'
comment|'# version 2.1 of the License, or (at your option) any later version.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# This library is distributed in the hope that it will be useful,'
nl|'\n'
comment|'# but WITHOUT ANY WARRANTY; without even the implied warranty of'
nl|'\n'
comment|'# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU'
nl|'\n'
comment|'# Lesser General Public License for more details.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# You should have received a copy of the GNU Lesser General Public'
nl|'\n'
comment|'# License along with this library; if not, write to the Free Software'
nl|'\n'
comment|'# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301'
nl|'\n'
nl|'\n'
name|'import'
name|'socket'
newline|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# See if Python 2.6+ SSL support is available'
nl|'\n'
comment|'#'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'import'
name|'ssl'
newline|'\n'
DECL|variable|HAVE_PY26_SSL
name|'HAVE_PY26_SSL'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'except'
op|':'
newline|'\n'
DECL|variable|HAVE_PY26_SSL
indent|'    '
name|'HAVE_PY26_SSL'
op|'='
name|'False'
newline|'\n'
nl|'\n'
dedent|''
name|'from'
name|'struct'
name|'import'
name|'pack'
op|','
name|'unpack'
newline|'\n'
nl|'\n'
DECL|variable|AMQP_PORT
name|'AMQP_PORT'
op|'='
number|'5672'
newline|'\n'
nl|'\n'
comment|'# Yes, Advanced Message Queuing Protocol Protocol is redundant'
nl|'\n'
DECL|variable|AMQP_PROTOCOL_HEADER
name|'AMQP_PROTOCOL_HEADER'
op|'='
string|"'AMQP\\x01\\x01\\x09\\x01'"
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|_AbstractTransport
name|'class'
name|'_AbstractTransport'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Common superclass for TCP and SSL transports\n\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'host'
op|','
name|'connect_timeout'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
string|"':'"
name|'in'
name|'host'
op|':'
newline|'\n'
indent|'            '
name|'host'
op|','
name|'port'
op|'='
name|'host'
op|'.'
name|'split'
op|'('
string|"':'"
op|','
number|'1'
op|')'
newline|'\n'
name|'port'
op|'='
name|'int'
op|'('
name|'port'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'port'
op|'='
name|'AMQP_PORT'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'sock'
op|'='
name|'socket'
op|'.'
name|'socket'
op|'('
name|'socket'
op|'.'
name|'AF_INET'
op|','
name|'socket'
op|'.'
name|'SOCK_STREAM'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'sock'
op|'.'
name|'settimeout'
op|'('
name|'connect_timeout'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sock'
op|'.'
name|'connect'
op|'('
op|'('
name|'host'
op|','
name|'port'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'socket'
op|'.'
name|'error'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sock'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'raise'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'sock'
op|'.'
name|'settimeout'
op|'('
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_setup_transport'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_write'
op|'('
name|'AMQP_PROTOCOL_HEADER'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__del__
dedent|''
name|'def'
name|'__del__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_read
dedent|''
name|'def'
name|'_read'
op|'('
name|'self'
op|','
name|'n'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Read exactly n bytes from the peer\n\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
string|"'Must be overriden in subclass'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_setup_transport
dedent|''
name|'def'
name|'_setup_transport'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Do any additional initialization of the class (used\n        by the subclasses).\n\n        """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_write
dedent|''
name|'def'
name|'_write'
op|'('
name|'self'
op|','
name|'s'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Completely write a string to the peer.\n\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
string|"'Must be overriden in subclass'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|close
dedent|''
name|'def'
name|'close'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'sock'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sock'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'sock'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|read_frame
dedent|''
dedent|''
name|'def'
name|'read_frame'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Read an AMQP frame.\n\n        """'
newline|'\n'
name|'frame_type'
op|','
name|'channel'
op|','
name|'size'
op|'='
name|'unpack'
op|'('
string|"'>BHI'"
op|','
name|'self'
op|'.'
name|'_read'
op|'('
number|'7'
op|')'
op|')'
newline|'\n'
name|'payload'
op|'='
name|'self'
op|'.'
name|'_read'
op|'('
name|'size'
op|')'
newline|'\n'
name|'ch'
op|'='
name|'self'
op|'.'
name|'_read'
op|'('
number|'1'
op|')'
newline|'\n'
name|'if'
name|'ch'
op|'=='
string|"'\\xce'"
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'frame_type'
op|','
name|'channel'
op|','
name|'payload'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'Exception'
op|'('
string|"'Framing Error, received 0x%02x while expecting 0xce'"
op|'%'
name|'ord'
op|'('
name|'ch'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|write_frame
dedent|''
dedent|''
name|'def'
name|'write_frame'
op|'('
name|'self'
op|','
name|'frame_type'
op|','
name|'channel'
op|','
name|'payload'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write out an AMQP frame.\n\n        """'
newline|'\n'
name|'size'
op|'='
name|'len'
op|'('
name|'payload'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_write'
op|'('
name|'pack'
op|'('
string|"'>BHI%dsB'"
op|'%'
name|'size'
op|','
nl|'\n'
name|'frame_type'
op|','
name|'channel'
op|','
name|'size'
op|','
name|'payload'
op|','
number|'0xce'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|SSLTransport
dedent|''
dedent|''
name|'class'
name|'SSLTransport'
op|'('
name|'_AbstractTransport'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Transport that works over SSL\n\n    """'
newline|'\n'
DECL|member|_setup_transport
name|'def'
name|'_setup_transport'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Wrap the socket in an SSL object, either the\n        new Python 2.6 version, or the older Python 2.5 and\n        lower version.\n\n        """'
newline|'\n'
name|'if'
name|'HAVE_PY26_SSL'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sslobj'
op|'='
name|'ssl'
op|'.'
name|'wrap_socket'
op|'('
name|'self'
op|'.'
name|'sock'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'sslobj'
op|'.'
name|'do_handshake'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'sslobj'
op|'='
name|'socket'
op|'.'
name|'ssl'
op|'('
name|'self'
op|'.'
name|'sock'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_read
dedent|''
dedent|''
name|'def'
name|'_read'
op|'('
name|'self'
op|','
name|'n'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        It seems that SSL Objects read() method may not supply as much\n        as you\'re asking for, at least with extremely large messages.\n        somewhere > 16K - found this in the test_channel.py test_large\n        unittest.\n\n        """'
newline|'\n'
name|'result'
op|'='
name|'self'
op|'.'
name|'sslobj'
op|'.'
name|'read'
op|'('
name|'n'
op|')'
newline|'\n'
nl|'\n'
name|'while'
name|'len'
op|'('
name|'result'
op|')'
op|'<'
name|'n'
op|':'
newline|'\n'
indent|'            '
name|'s'
op|'='
name|'self'
op|'.'
name|'sslobj'
op|'.'
name|'read'
op|'('
name|'n'
op|'-'
name|'len'
op|'('
name|'result'
op|')'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'s'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'IOError'
op|'('
string|"'Socket closed'"
op|')'
newline|'\n'
dedent|''
name|'result'
op|'+='
name|'s'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_write
dedent|''
name|'def'
name|'_write'
op|'('
name|'self'
op|','
name|'s'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Write a string out to the SSL socket fully.\n\n        """'
newline|'\n'
name|'while'
name|'s'
op|':'
newline|'\n'
indent|'            '
name|'n'
op|'='
name|'self'
op|'.'
name|'sslobj'
op|'.'
name|'write'
op|'('
name|'s'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'n'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'IOError'
op|'('
string|"'Socket closed'"
op|')'
newline|'\n'
dedent|''
name|'s'
op|'='
name|'s'
op|'['
name|'n'
op|':'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|class|TCPTransport
dedent|''
dedent|''
dedent|''
name|'class'
name|'TCPTransport'
op|'('
name|'_AbstractTransport'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Transport that deals directly with TCP socket.\n\n    """'
newline|'\n'
DECL|member|_setup_transport
name|'def'
name|'_setup_transport'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Setup to _write() directly to the socket, and\n        do our own buffered reads.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_write'
op|'='
name|'self'
op|'.'
name|'sock'
op|'.'
name|'sendall'
newline|'\n'
name|'self'
op|'.'
name|'_read_buffer'
op|'='
string|"''"
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_read
dedent|''
name|'def'
name|'_read'
op|'('
name|'self'
op|','
name|'n'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Read exactly n bytes from the socket\n\n        """'
newline|'\n'
name|'while'
name|'len'
op|'('
name|'self'
op|'.'
name|'_read_buffer'
op|')'
op|'<'
name|'n'
op|':'
newline|'\n'
indent|'            '
name|'s'
op|'='
name|'self'
op|'.'
name|'sock'
op|'.'
name|'recv'
op|'('
number|'65536'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'s'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'IOError'
op|'('
string|"'Socket closed'"
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_read_buffer'
op|'+='
name|'s'
newline|'\n'
nl|'\n'
dedent|''
name|'result'
op|'='
name|'self'
op|'.'
name|'_read_buffer'
op|'['
op|':'
name|'n'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_read_buffer'
op|'='
name|'self'
op|'.'
name|'_read_buffer'
op|'['
name|'n'
op|':'
op|']'
newline|'\n'
nl|'\n'
name|'return'
name|'result'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|create_transport
dedent|''
dedent|''
name|'def'
name|'create_transport'
op|'('
name|'host'
op|','
name|'connect_timeout'
op|','
name|'ssl'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Given a few parameters from the Connection constructor,\n    select and create a subclass of _AbstractTransport.\n\n    """'
newline|'\n'
name|'if'
name|'ssl'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'SSLTransport'
op|'('
name|'host'
op|','
name|'connect_timeout'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'TCPTransport'
op|'('
name|'host'
op|','
name|'connect_timeout'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
