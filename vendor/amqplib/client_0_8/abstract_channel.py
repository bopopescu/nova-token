begin_unit
string|'"""\nCode common to Connection and Channel objects.\n\n"""'
newline|'\n'
comment|'# Copyright (C) 2007-2008 Barry Pederson <bp@barryp.org>'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# This library is free software; you can redistribute it and/or'
nl|'\n'
comment|'# modify it under the terms of the GNU Lesser General Public'
nl|'\n'
comment|'# License as published by the Free Software Foundation; either'
nl|'\n'
comment|'# version 2.1 of the License, or (at your option) any later version.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# This library is distributed in the hope that it will be useful,'
nl|'\n'
comment|'# but WITHOUT ANY WARRANTY; without even the implied warranty of'
nl|'\n'
comment|'# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU'
nl|'\n'
comment|'# Lesser General Public License for more details.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# You should have received a copy of the GNU Lesser General Public'
nl|'\n'
comment|'# License along with this library; if not, write to the Free Software'
nl|'\n'
comment|'# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301'
nl|'\n'
nl|'\n'
name|'from'
name|'serialization'
name|'import'
name|'AMQPWriter'
newline|'\n'
nl|'\n'
DECL|variable|__all__
name|'__all__'
op|'='
op|'['
nl|'\n'
string|"'AbstractChannel'"
op|','
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|AbstractChannel
name|'class'
name|'AbstractChannel'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Superclass for both the Connection, which is treated\n    as channel 0, and other user-created Channel objects.\n\n    The subclasses must have a _METHOD_MAP class property, mapping\n    between AMQP method signatures and Python methods.\n\n    """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'connection'
op|','
name|'channel_id'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'connection'
op|'='
name|'connection'
newline|'\n'
name|'self'
op|'.'
name|'channel_id'
op|'='
name|'channel_id'
newline|'\n'
name|'connection'
op|'.'
name|'channels'
op|'['
name|'channel_id'
op|']'
op|'='
name|'self'
newline|'\n'
name|'self'
op|'.'
name|'method_queue'
op|'='
op|'['
op|']'
comment|'# Higher level queue for methods'
newline|'\n'
name|'self'
op|'.'
name|'auto_decode'
op|'='
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__enter__
dedent|''
name|'def'
name|'__enter__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Support for Python >= 2.5 \'with\' statements.\n\n        """'
newline|'\n'
name|'return'
name|'self'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__exit__
dedent|''
name|'def'
name|'__exit__'
op|'('
name|'self'
op|','
name|'type'
op|','
name|'value'
op|','
name|'traceback'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Support for Python >= 2.5 \'with\' statements.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|_send_method
dedent|''
name|'def'
name|'_send_method'
op|'('
name|'self'
op|','
name|'method_sig'
op|','
name|'args'
op|'='
string|"''"
op|','
name|'content'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Send a method for our channel.\n\n        """'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'args'
op|','
name|'AMQPWriter'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'args'
op|'='
name|'args'
op|'.'
name|'getvalue'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'connection'
op|'.'
name|'method_writer'
op|'.'
name|'write_method'
op|'('
name|'self'
op|'.'
name|'channel_id'
op|','
nl|'\n'
name|'method_sig'
op|','
name|'args'
op|','
name|'content'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|close
dedent|''
name|'def'
name|'close'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Close this Channel or Connection\n\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
string|"'Must be overriden in subclass'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|member|wait
dedent|''
name|'def'
name|'wait'
op|'('
name|'self'
op|','
name|'allowed_methods'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Wait for a method that matches our allowed_methods parameter (the\n        default value of None means match any method), and dispatch to it.\n\n        """'
newline|'\n'
name|'method_sig'
op|','
name|'args'
op|','
name|'content'
op|'='
name|'self'
op|'.'
name|'connection'
op|'.'
name|'_wait_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'channel_id'
op|','
name|'allowed_methods'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'content'
name|'and'
name|'self'
op|'.'
name|'auto_decode'
name|'and'
name|'hasattr'
op|'('
name|'content'
op|','
string|"'content_encoding'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'content'
op|'.'
name|'body'
op|'='
name|'content'
op|'.'
name|'body'
op|'.'
name|'decode'
op|'('
name|'content'
op|'.'
name|'content_encoding'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'amqp_method'
op|'='
name|'self'
op|'.'
name|'_METHOD_MAP'
op|'.'
name|'get'
op|'('
name|'method_sig'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'amqp_method'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'Exception'
op|'('
string|"'Unknown AMQP method (%d, %d)'"
op|'%'
name|'method_sig'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'content'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'amqp_method'
op|'('
name|'self'
op|','
name|'args'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'amqp_method'
op|'('
name|'self'
op|','
name|'args'
op|','
name|'content'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Placeholder, the concrete implementations will have to'
nl|'\n'
comment|'# supply their own versions of _METHOD_MAP'
nl|'\n'
comment|'#'
nl|'\n'
DECL|variable|_METHOD_MAP
dedent|''
dedent|''
name|'_METHOD_MAP'
op|'='
op|'{'
op|'}'
newline|'\n'
dedent|''
endmarker|''
end_unit
