begin_unit
comment|'# -*- coding: utf-8 -*-'
nl|'\n'
nl|'\n'
comment|'# daemon/daemon.py'
nl|'\n'
comment|'# Part of python-daemon, an implementation of PEP 3143.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Copyright \xc2\xa9 2008\xe2\x80\x932010 Ben Finney <ben+python@benfinney.id.au>'
nl|'\n'
comment|'# Copyright \xc2\xa9 2007\xe2\x80\x932008 Robert Niederreiter, Jens Klein'
nl|'\n'
comment|'# Copyright \xc2\xa9 2004\xe2\x80\x932005 Chad J. Schroeder'
nl|'\n'
comment|'# Copyright \xc2\xa9 2003 Clark Evans'
nl|'\n'
comment|'# Copyright \xc2\xa9 2002 Noah Spurrier'
nl|'\n'
comment|'# Copyright \xc2\xa9 2001 J\xc3\xbcrgen Hermann'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# This is free software: you may copy, modify, and/or distribute this work'
nl|'\n'
comment|'# under the terms of the Python Software Foundation License, version 2 or'
nl|'\n'
comment|'# later as published by the Python Software Foundation.'
nl|'\n'
comment|'# No warranty expressed or implied. See the file LICENSE.PSF-2 for details.'
nl|'\n'
nl|'\n'
string|'""" Daemon process behaviour.\n    """'
newline|'\n'
nl|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'sys'
newline|'\n'
name|'import'
name|'resource'
newline|'\n'
name|'import'
name|'errno'
newline|'\n'
name|'import'
name|'signal'
newline|'\n'
name|'import'
name|'socket'
newline|'\n'
name|'import'
name|'atexit'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DaemonError
name|'class'
name|'DaemonError'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Base exception class for errors from this module. """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DaemonOSEnvironmentError
dedent|''
name|'class'
name|'DaemonOSEnvironmentError'
op|'('
name|'DaemonError'
op|','
name|'OSError'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Exception raised when daemon OS environment setup receives error. """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DaemonProcessDetachError
dedent|''
name|'class'
name|'DaemonProcessDetachError'
op|'('
name|'DaemonError'
op|','
name|'OSError'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Exception raised when process detach fails. """'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DaemonContext
dedent|''
name|'class'
name|'DaemonContext'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Context for turning the current program into a daemon process.\n\n        A `DaemonContext` instance represents the behaviour settings and\n        process context for the program when it becomes a daemon. The\n        behaviour and environment is customised by setting options on the\n        instance, before calling the `open` method.\n\n        Each option can be passed as a keyword argument to the `DaemonContext`\n        constructor, or subsequently altered by assigning to an attribute on\n        the instance at any time prior to calling `open`. That is, for\n        options named `wibble` and `wubble`, the following invocation::\n\n            foo = daemon.DaemonContext(wibble=bar, wubble=baz)\n            foo.open()\n\n        is equivalent to::\n\n            foo = daemon.DaemonContext()\n            foo.wibble = bar\n            foo.wubble = baz\n            foo.open()\n\n        The following options are defined.\n\n        `files_preserve`\n            :Default: ``None``\n\n            List of files that should *not* be closed when starting the\n            daemon. If ``None``, all open file descriptors will be closed.\n\n            Elements of the list are file descriptors (as returned by a file\n            object\'s `fileno()` method) or Python `file` objects. Each\n            specifies a file that is not to be closed during daemon start.\n\n        `chroot_directory`\n            :Default: ``None``\n\n            Full path to a directory to set as the effective root directory of\n            the process. If ``None``, specifies that the root directory is not\n            to be changed.\n\n        `working_directory`\n            :Default: ``\'/\'``\n\n            Full path of the working directory to which the process should\n            change on daemon start.\n\n            Since a filesystem cannot be unmounted if a process has its\n            current working directory on that filesystem, this should either\n            be left at default or set to a directory that is a sensible \xe2\x80\x9chome\n            directory\xe2\x80\x9d for the daemon while it is running.\n\n        `umask`\n            :Default: ``0``\n\n            File access creation mask (\xe2\x80\x9cumask\xe2\x80\x9d) to set for the process on\n            daemon start.\n\n            Since a process inherits its umask from its parent process,\n            starting the daemon will reset the umask to this value so that\n            files are created by the daemon with access modes as it expects.\n\n        `pidfile`\n            :Default: ``None``\n\n            Context manager for a PID lock file. When the daemon context opens\n            and closes, it enters and exits the `pidfile` context manager.\n\n        `detach_process`\n            :Default: ``None``\n\n            If ``True``, detach the process context when opening the daemon\n            context; if ``False``, do not detach.\n\n            If unspecified (``None``) during initialisation of the instance,\n            this will be set to ``True`` by default, and ``False`` only if\n            detaching the process is determined to be redundant; for example,\n            in the case when the process was started by `init`, by `initd`, or\n            by `inetd`.\n\n        `signal_map`\n            :Default: system-dependent\n\n            Mapping from operating system signals to callback actions.\n\n            The mapping is used when the daemon context opens, and determines\n            the action for each signal\'s signal handler:\n\n            * A value of ``None`` will ignore the signal (by setting the\n              signal action to ``signal.SIG_IGN``).\n\n            * A string value will be used as the name of an attribute on the\n              ``DaemonContext`` instance. The attribute\'s value will be used\n              as the action for the signal handler.\n\n            * Any other value will be used as the action for the\n              signal handler. See the ``signal.signal`` documentation\n              for details of the signal handler interface.\n\n            The default value depends on which signals are defined on the\n            running system. Each item from the list below whose signal is\n            actually defined in the ``signal`` module will appear in the\n            default map:\n\n            * ``signal.SIGTTIN``: ``None``\n\n            * ``signal.SIGTTOU``: ``None``\n\n            * ``signal.SIGTSTP``: ``None``\n\n            * ``signal.SIGTERM``: ``\'terminate\'``\n\n            Depending on how the program will interact with its child\n            processes, it may need to specify a signal map that\n            includes the ``signal.SIGCHLD`` signal (received when a\n            child process exits). See the specific operating system\'s\n            documentation for more detail on how to determine what\n            circumstances dictate the need for signal handlers.\n\n        `uid`\n            :Default: ``os.getuid()``\n\n        `gid`\n            :Default: ``os.getgid()``\n\n            The user ID (\xe2\x80\x9cUID\xe2\x80\x9d) value and group ID (\xe2\x80\x9cGID\xe2\x80\x9d) value to switch\n            the process to on daemon start.\n\n            The default values, the real UID and GID of the process, will\n            relinquish any effective privilege elevation inherited by the\n            process.\n\n        `prevent_core`\n            :Default: ``True``\n\n            If true, prevents the generation of core files, in order to avoid\n            leaking sensitive information from daemons run as `root`.\n\n        `stdin`\n            :Default: ``None``\n\n        `stdout`\n            :Default: ``None``\n\n        `stderr`\n            :Default: ``None``\n\n            Each of `stdin`, `stdout`, and `stderr` is a file-like object\n            which will be used as the new file for the standard I/O stream\n            `sys.stdin`, `sys.stdout`, and `sys.stderr` respectively. The file\n            should therefore be open, with a minimum of mode \'r\' in the case\n            of `stdin`, and mode \'w+\' in the case of `stdout` and `stderr`.\n\n            If the object has a `fileno()` method that returns a file\n            descriptor, the corresponding file will be excluded from being\n            closed during daemon start (that is, it will be treated as though\n            it were listed in `files_preserve`).\n\n            If ``None``, the corresponding system stream is re-bound to the\n            file named by `os.devnull`.\n\n        """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
nl|'\n'
name|'self'
op|','
nl|'\n'
name|'chroot_directory'
op|'='
name|'None'
op|','
nl|'\n'
name|'working_directory'
op|'='
string|"'/'"
op|','
nl|'\n'
name|'umask'
op|'='
number|'0'
op|','
nl|'\n'
name|'uid'
op|'='
name|'None'
op|','
nl|'\n'
name|'gid'
op|'='
name|'None'
op|','
nl|'\n'
name|'prevent_core'
op|'='
name|'True'
op|','
nl|'\n'
name|'detach_process'
op|'='
name|'None'
op|','
nl|'\n'
name|'files_preserve'
op|'='
name|'None'
op|','
nl|'\n'
name|'pidfile'
op|'='
name|'None'
op|','
nl|'\n'
name|'stdin'
op|'='
name|'None'
op|','
nl|'\n'
name|'stdout'
op|'='
name|'None'
op|','
nl|'\n'
name|'stderr'
op|'='
name|'None'
op|','
nl|'\n'
name|'signal_map'
op|'='
name|'None'
op|','
nl|'\n'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Set up a new instance. """'
newline|'\n'
name|'self'
op|'.'
name|'chroot_directory'
op|'='
name|'chroot_directory'
newline|'\n'
name|'self'
op|'.'
name|'working_directory'
op|'='
name|'working_directory'
newline|'\n'
name|'self'
op|'.'
name|'umask'
op|'='
name|'umask'
newline|'\n'
name|'self'
op|'.'
name|'prevent_core'
op|'='
name|'prevent_core'
newline|'\n'
name|'self'
op|'.'
name|'files_preserve'
op|'='
name|'files_preserve'
newline|'\n'
name|'self'
op|'.'
name|'pidfile'
op|'='
name|'pidfile'
newline|'\n'
name|'self'
op|'.'
name|'stdin'
op|'='
name|'stdin'
newline|'\n'
name|'self'
op|'.'
name|'stdout'
op|'='
name|'stdout'
newline|'\n'
name|'self'
op|'.'
name|'stderr'
op|'='
name|'stderr'
newline|'\n'
nl|'\n'
name|'if'
name|'uid'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'uid'
op|'='
name|'os'
op|'.'
name|'getuid'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'uid'
op|'='
name|'uid'
newline|'\n'
name|'if'
name|'gid'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'gid'
op|'='
name|'os'
op|'.'
name|'getgid'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'gid'
op|'='
name|'gid'
newline|'\n'
nl|'\n'
name|'if'
name|'detach_process'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'detach_process'
op|'='
name|'is_detach_process_context_required'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'detach_process'
op|'='
name|'detach_process'
newline|'\n'
nl|'\n'
name|'if'
name|'signal_map'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'signal_map'
op|'='
name|'make_default_signal_map'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'signal_map'
op|'='
name|'signal_map'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_is_open'
op|'='
name|'False'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|is_open
name|'def'
name|'is_open'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" ``True`` if the instance is currently open. """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_is_open'
newline|'\n'
nl|'\n'
DECL|member|open
dedent|''
name|'def'
name|'open'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Become a daemon process.\n            :Return: ``None``\n\n            Open the daemon context, turning the current program into a daemon\n            process. This performs the following steps:\n\n            * If this instance\'s `is_open` property is true, return\n              immediately. This makes it safe to call `open` multiple times on\n              an instance.\n\n            * If the `prevent_core` attribute is true, set the resource limits\n              for the process to prevent any core dump from the process.\n\n            * If the `chroot_directory` attribute is not ``None``, set the\n              effective root directory of the process to that directory (via\n              `os.chroot`).\n\n              This allows running the daemon process inside a \xe2\x80\x9cchroot gaol\xe2\x80\x9d\n              as a means of limiting the system\'s exposure to rogue behaviour\n              by the process. Note that the specified directory needs to\n              already be set up for this purpose.\n\n            * Set the process UID and GID to the `uid` and `gid` attribute\n              values.\n\n            * Close all open file descriptors. This excludes those listed in\n              the `files_preserve` attribute, and those that correspond to the\n              `stdin`, `stdout`, or `stderr` attributes.\n\n            * Change current working directory to the path specified by the\n              `working_directory` attribute.\n\n            * Reset the file access creation mask to the value specified by\n              the `umask` attribute.\n\n            * If the `detach_process` option is true, detach the current\n              process into its own process group, and disassociate from any\n              controlling terminal.\n\n            * Set signal handlers as specified by the `signal_map` attribute.\n\n            * If any of the attributes `stdin`, `stdout`, `stderr` are not\n              ``None``, bind the system streams `sys.stdin`, `sys.stdout`,\n              and/or `sys.stderr` to the files represented by the\n              corresponding attributes. Where the attribute has a file\n              descriptor, the descriptor is duplicated (instead of re-binding\n              the name).\n\n            * If the `pidfile` attribute is not ``None``, enter its context\n              manager.\n\n            * Mark this instance as open (for the purpose of future `open` and\n              `close` calls).\n\n            * Register the `close` method to be called during Python\'s exit\n              processing.\n\n            When the function returns, the running program is a daemon\n            process.\n\n            """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'is_open'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'chroot_directory'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'change_root_directory'
op|'('
name|'self'
op|'.'
name|'chroot_directory'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'prevent_core'
op|':'
newline|'\n'
indent|'            '
name|'prevent_core_dump'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'change_file_creation_mask'
op|'('
name|'self'
op|'.'
name|'umask'
op|')'
newline|'\n'
name|'change_working_directory'
op|'('
name|'self'
op|'.'
name|'working_directory'
op|')'
newline|'\n'
name|'change_process_owner'
op|'('
name|'self'
op|'.'
name|'uid'
op|','
name|'self'
op|'.'
name|'gid'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'detach_process'
op|':'
newline|'\n'
indent|'            '
name|'detach_process_context'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'signal_handler_map'
op|'='
name|'self'
op|'.'
name|'_make_signal_handler_map'
op|'('
op|')'
newline|'\n'
name|'set_signal_handlers'
op|'('
name|'signal_handler_map'
op|')'
newline|'\n'
nl|'\n'
name|'exclude_fds'
op|'='
name|'self'
op|'.'
name|'_get_exclude_file_descriptors'
op|'('
op|')'
newline|'\n'
name|'close_all_open_files'
op|'('
name|'exclude'
op|'='
name|'exclude_fds'
op|')'
newline|'\n'
nl|'\n'
name|'redirect_stream'
op|'('
name|'sys'
op|'.'
name|'stdin'
op|','
name|'self'
op|'.'
name|'stdin'
op|')'
newline|'\n'
name|'redirect_stream'
op|'('
name|'sys'
op|'.'
name|'stdout'
op|','
name|'self'
op|'.'
name|'stdout'
op|')'
newline|'\n'
name|'redirect_stream'
op|'('
name|'sys'
op|'.'
name|'stderr'
op|','
name|'self'
op|'.'
name|'stderr'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'pidfile'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'pidfile'
op|'.'
name|'__enter__'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_is_open'
op|'='
name|'True'
newline|'\n'
nl|'\n'
name|'register_atexit_function'
op|'('
name|'self'
op|'.'
name|'close'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__enter__
dedent|''
name|'def'
name|'__enter__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Context manager entry point. """'
newline|'\n'
name|'self'
op|'.'
name|'open'
op|'('
op|')'
newline|'\n'
name|'return'
name|'self'
newline|'\n'
nl|'\n'
DECL|member|close
dedent|''
name|'def'
name|'close'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Exit the daemon process context.\n            :Return: ``None``\n\n            Close the daemon context. This performs the following steps:\n\n            * If this instance\'s `is_open` property is false, return\n              immediately. This makes it safe to call `close` multiple times\n              on an instance.\n\n            * If the `pidfile` attribute is not ``None``, exit its context\n              manager.\n\n            * Mark this instance as closed (for the purpose of future `open`\n              and `close` calls).\n\n            """'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'is_open'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'pidfile'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
comment|'# Follow the interface for telling a context manager to exit,'
nl|'\n'
comment|'# <URL:http://docs.python.org/library/stdtypes.html#typecontextmanager>.'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'pidfile'
op|'.'
name|'__exit__'
op|'('
name|'None'
op|','
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_is_open'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|member|__exit__
dedent|''
name|'def'
name|'__exit__'
op|'('
name|'self'
op|','
name|'exc_type'
op|','
name|'exc_value'
op|','
name|'traceback'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Context manager exit point. """'
newline|'\n'
name|'self'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|terminate
dedent|''
name|'def'
name|'terminate'
op|'('
name|'self'
op|','
name|'signal_number'
op|','
name|'stack_frame'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Signal handler for end-process signals.\n            :Return: ``None``\n\n            Signal handler for the ``signal.SIGTERM`` signal. Performs the\n            following step:\n\n            * Raise a ``SystemExit`` exception explaining the signal.\n\n            """'
newline|'\n'
name|'exception'
op|'='
name|'SystemExit'
op|'('
nl|'\n'
string|'"Terminating on signal %(signal_number)r"'
nl|'\n'
op|'%'
name|'vars'
op|'('
op|')'
op|')'
newline|'\n'
name|'raise'
name|'exception'
newline|'\n'
nl|'\n'
DECL|member|_get_exclude_file_descriptors
dedent|''
name|'def'
name|'_get_exclude_file_descriptors'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Return the set of file descriptors to exclude closing.\n\n            Returns a set containing the file descriptors for the\n            items in `files_preserve`, and also each of `stdin`,\n            `stdout`, and `stderr`:\n\n            * If the item is ``None``, it is omitted from the return\n              set.\n\n            * If the item has a ``fileno()`` method, that method\'s\n              return value is in the return set.\n\n            * Otherwise, the item is in the return set verbatim.\n\n            """'
newline|'\n'
name|'files_preserve'
op|'='
name|'self'
op|'.'
name|'files_preserve'
newline|'\n'
name|'if'
name|'files_preserve'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'files_preserve'
op|'='
op|'['
op|']'
newline|'\n'
dedent|''
name|'files_preserve'
op|'.'
name|'extend'
op|'('
nl|'\n'
name|'item'
name|'for'
name|'item'
name|'in'
op|'['
name|'self'
op|'.'
name|'stdin'
op|','
name|'self'
op|'.'
name|'stdout'
op|','
name|'self'
op|'.'
name|'stderr'
op|']'
nl|'\n'
name|'if'
name|'hasattr'
op|'('
name|'item'
op|','
string|"'fileno'"
op|')'
op|')'
newline|'\n'
name|'exclude_descriptors'
op|'='
name|'set'
op|'('
op|')'
newline|'\n'
name|'for'
name|'item'
name|'in'
name|'files_preserve'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'item'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'if'
name|'hasattr'
op|'('
name|'item'
op|','
string|"'fileno'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'exclude_descriptors'
op|'.'
name|'add'
op|'('
name|'item'
op|'.'
name|'fileno'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'exclude_descriptors'
op|'.'
name|'add'
op|'('
name|'item'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'exclude_descriptors'
newline|'\n'
nl|'\n'
DECL|member|_make_signal_handler
dedent|''
name|'def'
name|'_make_signal_handler'
op|'('
name|'self'
op|','
name|'target'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Make the signal handler for a specified target object.\n\n            If `target` is ``None``, returns ``signal.SIG_IGN``. If\n            `target` is a string, returns the attribute of this\n            instance named by that string. Otherwise, returns `target`\n            itself.\n\n            """'
newline|'\n'
name|'if'
name|'target'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'='
name|'signal'
op|'.'
name|'SIG_IGN'
newline|'\n'
dedent|''
name|'elif'
name|'isinstance'
op|'('
name|'target'
op|','
name|'basestring'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'name'
op|'='
name|'target'
newline|'\n'
name|'result'
op|'='
name|'getattr'
op|'('
name|'self'
op|','
name|'name'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'='
name|'target'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
DECL|member|_make_signal_handler_map
dedent|''
name|'def'
name|'_make_signal_handler_map'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Make the map from signals to handlers for this instance.\n\n            Constructs a map from signal numbers to handlers for this\n            context instance, suitable for passing to\n            `set_signal_handlers`.\n\n            """'
newline|'\n'
name|'signal_handler_map'
op|'='
name|'dict'
op|'('
nl|'\n'
op|'('
name|'signal_number'
op|','
name|'self'
op|'.'
name|'_make_signal_handler'
op|'('
name|'target'
op|')'
op|')'
nl|'\n'
name|'for'
op|'('
name|'signal_number'
op|','
name|'target'
op|')'
name|'in'
name|'self'
op|'.'
name|'signal_map'
op|'.'
name|'items'
op|'('
op|')'
op|')'
newline|'\n'
name|'return'
name|'signal_handler_map'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|change_working_directory
dedent|''
dedent|''
name|'def'
name|'change_working_directory'
op|'('
name|'directory'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Change the working directory of this process.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'os'
op|'.'
name|'chdir'
op|'('
name|'directory'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|','
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'error'
op|'='
name|'DaemonOSEnvironmentError'
op|'('
nl|'\n'
string|'"Unable to change working directory (%(exc)s)"'
nl|'\n'
op|'%'
name|'vars'
op|'('
op|')'
op|')'
newline|'\n'
name|'raise'
name|'error'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|change_root_directory
dedent|''
dedent|''
name|'def'
name|'change_root_directory'
op|'('
name|'directory'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Change the root directory of this process.\n\n        Sets the current working directory, then the process root\n        directory, to the specified `directory`. Requires appropriate\n        OS privileges for this process.\n\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'os'
op|'.'
name|'chdir'
op|'('
name|'directory'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'chroot'
op|'('
name|'directory'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|','
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'error'
op|'='
name|'DaemonOSEnvironmentError'
op|'('
nl|'\n'
string|'"Unable to change root directory (%(exc)s)"'
nl|'\n'
op|'%'
name|'vars'
op|'('
op|')'
op|')'
newline|'\n'
name|'raise'
name|'error'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|change_file_creation_mask
dedent|''
dedent|''
name|'def'
name|'change_file_creation_mask'
op|'('
name|'mask'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Change the file creation mask for this process.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'os'
op|'.'
name|'umask'
op|'('
name|'mask'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|','
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'error'
op|'='
name|'DaemonOSEnvironmentError'
op|'('
nl|'\n'
string|'"Unable to change file creation mask (%(exc)s)"'
nl|'\n'
op|'%'
name|'vars'
op|'('
op|')'
op|')'
newline|'\n'
name|'raise'
name|'error'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|change_process_owner
dedent|''
dedent|''
name|'def'
name|'change_process_owner'
op|'('
name|'uid'
op|','
name|'gid'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Change the owning UID and GID of this process.\n\n        Sets the GID then the UID of the process (in that order, to\n        avoid permission errors) to the specified `gid` and `uid`\n        values. Requires appropriate OS privileges for this process.\n\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'os'
op|'.'
name|'setgid'
op|'('
name|'gid'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'setuid'
op|'('
name|'uid'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|','
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'error'
op|'='
name|'DaemonOSEnvironmentError'
op|'('
nl|'\n'
string|'"Unable to change file creation mask (%(exc)s)"'
nl|'\n'
op|'%'
name|'vars'
op|'('
op|')'
op|')'
newline|'\n'
name|'raise'
name|'error'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|prevent_core_dump
dedent|''
dedent|''
name|'def'
name|'prevent_core_dump'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Prevent this process from generating a core dump.\n\n        Sets the soft and hard limits for core dump size to zero. On\n        Unix, this prevents the process from creating core dump\n        altogether.\n\n        """'
newline|'\n'
name|'core_resource'
op|'='
name|'resource'
op|'.'
name|'RLIMIT_CORE'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# Ensure the resource limit exists on this platform, by requesting'
nl|'\n'
comment|'# its current value'
nl|'\n'
indent|'        '
name|'core_limit_prev'
op|'='
name|'resource'
op|'.'
name|'getrlimit'
op|'('
name|'core_resource'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|','
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'error'
op|'='
name|'DaemonOSEnvironmentError'
op|'('
nl|'\n'
string|'"System does not support RLIMIT_CORE resource limit (%(exc)s)"'
nl|'\n'
op|'%'
name|'vars'
op|'('
op|')'
op|')'
newline|'\n'
name|'raise'
name|'error'
newline|'\n'
nl|'\n'
comment|'# Set hard and soft limits to zero, i.e. no core dump at all'
nl|'\n'
dedent|''
name|'core_limit'
op|'='
op|'('
number|'0'
op|','
number|'0'
op|')'
newline|'\n'
name|'resource'
op|'.'
name|'setrlimit'
op|'('
name|'core_resource'
op|','
name|'core_limit'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|detach_process_context
dedent|''
name|'def'
name|'detach_process_context'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Detach the process context from parent and session.\n\n        Detach from the parent process and session group, allowing the\n        parent to exit while this process continues running.\n\n        Reference: \xe2\x80\x9cAdvanced Programming in the Unix Environment\xe2\x80\x9d,\n        section 13.3, by W. Richard Stevens, published 1993 by\n        Addison-Wesley.\n    \n        """'
newline|'\n'
nl|'\n'
DECL|function|fork_then_exit_parent
name|'def'
name|'fork_then_exit_parent'
op|'('
name|'error_message'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Fork a child process, then exit the parent process.\n\n            If the fork fails, raise a ``DaemonProcessDetachError``\n            with ``error_message``.\n\n            """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'pid'
op|'='
name|'os'
op|'.'
name|'fork'
op|'('
op|')'
newline|'\n'
name|'if'
name|'pid'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'_exit'
op|'('
number|'0'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'OSError'
op|','
name|'exc'
op|':'
newline|'\n'
indent|'            '
name|'exc_errno'
op|'='
name|'exc'
op|'.'
name|'errno'
newline|'\n'
name|'exc_strerror'
op|'='
name|'exc'
op|'.'
name|'strerror'
newline|'\n'
name|'error'
op|'='
name|'DaemonProcessDetachError'
op|'('
nl|'\n'
string|'"%(error_message)s: [%(exc_errno)d] %(exc_strerror)s"'
op|'%'
name|'vars'
op|'('
op|')'
op|')'
newline|'\n'
name|'raise'
name|'error'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'fork_then_exit_parent'
op|'('
name|'error_message'
op|'='
string|'"Failed first fork"'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'setsid'
op|'('
op|')'
newline|'\n'
name|'fork_then_exit_parent'
op|'('
name|'error_message'
op|'='
string|'"Failed second fork"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|is_process_started_by_init
dedent|''
name|'def'
name|'is_process_started_by_init'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Determine if the current process is started by `init`.\n\n        The `init` process has the process ID of 1; if that is our\n        parent process ID, return ``True``, otherwise ``False``.\n    \n        """'
newline|'\n'
name|'result'
op|'='
name|'False'
newline|'\n'
nl|'\n'
name|'init_pid'
op|'='
number|'1'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'getppid'
op|'('
op|')'
op|'=='
name|'init_pid'
op|':'
newline|'\n'
indent|'        '
name|'result'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|is_socket
dedent|''
name|'def'
name|'is_socket'
op|'('
name|'fd'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Determine if the file descriptor is a socket.\n\n        Return ``False`` if querying the socket type of `fd` raises an\n        error; otherwise return ``True``.\n\n        """'
newline|'\n'
name|'result'
op|'='
name|'False'
newline|'\n'
nl|'\n'
name|'file_socket'
op|'='
name|'socket'
op|'.'
name|'fromfd'
op|'('
name|'fd'
op|','
name|'socket'
op|'.'
name|'AF_INET'
op|','
name|'socket'
op|'.'
name|'SOCK_RAW'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'socket_type'
op|'='
name|'file_socket'
op|'.'
name|'getsockopt'
op|'('
nl|'\n'
name|'socket'
op|'.'
name|'SOL_SOCKET'
op|','
name|'socket'
op|'.'
name|'SO_TYPE'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'socket'
op|'.'
name|'error'
op|','
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'exc_errno'
op|'='
name|'exc'
op|'.'
name|'args'
op|'['
number|'0'
op|']'
newline|'\n'
name|'if'
name|'exc_errno'
op|'=='
name|'errno'
op|'.'
name|'ENOTSOCK'
op|':'
newline|'\n'
comment|'# Socket operation on non-socket'
nl|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Some other socket error'
nl|'\n'
indent|'            '
name|'result'
op|'='
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# No error getting socket type'
nl|'\n'
indent|'        '
name|'result'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|is_process_started_by_superserver
dedent|''
name|'def'
name|'is_process_started_by_superserver'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Determine if the current process is started by the superserver.\n\n        The internet superserver creates a network socket, and\n        attaches it to the standard streams of the child process. If\n        that is the case for this process, return ``True``, otherwise\n        ``False``.\n    \n        """'
newline|'\n'
name|'result'
op|'='
name|'False'
newline|'\n'
nl|'\n'
name|'stdin_fd'
op|'='
name|'sys'
op|'.'
name|'__stdin__'
op|'.'
name|'fileno'
op|'('
op|')'
newline|'\n'
name|'if'
name|'is_socket'
op|'('
name|'stdin_fd'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'result'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|is_detach_process_context_required
dedent|''
name|'def'
name|'is_detach_process_context_required'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Determine whether detaching process context is required.\n\n        Return ``True`` if the process environment indicates the\n        process is already detached:\n\n        * Process was started by `init`; or\n\n        * Process was started by `inetd`.\n\n        """'
newline|'\n'
name|'result'
op|'='
name|'True'
newline|'\n'
name|'if'
name|'is_process_started_by_init'
op|'('
op|')'
name|'or'
name|'is_process_started_by_superserver'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'result'
op|'='
name|'False'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|close_file_descriptor_if_open
dedent|''
name|'def'
name|'close_file_descriptor_if_open'
op|'('
name|'fd'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Close a file descriptor if already open.\n\n        Close the file descriptor `fd`, suppressing an error in the\n        case the file was not open.\n\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'os'
op|'.'
name|'close'
op|'('
name|'fd'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
op|','
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'exc'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'EBADF'
op|':'
newline|'\n'
comment|'# File descriptor was not open'
nl|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'error'
op|'='
name|'DaemonOSEnvironmentError'
op|'('
nl|'\n'
string|'"Failed to close file descriptor %(fd)d"'
nl|'\n'
string|'" (%(exc)s)"'
nl|'\n'
op|'%'
name|'vars'
op|'('
op|')'
op|')'
newline|'\n'
name|'raise'
name|'error'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|MAXFD
dedent|''
dedent|''
dedent|''
name|'MAXFD'
op|'='
number|'2048'
newline|'\n'
nl|'\n'
DECL|function|get_maximum_file_descriptors
name|'def'
name|'get_maximum_file_descriptors'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Return the maximum number of open file descriptors for this process.\n\n        Return the process hard resource limit of maximum number of\n        open file descriptors. If the limit is \xe2\x80\x9cinfinity\xe2\x80\x9d, a default\n        value of ``MAXFD`` is returned.\n\n        """'
newline|'\n'
name|'limits'
op|'='
name|'resource'
op|'.'
name|'getrlimit'
op|'('
name|'resource'
op|'.'
name|'RLIMIT_NOFILE'
op|')'
newline|'\n'
name|'result'
op|'='
name|'limits'
op|'['
number|'1'
op|']'
newline|'\n'
name|'if'
name|'result'
op|'=='
name|'resource'
op|'.'
name|'RLIM_INFINITY'
op|':'
newline|'\n'
indent|'        '
name|'result'
op|'='
name|'MAXFD'
newline|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|close_all_open_files
dedent|''
name|'def'
name|'close_all_open_files'
op|'('
name|'exclude'
op|'='
name|'set'
op|'('
op|')'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Close all open file descriptors.\n\n        Closes every file descriptor (if open) of this process. If\n        specified, `exclude` is a set of file descriptors to *not*\n        close.\n\n        """'
newline|'\n'
name|'maxfd'
op|'='
name|'get_maximum_file_descriptors'
op|'('
op|')'
newline|'\n'
name|'for'
name|'fd'
name|'in'
name|'reversed'
op|'('
name|'range'
op|'('
name|'maxfd'
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'fd'
name|'not'
name|'in'
name|'exclude'
op|':'
newline|'\n'
indent|'            '
name|'close_file_descriptor_if_open'
op|'('
name|'fd'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|redirect_stream
dedent|''
dedent|''
dedent|''
name|'def'
name|'redirect_stream'
op|'('
name|'system_stream'
op|','
name|'target_stream'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Redirect a system stream to a specified file.\n\n        `system_stream` is a standard system stream such as\n        ``sys.stdout``. `target_stream` is an open file object that\n        should replace the corresponding system stream object.\n\n        If `target_stream` is ``None``, defaults to opening the\n        operating system\'s null device and using its file descriptor.\n\n        """'
newline|'\n'
name|'if'
name|'target_stream'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'target_fd'
op|'='
name|'os'
op|'.'
name|'open'
op|'('
name|'os'
op|'.'
name|'devnull'
op|','
name|'os'
op|'.'
name|'O_RDWR'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'target_fd'
op|'='
name|'target_stream'
op|'.'
name|'fileno'
op|'('
op|')'
newline|'\n'
dedent|''
name|'os'
op|'.'
name|'dup2'
op|'('
name|'target_fd'
op|','
name|'system_stream'
op|'.'
name|'fileno'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|make_default_signal_map
dedent|''
name|'def'
name|'make_default_signal_map'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Make the default signal map for this system.\n\n        The signals available differ by system. The map will not\n        contain any signals not defined on the running system.\n\n        """'
newline|'\n'
name|'name_map'
op|'='
op|'{'
nl|'\n'
string|"'SIGTSTP'"
op|':'
name|'None'
op|','
nl|'\n'
string|"'SIGTTIN'"
op|':'
name|'None'
op|','
nl|'\n'
string|"'SIGTTOU'"
op|':'
name|'None'
op|','
nl|'\n'
string|"'SIGTERM'"
op|':'
string|"'terminate'"
op|','
nl|'\n'
op|'}'
newline|'\n'
name|'signal_map'
op|'='
name|'dict'
op|'('
nl|'\n'
op|'('
name|'getattr'
op|'('
name|'signal'
op|','
name|'name'
op|')'
op|','
name|'target'
op|')'
nl|'\n'
name|'for'
op|'('
name|'name'
op|','
name|'target'
op|')'
name|'in'
name|'name_map'
op|'.'
name|'items'
op|'('
op|')'
nl|'\n'
name|'if'
name|'hasattr'
op|'('
name|'signal'
op|','
name|'name'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'signal_map'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|set_signal_handlers
dedent|''
name|'def'
name|'set_signal_handlers'
op|'('
name|'signal_handler_map'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Set the signal handlers as specified.\n\n        The `signal_handler_map` argument is a map from signal number\n        to signal handler. See the `signal` module for details.\n\n        """'
newline|'\n'
name|'for'
op|'('
name|'signal_number'
op|','
name|'handler'
op|')'
name|'in'
name|'signal_handler_map'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'signal'
op|'.'
name|'signal'
op|'('
name|'signal_number'
op|','
name|'handler'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|register_atexit_function
dedent|''
dedent|''
name|'def'
name|'register_atexit_function'
op|'('
name|'func'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Register a function for processing at program exit.\n\n        The function `func` is registered for a call with no arguments\n        at program exit.\n\n        """'
newline|'\n'
name|'atexit'
op|'.'
name|'register'
op|'('
name|'func'
op|')'
newline|'\n'
dedent|''
endmarker|''
end_unit
