begin_unit
string|'"""\n\nSending/Receiving Messages.\n\n"""'
newline|'\n'
name|'from'
name|'itertools'
name|'import'
name|'count'
newline|'\n'
name|'from'
name|'carrot'
op|'.'
name|'utils'
name|'import'
name|'gen_unique_id'
newline|'\n'
name|'import'
name|'warnings'
newline|'\n'
nl|'\n'
name|'from'
name|'carrot'
name|'import'
name|'serialization'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Consumer
name|'class'
name|'Consumer'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Message consumer.\n\n    :param connection: see :attr:`connection`.\n    :param queue: see :attr:`queue`.\n    :param exchange: see :attr:`exchange`.\n    :param routing_key: see :attr:`routing_key`.\n\n    :keyword durable: see :attr:`durable`.\n    :keyword auto_delete: see :attr:`auto_delete`.\n    :keyword exclusive: see :attr:`exclusive`.\n    :keyword exchange_type: see :attr:`exchange_type`.\n    :keyword auto_ack: see :attr:`auto_ack`.\n    :keyword no_ack: see :attr:`no_ack`.\n    :keyword auto_declare: see :attr:`auto_declare`.\n\n\n    .. attribute:: connection\n\n        The connection to the broker.\n        A :class:`carrot.connection.BrokerConnection` instance.\n\n    .. attribute:: queue\n\n       Name of the queue.\n\n    .. attribute:: exchange\n\n        Name of the exchange the queue binds to.\n\n    .. attribute:: routing_key\n\n        The routing key (if any). The interpretation of the routing key\n        depends on the value of the :attr:`exchange_type` attribute:\n\n            * direct exchange\n\n                Matches if the routing key property of the message and\n                the :attr:`routing_key` attribute are identical.\n\n            * fanout exchange\n\n                Always matches, even if the binding does not have a key.\n\n            * topic exchange\n\n                Matches the routing key property of the message by a primitive\n                pattern matching scheme. The message routing key then consists\n                of words separated by dots (``"."``, like domain names), and\n                two special characters are available; star (``"*"``) and hash\n                (``"#"``). The star matches any word, and the hash matches\n                zero or more words. For example ``"*.stock.#"`` matches the\n                routing keys ``"usd.stock"`` and ``"eur.stock.db"`` but not\n                ``"stock.nasdaq"``.\n\n    .. attribute:: durable\n\n        Durable exchanges remain active when a server restarts. Non-durable\n        exchanges (transient exchanges) are purged when a server restarts.\n        Default is ``True``.\n\n    .. attribute:: auto_delete\n\n        If set, the exchange is deleted when all queues have finished\n        using it. Default is ``False``.\n\n    .. attribute:: exclusive\n\n        Exclusive queues may only be consumed from by the current connection.\n        When :attr:`exclusive` is on, this also implies :attr:`auto_delete`.\n        Default is ``False``.\n\n    .. attribute:: exchange_type\n\n        AMQP defines four default exchange types (routing algorithms) that\n        covers most of the common messaging use cases. An AMQP broker can\n        also define additional exchange types, so see your message brokers\n        manual for more information about available exchange types.\n\n            * Direct\n\n                Direct match between the routing key in the message, and the\n                routing criteria used when a queue is bound to this exchange.\n\n            * Topic\n\n                Wildcard match between the routing key and the routing pattern\n                specified in the binding. The routing key is treated as zero\n                or more words delimited by ``"."`` and supports special\n                wildcard characters. ``"*"`` matches a single word and ``"#"``\n                matches zero or more words.\n\n            * Fanout\n\n                Queues are bound to this exchange with no arguments. Hence any\n                message sent to this exchange will be forwarded to all queues\n                bound to this exchange.\n\n            * Headers\n\n                Queues are bound to this exchange with a table of arguments\n                containing headers and values (optional). A special argument\n                named "x-match" determines the matching algorithm, where\n                ``"all"`` implies an ``AND`` (all pairs must match) and\n                ``"any"`` implies ``OR`` (at least one pair must match).\n\n                Use the :attr:`routing_key`` is used to specify the arguments,\n                the same when sending messages.\n\n            This description of AMQP exchange types was shamelessly stolen\n            from the blog post `AMQP in 10 minutes: Part 4`_ by\n            Rajith Attapattu. Recommended reading.\n\n            .. _`AMQP in 10 minutes: Part 4`:\n                http://bit.ly/amqp-exchange-types\n\n    .. attribute:: callbacks\n\n        List of registered callbacks to trigger when a message is received\n        by :meth:`wait`, :meth:`process_next` or :meth:`iterqueue`.\n\n    .. attribute:: warn_if_exists\n\n        Emit a warning if the queue has already been declared. If a queue\n        already exists, and you try to redeclare the queue with new settings,\n        the new settings will be silently ignored, so this can be\n        useful if you\'ve recently changed the :attr:`routing_key` attribute\n        or other settings.\n\n    .. attribute:: auto_ack\n\n        Acknowledgement is handled automatically once messages are received.\n        This means that the :meth:`carrot.backends.base.BaseMessage.ack` and\n        :meth:`carrot.backends.base.BaseMessage.reject` methods\n        on the message object are no longer valid.\n        By default :attr:`auto_ack` is set to ``False``, and the receiver is\n        required to manually handle acknowledgment.\n\n    .. attribute:: no_ack\n\n        Disable acknowledgement on the server-side. This is different from\n        :attr:`auto_ack` in that acknowledgement is turned off altogether.\n        This functionality increases performance but at the cost of\n        reliability. Messages can get lost if a client dies before it can\n        deliver them to the application.\n\n    .. attribute auto_declare\n\n        If this is ``True`` the following will be automatically declared:\n\n            * The queue if :attr:`queue` is set.\n            * The exchange if :attr:`exchange` is set.\n            * The :attr:`queue` will be bound to the :attr:`exchange`.\n\n        This is the default behaviour.\n\n\n    :raises `amqplib.client_0_8.channel.AMQPChannelException`: if the queue is\n        exclusive and the queue already exists and is owned by another\n        connection.\n\n\n    Example Usage\n\n        >>> consumer = Consumer(connection=DjangoBrokerConnection(),\n        ...               queue="foo", exchange="foo", routing_key="foo")\n        >>> def process_message(message_data, message):\n        ...     print("Got message %s: %s" % (\n        ...             message.delivery_tag, message_data))\n        >>> consumer.register_callback(process_message)\n        >>> consumer.wait() # Go into receive loop\n\n    """'
newline|'\n'
DECL|variable|queue
name|'queue'
op|'='
string|'""'
newline|'\n'
DECL|variable|exchange
name|'exchange'
op|'='
string|'""'
newline|'\n'
DECL|variable|routing_key
name|'routing_key'
op|'='
string|'""'
newline|'\n'
DECL|variable|durable
name|'durable'
op|'='
name|'True'
newline|'\n'
DECL|variable|exclusive
name|'exclusive'
op|'='
name|'False'
newline|'\n'
DECL|variable|auto_delete
name|'auto_delete'
op|'='
name|'False'
newline|'\n'
DECL|variable|exchange_type
name|'exchange_type'
op|'='
string|'"direct"'
newline|'\n'
DECL|variable|channel_open
name|'channel_open'
op|'='
name|'False'
newline|'\n'
DECL|variable|warn_if_exists
name|'warn_if_exists'
op|'='
name|'False'
newline|'\n'
DECL|variable|auto_declare
name|'auto_declare'
op|'='
name|'True'
newline|'\n'
DECL|variable|auto_ack
name|'auto_ack'
op|'='
name|'False'
newline|'\n'
DECL|variable|no_ack
name|'no_ack'
op|'='
name|'False'
newline|'\n'
DECL|variable|_closed
name|'_closed'
op|'='
name|'True'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'connection'
op|','
name|'queue'
op|'='
name|'None'
op|','
name|'exchange'
op|'='
name|'None'
op|','
nl|'\n'
name|'routing_key'
op|'='
name|'None'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'connection'
op|'='
name|'connection'
newline|'\n'
name|'self'
op|'.'
name|'backend'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|'"backend"'
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'backend'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'backend'
op|'='
name|'self'
op|'.'
name|'connection'
op|'.'
name|'create_backend'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'queue'
op|'='
name|'queue'
name|'or'
name|'self'
op|'.'
name|'queue'
newline|'\n'
nl|'\n'
comment|'# Binding.'
nl|'\n'
name|'self'
op|'.'
name|'queue'
op|'='
name|'queue'
name|'or'
name|'self'
op|'.'
name|'queue'
newline|'\n'
name|'self'
op|'.'
name|'exchange'
op|'='
name|'exchange'
name|'or'
name|'self'
op|'.'
name|'exchange'
newline|'\n'
name|'self'
op|'.'
name|'routing_key'
op|'='
name|'routing_key'
name|'or'
name|'self'
op|'.'
name|'routing_key'
newline|'\n'
name|'self'
op|'.'
name|'callbacks'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
comment|'# Options'
nl|'\n'
name|'self'
op|'.'
name|'durable'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|'"durable"'
op|','
name|'self'
op|'.'
name|'durable'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'exclusive'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|'"exclusive"'
op|','
name|'self'
op|'.'
name|'exclusive'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'auto_delete'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|'"auto_delete"'
op|','
name|'self'
op|'.'
name|'auto_delete'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'exchange_type'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|'"exchange_type"'
op|','
name|'self'
op|'.'
name|'exchange_type'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'warn_if_exists'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|'"warn_if_exists"'
op|','
nl|'\n'
name|'self'
op|'.'
name|'warn_if_exists'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'auto_ack'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|'"auto_ack"'
op|','
name|'self'
op|'.'
name|'auto_ack'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'auto_declare'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|'"auto_declare"'
op|','
name|'self'
op|'.'
name|'auto_declare'
op|')'
newline|'\n'
nl|'\n'
comment|'# exclusive implies auto-delete.'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'exclusive'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'auto_delete'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'consumer_tag'
op|'='
name|'self'
op|'.'
name|'_generate_consumer_tag'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'auto_declare'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'declare'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|__enter__
dedent|''
dedent|''
name|'def'
name|'__enter__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
newline|'\n'
nl|'\n'
DECL|member|__exit__
dedent|''
name|'def'
name|'__exit__'
op|'('
name|'self'
op|','
name|'e_type'
op|','
name|'e_value'
op|','
name|'e_trace'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'e_type'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'e_type'
op|'('
name|'e_value'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|__iter__
dedent|''
name|'def'
name|'__iter__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""iter(Consumer) -> Consumer.iterqueue(infinite=True)"""'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'iterqueue'
op|'('
name|'infinite'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_generate_consumer_tag
dedent|''
name|'def'
name|'_generate_consumer_tag'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Generate a unique consumer tag.\n\n        :rtype string:\n\n        """'
newline|'\n'
name|'return'
string|'"%s.%s-%s"'
op|'%'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'__class__'
op|'.'
name|'__module__'
op|','
nl|'\n'
name|'self'
op|'.'
name|'__class__'
op|'.'
name|'__name__'
op|','
nl|'\n'
name|'gen_unique_id'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|declare
dedent|''
name|'def'
name|'declare'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Declares the queue, the exchange and binds the queue to\n        the exchange."""'
newline|'\n'
name|'arguments'
op|'='
name|'None'
newline|'\n'
name|'routing_key'
op|'='
name|'self'
op|'.'
name|'routing_key'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'exchange_type'
op|'=='
string|'"headers"'
op|':'
newline|'\n'
indent|'            '
name|'arguments'
op|','
name|'routing_key'
op|'='
name|'routing_key'
op|','
string|'""'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'queue'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'backend'
op|'.'
name|'queue_declare'
op|'('
name|'queue'
op|'='
name|'self'
op|'.'
name|'queue'
op|','
name|'durable'
op|'='
name|'self'
op|'.'
name|'durable'
op|','
nl|'\n'
name|'exclusive'
op|'='
name|'self'
op|'.'
name|'exclusive'
op|','
nl|'\n'
name|'auto_delete'
op|'='
name|'self'
op|'.'
name|'auto_delete'
op|','
nl|'\n'
name|'warn_if_exists'
op|'='
name|'self'
op|'.'
name|'warn_if_exists'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'exchange'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'backend'
op|'.'
name|'exchange_declare'
op|'('
name|'exchange'
op|'='
name|'self'
op|'.'
name|'exchange'
op|','
nl|'\n'
name|'type'
op|'='
name|'self'
op|'.'
name|'exchange_type'
op|','
nl|'\n'
name|'durable'
op|'='
name|'self'
op|'.'
name|'durable'
op|','
nl|'\n'
name|'auto_delete'
op|'='
name|'self'
op|'.'
name|'auto_delete'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'queue'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'backend'
op|'.'
name|'queue_bind'
op|'('
name|'queue'
op|'='
name|'self'
op|'.'
name|'queue'
op|','
nl|'\n'
name|'exchange'
op|'='
name|'self'
op|'.'
name|'exchange'
op|','
nl|'\n'
name|'routing_key'
op|'='
name|'routing_key'
op|','
nl|'\n'
name|'arguments'
op|'='
name|'arguments'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_closed'
op|'='
name|'False'
newline|'\n'
name|'return'
name|'self'
newline|'\n'
nl|'\n'
DECL|member|_receive_callback
dedent|''
name|'def'
name|'_receive_callback'
op|'('
name|'self'
op|','
name|'raw_message'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Internal method used when a message is received in consume mode."""'
newline|'\n'
name|'message'
op|'='
name|'self'
op|'.'
name|'backend'
op|'.'
name|'message_to_python'
op|'('
name|'raw_message'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'auto_ack'
name|'and'
name|'not'
name|'message'
op|'.'
name|'acknowledged'
op|':'
newline|'\n'
indent|'            '
name|'message'
op|'.'
name|'ack'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'receive'
op|'('
name|'message'
op|'.'
name|'payload'
op|','
name|'message'
op|')'
newline|'\n'
nl|'\n'
DECL|member|fetch
dedent|''
name|'def'
name|'fetch'
op|'('
name|'self'
op|','
name|'no_ack'
op|'='
name|'None'
op|','
name|'auto_ack'
op|'='
name|'None'
op|','
name|'enable_callbacks'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Receive the next message waiting on the queue.\n\n        :returns: A :class:`carrot.backends.base.BaseMessage` instance,\n            or ``None`` if there\'s no messages to be received.\n\n        :keyword enable_callbacks: Enable callbacks. The message will be\n            processed with all registered callbacks. Default is disabled.\n        :keyword auto_ack: Override the default :attr:`auto_ack` setting.\n        :keyword no_ack: Override the default :attr:`no_ack` setting.\n\n        """'
newline|'\n'
name|'no_ack'
op|'='
name|'no_ack'
name|'or'
name|'self'
op|'.'
name|'no_ack'
newline|'\n'
name|'auto_ack'
op|'='
name|'auto_ack'
name|'or'
name|'self'
op|'.'
name|'auto_ack'
newline|'\n'
name|'message'
op|'='
name|'self'
op|'.'
name|'backend'
op|'.'
name|'get'
op|'('
name|'self'
op|'.'
name|'queue'
op|','
name|'no_ack'
op|'='
name|'no_ack'
op|')'
newline|'\n'
name|'if'
name|'message'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'auto_ack'
name|'and'
name|'not'
name|'message'
op|'.'
name|'acknowledged'
op|':'
newline|'\n'
indent|'                '
name|'message'
op|'.'
name|'ack'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'enable_callbacks'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'receive'
op|'('
name|'message'
op|'.'
name|'payload'
op|','
name|'message'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'message'
newline|'\n'
nl|'\n'
DECL|member|process_next
dedent|''
name|'def'
name|'process_next'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""**DEPRECATED** Use :meth:`fetch` like this instead:\n\n            >>> message = self.fetch(enable_callbacks=True)\n\n        """'
newline|'\n'
name|'warnings'
op|'.'
name|'warn'
op|'('
name|'DeprecationWarning'
op|'('
nl|'\n'
string|'"Consumer.process_next has been deprecated in favor of \\\n            Consumer.fetch(enable_callbacks=True)"'
op|')'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'fetch'
op|'('
name|'enable_callbacks'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
DECL|member|receive
dedent|''
name|'def'
name|'receive'
op|'('
name|'self'
op|','
name|'message_data'
op|','
name|'message'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""This method is called when a new message is received by\n        running :meth:`wait`, :meth:`process_next` or :meth:`iterqueue`.\n\n        When a message is received, it passes the message on to the\n        callbacks listed in the :attr:`callbacks` attribute.\n        You can register callbacks using :meth:`register_callback`.\n\n        :param message_data: The deserialized message data.\n\n        :param message: The :class:`carrot.backends.base.BaseMessage` instance.\n\n        :raises NotImplementedError: If no callbacks has been registered.\n\n        """'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'callbacks'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'NotImplementedError'
op|'('
string|'"No consumer callbacks registered"'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'callback'
name|'in'
name|'self'
op|'.'
name|'callbacks'
op|':'
newline|'\n'
indent|'            '
name|'callback'
op|'('
name|'message_data'
op|','
name|'message'
op|')'
newline|'\n'
nl|'\n'
DECL|member|register_callback
dedent|''
dedent|''
name|'def'
name|'register_callback'
op|'('
name|'self'
op|','
name|'callback'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Register a callback function to be triggered by :meth:`receive`.\n\n        The ``callback`` function must take two arguments:\n\n            * message_data\n\n                The deserialized message data\n\n            * message\n\n                The :class:`carrot.backends.base.BaseMessage` instance.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'callbacks'
op|'.'
name|'append'
op|'('
name|'callback'
op|')'
newline|'\n'
nl|'\n'
DECL|member|discard_all
dedent|''
name|'def'
name|'discard_all'
op|'('
name|'self'
op|','
name|'filterfunc'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Discard all waiting messages.\n\n        :param filterfunc: A filter function to only discard the messages this\n            filter returns.\n\n        :returns: the number of messages discarded.\n\n        *WARNING*: All incoming messages will be ignored and not processed.\n\n        Example using filter:\n\n            >>> def waiting_feeds_only(message):\n            ...     try:\n            ...         message_data = message.decode()\n            ...     except: # Should probably be more specific.\n            ...         pass\n            ...\n            ...     if message_data.get("type") == "feed":\n            ...         return True\n            ...     else:\n            ...         return False\n        """'
newline|'\n'
name|'if'
name|'not'
name|'filterfunc'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'backend'
op|'.'
name|'queue_purge'
op|'('
name|'self'
op|'.'
name|'queue'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'no_ack'
name|'or'
name|'self'
op|'.'
name|'auto_ack'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'Exception'
op|'('
string|'"discard_all: Can\'t use filter with auto/no-ack."'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'discarded_count'
op|'='
number|'0'
newline|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'message'
op|'='
name|'self'
op|'.'
name|'fetch'
op|'('
op|')'
newline|'\n'
name|'if'
name|'message'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'discarded_count'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'filterfunc'
op|'('
name|'message'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'message'
op|'.'
name|'ack'
op|'('
op|')'
newline|'\n'
name|'discarded_count'
op|'+='
number|'1'
newline|'\n'
nl|'\n'
DECL|member|iterconsume
dedent|''
dedent|''
dedent|''
name|'def'
name|'iterconsume'
op|'('
name|'self'
op|','
name|'limit'
op|'='
name|'None'
op|','
name|'no_ack'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Iterator processing new messages as they arrive.\n        Every new message will be passed to the callbacks, and the iterator\n        returns ``True``. The iterator is infinite unless the ``limit``\n        argument is specified or someone closes the consumer.\n\n        :meth:`iterconsume` uses transient requests for messages on the\n        server, while :meth:`iterequeue` uses synchronous access. In most\n        cases you want :meth:`iterconsume`, but if your environment does not\n        support this behaviour you can resort to using :meth:`iterqueue`\n        instead.\n\n        Also, :meth:`iterconsume` does not return the message\n        at each step, something which :meth:`iterqueue` does.\n\n        :keyword limit: Maximum number of messages to process.\n\n        :raises StopIteration: if limit is set and the message limit has been\n            reached.\n\n        """'
newline|'\n'
name|'no_ack'
op|'='
name|'no_ack'
name|'or'
name|'self'
op|'.'
name|'no_ack'
newline|'\n'
name|'self'
op|'.'
name|'backend'
op|'.'
name|'declare_consumer'
op|'('
name|'queue'
op|'='
name|'self'
op|'.'
name|'queue'
op|','
name|'no_ack'
op|'='
name|'no_ack'
op|','
nl|'\n'
name|'callback'
op|'='
name|'self'
op|'.'
name|'_receive_callback'
op|','
nl|'\n'
name|'consumer_tag'
op|'='
name|'self'
op|'.'
name|'consumer_tag'
op|','
nl|'\n'
name|'nowait'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'channel_open'
op|'='
name|'True'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'backend'
op|'.'
name|'consume'
op|'('
name|'limit'
op|'='
name|'limit'
op|')'
newline|'\n'
nl|'\n'
DECL|member|wait
dedent|''
name|'def'
name|'wait'
op|'('
name|'self'
op|','
name|'limit'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Go into consume mode.\n\n        Mostly for testing purposes and simple programs, you probably\n        want :meth:`iterconsume` or :meth:`iterqueue` instead.\n\n        This runs an infinite loop, processing all incoming messages\n        using :meth:`receive` to apply the message to all registered\n        callbacks.\n\n        """'
newline|'\n'
name|'it'
op|'='
name|'self'
op|'.'
name|'iterconsume'
op|'('
name|'limit'
op|')'
newline|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'it'
op|'.'
name|'next'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|iterqueue
dedent|''
dedent|''
name|'def'
name|'iterqueue'
op|'('
name|'self'
op|','
name|'limit'
op|'='
name|'None'
op|','
name|'infinite'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Infinite iterator yielding pending messages, by using\n        synchronous direct access to the queue (``basic_get``).\n\n        :meth:`iterqueue` is used where synchronous functionality is more\n        important than performance. If you can, use :meth:`iterconsume`\n        instead.\n\n        :keyword limit: If set, the iterator stops when it has processed\n            this number of messages in total.\n\n        :keyword infinite: Don\'t raise :exc:`StopIteration` if there is no\n            messages waiting, but return ``None`` instead. If infinite you\n            obviously shouldn\'t consume the whole iterator at once without\n            using a ``limit``.\n\n        :raises StopIteration: If there is no messages waiting, and the\n            iterator is not infinite.\n\n        """'
newline|'\n'
name|'for'
name|'items_since_start'
name|'in'
name|'count'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'item'
op|'='
name|'self'
op|'.'
name|'fetch'
op|'('
op|')'
newline|'\n'
name|'if'
op|'('
name|'not'
name|'infinite'
name|'and'
name|'item'
name|'is'
name|'None'
op|')'
name|'or'
op|'('
name|'limit'
name|'and'
name|'items_since_start'
op|'>='
name|'limit'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'StopIteration'
newline|'\n'
dedent|''
name|'yield'
name|'item'
newline|'\n'
nl|'\n'
DECL|member|cancel
dedent|''
dedent|''
name|'def'
name|'cancel'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Cancel a running :meth:`iterconsume` session."""'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'channel_open'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'backend'
op|'.'
name|'cancel'
op|'('
name|'self'
op|'.'
name|'consumer_tag'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|close
dedent|''
dedent|''
dedent|''
name|'def'
name|'close'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Close the channel to the queue."""'
newline|'\n'
name|'self'
op|'.'
name|'cancel'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'backend'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_closed'
op|'='
name|'True'
newline|'\n'
nl|'\n'
DECL|member|flow
dedent|''
name|'def'
name|'flow'
op|'('
name|'self'
op|','
name|'active'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""This method asks the peer to pause or restart the flow of\n        content data.\n\n        This is a simple flow-control mechanism that a\n        peer can use to avoid oveflowing its queues or otherwise\n        finding itself receiving more messages than it can process.\n        Note that this method is not intended for window control.  The\n        peer that receives a request to stop sending content should\n        finish sending the current content, if any, and then wait\n        until it receives the ``flow(active=True)`` restart method.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'backend'
op|'.'
name|'flow'
op|'('
name|'active'
op|')'
newline|'\n'
nl|'\n'
DECL|member|qos
dedent|''
name|'def'
name|'qos'
op|'('
name|'self'
op|','
name|'prefetch_size'
op|'='
number|'0'
op|','
name|'prefetch_count'
op|'='
number|'0'
op|','
name|'apply_global'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Request specific Quality of Service.\n\n        This method requests a specific quality of service.  The QoS\n        can be specified for the current channel or for all channels\n        on the connection.  The particular properties and semantics of\n        a qos method always depend on the content class semantics.\n        Though the qos method could in principle apply to both peers,\n        it is currently meaningful only for the server.\n\n        :param prefetch_size: Prefetch window in octets.\n            The client can request that messages be sent in\n            advance so that when the client finishes processing a\n            message, the following message is already held\n            locally, rather than needing to be sent down the\n            channel.  Prefetching gives a performance improvement.\n            This field specifies the prefetch window size in\n            octets.  The server will send a message in advance if\n            it is equal to or smaller in size than the available\n            prefetch size (and also falls into other prefetch\n            limits). May be set to zero, meaning "no specific\n            limit", although other prefetch limits may still\n            apply. The ``prefetch_size`` is ignored if the\n            :attr:`no_ack` option is set.\n\n        :param prefetch_count: Specifies a prefetch window in terms of whole\n            messages. This field may be used in combination with\n            ``prefetch_size``; A message will only be sent\n            in advance if both prefetch windows (and those at the\n            channel and connection level) allow it. The prefetch-\n            count is ignored if the :attr:`no_ack` option is set.\n\n        :keyword apply_global: By default the QoS settings apply to the\n            current channel only. If this is set, they are applied\n            to the entire connection.\n\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'backend'
op|'.'
name|'qos'
op|'('
name|'prefetch_size'
op|','
name|'prefetch_count'
op|','
name|'apply_global'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Publisher
dedent|''
dedent|''
name|'class'
name|'Publisher'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Message publisher.\n\n    :param connection: see :attr:`connection`.\n    :param exchange: see :attr:`exchange`.\n    :param routing_key: see :attr:`routing_key`.\n\n    :keyword exchange_type: see :attr:`Consumer.exchange_type`.\n    :keyword durable: see :attr:`Consumer.durable`.\n    :keyword auto_delete: see :attr:`Consumer.auto_delete`.\n    :keyword serializer: see :attr:`serializer`.\n    :keyword auto_declare: See :attr:`auto_declare`.\n\n\n    .. attribute:: connection\n\n        The connection to the broker.\n        A :class:`carrot.connection.BrokerConnection` instance.\n\n    .. attribute:: exchange\n\n        Name of the exchange we send messages to.\n\n    .. attribute:: routing_key\n\n        The default routing key for messages sent using this publisher.\n        See :attr:`Consumer.routing_key` for more information.\n        You can override the routing key by passing an explicit\n        ``routing_key`` argument to :meth:`send`.\n\n    .. attribute:: delivery_mode\n\n        The default delivery mode used for messages. The value is an integer.\n        The following delivery modes are supported by (at least) RabbitMQ:\n\n            * 1 or "non-persistent"\n\n                The message is non-persistent. Which means it is stored in\n                memory only, and is lost if the server dies or restarts.\n\n            * 2 or "persistent"\n                The message is persistent. Which means the message is\n                stored both in-memory, and on disk, and therefore\n                preserved if the server dies or restarts.\n\n        The default value is ``2`` (persistent).\n\n    .. attribute:: exchange_type\n\n        See :attr:`Consumer.exchange_type`.\n\n    .. attribute:: durable\n\n        See :attr:`Consumer.durable`.\n\n    .. attribute:: auto_delete\n\n        See :attr:`Consumer.auto_delete`.\n\n    .. attribute:: auto_declare\n\n        If this is ``True`` and the :attr:`exchange` name is set, the exchange\n        will be automatically declared at instantiation.\n        You can manually the declare the exchange by using the :meth:`declare`\n        method.\n\n        Auto declare is on by default.\n\n    .. attribute:: serializer\n\n        A string identifying the default serialization method to use.\n        Defaults to ``json``. Can be ``json`` (default), ``raw``,\n        ``pickle``, ``hessian``, ``yaml``, or any custom serialization\n        methods that have been registered with\n        :mod:`carrot.serialization.registry`.\n\n    """'
newline|'\n'
nl|'\n'
DECL|variable|NONE_PERSISTENT_DELIVERY_MODE
name|'NONE_PERSISTENT_DELIVERY_MODE'
op|'='
number|'1'
newline|'\n'
DECL|variable|PERSISTENT_DELIVERY_MODE
name|'PERSISTENT_DELIVERY_MODE'
op|'='
number|'2'
newline|'\n'
DECL|variable|DELIVERY_MODES
name|'DELIVERY_MODES'
op|'='
op|'{'
nl|'\n'
string|'"non-persistent"'
op|':'
name|'NONE_PERSISTENT_DELIVERY_MODE'
op|','
nl|'\n'
string|'"persistent"'
op|':'
name|'PERSISTENT_DELIVERY_MODE'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
DECL|variable|exchange
name|'exchange'
op|'='
string|'""'
newline|'\n'
DECL|variable|routing_key
name|'routing_key'
op|'='
string|'""'
newline|'\n'
DECL|variable|delivery_mode
name|'delivery_mode'
op|'='
name|'PERSISTENT_DELIVERY_MODE'
newline|'\n'
DECL|variable|_closed
name|'_closed'
op|'='
name|'True'
newline|'\n'
DECL|variable|exchange_type
name|'exchange_type'
op|'='
string|'"direct"'
newline|'\n'
DECL|variable|durable
name|'durable'
op|'='
name|'True'
newline|'\n'
DECL|variable|auto_delete
name|'auto_delete'
op|'='
name|'False'
newline|'\n'
DECL|variable|auto_declare
name|'auto_declare'
op|'='
name|'True'
newline|'\n'
DECL|variable|serializer
name|'serializer'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'connection'
op|','
name|'exchange'
op|'='
name|'None'
op|','
name|'routing_key'
op|'='
name|'None'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'connection'
op|'='
name|'connection'
newline|'\n'
name|'self'
op|'.'
name|'backend'
op|'='
name|'self'
op|'.'
name|'connection'
op|'.'
name|'create_backend'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'exchange'
op|'='
name|'exchange'
name|'or'
name|'self'
op|'.'
name|'exchange'
newline|'\n'
name|'self'
op|'.'
name|'routing_key'
op|'='
name|'routing_key'
name|'or'
name|'self'
op|'.'
name|'routing_key'
newline|'\n'
name|'self'
op|'.'
name|'delivery_mode'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|'"delivery_mode"'
op|','
name|'self'
op|'.'
name|'delivery_mode'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'delivery_mode'
op|'='
name|'self'
op|'.'
name|'DELIVERY_MODES'
op|'.'
name|'get'
op|'('
name|'self'
op|'.'
name|'delivery_mode'
op|','
nl|'\n'
name|'self'
op|'.'
name|'delivery_mode'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'exchange_type'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|'"exchange_type"'
op|','
name|'self'
op|'.'
name|'exchange_type'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'durable'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|'"durable"'
op|','
name|'self'
op|'.'
name|'durable'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'auto_delete'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|'"auto_delete"'
op|','
name|'self'
op|'.'
name|'auto_delete'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'serializer'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|'"serializer"'
op|','
name|'self'
op|'.'
name|'serializer'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'auto_declare'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|'"auto_declare"'
op|','
name|'self'
op|'.'
name|'auto_declare'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_closed'
op|'='
name|'False'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'auto_declare'
name|'and'
name|'self'
op|'.'
name|'exchange'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'declare'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|declare
dedent|''
dedent|''
name|'def'
name|'declare'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Declare the exchange.\n\n        Creates the exchange on the broker.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'backend'
op|'.'
name|'exchange_declare'
op|'('
name|'exchange'
op|'='
name|'self'
op|'.'
name|'exchange'
op|','
nl|'\n'
name|'type'
op|'='
name|'self'
op|'.'
name|'exchange_type'
op|','
nl|'\n'
name|'durable'
op|'='
name|'self'
op|'.'
name|'durable'
op|','
nl|'\n'
name|'auto_delete'
op|'='
name|'self'
op|'.'
name|'auto_delete'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__enter__
dedent|''
name|'def'
name|'__enter__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
newline|'\n'
nl|'\n'
DECL|member|__exit__
dedent|''
name|'def'
name|'__exit__'
op|'('
name|'self'
op|','
name|'e_type'
op|','
name|'e_value'
op|','
name|'e_trace'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'e_type'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'e_type'
op|'('
name|'e_value'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|create_message
dedent|''
name|'def'
name|'create_message'
op|'('
name|'self'
op|','
name|'message_data'
op|','
name|'delivery_mode'
op|'='
name|'None'
op|','
name|'priority'
op|'='
name|'None'
op|','
nl|'\n'
name|'content_type'
op|'='
name|'None'
op|','
name|'content_encoding'
op|'='
name|'None'
op|','
nl|'\n'
name|'serializer'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""With any data, serialize it and encapsulate it in a AMQP\n        message with the proper headers set."""'
newline|'\n'
nl|'\n'
name|'delivery_mode'
op|'='
name|'delivery_mode'
name|'or'
name|'self'
op|'.'
name|'delivery_mode'
newline|'\n'
nl|'\n'
comment|"# No content_type? Then we're serializing the data internally."
nl|'\n'
name|'if'
name|'not'
name|'content_type'
op|':'
newline|'\n'
indent|'            '
name|'serializer'
op|'='
name|'serializer'
name|'or'
name|'self'
op|'.'
name|'serializer'
newline|'\n'
op|'('
name|'content_type'
op|','
name|'content_encoding'
op|','
nl|'\n'
name|'message_data'
op|')'
op|'='
name|'serialization'
op|'.'
name|'encode'
op|'('
name|'message_data'
op|','
nl|'\n'
name|'serializer'
op|'='
name|'serializer'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|"# If the programmer doesn't want us to serialize,"
nl|'\n'
comment|'# make sure content_encoding is set.'
nl|'\n'
indent|'            '
name|'if'
name|'isinstance'
op|'('
name|'message_data'
op|','
name|'unicode'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'not'
name|'content_encoding'
op|':'
newline|'\n'
indent|'                    '
name|'content_encoding'
op|'='
string|"'utf-8'"
newline|'\n'
dedent|''
name|'message_data'
op|'='
name|'message_data'
op|'.'
name|'encode'
op|'('
name|'content_encoding'
op|')'
newline|'\n'
nl|'\n'
comment|"# If they passed in a string, we can't know anything"
nl|'\n'
comment|"# about it.  So assume it's binary data."
nl|'\n'
dedent|''
name|'elif'
name|'not'
name|'content_encoding'
op|':'
newline|'\n'
indent|'                '
name|'content_encoding'
op|'='
string|"'binary'"
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'backend'
op|'.'
name|'prepare_message'
op|'('
name|'message_data'
op|','
name|'delivery_mode'
op|','
nl|'\n'
name|'priority'
op|'='
name|'priority'
op|','
nl|'\n'
name|'content_type'
op|'='
name|'content_type'
op|','
nl|'\n'
name|'content_encoding'
op|'='
name|'content_encoding'
op|')'
newline|'\n'
nl|'\n'
DECL|member|send
dedent|''
name|'def'
name|'send'
op|'('
name|'self'
op|','
name|'message_data'
op|','
name|'routing_key'
op|'='
name|'None'
op|','
name|'delivery_mode'
op|'='
name|'None'
op|','
nl|'\n'
name|'mandatory'
op|'='
name|'False'
op|','
name|'immediate'
op|'='
name|'False'
op|','
name|'priority'
op|'='
number|'0'
op|','
name|'content_type'
op|'='
name|'None'
op|','
nl|'\n'
name|'content_encoding'
op|'='
name|'None'
op|','
name|'serializer'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Send a message.\n\n        :param message_data: The message data to send. Can be a list,\n            dictionary or a string.\n\n        :keyword routing_key: A custom routing key for the message.\n            If not set, the default routing key set in the :attr:`routing_key`\n            attribute is used.\n\n        :keyword mandatory: If set, the message has mandatory routing.\n            By default the message is silently dropped by the server if it\n            can\'t be routed to a queue. However - If the message is mandatory,\n            an exception will be raised instead.\n\n        :keyword immediate: Request immediate delivery.\n            If the message cannot be routed to a queue consumer immediately,\n            an exception will be raised. This is instead of the default\n            behaviour, where the server will accept and queue the message,\n            but with no guarantee that the message will ever be consumed.\n\n        :keyword delivery_mode: Override the default :attr:`delivery_mode`.\n\n        :keyword priority: The message priority, ``0`` to ``9``.\n\n        :keyword content_type: The messages content_type. If content_type\n            is set, no serialization occurs as it is assumed this is either\n            a binary object, or you\'ve done your own serialization.\n            Leave blank if using built-in serialization as our library\n            properly sets content_type.\n\n        :keyword content_encoding: The character set in which this object\n            is encoded. Use "binary" if sending in raw binary objects.\n            Leave blank if using built-in serialization as our library\n            properly sets content_encoding.\n\n        :keyword serializer: Override the default :attr:`serializer`.\n\n        """'
newline|'\n'
name|'headers'
op|'='
name|'None'
newline|'\n'
name|'routing_key'
op|'='
name|'routing_key'
name|'or'
name|'self'
op|'.'
name|'routing_key'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'exchange_type'
op|'=='
string|'"headers"'
op|':'
newline|'\n'
indent|'            '
name|'headers'
op|','
name|'routing_key'
op|'='
name|'routing_key'
op|','
string|'""'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
name|'message'
op|'='
name|'self'
op|'.'
name|'create_message'
op|'('
name|'message_data'
op|','
name|'priority'
op|'='
name|'priority'
op|','
nl|'\n'
name|'delivery_mode'
op|'='
name|'delivery_mode'
op|','
nl|'\n'
name|'content_type'
op|'='
name|'content_type'
op|','
nl|'\n'
name|'content_encoding'
op|'='
name|'content_encoding'
op|','
nl|'\n'
name|'serializer'
op|'='
name|'serializer'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'backend'
op|'.'
name|'publish'
op|'('
name|'message'
op|','
nl|'\n'
name|'exchange'
op|'='
name|'self'
op|'.'
name|'exchange'
op|','
name|'routing_key'
op|'='
name|'routing_key'
op|','
nl|'\n'
name|'mandatory'
op|'='
name|'mandatory'
op|','
name|'immediate'
op|'='
name|'immediate'
op|','
nl|'\n'
name|'headers'
op|'='
name|'headers'
op|')'
newline|'\n'
nl|'\n'
DECL|member|close
dedent|''
name|'def'
name|'close'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Close connection to queue."""'
newline|'\n'
name|'self'
op|'.'
name|'backend'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_closed'
op|'='
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Messaging
dedent|''
dedent|''
name|'class'
name|'Messaging'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""A combined message publisher and consumer."""'
newline|'\n'
DECL|variable|queue
name|'queue'
op|'='
string|'""'
newline|'\n'
DECL|variable|exchange
name|'exchange'
op|'='
string|'""'
newline|'\n'
DECL|variable|routing_key
name|'routing_key'
op|'='
string|'""'
newline|'\n'
DECL|variable|publisher_cls
name|'publisher_cls'
op|'='
name|'Publisher'
newline|'\n'
DECL|variable|consumer_cls
name|'consumer_cls'
op|'='
name|'Consumer'
newline|'\n'
DECL|variable|_closed
name|'_closed'
op|'='
name|'True'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'connection'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'connection'
op|'='
name|'connection'
newline|'\n'
name|'self'
op|'.'
name|'exchange'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|'"exchange"'
op|','
name|'self'
op|'.'
name|'exchange'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'queue'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|'"queue"'
op|','
name|'self'
op|'.'
name|'queue'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'routing_key'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|'"routing_key"'
op|','
name|'self'
op|'.'
name|'routing_key'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'publisher'
op|'='
name|'self'
op|'.'
name|'publisher_cls'
op|'('
name|'connection'
op|','
nl|'\n'
name|'exchange'
op|'='
name|'self'
op|'.'
name|'exchange'
op|','
name|'routing_key'
op|'='
name|'self'
op|'.'
name|'routing_key'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'consumer'
op|'='
name|'self'
op|'.'
name|'consumer_cls'
op|'('
name|'connection'
op|','
name|'queue'
op|'='
name|'self'
op|'.'
name|'queue'
op|','
nl|'\n'
name|'exchange'
op|'='
name|'self'
op|'.'
name|'exchange'
op|','
name|'routing_key'
op|'='
name|'self'
op|'.'
name|'routing_key'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'consumer'
op|'.'
name|'register_callback'
op|'('
name|'self'
op|'.'
name|'receive'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'callbacks'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_closed'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|member|__enter__
dedent|''
name|'def'
name|'__enter__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
newline|'\n'
nl|'\n'
DECL|member|__exit__
dedent|''
name|'def'
name|'__exit__'
op|'('
name|'self'
op|','
name|'e_type'
op|','
name|'e_value'
op|','
name|'e_trace'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'e_type'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'e_type'
op|'('
name|'e_value'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|register_callback
dedent|''
name|'def'
name|'register_callback'
op|'('
name|'self'
op|','
name|'callback'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""See :meth:`Consumer.register_callback`"""'
newline|'\n'
name|'self'
op|'.'
name|'callbacks'
op|'.'
name|'append'
op|'('
name|'callback'
op|')'
newline|'\n'
nl|'\n'
DECL|member|receive
dedent|''
name|'def'
name|'receive'
op|'('
name|'self'
op|','
name|'message_data'
op|','
name|'message'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""See :meth:`Consumer.receive`"""'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'callbacks'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'NotImplementedError'
op|'('
string|'"No consumer callbacks registered"'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'callback'
name|'in'
name|'self'
op|'.'
name|'callbacks'
op|':'
newline|'\n'
indent|'            '
name|'callback'
op|'('
name|'message_data'
op|','
name|'message'
op|')'
newline|'\n'
nl|'\n'
DECL|member|send
dedent|''
dedent|''
name|'def'
name|'send'
op|'('
name|'self'
op|','
name|'message_data'
op|','
name|'delivery_mode'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""See :meth:`Publisher.send`"""'
newline|'\n'
name|'self'
op|'.'
name|'publisher'
op|'.'
name|'send'
op|'('
name|'message_data'
op|','
name|'delivery_mode'
op|'='
name|'delivery_mode'
op|')'
newline|'\n'
nl|'\n'
DECL|member|fetch
dedent|''
name|'def'
name|'fetch'
op|'('
name|'self'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""See :meth:`Consumer.fetch`"""'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'consumer'
op|'.'
name|'fetch'
op|'('
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
DECL|member|close
dedent|''
name|'def'
name|'close'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Close any open channels."""'
newline|'\n'
name|'self'
op|'.'
name|'consumer'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'publisher'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_closed'
op|'='
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ConsumerSet
dedent|''
dedent|''
name|'class'
name|'ConsumerSet'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Receive messages from multiple consumers.\n\n    :param connection: see :attr:`connection`.\n    :param from_dict: see :attr:`from_dict`.\n    :param consumers: see :attr:`consumers`.\n    :param callbacks: see :attr:`callbacks`.\n\n    .. attribute:: connection\n\n        The connection to the broker.\n        A :class:`carrot.connection.BrokerConnection` instance.\n\n    .. attribute:: callbacks\n\n        A list of callbacks to be called when a message is received.\n        See :class:`Consumer.register_callback`.\n\n    .. attribute:: from_dict\n\n        Add consumers from a dictionary configuration::\n\n            {\n                "webshot": {\n                            "exchange": "link_exchange",\n                            "exchange_type": "topic",\n                            "binding_key": "links.webshot",\n                            "default_routing_key": "links.webshot",\n                    },\n                "retrieve": {\n                            "exchange": "link_exchange",\n                            "exchange_type" = "topic",\n                            "binding_key": "links.*",\n                            "default_routing_key": "links.retrieve",\n                            "auto_delete": True,\n                            # ...\n                    },\n            }\n\n    .. attribute:: consumers\n\n        Add consumers from a list of :class:`Consumer` instances.\n\n    .. attribute:: auto_ack\n\n        Default value for the :attr:`Consumer.auto_ack` attribute.\n\n    """'
newline|'\n'
DECL|variable|auto_ack
name|'auto_ack'
op|'='
name|'False'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'connection'
op|','
name|'from_dict'
op|'='
name|'None'
op|','
name|'consumers'
op|'='
name|'None'
op|','
nl|'\n'
name|'callbacks'
op|'='
name|'None'
op|','
op|'**'
name|'options'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'connection'
op|'='
name|'connection'
newline|'\n'
name|'self'
op|'.'
name|'options'
op|'='
name|'options'
newline|'\n'
name|'self'
op|'.'
name|'from_dict'
op|'='
name|'from_dict'
name|'or'
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'consumers'
op|'='
name|'consumers'
name|'or'
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'callbacks'
op|'='
name|'callbacks'
name|'or'
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_open_consumers'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'backend'
op|'='
name|'self'
op|'.'
name|'connection'
op|'.'
name|'create_backend'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'auto_ack'
op|'='
name|'options'
op|'.'
name|'get'
op|'('
string|'"auto_ack"'
op|','
name|'self'
op|'.'
name|'auto_ack'
op|')'
newline|'\n'
nl|'\n'
op|'['
name|'self'
op|'.'
name|'add_consumer_from_dict'
op|'('
name|'queue_name'
op|','
op|'**'
name|'queue_options'
op|')'
nl|'\n'
name|'for'
name|'queue_name'
op|','
name|'queue_options'
name|'in'
name|'self'
op|'.'
name|'from_dict'
op|'.'
name|'items'
op|'('
op|')'
op|']'
newline|'\n'
nl|'\n'
DECL|member|_receive_callback
dedent|''
name|'def'
name|'_receive_callback'
op|'('
name|'self'
op|','
name|'raw_message'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Internal method used when a message is received in consume mode."""'
newline|'\n'
name|'message'
op|'='
name|'self'
op|'.'
name|'backend'
op|'.'
name|'message_to_python'
op|'('
name|'raw_message'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'auto_ack'
name|'and'
name|'not'
name|'message'
op|'.'
name|'acknowledged'
op|':'
newline|'\n'
indent|'            '
name|'message'
op|'.'
name|'ack'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'receive'
op|'('
name|'message'
op|'.'
name|'decode'
op|'('
op|')'
op|','
name|'message'
op|')'
newline|'\n'
nl|'\n'
DECL|member|add_consumer_from_dict
dedent|''
name|'def'
name|'add_consumer_from_dict'
op|'('
name|'self'
op|','
name|'queue'
op|','
op|'**'
name|'options'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Add another consumer from dictionary configuration."""'
newline|'\n'
name|'consumer'
op|'='
name|'Consumer'
op|'('
name|'self'
op|'.'
name|'connection'
op|','
name|'queue'
op|'='
name|'queue'
op|','
nl|'\n'
name|'backend'
op|'='
name|'self'
op|'.'
name|'backend'
op|','
op|'**'
name|'options'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'consumers'
op|'.'
name|'append'
op|'('
name|'consumer'
op|')'
newline|'\n'
nl|'\n'
DECL|member|add_consumer
dedent|''
name|'def'
name|'add_consumer'
op|'('
name|'self'
op|','
name|'consumer'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Add another consumer from a :class:`Consumer` instance."""'
newline|'\n'
name|'consumer'
op|'.'
name|'backend'
op|'='
name|'self'
op|'.'
name|'backend'
newline|'\n'
name|'self'
op|'.'
name|'consumers'
op|'.'
name|'append'
op|'('
name|'consumer'
op|')'
newline|'\n'
nl|'\n'
DECL|member|register_callback
dedent|''
name|'def'
name|'register_callback'
op|'('
name|'self'
op|','
name|'callback'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Register new callback to be called when a message is received.\n        See :meth:`Consumer.register_callback`"""'
newline|'\n'
name|'self'
op|'.'
name|'callbacks'
op|'.'
name|'append'
op|'('
name|'callback'
op|')'
newline|'\n'
nl|'\n'
DECL|member|receive
dedent|''
name|'def'
name|'receive'
op|'('
name|'self'
op|','
name|'message_data'
op|','
name|'message'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""What to do when a message is received.\n        See :meth:`Consumer.receive`."""'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'callbacks'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'NotImplementedError'
op|'('
string|'"No consumer callbacks registered"'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'callback'
name|'in'
name|'self'
op|'.'
name|'callbacks'
op|':'
newline|'\n'
indent|'            '
name|'callback'
op|'('
name|'message_data'
op|','
name|'message'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_declare_consumer
dedent|''
dedent|''
name|'def'
name|'_declare_consumer'
op|'('
name|'self'
op|','
name|'consumer'
op|','
name|'nowait'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Declare consumer so messages can be received from it using\n        :meth:`iterconsume`."""'
newline|'\n'
comment|"# Use the ConsumerSet's consumer by default, but if the"
nl|'\n'
comment|'# child consumer has a callback, honor it.'
nl|'\n'
name|'callback'
op|'='
name|'consumer'
op|'.'
name|'callbacks'
name|'and'
name|'consumer'
op|'.'
name|'_receive_callback'
name|'or'
name|'self'
op|'.'
name|'_receive_callback'
newline|'\n'
name|'self'
op|'.'
name|'backend'
op|'.'
name|'declare_consumer'
op|'('
name|'queue'
op|'='
name|'consumer'
op|'.'
name|'queue'
op|','
nl|'\n'
name|'no_ack'
op|'='
name|'consumer'
op|'.'
name|'no_ack'
op|','
nl|'\n'
name|'nowait'
op|'='
name|'nowait'
op|','
nl|'\n'
name|'callback'
op|'='
name|'callback'
op|','
nl|'\n'
name|'consumer_tag'
op|'='
name|'consumer'
op|'.'
name|'consumer_tag'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_open_consumers'
op|'.'
name|'append'
op|'('
name|'consumer'
op|'.'
name|'consumer_tag'
op|')'
newline|'\n'
nl|'\n'
DECL|member|iterconsume
dedent|''
name|'def'
name|'iterconsume'
op|'('
name|'self'
op|','
name|'limit'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Cycle between all consumers in consume mode.\n\n        See :meth:`Consumer.iterconsume`.\n        """'
newline|'\n'
name|'head'
op|'='
name|'self'
op|'.'
name|'consumers'
op|'['
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
name|'tail'
op|'='
name|'self'
op|'.'
name|'consumers'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
op|'['
name|'self'
op|'.'
name|'_declare_consumer'
op|'('
name|'consumer'
op|','
name|'nowait'
op|'='
name|'True'
op|')'
nl|'\n'
name|'for'
name|'consumer'
name|'in'
name|'head'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_declare_consumer'
op|'('
name|'tail'
op|','
name|'nowait'
op|'='
name|'False'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'backend'
op|'.'
name|'consume'
op|'('
name|'limit'
op|'='
name|'limit'
op|')'
newline|'\n'
nl|'\n'
DECL|member|discard_all
dedent|''
name|'def'
name|'discard_all'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Discard all messages. Does not support filtering.\n        See :meth:`Consumer.discard_all`."""'
newline|'\n'
name|'return'
name|'sum'
op|'('
op|'['
name|'consumer'
op|'.'
name|'discard_all'
op|'('
op|')'
nl|'\n'
name|'for'
name|'consumer'
name|'in'
name|'self'
op|'.'
name|'consumers'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|flow
dedent|''
name|'def'
name|'flow'
op|'('
name|'self'
op|','
name|'active'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""This method asks the peer to pause or restart the flow of\n        content data.\n\n        See :meth:`Consumer.flow`.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'backend'
op|'.'
name|'flow'
op|'('
name|'active'
op|')'
newline|'\n'
nl|'\n'
DECL|member|qos
dedent|''
name|'def'
name|'qos'
op|'('
name|'self'
op|','
name|'prefetch_size'
op|'='
number|'0'
op|','
name|'prefetch_count'
op|'='
number|'0'
op|','
name|'apply_global'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Request specific Quality of Service.\n\n        See :meth:`Consumer.cos`.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'backend'
op|'.'
name|'qos'
op|'('
name|'prefetch_size'
op|','
name|'prefetch_count'
op|','
name|'apply_global'
op|')'
newline|'\n'
nl|'\n'
DECL|member|cancel
dedent|''
name|'def'
name|'cancel'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Cancel a running :meth:`iterconsume` session."""'
newline|'\n'
name|'for'
name|'consumer_tag'
name|'in'
name|'self'
op|'.'
name|'_open_consumers'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'backend'
op|'.'
name|'cancel'
op|'('
name|'consumer_tag'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_open_consumers'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|close
dedent|''
name|'def'
name|'close'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Close all consumers."""'
newline|'\n'
name|'self'
op|'.'
name|'cancel'
op|'('
op|')'
newline|'\n'
name|'for'
name|'consumer'
name|'in'
name|'self'
op|'.'
name|'consumers'
op|':'
newline|'\n'
indent|'            '
name|'consumer'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
