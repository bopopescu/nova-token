begin_unit
name|'from'
name|'uuid'
name|'import'
name|'UUID'
op|','
name|'uuid4'
op|','
name|'_uuid_generate_random'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'import'
name|'ctypes'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
DECL|variable|ctypes
indent|'    '
name|'ctypes'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|gen_unique_id
dedent|''
name|'def'
name|'gen_unique_id'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Generate a unique id, having - hopefully - a very small chance of\n    collission.\n\n    For now this is provided by :func:`uuid.uuid4`.\n    """'
newline|'\n'
comment|'# Workaround for http://bugs.python.org/issue4607'
nl|'\n'
name|'if'
name|'ctypes'
name|'and'
name|'_uuid_generate_random'
op|':'
newline|'\n'
indent|'        '
name|'buffer'
op|'='
name|'ctypes'
op|'.'
name|'create_string_buffer'
op|'('
number|'16'
op|')'
newline|'\n'
name|'_uuid_generate_random'
op|'('
name|'buffer'
op|')'
newline|'\n'
name|'return'
name|'str'
op|'('
name|'UUID'
op|'('
name|'bytes'
op|'='
name|'buffer'
op|'.'
name|'raw'
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'str'
op|'('
name|'uuid4'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_compat_rl_partition
dedent|''
name|'def'
name|'_compat_rl_partition'
op|'('
name|'S'
op|','
name|'sep'
op|','
name|'direction'
op|'='
name|'str'
op|'.'
name|'split'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'items'
op|'='
name|'direction'
op|'('
name|'S'
op|','
name|'sep'
op|','
number|'1'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'items'
op|')'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'items'
op|'['
number|'0'
op|']'
op|','
name|'sep'
op|','
string|"''"
newline|'\n'
dedent|''
name|'return'
name|'items'
op|'['
number|'0'
op|']'
op|','
name|'sep'
op|','
name|'items'
op|'['
number|'1'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_compat_partition
dedent|''
name|'def'
name|'_compat_partition'
op|'('
name|'S'
op|','
name|'sep'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""``partition(S, sep) -> (head, sep, tail)``\n\n    Search for the separator ``sep`` in ``S``, and return the part before\n    it, the separator itself, and the part after it. If the separator is not\n    found, return ``S`` and two empty strings.\n\n    """'
newline|'\n'
name|'return'
name|'_compat_rl_partition'
op|'('
name|'S'
op|','
name|'sep'
op|','
name|'direction'
op|'='
name|'str'
op|'.'
name|'split'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_compat_rpartition
dedent|''
name|'def'
name|'_compat_rpartition'
op|'('
name|'S'
op|','
name|'sep'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""``rpartition(S, sep) -> (tail, sep, head)``\n\n    Search for the separator ``sep`` in ``S``, starting at the end of ``S``,\n    and return the part before it, the separator itself, and the part\n    after it. If the separator is not found, return two empty\n    strings and ``S``.\n\n    """'
newline|'\n'
name|'return'
name|'_compat_rl_partition'
op|'('
name|'S'
op|','
name|'sep'
op|','
name|'direction'
op|'='
name|'str'
op|'.'
name|'rsplit'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'    '
name|'partition'
op|'='
name|'str'
op|'.'
name|'partition'
newline|'\n'
name|'rpartition'
op|'='
name|'str'
op|'.'
name|'rpartition'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
comment|'# Python <= 2.4'
newline|'\n'
DECL|variable|partition
indent|'    '
name|'partition'
op|'='
name|'_compat_partition'
newline|'\n'
DECL|variable|rpartition
name|'rpartition'
op|'='
name|'_compat_rpartition'
newline|'\n'
dedent|''
endmarker|''
end_unit
