begin_unit
string|'"""\nIPy - class and tools for handling of IPv4 and IPv6 addresses and networks.\nSee README file for learn how to use IPy.\n\nFurther Information might be available at:\nhttp://software.inl.fr/trac/trac.cgi/wiki/IPy\n"""'
newline|'\n'
nl|'\n'
comment|'# $HeadURL: https://svn.inl.fr/inl-svn/src/tools/ipy/tags/IPy-0.70/IPy.py $'
nl|'\n'
comment|'# $Id: IPy.py 19309 2009-10-29 10:21:13Z haypo $'
nl|'\n'
nl|'\n'
DECL|variable|__rcsid__
name|'__rcsid__'
op|'='
string|"'$Id: IPy.py 19309 2009-10-29 10:21:13Z haypo $'"
newline|'\n'
DECL|variable|__version__
name|'__version__'
op|'='
string|"'0.70'"
newline|'\n'
nl|'\n'
name|'import'
name|'types'
newline|'\n'
nl|'\n'
comment|'# Definition of the Ranges for IPv4 IPs'
nl|'\n'
comment|'# this should include www.iana.org/assignments/ipv4-address-space'
nl|'\n'
comment|'# and www.iana.org/assignments/multicast-addresses'
nl|'\n'
DECL|variable|IPv4ranges
name|'IPv4ranges'
op|'='
op|'{'
nl|'\n'
string|"'0'"
op|':'
string|"'PUBLIC'"
op|','
comment|'# fall back'
nl|'\n'
string|"'00000000'"
op|':'
string|"'PRIVATE'"
op|','
comment|'# 0/8'
nl|'\n'
string|"'00001010'"
op|':'
string|"'PRIVATE'"
op|','
comment|'# 10/8'
nl|'\n'
string|"'01111111'"
op|':'
string|"'PRIVATE'"
op|','
comment|'# 127.0/8'
nl|'\n'
string|"'1'"
op|':'
string|"'PUBLIC'"
op|','
comment|'# fall back'
nl|'\n'
string|"'1010100111111110'"
op|':'
string|"'PRIVATE'"
op|','
comment|'# 169.254/16'
nl|'\n'
string|"'101011000001'"
op|':'
string|"'PRIVATE'"
op|','
comment|'# 172.16/12'
nl|'\n'
string|"'1100000010101000'"
op|':'
string|"'PRIVATE'"
op|','
comment|'# 192.168/16'
nl|'\n'
string|"'11011111'"
op|':'
string|"'RESERVED'"
op|','
comment|'# 223/8'
nl|'\n'
string|"'111'"
op|':'
string|"'RESERVED'"
comment|'# 224/3'
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
comment|'# Definition of the Ranges for IPv6 IPs'
nl|'\n'
comment|'# see also www.iana.org/assignments/ipv6-address-space,'
nl|'\n'
comment|'# www.iana.org/assignments/ipv6-tla-assignments,'
nl|'\n'
comment|'# www.iana.org/assignments/ipv6-multicast-addresses,'
nl|'\n'
comment|'# www.iana.org/assignments/ipv6-anycast-addresses'
nl|'\n'
DECL|variable|IPv6ranges
name|'IPv6ranges'
op|'='
op|'{'
nl|'\n'
string|"'00000000'"
op|':'
string|"'RESERVED'"
op|','
comment|'# ::/8'
nl|'\n'
string|"'00000001'"
op|':'
string|"'UNASSIGNED'"
op|','
comment|'# 100::/8'
nl|'\n'
string|"'0000001'"
op|':'
string|"'NSAP'"
op|','
comment|'# 200::/7'
nl|'\n'
string|"'0000010'"
op|':'
string|"'IPX'"
op|','
comment|'# 400::/7'
nl|'\n'
string|"'0000011'"
op|':'
string|"'UNASSIGNED'"
op|','
comment|'# 600::/7'
nl|'\n'
string|"'00001'"
op|':'
string|"'UNASSIGNED'"
op|','
comment|'# 800::/5'
nl|'\n'
string|"'0001'"
op|':'
string|"'UNASSIGNED'"
op|','
comment|'# 1000::/4'
nl|'\n'
string|"'0010000000000000'"
op|':'
string|"'RESERVED'"
op|','
comment|'# 2000::/16 Reserved'
nl|'\n'
string|"'0010000000000001'"
op|':'
string|"'ASSIGNABLE'"
op|','
comment|'# 2001::/16 Sub-TLA Assignments [RFC2450]'
nl|'\n'
string|"'00100000000000010000000'"
op|':'
string|"'ASSIGNABLE IANA'"
op|','
comment|'# 2001:0000::/29 - 2001:01F8::/29 IANA'
nl|'\n'
string|"'00100000000000010000001'"
op|':'
string|"'ASSIGNABLE APNIC'"
op|','
comment|'# 2001:0200::/29 - 2001:03F8::/29 APNIC'
nl|'\n'
string|"'00100000000000010000010'"
op|':'
string|"'ASSIGNABLE ARIN'"
op|','
comment|'# 2001:0400::/29 - 2001:05F8::/29 ARIN'
nl|'\n'
string|"'00100000000000010000011'"
op|':'
string|"'ASSIGNABLE RIPE'"
op|','
comment|'# 2001:0600::/29 - 2001:07F8::/29 RIPE NCC'
nl|'\n'
string|"'0010000000000010'"
op|':'
string|"'6TO4'"
op|','
comment|'# 2002::/16 "6to4" [RFC3056]'
nl|'\n'
string|"'0011111111111110'"
op|':'
string|"'6BONE'"
op|','
comment|'# 3FFE::/16 6bone Testing [RFC2471]'
nl|'\n'
string|"'0011111111111111'"
op|':'
string|"'RESERVED'"
op|','
comment|'# 3FFF::/16 Reserved'
nl|'\n'
string|"'010'"
op|':'
string|"'GLOBAL-UNICAST'"
op|','
comment|'# 4000::/3'
nl|'\n'
string|"'011'"
op|':'
string|"'UNASSIGNED'"
op|','
comment|'# 6000::/3'
nl|'\n'
string|"'100'"
op|':'
string|"'GEO-UNICAST'"
op|','
comment|'# 8000::/3'
nl|'\n'
string|"'101'"
op|':'
string|"'UNASSIGNED'"
op|','
comment|'# A000::/3'
nl|'\n'
string|"'110'"
op|':'
string|"'UNASSIGNED'"
op|','
comment|'# C000::/3'
nl|'\n'
string|"'1110'"
op|':'
string|"'UNASSIGNED'"
op|','
comment|'# E000::/4'
nl|'\n'
string|"'11110'"
op|':'
string|"'UNASSIGNED'"
op|','
comment|'# F000::/5'
nl|'\n'
string|"'111110'"
op|':'
string|"'UNASSIGNED'"
op|','
comment|'# F800::/6'
nl|'\n'
string|"'1111110'"
op|':'
string|"'UNASSIGNED'"
op|','
comment|'# FC00::/7'
nl|'\n'
string|"'111111100'"
op|':'
string|"'UNASSIGNED'"
op|','
comment|'# FE00::/9'
nl|'\n'
string|"'1111111010'"
op|':'
string|"'LINKLOCAL'"
op|','
comment|'# FE80::/10'
nl|'\n'
string|"'1111111011'"
op|':'
string|"'SITELOCAL'"
op|','
comment|'# FEC0::/10'
nl|'\n'
string|"'11111111'"
op|':'
string|"'MULTICAST'"
op|','
comment|'# FF00::/8'
nl|'\n'
string|"'0'"
op|'*'
number|'96'
op|':'
string|"'IPV4COMP'"
op|','
comment|'# ::/96'
nl|'\n'
string|"'0'"
op|'*'
number|'80'
op|'+'
string|"'1'"
op|'*'
number|'16'
op|':'
string|"'IPV4MAP'"
op|','
comment|'# ::FFFF:0:0/96'
nl|'\n'
string|"'0'"
op|'*'
number|'128'
op|':'
string|"'UNSPECIFIED'"
op|','
comment|'# ::/128'
nl|'\n'
string|"'0'"
op|'*'
number|'127'
op|'+'
string|"'1'"
op|':'
string|"'LOOPBACK'"
comment|'# ::1/128'
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|IPint
name|'class'
name|'IPint'
op|':'
newline|'\n'
indent|'    '
string|'"""Handling of IP addresses returning integers.\n\n    Use class IP instead because some features are not implemented for\n    IPint."""'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'data'
op|','
name|'ipversion'
op|'='
number|'0'
op|','
name|'make_net'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create an instance of an IP object.\n\n        Data can be a network specification or a single IP. IP\n        addresses can be specified in all forms understood by\n        parseAddress(). The size of a network can be specified as\n\n        /prefixlen        a.b.c.0/24               2001:658:22a:cafe::/64\n        -lastIP           a.b.c.0-a.b.c.255        2001:658:22a:cafe::-2001:658:22a:cafe:ffff:ffff:ffff:ffff\n        /decimal netmask  a.b.c.d/255.255.255.0    not supported for IPv6\n\n        If no size specification is given a size of 1 address (/32 for\n        IPv4 and /128 for IPv6) is assumed.\n\n        If make_net is True, an IP address will be transformed into the network\n        address by applying the specified netmask.\n\n        >>> print IP(\'127.0.0.0/8\')\n        127.0.0.0/8\n        >>> print IP(\'127.0.0.0/255.0.0.0\')\n        127.0.0.0/8\n        >>> print IP(\'127.0.0.0-127.255.255.255\')\n        127.0.0.0/8\n        >>> print IP(\'127.0.0.1/255.0.0.0\', make_net=True)\n        127.0.0.0/8\n\n        See module documentation for more examples.\n        """'
newline|'\n'
nl|'\n'
comment|'# Print no Prefixlen for /32 and /128'
nl|'\n'
name|'self'
op|'.'
name|'NoPrefixForSingleIp'
op|'='
number|'1'
newline|'\n'
nl|'\n'
comment|'# Do we want prefix printed by default? see _printPrefix()'
nl|'\n'
name|'self'
op|'.'
name|'WantPrefixLen'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'netbits'
op|'='
number|'0'
newline|'\n'
name|'prefixlen'
op|'='
op|'-'
number|'1'
newline|'\n'
nl|'\n'
comment|'# handling of non string values in constructor'
nl|'\n'
name|'if'
name|'type'
op|'('
name|'data'
op|')'
op|'=='
name|'types'
op|'.'
name|'IntType'
name|'or'
name|'type'
op|'('
name|'data'
op|')'
op|'=='
name|'types'
op|'.'
name|'LongType'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'ip'
op|'='
name|'long'
op|'('
name|'data'
op|')'
newline|'\n'
name|'if'
name|'ipversion'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'self'
op|'.'
name|'ip'
op|'<'
number|'0x100000000L'
op|':'
newline|'\n'
indent|'                    '
name|'ipversion'
op|'='
number|'4'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'ipversion'
op|'='
number|'6'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'ipversion'
op|'=='
number|'4'
op|':'
newline|'\n'
indent|'                '
name|'prefixlen'
op|'='
number|'32'
newline|'\n'
dedent|''
name|'elif'
name|'ipversion'
op|'=='
number|'6'
op|':'
newline|'\n'
indent|'                '
name|'prefixlen'
op|'='
number|'128'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'ValueError'
op|','
string|'"only IPv4 and IPv6 supported"'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_ipversion'
op|'='
name|'ipversion'
newline|'\n'
name|'self'
op|'.'
name|'_prefixlen'
op|'='
name|'prefixlen'
newline|'\n'
comment|'# handle IP instance as an parameter'
nl|'\n'
dedent|''
name|'elif'
name|'isinstance'
op|'('
name|'data'
op|','
name|'IPint'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_ipversion'
op|'='
name|'data'
op|'.'
name|'_ipversion'
newline|'\n'
name|'self'
op|'.'
name|'_prefixlen'
op|'='
name|'data'
op|'.'
name|'_prefixlen'
newline|'\n'
name|'self'
op|'.'
name|'ip'
op|'='
name|'data'
op|'.'
name|'ip'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# TODO: refactor me!'
nl|'\n'
comment|'# splitting of a string into IP and prefixlen et. al.'
nl|'\n'
indent|'            '
name|'x'
op|'='
name|'data'
op|'.'
name|'split'
op|'('
string|"'-'"
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'x'
op|')'
op|'=='
number|'2'
op|':'
newline|'\n'
comment|'# a.b.c.0-a.b.c.255 specification ?'
nl|'\n'
indent|'                '
op|'('
name|'ip'
op|','
name|'last'
op|')'
op|'='
name|'x'
newline|'\n'
op|'('
name|'self'
op|'.'
name|'ip'
op|','
name|'parsedVersion'
op|')'
op|'='
name|'parseAddress'
op|'('
name|'ip'
op|')'
newline|'\n'
name|'if'
name|'parsedVersion'
op|'!='
number|'4'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'ValueError'
op|','
string|'"first-last notation only allowed for IPv4"'
newline|'\n'
dedent|''
op|'('
name|'last'
op|','
name|'lastversion'
op|')'
op|'='
name|'parseAddress'
op|'('
name|'last'
op|')'
newline|'\n'
name|'if'
name|'lastversion'
op|'!='
number|'4'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'ValueError'
op|','
string|'"last address should be IPv4, too"'
newline|'\n'
dedent|''
name|'if'
name|'last'
op|'<'
name|'self'
op|'.'
name|'ip'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'ValueError'
op|','
string|'"last address should be larger than first"'
newline|'\n'
dedent|''
name|'size'
op|'='
name|'last'
op|'-'
name|'self'
op|'.'
name|'ip'
newline|'\n'
name|'netbits'
op|'='
name|'_count1Bits'
op|'('
name|'size'
op|')'
newline|'\n'
comment|'# make sure the broadcast is the same as the last ip'
nl|'\n'
comment|'# otherwise it will return /16 for something like:'
nl|'\n'
comment|'# 192.168.0.0-192.168.191.255'
nl|'\n'
name|'if'
name|'IP'
op|'('
string|"'%s/%s'"
op|'%'
op|'('
name|'ip'
op|','
number|'32'
op|'-'
name|'netbits'
op|')'
op|')'
op|'.'
name|'broadcast'
op|'('
op|')'
op|'.'
name|'int'
op|'('
op|')'
op|'!='
name|'last'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'ValueError'
op|','
string|'"the range %s is not on a network boundary."'
op|'%'
name|'data'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'len'
op|'('
name|'x'
op|')'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'x'
op|'='
name|'data'
op|'.'
name|'split'
op|'('
string|"'/'"
op|')'
newline|'\n'
comment|'# if no prefix is given use defaults'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'x'
op|')'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'                    '
name|'ip'
op|'='
name|'x'
op|'['
number|'0'
op|']'
newline|'\n'
name|'prefixlen'
op|'='
op|'-'
number|'1'
newline|'\n'
dedent|''
name|'elif'
name|'len'
op|'('
name|'x'
op|')'
op|'>'
number|'2'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'ValueError'
op|','
string|'"only one \'/\' allowed in IP Address"'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
op|'('
name|'ip'
op|','
name|'prefixlen'
op|')'
op|'='
name|'x'
newline|'\n'
name|'if'
name|'prefixlen'
op|'.'
name|'find'
op|'('
string|"'.'"
op|')'
op|'!='
op|'-'
number|'1'
op|':'
newline|'\n'
comment|'# check if the user might have used a netmask like'
nl|'\n'
comment|'# a.b.c.d/255.255.255.0'
nl|'\n'
indent|'                        '
op|'('
name|'netmask'
op|','
name|'vers'
op|')'
op|'='
name|'parseAddress'
op|'('
name|'prefixlen'
op|')'
newline|'\n'
name|'if'
name|'vers'
op|'!='
number|'4'
op|':'
newline|'\n'
indent|'                            '
name|'raise'
name|'ValueError'
op|','
string|'"netmask must be IPv4"'
newline|'\n'
dedent|''
name|'prefixlen'
op|'='
name|'_netmaskToPrefixlen'
op|'('
name|'netmask'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'elif'
name|'len'
op|'('
name|'x'
op|')'
op|'>'
number|'2'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'ValueError'
op|','
string|'"only one \'-\' allowed in IP Address"'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'ValueError'
op|','
string|'"can\'t parse"'
newline|'\n'
nl|'\n'
dedent|''
op|'('
name|'self'
op|'.'
name|'ip'
op|','
name|'parsedVersion'
op|')'
op|'='
name|'parseAddress'
op|'('
name|'ip'
op|')'
newline|'\n'
name|'if'
name|'ipversion'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'ipversion'
op|'='
name|'parsedVersion'
newline|'\n'
dedent|''
name|'if'
name|'prefixlen'
op|'=='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'ipversion'
op|'=='
number|'4'
op|':'
newline|'\n'
indent|'                    '
name|'prefixlen'
op|'='
number|'32'
op|'-'
name|'netbits'
newline|'\n'
dedent|''
name|'elif'
name|'ipversion'
op|'=='
number|'6'
op|':'
newline|'\n'
indent|'                    '
name|'prefixlen'
op|'='
number|'128'
op|'-'
name|'netbits'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'ValueError'
op|','
string|'"only IPv4 and IPv6 supported"'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_ipversion'
op|'='
name|'ipversion'
newline|'\n'
name|'self'
op|'.'
name|'_prefixlen'
op|'='
name|'int'
op|'('
name|'prefixlen'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'make_net'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'ip'
op|'='
name|'self'
op|'.'
name|'ip'
op|'&'
name|'_prefixlenToNetmask'
op|'('
name|'self'
op|'.'
name|'_prefixlen'
op|','
name|'self'
op|'.'
name|'_ipversion'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'_checkNetaddrWorksWithPrefixlen'
op|'('
name|'self'
op|'.'
name|'ip'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_prefixlen'
op|','
name|'self'
op|'.'
name|'_ipversion'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'ValueError'
op|','
string|'"%s has invalid prefix length (%s)"'
op|'%'
op|'('
name|'repr'
op|'('
name|'self'
op|')'
op|','
name|'self'
op|'.'
name|'_prefixlen'
op|')'
newline|'\n'
nl|'\n'
DECL|member|int
dedent|''
dedent|''
dedent|''
name|'def'
name|'int'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the first / base / network addess as an (long) integer.\n\n        The same as IP[0].\n\n        >>> "%X" % IP(\'10.0.0.0/8\').int()\n        \'A000000\'\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'ip'
newline|'\n'
nl|'\n'
DECL|member|version
dedent|''
name|'def'
name|'version'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the IP version of this Object.\n\n        >>> IP(\'10.0.0.0/8\').version()\n        4\n        >>> IP(\'::1\').version()\n        6\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_ipversion'
newline|'\n'
nl|'\n'
DECL|member|prefixlen
dedent|''
name|'def'
name|'prefixlen'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns Network Prefixlen.\n\n        >>> IP(\'10.0.0.0/8\').prefixlen()\n        8\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_prefixlen'
newline|'\n'
nl|'\n'
DECL|member|net
dedent|''
name|'def'
name|'net'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the base (first) address of a network as an (long) integer.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'int'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|broadcast
dedent|''
name|'def'
name|'broadcast'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return the broadcast (last) address of a network as an (long) integer.\n\n        The same as IP[-1]."""'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'int'
op|'('
op|')'
op|'+'
name|'self'
op|'.'
name|'len'
op|'('
op|')'
op|'-'
number|'1'
newline|'\n'
nl|'\n'
DECL|member|_printPrefix
dedent|''
name|'def'
name|'_printPrefix'
op|'('
name|'self'
op|','
name|'want'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Prints Prefixlen/Netmask.\n\n        Not really. In fact it is our universal Netmask/Prefixlen printer.\n        This is considered an internal function.\n\n        want == 0 / None        don\'t return anything    1.2.3.0\n        want == 1               /prefix                  1.2.3.0/24\n        want == 2               /netmask                 1.2.3.0/255.255.255.0\n        want == 3               -lastip                  1.2.3.0-1.2.3.255\n        """'
newline|'\n'
nl|'\n'
name|'if'
op|'('
name|'self'
op|'.'
name|'_ipversion'
op|'=='
number|'4'
name|'and'
name|'self'
op|'.'
name|'_prefixlen'
op|'=='
number|'32'
op|')'
name|'or'
op|'('
name|'self'
op|'.'
name|'_ipversion'
op|'=='
number|'6'
name|'and'
name|'self'
op|'.'
name|'_prefixlen'
op|'=='
number|'128'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'NoPrefixForSingleIp'
op|':'
newline|'\n'
indent|'                '
name|'want'
op|'='
number|'0'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'want'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'want'
op|'='
name|'self'
op|'.'
name|'WantPrefixLen'
newline|'\n'
name|'if'
name|'want'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'want'
op|'='
number|'1'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'want'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'want'
op|'=='
number|'2'
op|':'
newline|'\n'
comment|'# this should work with IP and IPint'
nl|'\n'
indent|'                '
name|'netmask'
op|'='
name|'self'
op|'.'
name|'netmask'
op|'('
op|')'
newline|'\n'
name|'if'
name|'type'
op|'('
name|'netmask'
op|')'
op|'!='
name|'types'
op|'.'
name|'IntType'
name|'and'
name|'type'
op|'('
name|'netmask'
op|')'
op|'!='
name|'types'
op|'.'
name|'LongType'
op|':'
newline|'\n'
indent|'                    '
name|'netmask'
op|'='
name|'netmask'
op|'.'
name|'int'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
string|'"/%s"'
op|'%'
op|'('
name|'intToIp'
op|'('
name|'netmask'
op|','
name|'self'
op|'.'
name|'_ipversion'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'want'
op|'=='
number|'3'
op|':'
newline|'\n'
indent|'                '
name|'return'
string|'"-%s"'
op|'%'
op|'('
name|'intToIp'
op|'('
name|'self'
op|'.'
name|'ip'
op|'+'
name|'self'
op|'.'
name|'len'
op|'('
op|')'
op|'-'
number|'1'
op|','
name|'self'
op|'.'
name|'_ipversion'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# default'
nl|'\n'
indent|'                '
name|'return'
string|'"/%d"'
op|'%'
op|'('
name|'self'
op|'.'
name|'_prefixlen'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"''"
newline|'\n'
nl|'\n'
comment|'# We have different flavours to convert to:'
nl|'\n'
comment|'# strFullsize   127.0.0.1    2001:0658:022a:cafe:0200:c0ff:fe8d:08fa'
nl|'\n'
comment|'# strNormal     127.0.0.1    2001:658:22a:cafe:200:c0ff:fe8d:08fa'
nl|'\n'
comment|'# strCompressed 127.0.0.1    2001:658:22a:cafe::1'
nl|'\n'
comment|'# strHex        0x7F000001L  0x20010658022ACAFE0200C0FFFE8D08FA'
nl|'\n'
comment|'# strDec        2130706433   42540616829182469433547974687817795834'
nl|'\n'
nl|'\n'
DECL|member|strBin
dedent|''
dedent|''
name|'def'
name|'strBin'
op|'('
name|'self'
op|','
name|'wantprefixlen'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a string representation as a binary value.\n\n        >>> print IP(\'127.0.0.1\').strBin()\n        01111111000000000000000000000001\n        """'
newline|'\n'
nl|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_ipversion'
op|'=='
number|'4'
op|':'
newline|'\n'
indent|'            '
name|'bits'
op|'='
number|'32'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_ipversion'
op|'=='
number|'6'
op|':'
newline|'\n'
indent|'            '
name|'bits'
op|'='
number|'128'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|','
string|'"only IPv4 and IPv6 supported"'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'WantPrefixLen'
op|'=='
name|'None'
name|'and'
name|'wantprefixlen'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'wantprefixlen'
op|'='
number|'0'
newline|'\n'
dedent|''
name|'ret'
op|'='
name|'_intToBin'
op|'('
name|'self'
op|'.'
name|'ip'
op|')'
newline|'\n'
name|'return'
string|"'0'"
op|'*'
op|'('
name|'bits'
op|'-'
name|'len'
op|'('
name|'ret'
op|')'
op|')'
op|'+'
name|'ret'
op|'+'
name|'self'
op|'.'
name|'_printPrefix'
op|'('
name|'wantprefixlen'
op|')'
newline|'\n'
nl|'\n'
DECL|member|strCompressed
dedent|''
name|'def'
name|'strCompressed'
op|'('
name|'self'
op|','
name|'wantprefixlen'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a string representation in compressed format using \'::\' Notation.\n\n        >>> IP(\'127.0.0.1\').strCompressed()\n        \'127.0.0.1\'\n        >>> IP(\'2001:0658:022a:cafe:0200::1\').strCompressed()\n        \'2001:658:22a:cafe:200::1\'\n        >>> IP(\'ffff:ffff:ffff:ffff:ffff:f:f:fffc/127\').strCompressed()\n        \'ffff:ffff:ffff:ffff:ffff:f:f:fffc/127\'\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'WantPrefixLen'
op|'=='
name|'None'
name|'and'
name|'wantprefixlen'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'wantprefixlen'
op|'='
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_ipversion'
op|'=='
number|'4'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'strFullsize'
op|'('
name|'wantprefixlen'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'ip'
op|'>>'
number|'32'
op|'=='
number|'0xffff'
op|':'
newline|'\n'
indent|'                '
name|'ipv4'
op|'='
name|'intToIp'
op|'('
name|'self'
op|'.'
name|'ip'
op|'&'
number|'0xffffffff'
op|','
number|'4'
op|')'
newline|'\n'
name|'text'
op|'='
string|'"::ffff:"'
op|'+'
name|'ipv4'
op|'+'
name|'self'
op|'.'
name|'_printPrefix'
op|'('
name|'wantprefixlen'
op|')'
newline|'\n'
name|'return'
name|'text'
newline|'\n'
comment|"# find the longest sequence of '0'"
nl|'\n'
dedent|''
name|'hextets'
op|'='
op|'['
name|'int'
op|'('
name|'x'
op|','
number|'16'
op|')'
name|'for'
name|'x'
name|'in'
name|'self'
op|'.'
name|'strFullsize'
op|'('
number|'0'
op|')'
op|'.'
name|'split'
op|'('
string|"':'"
op|')'
op|']'
newline|'\n'
comment|'# every element of followingzeros will contain the number of zeros'
nl|'\n'
comment|'# following the corresponding element of hextets'
nl|'\n'
name|'followingzeros'
op|'='
op|'['
number|'0'
op|']'
op|'*'
number|'8'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'len'
op|'('
name|'hextets'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'followingzeros'
op|'['
name|'i'
op|']'
op|'='
name|'_countFollowingZeros'
op|'('
name|'hextets'
op|'['
name|'i'
op|':'
op|']'
op|')'
newline|'\n'
comment|'# compressionpos is the position where we can start removing zeros'
nl|'\n'
dedent|''
name|'compressionpos'
op|'='
name|'followingzeros'
op|'.'
name|'index'
op|'('
name|'max'
op|'('
name|'followingzeros'
op|')'
op|')'
newline|'\n'
name|'if'
name|'max'
op|'('
name|'followingzeros'
op|')'
op|'>'
number|'1'
op|':'
newline|'\n'
comment|'# genererate string with the longest number of zeros cut out'
nl|'\n'
comment|'# now we need hextets as strings'
nl|'\n'
indent|'                '
name|'hextets'
op|'='
op|'['
name|'x'
name|'for'
name|'x'
name|'in'
name|'self'
op|'.'
name|'strNormal'
op|'('
number|'0'
op|')'
op|'.'
name|'split'
op|'('
string|"':'"
op|')'
op|']'
newline|'\n'
name|'while'
name|'compressionpos'
op|'<'
name|'len'
op|'('
name|'hextets'
op|')'
name|'and'
name|'hextets'
op|'['
name|'compressionpos'
op|']'
op|'=='
string|"'0'"
op|':'
newline|'\n'
indent|'                    '
name|'del'
op|'('
name|'hextets'
op|'['
name|'compressionpos'
op|']'
op|')'
newline|'\n'
dedent|''
name|'hextets'
op|'.'
name|'insert'
op|'('
name|'compressionpos'
op|','
string|"''"
op|')'
newline|'\n'
name|'if'
name|'compressionpos'
op|'+'
number|'1'
op|'>='
name|'len'
op|'('
name|'hextets'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'hextets'
op|'.'
name|'append'
op|'('
string|"''"
op|')'
newline|'\n'
dedent|''
name|'if'
name|'compressionpos'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'hextets'
op|'='
op|'['
string|"''"
op|']'
op|'+'
name|'hextets'
newline|'\n'
dedent|''
name|'return'
string|"':'"
op|'.'
name|'join'
op|'('
name|'hextets'
op|')'
op|'+'
name|'self'
op|'.'
name|'_printPrefix'
op|'('
name|'wantprefixlen'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'self'
op|'.'
name|'strNormal'
op|'('
number|'0'
op|')'
op|'+'
name|'self'
op|'.'
name|'_printPrefix'
op|'('
name|'wantprefixlen'
op|')'
newline|'\n'
nl|'\n'
DECL|member|strNormal
dedent|''
dedent|''
dedent|''
name|'def'
name|'strNormal'
op|'('
name|'self'
op|','
name|'wantprefixlen'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a string representation in the usual format.\n\n        >>> print IP(\'127.0.0.1\').strNormal()\n        127.0.0.1\n        >>> print IP(\'2001:0658:022a:cafe:0200::1\').strNormal()\n        2001:658:22a:cafe:200:0:0:1\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'WantPrefixLen'
op|'=='
name|'None'
name|'and'
name|'wantprefixlen'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'wantprefixlen'
op|'='
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_ipversion'
op|'=='
number|'4'
op|':'
newline|'\n'
indent|'            '
name|'ret'
op|'='
name|'self'
op|'.'
name|'strFullsize'
op|'('
number|'0'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_ipversion'
op|'=='
number|'6'
op|':'
newline|'\n'
indent|'            '
name|'ret'
op|'='
string|"':'"
op|'.'
name|'join'
op|'('
op|'['
name|'hex'
op|'('
name|'x'
op|')'
op|'['
number|'2'
op|':'
op|']'
name|'for'
name|'x'
name|'in'
op|'['
name|'int'
op|'('
name|'x'
op|','
number|'16'
op|')'
name|'for'
name|'x'
name|'in'
name|'self'
op|'.'
name|'strFullsize'
op|'('
number|'0'
op|')'
op|'.'
name|'split'
op|'('
string|"':'"
op|')'
op|']'
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|','
string|'"only IPv4 and IPv6 supported"'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
dedent|''
name|'return'
name|'ret'
op|'+'
name|'self'
op|'.'
name|'_printPrefix'
op|'('
name|'wantprefixlen'
op|')'
newline|'\n'
nl|'\n'
DECL|member|strFullsize
dedent|''
name|'def'
name|'strFullsize'
op|'('
name|'self'
op|','
name|'wantprefixlen'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a string representation in the non-mangled format.\n\n        >>> print IP(\'127.0.0.1\').strFullsize()\n        127.0.0.1\n        >>> print IP(\'2001:0658:022a:cafe:0200::1\').strFullsize()\n        2001:0658:022a:cafe:0200:0000:0000:0001\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'WantPrefixLen'
op|'=='
name|'None'
name|'and'
name|'wantprefixlen'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'wantprefixlen'
op|'='
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'intToIp'
op|'('
name|'self'
op|'.'
name|'ip'
op|','
name|'self'
op|'.'
name|'_ipversion'
op|')'
op|'.'
name|'lower'
op|'('
op|')'
op|'+'
name|'self'
op|'.'
name|'_printPrefix'
op|'('
name|'wantprefixlen'
op|')'
newline|'\n'
nl|'\n'
DECL|member|strHex
dedent|''
name|'def'
name|'strHex'
op|'('
name|'self'
op|','
name|'wantprefixlen'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a string representation in hex format in lower case.\n\n        >>> IP(\'127.0.0.1\').strHex()\n        \'0x7f000001\'\n        >>> IP(\'2001:0658:022a:cafe:0200::1\').strHex()\n        \'0x20010658022acafe0200000000000001\'\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'WantPrefixLen'
op|'=='
name|'None'
name|'and'
name|'wantprefixlen'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'wantprefixlen'
op|'='
number|'0'
newline|'\n'
nl|'\n'
dedent|''
name|'x'
op|'='
name|'hex'
op|'('
name|'self'
op|'.'
name|'ip'
op|')'
newline|'\n'
name|'if'
name|'x'
op|'['
op|'-'
number|'1'
op|']'
op|'=='
string|"'L'"
op|':'
newline|'\n'
indent|'            '
name|'x'
op|'='
name|'x'
op|'['
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
dedent|''
name|'return'
name|'x'
op|'.'
name|'lower'
op|'('
op|')'
op|'+'
name|'self'
op|'.'
name|'_printPrefix'
op|'('
name|'wantprefixlen'
op|')'
newline|'\n'
nl|'\n'
DECL|member|strDec
dedent|''
name|'def'
name|'strDec'
op|'('
name|'self'
op|','
name|'wantprefixlen'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a string representation in decimal format.\n\n        >>> print IP(\'127.0.0.1\').strDec()\n        2130706433\n        >>> print IP(\'2001:0658:022a:cafe:0200::1\').strDec()\n        42540616829182469433547762482097946625\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'WantPrefixLen'
op|'=='
name|'None'
name|'and'
name|'wantprefixlen'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'wantprefixlen'
op|'='
number|'0'
newline|'\n'
nl|'\n'
dedent|''
name|'x'
op|'='
name|'str'
op|'('
name|'self'
op|'.'
name|'ip'
op|')'
newline|'\n'
name|'if'
name|'x'
op|'['
op|'-'
number|'1'
op|']'
op|'=='
string|"'L'"
op|':'
newline|'\n'
indent|'            '
name|'x'
op|'='
name|'x'
op|'['
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
dedent|''
name|'return'
name|'x'
op|'+'
name|'self'
op|'.'
name|'_printPrefix'
op|'('
name|'wantprefixlen'
op|')'
newline|'\n'
nl|'\n'
DECL|member|iptype
dedent|''
name|'def'
name|'iptype'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a description of the IP type (\'PRIVATE\', \'RESERVERD\', etc).\n\n        >>> print IP(\'127.0.0.1\').iptype()\n        PRIVATE\n        >>> print IP(\'192.168.1.1\').iptype()\n        PRIVATE\n        >>> print IP(\'195.185.1.2\').iptype()\n        PUBLIC\n        >>> print IP(\'::1\').iptype()\n        LOOPBACK\n        >>> print IP(\'2001:0658:022a:cafe:0200::1\').iptype()\n        ASSIGNABLE RIPE\n\n        The type information for IPv6 is out of sync with reality.\n        """'
newline|'\n'
nl|'\n'
comment|'# this could be greatly improved'
nl|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_ipversion'
op|'=='
number|'4'
op|':'
newline|'\n'
indent|'            '
name|'iprange'
op|'='
name|'IPv4ranges'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_ipversion'
op|'=='
number|'6'
op|':'
newline|'\n'
indent|'            '
name|'iprange'
op|'='
name|'IPv6ranges'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|','
string|'"only IPv4 and IPv6 supported"'
newline|'\n'
nl|'\n'
dedent|''
name|'bits'
op|'='
name|'self'
op|'.'
name|'strBin'
op|'('
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'len'
op|'('
name|'bits'
op|')'
op|','
number|'0'
op|','
op|'-'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'iprange'
op|'.'
name|'has_key'
op|'('
name|'bits'
op|'['
op|':'
name|'i'
op|']'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'iprange'
op|'['
name|'bits'
op|'['
op|':'
name|'i'
op|']'
op|']'
newline|'\n'
dedent|''
dedent|''
name|'return'
string|'"unknown"'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|netmask
dedent|''
name|'def'
name|'netmask'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return netmask as an integer.\n\n        >>> "%X" % IP(\'195.185.0.0/16\').netmask().int()\n        \'FFFF0000\'\n        """'
newline|'\n'
nl|'\n'
comment|'# TODO: unify with prefixlenToNetmask?'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_ipversion'
op|'=='
number|'4'
op|':'
newline|'\n'
indent|'            '
name|'locallen'
op|'='
number|'32'
op|'-'
name|'self'
op|'.'
name|'_prefixlen'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_ipversion'
op|'=='
number|'6'
op|':'
newline|'\n'
indent|'            '
name|'locallen'
op|'='
number|'128'
op|'-'
name|'self'
op|'.'
name|'_prefixlen'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|','
string|'"only IPv4 and IPv6 supported"'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
op|'('
op|'('
number|'2L'
op|'**'
name|'self'
op|'.'
name|'_prefixlen'
op|')'
op|'-'
number|'1'
op|')'
op|'<<'
name|'locallen'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|strNetmask
dedent|''
name|'def'
name|'strNetmask'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return netmask as an string. Mostly useful for IPv6.\n\n        >>> print IP(\'195.185.0.0/16\').strNetmask()\n        255.255.0.0\n        >>> print IP(\'2001:0658:022a:cafe::0/64\').strNetmask()\n        /64\n        """'
newline|'\n'
nl|'\n'
comment|'# TODO: unify with prefixlenToNetmask?'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_ipversion'
op|'=='
number|'4'
op|':'
newline|'\n'
indent|'            '
name|'locallen'
op|'='
number|'32'
op|'-'
name|'self'
op|'.'
name|'_prefixlen'
newline|'\n'
name|'return'
name|'intToIp'
op|'('
op|'('
op|'('
number|'2L'
op|'**'
name|'self'
op|'.'
name|'_prefixlen'
op|')'
op|'-'
number|'1'
op|')'
op|'<<'
name|'locallen'
op|','
number|'4'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_ipversion'
op|'=='
number|'6'
op|':'
newline|'\n'
indent|'            '
name|'locallen'
op|'='
number|'128'
op|'-'
name|'self'
op|'.'
name|'_prefixlen'
newline|'\n'
name|'return'
string|'"/%d"'
op|'%'
name|'self'
op|'.'
name|'_prefixlen'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|','
string|'"only IPv4 and IPv6 supported"'
newline|'\n'
nl|'\n'
DECL|member|len
dedent|''
dedent|''
name|'def'
name|'len'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the length of a subnet.\n\n        >>> print IP(\'195.185.1.0/28\').len()\n        16\n        >>> print IP(\'195.185.1.0/24\').len()\n        256\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_ipversion'
op|'=='
number|'4'
op|':'
newline|'\n'
indent|'            '
name|'locallen'
op|'='
number|'32'
op|'-'
name|'self'
op|'.'
name|'_prefixlen'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_ipversion'
op|'=='
number|'6'
op|':'
newline|'\n'
indent|'            '
name|'locallen'
op|'='
number|'128'
op|'-'
name|'self'
op|'.'
name|'_prefixlen'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|','
string|'"only IPv4 and IPv6 supported"'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
number|'2L'
op|'**'
name|'locallen'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__nonzero__
dedent|''
name|'def'
name|'__nonzero__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""All IPy objects should evaluate to true in boolean context.\n        Ordinarily they do, but if handling a default route expressed as\n        0.0.0.0/0, the __len__() of the object becomes 0, which is used\n        as the boolean value of the object.\n        """'
newline|'\n'
name|'return'
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__len__
dedent|''
name|'def'
name|'__len__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the length of a subnet.\n\n        Called to implement the built-in function len().\n        It breaks with IPv6 Networks. Anybody knows how to fix this."""'
newline|'\n'
nl|'\n'
comment|'# Python < 2.2 has this silly restriction which breaks IPv6'
nl|'\n'
comment|'# how about Python >= 2.2 ... ouch - it persists!'
nl|'\n'
nl|'\n'
name|'return'
name|'int'
op|'('
name|'self'
op|'.'
name|'len'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__getitem__
dedent|''
name|'def'
name|'__getitem__'
op|'('
name|'self'
op|','
name|'key'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Called to implement evaluation of self[key].\n\n        >>> ip=IP(\'127.0.0.0/30\')\n        >>> for x in ip:\n        ...  print repr(x)\n        ...\n        IP(\'127.0.0.0\')\n        IP(\'127.0.0.1\')\n        IP(\'127.0.0.2\')\n        IP(\'127.0.0.3\')\n        >>> ip[2]\n        IP(\'127.0.0.2\')\n        >>> ip[-1]\n        IP(\'127.0.0.3\')\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'type'
op|'('
name|'key'
op|')'
op|'!='
name|'types'
op|'.'
name|'IntType'
name|'and'
name|'type'
op|'('
name|'key'
op|')'
op|'!='
name|'types'
op|'.'
name|'LongType'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'TypeError'
newline|'\n'
dedent|''
name|'if'
name|'key'
op|'<'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'abs'
op|'('
name|'key'
op|')'
op|'<='
name|'self'
op|'.'
name|'len'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'key'
op|'='
name|'self'
op|'.'
name|'len'
op|'('
op|')'
op|'-'
name|'abs'
op|'('
name|'key'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'IndexError'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'key'
op|'>='
name|'self'
op|'.'
name|'len'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'IndexError'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'ip'
op|'+'
name|'long'
op|'('
name|'key'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|member|__contains__
dedent|''
name|'def'
name|'__contains__'
op|'('
name|'self'
op|','
name|'item'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Called to implement membership test operators.\n\n        Should return true if item is in self, false otherwise. Item\n        can be other IP-objects, strings or ints.\n\n        >>> IP(\'195.185.1.1\').strHex()\n        \'0xc3b90101\'\n        >>> 0xC3B90101L in IP(\'195.185.1.0/24\')\n        1\n        >>> \'127.0.0.1\' in IP(\'127.0.0.0/24\')\n        1\n        >>> IP(\'127.0.0.0/24\') in IP(\'127.0.0.0/25\')\n        0\n        """'
newline|'\n'
nl|'\n'
name|'item'
op|'='
name|'IP'
op|'('
name|'item'
op|')'
newline|'\n'
name|'if'
name|'item'
op|'.'
name|'ip'
op|'>='
name|'self'
op|'.'
name|'ip'
name|'and'
name|'item'
op|'.'
name|'ip'
op|'<'
name|'self'
op|'.'
name|'ip'
op|'+'
name|'self'
op|'.'
name|'len'
op|'('
op|')'
op|'-'
name|'item'
op|'.'
name|'len'
op|'('
op|')'
op|'+'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'return'
number|'1'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
number|'0'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|overlaps
dedent|''
dedent|''
name|'def'
name|'overlaps'
op|'('
name|'self'
op|','
name|'item'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check if two IP address ranges overlap.\n\n        Returns 0 if the two ranges don\'t overlap, 1 if the given\n        range overlaps at the end and -1 if it does at the beginning.\n\n        >>> IP(\'192.168.0.0/23\').overlaps(\'192.168.1.0/24\')\n        1\n        >>> IP(\'192.168.0.0/23\').overlaps(\'192.168.1.255\')\n        1\n        >>> IP(\'192.168.0.0/23\').overlaps(\'192.168.2.0\')\n        0\n        >>> IP(\'192.168.1.0/24\').overlaps(\'192.168.0.0/23\')\n        -1\n        """'
newline|'\n'
nl|'\n'
name|'item'
op|'='
name|'IP'
op|'('
name|'item'
op|')'
newline|'\n'
name|'if'
name|'item'
op|'.'
name|'ip'
op|'>='
name|'self'
op|'.'
name|'ip'
name|'and'
name|'item'
op|'.'
name|'ip'
op|'<'
name|'self'
op|'.'
name|'ip'
op|'+'
name|'self'
op|'.'
name|'len'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
number|'1'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'ip'
op|'>='
name|'item'
op|'.'
name|'ip'
name|'and'
name|'self'
op|'.'
name|'ip'
op|'<'
name|'item'
op|'.'
name|'ip'
op|'+'
name|'item'
op|'.'
name|'len'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'-'
number|'1'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
number|'0'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Dispatch to the prefered String Representation.\n\n        Used to implement str(IP)."""'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'strCompressed'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Print a representation of the Object.\n\n        Used to implement repr(IP). Returns a string which evaluates\n        to an identical Object (without the wantprefixlen stuff - see\n        module docstring.\n\n        >>> print repr(IP(\'10.0.0.0/24\'))\n        IP(\'10.0.0.0/24\')\n        """'
newline|'\n'
nl|'\n'
name|'return'
op|'('
string|'"IPint(\'%s\')"'
op|'%'
op|'('
name|'self'
op|'.'
name|'strCompressed'
op|'('
number|'1'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__cmp__
dedent|''
name|'def'
name|'__cmp__'
op|'('
name|'self'
op|','
name|'other'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Called by comparison operations.\n\n        Should return a negative integer if self < other, zero if self\n        == other, a positive integer if self > other.\n\n        Networks with different prefixlen are considered non-equal.\n        Networks with the same prefixlen and differing addresses are\n        considered non equal but are compared by their base address\n        integer value to aid sorting of IP objects.\n\n        The version of Objects is not put into consideration.\n\n        >>> IP(\'10.0.0.0/24\') > IP(\'10.0.0.0\')\n        1\n        >>> IP(\'10.0.0.0/24\') < IP(\'10.0.0.0\')\n        0\n        >>> IP(\'10.0.0.0/24\') < IP(\'12.0.0.0/24\')\n        1\n        >>> IP(\'10.0.0.0/24\') > IP(\'12.0.0.0/24\')\n        0\n\n        """'
newline|'\n'
nl|'\n'
comment|'# Im not really sure if this is "the right thing to do"'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_prefixlen'
op|'<'
name|'other'
op|'.'
name|'prefixlen'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'('
name|'other'
op|'.'
name|'prefixlen'
op|'('
op|')'
op|'-'
name|'self'
op|'.'
name|'_prefixlen'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_prefixlen'
op|'>'
name|'other'
op|'.'
name|'prefixlen'
op|'('
op|')'
op|':'
newline|'\n'
nl|'\n'
comment|'# Fixed bySamuel Krempp <krempp@crans.ens-cachan.fr>:'
nl|'\n'
nl|'\n'
comment|'# The bug is quite obvious really (as 99% bugs are once'
nl|'\n'
comment|"# spotted, isn't it ? ;-) Because of precedence of"
nl|'\n'
comment|'# multiplication by -1 over the substraction, prefixlen'
nl|'\n'
comment|'# differences were causing the __cmp__ function to always'
nl|'\n'
comment|'# return positive numbers, thus the function was failing'
nl|'\n'
comment|'# the basic assumptions for a __cmp__ function.'
nl|'\n'
nl|'\n'
comment|'# Namely we could have (a > b AND b > a), when the'
nl|'\n'
comment|'# prefixlen of a and b are different.  (eg let'
nl|'\n'
comment|'# a=IP("1.0.0.0/24"); b=IP("2.0.0.0/16");) thus, anything'
nl|'\n'
comment|'# could happen when launching a sort algorithm..'
nl|'\n'
comment|"# everything's in order with the trivial, attached patch."
nl|'\n'
nl|'\n'
indent|'            '
name|'return'
op|'('
name|'self'
op|'.'
name|'_prefixlen'
op|'-'
name|'other'
op|'.'
name|'prefixlen'
op|'('
op|')'
op|')'
op|'*'
op|'-'
number|'1'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'ip'
op|'<'
name|'other'
op|'.'
name|'ip'
op|':'
newline|'\n'
indent|'                '
name|'return'
op|'-'
number|'1'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'ip'
op|'>'
name|'other'
op|'.'
name|'ip'
op|':'
newline|'\n'
indent|'                '
name|'return'
number|'1'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_ipversion'
op|'!='
name|'other'
op|'.'
name|'_ipversion'
op|':'
newline|'\n'
comment|"# IP('0.0.0.0'), IP('::/0')"
nl|'\n'
indent|'                '
name|'return'
name|'cmp'
op|'('
name|'self'
op|'.'
name|'_ipversion'
op|','
name|'other'
op|'.'
name|'_ipversion'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'return'
number|'0'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|__hash__
dedent|''
dedent|''
dedent|''
name|'def'
name|'__hash__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Called for the key object for dictionary operations, and by\n        the built-in function hash(). Should return a 32-bit integer\n        usable as a hash value for dictionary operations. The only\n        required property is that objects which compare equal have the\n        same hash value\n\n        >>> IP(\'10.0.0.0/24\').__hash__()\n        -167772185\n        """'
newline|'\n'
nl|'\n'
name|'thehash'
op|'='
name|'int'
op|'('
op|'-'
number|'1'
op|')'
newline|'\n'
name|'ip'
op|'='
name|'self'
op|'.'
name|'ip'
newline|'\n'
name|'while'
name|'ip'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'thehash'
op|'='
name|'thehash'
op|'^'
op|'('
name|'ip'
op|'&'
number|'0x7fffffff'
op|')'
newline|'\n'
name|'ip'
op|'='
name|'ip'
op|'>>'
number|'32'
newline|'\n'
dedent|''
name|'thehash'
op|'='
name|'thehash'
op|'^'
name|'self'
op|'.'
name|'_prefixlen'
newline|'\n'
name|'return'
name|'int'
op|'('
name|'thehash'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|IP
dedent|''
dedent|''
name|'class'
name|'IP'
op|'('
name|'IPint'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Class for handling IP addresses and networks."""'
newline|'\n'
nl|'\n'
DECL|member|net
name|'def'
name|'net'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the base (first) address of a network as an IP object.\n\n        The same as IP[0].\n\n        >>> IP(\'10.0.0.0/8\').net()\n        IP(\'10.0.0.0\')\n        """'
newline|'\n'
name|'return'
name|'IP'
op|'('
name|'IPint'
op|'.'
name|'net'
op|'('
name|'self'
op|')'
op|','
name|'ipversion'
op|'='
name|'self'
op|'.'
name|'_ipversion'
op|')'
newline|'\n'
nl|'\n'
DECL|member|broadcast
dedent|''
name|'def'
name|'broadcast'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the broadcast (last) address of a network as an IP object.\n\n        The same as IP[-1].\n\n        >>> IP(\'10.0.0.0/8\').broadcast()\n        IP(\'10.255.255.255\')\n        """'
newline|'\n'
name|'return'
name|'IP'
op|'('
name|'IPint'
op|'.'
name|'broadcast'
op|'('
name|'self'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|netmask
dedent|''
name|'def'
name|'netmask'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return netmask as an IP object.\n\n        >>> IP(\'10.0.0.0/8\').netmask()\n        IP(\'255.0.0.0\')\n         """'
newline|'\n'
name|'return'
name|'IP'
op|'('
name|'IPint'
op|'.'
name|'netmask'
op|'('
name|'self'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|member|reverseNames
dedent|''
name|'def'
name|'reverseNames'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a list with values forming the reverse lookup.\n\n        >>> IP(\'213.221.113.87/32\').reverseNames()\n        [\'87.113.221.213.in-addr.arpa.\']\n        >>> IP(\'213.221.112.224/30\').reverseNames()\n        [\'224.112.221.213.in-addr.arpa.\', \'225.112.221.213.in-addr.arpa.\', \'226.112.221.213.in-addr.arpa.\', \'227.112.221.213.in-addr.arpa.\']\n        >>> IP(\'127.0.0.0/24\').reverseNames()\n        [\'0.0.127.in-addr.arpa.\']\n        >>> IP(\'127.0.0.0/23\').reverseNames()\n        [\'0.0.127.in-addr.arpa.\', \'1.0.127.in-addr.arpa.\']\n        >>> IP(\'127.0.0.0/16\').reverseNames()\n        [\'0.127.in-addr.arpa.\']\n        >>> IP(\'127.0.0.0/15\').reverseNames()\n        [\'0.127.in-addr.arpa.\', \'1.127.in-addr.arpa.\']\n        >>> IP(\'128.0.0.0/8\').reverseNames()\n        [\'128.in-addr.arpa.\']\n        >>> IP(\'128.0.0.0/7\').reverseNames()\n        [\'128.in-addr.arpa.\', \'129.in-addr.arpa.\']\n        >>> IP(\'::1:2\').reverseNames()\n        [\'2.0.0.0.1.ip6.arpa.\']\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_ipversion'
op|'=='
number|'4'
op|':'
newline|'\n'
indent|'            '
name|'ret'
op|'='
op|'['
op|']'
newline|'\n'
comment|'# TODO: Refactor. Add support for IPint objects'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'len'
op|'('
op|')'
op|'<'
number|'2'
op|'**'
number|'8'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'x'
name|'in'
name|'self'
op|':'
newline|'\n'
indent|'                    '
name|'ret'
op|'.'
name|'append'
op|'('
name|'x'
op|'.'
name|'reverseName'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'self'
op|'.'
name|'len'
op|'('
op|')'
op|'<'
number|'2'
op|'**'
number|'16L'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
number|'0'
op|','
name|'self'
op|'.'
name|'len'
op|'('
op|')'
op|','
number|'2'
op|'**'
number|'8'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'ret'
op|'.'
name|'append'
op|'('
name|'self'
op|'['
name|'i'
op|']'
op|'.'
name|'reverseName'
op|'('
op|')'
op|'['
number|'2'
op|':'
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'self'
op|'.'
name|'len'
op|'('
op|')'
op|'<'
number|'2'
op|'**'
number|'24L'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
number|'0'
op|','
name|'self'
op|'.'
name|'len'
op|'('
op|')'
op|','
number|'2'
op|'**'
number|'16'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'ret'
op|'.'
name|'append'
op|'('
name|'self'
op|'['
name|'i'
op|']'
op|'.'
name|'reverseName'
op|'('
op|')'
op|'['
number|'4'
op|':'
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
number|'0'
op|','
name|'self'
op|'.'
name|'len'
op|'('
op|')'
op|','
number|'2'
op|'**'
number|'24'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'ret'
op|'.'
name|'append'
op|'('
name|'self'
op|'['
name|'i'
op|']'
op|'.'
name|'reverseName'
op|'('
op|')'
op|'['
number|'6'
op|':'
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'ret'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_ipversion'
op|'=='
number|'6'
op|':'
newline|'\n'
indent|'            '
name|'s'
op|'='
name|'hex'
op|'('
name|'self'
op|'.'
name|'ip'
op|')'
op|'['
number|'2'
op|':'
op|']'
op|'.'
name|'lower'
op|'('
op|')'
newline|'\n'
name|'if'
name|'s'
op|'['
op|'-'
number|'1'
op|']'
op|'=='
string|"'l'"
op|':'
newline|'\n'
indent|'                '
name|'s'
op|'='
name|'s'
op|'['
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_prefixlen'
op|'%'
number|'4'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'NotImplementedError'
op|','
string|'"can\'t create IPv6 reverse names at sub nibble level"'
newline|'\n'
dedent|''
name|'s'
op|'='
name|'list'
op|'('
name|'s'
op|')'
newline|'\n'
name|'s'
op|'.'
name|'reverse'
op|'('
op|')'
newline|'\n'
name|'s'
op|'='
string|"'.'"
op|'.'
name|'join'
op|'('
name|'s'
op|')'
newline|'\n'
name|'first_nibble_index'
op|'='
name|'int'
op|'('
number|'32'
op|'-'
op|'('
name|'self'
op|'.'
name|'_prefixlen'
op|'/'
number|'4'
op|')'
op|')'
op|'*'
number|'2'
newline|'\n'
name|'return'
op|'['
string|'"%s.ip6.arpa."'
op|'%'
name|'s'
op|'['
name|'first_nibble_index'
op|':'
op|']'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|','
string|'"only IPv4 and IPv6 supported"'
newline|'\n'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|member|reverseName
dedent|''
dedent|''
name|'def'
name|'reverseName'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the value for reverse lookup/PTR records as RFC 2317 look alike.\n\n        RFC 2317 is an ugly hack which only works for sub-/24 e.g. not\n        for /23. Do not use it. Better set up a zone for every\n        address. See reverseName for a way to achieve that.\n\n        >>> print IP(\'195.185.1.1\').reverseName()\n        1.1.185.195.in-addr.arpa.\n        >>> print IP(\'195.185.1.0/28\').reverseName()\n        0-15.1.185.195.in-addr.arpa.\n        >>> IP(\'::1:2\').reverseName()\n        \'2.0.0.0.1.ip6.arpa.\'\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_ipversion'
op|'=='
number|'4'
op|':'
newline|'\n'
indent|'            '
name|'s'
op|'='
name|'self'
op|'.'
name|'strFullsize'
op|'('
number|'0'
op|')'
newline|'\n'
name|'s'
op|'='
name|'s'
op|'.'
name|'split'
op|'('
string|"'.'"
op|')'
newline|'\n'
name|'s'
op|'.'
name|'reverse'
op|'('
op|')'
newline|'\n'
name|'first_byte_index'
op|'='
name|'int'
op|'('
number|'4'
op|'-'
op|'('
name|'self'
op|'.'
name|'_prefixlen'
op|'/'
number|'8'
op|')'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_prefixlen'
op|'%'
number|'8'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'nibblepart'
op|'='
string|'"%s-%s"'
op|'%'
op|'('
name|'s'
op|'['
number|'3'
op|'-'
op|'('
name|'self'
op|'.'
name|'_prefixlen'
op|'/'
number|'8'
op|')'
op|']'
op|','
name|'intToIp'
op|'('
name|'self'
op|'.'
name|'ip'
op|'+'
name|'self'
op|'.'
name|'len'
op|'('
op|')'
op|'-'
number|'1'
op|','
number|'4'
op|')'
op|'.'
name|'split'
op|'('
string|"'.'"
op|')'
op|'['
op|'-'
number|'1'
op|']'
op|')'
newline|'\n'
name|'if'
name|'nibblepart'
op|'['
op|'-'
number|'1'
op|']'
op|'=='
string|"'l'"
op|':'
newline|'\n'
indent|'                    '
name|'nibblepart'
op|'='
name|'nibblepart'
op|'['
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
dedent|''
name|'nibblepart'
op|'+='
string|"'.'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'nibblepart'
op|'='
string|'""'
newline|'\n'
nl|'\n'
dedent|''
name|'s'
op|'='
string|"'.'"
op|'.'
name|'join'
op|'('
name|'s'
op|'['
name|'first_byte_index'
op|':'
op|']'
op|')'
newline|'\n'
name|'return'
string|'"%s%s.in-addr.arpa."'
op|'%'
op|'('
name|'nibblepart'
op|','
name|'s'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_ipversion'
op|'=='
number|'6'
op|':'
newline|'\n'
indent|'            '
name|'s'
op|'='
name|'hex'
op|'('
name|'self'
op|'.'
name|'ip'
op|')'
op|'['
number|'2'
op|':'
op|']'
op|'.'
name|'lower'
op|'('
op|')'
newline|'\n'
name|'if'
name|'s'
op|'['
op|'-'
number|'1'
op|']'
op|'=='
string|"'l'"
op|':'
newline|'\n'
indent|'                '
name|'s'
op|'='
name|'s'
op|'['
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_prefixlen'
op|'%'
number|'4'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'nibblepart'
op|'='
string|'"%s-%s"'
op|'%'
op|'('
name|'s'
op|'['
name|'self'
op|'.'
name|'_prefixlen'
op|':'
op|']'
op|','
name|'hex'
op|'('
name|'self'
op|'.'
name|'ip'
op|'+'
name|'self'
op|'.'
name|'len'
op|'('
op|')'
op|'-'
number|'1'
op|')'
op|'['
number|'2'
op|':'
op|']'
op|'.'
name|'lower'
op|'('
op|')'
op|')'
newline|'\n'
name|'if'
name|'nibblepart'
op|'['
op|'-'
number|'1'
op|']'
op|'=='
string|"'l'"
op|':'
newline|'\n'
indent|'                    '
name|'nibblepart'
op|'='
name|'nibblepart'
op|'['
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
dedent|''
name|'nibblepart'
op|'+='
string|"'.'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'nibblepart'
op|'='
string|'""'
newline|'\n'
dedent|''
name|'s'
op|'='
name|'list'
op|'('
name|'s'
op|')'
newline|'\n'
name|'s'
op|'.'
name|'reverse'
op|'('
op|')'
newline|'\n'
name|'s'
op|'='
string|"'.'"
op|'.'
name|'join'
op|'('
name|'s'
op|')'
newline|'\n'
name|'first_nibble_index'
op|'='
name|'int'
op|'('
number|'32'
op|'-'
op|'('
name|'self'
op|'.'
name|'_prefixlen'
op|'/'
number|'4'
op|')'
op|')'
op|'*'
number|'2'
newline|'\n'
name|'return'
string|'"%s%s.ip6.arpa."'
op|'%'
op|'('
name|'nibblepart'
op|','
name|'s'
op|'['
name|'first_nibble_index'
op|':'
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|','
string|'"only IPv4 and IPv6 supported"'
newline|'\n'
nl|'\n'
DECL|member|make_net
dedent|''
dedent|''
name|'def'
name|'make_net'
op|'('
name|'self'
op|','
name|'netmask'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Transform a single IP address into a network specification by\n        applying the given netmask.\n\n        Returns a new IP instance.\n\n        >>> print IP(\'127.0.0.1\').make_net(\'255.0.0.0\')\n        127.0.0.0/8\n        """'
newline|'\n'
name|'if'
string|"'/'"
name|'in'
name|'str'
op|'('
name|'netmask'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|','
string|'"invalid netmask (%s)"'
op|'%'
name|'netmask'
newline|'\n'
dedent|''
name|'return'
name|'IP'
op|'('
string|"'%s/%s'"
op|'%'
op|'('
name|'self'
op|','
name|'netmask'
op|')'
op|','
name|'make_net'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__getitem__
dedent|''
name|'def'
name|'__getitem__'
op|'('
name|'self'
op|','
name|'key'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Called to implement evaluation of self[key].\n\n        >>> ip=IP(\'127.0.0.0/30\')\n        >>> for x in ip:\n        ...  print str(x)\n        ...\n        127.0.0.0\n        127.0.0.1\n        127.0.0.2\n        127.0.0.3\n        >>> print str(ip[2])\n        127.0.0.2\n        >>> print str(ip[-1])\n        127.0.0.3\n        """'
newline|'\n'
name|'return'
name|'IP'
op|'('
name|'IPint'
op|'.'
name|'__getitem__'
op|'('
name|'self'
op|','
name|'key'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Print a representation of the Object.\n\n        >>> IP(\'10.0.0.0/8\')\n        IP(\'10.0.0.0/8\')\n        """'
newline|'\n'
nl|'\n'
name|'return'
op|'('
string|'"IP(\'%s\')"'
op|'%'
op|'('
name|'self'
op|'.'
name|'strCompressed'
op|'('
number|'1'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__add__
dedent|''
name|'def'
name|'__add__'
op|'('
name|'self'
op|','
name|'other'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Emulate numeric objects through network aggregation"""'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'prefixlen'
op|'('
op|')'
op|'!='
name|'other'
op|'.'
name|'prefixlen'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|','
string|'"Only networks with the same prefixlen can be added."'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'prefixlen'
op|'<'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|','
string|'"Networks with a prefixlen longer than /1 can\'t be added."'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'version'
op|'('
op|')'
op|'!='
name|'other'
op|'.'
name|'version'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|','
string|'"Only networks with the same IP version can be added."'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'>'
name|'other'
op|':'
newline|'\n'
comment|'# fixed by Skinny Puppy <skin_pup-IPy@happypoo.com>'
nl|'\n'
indent|'            '
name|'return'
name|'other'
op|'.'
name|'__add__'
op|'('
name|'self'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'ret'
op|'='
name|'IP'
op|'('
name|'self'
op|'.'
name|'int'
op|'('
op|')'
op|')'
newline|'\n'
name|'ret'
op|'.'
name|'_prefixlen'
op|'='
name|'self'
op|'.'
name|'prefixlen'
op|'('
op|')'
op|'-'
number|'1'
newline|'\n'
name|'return'
name|'ret'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_parseAddressIPv6
dedent|''
dedent|''
dedent|''
name|'def'
name|'_parseAddressIPv6'
op|'('
name|'ipstr'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Internal function used by parseAddress() to parse IPv6 address with \':\'.\n\n    >>> _parseAddressIPv6(\'::\')\n    0L\n    >>> _parseAddressIPv6(\'::1\')\n    1L\n    >>> _parseAddressIPv6(\'0:0:0:0:0:0:0:1\')\n    1L\n    >>> _parseAddressIPv6(\'0:0:0::0:0:1\')\n    1L\n    >>> _parseAddressIPv6(\'0:0:0:0:0:0:0:0\')\n    0L\n    >>> _parseAddressIPv6(\'0:0:0::0:0:0\')\n    0L\n\n    >>> _parseAddressIPv6(\'FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\')\n    338770000845734292534325025077361652240L\n    >>> _parseAddressIPv6(\'1080:0000:0000:0000:0008:0800:200C:417A\')\n    21932261930451111902915077091070067066L\n    >>> _parseAddressIPv6(\'1080:0:0:0:8:800:200C:417A\')\n    21932261930451111902915077091070067066L\n    >>> _parseAddressIPv6(\'1080:0::8:800:200C:417A\')\n    21932261930451111902915077091070067066L\n    >>> _parseAddressIPv6(\'1080::8:800:200C:417A\')\n    21932261930451111902915077091070067066L\n    >>> _parseAddressIPv6(\'FF01:0:0:0:0:0:0:43\')\n    338958331222012082418099330867817087043L\n    >>> _parseAddressIPv6(\'FF01:0:0::0:0:43\')\n    338958331222012082418099330867817087043L\n    >>> _parseAddressIPv6(\'FF01::43\')\n    338958331222012082418099330867817087043L\n    >>> _parseAddressIPv6(\'0:0:0:0:0:0:13.1.68.3\')\n    218186755L\n    >>> _parseAddressIPv6(\'::13.1.68.3\')\n    218186755L\n    >>> _parseAddressIPv6(\'0:0:0:0:0:FFFF:129.144.52.38\')\n    281472855454758L\n    >>> _parseAddressIPv6(\'::FFFF:129.144.52.38\')\n    281472855454758L\n    >>> _parseAddressIPv6(\'1080:0:0:0:8:800:200C:417A\')\n    21932261930451111902915077091070067066L\n    >>> _parseAddressIPv6(\'1080::8:800:200C:417A\')\n    21932261930451111902915077091070067066L\n    >>> _parseAddressIPv6(\'::1:2:3:4:5:6\')\n    1208962713947218704138246L\n    >>> _parseAddressIPv6(\'1:2:3:4:5:6::\')\n    5192455318486707404433266432802816L\n    """'
newline|'\n'
nl|'\n'
comment|'# Split string into a list, example:'
nl|'\n'
comment|"#   '1080:200C::417A' => ['1080', '200C', '417A'] and fill_pos=2"
nl|'\n'
comment|"# and fill_pos is the position of '::' in the list"
nl|'\n'
name|'items'
op|'='
op|'['
op|']'
newline|'\n'
name|'index'
op|'='
number|'0'
newline|'\n'
name|'fill_pos'
op|'='
name|'None'
newline|'\n'
name|'while'
name|'index'
op|'<'
name|'len'
op|'('
name|'ipstr'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'text'
op|'='
name|'ipstr'
op|'['
name|'index'
op|':'
op|']'
newline|'\n'
name|'if'
name|'text'
op|'.'
name|'startswith'
op|'('
string|'"::"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'fill_pos'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
comment|"# Invalid IPv6, eg. '1::2::'"
nl|'\n'
indent|'                '
name|'raise'
name|'ValueError'
op|'('
string|'"%r: Invalid IPv6 address: more than one \'::\'"'
op|'%'
name|'ipstr'
op|')'
newline|'\n'
dedent|''
name|'fill_pos'
op|'='
name|'len'
op|'('
name|'items'
op|')'
newline|'\n'
name|'index'
op|'+='
number|'2'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'pos'
op|'='
name|'text'
op|'.'
name|'find'
op|'('
string|"':'"
op|')'
newline|'\n'
name|'if'
name|'pos'
op|'=='
number|'0'
op|':'
newline|'\n'
comment|"# Invalid IPv6, eg. '1::2:'"
nl|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|'"%r: Invalid IPv6 address"'
op|'%'
name|'ipstr'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'pos'
op|'!='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'items'
op|'.'
name|'append'
op|'('
name|'text'
op|'['
op|':'
name|'pos'
op|']'
op|')'
newline|'\n'
name|'if'
name|'text'
op|'['
name|'pos'
op|':'
name|'pos'
op|'+'
number|'2'
op|']'
op|'=='
string|'"::"'
op|':'
newline|'\n'
indent|'                '
name|'index'
op|'+='
name|'pos'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'index'
op|'+='
name|'pos'
op|'+'
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'index'
op|'=='
name|'len'
op|'('
name|'ipstr'
op|')'
op|':'
newline|'\n'
comment|"# Invalid IPv6, eg. '1::2:'"
nl|'\n'
indent|'                '
name|'raise'
name|'ValueError'
op|'('
string|'"%r: Invalid IPv6 address"'
op|'%'
name|'ipstr'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'items'
op|'.'
name|'append'
op|'('
name|'text'
op|')'
newline|'\n'
name|'break'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'items'
name|'and'
string|"'.'"
name|'in'
name|'items'
op|'['
op|'-'
number|'1'
op|']'
op|':'
newline|'\n'
comment|"# IPv6 ending with IPv4 like '::ffff:192.168.0.1'"
nl|'\n'
indent|'        '
name|'if'
name|'not'
op|'('
name|'fill_pos'
op|'<='
name|'len'
op|'('
name|'items'
op|')'
op|'-'
number|'1'
op|')'
op|':'
newline|'\n'
comment|"# Invalid IPv6: 'ffff:192.168.0.1::'"
nl|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|'"%r: Invalid IPv6 address: \'::\' after IPv4"'
op|'%'
name|'ipstr'
op|')'
newline|'\n'
dedent|''
name|'value'
op|'='
name|'parseAddress'
op|'('
name|'items'
op|'['
op|'-'
number|'1'
op|']'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'items'
op|'='
name|'items'
op|'['
op|':'
op|'-'
number|'1'
op|']'
op|'+'
op|'['
string|'"%04x"'
op|'%'
op|'('
name|'value'
op|'>>'
number|'16'
op|')'
op|','
string|'"%04x"'
op|'%'
op|'('
name|'value'
op|'&'
number|'0xffff'
op|')'
op|']'
newline|'\n'
nl|'\n'
comment|"# Expand fill_pos to fill with '0'"
nl|'\n'
comment|"# ['1','2'] with fill_pos=1 => ['1', '0', '0', '0', '0', '0', '0', '2']"
nl|'\n'
dedent|''
name|'if'
name|'fill_pos'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'diff'
op|'='
number|'8'
op|'-'
name|'len'
op|'('
name|'items'
op|')'
newline|'\n'
name|'if'
name|'diff'
op|'<='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|'"%r: Invalid IPv6 address: \'::\' is not needed"'
op|'%'
name|'ipstr'
op|')'
newline|'\n'
dedent|''
name|'items'
op|'='
name|'items'
op|'['
op|':'
name|'fill_pos'
op|']'
op|'+'
op|'['
string|"'0'"
op|']'
op|'*'
name|'diff'
op|'+'
name|'items'
op|'['
name|'fill_pos'
op|':'
op|']'
newline|'\n'
nl|'\n'
comment|'# Here we have a list of 8 strings'
nl|'\n'
dedent|''
name|'if'
name|'len'
op|'('
name|'items'
op|')'
op|'!='
number|'8'
op|':'
newline|'\n'
comment|"# Invalid IPv6, eg. '1:2:3'"
nl|'\n'
indent|'        '
name|'raise'
name|'ValueError'
op|'('
string|'"%r: Invalid IPv6 address: should have 8 hextets"'
op|'%'
name|'ipstr'
op|')'
newline|'\n'
nl|'\n'
comment|'# Convert strings to long integer'
nl|'\n'
dedent|''
name|'value'
op|'='
number|'0L'
newline|'\n'
name|'index'
op|'='
number|'0'
newline|'\n'
name|'for'
name|'item'
name|'in'
name|'items'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'item'
op|'='
name|'int'
op|'('
name|'item'
op|','
number|'16'
op|')'
newline|'\n'
name|'error'
op|'='
name|'not'
op|'('
number|'0'
op|'<='
name|'item'
op|'<='
number|'0xFFFF'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'            '
name|'error'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'if'
name|'error'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|'"%r: Invalid IPv6 address: invalid hexlet %r"'
op|'%'
op|'('
name|'ipstr'
op|','
name|'item'
op|')'
op|')'
newline|'\n'
dedent|''
name|'value'
op|'='
op|'('
name|'value'
op|'<<'
number|'16'
op|')'
op|'+'
name|'item'
newline|'\n'
name|'index'
op|'+='
number|'1'
newline|'\n'
dedent|''
name|'return'
name|'value'
newline|'\n'
nl|'\n'
DECL|function|parseAddress
dedent|''
name|'def'
name|'parseAddress'
op|'('
name|'ipstr'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Parse a string and return the corresponding IP address (as integer)\n    and a guess of the IP version.\n\n    Following address formats are recognized:\n\n    >>> parseAddress(\'0x0123456789abcdef\')           # IPv4 if <= 0xffffffff else IPv6\n    (81985529216486895L, 6)\n    >>> parseAddress(\'123.123.123.123\')              # IPv4\n    (2071690107L, 4)\n    >>> parseAddress(\'123.123\')                      # 0-padded IPv4\n    (2071658496L, 4)\n    >>> parseAddress(\'1080:0000:0000:0000:0008:0800:200C:417A\')\n    (21932261930451111902915077091070067066L, 6)\n    >>> parseAddress(\'1080:0:0:0:8:800:200C:417A\')\n    (21932261930451111902915077091070067066L, 6)\n    >>> parseAddress(\'1080:0::8:800:200C:417A\')\n    (21932261930451111902915077091070067066L, 6)\n    >>> parseAddress(\'::1\')\n    (1L, 6)\n    >>> parseAddress(\'::\')\n    (0L, 6)\n    >>> parseAddress(\'0:0:0:0:0:FFFF:129.144.52.38\')\n    (281472855454758L, 6)\n    >>> parseAddress(\'::13.1.68.3\')\n    (218186755L, 6)\n    >>> parseAddress(\'::FFFF:129.144.52.38\')\n    (281472855454758L, 6)\n    """'
newline|'\n'
nl|'\n'
name|'if'
name|'ipstr'
op|'.'
name|'startswith'
op|'('
string|"'0x'"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'ret'
op|'='
name|'long'
op|'('
name|'ipstr'
op|'['
number|'2'
op|':'
op|']'
op|','
number|'16'
op|')'
newline|'\n'
name|'if'
name|'ret'
op|'>'
number|'0xffffffffffffffffffffffffffffffffL'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|','
string|'"%r: IP Address can\'t be bigger than 2^128"'
op|'%'
op|'('
name|'ipstr'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'ret'
op|'<'
number|'0x100000000L'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'('
name|'ret'
op|','
number|'4'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'('
name|'ret'
op|','
number|'6'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'ipstr'
op|'.'
name|'find'
op|'('
string|"':'"
op|')'
op|'!='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
name|'_parseAddressIPv6'
op|'('
name|'ipstr'
op|')'
op|','
number|'6'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'len'
op|'('
name|'ipstr'
op|')'
op|'=='
number|'32'
op|':'
newline|'\n'
comment|'# assume IPv6 in pure hexadecimal notation'
nl|'\n'
indent|'        '
name|'return'
op|'('
name|'long'
op|'('
name|'ipstr'
op|','
number|'16'
op|')'
op|','
number|'6'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'ipstr'
op|'.'
name|'find'
op|'('
string|"'.'"
op|')'
op|'!='
op|'-'
number|'1'
name|'or'
op|'('
name|'len'
op|'('
name|'ipstr'
op|')'
op|'<'
number|'4'
name|'and'
name|'int'
op|'('
name|'ipstr'
op|')'
op|'<'
number|'256'
op|')'
op|':'
newline|'\n'
comment|"# assume IPv4  ('127' gets interpreted as '127.0.0.0')"
nl|'\n'
indent|'        '
name|'bytes'
op|'='
name|'ipstr'
op|'.'
name|'split'
op|'('
string|"'.'"
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'bytes'
op|')'
op|'>'
number|'4'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|','
string|'"IPv4 Address with more than 4 bytes"'
newline|'\n'
dedent|''
name|'bytes'
op|'+='
op|'['
string|"'0'"
op|']'
op|'*'
op|'('
number|'4'
op|'-'
name|'len'
op|'('
name|'bytes'
op|')'
op|')'
newline|'\n'
name|'bytes'
op|'='
op|'['
name|'long'
op|'('
name|'x'
op|')'
name|'for'
name|'x'
name|'in'
name|'bytes'
op|']'
newline|'\n'
name|'for'
name|'x'
name|'in'
name|'bytes'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'x'
op|'>'
number|'255'
name|'or'
name|'x'
op|'<'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'ValueError'
op|','
string|'"%r: single byte must be 0 <= byte < 256"'
op|'%'
op|'('
name|'ipstr'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
op|'('
op|'('
name|'bytes'
op|'['
number|'0'
op|']'
op|'<<'
number|'24'
op|')'
op|'+'
op|'('
name|'bytes'
op|'['
number|'1'
op|']'
op|'<<'
number|'16'
op|')'
op|'+'
op|'('
name|'bytes'
op|'['
number|'2'
op|']'
op|'<<'
number|'8'
op|')'
op|'+'
name|'bytes'
op|'['
number|'3'
op|']'
op|','
number|'4'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# we try to interprete it as a decimal digit -'
nl|'\n'
comment|'# this ony works for numbers > 255 ... others'
nl|'\n'
comment|'# will be interpreted as IPv4 first byte'
nl|'\n'
indent|'        '
name|'ret'
op|'='
name|'long'
op|'('
name|'ipstr'
op|','
number|'10'
op|')'
newline|'\n'
name|'if'
name|'ret'
op|'>'
number|'0xffffffffffffffffffffffffffffffffL'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|','
string|'"IP Address can\'t be bigger than 2^128"'
newline|'\n'
dedent|''
name|'if'
name|'ret'
op|'<='
number|'0xffffffffL'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'('
name|'ret'
op|','
number|'4'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'('
name|'ret'
op|','
number|'6'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|intToIp
dedent|''
dedent|''
dedent|''
name|'def'
name|'intToIp'
op|'('
name|'ip'
op|','
name|'version'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Transform an integer string into an IP address."""'
newline|'\n'
nl|'\n'
comment|'# just to be sure and hoping for Python 2.22'
nl|'\n'
name|'ip'
op|'='
name|'long'
op|'('
name|'ip'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'ip'
op|'<'
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'ValueError'
op|','
string|'"IPs can\'t be negative: %d"'
op|'%'
op|'('
name|'ip'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'ret'
op|'='
string|"''"
newline|'\n'
name|'if'
name|'version'
op|'=='
number|'4'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'ip'
op|'>'
number|'0xffffffffL'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|','
string|'"IPv4 Addresses can\'t be larger than 0xffffffff: %s"'
op|'%'
op|'('
name|'hex'
op|'('
name|'ip'
op|')'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'l'
name|'in'
name|'range'
op|'('
number|'4'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'ret'
op|'='
name|'str'
op|'('
name|'ip'
op|'&'
number|'0xffL'
op|')'
op|'+'
string|"'.'"
op|'+'
name|'ret'
newline|'\n'
name|'ip'
op|'='
name|'ip'
op|'>>'
number|'8'
newline|'\n'
dedent|''
name|'ret'
op|'='
name|'ret'
op|'['
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
dedent|''
name|'elif'
name|'version'
op|'=='
number|'6'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'ip'
op|'>'
number|'0xffffffffffffffffffffffffffffffffL'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|','
string|'"IPv6 Addresses can\'t be larger than 0xffffffffffffffffffffffffffffffff: %s"'
op|'%'
op|'('
name|'hex'
op|'('
name|'ip'
op|')'
op|')'
newline|'\n'
dedent|''
name|'l'
op|'='
string|"'0'"
op|'*'
number|'32'
op|'+'
name|'hex'
op|'('
name|'ip'
op|')'
op|'['
number|'2'
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
name|'for'
name|'x'
name|'in'
name|'range'
op|'('
number|'1'
op|','
number|'33'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'ret'
op|'='
name|'l'
op|'['
op|'-'
name|'x'
op|']'
op|'+'
name|'ret'
newline|'\n'
name|'if'
name|'x'
op|'%'
number|'4'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'ret'
op|'='
string|"':'"
op|'+'
name|'ret'
newline|'\n'
dedent|''
dedent|''
name|'ret'
op|'='
name|'ret'
op|'['
number|'1'
op|':'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'ValueError'
op|','
string|'"only IPv4 and IPv6 supported"'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'ret'
newline|'\n'
nl|'\n'
DECL|function|_ipVersionToLen
dedent|''
name|'def'
name|'_ipVersionToLen'
op|'('
name|'version'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return number of bits in address for a certain IP version.\n\n    >>> _ipVersionToLen(4)\n    32\n    >>> _ipVersionToLen(6)\n    128\n    >>> _ipVersionToLen(5)\n    Traceback (most recent call last):\n      File "<stdin>", line 1, in ?\n      File "IPy.py", line 1076, in _ipVersionToLen\n        raise ValueError, "only IPv4 and IPv6 supported"\n    ValueError: only IPv4 and IPv6 supported\n    """'
newline|'\n'
nl|'\n'
name|'if'
name|'version'
op|'=='
number|'4'
op|':'
newline|'\n'
indent|'        '
name|'return'
number|'32'
newline|'\n'
dedent|''
name|'elif'
name|'version'
op|'=='
number|'6'
op|':'
newline|'\n'
indent|'        '
name|'return'
number|'128'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'ValueError'
op|','
string|'"only IPv4 and IPv6 supported"'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_countFollowingZeros
dedent|''
dedent|''
name|'def'
name|'_countFollowingZeros'
op|'('
name|'l'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return number of elements containing 0 at the beginning of the list."""'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'l'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'return'
number|'0'
newline|'\n'
dedent|''
name|'elif'
name|'l'
op|'['
number|'0'
op|']'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'return'
number|'0'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
number|'1'
op|'+'
name|'_countFollowingZeros'
op|'('
name|'l'
op|'['
number|'1'
op|':'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|_BitTable
dedent|''
dedent|''
name|'_BitTable'
op|'='
op|'{'
string|"'0'"
op|':'
string|"'0000'"
op|','
string|"'1'"
op|':'
string|"'0001'"
op|','
string|"'2'"
op|':'
string|"'0010'"
op|','
string|"'3'"
op|':'
string|"'0011'"
op|','
nl|'\n'
string|"'4'"
op|':'
string|"'0100'"
op|','
string|"'5'"
op|':'
string|"'0101'"
op|','
string|"'6'"
op|':'
string|"'0110'"
op|','
string|"'7'"
op|':'
string|"'0111'"
op|','
nl|'\n'
string|"'8'"
op|':'
string|"'1000'"
op|','
string|"'9'"
op|':'
string|"'1001'"
op|','
string|"'a'"
op|':'
string|"'1010'"
op|','
string|"'b'"
op|':'
string|"'1011'"
op|','
nl|'\n'
string|"'c'"
op|':'
string|"'1100'"
op|','
string|"'d'"
op|':'
string|"'1101'"
op|','
string|"'e'"
op|':'
string|"'1110'"
op|','
string|"'f'"
op|':'
string|"'1111'"
op|'}'
newline|'\n'
nl|'\n'
DECL|function|_intToBin
name|'def'
name|'_intToBin'
op|'('
name|'val'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the binary representation of an integer as string."""'
newline|'\n'
nl|'\n'
name|'if'
name|'val'
op|'<'
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'ValueError'
op|','
string|'"Only positive values allowed"'
newline|'\n'
dedent|''
name|'s'
op|'='
name|'hex'
op|'('
name|'val'
op|')'
op|'.'
name|'lower'
op|'('
op|')'
newline|'\n'
name|'ret'
op|'='
string|"''"
newline|'\n'
name|'if'
name|'s'
op|'['
op|'-'
number|'1'
op|']'
op|'=='
string|"'l'"
op|':'
newline|'\n'
indent|'        '
name|'s'
op|'='
name|'s'
op|'['
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
dedent|''
name|'for'
name|'x'
name|'in'
name|'s'
op|'['
number|'2'
op|':'
op|']'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'__debug__'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'_BitTable'
op|'.'
name|'has_key'
op|'('
name|'x'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'AssertionError'
op|','
string|'"hex() returned strange result"'
newline|'\n'
dedent|''
dedent|''
name|'ret'
op|'+='
name|'_BitTable'
op|'['
name|'x'
op|']'
newline|'\n'
comment|'# remove leading zeros'
nl|'\n'
dedent|''
name|'while'
name|'ret'
op|'['
number|'0'
op|']'
op|'=='
string|"'0'"
name|'and'
name|'len'
op|'('
name|'ret'
op|')'
op|'>'
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'ret'
op|'='
name|'ret'
op|'['
number|'1'
op|':'
op|']'
newline|'\n'
dedent|''
name|'return'
name|'ret'
newline|'\n'
nl|'\n'
DECL|function|_count1Bits
dedent|''
name|'def'
name|'_count1Bits'
op|'('
name|'num'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Find the highest bit set to 1 in an integer."""'
newline|'\n'
name|'ret'
op|'='
number|'0'
newline|'\n'
name|'while'
name|'num'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'num'
op|'='
name|'num'
op|'>>'
number|'1'
newline|'\n'
name|'ret'
op|'+='
number|'1'
newline|'\n'
dedent|''
name|'return'
name|'ret'
newline|'\n'
nl|'\n'
DECL|function|_count0Bits
dedent|''
name|'def'
name|'_count0Bits'
op|'('
name|'num'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Find the highest bit set to 0 in an integer."""'
newline|'\n'
nl|'\n'
comment|'# this could be so easy if _count1Bits(~long(num)) would work as excepted'
nl|'\n'
name|'num'
op|'='
name|'long'
op|'('
name|'num'
op|')'
newline|'\n'
name|'if'
name|'num'
op|'<'
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'ValueError'
op|','
string|'"Only positive Numbers please: %s"'
op|'%'
op|'('
name|'num'
op|')'
newline|'\n'
dedent|''
name|'ret'
op|'='
number|'0'
newline|'\n'
name|'while'
name|'num'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'num'
op|'&'
number|'1'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'break'
newline|'\n'
dedent|''
name|'num'
op|'='
name|'num'
op|'>>'
number|'1'
newline|'\n'
name|'ret'
op|'+='
number|'1'
newline|'\n'
dedent|''
name|'return'
name|'ret'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_checkPrefix
dedent|''
name|'def'
name|'_checkPrefix'
op|'('
name|'ip'
op|','
name|'prefixlen'
op|','
name|'version'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Check the validity of a prefix\n\n    Checks if the variant part of a prefix only has 0s, and the length is\n    correct.\n\n    >>> _checkPrefix(0x7f000000L, 24, 4)\n    1\n    >>> _checkPrefix(0x7f000001L, 24, 4)\n    0\n    >>> repr(_checkPrefix(0x7f000001L, -1, 4))\n    \'None\'\n    >>> repr(_checkPrefix(0x7f000001L, 33, 4))\n    \'None\'\n    """'
newline|'\n'
nl|'\n'
comment|'# TODO: unify this v4/v6/invalid code in a function'
nl|'\n'
name|'bits'
op|'='
name|'_ipVersionToLen'
op|'('
name|'version'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'prefixlen'
op|'<'
number|'0'
name|'or'
name|'prefixlen'
op|'>'
name|'bits'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'ip'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'zbits'
op|'='
name|'bits'
op|'+'
number|'1'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'zbits'
op|'='
name|'_count0Bits'
op|'('
name|'ip'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'zbits'
op|'<'
name|'bits'
op|'-'
name|'prefixlen'
op|':'
newline|'\n'
indent|'        '
name|'return'
number|'0'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_checkNetmask
dedent|''
dedent|''
name|'def'
name|'_checkNetmask'
op|'('
name|'netmask'
op|','
name|'masklen'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Checks if a netmask is expressable as a prefixlen."""'
newline|'\n'
nl|'\n'
name|'num'
op|'='
name|'long'
op|'('
name|'netmask'
op|')'
newline|'\n'
name|'bits'
op|'='
name|'masklen'
newline|'\n'
nl|'\n'
comment|'# remove zero bits at the end'
nl|'\n'
name|'while'
op|'('
name|'num'
op|'&'
number|'1'
op|')'
op|'=='
number|'0'
name|'and'
name|'bits'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'num'
op|'='
name|'num'
op|'>>'
number|'1'
newline|'\n'
name|'bits'
op|'-='
number|'1'
newline|'\n'
name|'if'
name|'bits'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'break'
newline|'\n'
comment|'# now check if the rest consists only of ones'
nl|'\n'
dedent|''
dedent|''
name|'while'
name|'bits'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'if'
op|'('
name|'num'
op|'&'
number|'1'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|','
string|'"Netmask %s can\'t be expressed as an prefix."'
op|'%'
op|'('
name|'hex'
op|'('
name|'netmask'
op|')'
op|')'
newline|'\n'
dedent|''
name|'num'
op|'='
name|'num'
op|'>>'
number|'1'
newline|'\n'
name|'bits'
op|'-='
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_checkNetaddrWorksWithPrefixlen
dedent|''
dedent|''
name|'def'
name|'_checkNetaddrWorksWithPrefixlen'
op|'('
name|'net'
op|','
name|'prefixlen'
op|','
name|'version'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Check if a base addess of a network is compatible with a prefixlen"""'
newline|'\n'
name|'if'
name|'net'
op|'&'
name|'_prefixlenToNetmask'
op|'('
name|'prefixlen'
op|','
name|'version'
op|')'
op|'=='
name|'net'
op|':'
newline|'\n'
indent|'        '
name|'return'
number|'1'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
number|'0'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_netmaskToPrefixlen
dedent|''
dedent|''
name|'def'
name|'_netmaskToPrefixlen'
op|'('
name|'netmask'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Convert an Integer representing a netmask to a prefixlen.\n\n    E.g. 0xffffff00 (255.255.255.0) returns 24\n    """'
newline|'\n'
nl|'\n'
name|'netlen'
op|'='
name|'_count0Bits'
op|'('
name|'netmask'
op|')'
newline|'\n'
name|'masklen'
op|'='
name|'_count1Bits'
op|'('
name|'netmask'
op|')'
newline|'\n'
name|'_checkNetmask'
op|'('
name|'netmask'
op|','
name|'masklen'
op|')'
newline|'\n'
name|'return'
name|'masklen'
op|'-'
name|'netlen'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_prefixlenToNetmask
dedent|''
name|'def'
name|'_prefixlenToNetmask'
op|'('
name|'prefixlen'
op|','
name|'version'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return a mask of n bits as a long integer.\n\n    From \'IP address conversion functions with the builtin socket module\'\n    by Alex Martelli\n    http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/66517\n    """'
newline|'\n'
name|'if'
name|'prefixlen'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'return'
number|'0'
newline|'\n'
dedent|''
name|'elif'
name|'prefixlen'
op|'<'
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'ValueError'
op|','
string|'"Prefixlen must be > 0"'
newline|'\n'
dedent|''
name|'return'
op|'('
op|'('
number|'2L'
op|'<<'
name|'prefixlen'
op|'-'
number|'1'
op|')'
op|'-'
number|'1'
op|')'
op|'<<'
op|'('
name|'_ipVersionToLen'
op|'('
name|'version'
op|')'
op|'-'
name|'prefixlen'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
name|'if'
name|'__name__'
op|'=='
string|'"__main__"'
op|':'
newline|'\n'
indent|'    '
name|'import'
name|'doctest'
newline|'\n'
name|'failure'
op|','
name|'nbtest'
op|'='
name|'doctest'
op|'.'
name|'testmod'
op|'('
op|')'
newline|'\n'
name|'if'
name|'failure'
op|':'
newline|'\n'
indent|'        '
name|'import'
name|'sys'
newline|'\n'
name|'sys'
op|'.'
name|'exit'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
