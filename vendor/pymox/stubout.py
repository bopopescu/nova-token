begin_unit
comment|'#!/usr/bin/python2.4'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Copyright 2008 Google Inc.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Licensed under the Apache License, Version 2.0 (the "License");'
nl|'\n'
comment|'# you may not use this file except in compliance with the License.'
nl|'\n'
comment|'# You may obtain a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#      http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'# distributed under the License is distributed on an "AS IS" BASIS,'
nl|'\n'
comment|'# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.'
nl|'\n'
comment|'# See the License for the specific language governing permissions and'
nl|'\n'
comment|'# limitations under the License.'
nl|'\n'
nl|'\n'
name|'import'
name|'inspect'
newline|'\n'
nl|'\n'
DECL|class|StubOutForTesting
name|'class'
name|'StubOutForTesting'
op|':'
newline|'\n'
indent|'  '
string|'"""Sample Usage:\n     You want os.path.exists() to always return true during testing.\n\n     stubs = StubOutForTesting()\n     stubs.Set(os.path, \'exists\', lambda x: 1)\n       ...\n     stubs.UnsetAll()\n\n     The above changes os.path.exists into a lambda that returns 1.  Once\n     the ... part of the code finishes, the UnsetAll() looks up the old value\n     of os.path.exists and restores it.\n\n  """'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'self'
op|'.'
name|'cache'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'stubs'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|__del__
dedent|''
name|'def'
name|'__del__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'self'
op|'.'
name|'SmartUnsetAll'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'UnsetAll'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|SmartSet
dedent|''
name|'def'
name|'SmartSet'
op|'('
name|'self'
op|','
name|'obj'
op|','
name|'attr_name'
op|','
name|'new_attr'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Replace obj.attr_name with new_attr. This method is smart and works\n       at the module, class, and instance level while preserving proper\n       inheritance. It will not stub out C types however unless that has been\n       explicitly allowed by the type.\n\n       This method supports the case where attr_name is a staticmethod or a\n       classmethod of obj.\n\n       Notes:\n      - If obj is an instance, then it is its class that will actually be\n        stubbed. Note that the method Set() does not do that: if obj is\n        an instance, it (and not its class) will be stubbed.\n      - The stubbing is using the builtin getattr and setattr. So, the __get__\n        and __set__ will be called when stubbing (TODO: A better idea would\n        probably be to manipulate obj.__dict__ instead of getattr() and\n        setattr()).\n\n       Raises AttributeError if the attribute cannot be found.\n    """'
newline|'\n'
name|'if'
op|'('
name|'inspect'
op|'.'
name|'ismodule'
op|'('
name|'obj'
op|')'
name|'or'
nl|'\n'
op|'('
name|'not'
name|'inspect'
op|'.'
name|'isclass'
op|'('
name|'obj'
op|')'
name|'and'
name|'obj'
op|'.'
name|'__dict__'
op|'.'
name|'has_key'
op|'('
name|'attr_name'
op|')'
op|')'
op|')'
op|':'
newline|'\n'
indent|'      '
name|'orig_obj'
op|'='
name|'obj'
newline|'\n'
name|'orig_attr'
op|'='
name|'getattr'
op|'('
name|'obj'
op|','
name|'attr_name'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'      '
name|'if'
name|'not'
name|'inspect'
op|'.'
name|'isclass'
op|'('
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'mro'
op|'='
name|'list'
op|'('
name|'inspect'
op|'.'
name|'getmro'
op|'('
name|'obj'
op|'.'
name|'__class__'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'mro'
op|'='
name|'list'
op|'('
name|'inspect'
op|'.'
name|'getmro'
op|'('
name|'obj'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'mro'
op|'.'
name|'reverse'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'orig_attr'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'for'
name|'cls'
name|'in'
name|'mro'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'          '
name|'orig_obj'
op|'='
name|'cls'
newline|'\n'
name|'orig_attr'
op|'='
name|'getattr'
op|'('
name|'obj'
op|','
name|'attr_name'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'          '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'orig_attr'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'      '
name|'raise'
name|'AttributeError'
op|'('
string|'"Attribute not found."'
op|')'
newline|'\n'
nl|'\n'
comment|"# Calling getattr() on a staticmethod transforms it to a 'normal' function."
nl|'\n'
comment|'# We need to ensure that we put it back as a staticmethod.'
nl|'\n'
dedent|''
name|'old_attribute'
op|'='
name|'obj'
op|'.'
name|'__dict__'
op|'.'
name|'get'
op|'('
name|'attr_name'
op|')'
newline|'\n'
name|'if'
name|'old_attribute'
name|'is'
name|'not'
name|'None'
name|'and'
name|'isinstance'
op|'('
name|'old_attribute'
op|','
name|'staticmethod'
op|')'
op|':'
newline|'\n'
indent|'      '
name|'orig_attr'
op|'='
name|'staticmethod'
op|'('
name|'orig_attr'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'stubs'
op|'.'
name|'append'
op|'('
op|'('
name|'orig_obj'
op|','
name|'attr_name'
op|','
name|'orig_attr'
op|')'
op|')'
newline|'\n'
name|'setattr'
op|'('
name|'orig_obj'
op|','
name|'attr_name'
op|','
name|'new_attr'
op|')'
newline|'\n'
nl|'\n'
DECL|member|SmartUnsetAll
dedent|''
name|'def'
name|'SmartUnsetAll'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Reverses all the SmartSet() calls, restoring things to their original\n    definition.  Its okay to call SmartUnsetAll() repeatedly, as later calls\n    have no effect if no SmartSet() calls have been made.\n\n    """'
newline|'\n'
name|'self'
op|'.'
name|'stubs'
op|'.'
name|'reverse'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'args'
name|'in'
name|'self'
op|'.'
name|'stubs'
op|':'
newline|'\n'
indent|'      '
name|'setattr'
op|'('
op|'*'
name|'args'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'stubs'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|Set
dedent|''
name|'def'
name|'Set'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'child_name'
op|','
name|'new_child'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Replace child_name\'s old definition with new_child, in the context\n    of the given parent.  The parent could be a module when the child is a\n    function at module scope.  Or the parent could be a class when a class\'\n    method is being replaced.  The named child is set to new_child, while\n    the prior definition is saved away for later, when UnsetAll() is called.\n\n    This method supports the case where child_name is a staticmethod or a\n    classmethod of parent.\n    """'
newline|'\n'
name|'old_child'
op|'='
name|'getattr'
op|'('
name|'parent'
op|','
name|'child_name'
op|')'
newline|'\n'
nl|'\n'
name|'old_attribute'
op|'='
name|'parent'
op|'.'
name|'__dict__'
op|'.'
name|'get'
op|'('
name|'child_name'
op|')'
newline|'\n'
name|'if'
name|'old_attribute'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'      '
name|'if'
name|'isinstance'
op|'('
name|'old_attribute'
op|','
name|'staticmethod'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'old_child'
op|'='
name|'staticmethod'
op|'('
name|'old_child'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'isinstance'
op|'('
name|'old_attribute'
op|','
name|'classmethod'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'old_child'
op|'='
name|'classmethod'
op|'('
name|'old_child'
op|'.'
name|'im_func'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'cache'
op|'.'
name|'append'
op|'('
op|'('
name|'parent'
op|','
name|'old_child'
op|','
name|'child_name'
op|')'
op|')'
newline|'\n'
name|'setattr'
op|'('
name|'parent'
op|','
name|'child_name'
op|','
name|'new_child'
op|')'
newline|'\n'
nl|'\n'
DECL|member|UnsetAll
dedent|''
name|'def'
name|'UnsetAll'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Reverses all the Set() calls, restoring things to their original\n    definition.  Its okay to call UnsetAll() repeatedly, as later calls have\n    no effect if no Set() calls have been made.\n\n    """'
newline|'\n'
comment|'# Undo calls to Set() in reverse order, in case Set() was called on the'
nl|'\n'
comment|'# same arguments repeatedly (want the original call to be last one undone)'
nl|'\n'
name|'self'
op|'.'
name|'cache'
op|'.'
name|'reverse'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'for'
op|'('
name|'parent'
op|','
name|'old_child'
op|','
name|'child_name'
op|')'
name|'in'
name|'self'
op|'.'
name|'cache'
op|':'
newline|'\n'
indent|'      '
name|'setattr'
op|'('
name|'parent'
op|','
name|'child_name'
op|','
name|'old_child'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'cache'
op|'='
op|'['
op|']'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
