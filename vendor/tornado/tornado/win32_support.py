begin_unit
comment|'# NOTE: win32 support is currently experimental, and not recommended'
nl|'\n'
comment|'# for production use.'
nl|'\n'
nl|'\n'
name|'import'
name|'ctypes'
newline|'\n'
name|'import'
name|'ctypes'
op|'.'
name|'wintypes'
newline|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'socket'
newline|'\n'
name|'import'
name|'errno'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# See: http://msdn.microsoft.com/en-us/library/ms738573(VS.85).aspx'
nl|'\n'
DECL|variable|ioctlsocket
name|'ioctlsocket'
op|'='
name|'ctypes'
op|'.'
name|'windll'
op|'.'
name|'ws2_32'
op|'.'
name|'ioctlsocket'
newline|'\n'
name|'ioctlsocket'
op|'.'
name|'argtypes'
op|'='
op|'('
name|'ctypes'
op|'.'
name|'wintypes'
op|'.'
name|'HANDLE'
op|','
name|'ctypes'
op|'.'
name|'wintypes'
op|'.'
name|'LONG'
op|','
name|'ctypes'
op|'.'
name|'wintypes'
op|'.'
name|'ULONG'
op|')'
newline|'\n'
name|'ioctlsocket'
op|'.'
name|'restype'
op|'='
name|'ctypes'
op|'.'
name|'c_int'
newline|'\n'
nl|'\n'
comment|'# See: http://msdn.microsoft.com/en-us/library/ms724935(VS.85).aspx'
nl|'\n'
DECL|variable|SetHandleInformation
name|'SetHandleInformation'
op|'='
name|'ctypes'
op|'.'
name|'windll'
op|'.'
name|'kernel32'
op|'.'
name|'SetHandleInformation'
newline|'\n'
name|'SetHandleInformation'
op|'.'
name|'argtypes'
op|'='
op|'('
name|'ctypes'
op|'.'
name|'wintypes'
op|'.'
name|'HANDLE'
op|','
name|'ctypes'
op|'.'
name|'wintypes'
op|'.'
name|'DWORD'
op|','
name|'ctypes'
op|'.'
name|'wintypes'
op|'.'
name|'DWORD'
op|')'
newline|'\n'
name|'SetHandleInformation'
op|'.'
name|'restype'
op|'='
name|'ctypes'
op|'.'
name|'wintypes'
op|'.'
name|'BOOL'
newline|'\n'
nl|'\n'
DECL|variable|HANDLE_FLAG_INHERIT
name|'HANDLE_FLAG_INHERIT'
op|'='
number|'0x00000001'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|F_GETFD
name|'F_GETFD'
op|'='
number|'1'
newline|'\n'
DECL|variable|F_SETFD
name|'F_SETFD'
op|'='
number|'2'
newline|'\n'
DECL|variable|F_GETFL
name|'F_GETFL'
op|'='
number|'3'
newline|'\n'
DECL|variable|F_SETFL
name|'F_SETFL'
op|'='
number|'4'
newline|'\n'
nl|'\n'
DECL|variable|FD_CLOEXEC
name|'FD_CLOEXEC'
op|'='
number|'1'
newline|'\n'
nl|'\n'
name|'os'
op|'.'
name|'O_NONBLOCK'
op|'='
number|'2048'
newline|'\n'
nl|'\n'
DECL|variable|FIONBIO
name|'FIONBIO'
op|'='
number|'126'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|fcntl
name|'def'
name|'fcntl'
op|'('
name|'fd'
op|','
name|'op'
op|','
name|'arg'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'op'
op|'=='
name|'F_GETFD'
name|'or'
name|'op'
op|'=='
name|'F_GETFL'
op|':'
newline|'\n'
indent|'        '
name|'return'
number|'0'
newline|'\n'
dedent|''
name|'elif'
name|'op'
op|'=='
name|'F_SETFD'
op|':'
newline|'\n'
comment|'# Check that the flag is CLOEXEC and translate'
nl|'\n'
indent|'        '
name|'if'
name|'arg'
op|'=='
name|'FD_CLOEXEC'
op|':'
newline|'\n'
indent|'            '
name|'success'
op|'='
name|'SetHandleInformation'
op|'('
name|'fd'
op|','
name|'HANDLE_FLAG_INHERIT'
op|','
name|'arg'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'success'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'ctypes'
op|'.'
name|'GetLastError'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|'"Unsupported arg"'
op|')'
newline|'\n'
comment|'#elif op == F_SETFL:'
nl|'\n'
comment|'## Check that the flag is NONBLOCK and translate'
nl|'\n'
comment|'#if arg == os.O_NONBLOCK:'
nl|'\n'
comment|'##pass'
nl|'\n'
comment|'#result = ioctlsocket(fd, FIONBIO, 1)'
nl|'\n'
comment|'#if result != 0:'
nl|'\n'
comment|'#raise ctypes.GetLastError()'
nl|'\n'
comment|'#else:'
nl|'\n'
comment|'#raise ValueError("Unsupported arg")'
nl|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'ValueError'
op|'('
string|'"Unsupported op"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Pipe
dedent|''
dedent|''
name|'class'
name|'Pipe'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Create an OS independent asynchronous pipe"""'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# Based on Zope async.py: http://svn.zope.org/zc.ngi/trunk/src/zc/ngi/async.py'
nl|'\n'
nl|'\n'
indent|'        '
name|'self'
op|'.'
name|'writer'
op|'='
name|'socket'
op|'.'
name|'socket'
op|'('
op|')'
newline|'\n'
comment|'# Disable buffering -- pulling the trigger sends 1 byte,'
nl|'\n'
comment|'# and we want that sent immediately, to wake up ASAP.'
nl|'\n'
name|'self'
op|'.'
name|'writer'
op|'.'
name|'setsockopt'
op|'('
name|'socket'
op|'.'
name|'IPPROTO_TCP'
op|','
name|'socket'
op|'.'
name|'TCP_NODELAY'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
name|'count'
op|'='
number|'0'
newline|'\n'
name|'while'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'count'
op|'+='
number|'1'
newline|'\n'
comment|'# Bind to a local port; for efficiency, let the OS pick'
nl|'\n'
comment|'# a free port for us.'
nl|'\n'
comment|'# Unfortunately, stress tests showed that we may not'
nl|'\n'
comment|'# be able to connect to that port ("Address already in'
nl|'\n'
comment|'# use") despite that the OS picked it.  This appears'
nl|'\n'
comment|'# to be a race bug in the Windows socket implementation.'
nl|'\n'
comment|'# So we loop until a connect() succeeds (almost always'
nl|'\n'
comment|'# on the first try).  See the long thread at'
nl|'\n'
comment|'# http://mail.zope.org/pipermail/zope/2005-July/160433.html'
nl|'\n'
comment|'# for hideous details.'
nl|'\n'
name|'a'
op|'='
name|'socket'
op|'.'
name|'socket'
op|'('
op|')'
newline|'\n'
name|'a'
op|'.'
name|'bind'
op|'('
op|'('
string|'"127.0.0.1"'
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'connect_address'
op|'='
name|'a'
op|'.'
name|'getsockname'
op|'('
op|')'
comment|'# assigned (host, port) pair'
newline|'\n'
name|'a'
op|'.'
name|'listen'
op|'('
number|'1'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'writer'
op|'.'
name|'connect'
op|'('
name|'connect_address'
op|')'
newline|'\n'
name|'break'
comment|'# success'
newline|'\n'
dedent|''
name|'except'
name|'socket'
op|'.'
name|'error'
op|','
name|'detail'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'detail'
op|'['
number|'0'
op|']'
op|'!='
name|'errno'
op|'.'
name|'WSAEADDRINUSE'
op|':'
newline|'\n'
comment|'# "Address already in use" is the only error'
nl|'\n'
comment|"# I've seen on two WinXP Pro SP2 boxes, under"
nl|'\n'
comment|'# Pythons 2.3.5 and 2.4.1.'
nl|'\n'
indent|'                    '
name|'raise'
newline|'\n'
comment|"# (10048, 'Address already in use')"
nl|'\n'
comment|"# assert count <= 2 # never triggered in Tim's tests"
nl|'\n'
dedent|''
name|'if'
name|'count'
op|'>='
number|'10'
op|':'
comment|"# I've never seen it go above 2"
newline|'\n'
indent|'                    '
name|'a'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'writer'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'raise'
name|'socket'
op|'.'
name|'error'
op|'('
string|'"Cannot bind trigger!"'
op|')'
newline|'\n'
comment|'# Close `a` and try again.  Note:  I originally put a short'
nl|'\n'
comment|"# sleep() here, but it didn't appear to help or hurt."
nl|'\n'
dedent|''
name|'a'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'reader'
op|','
name|'addr'
op|'='
name|'a'
op|'.'
name|'accept'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'reader'
op|'.'
name|'setblocking'
op|'('
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'writer'
op|'.'
name|'setblocking'
op|'('
number|'0'
op|')'
newline|'\n'
name|'a'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'reader_fd'
op|'='
name|'self'
op|'.'
name|'reader'
op|'.'
name|'fileno'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|read
dedent|''
name|'def'
name|'read'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Emulate a file descriptors read method"""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'reader'
op|'.'
name|'recv'
op|'('
number|'1'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'socket'
op|'.'
name|'error'
op|','
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'ex'
op|'.'
name|'args'
op|'['
number|'0'
op|']'
op|'=='
name|'errno'
op|'.'
name|'EWOULDBLOCK'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'IOError'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
nl|'\n'
DECL|member|write
dedent|''
dedent|''
name|'def'
name|'write'
op|'('
name|'self'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Emulate a file descriptors write method"""'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'writer'
op|'.'
name|'send'
op|'('
name|'data'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
