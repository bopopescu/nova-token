begin_unit
nl|'\n'
name|'import'
name|'markdown'
newline|'\n'
nl|'\n'
DECL|class|State
name|'class'
name|'State'
op|'('
name|'list'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Track the current and nested state of the parser. \n    \n    This utility class is used to track the state of the BlockParser and \n    support multiple levels if nesting. It\'s just a simple API wrapped around\n    a list. Each time a state is set, that state is appended to the end of the\n    list. Each time a state is reset, that state is removed from the end of\n    the list.\n\n    Therefore, each time a state is set for a nested block, that state must be \n    reset when we back out of that level of nesting or the state could be\n    corrupted.\n\n    While all the methods of a list object are available, only the three\n    defined below need be used.\n\n    """'
newline|'\n'
nl|'\n'
DECL|member|set
name|'def'
name|'set'
op|'('
name|'self'
op|','
name|'state'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Set a new state. """'
newline|'\n'
name|'self'
op|'.'
name|'append'
op|'('
name|'state'
op|')'
newline|'\n'
nl|'\n'
DECL|member|reset
dedent|''
name|'def'
name|'reset'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Step back one step in nested state. """'
newline|'\n'
name|'self'
op|'.'
name|'pop'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|isstate
dedent|''
name|'def'
name|'isstate'
op|'('
name|'self'
op|','
name|'state'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Test that top (current) level is of given state. """'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'['
op|'-'
number|'1'
op|']'
op|'=='
name|'state'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|class|BlockParser
dedent|''
dedent|''
dedent|''
name|'class'
name|'BlockParser'
op|':'
newline|'\n'
indent|'    '
string|'""" Parse Markdown blocks into an ElementTree object. \n    \n    A wrapper class that stitches the various BlockProcessors together,\n    looping through them and creating an ElementTree object.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'blockprocessors'
op|'='
name|'markdown'
op|'.'
name|'odict'
op|'.'
name|'OrderedDict'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'state'
op|'='
name|'State'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|parseDocument
dedent|''
name|'def'
name|'parseDocument'
op|'('
name|'self'
op|','
name|'lines'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Parse a markdown document into an ElementTree. \n        \n        Given a list of lines, an ElementTree object (not just a parent Element)\n        is created and the root element is passed to the parser as the parent.\n        The ElementTree object is returned.\n        \n        This should only be called on an entire document, not pieces.\n\n        """'
newline|'\n'
comment|'# Create a ElementTree from the lines'
nl|'\n'
name|'self'
op|'.'
name|'root'
op|'='
name|'markdown'
op|'.'
name|'etree'
op|'.'
name|'Element'
op|'('
name|'markdown'
op|'.'
name|'DOC_TAG'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'parseChunk'
op|'('
name|'self'
op|'.'
name|'root'
op|','
string|"'\\n'"
op|'.'
name|'join'
op|'('
name|'lines'
op|')'
op|')'
newline|'\n'
name|'return'
name|'markdown'
op|'.'
name|'etree'
op|'.'
name|'ElementTree'
op|'('
name|'self'
op|'.'
name|'root'
op|')'
newline|'\n'
nl|'\n'
DECL|member|parseChunk
dedent|''
name|'def'
name|'parseChunk'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'text'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Parse a chunk of markdown text and attach to given etree node. \n        \n        While the ``text`` argument is generally assumed to contain multiple\n        blocks which will be split on blank lines, it could contain only one\n        block. Generally, this method would be called by extensions when\n        block parsing is required. \n        \n        The ``parent`` etree Element passed in is altered in place. \n        Nothing is returned.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'parseBlocks'
op|'('
name|'parent'
op|','
name|'text'
op|'.'
name|'split'
op|'('
string|"'\\n\\n'"
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|parseBlocks
dedent|''
name|'def'
name|'parseBlocks'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'blocks'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Process blocks of markdown text and attach to given etree node. \n        \n        Given a list of ``blocks``, each blockprocessor is stepped through\n        until there are no blocks left. While an extension could potentially\n        call this method directly, it\'s generally expected to be used internally.\n\n        This is a public method as an extension may need to add/alter additional\n        BlockProcessors which call this method to recursively parse a nested\n        block.\n\n        """'
newline|'\n'
name|'while'
name|'blocks'
op|':'
newline|'\n'
indent|'           '
name|'for'
name|'processor'
name|'in'
name|'self'
op|'.'
name|'blockprocessors'
op|'.'
name|'values'
op|'('
op|')'
op|':'
newline|'\n'
indent|'               '
name|'if'
name|'processor'
op|'.'
name|'test'
op|'('
name|'parent'
op|','
name|'blocks'
op|'['
number|'0'
op|']'
op|')'
op|':'
newline|'\n'
indent|'                   '
name|'processor'
op|'.'
name|'run'
op|'('
name|'parent'
op|','
name|'blocks'
op|')'
newline|'\n'
name|'break'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
