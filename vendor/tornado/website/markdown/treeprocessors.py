begin_unit
name|'import'
name|'markdown'
newline|'\n'
name|'import'
name|'re'
newline|'\n'
nl|'\n'
DECL|function|isString
name|'def'
name|'isString'
op|'('
name|'s'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Check if it\'s string """'
newline|'\n'
name|'return'
name|'isinstance'
op|'('
name|'s'
op|','
name|'unicode'
op|')'
name|'or'
name|'isinstance'
op|'('
name|'s'
op|','
name|'str'
op|')'
newline|'\n'
nl|'\n'
DECL|class|Processor
dedent|''
name|'class'
name|'Processor'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'markdown_instance'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'markdown_instance'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'markdown'
op|'='
name|'markdown_instance'
newline|'\n'
nl|'\n'
DECL|class|Treeprocessor
dedent|''
dedent|''
dedent|''
name|'class'
name|'Treeprocessor'
op|'('
name|'Processor'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Treeprocessors are run on the ElementTree object before serialization.\n\n    Each Treeprocessor implements a "run" method that takes a pointer to an\n    ElementTree, modifies it as necessary and returns an ElementTree\n    object.\n\n    Treeprocessors must extend markdown.Treeprocessor.\n\n    """'
newline|'\n'
DECL|member|run
name|'def'
name|'run'
op|'('
name|'self'
op|','
name|'root'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Subclasses of Treeprocessor should implement a `run` method, which\n        takes a root ElementTree. This method can return another ElementTree \n        object, and the existing root ElementTree will be replaced, or it can \n        modify the current tree and return None.\n        """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|InlineProcessor
dedent|''
dedent|''
name|'class'
name|'InlineProcessor'
op|'('
name|'Treeprocessor'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A Treeprocessor that traverses a tree, applying inline patterns.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'md'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'__placeholder_prefix'
op|'='
name|'markdown'
op|'.'
name|'INLINE_PLACEHOLDER_PREFIX'
newline|'\n'
name|'self'
op|'.'
name|'__placeholder_suffix'
op|'='
name|'markdown'
op|'.'
name|'ETX'
newline|'\n'
name|'self'
op|'.'
name|'__placeholder_length'
op|'='
number|'4'
op|'+'
name|'len'
op|'('
name|'self'
op|'.'
name|'__placeholder_prefix'
op|')'
op|'+'
name|'len'
op|'('
name|'self'
op|'.'
name|'__placeholder_suffix'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'__placeholder_re'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
name|'markdown'
op|'.'
name|'INLINE_PLACEHOLDER'
op|'%'
string|"r'([0-9]{4})'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'markdown'
op|'='
name|'md'
newline|'\n'
nl|'\n'
DECL|member|__makePlaceholder
dedent|''
name|'def'
name|'__makePlaceholder'
op|'('
name|'self'
op|','
name|'type'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Generate a placeholder """'
newline|'\n'
name|'id'
op|'='
string|'"%04d"'
op|'%'
name|'len'
op|'('
name|'self'
op|'.'
name|'stashed_nodes'
op|')'
newline|'\n'
name|'hash'
op|'='
name|'markdown'
op|'.'
name|'INLINE_PLACEHOLDER'
op|'%'
name|'id'
newline|'\n'
name|'return'
name|'hash'
op|','
name|'id'
newline|'\n'
nl|'\n'
DECL|member|__findPlaceholder
dedent|''
name|'def'
name|'__findPlaceholder'
op|'('
name|'self'
op|','
name|'data'
op|','
name|'index'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Extract id from data string, start from index\n\n        Keyword arguments:\n\n        * data: string\n        * index: index, from which we start search\n\n        Returns: placeholder id and string index, after the found placeholder.\n        """'
newline|'\n'
nl|'\n'
name|'m'
op|'='
name|'self'
op|'.'
name|'__placeholder_re'
op|'.'
name|'search'
op|'('
name|'data'
op|','
name|'index'
op|')'
newline|'\n'
name|'if'
name|'m'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'m'
op|'.'
name|'group'
op|'('
number|'1'
op|')'
op|','
name|'m'
op|'.'
name|'end'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
op|','
name|'index'
op|'+'
number|'1'
newline|'\n'
nl|'\n'
DECL|member|__stashNode
dedent|''
dedent|''
name|'def'
name|'__stashNode'
op|'('
name|'self'
op|','
name|'node'
op|','
name|'type'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Add node to stash """'
newline|'\n'
name|'placeholder'
op|','
name|'id'
op|'='
name|'self'
op|'.'
name|'__makePlaceholder'
op|'('
name|'type'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'stashed_nodes'
op|'['
name|'id'
op|']'
op|'='
name|'node'
newline|'\n'
name|'return'
name|'placeholder'
newline|'\n'
nl|'\n'
DECL|member|__handleInline
dedent|''
name|'def'
name|'__handleInline'
op|'('
name|'self'
op|','
name|'data'
op|','
name|'patternIndex'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Process string with inline patterns and replace it\n        with placeholders\n\n        Keyword arguments:\n\n        * data: A line of Markdown text\n        * patternIndex: The index of the inlinePattern to start with\n\n        Returns: String with placeholders.\n\n        """'
newline|'\n'
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'data'
op|','
name|'markdown'
op|'.'
name|'AtomicString'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'startIndex'
op|'='
number|'0'
newline|'\n'
name|'while'
name|'patternIndex'
op|'<'
name|'len'
op|'('
name|'self'
op|'.'
name|'markdown'
op|'.'
name|'inlinePatterns'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'data'
op|','
name|'matched'
op|','
name|'startIndex'
op|'='
name|'self'
op|'.'
name|'__applyPattern'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'markdown'
op|'.'
name|'inlinePatterns'
op|'.'
name|'value_for_index'
op|'('
name|'patternIndex'
op|')'
op|','
nl|'\n'
name|'data'
op|','
name|'patternIndex'
op|','
name|'startIndex'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'matched'
op|':'
newline|'\n'
indent|'                    '
name|'patternIndex'
op|'+='
number|'1'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'data'
newline|'\n'
nl|'\n'
DECL|member|__processElementText
dedent|''
name|'def'
name|'__processElementText'
op|'('
name|'self'
op|','
name|'node'
op|','
name|'subnode'
op|','
name|'isText'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Process placeholders in Element.text or Element.tail\n        of Elements popped from self.stashed_nodes.\n\n        Keywords arguments:\n\n        * node: parent node\n        * subnode: processing node\n        * isText: bool variable, True - it\'s text, False - it\'s tail\n\n        Returns: None\n\n        """'
newline|'\n'
name|'if'
name|'isText'
op|':'
newline|'\n'
indent|'            '
name|'text'
op|'='
name|'subnode'
op|'.'
name|'text'
newline|'\n'
name|'subnode'
op|'.'
name|'text'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'text'
op|'='
name|'subnode'
op|'.'
name|'tail'
newline|'\n'
name|'subnode'
op|'.'
name|'tail'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'childResult'
op|'='
name|'self'
op|'.'
name|'__processPlaceholders'
op|'('
name|'text'
op|','
name|'subnode'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'isText'
name|'and'
name|'node'
name|'is'
name|'not'
name|'subnode'
op|':'
newline|'\n'
indent|'            '
name|'pos'
op|'='
name|'node'
op|'.'
name|'getchildren'
op|'('
op|')'
op|'.'
name|'index'
op|'('
name|'subnode'
op|')'
newline|'\n'
name|'node'
op|'.'
name|'remove'
op|'('
name|'subnode'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'pos'
op|'='
number|'0'
newline|'\n'
nl|'\n'
dedent|''
name|'childResult'
op|'.'
name|'reverse'
op|'('
op|')'
newline|'\n'
name|'for'
name|'newChild'
name|'in'
name|'childResult'
op|':'
newline|'\n'
indent|'            '
name|'node'
op|'.'
name|'insert'
op|'('
name|'pos'
op|','
name|'newChild'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__processPlaceholders
dedent|''
dedent|''
name|'def'
name|'__processPlaceholders'
op|'('
name|'self'
op|','
name|'data'
op|','
name|'parent'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Process string with placeholders and generate ElementTree tree.\n\n        Keyword arguments:\n\n        * data: string with placeholders instead of ElementTree elements.\n        * parent: Element, which contains processing inline data\n\n        Returns: list with ElementTree elements with applied inline patterns.\n        """'
newline|'\n'
DECL|function|linkText
name|'def'
name|'linkText'
op|'('
name|'text'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'text'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'result'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'result'
op|'['
op|'-'
number|'1'
op|']'
op|'.'
name|'tail'
op|':'
newline|'\n'
indent|'                        '
name|'result'
op|'['
op|'-'
number|'1'
op|']'
op|'.'
name|'tail'
op|'+='
name|'text'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'result'
op|'['
op|'-'
number|'1'
op|']'
op|'.'
name|'tail'
op|'='
name|'text'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'parent'
op|'.'
name|'text'
op|':'
newline|'\n'
indent|'                        '
name|'parent'
op|'.'
name|'text'
op|'+='
name|'text'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'parent'
op|'.'
name|'text'
op|'='
name|'text'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'result'
op|'='
op|'['
op|']'
newline|'\n'
name|'strartIndex'
op|'='
number|'0'
newline|'\n'
name|'while'
name|'data'
op|':'
newline|'\n'
indent|'            '
name|'index'
op|'='
name|'data'
op|'.'
name|'find'
op|'('
name|'self'
op|'.'
name|'__placeholder_prefix'
op|','
name|'strartIndex'
op|')'
newline|'\n'
name|'if'
name|'index'
op|'!='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'id'
op|','
name|'phEndIndex'
op|'='
name|'self'
op|'.'
name|'__findPlaceholder'
op|'('
name|'data'
op|','
name|'index'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'id'
name|'in'
name|'self'
op|'.'
name|'stashed_nodes'
op|':'
newline|'\n'
indent|'                    '
name|'node'
op|'='
name|'self'
op|'.'
name|'stashed_nodes'
op|'.'
name|'get'
op|'('
name|'id'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'index'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                        '
name|'text'
op|'='
name|'data'
op|'['
name|'strartIndex'
op|':'
name|'index'
op|']'
newline|'\n'
name|'linkText'
op|'('
name|'text'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'isString'
op|'('
name|'node'
op|')'
op|':'
comment|"# it's Element"
newline|'\n'
indent|'                        '
name|'for'
name|'child'
name|'in'
op|'['
name|'node'
op|']'
op|'+'
name|'node'
op|'.'
name|'getchildren'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                            '
name|'if'
name|'child'
op|'.'
name|'tail'
op|':'
newline|'\n'
indent|'                                '
name|'if'
name|'child'
op|'.'
name|'tail'
op|'.'
name|'strip'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                                    '
name|'self'
op|'.'
name|'__processElementText'
op|'('
name|'node'
op|','
name|'child'
op|','
name|'False'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'child'
op|'.'
name|'text'
op|':'
newline|'\n'
indent|'                                '
name|'if'
name|'child'
op|'.'
name|'text'
op|'.'
name|'strip'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                                    '
name|'self'
op|'.'
name|'__processElementText'
op|'('
name|'child'
op|','
name|'child'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'else'
op|':'
comment|"# it's just a string"
newline|'\n'
indent|'                        '
name|'linkText'
op|'('
name|'node'
op|')'
newline|'\n'
name|'strartIndex'
op|'='
name|'phEndIndex'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'strartIndex'
op|'='
name|'phEndIndex'
newline|'\n'
name|'result'
op|'.'
name|'append'
op|'('
name|'node'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'else'
op|':'
comment|'# wrong placeholder'
newline|'\n'
indent|'                    '
name|'end'
op|'='
name|'index'
op|'+'
name|'len'
op|'('
name|'prefix'
op|')'
newline|'\n'
name|'linkText'
op|'('
name|'data'
op|'['
name|'strartIndex'
op|':'
name|'end'
op|']'
op|')'
newline|'\n'
name|'strartIndex'
op|'='
name|'end'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'text'
op|'='
name|'data'
op|'['
name|'strartIndex'
op|':'
op|']'
newline|'\n'
name|'linkText'
op|'('
name|'text'
op|')'
newline|'\n'
name|'data'
op|'='
string|'""'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
DECL|member|__applyPattern
dedent|''
name|'def'
name|'__applyPattern'
op|'('
name|'self'
op|','
name|'pattern'
op|','
name|'data'
op|','
name|'patternIndex'
op|','
name|'startIndex'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check if the line fits the pattern, create the necessary\n        elements, add it to stashed_nodes.\n\n        Keyword arguments:\n\n        * data: the text to be processed\n        * pattern: the pattern to be checked\n        * patternIndex: index of current pattern\n        * startIndex: string index, from which we starting search\n\n        Returns: String with placeholders instead of ElementTree elements.\n\n        """'
newline|'\n'
name|'match'
op|'='
name|'pattern'
op|'.'
name|'getCompiledRegExp'
op|'('
op|')'
op|'.'
name|'match'
op|'('
name|'data'
op|'['
name|'startIndex'
op|':'
op|']'
op|')'
newline|'\n'
name|'leftData'
op|'='
name|'data'
op|'['
op|':'
name|'startIndex'
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'match'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'data'
op|','
name|'False'
op|','
number|'0'
newline|'\n'
nl|'\n'
dedent|''
name|'node'
op|'='
name|'pattern'
op|'.'
name|'handleMatch'
op|'('
name|'match'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'node'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'data'
op|','
name|'True'
op|','
name|'len'
op|'('
name|'leftData'
op|')'
op|'+'
name|'match'
op|'.'
name|'span'
op|'('
name|'len'
op|'('
name|'match'
op|'.'
name|'groups'
op|'('
op|')'
op|')'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'isString'
op|'('
name|'node'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'node'
op|'.'
name|'text'
op|','
name|'markdown'
op|'.'
name|'AtomicString'
op|')'
op|':'
newline|'\n'
comment|'# We need to process current node too'
nl|'\n'
indent|'                '
name|'for'
name|'child'
name|'in'
op|'['
name|'node'
op|']'
op|'+'
name|'node'
op|'.'
name|'getchildren'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'not'
name|'isString'
op|'('
name|'node'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'child'
op|'.'
name|'text'
op|':'
newline|'\n'
indent|'                            '
name|'child'
op|'.'
name|'text'
op|'='
name|'self'
op|'.'
name|'__handleInline'
op|'('
name|'child'
op|'.'
name|'text'
op|','
nl|'\n'
name|'patternIndex'
op|'+'
number|'1'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'child'
op|'.'
name|'tail'
op|':'
newline|'\n'
indent|'                            '
name|'child'
op|'.'
name|'tail'
op|'='
name|'self'
op|'.'
name|'__handleInline'
op|'('
name|'child'
op|'.'
name|'tail'
op|','
nl|'\n'
name|'patternIndex'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'placeholder'
op|'='
name|'self'
op|'.'
name|'__stashNode'
op|'('
name|'node'
op|','
name|'pattern'
op|'.'
name|'type'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'return'
string|'"%s%s%s%s"'
op|'%'
op|'('
name|'leftData'
op|','
nl|'\n'
name|'match'
op|'.'
name|'group'
op|'('
number|'1'
op|')'
op|','
nl|'\n'
name|'placeholder'
op|','
name|'match'
op|'.'
name|'groups'
op|'('
op|')'
op|'['
op|'-'
number|'1'
op|']'
op|')'
op|','
name|'True'
op|','
number|'0'
newline|'\n'
nl|'\n'
DECL|member|run
dedent|''
name|'def'
name|'run'
op|'('
name|'self'
op|','
name|'tree'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Apply inline patterns to a parsed Markdown tree.\n\n        Iterate over ElementTree, find elements with inline tag, apply inline\n        patterns and append newly created Elements to tree.  If you don\'t\n        want process your data with inline paterns, instead of normal string,\n        use subclass AtomicString:\n\n            node.text = markdown.AtomicString("data won\'t be processed with inline patterns")\n\n        Arguments:\n\n        * markdownTree: ElementTree object, representing Markdown tree.\n\n        Returns: ElementTree object with applied inline patterns.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'stashed_nodes'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
name|'stack'
op|'='
op|'['
name|'tree'
op|']'
newline|'\n'
nl|'\n'
name|'while'
name|'stack'
op|':'
newline|'\n'
indent|'            '
name|'currElement'
op|'='
name|'stack'
op|'.'
name|'pop'
op|'('
op|')'
newline|'\n'
name|'insertQueue'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'child'
name|'in'
name|'currElement'
op|'.'
name|'getchildren'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'child'
op|'.'
name|'text'
name|'and'
name|'not'
name|'isinstance'
op|'('
name|'child'
op|'.'
name|'text'
op|','
name|'markdown'
op|'.'
name|'AtomicString'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'text'
op|'='
name|'child'
op|'.'
name|'text'
newline|'\n'
name|'child'
op|'.'
name|'text'
op|'='
name|'None'
newline|'\n'
name|'lst'
op|'='
name|'self'
op|'.'
name|'__processPlaceholders'
op|'('
name|'self'
op|'.'
name|'__handleInline'
op|'('
nl|'\n'
name|'text'
op|')'
op|','
name|'child'
op|')'
newline|'\n'
name|'stack'
op|'+='
name|'lst'
newline|'\n'
name|'insertQueue'
op|'.'
name|'append'
op|'('
op|'('
name|'child'
op|','
name|'lst'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'child'
op|'.'
name|'getchildren'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'stack'
op|'.'
name|'append'
op|'('
name|'child'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'for'
name|'element'
op|','
name|'lst'
name|'in'
name|'insertQueue'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'element'
op|'.'
name|'text'
op|':'
newline|'\n'
indent|'                    '
name|'element'
op|'.'
name|'text'
op|'='
name|'markdown'
op|'.'
name|'inlinepatterns'
op|'.'
name|'handleAttributes'
op|'('
name|'element'
op|'.'
name|'text'
op|','
nl|'\n'
name|'element'
op|')'
newline|'\n'
dedent|''
name|'i'
op|'='
number|'0'
newline|'\n'
name|'for'
name|'newChild'
name|'in'
name|'lst'
op|':'
newline|'\n'
comment|'# Processing attributes'
nl|'\n'
indent|'                    '
name|'if'
name|'newChild'
op|'.'
name|'tail'
op|':'
newline|'\n'
indent|'                        '
name|'newChild'
op|'.'
name|'tail'
op|'='
name|'markdown'
op|'.'
name|'inlinepatterns'
op|'.'
name|'handleAttributes'
op|'('
name|'newChild'
op|'.'
name|'tail'
op|','
nl|'\n'
name|'element'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'newChild'
op|'.'
name|'text'
op|':'
newline|'\n'
indent|'                        '
name|'newChild'
op|'.'
name|'text'
op|'='
name|'markdown'
op|'.'
name|'inlinepatterns'
op|'.'
name|'handleAttributes'
op|'('
name|'newChild'
op|'.'
name|'text'
op|','
nl|'\n'
name|'newChild'
op|')'
newline|'\n'
dedent|''
name|'element'
op|'.'
name|'insert'
op|'('
name|'i'
op|','
name|'newChild'
op|')'
newline|'\n'
name|'i'
op|'+='
number|'1'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'tree'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|PrettifyTreeprocessor
dedent|''
dedent|''
name|'class'
name|'PrettifyTreeprocessor'
op|'('
name|'Treeprocessor'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Add linebreaks to the html document. """'
newline|'\n'
nl|'\n'
DECL|member|_prettifyETree
name|'def'
name|'_prettifyETree'
op|'('
name|'self'
op|','
name|'elem'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Recursively add linebreaks to ElementTree children. """'
newline|'\n'
nl|'\n'
name|'i'
op|'='
string|'"\\n"'
newline|'\n'
name|'if'
name|'markdown'
op|'.'
name|'isBlockLevel'
op|'('
name|'elem'
op|'.'
name|'tag'
op|')'
name|'and'
name|'elem'
op|'.'
name|'tag'
name|'not'
name|'in'
op|'['
string|"'code'"
op|','
string|"'pre'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
name|'not'
name|'elem'
op|'.'
name|'text'
name|'or'
name|'not'
name|'elem'
op|'.'
name|'text'
op|'.'
name|'strip'
op|'('
op|')'
op|')'
name|'and'
name|'len'
op|'('
name|'elem'
op|')'
name|'and'
name|'markdown'
op|'.'
name|'isBlockLevel'
op|'('
name|'elem'
op|'['
number|'0'
op|']'
op|'.'
name|'tag'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'elem'
op|'.'
name|'text'
op|'='
name|'i'
newline|'\n'
dedent|''
name|'for'
name|'e'
name|'in'
name|'elem'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'markdown'
op|'.'
name|'isBlockLevel'
op|'('
name|'e'
op|'.'
name|'tag'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_prettifyETree'
op|'('
name|'e'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'elem'
op|'.'
name|'tail'
name|'or'
name|'not'
name|'elem'
op|'.'
name|'tail'
op|'.'
name|'strip'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'elem'
op|'.'
name|'tail'
op|'='
name|'i'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'elem'
op|'.'
name|'tail'
name|'or'
name|'not'
name|'elem'
op|'.'
name|'tail'
op|'.'
name|'strip'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'elem'
op|'.'
name|'tail'
op|'='
name|'i'
newline|'\n'
nl|'\n'
DECL|member|run
dedent|''
dedent|''
name|'def'
name|'run'
op|'('
name|'self'
op|','
name|'root'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Add linebreaks to ElementTree root object. """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_prettifyETree'
op|'('
name|'root'
op|')'
newline|'\n'
comment|"# Do <br />'s seperately as they are often in the middle of"
nl|'\n'
comment|'# inline content and missed by _prettifyETree.'
nl|'\n'
name|'brs'
op|'='
name|'root'
op|'.'
name|'getiterator'
op|'('
string|"'br'"
op|')'
newline|'\n'
name|'for'
name|'br'
name|'in'
name|'brs'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'br'
op|'.'
name|'tail'
name|'or'
name|'not'
name|'br'
op|'.'
name|'tail'
op|'.'
name|'strip'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'br'
op|'.'
name|'tail'
op|'='
string|"'\\n'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'br'
op|'.'
name|'tail'
op|'='
string|"'\\n%s'"
op|'%'
name|'br'
op|'.'
name|'tail'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
