begin_unit
string|'"""\nCORE MARKDOWN BLOCKPARSER\n=============================================================================\n\nThis parser handles basic parsing of Markdown blocks.  It doesn\'t concern itself\nwith inline elements such as **bold** or *italics*, but rather just catches \nblocks, lists, quotes, etc.\n\nThe BlockParser is made up of a bunch of BlockProssors, each handling a \ndifferent type of block. Extensions may add/replace/remove BlockProcessors\nas they need to alter how markdown blocks are parsed.\n\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'re'
newline|'\n'
name|'import'
name|'markdown'
newline|'\n'
nl|'\n'
DECL|class|BlockProcessor
name|'class'
name|'BlockProcessor'
op|':'
newline|'\n'
indent|'    '
string|'""" Base class for block processors. \n    \n    Each subclass will provide the methods below to work with the source and\n    tree. Each processor will need to define it\'s own ``test`` and ``run``\n    methods. The ``test`` method should return True or False, to indicate\n    whether the current block should be processed by this processor. If the\n    test passes, the parser will call the processors ``run`` method.\n\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'parser'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'parser'
op|'='
name|'parser'
newline|'\n'
nl|'\n'
DECL|member|lastChild
dedent|''
name|'def'
name|'lastChild'
op|'('
name|'self'
op|','
name|'parent'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Return the last child of an etree element. """'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'parent'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'parent'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
DECL|member|detab
dedent|''
dedent|''
name|'def'
name|'detab'
op|'('
name|'self'
op|','
name|'text'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Remove a tab from the front of each line of the given text. """'
newline|'\n'
name|'newtext'
op|'='
op|'['
op|']'
newline|'\n'
name|'lines'
op|'='
name|'text'
op|'.'
name|'split'
op|'('
string|"'\\n'"
op|')'
newline|'\n'
name|'for'
name|'line'
name|'in'
name|'lines'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'line'
op|'.'
name|'startswith'
op|'('
string|"' '"
op|'*'
name|'markdown'
op|'.'
name|'TAB_LENGTH'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'newtext'
op|'.'
name|'append'
op|'('
name|'line'
op|'['
name|'markdown'
op|'.'
name|'TAB_LENGTH'
op|':'
op|']'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'not'
name|'line'
op|'.'
name|'strip'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'newtext'
op|'.'
name|'append'
op|'('
string|"''"
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'return'
string|"'\\n'"
op|'.'
name|'join'
op|'('
name|'newtext'
op|')'
op|','
string|"'\\n'"
op|'.'
name|'join'
op|'('
name|'lines'
op|'['
name|'len'
op|'('
name|'newtext'
op|')'
op|':'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|looseDetab
dedent|''
name|'def'
name|'looseDetab'
op|'('
name|'self'
op|','
name|'text'
op|','
name|'level'
op|'='
number|'1'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Remove a tab from front of lines but allowing dedented lines. """'
newline|'\n'
name|'lines'
op|'='
name|'text'
op|'.'
name|'split'
op|'('
string|"'\\n'"
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'len'
op|'('
name|'lines'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'lines'
op|'['
name|'i'
op|']'
op|'.'
name|'startswith'
op|'('
string|"' '"
op|'*'
name|'markdown'
op|'.'
name|'TAB_LENGTH'
op|'*'
name|'level'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'lines'
op|'['
name|'i'
op|']'
op|'='
name|'lines'
op|'['
name|'i'
op|']'
op|'['
name|'markdown'
op|'.'
name|'TAB_LENGTH'
op|'*'
name|'level'
op|':'
op|']'
newline|'\n'
dedent|''
dedent|''
name|'return'
string|"'\\n'"
op|'.'
name|'join'
op|'('
name|'lines'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test
dedent|''
name|'def'
name|'test'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'block'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Test for block type. Must be overridden by subclasses. \n        \n        As the parser loops through processors, it will call the ``test`` method\n        on each to determine if the given block of text is of that type. This\n        method must return a boolean ``True`` or ``False``. The actual method of\n        testing is left to the needs of that particular block type. It could \n        be as simple as ``block.startswith(some_string)`` or a complex regular\n        expression. As the block type may be different depending on the parent\n        of the block (i.e. inside a list), the parent etree element is also \n        provided and may be used as part of the test.\n\n        Keywords:\n        \n        * ``parent``: A etree element which will be the parent of the block.\n        * ``block``: A block of text from the source which has been split at \n            blank lines.\n        """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|run
dedent|''
name|'def'
name|'run'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'blocks'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Run processor. Must be overridden by subclasses. \n        \n        When the parser determines the appropriate type of a block, the parser\n        will call the corresponding processor\'s ``run`` method. This method\n        should parse the individual lines of the block and append them to\n        the etree. \n\n        Note that both the ``parent`` and ``etree`` keywords are pointers\n        to instances of the objects which should be edited in place. Each\n        processor must make changes to the existing objects as there is no\n        mechanism to return new/different objects to replace them.\n\n        This means that this method should be adding SubElements or adding text\n        to the parent, and should remove (``pop``) or add (``insert``) items to\n        the list of blocks.\n\n        Keywords:\n\n        * ``parent``: A etree element which is the parent of the current block.\n        * ``blocks``: A list of all remaining blocks of the document.\n        """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ListIndentProcessor
dedent|''
dedent|''
name|'class'
name|'ListIndentProcessor'
op|'('
name|'BlockProcessor'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Process children of list items. \n    \n    Example:\n        * a list item\n            process this part\n\n            or this part\n\n    """'
newline|'\n'
nl|'\n'
DECL|variable|INDENT_RE
name|'INDENT_RE'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'^(([ ]{%s})+)'"
op|'%'
name|'markdown'
op|'.'
name|'TAB_LENGTH'
op|')'
newline|'\n'
DECL|variable|ITEM_TYPES
name|'ITEM_TYPES'
op|'='
op|'['
string|"'li'"
op|']'
newline|'\n'
DECL|variable|LIST_TYPES
name|'LIST_TYPES'
op|'='
op|'['
string|"'ul'"
op|','
string|"'ol'"
op|']'
newline|'\n'
nl|'\n'
DECL|member|test
name|'def'
name|'test'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'block'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'block'
op|'.'
name|'startswith'
op|'('
string|"' '"
op|'*'
name|'markdown'
op|'.'
name|'TAB_LENGTH'
op|')'
name|'and'
name|'not'
name|'self'
op|'.'
name|'parser'
op|'.'
name|'state'
op|'.'
name|'isstate'
op|'('
string|"'detabbed'"
op|')'
name|'and'
op|'('
name|'parent'
op|'.'
name|'tag'
name|'in'
name|'self'
op|'.'
name|'ITEM_TYPES'
name|'or'
op|'('
name|'len'
op|'('
name|'parent'
op|')'
name|'and'
name|'parent'
op|'['
op|'-'
number|'1'
op|']'
name|'and'
op|'('
name|'parent'
op|'['
op|'-'
number|'1'
op|']'
op|'.'
name|'tag'
name|'in'
name|'self'
op|'.'
name|'LIST_TYPES'
op|')'
nl|'\n'
op|')'
nl|'\n'
op|')'
newline|'\n'
nl|'\n'
DECL|member|run
dedent|''
name|'def'
name|'run'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'blocks'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'block'
op|'='
name|'blocks'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
newline|'\n'
name|'level'
op|','
name|'sibling'
op|'='
name|'self'
op|'.'
name|'get_level'
op|'('
name|'parent'
op|','
name|'block'
op|')'
newline|'\n'
name|'block'
op|'='
name|'self'
op|'.'
name|'looseDetab'
op|'('
name|'block'
op|','
name|'level'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'parser'
op|'.'
name|'state'
op|'.'
name|'set'
op|'('
string|"'detabbed'"
op|')'
newline|'\n'
name|'if'
name|'parent'
op|'.'
name|'tag'
name|'in'
name|'self'
op|'.'
name|'ITEM_TYPES'
op|':'
newline|'\n'
comment|'# The parent is already a li. Just parse the child block.'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'parser'
op|'.'
name|'parseBlocks'
op|'('
name|'parent'
op|','
op|'['
name|'block'
op|']'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'sibling'
op|'.'
name|'tag'
name|'in'
name|'self'
op|'.'
name|'ITEM_TYPES'
op|':'
newline|'\n'
comment|'# The sibling is a li. Use it as parent.'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'parser'
op|'.'
name|'parseBlocks'
op|'('
name|'sibling'
op|','
op|'['
name|'block'
op|']'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'len'
op|'('
name|'sibling'
op|')'
name|'and'
name|'sibling'
op|'['
op|'-'
number|'1'
op|']'
op|'.'
name|'tag'
name|'in'
name|'self'
op|'.'
name|'ITEM_TYPES'
op|':'
newline|'\n'
comment|'# The parent is a list (``ol`` or ``ul``) which has children.'
nl|'\n'
comment|'# Assume the last child li is the parent of this block.'
nl|'\n'
indent|'            '
name|'if'
name|'sibling'
op|'['
op|'-'
number|'1'
op|']'
op|'.'
name|'text'
op|':'
newline|'\n'
comment|'# If the parent li has text, that text needs to be moved to a p'
nl|'\n'
indent|'                '
name|'block'
op|'='
string|"'%s\\n\\n%s'"
op|'%'
op|'('
name|'sibling'
op|'['
op|'-'
number|'1'
op|']'
op|'.'
name|'text'
op|','
name|'block'
op|')'
newline|'\n'
name|'sibling'
op|'['
op|'-'
number|'1'
op|']'
op|'.'
name|'text'
op|'='
string|"''"
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'parser'
op|'.'
name|'parseChunk'
op|'('
name|'sibling'
op|'['
op|'-'
number|'1'
op|']'
op|','
name|'block'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'create_item'
op|'('
name|'sibling'
op|','
name|'block'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'parser'
op|'.'
name|'state'
op|'.'
name|'reset'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|create_item
dedent|''
name|'def'
name|'create_item'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'block'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Create a new li and parse the block with it as the parent. """'
newline|'\n'
name|'li'
op|'='
name|'markdown'
op|'.'
name|'etree'
op|'.'
name|'SubElement'
op|'('
name|'parent'
op|','
string|"'li'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'parser'
op|'.'
name|'parseBlocks'
op|'('
name|'li'
op|','
op|'['
name|'block'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_level
dedent|''
name|'def'
name|'get_level'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'block'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Get level of indent based on list level. """'
newline|'\n'
comment|'# Get indent level'
nl|'\n'
name|'m'
op|'='
name|'self'
op|'.'
name|'INDENT_RE'
op|'.'
name|'match'
op|'('
name|'block'
op|')'
newline|'\n'
name|'if'
name|'m'
op|':'
newline|'\n'
indent|'            '
name|'indent_level'
op|'='
name|'len'
op|'('
name|'m'
op|'.'
name|'group'
op|'('
number|'1'
op|')'
op|')'
op|'/'
name|'markdown'
op|'.'
name|'TAB_LENGTH'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'indent_level'
op|'='
number|'0'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'parser'
op|'.'
name|'state'
op|'.'
name|'isstate'
op|'('
string|"'list'"
op|')'
op|':'
newline|'\n'
comment|"# We're in a tightlist - so we already are at correct parent."
nl|'\n'
indent|'            '
name|'level'
op|'='
number|'1'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|"# We're in a looselist - so we need to find parent."
nl|'\n'
indent|'            '
name|'level'
op|'='
number|'0'
newline|'\n'
comment|'# Step through children of tree to find matching indent level.'
nl|'\n'
dedent|''
name|'while'
name|'indent_level'
op|'>'
name|'level'
op|':'
newline|'\n'
indent|'            '
name|'child'
op|'='
name|'self'
op|'.'
name|'lastChild'
op|'('
name|'parent'
op|')'
newline|'\n'
name|'if'
name|'child'
name|'and'
op|'('
name|'child'
op|'.'
name|'tag'
name|'in'
name|'self'
op|'.'
name|'LIST_TYPES'
name|'or'
name|'child'
op|'.'
name|'tag'
name|'in'
name|'self'
op|'.'
name|'ITEM_TYPES'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'child'
op|'.'
name|'tag'
name|'in'
name|'self'
op|'.'
name|'LIST_TYPES'
op|':'
newline|'\n'
indent|'                    '
name|'level'
op|'+='
number|'1'
newline|'\n'
dedent|''
name|'parent'
op|'='
name|'child'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|"# No more child levels. If we're short of indent_level,"
nl|'\n'
comment|'# we have a code block. So we stop here.'
nl|'\n'
indent|'                '
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'level'
op|','
name|'parent'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|CodeBlockProcessor
dedent|''
dedent|''
name|'class'
name|'CodeBlockProcessor'
op|'('
name|'BlockProcessor'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Process code blocks. """'
newline|'\n'
nl|'\n'
DECL|member|test
name|'def'
name|'test'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'block'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'block'
op|'.'
name|'startswith'
op|'('
string|"' '"
op|'*'
name|'markdown'
op|'.'
name|'TAB_LENGTH'
op|')'
newline|'\n'
nl|'\n'
DECL|member|run
dedent|''
name|'def'
name|'run'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'blocks'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'sibling'
op|'='
name|'self'
op|'.'
name|'lastChild'
op|'('
name|'parent'
op|')'
newline|'\n'
name|'block'
op|'='
name|'blocks'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
newline|'\n'
name|'theRest'
op|'='
string|"''"
newline|'\n'
name|'if'
name|'sibling'
name|'and'
name|'sibling'
op|'.'
name|'tag'
op|'=='
string|'"pre"'
name|'and'
name|'len'
op|'('
name|'sibling'
op|')'
name|'and'
name|'sibling'
op|'['
number|'0'
op|']'
op|'.'
name|'tag'
op|'=='
string|'"code"'
op|':'
newline|'\n'
comment|'# The previous block was a code block. As blank lines do not start'
nl|'\n'
comment|'# new code blocks, append this block to the previous, adding back'
nl|'\n'
comment|'# linebreaks removed from the split into a list.'
nl|'\n'
indent|'            '
name|'code'
op|'='
name|'sibling'
op|'['
number|'0'
op|']'
newline|'\n'
name|'block'
op|','
name|'theRest'
op|'='
name|'self'
op|'.'
name|'detab'
op|'('
name|'block'
op|')'
newline|'\n'
name|'code'
op|'.'
name|'text'
op|'='
name|'markdown'
op|'.'
name|'AtomicString'
op|'('
string|"'%s\\n%s\\n'"
op|'%'
op|'('
name|'code'
op|'.'
name|'text'
op|','
name|'block'
op|'.'
name|'rstrip'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# This is a new codeblock. Create the elements and insert text.'
nl|'\n'
indent|'            '
name|'pre'
op|'='
name|'markdown'
op|'.'
name|'etree'
op|'.'
name|'SubElement'
op|'('
name|'parent'
op|','
string|"'pre'"
op|')'
newline|'\n'
name|'code'
op|'='
name|'markdown'
op|'.'
name|'etree'
op|'.'
name|'SubElement'
op|'('
name|'pre'
op|','
string|"'code'"
op|')'
newline|'\n'
name|'block'
op|','
name|'theRest'
op|'='
name|'self'
op|'.'
name|'detab'
op|'('
name|'block'
op|')'
newline|'\n'
name|'code'
op|'.'
name|'text'
op|'='
name|'markdown'
op|'.'
name|'AtomicString'
op|'('
string|"'%s\\n'"
op|'%'
name|'block'
op|'.'
name|'rstrip'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'theRest'
op|':'
newline|'\n'
comment|'# This block contained unindented line(s) after the first indented '
nl|'\n'
comment|'# line. Insert these lines as the first block of the master blocks'
nl|'\n'
comment|'# list for future processing.'
nl|'\n'
indent|'            '
name|'blocks'
op|'.'
name|'insert'
op|'('
number|'0'
op|','
name|'theRest'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|BlockQuoteProcessor
dedent|''
dedent|''
dedent|''
name|'class'
name|'BlockQuoteProcessor'
op|'('
name|'BlockProcessor'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|RE
indent|'    '
name|'RE'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'(^|\\n)[ ]{0,3}>[ ]?(.*)'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|test
name|'def'
name|'test'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'block'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'bool'
op|'('
name|'self'
op|'.'
name|'RE'
op|'.'
name|'search'
op|'('
name|'block'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|run
dedent|''
name|'def'
name|'run'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'blocks'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'block'
op|'='
name|'blocks'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
newline|'\n'
name|'m'
op|'='
name|'self'
op|'.'
name|'RE'
op|'.'
name|'search'
op|'('
name|'block'
op|')'
newline|'\n'
name|'if'
name|'m'
op|':'
newline|'\n'
indent|'            '
name|'before'
op|'='
name|'block'
op|'['
op|':'
name|'m'
op|'.'
name|'start'
op|'('
op|')'
op|']'
comment|'# Lines before blockquote'
newline|'\n'
comment|'# Pass lines before blockquote in recursively for parsing forst.'
nl|'\n'
name|'self'
op|'.'
name|'parser'
op|'.'
name|'parseBlocks'
op|'('
name|'parent'
op|','
op|'['
name|'before'
op|']'
op|')'
newline|'\n'
comment|'# Remove ``> `` from begining of each line.'
nl|'\n'
name|'block'
op|'='
string|"'\\n'"
op|'.'
name|'join'
op|'('
op|'['
name|'self'
op|'.'
name|'clean'
op|'('
name|'line'
op|')'
name|'for'
name|'line'
name|'in'
nl|'\n'
name|'block'
op|'['
name|'m'
op|'.'
name|'start'
op|'('
op|')'
op|':'
op|']'
op|'.'
name|'split'
op|'('
string|"'\\n'"
op|')'
op|']'
op|')'
newline|'\n'
dedent|''
name|'sibling'
op|'='
name|'self'
op|'.'
name|'lastChild'
op|'('
name|'parent'
op|')'
newline|'\n'
name|'if'
name|'sibling'
name|'and'
name|'sibling'
op|'.'
name|'tag'
op|'=='
string|'"blockquote"'
op|':'
newline|'\n'
comment|'# Previous block was a blockquote so set that as this blocks parent'
nl|'\n'
indent|'            '
name|'quote'
op|'='
name|'sibling'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# This is a new blockquote. Create a new parent element.'
nl|'\n'
indent|'            '
name|'quote'
op|'='
name|'markdown'
op|'.'
name|'etree'
op|'.'
name|'SubElement'
op|'('
name|'parent'
op|','
string|"'blockquote'"
op|')'
newline|'\n'
comment|'# Recursively parse block with blockquote as parent.'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'parser'
op|'.'
name|'parseChunk'
op|'('
name|'quote'
op|','
name|'block'
op|')'
newline|'\n'
nl|'\n'
DECL|member|clean
dedent|''
name|'def'
name|'clean'
op|'('
name|'self'
op|','
name|'line'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Remove ``>`` from beginning of a line. """'
newline|'\n'
name|'m'
op|'='
name|'self'
op|'.'
name|'RE'
op|'.'
name|'match'
op|'('
name|'line'
op|')'
newline|'\n'
name|'if'
name|'line'
op|'.'
name|'strip'
op|'('
op|')'
op|'=='
string|'">"'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|'""'
newline|'\n'
dedent|''
name|'elif'
name|'m'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'m'
op|'.'
name|'group'
op|'('
number|'2'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'line'
newline|'\n'
nl|'\n'
DECL|class|OListProcessor
dedent|''
dedent|''
dedent|''
name|'class'
name|'OListProcessor'
op|'('
name|'BlockProcessor'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Process ordered list blocks. """'
newline|'\n'
nl|'\n'
DECL|variable|TAG
name|'TAG'
op|'='
string|"'ol'"
newline|'\n'
comment|'# Detect an item (``1. item``). ``group(1)`` contains contents of item.'
nl|'\n'
DECL|variable|RE
name|'RE'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'^[ ]{0,3}\\d+\\.[ ](.*)'"
op|')'
newline|'\n'
comment|'# Detect items on secondary lines. they can be of either list type.'
nl|'\n'
DECL|variable|CHILD_RE
name|'CHILD_RE'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'^[ ]{0,3}((\\d+\\.)|[*+-])[ ](.*)'"
op|')'
newline|'\n'
comment|'# Detect indented (nested) items of either type'
nl|'\n'
DECL|variable|INDENT_RE
name|'INDENT_RE'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'^[ ]{4,7}((\\d+\\.)|[*+-])[ ].*'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|test
name|'def'
name|'test'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'block'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'bool'
op|'('
name|'self'
op|'.'
name|'RE'
op|'.'
name|'match'
op|'('
name|'block'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|run
dedent|''
name|'def'
name|'run'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'blocks'
op|')'
op|':'
newline|'\n'
comment|'# Check fr multiple items in one block.'
nl|'\n'
indent|'        '
name|'items'
op|'='
name|'self'
op|'.'
name|'get_items'
op|'('
name|'blocks'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
op|')'
newline|'\n'
name|'sibling'
op|'='
name|'self'
op|'.'
name|'lastChild'
op|'('
name|'parent'
op|')'
newline|'\n'
name|'if'
name|'sibling'
name|'and'
name|'sibling'
op|'.'
name|'tag'
name|'in'
op|'['
string|"'ol'"
op|','
string|"'ul'"
op|']'
op|':'
newline|'\n'
comment|'# Previous block was a list item, so set that as parent'
nl|'\n'
indent|'            '
name|'lst'
op|'='
name|'sibling'
newline|'\n'
comment|'# make sure previous item is in a p.'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'lst'
op|')'
name|'and'
name|'lst'
op|'['
op|'-'
number|'1'
op|']'
op|'.'
name|'text'
name|'and'
name|'not'
name|'len'
op|'('
name|'lst'
op|'['
op|'-'
number|'1'
op|']'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'p'
op|'='
name|'markdown'
op|'.'
name|'etree'
op|'.'
name|'SubElement'
op|'('
name|'lst'
op|'['
op|'-'
number|'1'
op|']'
op|','
string|"'p'"
op|')'
newline|'\n'
name|'p'
op|'.'
name|'text'
op|'='
name|'lst'
op|'['
op|'-'
number|'1'
op|']'
op|'.'
name|'text'
newline|'\n'
name|'lst'
op|'['
op|'-'
number|'1'
op|']'
op|'.'
name|'text'
op|'='
string|"''"
newline|'\n'
comment|'# parse first block differently as it gets wrapped in a p.'
nl|'\n'
dedent|''
name|'li'
op|'='
name|'markdown'
op|'.'
name|'etree'
op|'.'
name|'SubElement'
op|'('
name|'lst'
op|','
string|"'li'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'parser'
op|'.'
name|'state'
op|'.'
name|'set'
op|'('
string|"'looselist'"
op|')'
newline|'\n'
name|'firstitem'
op|'='
name|'items'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'parser'
op|'.'
name|'parseBlocks'
op|'('
name|'li'
op|','
op|'['
name|'firstitem'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'parser'
op|'.'
name|'state'
op|'.'
name|'reset'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# This is a new list so create parent with appropriate tag.'
nl|'\n'
indent|'            '
name|'lst'
op|'='
name|'markdown'
op|'.'
name|'etree'
op|'.'
name|'SubElement'
op|'('
name|'parent'
op|','
name|'self'
op|'.'
name|'TAG'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'parser'
op|'.'
name|'state'
op|'.'
name|'set'
op|'('
string|"'list'"
op|')'
newline|'\n'
comment|'# Loop through items in block, recursively parsing each with the'
nl|'\n'
comment|'# appropriate parent.'
nl|'\n'
name|'for'
name|'item'
name|'in'
name|'items'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'item'
op|'.'
name|'startswith'
op|'('
string|"' '"
op|'*'
name|'markdown'
op|'.'
name|'TAB_LENGTH'
op|')'
op|':'
newline|'\n'
comment|'# Item is indented. Parse with last item as parent'
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'parser'
op|'.'
name|'parseBlocks'
op|'('
name|'lst'
op|'['
op|'-'
number|'1'
op|']'
op|','
op|'['
name|'item'
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# New item. Create li and parse with it as parent'
nl|'\n'
indent|'                '
name|'li'
op|'='
name|'markdown'
op|'.'
name|'etree'
op|'.'
name|'SubElement'
op|'('
name|'lst'
op|','
string|"'li'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'parser'
op|'.'
name|'parseBlocks'
op|'('
name|'li'
op|','
op|'['
name|'item'
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'parser'
op|'.'
name|'state'
op|'.'
name|'reset'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_items
dedent|''
name|'def'
name|'get_items'
op|'('
name|'self'
op|','
name|'block'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""" Break a block into list items. """'
newline|'\n'
name|'items'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'line'
name|'in'
name|'block'
op|'.'
name|'split'
op|'('
string|"'\\n'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'m'
op|'='
name|'self'
op|'.'
name|'CHILD_RE'
op|'.'
name|'match'
op|'('
name|'line'
op|')'
newline|'\n'
name|'if'
name|'m'
op|':'
newline|'\n'
comment|'# This is a new item. Append'
nl|'\n'
indent|'                '
name|'items'
op|'.'
name|'append'
op|'('
name|'m'
op|'.'
name|'group'
op|'('
number|'3'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'INDENT_RE'
op|'.'
name|'match'
op|'('
name|'line'
op|')'
op|':'
newline|'\n'
comment|'# This is an indented (possibly nested) item.'
nl|'\n'
indent|'                '
name|'if'
name|'items'
op|'['
op|'-'
number|'1'
op|']'
op|'.'
name|'startswith'
op|'('
string|"' '"
op|'*'
name|'markdown'
op|'.'
name|'TAB_LENGTH'
op|')'
op|':'
newline|'\n'
comment|'# Previous item was indented. Append to that item.'
nl|'\n'
indent|'                    '
name|'items'
op|'['
op|'-'
number|'1'
op|']'
op|'='
string|"'%s\\n%s'"
op|'%'
op|'('
name|'items'
op|'['
op|'-'
number|'1'
op|']'
op|','
name|'line'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'items'
op|'.'
name|'append'
op|'('
name|'line'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# This is another line of previous item. Append to that item.'
nl|'\n'
indent|'                '
name|'items'
op|'['
op|'-'
number|'1'
op|']'
op|'='
string|"'%s\\n%s'"
op|'%'
op|'('
name|'items'
op|'['
op|'-'
number|'1'
op|']'
op|','
name|'line'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'items'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|UListProcessor
dedent|''
dedent|''
name|'class'
name|'UListProcessor'
op|'('
name|'OListProcessor'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Process unordered list blocks. """'
newline|'\n'
nl|'\n'
DECL|variable|TAG
name|'TAG'
op|'='
string|"'ul'"
newline|'\n'
DECL|variable|RE
name|'RE'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'^[ ]{0,3}[*+-][ ](.*)'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|HashHeaderProcessor
dedent|''
name|'class'
name|'HashHeaderProcessor'
op|'('
name|'BlockProcessor'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Process Hash Headers. """'
newline|'\n'
nl|'\n'
comment|'# Detect a header at start of any line in block'
nl|'\n'
DECL|variable|RE
name|'RE'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'(^|\\n)(?P<level>#{1,6})(?P<header>.*?)#*(\\n|$)'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|test
name|'def'
name|'test'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'block'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'bool'
op|'('
name|'self'
op|'.'
name|'RE'
op|'.'
name|'search'
op|'('
name|'block'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|run
dedent|''
name|'def'
name|'run'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'blocks'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'block'
op|'='
name|'blocks'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
newline|'\n'
name|'m'
op|'='
name|'self'
op|'.'
name|'RE'
op|'.'
name|'search'
op|'('
name|'block'
op|')'
newline|'\n'
name|'if'
name|'m'
op|':'
newline|'\n'
indent|'            '
name|'before'
op|'='
name|'block'
op|'['
op|':'
name|'m'
op|'.'
name|'start'
op|'('
op|')'
op|']'
comment|'# All lines before header'
newline|'\n'
name|'after'
op|'='
name|'block'
op|'['
name|'m'
op|'.'
name|'end'
op|'('
op|')'
op|':'
op|']'
comment|'# All lines after header'
newline|'\n'
name|'if'
name|'before'
op|':'
newline|'\n'
comment|'# As the header was not the first line of the block and the'
nl|'\n'
comment|'# lines before the header must be parsed first,'
nl|'\n'
comment|'# recursively parse this lines as a block.'
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'parser'
op|'.'
name|'parseBlocks'
op|'('
name|'parent'
op|','
op|'['
name|'before'
op|']'
op|')'
newline|'\n'
comment|'# Create header using named groups from RE'
nl|'\n'
dedent|''
name|'h'
op|'='
name|'markdown'
op|'.'
name|'etree'
op|'.'
name|'SubElement'
op|'('
name|'parent'
op|','
string|"'h%d'"
op|'%'
name|'len'
op|'('
name|'m'
op|'.'
name|'group'
op|'('
string|"'level'"
op|')'
op|')'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'text'
op|'='
name|'m'
op|'.'
name|'group'
op|'('
string|"'header'"
op|')'
op|'.'
name|'strip'
op|'('
op|')'
newline|'\n'
name|'if'
name|'after'
op|':'
newline|'\n'
comment|'# Insert remaining lines as first block for future parsing.'
nl|'\n'
indent|'                '
name|'blocks'
op|'.'
name|'insert'
op|'('
number|'0'
op|','
name|'after'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# This should never happen, but just in case...'
nl|'\n'
indent|'            '
name|'message'
op|'('
name|'CRITICAL'
op|','
string|'"We\'ve got a problem header!"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|SetextHeaderProcessor
dedent|''
dedent|''
dedent|''
name|'class'
name|'SetextHeaderProcessor'
op|'('
name|'BlockProcessor'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Process Setext-style Headers. """'
newline|'\n'
nl|'\n'
comment|'# Detect Setext-style header. Must be first 2 lines of block.'
nl|'\n'
DECL|variable|RE
name|'RE'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'^.*?\\n[=-]{3,}'"
op|','
name|'re'
op|'.'
name|'MULTILINE'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test
name|'def'
name|'test'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'block'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'bool'
op|'('
name|'self'
op|'.'
name|'RE'
op|'.'
name|'match'
op|'('
name|'block'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|run
dedent|''
name|'def'
name|'run'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'blocks'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'lines'
op|'='
name|'blocks'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
op|'.'
name|'split'
op|'('
string|"'\\n'"
op|')'
newline|'\n'
comment|'# Determine level. ``=`` is 1 and ``-`` is 2.'
nl|'\n'
name|'if'
name|'lines'
op|'['
number|'1'
op|']'
op|'.'
name|'startswith'
op|'('
string|"'='"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'level'
op|'='
number|'1'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'level'
op|'='
number|'2'
newline|'\n'
dedent|''
name|'h'
op|'='
name|'markdown'
op|'.'
name|'etree'
op|'.'
name|'SubElement'
op|'('
name|'parent'
op|','
string|"'h%d'"
op|'%'
name|'level'
op|')'
newline|'\n'
name|'h'
op|'.'
name|'text'
op|'='
name|'lines'
op|'['
number|'0'
op|']'
op|'.'
name|'strip'
op|'('
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'lines'
op|')'
op|'>'
number|'2'
op|':'
newline|'\n'
comment|'# Block contains additional lines. Add to  master blocks for later.'
nl|'\n'
indent|'            '
name|'blocks'
op|'.'
name|'insert'
op|'('
number|'0'
op|','
string|"'\\n'"
op|'.'
name|'join'
op|'('
name|'lines'
op|'['
number|'2'
op|':'
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|HRProcessor
dedent|''
dedent|''
dedent|''
name|'class'
name|'HRProcessor'
op|'('
name|'BlockProcessor'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Process Horizontal Rules. """'
newline|'\n'
nl|'\n'
DECL|variable|RE
name|'RE'
op|'='
string|"r'[ ]{0,3}(?P<ch>[*_-])[ ]?((?P=ch)[ ]?){2,}[ ]*'"
newline|'\n'
comment|'# Detect hr on any line of a block.'
nl|'\n'
DECL|variable|SEARCH_RE
name|'SEARCH_RE'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'(^|\\n)%s(\\n|$)'"
op|'%'
name|'RE'
op|')'
newline|'\n'
comment|'# Match a hr on a single line of text.'
nl|'\n'
DECL|variable|MATCH_RE
name|'MATCH_RE'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'^%s$'"
op|'%'
name|'RE'
op|')'
newline|'\n'
nl|'\n'
DECL|member|test
name|'def'
name|'test'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'block'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'bool'
op|'('
name|'self'
op|'.'
name|'SEARCH_RE'
op|'.'
name|'search'
op|'('
name|'block'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|run
dedent|''
name|'def'
name|'run'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'blocks'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'lines'
op|'='
name|'blocks'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
op|'.'
name|'split'
op|'('
string|"'\\n'"
op|')'
newline|'\n'
name|'prelines'
op|'='
op|'['
op|']'
newline|'\n'
comment|'# Check for lines in block before hr.'
nl|'\n'
name|'for'
name|'line'
name|'in'
name|'lines'
op|':'
newline|'\n'
indent|'            '
name|'m'
op|'='
name|'self'
op|'.'
name|'MATCH_RE'
op|'.'
name|'match'
op|'('
name|'line'
op|')'
newline|'\n'
name|'if'
name|'m'
op|':'
newline|'\n'
indent|'                '
name|'break'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'prelines'
op|'.'
name|'append'
op|'('
name|'line'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'len'
op|'('
name|'prelines'
op|')'
op|':'
newline|'\n'
comment|'# Recursively parse lines before hr so they get parsed first.'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'parser'
op|'.'
name|'parseBlocks'
op|'('
name|'parent'
op|','
op|'['
string|"'\\n'"
op|'.'
name|'join'
op|'('
name|'prelines'
op|')'
op|']'
op|')'
newline|'\n'
comment|'# create hr'
nl|'\n'
dedent|''
name|'hr'
op|'='
name|'markdown'
op|'.'
name|'etree'
op|'.'
name|'SubElement'
op|'('
name|'parent'
op|','
string|"'hr'"
op|')'
newline|'\n'
comment|'# check for lines in block after hr.'
nl|'\n'
name|'lines'
op|'='
name|'lines'
op|'['
name|'len'
op|'('
name|'prelines'
op|')'
op|'+'
number|'1'
op|':'
op|']'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'lines'
op|')'
op|':'
newline|'\n'
comment|'# Add lines after hr to master blocks for later parsing.'
nl|'\n'
indent|'            '
name|'blocks'
op|'.'
name|'insert'
op|'('
number|'0'
op|','
string|"'\\n'"
op|'.'
name|'join'
op|'('
name|'lines'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|EmptyBlockProcessor
dedent|''
dedent|''
dedent|''
name|'class'
name|'EmptyBlockProcessor'
op|'('
name|'BlockProcessor'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Process blocks and start with an empty line. """'
newline|'\n'
nl|'\n'
comment|'# Detect a block that only contains whitespace '
nl|'\n'
comment|'# or only whitespace on the first line.'
nl|'\n'
DECL|variable|RE
name|'RE'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'^\\s*\\n'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|test
name|'def'
name|'test'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'block'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'bool'
op|'('
name|'self'
op|'.'
name|'RE'
op|'.'
name|'match'
op|'('
name|'block'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|run
dedent|''
name|'def'
name|'run'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'blocks'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'block'
op|'='
name|'blocks'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
newline|'\n'
name|'m'
op|'='
name|'self'
op|'.'
name|'RE'
op|'.'
name|'match'
op|'('
name|'block'
op|')'
newline|'\n'
name|'if'
name|'m'
op|':'
newline|'\n'
comment|'# Add remaining line to master blocks for later.'
nl|'\n'
indent|'            '
name|'blocks'
op|'.'
name|'insert'
op|'('
number|'0'
op|','
name|'block'
op|'['
name|'m'
op|'.'
name|'end'
op|'('
op|')'
op|':'
op|']'
op|')'
newline|'\n'
name|'sibling'
op|'='
name|'self'
op|'.'
name|'lastChild'
op|'('
name|'parent'
op|')'
newline|'\n'
name|'if'
name|'sibling'
name|'and'
name|'sibling'
op|'.'
name|'tag'
op|'=='
string|"'pre'"
name|'and'
name|'sibling'
op|'['
number|'0'
op|']'
name|'and'
name|'sibling'
op|'['
number|'0'
op|']'
op|'.'
name|'tag'
op|'=='
string|"'code'"
op|':'
newline|'\n'
comment|'# Last block is a codeblock. Append to preserve whitespace.'
nl|'\n'
indent|'                '
name|'sibling'
op|'['
number|'0'
op|']'
op|'.'
name|'text'
op|'='
name|'markdown'
op|'.'
name|'AtomicString'
op|'('
string|"'%s/n/n/n'"
op|'%'
name|'sibling'
op|'['
number|'0'
op|']'
op|'.'
name|'text'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ParagraphProcessor
dedent|''
dedent|''
dedent|''
dedent|''
name|'class'
name|'ParagraphProcessor'
op|'('
name|'BlockProcessor'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'""" Process Paragraph blocks. """'
newline|'\n'
nl|'\n'
DECL|member|test
name|'def'
name|'test'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'block'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
DECL|member|run
dedent|''
name|'def'
name|'run'
op|'('
name|'self'
op|','
name|'parent'
op|','
name|'blocks'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'block'
op|'='
name|'blocks'
op|'.'
name|'pop'
op|'('
number|'0'
op|')'
newline|'\n'
name|'if'
name|'block'
op|'.'
name|'strip'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# Not a blank block. Add to parent, otherwise throw it away.'
nl|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'parser'
op|'.'
name|'state'
op|'.'
name|'isstate'
op|'('
string|"'list'"
op|')'
op|':'
newline|'\n'
comment|'# The parent is a tight-list. Append to parent.text'
nl|'\n'
indent|'                '
name|'if'
name|'parent'
op|'.'
name|'text'
op|':'
newline|'\n'
indent|'                    '
name|'parent'
op|'.'
name|'text'
op|'='
string|"'%s\\n%s'"
op|'%'
op|'('
name|'parent'
op|'.'
name|'text'
op|','
name|'block'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'parent'
op|'.'
name|'text'
op|'='
name|'block'
op|'.'
name|'lstrip'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Create a regular paragraph'
nl|'\n'
indent|'                '
name|'p'
op|'='
name|'markdown'
op|'.'
name|'etree'
op|'.'
name|'SubElement'
op|'('
name|'parent'
op|','
string|"'p'"
op|')'
newline|'\n'
name|'p'
op|'.'
name|'text'
op|'='
name|'block'
op|'.'
name|'lstrip'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
