begin_unit
comment|'# Copyright 2012 OpenStack Foundation'
nl|'\n'
comment|'# All Rights Reserved'
nl|'\n'
comment|'# Copyright (c) 2012 NEC Corporation'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
comment|'#'
nl|'\n'
nl|'\n'
name|'import'
name|'copy'
newline|'\n'
name|'import'
name|'time'
newline|'\n'
name|'import'
name|'uuid'
newline|'\n'
nl|'\n'
name|'from'
name|'keystoneclient'
name|'import'
name|'auth'
newline|'\n'
name|'from'
name|'keystoneclient'
op|'.'
name|'auth'
name|'import'
name|'token_endpoint'
newline|'\n'
name|'from'
name|'keystoneclient'
name|'import'
name|'session'
newline|'\n'
name|'from'
name|'neutronclient'
op|'.'
name|'common'
name|'import'
name|'exceptions'
name|'as'
name|'neutron_client_exc'
newline|'\n'
name|'from'
name|'neutronclient'
op|'.'
name|'v2_0'
name|'import'
name|'client'
name|'as'
name|'clientv20'
newline|'\n'
name|'from'
name|'oslo_concurrency'
name|'import'
name|'lockutils'
newline|'\n'
name|'from'
name|'oslo_config'
name|'import'
name|'cfg'
newline|'\n'
name|'from'
name|'oslo_log'
name|'import'
name|'log'
name|'as'
name|'logging'
newline|'\n'
name|'from'
name|'oslo_utils'
name|'import'
name|'excutils'
newline|'\n'
name|'from'
name|'oslo_utils'
name|'import'
name|'uuidutils'
newline|'\n'
name|'import'
name|'six'
newline|'\n'
nl|'\n'
name|'from'
name|'nova'
op|'.'
name|'api'
op|'.'
name|'openstack'
name|'import'
name|'extensions'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'utils'
name|'as'
name|'compute_utils'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'exception'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_'
op|','
name|'_LE'
op|','
name|'_LI'
op|','
name|'_LW'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'network'
name|'import'
name|'base_api'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'network'
name|'import'
name|'model'
name|'as'
name|'network_model'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'network'
op|'.'
name|'neutronv2'
name|'import'
name|'constants'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'objects'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'pci'
name|'import'
name|'manager'
name|'as'
name|'pci_manager'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'pci'
name|'import'
name|'request'
name|'as'
name|'pci_request'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'pci'
name|'import'
name|'whitelist'
name|'as'
name|'pci_whitelist'
newline|'\n'
nl|'\n'
DECL|variable|neutron_opts
name|'neutron_opts'
op|'='
op|'['
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'url'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'http://127.0.0.1:9696'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'URL for connecting to neutron'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'region_name'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Region name for connecting to neutron in admin context'"
op|')'
op|','
nl|'\n'
comment|'# TODO(berrange) temporary hack until Neutron can pass over the'
nl|'\n'
comment|'# name of the OVS bridge it is configured with'
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'ovs_bridge'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'br-int'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Name of Integration Bridge used by Open vSwitch'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'extension_sync_interval'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'600'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Number of seconds before querying neutron for'"
nl|'\n'
string|"' extensions'"
op|')'
op|','
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
DECL|variable|NEUTRON_GROUP
name|'NEUTRON_GROUP'
op|'='
string|"'neutron'"
newline|'\n'
nl|'\n'
DECL|variable|CONF
name|'CONF'
op|'='
name|'cfg'
op|'.'
name|'CONF'
newline|'\n'
name|'CONF'
op|'.'
name|'register_opts'
op|'('
name|'neutron_opts'
op|','
name|'NEUTRON_GROUP'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|deprecations
name|'deprecations'
op|'='
op|'{'
string|"'cafile'"
op|':'
op|'['
name|'cfg'
op|'.'
name|'DeprecatedOpt'
op|'('
string|"'ca_certificates_file'"
op|','
nl|'\n'
DECL|variable|group
name|'group'
op|'='
name|'NEUTRON_GROUP'
op|')'
op|']'
op|','
nl|'\n'
string|"'insecure'"
op|':'
op|'['
name|'cfg'
op|'.'
name|'DeprecatedOpt'
op|'('
string|"'api_insecure'"
op|','
nl|'\n'
DECL|variable|group
name|'group'
op|'='
name|'NEUTRON_GROUP'
op|')'
op|']'
op|','
nl|'\n'
string|"'timeout'"
op|':'
op|'['
name|'cfg'
op|'.'
name|'DeprecatedOpt'
op|'('
string|"'url_timeout'"
op|','
nl|'\n'
DECL|variable|group
name|'group'
op|'='
name|'NEUTRON_GROUP'
op|')'
op|']'
op|'}'
newline|'\n'
nl|'\n'
DECL|variable|_neutron_options
name|'_neutron_options'
op|'='
name|'session'
op|'.'
name|'Session'
op|'.'
name|'register_conf_options'
op|'('
nl|'\n'
name|'CONF'
op|','
name|'NEUTRON_GROUP'
op|','
name|'deprecated_opts'
op|'='
name|'deprecations'
op|')'
newline|'\n'
name|'auth'
op|'.'
name|'register_conf_options'
op|'('
name|'CONF'
op|','
name|'NEUTRON_GROUP'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'default_floating_pool'"
op|','
string|"'nova.network.floating_ips'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'flat_injected'"
op|','
string|"'nova.network.manager'"
op|')'
newline|'\n'
DECL|variable|LOG
name|'LOG'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|soft_external_network_attach_authorize
name|'soft_external_network_attach_authorize'
op|'='
name|'extensions'
op|'.'
name|'soft_core_authorizer'
op|'('
nl|'\n'
string|"'network'"
op|','
string|"'attach_external_network'"
op|')'
newline|'\n'
nl|'\n'
DECL|variable|_SESSION
name|'_SESSION'
op|'='
name|'None'
newline|'\n'
DECL|variable|_ADMIN_AUTH
name|'_ADMIN_AUTH'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|list_opts
name|'def'
name|'list_opts'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
name|'list'
op|'='
name|'copy'
op|'.'
name|'deepcopy'
op|'('
name|'_neutron_options'
op|')'
newline|'\n'
name|'list'
op|'.'
name|'insert'
op|'('
number|'0'
op|','
name|'auth'
op|'.'
name|'get_common_conf_options'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
comment|'# NOTE(dims): There are a lot of auth plugins, we just generate'
nl|'\n'
comment|'# the config options for a few common ones'
nl|'\n'
name|'plugins'
op|'='
op|'['
string|"'password'"
op|','
string|"'v2password'"
op|','
string|"'v3password'"
op|']'
newline|'\n'
name|'for'
name|'name'
name|'in'
name|'plugins'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'plugin_option'
name|'in'
name|'auth'
op|'.'
name|'get_plugin_class'
op|'('
name|'name'
op|')'
op|'.'
name|'get_options'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'found'
op|'='
name|'False'
newline|'\n'
name|'for'
name|'option'
name|'in'
name|'list'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'option'
op|'.'
name|'name'
op|'=='
name|'plugin_option'
op|'.'
name|'name'
op|':'
newline|'\n'
indent|'                    '
name|'found'
op|'='
name|'True'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'found'
op|':'
newline|'\n'
indent|'                '
name|'list'
op|'.'
name|'append'
op|'('
name|'plugin_option'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'list'
op|'.'
name|'sort'
op|'('
name|'key'
op|'='
name|'lambda'
name|'x'
op|':'
name|'x'
op|'.'
name|'name'
op|')'
newline|'\n'
name|'return'
op|'['
op|'('
name|'NEUTRON_GROUP'
op|','
name|'list'
op|')'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|reset_state
dedent|''
name|'def'
name|'reset_state'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
name|'global'
name|'_ADMIN_AUTH'
newline|'\n'
name|'global'
name|'_SESSION'
newline|'\n'
nl|'\n'
name|'_ADMIN_AUTH'
op|'='
name|'None'
newline|'\n'
name|'_SESSION'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_load_auth_plugin
dedent|''
name|'def'
name|'_load_auth_plugin'
op|'('
name|'conf'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'auth_plugin'
op|'='
name|'auth'
op|'.'
name|'load_from_conf_options'
op|'('
name|'conf'
op|','
name|'NEUTRON_GROUP'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'auth_plugin'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'auth_plugin'
newline|'\n'
nl|'\n'
dedent|''
name|'err_msg'
op|'='
name|'_'
op|'('
string|"'Unknown auth plugin: %s'"
op|')'
op|'%'
name|'conf'
op|'.'
name|'neutron'
op|'.'
name|'auth_plugin'
newline|'\n'
name|'raise'
name|'neutron_client_exc'
op|'.'
name|'Unauthorized'
op|'('
name|'message'
op|'='
name|'err_msg'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_client
dedent|''
name|'def'
name|'get_client'
op|'('
name|'context'
op|','
name|'admin'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(dprince): In the case where no auth_token is present we allow use of'
nl|'\n'
comment|'# neutron admin tenant credentials if it is an admin context.  This is to'
nl|'\n'
comment|'# support some services (metadata API) where an admin context is used'
nl|'\n'
comment|'# without an auth token.'
nl|'\n'
indent|'    '
name|'global'
name|'_ADMIN_AUTH'
newline|'\n'
name|'global'
name|'_SESSION'
newline|'\n'
nl|'\n'
name|'auth_plugin'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'_SESSION'
op|':'
newline|'\n'
indent|'        '
name|'_SESSION'
op|'='
name|'session'
op|'.'
name|'Session'
op|'.'
name|'load_from_conf_options'
op|'('
name|'CONF'
op|','
name|'NEUTRON_GROUP'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'admin'
name|'or'
op|'('
name|'context'
op|'.'
name|'is_admin'
name|'and'
name|'not'
name|'context'
op|'.'
name|'auth_token'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(jamielennox): The theory here is that we maintain one'
nl|'\n'
comment|'# authenticated admin auth globally. The plugin will authenticate'
nl|'\n'
comment|'# internally (not thread safe) and on demand so we extract a current'
nl|'\n'
comment|'# auth plugin from it (whilst locked). This may or may not require'
nl|'\n'
comment|'# reauthentication. We then use the static token plugin to issue the'
nl|'\n'
comment|'# actual request with that current token in a thread safe way.'
nl|'\n'
indent|'        '
name|'if'
name|'not'
name|'_ADMIN_AUTH'
op|':'
newline|'\n'
indent|'            '
name|'_ADMIN_AUTH'
op|'='
name|'_load_auth_plugin'
op|'('
name|'CONF'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'with'
name|'lockutils'
op|'.'
name|'lock'
op|'('
string|"'neutron_admin_auth_token_lock'"
op|')'
op|':'
newline|'\n'
comment|'# FIXME(jamielennox): We should also retrieve the endpoint from the'
nl|'\n'
comment|'# catalog here rather than relying on setting it in CONF.'
nl|'\n'
indent|'            '
name|'auth_token'
op|'='
name|'_ADMIN_AUTH'
op|'.'
name|'get_token'
op|'('
name|'_SESSION'
op|')'
newline|'\n'
nl|'\n'
comment|"# FIXME(jamielennox): why aren't we using the service catalog?"
nl|'\n'
dedent|''
name|'auth_plugin'
op|'='
name|'token_endpoint'
op|'.'
name|'Token'
op|'('
name|'CONF'
op|'.'
name|'neutron'
op|'.'
name|'url'
op|','
name|'auth_token'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'context'
op|'.'
name|'auth_token'
op|':'
newline|'\n'
indent|'        '
name|'auth_plugin'
op|'='
name|'context'
op|'.'
name|'get_auth_plugin'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'auth_plugin'
op|':'
newline|'\n'
comment|'# We did not get a user token and we should not be using'
nl|'\n'
comment|'# an admin token so log an error'
nl|'\n'
indent|'        '
name|'raise'
name|'neutron_client_exc'
op|'.'
name|'Unauthorized'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'clientv20'
op|'.'
name|'Client'
op|'('
name|'session'
op|'='
name|'_SESSION'
op|','
nl|'\n'
name|'auth'
op|'='
name|'auth_plugin'
op|','
nl|'\n'
name|'endpoint_override'
op|'='
name|'CONF'
op|'.'
name|'neutron'
op|'.'
name|'url'
op|','
nl|'\n'
name|'region_name'
op|'='
name|'CONF'
op|'.'
name|'neutron'
op|'.'
name|'region_name'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_is_not_duplicate
dedent|''
name|'def'
name|'_is_not_duplicate'
op|'('
name|'item'
op|','
name|'items'
op|','
name|'items_list_name'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'present'
op|'='
name|'item'
name|'in'
name|'items'
newline|'\n'
nl|'\n'
comment|"# The expectation from this function's perspective is that the"
nl|'\n'
comment|'# item is not part of the items list so if it is part of it'
nl|'\n'
comment|'# we should at least log it as a warning'
nl|'\n'
name|'if'
name|'present'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"%(item)s already exists in list: %(list_name)s "'
nl|'\n'
string|'"containing: %(items)s. ignoring it"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'item'"
op|':'
name|'item'
op|','
nl|'\n'
string|"'list_name'"
op|':'
name|'items_list_name'
op|','
nl|'\n'
string|"'items'"
op|':'
name|'items'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'not'
name|'present'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|API
dedent|''
name|'class'
name|'API'
op|'('
name|'base_api'
op|'.'
name|'NetworkAPI'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""API for interacting with the neutron 2.x API."""'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'skip_policy_check'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'super'
op|'('
name|'API'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'skip_policy_check'
op|'='
name|'skip_policy_check'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'last_neutron_extension_sync'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'extensions'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|setup_networks_on_host
dedent|''
name|'def'
name|'setup_networks_on_host'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'host'
op|'='
name|'None'
op|','
nl|'\n'
name|'teardown'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Setup or teardown the network structures."""'
newline|'\n'
nl|'\n'
DECL|member|_get_available_networks
dedent|''
name|'def'
name|'_get_available_networks'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'project_id'
op|','
nl|'\n'
name|'net_ids'
op|'='
name|'None'
op|','
name|'neutron'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a network list available for the tenant.\n        The list contains networks owned by the tenant and public networks.\n        If net_ids specified, it searches networks with requested IDs only.\n        """'
newline|'\n'
name|'if'
name|'not'
name|'neutron'
op|':'
newline|'\n'
indent|'            '
name|'neutron'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'net_ids'
op|':'
newline|'\n'
comment|'# If user has specified to attach instance only to specific'
nl|'\n'
comment|'# networks then only add these to **search_opts. This search will'
nl|'\n'
comment|"# also include 'shared' networks."
nl|'\n'
indent|'            '
name|'search_opts'
op|'='
op|'{'
string|"'id'"
op|':'
name|'net_ids'
op|'}'
newline|'\n'
name|'nets'
op|'='
name|'neutron'
op|'.'
name|'list_networks'
op|'('
op|'**'
name|'search_opts'
op|')'
op|'.'
name|'get'
op|'('
string|"'networks'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# (1) Retrieve non-public network list owned by the tenant.'
nl|'\n'
indent|'            '
name|'search_opts'
op|'='
op|'{'
string|"'tenant_id'"
op|':'
name|'project_id'
op|','
string|"'shared'"
op|':'
name|'False'
op|'}'
newline|'\n'
name|'nets'
op|'='
name|'neutron'
op|'.'
name|'list_networks'
op|'('
op|'**'
name|'search_opts'
op|')'
op|'.'
name|'get'
op|'('
string|"'networks'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
comment|'# (2) Retrieve public network list.'
nl|'\n'
name|'search_opts'
op|'='
op|'{'
string|"'shared'"
op|':'
name|'True'
op|'}'
newline|'\n'
name|'nets'
op|'+='
name|'neutron'
op|'.'
name|'list_networks'
op|'('
op|'**'
name|'search_opts'
op|')'
op|'.'
name|'get'
op|'('
string|"'networks'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'_ensure_requested_network_ordering'
op|'('
nl|'\n'
name|'lambda'
name|'x'
op|':'
name|'x'
op|'['
string|"'id'"
op|']'
op|','
nl|'\n'
name|'nets'
op|','
nl|'\n'
name|'net_ids'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'nets'
newline|'\n'
nl|'\n'
DECL|member|_create_port
dedent|''
name|'def'
name|'_create_port'
op|'('
name|'self'
op|','
name|'port_client'
op|','
name|'instance'
op|','
name|'network_id'
op|','
name|'port_req_body'
op|','
nl|'\n'
name|'fixed_ip'
op|'='
name|'None'
op|','
name|'security_group_ids'
op|'='
name|'None'
op|','
nl|'\n'
name|'available_macs'
op|'='
name|'None'
op|','
name|'dhcp_opts'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Attempts to create a port for the instance on the given network.\n\n        :param port_client: The client to use to create the port.\n        :param instance: Create the port for the given instance.\n        :param network_id: Create the port on the given network.\n        :param port_req_body: Pre-populated port request. Should have the\n            device_id, device_owner, and any required neutron extension values.\n        :param fixed_ip: Optional fixed IP to use from the given network.\n        :param security_group_ids: Optional list of security group IDs to\n            apply to the port.\n        :param available_macs: Optional set of available MAC addresses,\n            from which one will be used at random.\n        :param dhcp_opts: Optional DHCP options.\n        :returns: ID of the created port.\n        :raises PortLimitExceeded: If neutron fails with an OverQuota error.\n        :raises NoMoreFixedIps: If neutron fails with\n            IpAddressGenerationFailure error.\n        :raises: PortBindingFailed: If port binding failed.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'fixed_ip'
op|':'
newline|'\n'
indent|'                '
name|'port_req_body'
op|'['
string|"'port'"
op|']'
op|'['
string|"'fixed_ips'"
op|']'
op|'='
op|'['
nl|'\n'
op|'{'
string|"'ip_address'"
op|':'
name|'str'
op|'('
name|'fixed_ip'
op|')'
op|'}'
op|']'
newline|'\n'
dedent|''
name|'port_req_body'
op|'['
string|"'port'"
op|']'
op|'['
string|"'network_id'"
op|']'
op|'='
name|'network_id'
newline|'\n'
name|'port_req_body'
op|'['
string|"'port'"
op|']'
op|'['
string|"'admin_state_up'"
op|']'
op|'='
name|'True'
newline|'\n'
name|'port_req_body'
op|'['
string|"'port'"
op|']'
op|'['
string|"'tenant_id'"
op|']'
op|'='
name|'instance'
op|'.'
name|'project_id'
newline|'\n'
name|'if'
name|'security_group_ids'
op|':'
newline|'\n'
indent|'                '
name|'port_req_body'
op|'['
string|"'port'"
op|']'
op|'['
string|"'security_groups'"
op|']'
op|'='
name|'security_group_ids'
newline|'\n'
dedent|''
name|'if'
name|'available_macs'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'not'
name|'available_macs'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'exception'
op|'.'
name|'PortNotFree'
op|'('
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
dedent|''
name|'mac_address'
op|'='
name|'available_macs'
op|'.'
name|'pop'
op|'('
op|')'
newline|'\n'
name|'port_req_body'
op|'['
string|"'port'"
op|']'
op|'['
string|"'mac_address'"
op|']'
op|'='
name|'mac_address'
newline|'\n'
dedent|''
name|'if'
name|'dhcp_opts'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'port_req_body'
op|'['
string|"'port'"
op|']'
op|'['
string|"'extra_dhcp_opts'"
op|']'
op|'='
name|'dhcp_opts'
newline|'\n'
dedent|''
name|'port'
op|'='
name|'port_client'
op|'.'
name|'create_port'
op|'('
name|'port_req_body'
op|')'
newline|'\n'
name|'port_id'
op|'='
name|'port'
op|'['
string|"'port'"
op|']'
op|'['
string|"'id'"
op|']'
newline|'\n'
name|'if'
op|'('
name|'port'
op|'['
string|"'port'"
op|']'
op|'.'
name|'get'
op|'('
string|"'binding:vif_type'"
op|')'
op|'=='
nl|'\n'
name|'network_model'
op|'.'
name|'VIF_TYPE_BINDING_FAILED'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'port_client'
op|'.'
name|'delete_port'
op|'('
name|'port_id'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'PortBindingFailed'
op|'('
name|'port_id'
op|'='
name|'port_id'
op|')'
newline|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Successfully created port: %s'"
op|','
name|'port_id'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'port_id'
newline|'\n'
dedent|''
name|'except'
name|'neutron_client_exc'
op|'.'
name|'InvalidIpForNetworkClient'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|"'Neutron error: %(ip)s is not a valid IP address '"
nl|'\n'
string|"'for network %(network_id)s.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'ip'"
op|':'
name|'fixed_ip'
op|','
string|"'network_id'"
op|':'
name|'network_id'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|"'Fixed IP %(ip)s is not a valid ip address for '"
nl|'\n'
string|"'network %(network_id)s.'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'ip'"
op|':'
name|'fixed_ip'
op|','
string|"'network_id'"
op|':'
name|'network_id'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InvalidInput'
op|'('
name|'reason'
op|'='
name|'msg'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'neutron_client_exc'
op|'.'
name|'IpAddressInUseClient'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|"'Neutron error: Fixed IP %s is '"
nl|'\n'
string|"'already in use.'"
op|')'
op|','
name|'fixed_ip'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'msg'
op|'='
name|'_'
op|'('
string|'"Fixed IP %s is already in use."'
op|')'
op|'%'
name|'fixed_ip'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'FixedIpAlreadyInUse'
op|'('
name|'message'
op|'='
name|'msg'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'neutron_client_exc'
op|'.'
name|'OverQuotaClient'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
nl|'\n'
string|"'Neutron error: Port quota exceeded in tenant: %s'"
op|')'
op|','
nl|'\n'
name|'port_req_body'
op|'['
string|"'port'"
op|']'
op|'['
string|"'tenant_id'"
op|']'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'PortLimitExceeded'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'neutron_client_exc'
op|'.'
name|'IpAddressGenerationFailureClient'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|"'Neutron error: No more fixed IPs in network: %s'"
op|')'
op|','
nl|'\n'
name|'network_id'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NoMoreFixedIps'
op|'('
name|'net'
op|'='
name|'network_id'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'neutron_client_exc'
op|'.'
name|'MacAddressInUseClient'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|"'Neutron error: MAC address %(mac)s is already '"
nl|'\n'
string|"'in use on network %(network)s.'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'mac'"
op|':'
name|'mac_address'
op|','
string|"'network'"
op|':'
name|'network_id'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'PortInUse'
op|'('
name|'port_id'
op|'='
name|'mac_address'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'neutron_client_exc'
op|'.'
name|'NeutronClientException'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Neutron error creating port on network %s'"
op|')'
op|','
nl|'\n'
name|'network_id'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_check_external_network_attach
dedent|''
dedent|''
dedent|''
name|'def'
name|'_check_external_network_attach'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'nets'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check if attaching to external network is permitted."""'
newline|'\n'
name|'if'
name|'not'
name|'soft_external_network_attach_authorize'
op|'('
name|'context'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'net'
name|'in'
name|'nets'
op|':'
newline|'\n'
comment|'# Perform this check here rather than in validate_networks to'
nl|'\n'
comment|'# ensure the check is performed every time'
nl|'\n'
comment|'# allocate_for_instance is invoked'
nl|'\n'
indent|'                '
name|'if'
name|'net'
op|'.'
name|'get'
op|'('
string|"'router:external'"
op|')'
name|'and'
name|'not'
name|'net'
op|'.'
name|'get'
op|'('
string|"'shared'"
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'exception'
op|'.'
name|'ExternalNetworkAttachForbidden'
op|'('
nl|'\n'
name|'network_uuid'
op|'='
name|'net'
op|'['
string|"'id'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_unbind_ports
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_unbind_ports'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'ports'
op|','
nl|'\n'
name|'neutron'
op|','
name|'port_client'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Unbind the given ports by clearing their device_id and\n        device_owner.\n\n        :param context: The request context.\n        :param ports: list of port IDs.\n        :param neutron: neutron client for the current context.\n        :param port_client: The client with appropriate karma for\n            updating the ports.\n        """'
newline|'\n'
name|'port_binding'
op|'='
name|'self'
op|'.'
name|'_has_port_binding_extension'
op|'('
name|'context'
op|','
nl|'\n'
name|'refresh_cache'
op|'='
name|'True'
op|','
name|'neutron'
op|'='
name|'neutron'
op|')'
newline|'\n'
name|'if'
name|'port_client'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|'# Requires admin creds to set port bindings'
nl|'\n'
indent|'            '
name|'port_client'
op|'='
op|'('
name|'neutron'
name|'if'
name|'not'
name|'port_binding'
name|'else'
nl|'\n'
name|'get_client'
op|'('
name|'context'
op|','
name|'admin'
op|'='
name|'True'
op|')'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'port_id'
name|'in'
name|'ports'
op|':'
newline|'\n'
comment|'# A port_id is optional in the NetworkRequest object so check here'
nl|'\n'
comment|'# in case the caller forgot to filter the list.'
nl|'\n'
indent|'            '
name|'if'
name|'port_id'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'port_req_body'
op|'='
op|'{'
string|"'port'"
op|':'
op|'{'
string|"'device_id'"
op|':'
string|"''"
op|','
string|"'device_owner'"
op|':'
string|"''"
op|'}'
op|'}'
newline|'\n'
name|'if'
name|'port_binding'
op|':'
newline|'\n'
indent|'                '
name|'port_req_body'
op|'['
string|"'port'"
op|']'
op|'['
string|"'binding:host_id'"
op|']'
op|'='
name|'None'
newline|'\n'
name|'port_req_body'
op|'['
string|"'port'"
op|']'
op|'['
string|"'binding:profile'"
op|']'
op|'='
op|'{'
op|'}'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'port_client'
op|'.'
name|'update_port'
op|'('
name|'port_id'
op|','
name|'port_req_body'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|'"Unable to clear device ID "'
nl|'\n'
string|'"for port \'%s\'"'
op|')'
op|','
name|'port_id'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_process_requested_networks
dedent|''
dedent|''
dedent|''
name|'def'
name|'_process_requested_networks'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'neutron'
op|','
nl|'\n'
name|'requested_networks'
op|','
name|'hypervisor_macs'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Processes and validates requested networks for allocation.\n\n        Iterates over the list of NetworkRequest objects, validating the\n        request and building sets of ports, networks and MAC addresses to\n        use for allocating ports for the instance.\n\n        :param instance: allocate networks on this instance\n        :type instance: nova.objects.Instance\n        :param neutron: neutron client session\n        :type neutron: neutronclient.v2_0.client.Client\n        :param requested_networks: list of NetworkRequests\n        :type requested_networks: nova.objects.NetworkRequestList\n        :param hypervisor_macs: None or a set of MAC addresses that the\n            instance should use. hypervisor_macs are supplied by the hypervisor\n            driver (contrast with requested_networks which is user supplied).\n            NB: NeutronV2 currently assigns hypervisor supplied MAC addresses\n            to arbitrary networks, which requires openflow switches to\n            function correctly if more than one network is being used with\n            the bare metal hypervisor (which is the only one known to limit\n            MAC addresses).\n        :type hypervisor_macs: set\n        :returns: tuple of:\n            - ports: dict mapping of port id to port dict\n            - net_ids: list of requested network ids\n            - ordered_networks: list of nova.objects.NetworkRequest objects\n                for requested networks (either via explicit network request\n                or the network for an explicit port request)\n            - available_macs: set of available MAC addresses to use if creating\n                a port later; this is the set of hypervisor_macs after removing\n                any MAC addresses from explicitly requested ports.\n        :raises nova.exception.PortNotFound: If a requested port is not found\n            in Neutron.\n        :raises nova.exception.PortNotUsable: If a requested port is not owned\n            by the same tenant that the instance is created under. This error\n            can also be raised if hypervisor_macs is not None and a requested\n            port\'s MAC address is not in that set.\n        :raises nova.exception.PortInUse: If a requested port is already\n            attached to another instance.\n        :raises nova.exception.PortNotUsableDNS: If a requested port has a\n            value assigned to its dns_name attribute.\n        """'
newline|'\n'
nl|'\n'
name|'available_macs'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'hypervisor_macs'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
comment|'# Make a copy we can mutate: records macs that have not been used'
nl|'\n'
comment|'# to create a port on a network. If we find a mac with a'
nl|'\n'
comment|'# pre-allocated port we also remove it from this set.'
nl|'\n'
indent|'            '
name|'available_macs'
op|'='
name|'set'
op|'('
name|'hypervisor_macs'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'ports'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'net_ids'
op|'='
op|'['
op|']'
newline|'\n'
name|'ordered_networks'
op|'='
op|'['
op|']'
newline|'\n'
name|'if'
name|'requested_networks'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'request'
name|'in'
name|'requested_networks'
op|':'
newline|'\n'
nl|'\n'
comment|'# Process a request to use a pre-existing neutron port.'
nl|'\n'
indent|'                '
name|'if'
name|'request'
op|'.'
name|'port_id'
op|':'
newline|'\n'
comment|'# Make sure the port exists.'
nl|'\n'
indent|'                    '
name|'port'
op|'='
name|'self'
op|'.'
name|'_show_port'
op|'('
name|'context'
op|','
name|'request'
op|'.'
name|'port_id'
op|','
nl|'\n'
name|'neutron_client'
op|'='
name|'neutron'
op|')'
newline|'\n'
comment|'# Make sure the instance has access to the port.'
nl|'\n'
name|'if'
name|'port'
op|'['
string|"'tenant_id'"
op|']'
op|'!='
name|'instance'
op|'.'
name|'project_id'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
name|'exception'
op|'.'
name|'PortNotUsable'
op|'('
name|'port_id'
op|'='
name|'request'
op|'.'
name|'port_id'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
nl|'\n'
comment|"# Make sure the port isn't already attached to another"
nl|'\n'
comment|'# instance.'
nl|'\n'
dedent|''
name|'if'
name|'port'
op|'.'
name|'get'
op|'('
string|"'device_id'"
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
name|'exception'
op|'.'
name|'PortInUse'
op|'('
name|'port_id'
op|'='
name|'request'
op|'.'
name|'port_id'
op|')'
newline|'\n'
nl|'\n'
comment|"# Make sure that if the user assigned a value to the port's"
nl|'\n'
comment|"# dns_name attribute, it is equal to the instance's"
nl|'\n'
comment|'# hostname'
nl|'\n'
dedent|''
name|'if'
name|'port'
op|'.'
name|'get'
op|'('
string|"'dns_name'"
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'port'
op|'['
string|"'dns_name'"
op|']'
op|'!='
name|'instance'
op|'.'
name|'hostname'
op|':'
newline|'\n'
indent|'                            '
name|'raise'
name|'exception'
op|'.'
name|'PortNotUsableDNS'
op|'('
nl|'\n'
name|'port_id'
op|'='
name|'request'
op|'.'
name|'port_id'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|'.'
name|'uuid'
op|','
name|'value'
op|'='
name|'port'
op|'['
string|"'dns_name'"
op|']'
op|','
nl|'\n'
name|'hostname'
op|'='
name|'instance'
op|'.'
name|'hostname'
op|')'
newline|'\n'
nl|'\n'
comment|'# Make sure the port is usable'
nl|'\n'
dedent|''
dedent|''
name|'if'
op|'('
name|'port'
op|'.'
name|'get'
op|'('
string|"'binding:vif_type'"
op|')'
op|'=='
nl|'\n'
name|'network_model'
op|'.'
name|'VIF_TYPE_BINDING_FAILED'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
name|'exception'
op|'.'
name|'PortBindingFailed'
op|'('
nl|'\n'
name|'port_id'
op|'='
name|'request'
op|'.'
name|'port_id'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'hypervisor_macs'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'port'
op|'['
string|"'mac_address'"
op|']'
name|'not'
name|'in'
name|'hypervisor_macs'
op|':'
newline|'\n'
indent|'                            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Port %(port)s mac address %(mac)s is "'
nl|'\n'
string|'"not in the set of hypervisor macs: "'
nl|'\n'
string|'"%(hyper_macs)s"'
op|','
nl|'\n'
op|'{'
string|"'port'"
op|':'
name|'request'
op|'.'
name|'port_id'
op|','
nl|'\n'
string|"'mac'"
op|':'
name|'port'
op|'['
string|"'mac_address'"
op|']'
op|','
nl|'\n'
string|"'hyper_macs'"
op|':'
name|'hypervisor_macs'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'PortNotUsable'
op|'('
nl|'\n'
name|'port_id'
op|'='
name|'request'
op|'.'
name|'port_id'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
comment|"# Don't try to use this MAC if we need to create a"
nl|'\n'
comment|'# port on the fly later. Identical MACs may be'
nl|'\n'
comment|'# configured by users into multiple ports so we'
nl|'\n'
comment|'# discard rather than popping.'
nl|'\n'
dedent|''
name|'available_macs'
op|'.'
name|'discard'
op|'('
name|'port'
op|'['
string|"'mac_address'"
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# If requesting a specific port, automatically process'
nl|'\n'
comment|'# the network for that port as if it were explicitly'
nl|'\n'
comment|'# requested.'
nl|'\n'
dedent|''
name|'request'
op|'.'
name|'network_id'
op|'='
name|'port'
op|'['
string|"'network_id'"
op|']'
newline|'\n'
name|'ports'
op|'['
name|'request'
op|'.'
name|'port_id'
op|']'
op|'='
name|'port'
newline|'\n'
nl|'\n'
comment|'# Process a request to use a specific neutron network.'
nl|'\n'
dedent|''
name|'if'
name|'request'
op|'.'
name|'network_id'
op|':'
newline|'\n'
indent|'                    '
name|'net_ids'
op|'.'
name|'append'
op|'('
name|'request'
op|'.'
name|'network_id'
op|')'
newline|'\n'
name|'ordered_networks'
op|'.'
name|'append'
op|'('
name|'request'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'ports'
op|','
name|'net_ids'
op|','
name|'ordered_networks'
op|','
name|'available_macs'
newline|'\n'
nl|'\n'
DECL|member|_process_security_groups
dedent|''
name|'def'
name|'_process_security_groups'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'neutron'
op|','
name|'security_groups'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Processes and validates requested security groups for allocation.\n\n        Iterates over the list of requested security groups, validating the\n        request and filtering out the list of security group IDs to use for\n        port allocation.\n\n        :param instance: allocate networks on this instance\n        :type instance: nova.objects.Instance\n        :param neutron: neutron client session\n        :type neutron: neutronclient.v2_0.client.Client\n        :param security_groups: list of requested security group name or IDs\n            to use when allocating new ports for the instance\n        :return: list of security group IDs to use when allocating new ports\n        :raises nova.exception.NoUniqueMatch: If multiple security groups\n            are requested with the same name.\n        :raises nova.exception.SecurityGroupNotFound: If a requested security\n            group is not in the tenant-filtered list of available security\n            groups in Neutron.\n        """'
newline|'\n'
name|'security_group_ids'
op|'='
op|'['
op|']'
newline|'\n'
comment|'# TODO(arosen) Should optimize more to do direct query for security'
nl|'\n'
comment|'# group if len(security_groups) == 1'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'security_groups'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'search_opts'
op|'='
op|'{'
string|"'tenant_id'"
op|':'
name|'instance'
op|'.'
name|'project_id'
op|'}'
newline|'\n'
name|'user_security_groups'
op|'='
name|'neutron'
op|'.'
name|'list_security_groups'
op|'('
nl|'\n'
op|'**'
name|'search_opts'
op|')'
op|'.'
name|'get'
op|'('
string|"'security_groups'"
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'security_group'
name|'in'
name|'security_groups'
op|':'
newline|'\n'
indent|'                '
name|'name_match'
op|'='
name|'None'
newline|'\n'
name|'uuid_match'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'user_security_group'
name|'in'
name|'user_security_groups'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'user_security_group'
op|'['
string|"'name'"
op|']'
op|'=='
name|'security_group'
op|':'
newline|'\n'
comment|'# If there was a name match in a previous iteration'
nl|'\n'
comment|'# of the loop, we have a conflict.'
nl|'\n'
indent|'                        '
name|'if'
name|'name_match'
op|':'
newline|'\n'
indent|'                            '
name|'raise'
name|'exception'
op|'.'
name|'NoUniqueMatch'
op|'('
nl|'\n'
name|'_'
op|'('
string|'"Multiple security groups found matching"'
nl|'\n'
string|'" \'%s\'. Use an ID to be more specific."'
op|')'
op|'%'
nl|'\n'
name|'security_group'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'name_match'
op|'='
name|'user_security_group'
op|'['
string|"'id'"
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'user_security_group'
op|'['
string|"'id'"
op|']'
op|'=='
name|'security_group'
op|':'
newline|'\n'
indent|'                        '
name|'uuid_match'
op|'='
name|'user_security_group'
op|'['
string|"'id'"
op|']'
newline|'\n'
nl|'\n'
comment|'# If a user names the security group the same as'
nl|'\n'
comment|"# another's security groups uuid, the name takes priority."
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'name_match'
op|':'
newline|'\n'
indent|'                    '
name|'security_group_ids'
op|'.'
name|'append'
op|'('
name|'name_match'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'uuid_match'
op|':'
newline|'\n'
indent|'                    '
name|'security_group_ids'
op|'.'
name|'append'
op|'('
name|'uuid_match'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'exception'
op|'.'
name|'SecurityGroupNotFound'
op|'('
nl|'\n'
name|'security_group_id'
op|'='
name|'security_group'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'security_group_ids'
newline|'\n'
nl|'\n'
DECL|member|allocate_for_instance
dedent|''
name|'def'
name|'allocate_for_instance'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Allocate network resources for the instance.\n\n        :param context: The request context.\n        :param instance: nova.objects.instance.Instance object.\n        :param requested_networks: optional value containing\n            network_id, fixed_ip, and port_id\n        :param security_groups: security groups to allocate for instance\n        :param macs: None or a set of MAC addresses that the instance\n            should use. macs is supplied by the hypervisor driver (contrast\n            with requested_networks which is user supplied).\n            NB: NeutronV2 currently assigns hypervisor supplied MAC addresses\n            to arbitrary networks, which requires openflow switches to\n            function correctly if more than one network is being used with\n            the bare metal hypervisor (which is the only one known to limit\n            MAC addresses).\n        :param dhcp_options: None or a set of key/value pairs that should\n            determine the DHCP BOOTP response, eg. for PXE booting an instance\n            configured with the baremetal hypervisor. It is expected that these\n            are already formatted for the neutron v2 api.\n            See nova/virt/driver.py:dhcp_options_for_instance for an example.\n        :param bind_host_id: the host ID to attach to the ports being created.\n        """'
newline|'\n'
name|'hypervisor_macs'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'macs'"
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
comment|'# The neutron client and port_client (either the admin context or'
nl|'\n'
comment|'# tenant context) are read here. The reason for this is that there are'
nl|'\n'
comment|'# a number of different calls for the instance allocation.'
nl|'\n'
comment|'# We do not want to create a new neutron session for each of these'
nl|'\n'
comment|'# calls.'
nl|'\n'
name|'neutron'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
comment|'# Requires admin creds to set port bindings'
nl|'\n'
name|'port_client'
op|'='
op|'('
name|'neutron'
name|'if'
name|'not'
nl|'\n'
name|'self'
op|'.'
name|'_has_port_binding_extension'
op|'('
name|'context'
op|','
nl|'\n'
name|'refresh_cache'
op|'='
name|'True'
op|','
name|'neutron'
op|'='
name|'neutron'
op|')'
name|'else'
nl|'\n'
name|'get_client'
op|'('
name|'context'
op|','
name|'admin'
op|'='
name|'True'
op|')'
op|')'
newline|'\n'
comment|'# Store the admin client - this is used later'
nl|'\n'
name|'admin_client'
op|'='
name|'port_client'
name|'if'
name|'neutron'
op|'!='
name|'port_client'
name|'else'
name|'None'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'allocate_for_instance()'"
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'instance'
op|'.'
name|'project_id'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|"'empty project id for instance %s'"
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InvalidInput'
op|'('
nl|'\n'
name|'reason'
op|'='
name|'msg'
op|'%'
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
dedent|''
name|'requested_networks'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'requested_networks'"
op|')'
newline|'\n'
name|'dhcp_opts'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'dhcp_options'"
op|','
name|'None'
op|')'
newline|'\n'
name|'bind_host_id'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'bind_host_id'"
op|')'
newline|'\n'
name|'ports'
op|','
name|'net_ids'
op|','
name|'ordered_networks'
op|','
name|'available_macs'
op|'='
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_process_requested_networks'
op|'('
name|'context'
op|','
nl|'\n'
name|'instance'
op|','
name|'neutron'
op|','
name|'requested_networks'
op|','
name|'hypervisor_macs'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'nets'
op|'='
name|'self'
op|'.'
name|'_get_available_networks'
op|'('
name|'context'
op|','
name|'instance'
op|'.'
name|'project_id'
op|','
nl|'\n'
name|'net_ids'
op|','
name|'neutron'
op|'='
name|'neutron'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'nets'
op|':'
newline|'\n'
comment|'# NOTE(chaochin): If user specifies a network id and the network'
nl|'\n'
comment|'# can not be found, raise NetworkNotFound error.'
nl|'\n'
indent|'            '
name|'if'
name|'requested_networks'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'request'
name|'in'
name|'requested_networks'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'not'
name|'request'
op|'.'
name|'port_id'
name|'and'
name|'request'
op|'.'
name|'network_id'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
name|'exception'
op|'.'
name|'NetworkNotFound'
op|'('
nl|'\n'
name|'network_id'
op|'='
name|'request'
op|'.'
name|'network_id'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"No network configured"'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'network_model'
op|'.'
name|'NetworkInfo'
op|'('
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# if this function is directly called without a requested_network param'
nl|'\n'
comment|'# or if it is indirectly called through allocate_port_for_instance()'
nl|'\n'
comment|'# with None params=(network_id=None, requested_ip=None, port_id=None,'
nl|'\n'
comment|'# pci_request_id=None):'
nl|'\n'
dedent|''
dedent|''
name|'if'
op|'('
name|'not'
name|'requested_networks'
nl|'\n'
name|'or'
name|'requested_networks'
op|'.'
name|'is_single_unspecified'
op|')'
op|':'
newline|'\n'
comment|'# bug/1267723 - if no network is requested and more'
nl|'\n'
comment|'# than one is available then raise NetworkAmbiguous Exception'
nl|'\n'
indent|'            '
name|'if'
name|'len'
op|'('
name|'nets'
op|')'
op|'>'
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
name|'_'
op|'('
string|'"Multiple possible networks found, use a Network "'
nl|'\n'
string|'"ID to be more specific."'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NetworkAmbiguous'
op|'('
name|'msg'
op|')'
newline|'\n'
dedent|''
name|'ordered_networks'
op|'.'
name|'append'
op|'('
nl|'\n'
name|'objects'
op|'.'
name|'NetworkRequest'
op|'('
name|'network_id'
op|'='
name|'nets'
op|'['
number|'0'
op|']'
op|'['
string|"'id'"
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(melwitt): check external net attach permission after the'
nl|'\n'
comment|'#                check for ambiguity, there could be another'
nl|'\n'
comment|'#                available net which is permitted bug/1364344'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_check_external_network_attach'
op|'('
name|'context'
op|','
name|'nets'
op|')'
newline|'\n'
nl|'\n'
name|'security_groups'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'security_groups'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'security_group_ids'
op|'='
name|'self'
op|'.'
name|'_process_security_groups'
op|'('
nl|'\n'
name|'instance'
op|','
name|'neutron'
op|','
name|'security_groups'
op|')'
newline|'\n'
nl|'\n'
name|'preexisting_port_ids'
op|'='
op|'['
op|']'
newline|'\n'
name|'created_port_ids'
op|'='
op|'['
op|']'
newline|'\n'
name|'ports_in_requested_order'
op|'='
op|'['
op|']'
newline|'\n'
name|'nets_in_requested_order'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'request'
name|'in'
name|'ordered_networks'
op|':'
newline|'\n'
comment|'# Network lookup for available network_id'
nl|'\n'
indent|'            '
name|'network'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'net'
name|'in'
name|'nets'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'net'
op|'['
string|"'id'"
op|']'
op|'=='
name|'request'
op|'.'
name|'network_id'
op|':'
newline|'\n'
indent|'                    '
name|'network'
op|'='
name|'net'
newline|'\n'
name|'break'
newline|'\n'
comment|'# if network_id did not pass validate_networks() and not available'
nl|'\n'
comment|'# here then skip it safely not continuing with a None Network'
nl|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'nets_in_requested_order'
op|'.'
name|'append'
op|'('
name|'network'
op|')'
newline|'\n'
comment|'# If security groups are requested on an instance then the'
nl|'\n'
comment|'# network must has a subnet associated with it. Some plugins'
nl|'\n'
comment|'# implement the port-security extension which requires'
nl|'\n'
comment|"# 'port_security_enabled' to be True for security groups."
nl|'\n'
comment|"# That is why True is returned if 'port_security_enabled'"
nl|'\n'
comment|'# is not found.'
nl|'\n'
name|'if'
op|'('
name|'security_groups'
name|'and'
name|'not'
op|'('
nl|'\n'
name|'network'
op|'['
string|"'subnets'"
op|']'
nl|'\n'
name|'and'
name|'network'
op|'.'
name|'get'
op|'('
string|"'port_security_enabled'"
op|','
name|'True'
op|')'
op|')'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'SecurityGroupCannotBeApplied'
op|'('
op|')'
newline|'\n'
dedent|''
name|'request'
op|'.'
name|'network_id'
op|'='
name|'network'
op|'['
string|"'id'"
op|']'
newline|'\n'
name|'zone'
op|'='
string|"'compute:%s'"
op|'%'
name|'instance'
op|'.'
name|'availability_zone'
newline|'\n'
name|'port_req_body'
op|'='
op|'{'
string|"'port'"
op|':'
op|'{'
string|"'device_id'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|','
nl|'\n'
string|"'device_owner'"
op|':'
name|'zone'
op|'}'
op|'}'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_populate_neutron_extension_values'
op|'('
nl|'\n'
name|'context'
op|','
name|'instance'
op|','
name|'request'
op|'.'
name|'pci_request_id'
op|','
name|'port_req_body'
op|','
nl|'\n'
name|'network'
op|'='
name|'network'
op|','
name|'neutron'
op|'='
name|'neutron'
op|','
nl|'\n'
name|'bind_host_id'
op|'='
name|'bind_host_id'
op|')'
newline|'\n'
name|'if'
name|'request'
op|'.'
name|'port_id'
op|':'
newline|'\n'
indent|'                    '
name|'port'
op|'='
name|'ports'
op|'['
name|'request'
op|'.'
name|'port_id'
op|']'
newline|'\n'
name|'port_client'
op|'.'
name|'update_port'
op|'('
name|'port'
op|'['
string|"'id'"
op|']'
op|','
name|'port_req_body'
op|')'
newline|'\n'
name|'preexisting_port_ids'
op|'.'
name|'append'
op|'('
name|'port'
op|'['
string|"'id'"
op|']'
op|')'
newline|'\n'
name|'ports_in_requested_order'
op|'.'
name|'append'
op|'('
name|'port'
op|'['
string|"'id'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'created_port'
op|'='
name|'self'
op|'.'
name|'_create_port'
op|'('
nl|'\n'
name|'port_client'
op|','
name|'instance'
op|','
name|'request'
op|'.'
name|'network_id'
op|','
nl|'\n'
name|'port_req_body'
op|','
name|'request'
op|'.'
name|'address'
op|','
nl|'\n'
name|'security_group_ids'
op|','
name|'available_macs'
op|','
name|'dhcp_opts'
op|')'
newline|'\n'
name|'created_port_ids'
op|'.'
name|'append'
op|'('
name|'created_port'
op|')'
newline|'\n'
name|'ports_in_requested_order'
op|'.'
name|'append'
op|'('
name|'created_port'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_update_port_dns_name'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network'
op|','
nl|'\n'
name|'ports_in_requested_order'
op|'['
op|'-'
number|'1'
op|']'
op|','
nl|'\n'
name|'neutron'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_unbind_ports'
op|'('
name|'context'
op|','
nl|'\n'
name|'preexisting_port_ids'
op|','
nl|'\n'
name|'neutron'
op|','
name|'port_client'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_delete_ports'
op|'('
name|'neutron'
op|','
name|'instance'
op|','
name|'created_port_ids'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'nw_info'
op|'='
name|'self'
op|'.'
name|'get_instance_nw_info'
op|'('
nl|'\n'
name|'context'
op|','
name|'instance'
op|','
name|'networks'
op|'='
name|'nets_in_requested_order'
op|','
nl|'\n'
name|'port_ids'
op|'='
name|'ports_in_requested_order'
op|','
nl|'\n'
name|'admin_client'
op|'='
name|'admin_client'
op|','
nl|'\n'
name|'preexisting_port_ids'
op|'='
name|'preexisting_port_ids'
op|','
nl|'\n'
name|'update_cells'
op|'='
name|'True'
op|')'
newline|'\n'
comment|'# NOTE(danms): Only return info about ports we created in this run.'
nl|'\n'
comment|'# In the initial allocation case, this will be everything we created,'
nl|'\n'
comment|'# and in later runs will only be what was created that time. Thus,'
nl|'\n'
comment|'# this only affects the attach case, not the original use for this'
nl|'\n'
comment|'# method.'
nl|'\n'
name|'return'
name|'network_model'
op|'.'
name|'NetworkInfo'
op|'('
op|'['
name|'vif'
name|'for'
name|'vif'
name|'in'
name|'nw_info'
nl|'\n'
name|'if'
name|'vif'
op|'['
string|"'id'"
op|']'
name|'in'
name|'created_port_ids'
op|'+'
nl|'\n'
name|'preexisting_port_ids'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_refresh_neutron_extensions_cache
dedent|''
name|'def'
name|'_refresh_neutron_extensions_cache'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'neutron'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Refresh the neutron extensions cache when necessary."""'
newline|'\n'
name|'if'
op|'('
name|'not'
name|'self'
op|'.'
name|'last_neutron_extension_sync'
name|'or'
nl|'\n'
op|'('
op|'('
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|'-'
name|'self'
op|'.'
name|'last_neutron_extension_sync'
op|')'
nl|'\n'
op|'>='
name|'CONF'
op|'.'
name|'neutron'
op|'.'
name|'extension_sync_interval'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'neutron'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'neutron'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
dedent|''
name|'extensions_list'
op|'='
name|'neutron'
op|'.'
name|'list_extensions'
op|'('
op|')'
op|'['
string|"'extensions'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'last_neutron_extension_sync'
op|'='
name|'time'
op|'.'
name|'time'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'extensions'
op|'.'
name|'clear'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'extensions'
op|'='
op|'{'
name|'ext'
op|'['
string|"'name'"
op|']'
op|':'
name|'ext'
name|'for'
name|'ext'
name|'in'
name|'extensions_list'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|_has_port_binding_extension
dedent|''
dedent|''
name|'def'
name|'_has_port_binding_extension'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'refresh_cache'
op|'='
name|'False'
op|','
nl|'\n'
name|'neutron'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'refresh_cache'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_refresh_neutron_extensions_cache'
op|'('
name|'context'
op|','
name|'neutron'
op|'='
name|'neutron'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'constants'
op|'.'
name|'PORTBINDING_EXT'
name|'in'
name|'self'
op|'.'
name|'extensions'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_populate_neutron_binding_profile
name|'def'
name|'_populate_neutron_binding_profile'
op|'('
name|'instance'
op|','
name|'pci_request_id'
op|','
nl|'\n'
name|'port_req_body'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Populate neutron binding:profile.\n\n        Populate it with SR-IOV related information\n        """'
newline|'\n'
name|'if'
name|'pci_request_id'
op|':'
newline|'\n'
indent|'            '
name|'pci_dev'
op|'='
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
nl|'\n'
name|'instance'
op|','
name|'pci_request_id'
op|')'
op|'.'
name|'pop'
op|'('
op|')'
newline|'\n'
name|'devspec'
op|'='
name|'pci_whitelist'
op|'.'
name|'get_pci_device_devspec'
op|'('
name|'pci_dev'
op|')'
newline|'\n'
name|'profile'
op|'='
op|'{'
string|"'pci_vendor_info'"
op|':'
string|'"%s:%s"'
op|'%'
op|'('
name|'pci_dev'
op|'.'
name|'vendor_id'
op|','
nl|'\n'
name|'pci_dev'
op|'.'
name|'product_id'
op|')'
op|','
nl|'\n'
string|"'pci_slot'"
op|':'
name|'pci_dev'
op|'.'
name|'address'
op|','
nl|'\n'
string|"'physical_network'"
op|':'
nl|'\n'
name|'devspec'
op|'.'
name|'get_tags'
op|'('
op|')'
op|'.'
name|'get'
op|'('
string|"'physical_network'"
op|')'
nl|'\n'
op|'}'
newline|'\n'
name|'port_req_body'
op|'['
string|"'port'"
op|']'
op|'['
string|"'binding:profile'"
op|']'
op|'='
name|'profile'
newline|'\n'
nl|'\n'
DECL|member|_populate_neutron_extension_values
dedent|''
dedent|''
name|'def'
name|'_populate_neutron_extension_values'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'pci_request_id'
op|','
name|'port_req_body'
op|','
nl|'\n'
name|'network'
op|'='
name|'None'
op|','
name|'neutron'
op|'='
name|'None'
op|','
nl|'\n'
name|'bind_host_id'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Populate neutron extension values for the instance.\n\n        If the extensions loaded contain QOS_QUEUE then pass the rxtx_factor.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_refresh_neutron_extensions_cache'
op|'('
name|'context'
op|','
name|'neutron'
op|'='
name|'neutron'
op|')'
newline|'\n'
name|'if'
name|'constants'
op|'.'
name|'QOS_QUEUE'
name|'in'
name|'self'
op|'.'
name|'extensions'
op|':'
newline|'\n'
indent|'            '
name|'flavor'
op|'='
name|'instance'
op|'.'
name|'get_flavor'
op|'('
op|')'
newline|'\n'
name|'rxtx_factor'
op|'='
name|'flavor'
op|'.'
name|'get'
op|'('
string|"'rxtx_factor'"
op|')'
newline|'\n'
name|'port_req_body'
op|'['
string|"'port'"
op|']'
op|'['
string|"'rxtx_factor'"
op|']'
op|'='
name|'rxtx_factor'
newline|'\n'
dedent|''
name|'has_port_binding_extension'
op|'='
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_has_port_binding_extension'
op|'('
name|'context'
op|','
name|'neutron'
op|'='
name|'neutron'
op|')'
op|')'
newline|'\n'
name|'if'
name|'has_port_binding_extension'
op|':'
newline|'\n'
indent|'            '
name|'port_req_body'
op|'['
string|"'port'"
op|']'
op|'['
string|"'binding:host_id'"
op|']'
op|'='
name|'bind_host_id'
newline|'\n'
name|'self'
op|'.'
name|'_populate_neutron_binding_profile'
op|'('
name|'instance'
op|','
nl|'\n'
name|'pci_request_id'
op|','
nl|'\n'
name|'port_req_body'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'constants'
op|'.'
name|'DNS_INTEGRATION'
name|'in'
name|'self'
op|'.'
name|'extensions'
op|':'
newline|'\n'
comment|'# If the DNS integration extension is enabled in Neutron, most'
nl|'\n'
comment|'# ports will get their dns_name attribute set in the port create or'
nl|'\n'
comment|'# update requests in allocate_for_instance. So we just add the'
nl|'\n'
comment|'# dns_name attribute to the payload of those requests. The'
nl|'\n'
comment|'# exception is when the port binding extension is enabled in'
nl|'\n'
comment|'# Neutron and the port is on a network that has a non-blank'
nl|'\n'
comment|'# dns_domain attribute. This case requires to be processed by'
nl|'\n'
comment|'# method _update_port_dns_name'
nl|'\n'
indent|'            '
name|'if'
op|'('
name|'not'
name|'has_port_binding_extension'
nl|'\n'
name|'or'
name|'not'
name|'network'
op|'.'
name|'get'
op|'('
string|"'dns_domain'"
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'port_req_body'
op|'['
string|"'port'"
op|']'
op|'['
string|"'dns_name'"
op|']'
op|'='
name|'instance'
op|'.'
name|'hostname'
newline|'\n'
nl|'\n'
DECL|member|_update_port_dns_name
dedent|''
dedent|''
dedent|''
name|'def'
name|'_update_port_dns_name'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network'
op|','
name|'port_id'
op|','
nl|'\n'
name|'neutron'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Update an instance port dns_name attribute with instance.hostname.\n\n        The dns_name attribute of a port on a network with a non-blank\n        dns_domain attribute will be sent to the external DNS service\n        (Designate) if DNS integration is enabled in Neutron. This requires the\n        assignment of the dns_name to the port to be done with a Neutron client\n        using the user\'s context. allocate_for_instance uses a port with admin\n        context if the port binding extensions is enabled in Neutron. In this\n        case, we assign in this method the dns_name attribute to the port with\n        an additional update request. Only a very small fraction of ports will\n        require this additional update request.\n        """'
newline|'\n'
name|'if'
op|'('
name|'constants'
op|'.'
name|'DNS_INTEGRATION'
name|'in'
name|'self'
op|'.'
name|'extensions'
name|'and'
nl|'\n'
name|'self'
op|'.'
name|'_has_port_binding_extension'
op|'('
name|'context'
op|')'
name|'and'
nl|'\n'
name|'network'
op|'.'
name|'get'
op|'('
string|"'dns_domain'"
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'port_req_body'
op|'='
op|'{'
string|"'port'"
op|':'
op|'{'
string|"'dns_name'"
op|':'
name|'instance'
op|'.'
name|'hostname'
op|'}'
op|'}'
newline|'\n'
name|'neutron'
op|'.'
name|'update_port'
op|'('
name|'port_id'
op|','
name|'port_req_body'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'neutron_client_exc'
op|'.'
name|'BadRequest'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|"'Neutron error: Instance hostname '"
nl|'\n'
string|"'%(hostname)s is not a valid DNS name'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'hostname'"
op|':'
name|'instance'
op|'.'
name|'hostname'
op|'}'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|"'Instance hostname %(hostname)s is not a valid DNS '"
nl|'\n'
string|"'name'"
op|')'
op|'%'
op|'{'
string|"'hostname'"
op|':'
name|'instance'
op|'.'
name|'hostname'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InvalidInput'
op|'('
name|'reason'
op|'='
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_delete_ports
dedent|''
dedent|''
dedent|''
name|'def'
name|'_delete_ports'
op|'('
name|'self'
op|','
name|'neutron'
op|','
name|'instance'
op|','
name|'ports'
op|','
name|'raise_if_fail'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'exceptions'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'port'
name|'in'
name|'ports'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'neutron'
op|'.'
name|'delete_port'
op|'('
name|'port'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'neutron_client_exc'
op|'.'
name|'NeutronClientException'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'e'
op|'.'
name|'status_code'
op|'=='
number|'404'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"Port %s does not exist"'
op|')'
op|','
name|'port'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'exceptions'
op|'.'
name|'append'
op|'('
name|'e'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'warning'
op|'('
nl|'\n'
name|'_LW'
op|'('
string|'"Failed to delete port %s for instance."'
op|')'
op|','
nl|'\n'
name|'port'
op|','
name|'instance'
op|'='
name|'instance'
op|','
name|'exc_info'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'len'
op|'('
name|'exceptions'
op|')'
op|'>'
number|'0'
name|'and'
name|'raise_if_fail'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exceptions'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
DECL|member|deallocate_for_instance
dedent|''
dedent|''
name|'def'
name|'deallocate_for_instance'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Deallocate all network resources related to the instance."""'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'deallocate_for_instance()'"
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'search_opts'
op|'='
op|'{'
string|"'device_id'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|'}'
newline|'\n'
name|'neutron'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
name|'data'
op|'='
name|'neutron'
op|'.'
name|'list_ports'
op|'('
op|'**'
name|'search_opts'
op|')'
newline|'\n'
name|'ports'
op|'='
op|'['
name|'port'
op|'['
string|"'id'"
op|']'
name|'for'
name|'port'
name|'in'
name|'data'
op|'.'
name|'get'
op|'('
string|"'ports'"
op|','
op|'['
op|']'
op|')'
op|']'
newline|'\n'
nl|'\n'
name|'requested_networks'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'requested_networks'"
op|')'
name|'or'
op|'['
op|']'
newline|'\n'
comment|'# NOTE(danms): Temporary and transitional'
nl|'\n'
name|'if'
name|'isinstance'
op|'('
name|'requested_networks'
op|','
name|'objects'
op|'.'
name|'NetworkRequestList'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'requested_networks'
op|'='
name|'requested_networks'
op|'.'
name|'as_tuples'
op|'('
op|')'
newline|'\n'
dedent|''
name|'ports_to_skip'
op|'='
name|'set'
op|'('
op|'['
name|'port_id'
name|'for'
name|'nets'
op|','
name|'fips'
op|','
name|'port_id'
op|','
name|'pci_request_id'
nl|'\n'
name|'in'
name|'requested_networks'
op|']'
op|')'
newline|'\n'
comment|'# NOTE(boden): requested_networks only passed in when deallocating'
nl|'\n'
comment|'# from a failed build / spawn call. Therefore we need to include'
nl|'\n'
comment|'# preexisting ports when deallocating from a standard delete op'
nl|'\n'
comment|'# in which case requested_networks is not provided.'
nl|'\n'
name|'ports_to_skip'
op|'|='
name|'set'
op|'('
name|'self'
op|'.'
name|'_get_preexisting_port_ids'
op|'('
name|'instance'
op|')'
op|')'
newline|'\n'
name|'ports'
op|'='
name|'set'
op|'('
name|'ports'
op|')'
op|'-'
name|'ports_to_skip'
newline|'\n'
nl|'\n'
comment|'# Reset device_id and device_owner for the ports that are skipped'
nl|'\n'
name|'self'
op|'.'
name|'_unbind_ports'
op|'('
name|'context'
op|','
name|'ports_to_skip'
op|','
name|'neutron'
op|')'
newline|'\n'
comment|'# Delete the rest of the ports'
nl|'\n'
name|'self'
op|'.'
name|'_delete_ports'
op|'('
name|'neutron'
op|','
name|'instance'
op|','
name|'ports'
op|','
name|'raise_if_fail'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(arosen): This clears out the network_cache only if the instance'
nl|'\n'
comment|"# hasn't already been deleted. This is needed when an instance fails to"
nl|'\n'
comment|'# launch and is rescheduled onto another compute node. If the instance'
nl|'\n'
comment|'# has already been deleted this call does nothing.'
nl|'\n'
name|'base_api'
op|'.'
name|'update_instance_cache_with_nw_info'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'network_model'
op|'.'
name|'NetworkInfo'
op|'('
op|'['
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|allocate_port_for_instance
dedent|''
name|'def'
name|'allocate_port_for_instance'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'port_id'
op|','
nl|'\n'
name|'network_id'
op|'='
name|'None'
op|','
name|'requested_ip'
op|'='
name|'None'
op|','
nl|'\n'
name|'bind_host_id'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Allocate a port for the instance."""'
newline|'\n'
name|'requested_networks'
op|'='
name|'objects'
op|'.'
name|'NetworkRequestList'
op|'('
nl|'\n'
name|'objects'
op|'='
op|'['
name|'objects'
op|'.'
name|'NetworkRequest'
op|'('
name|'network_id'
op|'='
name|'network_id'
op|','
nl|'\n'
name|'address'
op|'='
name|'requested_ip'
op|','
nl|'\n'
name|'port_id'
op|'='
name|'port_id'
op|','
nl|'\n'
name|'pci_request_id'
op|'='
name|'None'
op|')'
op|']'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'allocate_for_instance'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'requested_networks'
op|'='
name|'requested_networks'
op|','
nl|'\n'
name|'bind_host_id'
op|'='
name|'bind_host_id'
op|')'
newline|'\n'
nl|'\n'
DECL|member|deallocate_port_for_instance
dedent|''
name|'def'
name|'deallocate_port_for_instance'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'port_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Remove a specified port from the instance.\n\n        Return network information for the instance\n        """'
newline|'\n'
name|'neutron'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
name|'preexisting_ports'
op|'='
name|'self'
op|'.'
name|'_get_preexisting_port_ids'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'port_id'
name|'in'
name|'preexisting_ports'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_unbind_ports'
op|'('
name|'context'
op|','
op|'['
name|'port_id'
op|']'
op|','
name|'neutron'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_delete_ports'
op|'('
name|'neutron'
op|','
name|'instance'
op|','
op|'['
name|'port_id'
op|']'
op|','
nl|'\n'
name|'raise_if_fail'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'get_instance_nw_info'
op|'('
name|'context'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|list_ports
dedent|''
name|'def'
name|'list_ports'
op|'('
name|'self'
op|','
name|'context'
op|','
op|'**'
name|'search_opts'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""List ports for the client based on search options."""'
newline|'\n'
name|'return'
name|'get_client'
op|'('
name|'context'
op|')'
op|'.'
name|'list_ports'
op|'('
op|'**'
name|'search_opts'
op|')'
newline|'\n'
nl|'\n'
DECL|member|show_port
dedent|''
name|'def'
name|'show_port'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'port_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the port for the client given the port id.\n\n        :param context: Request context.\n        :param port_id: The id of port to be queried.\n        :returns: A dict containing port data keyed by \'port\', e.g.\n\n        ::\n\n            {\'port\': {\'port_id\': \'abcd\',\n                      \'fixed_ip_address\': \'1.2.3.4\'}}\n        """'
newline|'\n'
name|'return'
name|'dict'
op|'('
name|'port'
op|'='
name|'self'
op|'.'
name|'_show_port'
op|'('
name|'context'
op|','
name|'port_id'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_show_port
dedent|''
name|'def'
name|'_show_port'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'port_id'
op|','
name|'neutron_client'
op|'='
name|'None'
op|','
name|'fields'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the port for the client given the port id.\n\n        :param context: Request context.\n        :param port_id: The id of port to be queried.\n        :param neutron_client: A neutron client.\n        :param fields: The condition fields to query port data.\n        :returns: A dict of port data.\n                  e.g. {\'port_id\': \'abcd\', \'fixed_ip_address\': \'1.2.3.4\'}\n        """'
newline|'\n'
name|'if'
name|'not'
name|'neutron_client'
op|':'
newline|'\n'
indent|'            '
name|'neutron_client'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'fields'
op|':'
newline|'\n'
indent|'                '
name|'result'
op|'='
name|'neutron_client'
op|'.'
name|'show_port'
op|'('
name|'port_id'
op|','
name|'fields'
op|'='
name|'fields'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'result'
op|'='
name|'neutron_client'
op|'.'
name|'show_port'
op|'('
name|'port_id'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'result'
op|'.'
name|'get'
op|'('
string|"'port'"
op|')'
newline|'\n'
dedent|''
name|'except'
name|'neutron_client_exc'
op|'.'
name|'PortNotFoundClient'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'PortNotFound'
op|'('
name|'port_id'
op|'='
name|'port_id'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'neutron_client_exc'
op|'.'
name|'Unauthorized'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'Forbidden'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'neutron_client_exc'
op|'.'
name|'NeutronClientException'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|'"Failed to access port %(port_id)s: %(reason)s"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'port_id'"
op|':'
name|'port_id'
op|','
string|"'reason'"
op|':'
name|'exc'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'message'
op|'='
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_instance_nw_info
dedent|''
dedent|''
name|'def'
name|'_get_instance_nw_info'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'networks'
op|'='
name|'None'
op|','
nl|'\n'
name|'port_ids'
op|'='
name|'None'
op|','
name|'admin_client'
op|'='
name|'None'
op|','
nl|'\n'
name|'preexisting_port_ids'
op|'='
name|'None'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(danms): This is an inner method intended to be called'
nl|'\n'
comment|'# by other code that updates instance nwinfo. It *must* be'
nl|'\n'
comment|'# called with the refresh_cache-%(instance_uuid) lock held!'
nl|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'_get_instance_nw_info()'"
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
comment|'# Ensure that we have an up to date copy of the instance info cache.'
nl|'\n'
comment|'# Otherwise multiple requests could collide and cause cache'
nl|'\n'
comment|'# corruption.'
nl|'\n'
name|'compute_utils'
op|'.'
name|'refresh_info_cache_for_instance'
op|'('
name|'context'
op|','
name|'instance'
op|')'
newline|'\n'
name|'nw_info'
op|'='
name|'self'
op|'.'
name|'_build_network_info_model'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'networks'
op|','
nl|'\n'
name|'port_ids'
op|','
name|'admin_client'
op|','
nl|'\n'
name|'preexisting_port_ids'
op|')'
newline|'\n'
name|'return'
name|'network_model'
op|'.'
name|'NetworkInfo'
op|'.'
name|'hydrate'
op|'('
name|'nw_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_gather_port_ids_and_networks
dedent|''
name|'def'
name|'_gather_port_ids_and_networks'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'networks'
op|'='
name|'None'
op|','
nl|'\n'
name|'port_ids'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return an instance\'s complete list of port_ids and networks."""'
newline|'\n'
nl|'\n'
name|'if'
op|'('
op|'('
name|'networks'
name|'is'
name|'None'
name|'and'
name|'port_ids'
name|'is'
name|'not'
name|'None'
op|')'
name|'or'
nl|'\n'
op|'('
name|'port_ids'
name|'is'
name|'None'
name|'and'
name|'networks'
name|'is'
name|'not'
name|'None'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'message'
op|'='
name|'_'
op|'('
string|'"This method needs to be called with either "'
nl|'\n'
string|'"networks=None and port_ids=None or port_ids and "'
nl|'\n'
string|'"networks as not none."'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'message'
op|'='
name|'message'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'ifaces'
op|'='
name|'compute_utils'
op|'.'
name|'get_nw_info_for_instance'
op|'('
name|'instance'
op|')'
newline|'\n'
comment|'# This code path is only done when refreshing the network_cache'
nl|'\n'
name|'if'
name|'port_ids'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'port_ids'
op|'='
op|'['
name|'iface'
op|'['
string|"'id'"
op|']'
name|'for'
name|'iface'
name|'in'
name|'ifaces'
op|']'
newline|'\n'
name|'net_ids'
op|'='
op|'['
name|'iface'
op|'['
string|"'network'"
op|']'
op|'['
string|"'id'"
op|']'
name|'for'
name|'iface'
name|'in'
name|'ifaces'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'networks'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'networks'
op|'='
name|'self'
op|'.'
name|'_get_available_networks'
op|'('
name|'context'
op|','
nl|'\n'
name|'instance'
op|'.'
name|'project_id'
op|','
nl|'\n'
name|'net_ids'
op|')'
newline|'\n'
comment|'# an interface was added/removed from instance.'
nl|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
nl|'\n'
comment|'# Prepare the network ids list for validation purposes'
nl|'\n'
indent|'            '
name|'networks_ids'
op|'='
op|'['
name|'network'
op|'['
string|"'id'"
op|']'
name|'for'
name|'network'
name|'in'
name|'networks'
op|']'
newline|'\n'
nl|'\n'
comment|"# Validate that interface networks doesn't exist in networks."
nl|'\n'
comment|'# Though this issue can and should be solved in methods'
nl|'\n'
comment|'# that prepare the networks list, this method should have this'
nl|'\n'
comment|'# ignore-duplicate-networks/port-ids mechanism to reduce the'
nl|'\n'
comment|'# probability of failing to boot the VM.'
nl|'\n'
name|'networks'
op|'='
name|'networks'
op|'+'
op|'['
nl|'\n'
op|'{'
string|"'id'"
op|':'
name|'iface'
op|'['
string|"'network'"
op|']'
op|'['
string|"'id'"
op|']'
op|','
nl|'\n'
string|"'name'"
op|':'
name|'iface'
op|'['
string|"'network'"
op|']'
op|'['
string|"'label'"
op|']'
op|','
nl|'\n'
string|"'tenant_id'"
op|':'
name|'iface'
op|'['
string|"'network'"
op|']'
op|'['
string|"'meta'"
op|']'
op|'['
string|"'tenant_id'"
op|']'
op|'}'
nl|'\n'
name|'for'
name|'iface'
name|'in'
name|'ifaces'
nl|'\n'
name|'if'
name|'_is_not_duplicate'
op|'('
name|'iface'
op|'['
string|"'network'"
op|']'
op|'['
string|"'id'"
op|']'
op|','
nl|'\n'
name|'networks_ids'
op|','
nl|'\n'
string|'"networks"'
op|','
nl|'\n'
name|'instance'
op|')'
op|']'
newline|'\n'
nl|'\n'
comment|'# Include existing interfaces so they are not removed from the db.'
nl|'\n'
comment|'# Validate that the interface id is not in the port_ids'
nl|'\n'
name|'port_ids'
op|'='
op|'['
name|'iface'
op|'['
string|"'id'"
op|']'
name|'for'
name|'iface'
name|'in'
name|'ifaces'
nl|'\n'
name|'if'
name|'_is_not_duplicate'
op|'('
name|'iface'
op|'['
string|"'id'"
op|']'
op|','
nl|'\n'
name|'port_ids'
op|','
nl|'\n'
string|'"port_ids"'
op|','
nl|'\n'
name|'instance'
op|')'
op|']'
op|'+'
name|'port_ids'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'networks'
op|','
name|'port_ids'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'base_api'
op|'.'
name|'refresh_cache'
newline|'\n'
DECL|member|add_fixed_ip_to_instance
name|'def'
name|'add_fixed_ip_to_instance'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Add a fixed IP to the instance from specified network."""'
newline|'\n'
name|'neutron'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
name|'search_opts'
op|'='
op|'{'
string|"'network_id'"
op|':'
name|'network_id'
op|'}'
newline|'\n'
name|'data'
op|'='
name|'neutron'
op|'.'
name|'list_subnets'
op|'('
op|'**'
name|'search_opts'
op|')'
newline|'\n'
name|'ipam_subnets'
op|'='
name|'data'
op|'.'
name|'get'
op|'('
string|"'subnets'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'ipam_subnets'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'NetworkNotFoundForInstance'
op|'('
nl|'\n'
name|'instance_id'
op|'='
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'zone'
op|'='
string|"'compute:%s'"
op|'%'
name|'instance'
op|'.'
name|'availability_zone'
newline|'\n'
name|'search_opts'
op|'='
op|'{'
string|"'device_id'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|','
nl|'\n'
string|"'device_owner'"
op|':'
name|'zone'
op|','
nl|'\n'
string|"'network_id'"
op|':'
name|'network_id'
op|'}'
newline|'\n'
name|'data'
op|'='
name|'neutron'
op|'.'
name|'list_ports'
op|'('
op|'**'
name|'search_opts'
op|')'
newline|'\n'
name|'ports'
op|'='
name|'data'
op|'['
string|"'ports'"
op|']'
newline|'\n'
name|'for'
name|'p'
name|'in'
name|'ports'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'subnet'
name|'in'
name|'ipam_subnets'
op|':'
newline|'\n'
indent|'                '
name|'fixed_ips'
op|'='
name|'p'
op|'['
string|"'fixed_ips'"
op|']'
newline|'\n'
name|'fixed_ips'
op|'.'
name|'append'
op|'('
op|'{'
string|"'subnet_id'"
op|':'
name|'subnet'
op|'['
string|"'id'"
op|']'
op|'}'
op|')'
newline|'\n'
name|'port_req_body'
op|'='
op|'{'
string|"'port'"
op|':'
op|'{'
string|"'fixed_ips'"
op|':'
name|'fixed_ips'
op|'}'
op|'}'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'neutron'
op|'.'
name|'update_port'
op|'('
name|'p'
op|'['
string|"'id'"
op|']'
op|','
name|'port_req_body'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_get_instance_nw_info'
op|'('
name|'context'
op|','
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'                    '
name|'msg'
op|'='
op|'('
string|'"Unable to update port %(portid)s on subnet "'
nl|'\n'
string|'"%(subnet_id)s with failure: %(exception)s"'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'msg'
op|','
op|'{'
string|"'portid'"
op|':'
name|'p'
op|'['
string|"'id'"
op|']'
op|','
nl|'\n'
string|"'subnet_id'"
op|':'
name|'subnet'
op|'['
string|"'id'"
op|']'
op|','
nl|'\n'
string|"'exception'"
op|':'
name|'ex'
op|'}'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'NetworkNotFoundForInstance'
op|'('
nl|'\n'
name|'instance_id'
op|'='
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'base_api'
op|'.'
name|'refresh_cache'
newline|'\n'
DECL|member|remove_fixed_ip_from_instance
name|'def'
name|'remove_fixed_ip_from_instance'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'address'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Remove a fixed IP from the instance."""'
newline|'\n'
name|'neutron'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
name|'zone'
op|'='
string|"'compute:%s'"
op|'%'
name|'instance'
op|'.'
name|'availability_zone'
newline|'\n'
name|'search_opts'
op|'='
op|'{'
string|"'device_id'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|','
nl|'\n'
string|"'device_owner'"
op|':'
name|'zone'
op|','
nl|'\n'
string|"'fixed_ips'"
op|':'
string|"'ip_address=%s'"
op|'%'
name|'address'
op|'}'
newline|'\n'
name|'data'
op|'='
name|'neutron'
op|'.'
name|'list_ports'
op|'('
op|'**'
name|'search_opts'
op|')'
newline|'\n'
name|'ports'
op|'='
name|'data'
op|'['
string|"'ports'"
op|']'
newline|'\n'
name|'for'
name|'p'
name|'in'
name|'ports'
op|':'
newline|'\n'
indent|'            '
name|'fixed_ips'
op|'='
name|'p'
op|'['
string|"'fixed_ips'"
op|']'
newline|'\n'
name|'new_fixed_ips'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'fixed_ip'
name|'in'
name|'fixed_ips'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'fixed_ip'
op|'['
string|"'ip_address'"
op|']'
op|'!='
name|'address'
op|':'
newline|'\n'
indent|'                    '
name|'new_fixed_ips'
op|'.'
name|'append'
op|'('
name|'fixed_ip'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'port_req_body'
op|'='
op|'{'
string|"'port'"
op|':'
op|'{'
string|"'fixed_ips'"
op|':'
name|'new_fixed_ips'
op|'}'
op|'}'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'neutron'
op|'.'
name|'update_port'
op|'('
name|'p'
op|'['
string|"'id'"
op|']'
op|','
name|'port_req_body'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
op|'('
string|'"Unable to update port %(portid)s with"'
nl|'\n'
string|'" failure: %(exception)s"'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'msg'
op|','
op|'{'
string|"'portid'"
op|':'
name|'p'
op|'['
string|"'id'"
op|']'
op|','
string|"'exception'"
op|':'
name|'ex'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_get_instance_nw_info'
op|'('
name|'context'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'FixedIpNotFoundForSpecificInstance'
op|'('
nl|'\n'
name|'instance_uuid'
op|'='
name|'instance'
op|'.'
name|'uuid'
op|','
name|'ip'
op|'='
name|'address'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_port_vnic_info
dedent|''
name|'def'
name|'_get_port_vnic_info'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'neutron'
op|','
name|'port_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve port vnic info\n\n        Invoked with a valid port_id.\n        Return vnic type and the attached physical network name.\n        """'
newline|'\n'
name|'phynet_name'
op|'='
name|'None'
newline|'\n'
name|'port'
op|'='
name|'self'
op|'.'
name|'_show_port'
op|'('
name|'context'
op|','
name|'port_id'
op|','
name|'neutron_client'
op|'='
name|'neutron'
op|','
nl|'\n'
name|'fields'
op|'='
op|'['
string|"'binding:vnic_type'"
op|','
string|"'network_id'"
op|']'
op|')'
newline|'\n'
name|'vnic_type'
op|'='
name|'port'
op|'.'
name|'get'
op|'('
string|"'binding:vnic_type'"
op|','
nl|'\n'
name|'network_model'
op|'.'
name|'VNIC_TYPE_NORMAL'
op|')'
newline|'\n'
name|'if'
name|'vnic_type'
name|'in'
name|'network_model'
op|'.'
name|'VNIC_TYPES_SRIOV'
op|':'
newline|'\n'
indent|'            '
name|'net_id'
op|'='
name|'port'
op|'['
string|"'network_id'"
op|']'
newline|'\n'
name|'net'
op|'='
name|'neutron'
op|'.'
name|'show_network'
op|'('
name|'net_id'
op|','
nl|'\n'
name|'fields'
op|'='
string|"'provider:physical_network'"
op|')'
op|'.'
name|'get'
op|'('
string|"'network'"
op|')'
newline|'\n'
name|'phynet_name'
op|'='
name|'net'
op|'.'
name|'get'
op|'('
string|"'provider:physical_network'"
op|')'
newline|'\n'
dedent|''
name|'return'
name|'vnic_type'
op|','
name|'phynet_name'
newline|'\n'
nl|'\n'
DECL|member|create_pci_requests_for_sriov_ports
dedent|''
name|'def'
name|'create_pci_requests_for_sriov_ports'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'pci_requests'
op|','
nl|'\n'
name|'requested_networks'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check requested networks for any SR-IOV port request.\n\n        Create a PCI request object for each SR-IOV port, and add it to the\n        pci_requests object that contains a list of PCI request object.\n        """'
newline|'\n'
name|'if'
name|'not'
name|'requested_networks'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'neutron'
op|'='
name|'get_client'
op|'('
name|'context'
op|','
name|'admin'
op|'='
name|'True'
op|')'
newline|'\n'
name|'for'
name|'request_net'
name|'in'
name|'requested_networks'
op|':'
newline|'\n'
indent|'            '
name|'phynet_name'
op|'='
name|'None'
newline|'\n'
name|'vnic_type'
op|'='
name|'network_model'
op|'.'
name|'VNIC_TYPE_NORMAL'
newline|'\n'
nl|'\n'
name|'if'
name|'request_net'
op|'.'
name|'port_id'
op|':'
newline|'\n'
indent|'                '
name|'vnic_type'
op|','
name|'phynet_name'
op|'='
name|'self'
op|'.'
name|'_get_port_vnic_info'
op|'('
nl|'\n'
name|'context'
op|','
name|'neutron'
op|','
name|'request_net'
op|'.'
name|'port_id'
op|')'
newline|'\n'
dedent|''
name|'pci_request_id'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'vnic_type'
name|'in'
name|'network_model'
op|'.'
name|'VNIC_TYPES_SRIOV'
op|':'
newline|'\n'
indent|'                '
name|'request'
op|'='
name|'objects'
op|'.'
name|'InstancePCIRequest'
op|'('
nl|'\n'
name|'count'
op|'='
number|'1'
op|','
nl|'\n'
name|'spec'
op|'='
op|'['
op|'{'
name|'pci_request'
op|'.'
name|'PCI_NET_TAG'
op|':'
name|'phynet_name'
op|'}'
op|']'
op|','
nl|'\n'
name|'request_id'
op|'='
name|'str'
op|'('
name|'uuid'
op|'.'
name|'uuid4'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
name|'pci_requests'
op|'.'
name|'requests'
op|'.'
name|'append'
op|'('
name|'request'
op|')'
newline|'\n'
name|'pci_request_id'
op|'='
name|'request'
op|'.'
name|'request_id'
newline|'\n'
nl|'\n'
comment|'# Add pci_request_id into the requested network'
nl|'\n'
dedent|''
name|'request_net'
op|'.'
name|'pci_request_id'
op|'='
name|'pci_request_id'
newline|'\n'
nl|'\n'
DECL|member|_ports_needed_per_instance
dedent|''
dedent|''
name|'def'
name|'_ports_needed_per_instance'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'neutron'
op|','
name|'requested_networks'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'ports_needed_per_instance'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'requested_networks'
name|'is'
name|'None'
name|'or'
name|'len'
op|'('
name|'requested_networks'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'nets'
op|'='
name|'self'
op|'.'
name|'_get_available_networks'
op|'('
name|'context'
op|','
name|'context'
op|'.'
name|'project_id'
op|','
nl|'\n'
name|'neutron'
op|'='
name|'neutron'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'nets'
op|')'
op|'>'
number|'1'
op|':'
newline|'\n'
comment|"# Attaching to more than one network by default doesn't"
nl|'\n'
comment|'# make sense, as the order will be arbitrary and the guest OS'
nl|'\n'
comment|"# won't know which to configure"
nl|'\n'
indent|'                '
name|'msg'
op|'='
name|'_'
op|'('
string|'"Multiple possible networks found, use a Network "'
nl|'\n'
string|'"ID to be more specific."'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NetworkAmbiguous'
op|'('
name|'msg'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'ports_needed_per_instance'
op|'='
number|'1'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'net_ids_requested'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
comment|'# TODO(danms): Remove me when all callers pass an object'
nl|'\n'
name|'if'
name|'isinstance'
op|'('
name|'requested_networks'
op|'['
number|'0'
op|']'
op|','
name|'tuple'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'requested_networks'
op|'='
name|'objects'
op|'.'
name|'NetworkRequestList'
op|'('
nl|'\n'
name|'objects'
op|'='
op|'['
name|'objects'
op|'.'
name|'NetworkRequest'
op|'.'
name|'from_tuple'
op|'('
name|'t'
op|')'
nl|'\n'
name|'for'
name|'t'
name|'in'
name|'requested_networks'
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'request'
name|'in'
name|'requested_networks'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'request'
op|'.'
name|'port_id'
op|':'
newline|'\n'
indent|'                    '
name|'port'
op|'='
name|'self'
op|'.'
name|'_show_port'
op|'('
name|'context'
op|','
name|'request'
op|'.'
name|'port_id'
op|','
nl|'\n'
name|'neutron_client'
op|'='
name|'neutron'
op|')'
newline|'\n'
name|'if'
name|'port'
op|'.'
name|'get'
op|'('
string|"'device_id'"
op|','
name|'None'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
name|'exception'
op|'.'
name|'PortInUse'
op|'('
name|'port_id'
op|'='
name|'request'
op|'.'
name|'port_id'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'port'
op|'.'
name|'get'
op|'('
string|"'fixed_ips'"
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
name|'exception'
op|'.'
name|'PortRequiresFixedIP'
op|'('
nl|'\n'
name|'port_id'
op|'='
name|'request'
op|'.'
name|'port_id'
op|')'
newline|'\n'
dedent|''
name|'request'
op|'.'
name|'network_id'
op|'='
name|'port'
op|'['
string|"'network_id'"
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'ports_needed_per_instance'
op|'+='
number|'1'
newline|'\n'
name|'net_ids_requested'
op|'.'
name|'append'
op|'('
name|'request'
op|'.'
name|'network_id'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(jecarey) There is currently a race condition.'
nl|'\n'
comment|'# That is, if you have more than one request for a specific'
nl|'\n'
comment|'# fixed IP at the same time then only one will be allocated'
nl|'\n'
comment|'# the ip. The fixed IP will be allocated to only one of the'
nl|'\n'
comment|'# instances that will run. The second instance will fail on'
nl|'\n'
comment|'# spawn. That instance will go into error state.'
nl|'\n'
comment|'# TODO(jecarey) Need to address this race condition once we'
nl|'\n'
comment|'# have the ability to update mac addresses in Neutron.'
nl|'\n'
name|'if'
name|'request'
op|'.'
name|'address'
op|':'
newline|'\n'
comment|'# TODO(jecarey) Need to look at consolidating list_port'
nl|'\n'
comment|'# calls once able to OR filters.'
nl|'\n'
indent|'                        '
name|'search_opts'
op|'='
op|'{'
string|"'network_id'"
op|':'
name|'request'
op|'.'
name|'network_id'
op|','
nl|'\n'
string|"'fixed_ips'"
op|':'
string|"'ip_address=%s'"
op|'%'
op|'('
nl|'\n'
name|'request'
op|'.'
name|'address'
op|')'
op|','
nl|'\n'
string|"'fields'"
op|':'
string|"'device_id'"
op|'}'
newline|'\n'
name|'existing_ports'
op|'='
name|'neutron'
op|'.'
name|'list_ports'
op|'('
nl|'\n'
op|'**'
name|'search_opts'
op|')'
op|'['
string|"'ports'"
op|']'
newline|'\n'
name|'if'
name|'existing_ports'
op|':'
newline|'\n'
indent|'                            '
name|'i_uuid'
op|'='
name|'existing_ports'
op|'['
number|'0'
op|']'
op|'['
string|"'device_id'"
op|']'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'FixedIpAlreadyInUse'
op|'('
nl|'\n'
name|'address'
op|'='
name|'request'
op|'.'
name|'address'
op|','
nl|'\n'
name|'instance_uuid'
op|'='
name|'i_uuid'
op|')'
newline|'\n'
nl|'\n'
comment|'# Now check to see if all requested networks exist'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'if'
name|'net_ids_requested'
op|':'
newline|'\n'
indent|'                '
name|'nets'
op|'='
name|'self'
op|'.'
name|'_get_available_networks'
op|'('
nl|'\n'
name|'context'
op|','
name|'context'
op|'.'
name|'project_id'
op|','
name|'net_ids_requested'
op|','
nl|'\n'
name|'neutron'
op|'='
name|'neutron'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'net'
name|'in'
name|'nets'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'not'
name|'net'
op|'.'
name|'get'
op|'('
string|"'subnets'"
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
name|'exception'
op|'.'
name|'NetworkRequiresSubnet'
op|'('
nl|'\n'
name|'network_uuid'
op|'='
name|'net'
op|'['
string|"'id'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'len'
op|'('
name|'nets'
op|')'
op|'!='
name|'len'
op|'('
name|'net_ids_requested'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'requested_netid_set'
op|'='
name|'set'
op|'('
name|'net_ids_requested'
op|')'
newline|'\n'
name|'returned_netid_set'
op|'='
name|'set'
op|'('
op|'['
name|'net'
op|'['
string|"'id'"
op|']'
name|'for'
name|'net'
name|'in'
name|'nets'
op|']'
op|')'
newline|'\n'
name|'lostid_set'
op|'='
name|'requested_netid_set'
op|'-'
name|'returned_netid_set'
newline|'\n'
name|'if'
name|'lostid_set'
op|':'
newline|'\n'
indent|'                        '
name|'id_str'
op|'='
string|"''"
newline|'\n'
name|'for'
name|'_id'
name|'in'
name|'lostid_set'
op|':'
newline|'\n'
indent|'                            '
name|'id_str'
op|'='
name|'id_str'
name|'and'
name|'id_str'
op|'+'
string|"', '"
op|'+'
name|'_id'
name|'or'
name|'_id'
newline|'\n'
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'NetworkNotFound'
op|'('
name|'network_id'
op|'='
name|'id_str'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'return'
name|'ports_needed_per_instance'
newline|'\n'
nl|'\n'
DECL|member|validate_networks
dedent|''
name|'def'
name|'validate_networks'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'requested_networks'
op|','
name|'num_instances'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Validate that the tenant can use the requested networks.\n\n        Return the number of instances than can be successfully allocated\n        with the requested network configuration.\n        """'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'validate_networks() for %s'"
op|','
name|'requested_networks'
op|')'
newline|'\n'
nl|'\n'
name|'neutron'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
name|'ports_needed_per_instance'
op|'='
name|'self'
op|'.'
name|'_ports_needed_per_instance'
op|'('
nl|'\n'
name|'context'
op|','
name|'neutron'
op|','
name|'requested_networks'
op|')'
newline|'\n'
nl|'\n'
comment|'# Note(PhilD): Ideally Nova would create all required ports as part of'
nl|'\n'
comment|'# network validation, but port creation requires some details'
nl|'\n'
comment|'# from the hypervisor.  So we just check the quota and return'
nl|'\n'
comment|'# how many of the requested number of instances can be created'
nl|'\n'
name|'if'
name|'ports_needed_per_instance'
op|':'
newline|'\n'
indent|'            '
name|'quotas'
op|'='
name|'neutron'
op|'.'
name|'show_quota'
op|'('
name|'tenant_id'
op|'='
name|'context'
op|'.'
name|'project_id'
op|')'
op|'['
string|"'quota'"
op|']'
newline|'\n'
name|'if'
name|'quotas'
op|'.'
name|'get'
op|'('
string|"'port'"
op|','
op|'-'
number|'1'
op|')'
op|'=='
op|'-'
number|'1'
op|':'
newline|'\n'
comment|'# Unlimited Port Quota'
nl|'\n'
indent|'                '
name|'return'
name|'num_instances'
newline|'\n'
nl|'\n'
comment|'# We only need the port count so only ask for ids back.'
nl|'\n'
dedent|''
name|'params'
op|'='
name|'dict'
op|'('
name|'tenant_id'
op|'='
name|'context'
op|'.'
name|'project_id'
op|','
name|'fields'
op|'='
op|'['
string|"'id'"
op|']'
op|')'
newline|'\n'
name|'ports'
op|'='
name|'neutron'
op|'.'
name|'list_ports'
op|'('
op|'**'
name|'params'
op|')'
op|'['
string|"'ports'"
op|']'
newline|'\n'
name|'free_ports'
op|'='
name|'quotas'
op|'.'
name|'get'
op|'('
string|"'port'"
op|')'
op|'-'
name|'len'
op|'('
name|'ports'
op|')'
newline|'\n'
name|'if'
name|'free_ports'
op|'<'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|'"The number of defined ports: %(ports)d "'
nl|'\n'
string|'"is over the limit: %(quota)d"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'ports'"
op|':'
name|'len'
op|'('
name|'ports'
op|')'
op|','
nl|'\n'
string|"'quota'"
op|':'
name|'quotas'
op|'.'
name|'get'
op|'('
string|"'port'"
op|')'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'PortLimitExceeded'
op|'('
name|'msg'
op|')'
newline|'\n'
dedent|''
name|'ports_needed'
op|'='
name|'ports_needed_per_instance'
op|'*'
name|'num_instances'
newline|'\n'
name|'if'
name|'free_ports'
op|'>='
name|'ports_needed'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'num_instances'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'free_ports'
op|'//'
name|'ports_needed_per_instance'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'num_instances'
newline|'\n'
nl|'\n'
DECL|member|_get_instance_uuids_by_ip
dedent|''
name|'def'
name|'_get_instance_uuids_by_ip'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'address'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve instance uuids associated with the given IP address.\n\n        :returns: A list of dicts containing the uuids keyed by \'instance_uuid\'\n                  e.g. [{\'instance_uuid\': uuid}, ...]\n        """'
newline|'\n'
name|'search_opts'
op|'='
op|'{'
string|'"fixed_ips"'
op|':'
string|"'ip_address=%s'"
op|'%'
name|'address'
op|'}'
newline|'\n'
name|'data'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
op|'.'
name|'list_ports'
op|'('
op|'**'
name|'search_opts'
op|')'
newline|'\n'
name|'ports'
op|'='
name|'data'
op|'.'
name|'get'
op|'('
string|"'ports'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'return'
op|'['
op|'{'
string|"'instance_uuid'"
op|':'
name|'port'
op|'['
string|"'device_id'"
op|']'
op|'}'
name|'for'
name|'port'
name|'in'
name|'ports'
nl|'\n'
name|'if'
name|'port'
op|'['
string|"'device_id'"
op|']'
op|']'
newline|'\n'
nl|'\n'
DECL|member|_get_port_id_by_fixed_address
dedent|''
name|'def'
name|'_get_port_id_by_fixed_address'
op|'('
name|'self'
op|','
name|'client'
op|','
nl|'\n'
name|'instance'
op|','
name|'address'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return port_id from a fixed address."""'
newline|'\n'
name|'zone'
op|'='
string|"'compute:%s'"
op|'%'
name|'instance'
op|'.'
name|'availability_zone'
newline|'\n'
name|'search_opts'
op|'='
op|'{'
string|"'device_id'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|','
nl|'\n'
string|"'device_owner'"
op|':'
name|'zone'
op|'}'
newline|'\n'
name|'data'
op|'='
name|'client'
op|'.'
name|'list_ports'
op|'('
op|'**'
name|'search_opts'
op|')'
newline|'\n'
name|'ports'
op|'='
name|'data'
op|'['
string|"'ports'"
op|']'
newline|'\n'
name|'port_id'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'p'
name|'in'
name|'ports'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'ip'
name|'in'
name|'p'
op|'['
string|"'fixed_ips'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'ip'
op|'['
string|"'ip_address'"
op|']'
op|'=='
name|'address'
op|':'
newline|'\n'
indent|'                    '
name|'port_id'
op|'='
name|'p'
op|'['
string|"'id'"
op|']'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'not'
name|'port_id'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'FixedIpNotFoundForAddress'
op|'('
name|'address'
op|'='
name|'address'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'port_id'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'base_api'
op|'.'
name|'refresh_cache'
newline|'\n'
DECL|member|associate_floating_ip
name|'def'
name|'associate_floating_ip'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'floating_address'
op|','
name|'fixed_address'
op|','
nl|'\n'
name|'affect_auto_assigned'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Associate a floating IP with a fixed IP."""'
newline|'\n'
nl|'\n'
comment|"# Note(amotoki): 'affect_auto_assigned' is not respected"
nl|'\n'
comment|'# since it is not used anywhere in nova code and I could'
nl|'\n'
comment|'# find why this parameter exists.'
nl|'\n'
nl|'\n'
name|'client'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
name|'port_id'
op|'='
name|'self'
op|'.'
name|'_get_port_id_by_fixed_address'
op|'('
name|'client'
op|','
name|'instance'
op|','
nl|'\n'
name|'fixed_address'
op|')'
newline|'\n'
name|'fip'
op|'='
name|'self'
op|'.'
name|'_get_floating_ip_by_address'
op|'('
name|'client'
op|','
name|'floating_address'
op|')'
newline|'\n'
name|'param'
op|'='
op|'{'
string|"'port_id'"
op|':'
name|'port_id'
op|','
nl|'\n'
string|"'fixed_ip_address'"
op|':'
name|'fixed_address'
op|'}'
newline|'\n'
name|'client'
op|'.'
name|'update_floatingip'
op|'('
name|'fip'
op|'['
string|"'id'"
op|']'
op|','
op|'{'
string|"'floatingip'"
op|':'
name|'param'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'fip'
op|'['
string|"'port_id'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'port'
op|'='
name|'self'
op|'.'
name|'_show_port'
op|'('
name|'context'
op|','
name|'fip'
op|'['
string|"'port_id'"
op|']'
op|','
nl|'\n'
name|'neutron_client'
op|'='
name|'client'
op|')'
newline|'\n'
name|'orig_instance_uuid'
op|'='
name|'port'
op|'['
string|"'device_id'"
op|']'
newline|'\n'
nl|'\n'
name|'msg_dict'
op|'='
name|'dict'
op|'('
name|'address'
op|'='
name|'floating_address'
op|','
nl|'\n'
name|'instance_id'
op|'='
name|'orig_instance_uuid'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'re-assign floating IP %(address)s from '"
nl|'\n'
string|"'instance %(instance_id)s'"
op|')'
op|','
name|'msg_dict'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'orig_instance'
op|'='
name|'objects'
op|'.'
name|'Instance'
op|'.'
name|'get_by_uuid'
op|'('
name|'context'
op|','
nl|'\n'
name|'orig_instance_uuid'
op|')'
newline|'\n'
nl|'\n'
comment|'# purge cached nw info for the original instance'
nl|'\n'
name|'base_api'
op|'.'
name|'update_instance_cache_with_nw_info'
op|'('
name|'self'
op|','
name|'context'
op|','
nl|'\n'
name|'orig_instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_all
dedent|''
dedent|''
name|'def'
name|'get_all'
op|'('
name|'self'
op|','
name|'context'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get all networks for client."""'
newline|'\n'
name|'client'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
name|'networks'
op|'='
name|'client'
op|'.'
name|'list_networks'
op|'('
op|')'
op|'.'
name|'get'
op|'('
string|"'networks'"
op|')'
newline|'\n'
name|'network_objs'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'network'
name|'in'
name|'networks'
op|':'
newline|'\n'
indent|'            '
name|'network_objs'
op|'.'
name|'append'
op|'('
name|'objects'
op|'.'
name|'Network'
op|'('
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'name'
op|'='
name|'network'
op|'['
string|"'name'"
op|']'
op|','
nl|'\n'
name|'label'
op|'='
name|'network'
op|'['
string|"'name'"
op|']'
op|','
nl|'\n'
name|'uuid'
op|'='
name|'network'
op|'['
string|"'id'"
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'objects'
op|'.'
name|'NetworkList'
op|'('
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'objects'
op|'='
name|'network_objs'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get
dedent|''
name|'def'
name|'get'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'network_uuid'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get specific network for client."""'
newline|'\n'
name|'client'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'network'
op|'='
name|'client'
op|'.'
name|'show_network'
op|'('
name|'network_uuid'
op|')'
op|'.'
name|'get'
op|'('
string|"'network'"
op|')'
name|'or'
op|'{'
op|'}'
newline|'\n'
dedent|''
name|'except'
name|'neutron_client_exc'
op|'.'
name|'NetworkNotFoundClient'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'NetworkNotFound'
op|'('
name|'network_id'
op|'='
name|'network_uuid'
op|')'
newline|'\n'
dedent|''
name|'net_obj'
op|'='
name|'objects'
op|'.'
name|'Network'
op|'('
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'name'
op|'='
name|'network'
op|'['
string|"'name'"
op|']'
op|','
nl|'\n'
name|'label'
op|'='
name|'network'
op|'['
string|"'name'"
op|']'
op|','
nl|'\n'
name|'uuid'
op|'='
name|'network'
op|'['
string|"'id'"
op|']'
op|')'
newline|'\n'
name|'return'
name|'net_obj'
newline|'\n'
nl|'\n'
DECL|member|delete
dedent|''
name|'def'
name|'delete'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'network_uuid'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Delete a network for client."""'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|disassociate
dedent|''
name|'def'
name|'disassociate'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'network_uuid'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Disassociate a network for client."""'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|associate
dedent|''
name|'def'
name|'associate'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'network_uuid'
op|','
name|'host'
op|'='
name|'base_api'
op|'.'
name|'SENTINEL'
op|','
nl|'\n'
name|'project'
op|'='
name|'base_api'
op|'.'
name|'SENTINEL'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Associate a network for client."""'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_fixed_ip
dedent|''
name|'def'
name|'get_fixed_ip'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get a fixed IP from the id."""'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_fixed_ip_by_address
dedent|''
name|'def'
name|'get_fixed_ip_by_address'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'address'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return instance uuids given an address."""'
newline|'\n'
name|'uuid_maps'
op|'='
name|'self'
op|'.'
name|'_get_instance_uuids_by_ip'
op|'('
name|'context'
op|','
name|'address'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'uuid_maps'
op|')'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'uuid_maps'
op|'['
number|'0'
op|']'
newline|'\n'
dedent|''
name|'elif'
name|'not'
name|'uuid_maps'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'FixedIpNotFoundForAddress'
op|'('
name|'address'
op|'='
name|'address'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'FixedIpAssociatedWithMultipleInstances'
op|'('
nl|'\n'
name|'address'
op|'='
name|'address'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_setup_net_dict
dedent|''
dedent|''
name|'def'
name|'_setup_net_dict'
op|'('
name|'self'
op|','
name|'client'
op|','
name|'network_id'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'network_id'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'{'
op|'}'
newline|'\n'
dedent|''
name|'pool'
op|'='
name|'client'
op|'.'
name|'show_network'
op|'('
name|'network_id'
op|')'
op|'['
string|"'network'"
op|']'
newline|'\n'
name|'return'
op|'{'
name|'pool'
op|'['
string|"'id'"
op|']'
op|':'
name|'pool'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|_setup_port_dict
dedent|''
name|'def'
name|'_setup_port_dict'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'client'
op|','
name|'port_id'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'port_id'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'{'
op|'}'
newline|'\n'
dedent|''
name|'port'
op|'='
name|'self'
op|'.'
name|'_show_port'
op|'('
name|'context'
op|','
name|'port_id'
op|','
name|'neutron_client'
op|'='
name|'client'
op|')'
newline|'\n'
name|'return'
op|'{'
name|'port'
op|'['
string|"'id'"
op|']'
op|':'
name|'port'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|_setup_pools_dict
dedent|''
name|'def'
name|'_setup_pools_dict'
op|'('
name|'self'
op|','
name|'client'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pools'
op|'='
name|'self'
op|'.'
name|'_get_floating_ip_pools'
op|'('
name|'client'
op|')'
newline|'\n'
name|'return'
op|'{'
name|'i'
op|'['
string|"'id'"
op|']'
op|':'
name|'i'
name|'for'
name|'i'
name|'in'
name|'pools'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|_setup_ports_dict
dedent|''
name|'def'
name|'_setup_ports_dict'
op|'('
name|'self'
op|','
name|'client'
op|','
name|'project_id'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'search_opts'
op|'='
op|'{'
string|"'tenant_id'"
op|':'
name|'project_id'
op|'}'
name|'if'
name|'project_id'
name|'else'
op|'{'
op|'}'
newline|'\n'
name|'ports'
op|'='
name|'client'
op|'.'
name|'list_ports'
op|'('
op|'**'
name|'search_opts'
op|')'
op|'['
string|"'ports'"
op|']'
newline|'\n'
name|'return'
op|'{'
name|'p'
op|'['
string|"'id'"
op|']'
op|':'
name|'p'
name|'for'
name|'p'
name|'in'
name|'ports'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|get_floating_ip
dedent|''
name|'def'
name|'get_floating_ip'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return floating IP object given the floating IP id."""'
newline|'\n'
name|'client'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'fip'
op|'='
name|'client'
op|'.'
name|'show_floatingip'
op|'('
name|'id'
op|')'
op|'['
string|"'floatingip'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'neutron_client_exc'
op|'.'
name|'NeutronClientException'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'e'
op|'.'
name|'status_code'
op|'=='
number|'404'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'FloatingIpNotFound'
op|'('
name|'id'
op|'='
name|'id'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Unable to access floating IP %s'"
op|')'
op|','
name|'id'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'pool_dict'
op|'='
name|'self'
op|'.'
name|'_setup_net_dict'
op|'('
name|'client'
op|','
nl|'\n'
name|'fip'
op|'['
string|"'floating_network_id'"
op|']'
op|')'
newline|'\n'
name|'port_dict'
op|'='
name|'self'
op|'.'
name|'_setup_port_dict'
op|'('
name|'context'
op|','
name|'client'
op|','
name|'fip'
op|'['
string|"'port_id'"
op|']'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_format_floating_ip_model'
op|'('
name|'fip'
op|','
name|'pool_dict'
op|','
name|'port_dict'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_floating_ip_pools
dedent|''
name|'def'
name|'_get_floating_ip_pools'
op|'('
name|'self'
op|','
name|'client'
op|','
name|'project_id'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'search_opts'
op|'='
op|'{'
name|'constants'
op|'.'
name|'NET_EXTERNAL'
op|':'
name|'True'
op|'}'
newline|'\n'
name|'if'
name|'project_id'
op|':'
newline|'\n'
indent|'            '
name|'search_opts'
op|'.'
name|'update'
op|'('
op|'{'
string|"'tenant_id'"
op|':'
name|'project_id'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'data'
op|'='
name|'client'
op|'.'
name|'list_networks'
op|'('
op|'**'
name|'search_opts'
op|')'
newline|'\n'
name|'return'
name|'data'
op|'['
string|"'networks'"
op|']'
newline|'\n'
nl|'\n'
DECL|member|get_floating_ip_pools
dedent|''
name|'def'
name|'get_floating_ip_pools'
op|'('
name|'self'
op|','
name|'context'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return floating IP pool names."""'
newline|'\n'
name|'client'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
name|'pools'
op|'='
name|'self'
op|'.'
name|'_get_floating_ip_pools'
op|'('
name|'client'
op|')'
newline|'\n'
comment|'# Note(salv-orlando): Return a list of names to be consistent with'
nl|'\n'
comment|'# nova.network.api.get_floating_ip_pools'
nl|'\n'
name|'return'
op|'['
name|'n'
op|'['
string|"'name'"
op|']'
name|'or'
name|'n'
op|'['
string|"'id'"
op|']'
name|'for'
name|'n'
name|'in'
name|'pools'
op|']'
newline|'\n'
nl|'\n'
DECL|member|_format_floating_ip_model
dedent|''
name|'def'
name|'_format_floating_ip_model'
op|'('
name|'self'
op|','
name|'fip'
op|','
name|'pool_dict'
op|','
name|'port_dict'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pool'
op|'='
name|'pool_dict'
op|'['
name|'fip'
op|'['
string|"'floating_network_id'"
op|']'
op|']'
newline|'\n'
name|'result'
op|'='
op|'{'
string|"'id'"
op|':'
name|'fip'
op|'['
string|"'id'"
op|']'
op|','
nl|'\n'
string|"'address'"
op|':'
name|'fip'
op|'['
string|"'floating_ip_address'"
op|']'
op|','
nl|'\n'
string|"'pool'"
op|':'
name|'pool'
op|'['
string|"'name'"
op|']'
name|'or'
name|'pool'
op|'['
string|"'id'"
op|']'
op|','
nl|'\n'
string|"'project_id'"
op|':'
name|'fip'
op|'['
string|"'tenant_id'"
op|']'
op|','
nl|'\n'
comment|'# In Neutron v2, an exact fixed_ip_id does not exist.'
nl|'\n'
string|"'fixed_ip_id'"
op|':'
name|'fip'
op|'['
string|"'port_id'"
op|']'
op|','
nl|'\n'
op|'}'
newline|'\n'
comment|'# In Neutron v2 API fixed_ip_address and instance uuid'
nl|'\n'
comment|'# (= device_id) are known here, so pass it as a result.'
nl|'\n'
name|'result'
op|'['
string|"'fixed_ip'"
op|']'
op|'='
op|'{'
string|"'address'"
op|':'
name|'fip'
op|'['
string|"'fixed_ip_address'"
op|']'
op|'}'
newline|'\n'
name|'if'
name|'fip'
op|'['
string|"'port_id'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'instance_uuid'
op|'='
name|'port_dict'
op|'['
name|'fip'
op|'['
string|"'port_id'"
op|']'
op|']'
op|'['
string|"'device_id'"
op|']'
newline|'\n'
name|'result'
op|'['
string|"'instance'"
op|']'
op|'='
op|'{'
string|"'uuid'"
op|':'
name|'instance_uuid'
op|'}'
newline|'\n'
comment|'# TODO(mriedem): remove this workaround once the get_floating_ip*'
nl|'\n'
comment|'# API methods are converted to use nova objects.'
nl|'\n'
name|'result'
op|'['
string|"'fixed_ip'"
op|']'
op|'['
string|"'instance_uuid'"
op|']'
op|'='
name|'instance_uuid'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'['
string|"'instance'"
op|']'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
DECL|member|get_floating_ip_by_address
dedent|''
name|'def'
name|'get_floating_ip_by_address'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'address'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a floating IP given an address."""'
newline|'\n'
name|'client'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
name|'fip'
op|'='
name|'self'
op|'.'
name|'_get_floating_ip_by_address'
op|'('
name|'client'
op|','
name|'address'
op|')'
newline|'\n'
name|'pool_dict'
op|'='
name|'self'
op|'.'
name|'_setup_net_dict'
op|'('
name|'client'
op|','
nl|'\n'
name|'fip'
op|'['
string|"'floating_network_id'"
op|']'
op|')'
newline|'\n'
name|'port_dict'
op|'='
name|'self'
op|'.'
name|'_setup_port_dict'
op|'('
name|'context'
op|','
name|'client'
op|','
name|'fip'
op|'['
string|"'port_id'"
op|']'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_format_floating_ip_model'
op|'('
name|'fip'
op|','
name|'pool_dict'
op|','
name|'port_dict'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_floating_ips_by_project
dedent|''
name|'def'
name|'get_floating_ips_by_project'
op|'('
name|'self'
op|','
name|'context'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'client'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
name|'project_id'
op|'='
name|'context'
op|'.'
name|'project_id'
newline|'\n'
name|'fips'
op|'='
name|'self'
op|'.'
name|'_safe_get_floating_ips'
op|'('
name|'client'
op|','
name|'tenant_id'
op|'='
name|'project_id'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'fips'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'['
op|']'
newline|'\n'
dedent|''
name|'pool_dict'
op|'='
name|'self'
op|'.'
name|'_setup_pools_dict'
op|'('
name|'client'
op|')'
newline|'\n'
name|'port_dict'
op|'='
name|'self'
op|'.'
name|'_setup_ports_dict'
op|'('
name|'client'
op|','
name|'project_id'
op|')'
newline|'\n'
name|'return'
op|'['
name|'self'
op|'.'
name|'_format_floating_ip_model'
op|'('
name|'fip'
op|','
name|'pool_dict'
op|','
name|'port_dict'
op|')'
nl|'\n'
name|'for'
name|'fip'
name|'in'
name|'fips'
op|']'
newline|'\n'
nl|'\n'
DECL|member|get_instance_id_by_floating_address
dedent|''
name|'def'
name|'get_instance_id_by_floating_address'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'address'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the instance id a floating IP\'s fixed IP is allocated to."""'
newline|'\n'
name|'client'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
name|'fip'
op|'='
name|'self'
op|'.'
name|'_get_floating_ip_by_address'
op|'('
name|'client'
op|','
name|'address'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'fip'
op|'['
string|"'port_id'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'port'
op|'='
name|'self'
op|'.'
name|'_show_port'
op|'('
name|'context'
op|','
name|'fip'
op|'['
string|"'port_id'"
op|']'
op|','
name|'neutron_client'
op|'='
name|'client'
op|')'
newline|'\n'
name|'return'
name|'port'
op|'['
string|"'device_id'"
op|']'
newline|'\n'
nl|'\n'
DECL|member|get_vifs_by_instance
dedent|''
name|'def'
name|'get_vifs_by_instance'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_vif_by_mac_address
dedent|''
name|'def'
name|'get_vif_by_mac_address'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'mac_address'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_floating_ip_pool_id_by_name_or_id
dedent|''
name|'def'
name|'_get_floating_ip_pool_id_by_name_or_id'
op|'('
name|'self'
op|','
name|'client'
op|','
name|'name_or_id'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'search_opts'
op|'='
op|'{'
name|'constants'
op|'.'
name|'NET_EXTERNAL'
op|':'
name|'True'
op|','
string|"'fields'"
op|':'
string|"'id'"
op|'}'
newline|'\n'
name|'if'
name|'uuidutils'
op|'.'
name|'is_uuid_like'
op|'('
name|'name_or_id'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'search_opts'
op|'.'
name|'update'
op|'('
op|'{'
string|"'id'"
op|':'
name|'name_or_id'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'search_opts'
op|'.'
name|'update'
op|'('
op|'{'
string|"'name'"
op|':'
name|'name_or_id'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'data'
op|'='
name|'client'
op|'.'
name|'list_networks'
op|'('
op|'**'
name|'search_opts'
op|')'
newline|'\n'
name|'nets'
op|'='
name|'data'
op|'['
string|"'networks'"
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'nets'
op|')'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'nets'
op|'['
number|'0'
op|']'
op|'['
string|"'id'"
op|']'
newline|'\n'
dedent|''
name|'elif'
name|'len'
op|'('
name|'nets'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'FloatingIpPoolNotFound'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|'"Multiple floating IP pools matches found for name \'%s\'"'
op|')'
nl|'\n'
op|'%'
name|'name_or_id'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'message'
op|'='
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|allocate_floating_ip
dedent|''
dedent|''
name|'def'
name|'allocate_floating_ip'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'pool'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Add a floating IP to a project from a pool."""'
newline|'\n'
name|'client'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
name|'pool'
op|'='
name|'pool'
name|'or'
name|'CONF'
op|'.'
name|'default_floating_pool'
newline|'\n'
name|'pool_id'
op|'='
name|'self'
op|'.'
name|'_get_floating_ip_pool_id_by_name_or_id'
op|'('
name|'client'
op|','
name|'pool'
op|')'
newline|'\n'
nl|'\n'
name|'param'
op|'='
op|'{'
string|"'floatingip'"
op|':'
op|'{'
string|"'floating_network_id'"
op|':'
name|'pool_id'
op|'}'
op|'}'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'fip'
op|'='
name|'client'
op|'.'
name|'create_floatingip'
op|'('
name|'param'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'neutron_client_exc'
op|'.'
name|'IpAddressGenerationFailureClient'
op|','
nl|'\n'
name|'neutron_client_exc'
op|'.'
name|'ExternalIpAddressExhaustedClient'
op|')'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'NoMoreFloatingIps'
op|'('
name|'six'
op|'.'
name|'text_type'
op|'('
name|'e'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'neutron_client_exc'
op|'.'
name|'OverQuotaClient'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'FloatingIpLimitExceeded'
op|'('
name|'six'
op|'.'
name|'text_type'
op|'('
name|'e'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'neutron_client_exc'
op|'.'
name|'BadRequest'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'FloatingIpBadRequest'
op|'('
name|'six'
op|'.'
name|'text_type'
op|'('
name|'e'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'fip'
op|'['
string|"'floatingip'"
op|']'
op|'['
string|"'floating_ip_address'"
op|']'
newline|'\n'
nl|'\n'
DECL|member|_safe_get_floating_ips
dedent|''
name|'def'
name|'_safe_get_floating_ips'
op|'('
name|'self'
op|','
name|'client'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get floating IP gracefully handling 404 from Neutron."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'client'
op|'.'
name|'list_floatingips'
op|'('
op|'**'
name|'kwargs'
op|')'
op|'['
string|"'floatingips'"
op|']'
newline|'\n'
comment|'# If a neutron plugin does not implement the L3 API a 404 from'
nl|'\n'
comment|'# list_floatingips will be raised.'
nl|'\n'
dedent|''
name|'except'
name|'neutron_client_exc'
op|'.'
name|'NotFound'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'['
op|']'
newline|'\n'
dedent|''
name|'except'
name|'neutron_client_exc'
op|'.'
name|'NeutronClientException'
name|'as'
name|'e'
op|':'
newline|'\n'
comment|'# bug/1513879 neutron client is currently using'
nl|'\n'
comment|'# NeutronClientException when there is no L3 API'
nl|'\n'
indent|'            '
name|'if'
name|'e'
op|'.'
name|'status_code'
op|'=='
number|'404'
op|':'
newline|'\n'
indent|'                '
name|'return'
op|'['
op|']'
newline|'\n'
dedent|''
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Unable to access floating IP for %s'"
op|')'
op|','
nl|'\n'
string|"', '"
op|'.'
name|'join'
op|'('
op|'['
string|"'%s %s'"
op|'%'
op|'('
name|'k'
op|','
name|'v'
op|')'
nl|'\n'
name|'for'
name|'k'
op|','
name|'v'
name|'in'
name|'six'
op|'.'
name|'iteritems'
op|'('
name|'kwargs'
op|')'
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_floating_ip_by_address
dedent|''
dedent|''
dedent|''
name|'def'
name|'_get_floating_ip_by_address'
op|'('
name|'self'
op|','
name|'client'
op|','
name|'address'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get floating IP from floating IP address."""'
newline|'\n'
name|'if'
name|'not'
name|'address'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'FloatingIpNotFoundForAddress'
op|'('
name|'address'
op|'='
name|'address'
op|')'
newline|'\n'
dedent|''
name|'fips'
op|'='
name|'self'
op|'.'
name|'_safe_get_floating_ips'
op|'('
name|'client'
op|','
name|'floating_ip_address'
op|'='
name|'address'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'fips'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'FloatingIpNotFoundForAddress'
op|'('
name|'address'
op|'='
name|'address'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'len'
op|'('
name|'fips'
op|')'
op|'>'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'FloatingIpMultipleFoundForAddress'
op|'('
name|'address'
op|'='
name|'address'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'fips'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
DECL|member|_get_floating_ips_by_fixed_and_port
dedent|''
name|'def'
name|'_get_floating_ips_by_fixed_and_port'
op|'('
name|'self'
op|','
name|'client'
op|','
name|'fixed_ip'
op|','
name|'port'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get floating IPs from fixed IP and port."""'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_safe_get_floating_ips'
op|'('
name|'client'
op|','
name|'fixed_ip_address'
op|'='
name|'fixed_ip'
op|','
nl|'\n'
name|'port_id'
op|'='
name|'port'
op|')'
newline|'\n'
nl|'\n'
DECL|member|release_floating_ip
dedent|''
name|'def'
name|'release_floating_ip'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'address'
op|','
nl|'\n'
name|'affect_auto_assigned'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Remove a floating IP with the given address from a project."""'
newline|'\n'
nl|'\n'
comment|'# Note(amotoki): We cannot handle a case where multiple pools'
nl|'\n'
comment|'# have overlapping IP address range. In this case we cannot use'
nl|'\n'
comment|"# 'address' as a unique key."
nl|'\n'
comment|'# This is a limitation of the current nova.'
nl|'\n'
nl|'\n'
comment|"# Note(amotoki): 'affect_auto_assigned' is not respected"
nl|'\n'
comment|'# since it is not used anywhere in nova code and I could'
nl|'\n'
comment|'# find why this parameter exists.'
nl|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_release_floating_ip'
op|'('
name|'context'
op|','
name|'address'
op|')'
newline|'\n'
nl|'\n'
DECL|member|disassociate_and_release_floating_ip
dedent|''
name|'def'
name|'disassociate_and_release_floating_ip'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'floating_ip'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Removes (deallocates) and deletes the floating IP.\n\n        This api call was added to allow this to be done in one operation\n        if using neutron.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_release_floating_ip'
op|'('
name|'context'
op|','
name|'floating_ip'
op|'['
string|"'address'"
op|']'
op|','
nl|'\n'
name|'raise_if_associated'
op|'='
name|'False'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_release_floating_ip
dedent|''
name|'def'
name|'_release_floating_ip'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'address'
op|','
nl|'\n'
name|'raise_if_associated'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'client'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
name|'fip'
op|'='
name|'self'
op|'.'
name|'_get_floating_ip_by_address'
op|'('
name|'client'
op|','
name|'address'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'raise_if_associated'
name|'and'
name|'fip'
op|'['
string|"'port_id'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'FloatingIpAssociated'
op|'('
name|'address'
op|'='
name|'address'
op|')'
newline|'\n'
dedent|''
name|'client'
op|'.'
name|'delete_floatingip'
op|'('
name|'fip'
op|'['
string|"'id'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'base_api'
op|'.'
name|'refresh_cache'
newline|'\n'
DECL|member|disassociate_floating_ip
name|'def'
name|'disassociate_floating_ip'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'address'
op|','
nl|'\n'
name|'affect_auto_assigned'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Disassociate a floating IP from the instance."""'
newline|'\n'
nl|'\n'
comment|"# Note(amotoki): 'affect_auto_assigned' is not respected"
nl|'\n'
comment|'# since it is not used anywhere in nova code and I could'
nl|'\n'
comment|'# find why this parameter exists.'
nl|'\n'
nl|'\n'
name|'client'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
name|'fip'
op|'='
name|'self'
op|'.'
name|'_get_floating_ip_by_address'
op|'('
name|'client'
op|','
name|'address'
op|')'
newline|'\n'
name|'client'
op|'.'
name|'update_floatingip'
op|'('
name|'fip'
op|'['
string|"'id'"
op|']'
op|','
op|'{'
string|"'floatingip'"
op|':'
op|'{'
string|"'port_id'"
op|':'
name|'None'
op|'}'
op|'}'
op|')'
newline|'\n'
nl|'\n'
DECL|member|migrate_instance_start
dedent|''
name|'def'
name|'migrate_instance_start'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'migration'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Start to migrate the network of an instance."""'
newline|'\n'
comment|"# NOTE(wenjianhn): just pass to make migrate instance doesn't"
nl|'\n'
comment|'# raise for now.'
nl|'\n'
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|migrate_instance_finish
dedent|''
name|'def'
name|'migrate_instance_finish'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'migration'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Finish migrating the network of an instance."""'
newline|'\n'
name|'self'
op|'.'
name|'_update_port_binding_for_instance'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'migration'
op|'['
string|"'dest_compute'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|add_network_to_project
dedent|''
name|'def'
name|'add_network_to_project'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'project_id'
op|','
name|'network_uuid'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Force add a network to the project."""'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_nw_info_get_ips
dedent|''
name|'def'
name|'_nw_info_get_ips'
op|'('
name|'self'
op|','
name|'client'
op|','
name|'port'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'network_IPs'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'fixed_ip'
name|'in'
name|'port'
op|'['
string|"'fixed_ips'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'fixed'
op|'='
name|'network_model'
op|'.'
name|'FixedIP'
op|'('
name|'address'
op|'='
name|'fixed_ip'
op|'['
string|"'ip_address'"
op|']'
op|')'
newline|'\n'
name|'floats'
op|'='
name|'self'
op|'.'
name|'_get_floating_ips_by_fixed_and_port'
op|'('
nl|'\n'
name|'client'
op|','
name|'fixed_ip'
op|'['
string|"'ip_address'"
op|']'
op|','
name|'port'
op|'['
string|"'id'"
op|']'
op|')'
newline|'\n'
name|'for'
name|'ip'
name|'in'
name|'floats'
op|':'
newline|'\n'
indent|'                '
name|'fip'
op|'='
name|'network_model'
op|'.'
name|'IP'
op|'('
name|'address'
op|'='
name|'ip'
op|'['
string|"'floating_ip_address'"
op|']'
op|','
nl|'\n'
name|'type'
op|'='
string|"'floating'"
op|')'
newline|'\n'
name|'fixed'
op|'.'
name|'add_floating_ip'
op|'('
name|'fip'
op|')'
newline|'\n'
dedent|''
name|'network_IPs'
op|'.'
name|'append'
op|'('
name|'fixed'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'network_IPs'
newline|'\n'
nl|'\n'
DECL|member|_nw_info_get_subnets
dedent|''
name|'def'
name|'_nw_info_get_subnets'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'port'
op|','
name|'network_IPs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'subnets'
op|'='
name|'self'
op|'.'
name|'_get_subnets_from_port'
op|'('
name|'context'
op|','
name|'port'
op|')'
newline|'\n'
name|'for'
name|'subnet'
name|'in'
name|'subnets'
op|':'
newline|'\n'
indent|'            '
name|'subnet'
op|'['
string|"'ips'"
op|']'
op|'='
op|'['
name|'fixed_ip'
name|'for'
name|'fixed_ip'
name|'in'
name|'network_IPs'
nl|'\n'
name|'if'
name|'fixed_ip'
op|'.'
name|'is_in_subnet'
op|'('
name|'subnet'
op|')'
op|']'
newline|'\n'
dedent|''
name|'return'
name|'subnets'
newline|'\n'
nl|'\n'
DECL|member|_nw_info_build_network
dedent|''
name|'def'
name|'_nw_info_build_network'
op|'('
name|'self'
op|','
name|'port'
op|','
name|'networks'
op|','
name|'subnets'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'network_name'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'net'
name|'in'
name|'networks'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'port'
op|'['
string|"'network_id'"
op|']'
op|'=='
name|'net'
op|'['
string|"'id'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'network_name'
op|'='
name|'net'
op|'['
string|"'name'"
op|']'
newline|'\n'
name|'tenant_id'
op|'='
name|'net'
op|'['
string|"'tenant_id'"
op|']'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'tenant_id'
op|'='
name|'port'
op|'['
string|"'tenant_id'"
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"Network %(id)s not matched with the tenants "'
nl|'\n'
string|'"network! The ports tenant %(tenant_id)s will be "'
nl|'\n'
string|'"used."'
op|')'
op|','
nl|'\n'
op|'{'
string|"'id'"
op|':'
name|'port'
op|'['
string|"'network_id'"
op|']'
op|','
string|"'tenant_id'"
op|':'
name|'tenant_id'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'bridge'
op|'='
name|'None'
newline|'\n'
name|'ovs_interfaceid'
op|'='
name|'None'
newline|'\n'
comment|'# Network model metadata'
nl|'\n'
name|'should_create_bridge'
op|'='
name|'None'
newline|'\n'
name|'vif_type'
op|'='
name|'port'
op|'.'
name|'get'
op|'('
string|"'binding:vif_type'"
op|')'
newline|'\n'
name|'port_details'
op|'='
name|'port'
op|'.'
name|'get'
op|'('
string|"'binding:vif_details'"
op|')'
newline|'\n'
comment|'# TODO(berrange) Neutron should pass the bridge name'
nl|'\n'
comment|'# in another binding metadata field'
nl|'\n'
name|'if'
name|'vif_type'
op|'=='
name|'network_model'
op|'.'
name|'VIF_TYPE_OVS'
op|':'
newline|'\n'
indent|'            '
name|'bridge'
op|'='
name|'CONF'
op|'.'
name|'neutron'
op|'.'
name|'ovs_bridge'
newline|'\n'
name|'ovs_interfaceid'
op|'='
name|'port'
op|'['
string|"'id'"
op|']'
newline|'\n'
dedent|''
name|'elif'
name|'vif_type'
op|'=='
name|'network_model'
op|'.'
name|'VIF_TYPE_BRIDGE'
op|':'
newline|'\n'
indent|'            '
name|'bridge'
op|'='
string|'"brq"'
op|'+'
name|'port'
op|'['
string|"'network_id'"
op|']'
newline|'\n'
name|'should_create_bridge'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'elif'
name|'vif_type'
op|'=='
name|'network_model'
op|'.'
name|'VIF_TYPE_DVS'
op|':'
newline|'\n'
comment|'# The name of the DVS port group will contain the neutron'
nl|'\n'
comment|'# network id'
nl|'\n'
indent|'            '
name|'bridge'
op|'='
name|'port'
op|'['
string|"'network_id'"
op|']'
newline|'\n'
dedent|''
name|'elif'
op|'('
name|'vif_type'
op|'=='
name|'network_model'
op|'.'
name|'VIF_TYPE_VHOSTUSER'
name|'and'
nl|'\n'
name|'port_details'
op|'.'
name|'get'
op|'('
name|'network_model'
op|'.'
name|'VIF_DETAILS_VHOSTUSER_OVS_PLUG'
op|','
nl|'\n'
name|'False'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'bridge'
op|'='
name|'CONF'
op|'.'
name|'neutron'
op|'.'
name|'ovs_bridge'
newline|'\n'
name|'ovs_interfaceid'
op|'='
name|'port'
op|'['
string|"'id'"
op|']'
newline|'\n'
nl|'\n'
comment|'# Prune the bridge name if necessary. For the DVS this is not done'
nl|'\n'
comment|"# as the bridge is a '<network-name>-<network-UUID>'."
nl|'\n'
dedent|''
name|'if'
name|'bridge'
name|'is'
name|'not'
name|'None'
name|'and'
name|'vif_type'
op|'!='
name|'network_model'
op|'.'
name|'VIF_TYPE_DVS'
op|':'
newline|'\n'
indent|'            '
name|'bridge'
op|'='
name|'bridge'
op|'['
op|':'
name|'network_model'
op|'.'
name|'NIC_NAME_LEN'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'network'
op|'='
name|'network_model'
op|'.'
name|'Network'
op|'('
nl|'\n'
name|'id'
op|'='
name|'port'
op|'['
string|"'network_id'"
op|']'
op|','
nl|'\n'
name|'bridge'
op|'='
name|'bridge'
op|','
nl|'\n'
name|'injected'
op|'='
name|'CONF'
op|'.'
name|'flat_injected'
op|','
nl|'\n'
name|'label'
op|'='
name|'network_name'
op|','
nl|'\n'
name|'tenant_id'
op|'='
name|'tenant_id'
nl|'\n'
op|')'
newline|'\n'
name|'network'
op|'['
string|"'subnets'"
op|']'
op|'='
name|'subnets'
newline|'\n'
name|'port_profile'
op|'='
name|'port'
op|'.'
name|'get'
op|'('
string|"'binding:profile'"
op|')'
newline|'\n'
name|'if'
name|'port_profile'
op|':'
newline|'\n'
indent|'            '
name|'physical_network'
op|'='
name|'port_profile'
op|'.'
name|'get'
op|'('
string|"'physical_network'"
op|')'
newline|'\n'
name|'if'
name|'physical_network'
op|':'
newline|'\n'
indent|'                '
name|'network'
op|'['
string|"'physical_network'"
op|']'
op|'='
name|'physical_network'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'should_create_bridge'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'network'
op|'['
string|"'should_create_bridge'"
op|']'
op|'='
name|'should_create_bridge'
newline|'\n'
dedent|''
name|'return'
name|'network'
op|','
name|'ovs_interfaceid'
newline|'\n'
nl|'\n'
DECL|member|_get_preexisting_port_ids
dedent|''
name|'def'
name|'_get_preexisting_port_ids'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve the preexisting ports associated with the given instance.\n        These ports were not created by nova and hence should not be\n        deallocated upon instance deletion.\n        """'
newline|'\n'
name|'net_info'
op|'='
name|'compute_utils'
op|'.'
name|'get_nw_info_for_instance'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'net_info'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Instance cache missing network info.'"
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'return'
op|'['
name|'vif'
op|'['
string|"'id'"
op|']'
name|'for'
name|'vif'
name|'in'
name|'net_info'
nl|'\n'
name|'if'
name|'vif'
op|'.'
name|'get'
op|'('
string|"'preserve_on_delete'"
op|')'
op|']'
newline|'\n'
nl|'\n'
DECL|member|_build_network_info_model
dedent|''
name|'def'
name|'_build_network_info_model'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'networks'
op|'='
name|'None'
op|','
nl|'\n'
name|'port_ids'
op|'='
name|'None'
op|','
name|'admin_client'
op|'='
name|'None'
op|','
nl|'\n'
name|'preexisting_port_ids'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return list of ordered VIFs attached to instance.\n\n        :param context: Request context.\n        :param instance: Instance we are returning network info for.\n        :param networks: List of networks being attached to an instance.\n                         If value is None this value will be populated\n                         from the existing cached value.\n        :param port_ids: List of port_ids that are being attached to an\n                         instance in order of attachment. If value is None\n                         this value will be populated from the existing\n                         cached value.\n        :param admin_client: A neutron client for the admin context.\n        :param preexisting_port_ids: List of port_ids that nova didn\'t\n                        allocate and there shouldn\'t be deleted when\n                        an instance is de-allocated. Supplied list will\n                        be added to the cached list of preexisting port\n                        IDs for this instance.\n        """'
newline|'\n'
nl|'\n'
name|'search_opts'
op|'='
op|'{'
string|"'tenant_id'"
op|':'
name|'instance'
op|'.'
name|'project_id'
op|','
nl|'\n'
string|"'device_id'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|','
op|'}'
newline|'\n'
name|'if'
name|'admin_client'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'client'
op|'='
name|'get_client'
op|'('
name|'context'
op|','
name|'admin'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'client'
op|'='
name|'admin_client'
newline|'\n'
nl|'\n'
dedent|''
name|'data'
op|'='
name|'client'
op|'.'
name|'list_ports'
op|'('
op|'**'
name|'search_opts'
op|')'
newline|'\n'
nl|'\n'
name|'current_neutron_ports'
op|'='
name|'data'
op|'.'
name|'get'
op|'('
string|"'ports'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'nw_info_refresh'
op|'='
name|'networks'
name|'is'
name|'None'
name|'and'
name|'port_ids'
name|'is'
name|'None'
newline|'\n'
name|'networks'
op|','
name|'port_ids'
op|'='
name|'self'
op|'.'
name|'_gather_port_ids_and_networks'
op|'('
nl|'\n'
name|'context'
op|','
name|'instance'
op|','
name|'networks'
op|','
name|'port_ids'
op|')'
newline|'\n'
name|'nw_info'
op|'='
name|'network_model'
op|'.'
name|'NetworkInfo'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'preexisting_port_ids'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'preexisting_port_ids'
op|'='
op|'['
op|']'
newline|'\n'
dedent|''
name|'preexisting_port_ids'
op|'='
name|'set'
op|'('
nl|'\n'
name|'preexisting_port_ids'
op|'+'
name|'self'
op|'.'
name|'_get_preexisting_port_ids'
op|'('
name|'instance'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'current_neutron_port_map'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'current_neutron_port'
name|'in'
name|'current_neutron_ports'
op|':'
newline|'\n'
indent|'            '
name|'current_neutron_port_map'
op|'['
name|'current_neutron_port'
op|'['
string|"'id'"
op|']'
op|']'
op|'='
op|'('
nl|'\n'
name|'current_neutron_port'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'port_id'
name|'in'
name|'port_ids'
op|':'
newline|'\n'
indent|'            '
name|'current_neutron_port'
op|'='
name|'current_neutron_port_map'
op|'.'
name|'get'
op|'('
name|'port_id'
op|')'
newline|'\n'
name|'if'
name|'current_neutron_port'
op|':'
newline|'\n'
indent|'                '
name|'vif_active'
op|'='
name|'False'
newline|'\n'
name|'if'
op|'('
name|'current_neutron_port'
op|'['
string|"'admin_state_up'"
op|']'
name|'is'
name|'False'
nl|'\n'
name|'or'
name|'current_neutron_port'
op|'['
string|"'status'"
op|']'
op|'=='
string|"'ACTIVE'"
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'vif_active'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'network_IPs'
op|'='
name|'self'
op|'.'
name|'_nw_info_get_ips'
op|'('
name|'client'
op|','
nl|'\n'
name|'current_neutron_port'
op|')'
newline|'\n'
name|'subnets'
op|'='
name|'self'
op|'.'
name|'_nw_info_get_subnets'
op|'('
name|'context'
op|','
nl|'\n'
name|'current_neutron_port'
op|','
nl|'\n'
name|'network_IPs'
op|')'
newline|'\n'
nl|'\n'
name|'devname'
op|'='
string|'"tap"'
op|'+'
name|'current_neutron_port'
op|'['
string|"'id'"
op|']'
newline|'\n'
name|'devname'
op|'='
name|'devname'
op|'['
op|':'
name|'network_model'
op|'.'
name|'NIC_NAME_LEN'
op|']'
newline|'\n'
nl|'\n'
name|'network'
op|','
name|'ovs_interfaceid'
op|'='
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_nw_info_build_network'
op|'('
name|'current_neutron_port'
op|','
nl|'\n'
name|'networks'
op|','
name|'subnets'
op|')'
op|')'
newline|'\n'
name|'preserve_on_delete'
op|'='
op|'('
name|'current_neutron_port'
op|'['
string|"'id'"
op|']'
name|'in'
nl|'\n'
name|'preexisting_port_ids'
op|')'
newline|'\n'
nl|'\n'
name|'nw_info'
op|'.'
name|'append'
op|'('
name|'network_model'
op|'.'
name|'VIF'
op|'('
nl|'\n'
name|'id'
op|'='
name|'current_neutron_port'
op|'['
string|"'id'"
op|']'
op|','
nl|'\n'
name|'address'
op|'='
name|'current_neutron_port'
op|'['
string|"'mac_address'"
op|']'
op|','
nl|'\n'
name|'network'
op|'='
name|'network'
op|','
nl|'\n'
name|'vnic_type'
op|'='
name|'current_neutron_port'
op|'.'
name|'get'
op|'('
string|"'binding:vnic_type'"
op|','
nl|'\n'
name|'network_model'
op|'.'
name|'VNIC_TYPE_NORMAL'
op|')'
op|','
nl|'\n'
name|'type'
op|'='
name|'current_neutron_port'
op|'.'
name|'get'
op|'('
string|"'binding:vif_type'"
op|')'
op|','
nl|'\n'
name|'profile'
op|'='
name|'current_neutron_port'
op|'.'
name|'get'
op|'('
string|"'binding:profile'"
op|')'
op|','
nl|'\n'
name|'details'
op|'='
name|'current_neutron_port'
op|'.'
name|'get'
op|'('
string|"'binding:vif_details'"
op|')'
op|','
nl|'\n'
name|'ovs_interfaceid'
op|'='
name|'ovs_interfaceid'
op|','
nl|'\n'
name|'devname'
op|'='
name|'devname'
op|','
nl|'\n'
name|'active'
op|'='
name|'vif_active'
op|','
nl|'\n'
name|'preserve_on_delete'
op|'='
name|'preserve_on_delete'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'nw_info_refresh'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Port %s from network info_cache is no '"
nl|'\n'
string|"'longer associated with instance in Neutron. '"
nl|'\n'
string|"'Removing from network info_cache.'"
op|')'
op|','
name|'port_id'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'nw_info'
newline|'\n'
nl|'\n'
DECL|member|_get_subnets_from_port
dedent|''
name|'def'
name|'_get_subnets_from_port'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'port'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the subnets for a given port."""'
newline|'\n'
nl|'\n'
name|'fixed_ips'
op|'='
name|'port'
op|'['
string|"'fixed_ips'"
op|']'
newline|'\n'
comment|'# No fixed_ips for the port means there is no subnet associated'
nl|'\n'
comment|'# with the network the port is created on.'
nl|'\n'
comment|'# Since list_subnets(id=[]) returns all subnets visible for the'
nl|'\n'
comment|'# current tenant, returned subnets may contain subnets which is not'
nl|'\n'
comment|'# related to the port. To avoid this, the method returns here.'
nl|'\n'
name|'if'
name|'not'
name|'fixed_ips'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'['
op|']'
newline|'\n'
dedent|''
name|'search_opts'
op|'='
op|'{'
string|"'id'"
op|':'
op|'['
name|'ip'
op|'['
string|"'subnet_id'"
op|']'
name|'for'
name|'ip'
name|'in'
name|'fixed_ips'
op|']'
op|'}'
newline|'\n'
name|'data'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
op|'.'
name|'list_subnets'
op|'('
op|'**'
name|'search_opts'
op|')'
newline|'\n'
name|'ipam_subnets'
op|'='
name|'data'
op|'.'
name|'get'
op|'('
string|"'subnets'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'subnets'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'subnet'
name|'in'
name|'ipam_subnets'
op|':'
newline|'\n'
indent|'            '
name|'subnet_dict'
op|'='
op|'{'
string|"'cidr'"
op|':'
name|'subnet'
op|'['
string|"'cidr'"
op|']'
op|','
nl|'\n'
string|"'gateway'"
op|':'
name|'network_model'
op|'.'
name|'IP'
op|'('
nl|'\n'
name|'address'
op|'='
name|'subnet'
op|'['
string|"'gateway_ip'"
op|']'
op|','
nl|'\n'
name|'type'
op|'='
string|"'gateway'"
op|')'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
comment|'# attempt to populate DHCP server field'
nl|'\n'
name|'search_opts'
op|'='
op|'{'
string|"'network_id'"
op|':'
name|'subnet'
op|'['
string|"'network_id'"
op|']'
op|','
nl|'\n'
string|"'device_owner'"
op|':'
string|"'network:dhcp'"
op|'}'
newline|'\n'
name|'data'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
op|'.'
name|'list_ports'
op|'('
op|'**'
name|'search_opts'
op|')'
newline|'\n'
name|'dhcp_ports'
op|'='
name|'data'
op|'.'
name|'get'
op|'('
string|"'ports'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'for'
name|'p'
name|'in'
name|'dhcp_ports'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'ip_pair'
name|'in'
name|'p'
op|'['
string|"'fixed_ips'"
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'ip_pair'
op|'['
string|"'subnet_id'"
op|']'
op|'=='
name|'subnet'
op|'['
string|"'id'"
op|']'
op|':'
newline|'\n'
indent|'                        '
name|'subnet_dict'
op|'['
string|"'dhcp_server'"
op|']'
op|'='
name|'ip_pair'
op|'['
string|"'ip_address'"
op|']'
newline|'\n'
name|'break'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'subnet_object'
op|'='
name|'network_model'
op|'.'
name|'Subnet'
op|'('
op|'**'
name|'subnet_dict'
op|')'
newline|'\n'
name|'for'
name|'dns'
name|'in'
name|'subnet'
op|'.'
name|'get'
op|'('
string|"'dns_nameservers'"
op|','
op|'['
op|']'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'subnet_object'
op|'.'
name|'add_dns'
op|'('
nl|'\n'
name|'network_model'
op|'.'
name|'IP'
op|'('
name|'address'
op|'='
name|'dns'
op|','
name|'type'
op|'='
string|"'dns'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'route'
name|'in'
name|'subnet'
op|'.'
name|'get'
op|'('
string|"'host_routes'"
op|','
op|'['
op|']'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'subnet_object'
op|'.'
name|'add_route'
op|'('
nl|'\n'
name|'network_model'
op|'.'
name|'Route'
op|'('
name|'cidr'
op|'='
name|'route'
op|'['
string|"'destination'"
op|']'
op|','
nl|'\n'
name|'gateway'
op|'='
name|'network_model'
op|'.'
name|'IP'
op|'('
nl|'\n'
name|'address'
op|'='
name|'route'
op|'['
string|"'nexthop'"
op|']'
op|','
nl|'\n'
name|'type'
op|'='
string|"'gateway'"
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'subnets'
op|'.'
name|'append'
op|'('
name|'subnet_object'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'subnets'
newline|'\n'
nl|'\n'
DECL|member|get_dns_domains
dedent|''
name|'def'
name|'get_dns_domains'
op|'('
name|'self'
op|','
name|'context'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a list of available dns domains.\n\n        These can be used to create DNS entries for floating IPs.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|add_dns_entry
dedent|''
name|'def'
name|'add_dns_entry'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'address'
op|','
name|'name'
op|','
name|'dns_type'
op|','
name|'domain'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create specified DNS entry for address."""'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|modify_dns_entry
dedent|''
name|'def'
name|'modify_dns_entry'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'name'
op|','
name|'address'
op|','
name|'domain'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create specified DNS entry for address."""'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|delete_dns_entry
dedent|''
name|'def'
name|'delete_dns_entry'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'name'
op|','
name|'domain'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Delete the specified dns entry."""'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|delete_dns_domain
dedent|''
name|'def'
name|'delete_dns_domain'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'domain'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Delete the specified dns domain."""'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_dns_entries_by_address
dedent|''
name|'def'
name|'get_dns_entries_by_address'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'address'
op|','
name|'domain'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get entries for address and domain."""'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_dns_entries_by_name
dedent|''
name|'def'
name|'get_dns_entries_by_name'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'name'
op|','
name|'domain'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get entries for name and domain."""'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|create_private_dns_domain
dedent|''
name|'def'
name|'create_private_dns_domain'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'domain'
op|','
name|'availability_zone'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a private DNS domain with nova availability zone."""'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|create_public_dns_domain
dedent|''
name|'def'
name|'create_public_dns_domain'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'domain'
op|','
name|'project'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a private DNS domain with optional nova project."""'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|setup_instance_network_on_host
dedent|''
name|'def'
name|'setup_instance_network_on_host'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'host'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Setup network for specified instance on host."""'
newline|'\n'
name|'self'
op|'.'
name|'_update_port_binding_for_instance'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'host'
op|')'
newline|'\n'
nl|'\n'
DECL|member|cleanup_instance_network_on_host
dedent|''
name|'def'
name|'cleanup_instance_network_on_host'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'host'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Cleanup network for specified instance on host."""'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|_update_port_binding_for_instance
dedent|''
name|'def'
name|'_update_port_binding_for_instance'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'host'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'self'
op|'.'
name|'_has_port_binding_extension'
op|'('
name|'context'
op|','
name|'refresh_cache'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'neutron'
op|'='
name|'get_client'
op|'('
name|'context'
op|','
name|'admin'
op|'='
name|'True'
op|')'
newline|'\n'
name|'search_opts'
op|'='
op|'{'
string|"'device_id'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|','
nl|'\n'
string|"'tenant_id'"
op|':'
name|'instance'
op|'.'
name|'project_id'
op|'}'
newline|'\n'
name|'data'
op|'='
name|'neutron'
op|'.'
name|'list_ports'
op|'('
op|'**'
name|'search_opts'
op|')'
newline|'\n'
name|'ports'
op|'='
name|'data'
op|'['
string|"'ports'"
op|']'
newline|'\n'
name|'for'
name|'p'
name|'in'
name|'ports'
op|':'
newline|'\n'
comment|"# If the host hasn't changed, like in the case of resizing to the"
nl|'\n'
comment|'# same host, there is nothing to do.'
nl|'\n'
indent|'            '
name|'if'
name|'p'
op|'.'
name|'get'
op|'('
string|"'binding:host_id'"
op|')'
op|'!='
name|'host'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'neutron'
op|'.'
name|'update_port'
op|'('
name|'p'
op|'['
string|"'id'"
op|']'
op|','
nl|'\n'
op|'{'
string|"'port'"
op|':'
op|'{'
string|"'binding:host_id'"
op|':'
name|'host'
op|'}'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                    '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|'"Unable to update host of port %s"'
op|')'
op|','
nl|'\n'
name|'p'
op|'['
string|"'id'"
op|']'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|update_instance_vnic_index
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'update_instance_vnic_index'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'vif'
op|','
name|'index'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Update instance vnic index.\n\n        When the \'VNIC index\' extension is supported this method will update\n        the vnic index of the instance on the port.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_refresh_neutron_extensions_cache'
op|'('
name|'context'
op|')'
newline|'\n'
name|'if'
name|'constants'
op|'.'
name|'VNIC_INDEX_EXT'
name|'in'
name|'self'
op|'.'
name|'extensions'
op|':'
newline|'\n'
indent|'            '
name|'neutron'
op|'='
name|'get_client'
op|'('
name|'context'
op|')'
newline|'\n'
name|'port_req_body'
op|'='
op|'{'
string|"'port'"
op|':'
op|'{'
string|"'vnic_index'"
op|':'
name|'index'
op|'}'
op|'}'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'neutron'
op|'.'
name|'update_port'
op|'('
name|'vif'
op|'['
string|"'id'"
op|']'
op|','
name|'port_req_body'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Unable to update instance VNIC index '"
nl|'\n'
string|"'for port %s.'"
op|')'
op|','
nl|'\n'
name|'vif'
op|'['
string|"'id'"
op|']'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_ensure_requested_network_ordering
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_ensure_requested_network_ordering'
op|'('
name|'accessor'
op|','
name|'unordered'
op|','
name|'preferred'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Sort a list with respect to the preferred network ordering."""'
newline|'\n'
name|'if'
name|'preferred'
op|':'
newline|'\n'
indent|'        '
name|'unordered'
op|'.'
name|'sort'
op|'('
name|'key'
op|'='
name|'lambda'
name|'i'
op|':'
name|'preferred'
op|'.'
name|'index'
op|'('
name|'accessor'
op|'('
name|'i'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
