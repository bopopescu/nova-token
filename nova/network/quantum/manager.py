begin_unit
comment|'# vim: tabstop=4 shiftwidth=4 softtabstop=4'
nl|'\n'
nl|'\n'
comment|'# Copyright 2011 Nicira Networks, Inc'
nl|'\n'
comment|'# All Rights Reserved.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
nl|'\n'
name|'import'
name|'time'
newline|'\n'
nl|'\n'
name|'import'
name|'netaddr'
newline|'\n'
nl|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'instance_types'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'context'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'db'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'exception'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'flags'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'log'
name|'as'
name|'logging'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'network'
name|'import'
name|'manager'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'network'
op|'.'
name|'quantum'
name|'import'
name|'melange_ipam_lib'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'network'
op|'.'
name|'quantum'
name|'import'
name|'quantum_connection'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'cfg'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'utils'
newline|'\n'
nl|'\n'
DECL|variable|LOG
name|'LOG'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
string|'"nova.network.quantum.manager"'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|quantum_opts
name|'quantum_opts'
op|'='
op|'['
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'quantum_ipam_lib'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'nova.network.quantum.nova_ipam_lib'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|'"Indicates underlying IP address management library"'
op|')'
op|','
nl|'\n'
comment|'# TODO(Vek): Eventually, this needs to mean more than just using'
nl|'\n'
comment|'#            Melange for assignment of MAC addresses (with an'
nl|'\n'
comment|'#            appropriate flag name change, of course), but this is all'
nl|'\n'
comment|'#            it does right now'
nl|'\n'
name|'cfg'
op|'.'
name|'BoolOpt'
op|'('
string|"'use_melange_mac_generation'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
name|'False'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|'"Use Melange for assignment of MAC addresses"'
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'BoolOpt'
op|'('
string|"'quantum_use_dhcp'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
name|'False'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Whether or not to enable DHCP for networks'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'BoolOpt'
op|'('
string|"'quantum_use_port_security'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
name|'False'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Whether or not to enable port security'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'BoolOpt'
op|'('
string|"'quantum_port_security_include_link_local'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
name|'False'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Add the link local address to the port security list'"
op|')'
op|','
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
DECL|variable|FLAGS
name|'FLAGS'
op|'='
name|'flags'
op|'.'
name|'FLAGS'
newline|'\n'
name|'FLAGS'
op|'.'
name|'add_options'
op|'('
name|'quantum_opts'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|QuantumManager
name|'class'
name|'QuantumManager'
op|'('
name|'manager'
op|'.'
name|'FloatingIP'
op|','
name|'manager'
op|'.'
name|'FlatManager'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""NetworkManager class that communicates with a Quantum service\n       via a web services API to provision VM network connectivity.\n\n       For IP Address management, QuantumManager can be configured to\n       use either Nova\'s local DB or the Melange IPAM service.\n\n       Currently, the QuantumManager does NOT support:\n            * floating IPs\n\n       Support for these capabilities are targted for future releases.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|DHCP
name|'DHCP'
op|'='
name|'FLAGS'
op|'.'
name|'quantum_use_dhcp'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'q_conn'
op|'='
name|'None'
op|','
name|'ipam_lib'
op|'='
name|'None'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Initialize two key libraries, the connection to a\n           Quantum service, and the library for implementing IPAM.\n\n           Calls inherited FlatManager constructor.\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'q_conn'
op|':'
newline|'\n'
indent|'            '
name|'q_conn'
op|'='
name|'quantum_connection'
op|'.'
name|'QuantumClientConnection'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'q_conn'
op|'='
name|'q_conn'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'ipam_lib'
op|':'
newline|'\n'
indent|'            '
name|'ipam_lib'
op|'='
name|'FLAGS'
op|'.'
name|'quantum_ipam_lib'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_import_ipam_lib'
op|'('
name|'ipam_lib'
op|')'
newline|'\n'
nl|'\n'
name|'super'
op|'('
name|'QuantumManager'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
DECL|member|init_host
dedent|''
name|'def'
name|'init_host'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|"# Don't call into self.driver (linux_net) unless dhcp is enabled"
nl|'\n'
indent|'        '
name|'if'
name|'not'
name|'FLAGS'
op|'.'
name|'quantum_use_dhcp'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
comment|'# Initialize general L3 networking'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'l3driver'
op|'.'
name|'initialize'
op|'('
op|')'
newline|'\n'
comment|'# Initialize floating ip support (only works for nova ipam currently)'
nl|'\n'
name|'if'
name|'FLAGS'
op|'.'
name|'quantum_ipam_lib'
op|'=='
string|"'nova.network.quantum.nova_ipam_lib'"
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Initializing FloatingIP support"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'init_host_floating_ips'
op|'('
op|')'
newline|'\n'
comment|'# Set up all the forwarding rules for any network that has a'
nl|'\n'
comment|'# gateway set.'
nl|'\n'
dedent|''
name|'networks'
op|'='
name|'self'
op|'.'
name|'get_all_networks'
op|'('
op|')'
newline|'\n'
name|'cidrs'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'net'
name|'in'
name|'networks'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'net'
op|'['
string|"'gateway'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Initializing NAT: %s (cidr: %s, gw: %s)"'
op|'%'
op|'('
nl|'\n'
name|'net'
op|'['
string|"'label'"
op|']'
op|','
name|'net'
op|'['
string|"'cidr'"
op|']'
op|','
name|'net'
op|'['
string|"'gateway'"
op|']'
op|')'
op|')'
newline|'\n'
name|'cidrs'
op|'.'
name|'append'
op|'('
name|'net'
op|'['
string|"'cidr'"
op|']'
op|')'
newline|'\n'
comment|'# .. and for each network'
nl|'\n'
dedent|''
dedent|''
name|'for'
name|'c'
name|'in'
name|'cidrs'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'l3driver'
op|'.'
name|'initialize_network'
op|'('
name|'c'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_nova_id
dedent|''
dedent|''
name|'def'
name|'_get_nova_id'
op|'('
name|'self'
op|','
name|'instance'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
comment|'# When creating the network we need to pass in an identifier for'
nl|'\n'
comment|'# this zone.  Some Quantum plugins need this information in order'
nl|'\n'
comment|'# to set up appropriate networking.'
nl|'\n'
indent|'        '
name|'if'
name|'instance'
name|'and'
name|'instance'
op|'['
string|"'availability_zone'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'instance'
op|'['
string|"'availability_zone'"
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'FLAGS'
op|'.'
name|'node_availability_zone'
newline|'\n'
nl|'\n'
DECL|member|get_all_networks
dedent|''
dedent|''
name|'def'
name|'get_all_networks'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'networks'
op|'='
op|'['
op|']'
newline|'\n'
name|'admin_context'
op|'='
name|'context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
newline|'\n'
name|'networks'
op|'.'
name|'extend'
op|'('
name|'self'
op|'.'
name|'ipam'
op|'.'
name|'get_global_networks'
op|'('
name|'admin_context'
op|')'
op|')'
newline|'\n'
name|'networks'
op|'.'
name|'extend'
op|'('
name|'self'
op|'.'
name|'ipam'
op|'.'
name|'get_project_networks'
op|'('
name|'admin_context'
op|')'
op|')'
newline|'\n'
name|'return'
name|'networks'
newline|'\n'
nl|'\n'
DECL|member|create_networks
dedent|''
name|'def'
name|'create_networks'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'label'
op|','
name|'cidr'
op|','
name|'multi_host'
op|','
name|'num_networks'
op|','
nl|'\n'
name|'network_size'
op|','
name|'cidr_v6'
op|','
name|'gateway'
op|','
name|'gateway_v6'
op|','
name|'bridge'
op|','
nl|'\n'
name|'bridge_interface'
op|','
name|'dns1'
op|'='
name|'None'
op|','
name|'dns2'
op|'='
name|'None'
op|','
name|'uuid'
op|'='
name|'None'
op|','
nl|'\n'
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Unlike other NetworkManagers, with QuantumManager, each\n           create_networks calls should create only a single network.\n\n           Two scenarios exist:\n                - no \'uuid\' is specified, in which case we contact\n                  Quantum and create a new network.\n                - an existing \'uuid\' is specified, corresponding to\n                  a Quantum network created out of band.\n\n           In both cases, we initialize a subnet using the IPAM lib.\n        """'
newline|'\n'
comment|'# Enforce Configuration sanity.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# These flags are passed in from bin/nova-manage. The script'
nl|'\n'
comment|'# collects the arguments and then passes them in through this'
nl|'\n'
comment|'# function call. Note that in some cases, the script pre-processes'
nl|'\n'
comment|"# the arguments, and sets them to a default value if a parameter's"
nl|'\n'
comment|'# value was not specified on the command line. For pre-processed'
nl|'\n'
comment|'# parameters, the most effective check to see if the user passed it'
nl|'\n'
comment|'# in is to see if is different from the default value. (This'
nl|'\n'
comment|'# does miss the use case where the user passes in the default value'
nl|'\n'
comment|'# on the command line -- but it is unavoidable.)'
nl|'\n'
name|'if'
name|'multi_host'
op|'!='
name|'FLAGS'
op|'.'
name|'multi_host'
op|':'
newline|'\n'
comment|'# User specified it on the command line.'
nl|'\n'
indent|'            '
name|'raise'
name|'Exception'
op|'('
name|'_'
op|'('
string|'"QuantumManager does not use \'multi_host\'"'
nl|'\n'
string|'" parameter."'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'num_networks'
op|'!='
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'Exception'
op|'('
name|'_'
op|'('
string|'"QuantumManager requires that only one"'
nl|'\n'
string|'" network is created per call"'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'network_size'
op|'!='
name|'int'
op|'('
name|'FLAGS'
op|'.'
name|'network_size'
op|')'
op|':'
newline|'\n'
comment|'# User specified it on the command line.'
nl|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warning'
op|'('
string|'"Ignoring unnecessary parameter \'network_size\'"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'vlan_start'"
op|','
name|'None'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'kwargs'
op|'['
string|"'vlan_start'"
op|']'
op|'!='
name|'int'
op|'('
name|'FLAGS'
op|'.'
name|'vlan_start'
op|')'
op|':'
newline|'\n'
comment|'# User specified it on the command line.'
nl|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_'
op|'('
string|'"QuantumManager does not use \'vlan_start\'"'
nl|'\n'
string|'" parameter."'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'vpn_start'"
op|','
name|'None'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'kwargs'
op|'['
string|"'vpn_start'"
op|']'
op|'!='
name|'int'
op|'('
name|'FLAGS'
op|'.'
name|'vpn_start'
op|')'
op|':'
newline|'\n'
comment|'# User specified it on the command line.'
nl|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_'
op|'('
string|'"QuantumManager does not use \'vpn_start\'"'
nl|'\n'
string|'" parameter."'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'bridge'
name|'is'
name|'not'
name|'None'
name|'and'
name|'len'
op|'('
name|'bridge'
op|')'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_'
op|'('
string|'"QuantumManager does not use \'bridge\'"'
nl|'\n'
string|'" parameter."'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'bridge_interface'
name|'is'
name|'not'
name|'None'
name|'and'
name|'len'
op|'('
name|'bridge_interface'
op|')'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_'
op|'('
string|'"QuantumManager does not use \'bridge_interface\'"'
nl|'\n'
string|'" parameter."'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'gateway'
name|'is'
name|'not'
name|'None'
name|'and'
name|'len'
op|'('
name|'gateway'
op|')'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'gateway'
op|'.'
name|'split'
op|'('
string|"'.'"
op|')'
op|'['
number|'3'
op|']'
op|'!='
string|"'1'"
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'Exception'
op|'('
name|'_'
op|'('
string|'"QuantumManager requires a valid (.1)"'
nl|'\n'
string|'" gateway address."'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'q_tenant_id'
op|'='
name|'kwargs'
op|'['
string|'"project_id"'
op|']'
name|'or'
name|'FLAGS'
op|'.'
name|'quantum_default_tenant_id'
newline|'\n'
name|'quantum_net_id'
op|'='
name|'uuid'
newline|'\n'
comment|'# If a uuid was specified with the network it should have already been'
nl|'\n'
comment|'# created in Quantum, so make sure.'
nl|'\n'
name|'if'
name|'quantum_net_id'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'self'
op|'.'
name|'q_conn'
op|'.'
name|'network_exists'
op|'('
name|'q_tenant_id'
op|','
name|'quantum_net_id'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'Exception'
op|'('
name|'_'
op|'('
string|'"Unable to find existing quantum "'
string|'" network for tenant \'%(q_tenant_id)s\' with "'
nl|'\n'
string|'"net-id \'%(quantum_net_id)s\'"'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'nova_id'
op|'='
name|'self'
op|'.'
name|'_get_nova_id'
op|'('
op|')'
newline|'\n'
name|'quantum_net_id'
op|'='
name|'self'
op|'.'
name|'q_conn'
op|'.'
name|'create_network'
op|'('
name|'q_tenant_id'
op|','
name|'label'
op|','
nl|'\n'
name|'nova_id'
op|'='
name|'nova_id'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'ipam_tenant_id'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|'"project_id"'
op|','
name|'None'
op|')'
newline|'\n'
name|'priority'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|'"priority"'
op|','
number|'0'
op|')'
newline|'\n'
comment|'# NOTE(tr3buchet): this call creates a nova network in the nova db'
nl|'\n'
name|'self'
op|'.'
name|'ipam'
op|'.'
name|'create_subnet'
op|'('
name|'context'
op|','
name|'label'
op|','
name|'ipam_tenant_id'
op|','
name|'quantum_net_id'
op|','
nl|'\n'
name|'priority'
op|','
name|'cidr'
op|','
name|'gateway'
op|','
name|'gateway_v6'
op|','
nl|'\n'
name|'cidr_v6'
op|','
name|'dns1'
op|','
name|'dns2'
op|')'
newline|'\n'
nl|'\n'
comment|'# Initialize forwarding'
nl|'\n'
name|'self'
op|'.'
name|'l3driver'
op|'.'
name|'initialize_network'
op|'('
name|'cidr'
op|')'
newline|'\n'
nl|'\n'
name|'return'
op|'['
op|'{'
string|"'uuid'"
op|':'
name|'quantum_net_id'
op|'}'
op|']'
newline|'\n'
nl|'\n'
DECL|member|_generate_gw_dev
dedent|''
name|'def'
name|'_generate_gw_dev'
op|'('
name|'self'
op|','
name|'network_id'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|'"gw-"'
op|'+'
name|'str'
op|'('
name|'network_id'
op|'['
number|'0'
op|':'
number|'11'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|delete_network
dedent|''
name|'def'
name|'delete_network'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'fixed_range'
op|','
name|'uuid'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Lookup network by uuid, delete both the IPAM\n           subnet and the corresponding Quantum network.\n\n           The fixed_range parameter is kept here for interface compatibility\n           but is not used.\n        """'
newline|'\n'
name|'quantum_net_id'
op|'='
name|'uuid'
newline|'\n'
name|'project_id'
op|'='
name|'context'
op|'.'
name|'project_id'
newline|'\n'
name|'if'
name|'project_id'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|'# If nothing was found we default to this'
nl|'\n'
indent|'            '
name|'project_id'
op|'='
name|'FLAGS'
op|'.'
name|'quantum_default_tenant_id'
newline|'\n'
dedent|''
name|'q_tenant_id'
op|'='
name|'project_id'
name|'or'
name|'FLAGS'
op|'.'
name|'quantum_default_tenant_id'
newline|'\n'
comment|'# Check for any attached ports on the network and fail the deletion if'
nl|'\n'
comment|'# there is anything but the gateway port attached.  If it is only the'
nl|'\n'
comment|'# gateway port, unattach and delete it.'
nl|'\n'
name|'ports'
op|'='
name|'self'
op|'.'
name|'q_conn'
op|'.'
name|'get_attached_ports'
op|'('
name|'q_tenant_id'
op|','
name|'quantum_net_id'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'ports'
op|')'
op|'>'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'Exception'
op|'('
name|'_'
op|'('
string|'"Network %s in use, cannot delete"'
op|'%'
nl|'\n'
op|'('
name|'quantum_net_id'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Ports currently on network: %s"'
op|'%'
name|'ports'
op|')'
newline|'\n'
name|'for'
name|'p'
name|'in'
name|'ports'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'p'
op|'['
string|'"attachment"'
op|']'
op|'.'
name|'startswith'
op|'('
string|'"gw-"'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'q_conn'
op|'.'
name|'detach_and_delete_port'
op|'('
name|'q_tenant_id'
op|','
nl|'\n'
name|'quantum_net_id'
op|','
nl|'\n'
name|'p'
op|'['
string|"'port-id'"
op|']'
op|')'
newline|'\n'
comment|'# Now we can delete the network'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'q_conn'
op|'.'
name|'delete_network'
op|'('
name|'q_tenant_id'
op|','
name|'quantum_net_id'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Deleting network for tenant: %s"'
op|'%'
name|'project_id'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'ipam'
op|'.'
name|'delete_subnets_by_net_id'
op|'('
name|'context'
op|','
name|'quantum_net_id'
op|','
nl|'\n'
name|'project_id'
op|')'
newline|'\n'
comment|'# Get rid of dnsmasq'
nl|'\n'
name|'if'
name|'FLAGS'
op|'.'
name|'quantum_use_dhcp'
op|':'
newline|'\n'
indent|'            '
name|'dev'
op|'='
name|'self'
op|'.'
name|'_generate_gw_dev'
op|'('
name|'quantum_net_id'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'driver'
op|'.'
name|'kill_dhcp'
op|'('
name|'dev'
op|')'
newline|'\n'
nl|'\n'
DECL|member|allocate_for_instance
dedent|''
dedent|''
name|'def'
name|'allocate_for_instance'
op|'('
name|'self'
op|','
name|'context'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Called by compute when it is creating a new VM.\n\n           There are three key tasks:\n                - Determine the number and order of vNICs to create\n                - Allocate IP addresses\n                - Create ports on a Quantum network and attach vNICs.\n\n           We support two approaches to determining vNICs:\n                - By default, a VM gets a vNIC for any network belonging\n                  to the VM\'s project, and a vNIC for any "global" network\n                  that has a NULL project_id.  vNIC order is determined\n                  by the network\'s \'priority\' field.\n                - If the \'os-create-server-ext\' was used to create the VM,\n                  only the networks in \'requested_networks\' are used to\n                  create vNICs, and the vNIC order is determiend by the\n                  order in the requested_networks array.\n\n           For each vNIC, use the FlatManager to create the entries\n           in the virtual_interfaces table, contact Quantum to\n           create a port and attachment the vNIC, and use the IPAM\n           lib to allocate IP addresses.\n        """'
newline|'\n'
name|'instance_id'
op|'='
name|'kwargs'
op|'.'
name|'pop'
op|'('
string|"'instance_id'"
op|')'
newline|'\n'
name|'instance_type_id'
op|'='
name|'kwargs'
op|'['
string|"'instance_type_id'"
op|']'
newline|'\n'
name|'host'
op|'='
name|'kwargs'
op|'.'
name|'pop'
op|'('
string|"'host'"
op|')'
newline|'\n'
name|'project_id'
op|'='
name|'kwargs'
op|'.'
name|'pop'
op|'('
string|"'project_id'"
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"network allocations for instance %s"'
op|')'
op|','
name|'project_id'
op|')'
newline|'\n'
name|'requested_networks'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'requested_networks'"
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'requested_networks'
op|':'
newline|'\n'
indent|'            '
name|'net_proj_pairs'
op|'='
op|'['
op|'('
name|'net_id'
op|','
name|'project_id'
op|')'
name|'for'
op|'('
name|'net_id'
op|','
name|'_i'
op|')'
name|'in'
name|'requested_networks'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'net_proj_pairs'
op|'='
name|'self'
op|'.'
name|'ipam'
op|'.'
name|'get_project_and_global_net_ids'
op|'('
name|'context'
op|','
nl|'\n'
name|'project_id'
op|')'
newline|'\n'
nl|'\n'
comment|'# Create a port via quantum and attach the vif'
nl|'\n'
dedent|''
name|'for'
op|'('
name|'quantum_net_id'
op|','
name|'net_tenant_id'
op|')'
name|'in'
name|'net_proj_pairs'
op|':'
newline|'\n'
indent|'            '
name|'net_tenant_id'
op|'='
name|'net_tenant_id'
name|'or'
name|'FLAGS'
op|'.'
name|'quantum_default_tenant_id'
newline|'\n'
comment|"# FIXME(danwent): We'd like to have the manager be"
nl|'\n'
comment|'# completely decoupled from the nova networks table.'
nl|'\n'
comment|'# However, other parts of nova sometimes go behind our'
nl|'\n'
comment|'# back and access network data directly from the DB.  So'
nl|'\n'
comment|'# for now, the quantum manager knows that there is a nova'
nl|'\n'
comment|'# networks DB table and accesses it here.  updating the'
nl|'\n'
comment|'# virtual_interfaces table to use UUIDs would be one'
nl|'\n'
comment|'# solution, but this would require significant work'
nl|'\n'
comment|'# elsewhere.'
nl|'\n'
name|'admin_context'
op|'='
name|'context'
op|'.'
name|'elevated'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# We may not be able to get a network_ref here if this network'
nl|'\n'
comment|"# isn't in the database (i.e. it came from Quantum)."
nl|'\n'
name|'network_ref'
op|'='
name|'db'
op|'.'
name|'network_get_by_uuid'
op|'('
name|'admin_context'
op|','
nl|'\n'
name|'quantum_net_id'
op|')'
newline|'\n'
name|'if'
name|'network_ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'network_ref'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'network_ref'
op|'='
op|'{'
string|'"uuid"'
op|':'
name|'quantum_net_id'
op|','
nl|'\n'
string|'"project_id"'
op|':'
name|'net_tenant_id'
op|','
nl|'\n'
comment|'# NOTE(bgh): We need to document this somewhere but since'
nl|'\n'
comment|"# we don't know the priority of any networks we get from"
nl|'\n'
comment|'# quantum we just give them a priority of 0.  If its'
nl|'\n'
comment|'# necessary to specify the order of the vifs and what'
nl|'\n'
comment|'# network they map to then the user will have to use the'
nl|'\n'
comment|'# OSCreateServer extension and specify them explicitly.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# In the future users will be able to tag quantum networks'
nl|'\n'
comment|'# with a priority .. and at that point we can update the'
nl|'\n'
comment|'# code here to reflect that.'
nl|'\n'
string|'"priority"'
op|':'
number|'0'
op|','
nl|'\n'
string|'"id"'
op|':'
string|"'NULL'"
op|','
nl|'\n'
string|'"label"'
op|':'
string|'"quantum-net-%s"'
op|'%'
name|'quantum_net_id'
op|'}'
newline|'\n'
nl|'\n'
comment|'# TODO(tr3buchet): broken. Virtual interfaces require an integer'
nl|'\n'
comment|'#                  network ID and it is not nullable'
nl|'\n'
dedent|''
name|'vif_rec'
op|'='
name|'self'
op|'.'
name|'add_virtual_interface'
op|'('
name|'context'
op|','
nl|'\n'
name|'instance_id'
op|','
nl|'\n'
name|'network_ref'
op|'['
string|"'id'"
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# talk to Quantum API to create and attach port.'
nl|'\n'
name|'instance'
op|'='
name|'db'
op|'.'
name|'instance_get'
op|'('
name|'context'
op|','
name|'instance_id'
op|')'
newline|'\n'
name|'instance_type'
op|'='
name|'instance_types'
op|'.'
name|'get_instance_type'
op|'('
name|'instance_type_id'
op|')'
newline|'\n'
name|'rxtx_factor'
op|'='
name|'instance_type'
op|'['
string|"'rxtx_factor'"
op|']'
newline|'\n'
name|'nova_id'
op|'='
name|'self'
op|'.'
name|'_get_nova_id'
op|'('
name|'instance'
op|')'
newline|'\n'
comment|'# Tell the ipam library to allocate an IP'
nl|'\n'
name|'ips'
op|'='
name|'self'
op|'.'
name|'ipam'
op|'.'
name|'allocate_fixed_ips'
op|'('
name|'context'
op|','
name|'project_id'
op|','
nl|'\n'
name|'quantum_net_id'
op|','
name|'net_tenant_id'
op|','
name|'vif_rec'
op|')'
newline|'\n'
name|'pairs'
op|'='
op|'['
op|']'
newline|'\n'
comment|'# Set up port security if enabled'
nl|'\n'
name|'if'
name|'FLAGS'
op|'.'
name|'quantum_use_port_security'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'FLAGS'
op|'.'
name|'quantum_port_security_include_link_local'
op|':'
newline|'\n'
indent|'                    '
name|'mac'
op|'='
name|'netaddr'
op|'.'
name|'EUI'
op|'('
name|'vif_rec'
op|'['
string|"'address'"
op|']'
op|')'
newline|'\n'
name|'ips'
op|'.'
name|'append'
op|'('
name|'str'
op|'('
name|'mac'
op|'.'
name|'ipv6_link_local'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'pairs'
op|'='
op|'['
op|'{'
string|"'mac_address'"
op|':'
name|'vif_rec'
op|'['
string|"'address'"
op|']'
op|','
nl|'\n'
string|"'ip_address'"
op|':'
name|'ip'
op|'}'
name|'for'
name|'ip'
name|'in'
name|'ips'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'q_conn'
op|'.'
name|'create_and_attach_port'
op|'('
name|'net_tenant_id'
op|','
name|'quantum_net_id'
op|','
nl|'\n'
name|'vif_rec'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
name|'vm_id'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
name|'rxtx_factor'
op|'='
name|'rxtx_factor'
op|','
nl|'\n'
name|'nova_id'
op|'='
name|'nova_id'
op|','
nl|'\n'
name|'allowed_address_pairs'
op|'='
name|'pairs'
op|')'
newline|'\n'
comment|'# Set up/start the dhcp server for this network if necessary'
nl|'\n'
name|'if'
name|'FLAGS'
op|'.'
name|'quantum_use_dhcp'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'enable_dhcp'
op|'('
name|'context'
op|','
name|'quantum_net_id'
op|','
name|'network_ref'
op|','
nl|'\n'
name|'vif_rec'
op|','
name|'net_tenant_id'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'get_instance_nw_info'
op|'('
name|'context'
op|','
name|'instance_id'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
name|'instance_type_id'
op|','
name|'host'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'utils'
op|'.'
name|'synchronized'
op|'('
string|"'quantum-enable-dhcp'"
op|')'
newline|'\n'
DECL|member|enable_dhcp
name|'def'
name|'enable_dhcp'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'quantum_net_id'
op|','
name|'network_ref'
op|','
name|'vif_rec'
op|','
nl|'\n'
name|'project_id'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'info'
op|'('
string|'"Using DHCP for network: %s"'
op|'%'
name|'network_ref'
op|'['
string|"'label'"
op|']'
op|')'
newline|'\n'
comment|'# Figure out the ipam tenant id for this subnet:  We need to'
nl|'\n'
comment|'# query for the tenant_id since the network could be created'
nl|'\n'
comment|'# with the project_id as the tenant or the default tenant.'
nl|'\n'
name|'ipam_tenant_id'
op|'='
name|'self'
op|'.'
name|'ipam'
op|'.'
name|'get_tenant_id_by_net_id'
op|'('
name|'context'
op|','
nl|'\n'
name|'quantum_net_id'
op|','
name|'vif_rec'
op|'['
string|"'uuid'"
op|']'
op|','
name|'project_id'
op|')'
newline|'\n'
comment|'# Figure out what subnets correspond to this network'
nl|'\n'
name|'subnets'
op|'='
name|'self'
op|'.'
name|'ipam'
op|'.'
name|'get_subnets_by_net_id'
op|'('
name|'context'
op|','
nl|'\n'
name|'ipam_tenant_id'
op|','
name|'quantum_net_id'
op|','
name|'vif_rec'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Set up (or find) the dhcp server for each of the subnets'
nl|'\n'
comment|'# returned above (both v4 and v6).'
nl|'\n'
name|'for'
name|'subnet'
name|'in'
name|'subnets'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'subnet'
name|'is'
name|'None'
name|'or'
name|'subnet'
op|'['
string|"'cidr'"
op|']'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
comment|'# Fill in some of the network fields that we would have'
nl|'\n'
comment|"# previously gotten from the network table (they'll be"
nl|'\n'
comment|'# passed to the linux_net functions).'
nl|'\n'
dedent|''
name|'network_ref'
op|'['
string|"'cidr'"
op|']'
op|'='
name|'subnet'
op|'['
string|"'cidr'"
op|']'
newline|'\n'
name|'n'
op|'='
name|'netaddr'
op|'.'
name|'IPNetwork'
op|'('
name|'subnet'
op|'['
string|"'cidr'"
op|']'
op|')'
newline|'\n'
comment|'# NOTE(tr3buchet): should probably not always assume first+1'
nl|'\n'
name|'network_ref'
op|'['
string|"'dhcp_server'"
op|']'
op|'='
name|'netaddr'
op|'.'
name|'IPAddress'
op|'('
name|'n'
op|'.'
name|'first'
op|'+'
number|'1'
op|')'
newline|'\n'
comment|'# TODO(bgh): Melange should probably track dhcp_start'
nl|'\n'
comment|'# TODO(tr3buchet): melange should store dhcp_server as well'
nl|'\n'
name|'if'
name|'not'
string|"'dhcp_start'"
name|'in'
name|'network_ref'
name|'or'
name|'network_ref'
op|'['
string|"'dhcp_start'"
op|']'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'network_ref'
op|'['
string|"'dhcp_start'"
op|']'
op|'='
name|'netaddr'
op|'.'
name|'IPAddress'
op|'('
name|'n'
op|'.'
name|'first'
op|'+'
number|'2'
op|')'
newline|'\n'
dedent|''
name|'network_ref'
op|'['
string|"'broadcast'"
op|']'
op|'='
name|'netaddr'
op|'.'
name|'IPAddress'
op|'('
name|'n'
op|'.'
name|'broadcast'
op|')'
newline|'\n'
name|'network_ref'
op|'['
string|"'gateway'"
op|']'
op|'='
name|'subnet'
op|'['
string|"'gateway'"
op|']'
newline|'\n'
comment|"# Construct the interface id that we'll use for the bridge"
nl|'\n'
name|'interface_id'
op|'='
string|'"gw-"'
op|'+'
name|'str'
op|'('
name|'network_ref'
op|'['
string|"'uuid'"
op|']'
op|'['
number|'0'
op|':'
number|'11'
op|']'
op|')'
newline|'\n'
name|'network_ref'
op|'['
string|"'bridge'"
op|']'
op|'='
name|'interface_id'
newline|'\n'
comment|"# Query quantum to see if we've already created a port for"
nl|'\n'
comment|'# the gateway device and attached the device to the port.'
nl|'\n'
comment|"# If we haven't then we need to intiialize it and create"
nl|'\n'
comment|'# it.  This device will be the one serving dhcp via'
nl|'\n'
comment|'# dnsmasq.'
nl|'\n'
name|'q_tenant_id'
op|'='
name|'project_id'
name|'or'
name|'FLAGS'
op|'.'
name|'quantum_default_tenant_id'
newline|'\n'
name|'port'
op|'='
name|'self'
op|'.'
name|'q_conn'
op|'.'
name|'get_port_by_attachment'
op|'('
name|'q_tenant_id'
op|','
nl|'\n'
name|'quantum_net_id'
op|','
name|'interface_id'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'port'
op|':'
comment|'# No dhcp server has been started'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'l3driver'
op|'.'
name|'initialize_gateway'
op|'('
name|'network_ref'
op|')'
newline|'\n'
name|'dev'
op|'='
name|'self'
op|'.'
name|'driver'
op|'.'
name|'get_dev'
op|'('
name|'network_ref'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Intializing DHCP for network: %s"'
op|'%'
nl|'\n'
name|'network_ref'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'q_conn'
op|'.'
name|'create_and_attach_port'
op|'('
name|'q_tenant_id'
op|','
nl|'\n'
name|'quantum_net_id'
op|','
name|'interface_id'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
comment|"# We've already got one and its plugged in"
newline|'\n'
indent|'                '
name|'dev'
op|'='
name|'interface_id'
newline|'\n'
nl|'\n'
dedent|''
name|'hosts'
op|'='
name|'self'
op|'.'
name|'get_dhcp_hosts_text'
op|'('
name|'context'
op|','
nl|'\n'
name|'subnet'
op|'['
string|"'network_id'"
op|']'
op|','
name|'project_id'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'driver'
op|'.'
name|'update_dhcp_hostfile_with_text'
op|'('
name|'dev'
op|','
name|'hosts'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'driver'
op|'.'
name|'restart_dhcp'
op|'('
name|'context'
op|','
name|'dev'
op|','
name|'network_ref'
op|')'
newline|'\n'
nl|'\n'
DECL|member|add_virtual_interface
dedent|''
dedent|''
name|'def'
name|'add_virtual_interface'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance_id'
op|','
name|'network_id'
op|')'
op|':'
newline|'\n'
comment|"# If we're not using melange, use the default means..."
nl|'\n'
indent|'        '
name|'if'
name|'FLAGS'
op|'.'
name|'use_melange_mac_generation'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'_add_virtual_interface'
op|'('
name|'context'
op|','
name|'instance_id'
op|','
nl|'\n'
name|'network_id'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'super'
op|'('
name|'QuantumManager'
op|','
name|'self'
op|')'
op|'.'
name|'add_virtual_interface'
op|'('
name|'context'
op|','
nl|'\n'
name|'instance_id'
op|','
nl|'\n'
name|'network_id'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_add_virtual_interface
dedent|''
name|'def'
name|'_add_virtual_interface'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance_id'
op|','
name|'network_id'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'vif'
op|'='
op|'{'
string|"'instance_id'"
op|':'
name|'instance_id'
op|','
nl|'\n'
string|"'network_id'"
op|':'
name|'network_id'
op|','
nl|'\n'
string|"'uuid'"
op|':'
name|'str'
op|'('
name|'utils'
op|'.'
name|'gen_uuid'
op|'('
op|')'
op|')'
op|'}'
newline|'\n'
nl|'\n'
comment|'# TODO(Vek): Ideally, we would have a VirtualInterface class'
nl|'\n'
comment|'#            that would take care of delegating to whoever it'
nl|'\n'
comment|"#            needs to get information from.  We'll look at"
nl|'\n'
comment|"#            this after Trey's refactorings..."
nl|'\n'
name|'m_ipam'
op|'='
name|'melange_ipam_lib'
op|'.'
name|'get_ipam_lib'
op|'('
name|'self'
op|')'
newline|'\n'
name|'vif'
op|'['
string|"'address'"
op|']'
op|'='
name|'m_ipam'
op|'.'
name|'create_vif'
op|'('
name|'vif'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
name|'vif'
op|'['
string|"'instance_id'"
op|']'
op|','
nl|'\n'
name|'context'
op|'.'
name|'project_id'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'db'
op|'.'
name|'virtual_interface_create'
op|'('
name|'context'
op|','
name|'vif'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_instance_nw_info
dedent|''
name|'def'
name|'get_instance_nw_info'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance_id'
op|','
name|'instance_uuid'
op|','
nl|'\n'
name|'instance_type_id'
op|','
name|'host'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""This method is used by compute to fetch all network data\n           that should be used when creating the VM.\n\n           The method simply loops through all virtual interfaces\n           stored in the nova DB and queries the IPAM lib to get\n           the associated IP data.\n\n           The format of returned data is \'defined\' by the initial\n           set of NetworkManagers found in nova/network/manager.py .\n           Ideally this \'interface\' will be more formally defined\n           in the future.\n        """'
newline|'\n'
name|'admin_context'
op|'='
name|'context'
op|'.'
name|'elevated'
op|'('
op|')'
newline|'\n'
name|'project_id'
op|'='
name|'context'
op|'.'
name|'project_id'
newline|'\n'
name|'vifs'
op|'='
name|'db'
op|'.'
name|'virtual_interface_get_by_instance'
op|'('
name|'context'
op|','
name|'instance_id'
op|')'
newline|'\n'
name|'instance_type'
op|'='
name|'instance_types'
op|'.'
name|'get_instance_type'
op|'('
name|'instance_type_id'
op|')'
newline|'\n'
nl|'\n'
name|'net_tenant_dict'
op|'='
name|'dict'
op|'('
op|'('
name|'net_id'
op|','
name|'tenant_id'
op|')'
nl|'\n'
name|'for'
op|'('
name|'net_id'
op|','
name|'tenant_id'
op|')'
nl|'\n'
name|'in'
name|'self'
op|'.'
name|'ipam'
op|'.'
name|'get_project_and_global_net_ids'
op|'('
nl|'\n'
name|'context'
op|','
name|'project_id'
op|')'
op|')'
newline|'\n'
name|'networks'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'vif'
name|'in'
name|'vifs'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'vif'
op|'.'
name|'get'
op|'('
string|"'network_id'"
op|')'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'network'
op|'='
name|'db'
op|'.'
name|'network_get'
op|'('
name|'admin_context'
op|','
name|'vif'
op|'['
string|"'network_id'"
op|']'
op|')'
newline|'\n'
name|'net_tenant_id'
op|'='
name|'net_tenant_dict'
op|'['
name|'network'
op|'['
string|"'uuid'"
op|']'
op|']'
newline|'\n'
name|'if'
name|'net_tenant_id'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'net_tenant_id'
op|'='
name|'FLAGS'
op|'.'
name|'quantum_default_tenant_id'
newline|'\n'
dedent|''
name|'network'
op|'='
op|'{'
string|"'id'"
op|':'
name|'network'
op|'['
string|"'id'"
op|']'
op|','
nl|'\n'
string|"'uuid'"
op|':'
name|'network'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
string|"'bridge'"
op|':'
string|"''"
op|','
comment|'# Quantum ignores this field'
nl|'\n'
string|"'label'"
op|':'
name|'network'
op|'['
string|"'label'"
op|']'
op|','
nl|'\n'
string|"'project_id'"
op|':'
name|'net_tenant_id'
op|'}'
newline|'\n'
name|'networks'
op|'['
name|'vif'
op|'['
string|"'uuid'"
op|']'
op|']'
op|'='
name|'network'
newline|'\n'
nl|'\n'
comment|'# update instance network cache and return network_info'
nl|'\n'
dedent|''
dedent|''
name|'nw_info'
op|'='
name|'self'
op|'.'
name|'build_network_info_model'
op|'('
name|'context'
op|','
name|'vifs'
op|','
name|'networks'
op|','
nl|'\n'
name|'instance_type'
op|','
name|'host'
op|')'
newline|'\n'
name|'db'
op|'.'
name|'instance_info_cache_update'
op|'('
name|'context'
op|','
name|'instance_uuid'
op|','
nl|'\n'
op|'{'
string|"'network_info'"
op|':'
name|'nw_info'
op|'.'
name|'as_cache'
op|'('
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'nw_info'
newline|'\n'
nl|'\n'
DECL|member|deallocate_for_instance
dedent|''
name|'def'
name|'deallocate_for_instance'
op|'('
name|'self'
op|','
name|'context'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Called when a VM is terminated.  Loop through each virtual\n           interface in the Nova DB and remove the Quantum port and\n           clear the IP allocation using the IPAM.  Finally, remove\n           the virtual interfaces from the Nova DB.\n        """'
newline|'\n'
name|'instance_id'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'instance_id'"
op|')'
newline|'\n'
name|'project_id'
op|'='
name|'kwargs'
op|'.'
name|'pop'
op|'('
string|"'project_id'"
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'admin_context'
op|'='
name|'context'
op|'.'
name|'elevated'
op|'('
op|')'
newline|'\n'
name|'vifs'
op|'='
name|'db'
op|'.'
name|'virtual_interface_get_by_instance'
op|'('
name|'admin_context'
op|','
nl|'\n'
name|'instance_id'
op|')'
newline|'\n'
name|'for'
name|'vif_ref'
name|'in'
name|'vifs'
op|':'
newline|'\n'
indent|'            '
name|'interface_id'
op|'='
name|'vif_ref'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'q_tenant_id'
op|'='
name|'project_id'
newline|'\n'
nl|'\n'
name|'network_ref'
op|'='
name|'db'
op|'.'
name|'network_get'
op|'('
name|'admin_context'
op|','
name|'vif_ref'
op|'['
string|"'network_id'"
op|']'
op|')'
newline|'\n'
name|'net_id'
op|'='
name|'network_ref'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
nl|'\n'
comment|'# port deallocate block'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'port_id'
op|'='
name|'None'
newline|'\n'
name|'port_id'
op|'='
name|'self'
op|'.'
name|'q_conn'
op|'.'
name|'get_port_by_attachment'
op|'('
name|'q_tenant_id'
op|','
nl|'\n'
name|'net_id'
op|','
name|'interface_id'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'port_id'
op|':'
newline|'\n'
indent|'                    '
name|'q_tenant_id'
op|'='
name|'FLAGS'
op|'.'
name|'quantum_default_tenant_id'
newline|'\n'
name|'port_id'
op|'='
name|'self'
op|'.'
name|'q_conn'
op|'.'
name|'get_port_by_attachment'
op|'('
nl|'\n'
name|'q_tenant_id'
op|','
name|'net_id'
op|','
name|'interface_id'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'port_id'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'error'
op|'('
string|'"Unable to find port with attachment: %s"'
op|'%'
nl|'\n'
op|'('
name|'interface_id'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'q_conn'
op|'.'
name|'detach_and_delete_port'
op|'('
name|'q_tenant_id'
op|','
nl|'\n'
name|'net_id'
op|','
name|'port_id'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|':'
newline|'\n'
comment|'# except anything so the rest of deallocate can succeed'
nl|'\n'
indent|'                '
name|'msg'
op|'='
name|'_'
op|'('
string|"'port deallocation failed for instance: '"
nl|'\n'
string|"'|%(instance_id)s|, port_id: |%(port_id)s|'"
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'critical'
op|'('
name|'msg'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# ipam deallocation block'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'ipam_tenant_id'
op|'='
name|'self'
op|'.'
name|'ipam'
op|'.'
name|'get_tenant_id_by_net_id'
op|'('
name|'context'
op|','
nl|'\n'
name|'net_id'
op|','
name|'vif_ref'
op|'['
string|"'uuid'"
op|']'
op|','
name|'project_id'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'ipam'
op|'.'
name|'deallocate_ips_by_vif'
op|'('
name|'context'
op|','
name|'ipam_tenant_id'
op|','
nl|'\n'
name|'net_id'
op|','
name|'vif_ref'
op|')'
newline|'\n'
name|'db'
op|'.'
name|'virtual_interface_delete'
op|'('
name|'admin_context'
op|','
name|'vif_ref'
op|'['
string|"'id'"
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# If DHCP is enabled on this network then we need to update the'
nl|'\n'
comment|'# leases and restart the server.'
nl|'\n'
name|'if'
name|'FLAGS'
op|'.'
name|'quantum_use_dhcp'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'update_dhcp'
op|'('
name|'context'
op|','
name|'ipam_tenant_id'
op|','
name|'network_ref'
op|','
nl|'\n'
name|'vif_ref'
op|','
name|'project_id'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|':'
newline|'\n'
comment|'# except anything so the rest of deallocate can succeed'
nl|'\n'
indent|'                '
name|'vif_uuid'
op|'='
name|'vif_ref'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'msg'
op|'='
name|'_'
op|'('
string|"'ipam deallocation failed for instance: '"
nl|'\n'
string|"'|%(instance_id)s|, vif_uuid: |%(vif_uuid)s|'"
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'critical'
op|'('
name|'msg'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(bgh): At some point we should consider merging enable_dhcp() and'
nl|'\n'
comment|'# update_dhcp()'
nl|'\n'
comment|"# TODO(tr3buchet): agree, i'm curious why they differ even now.."
nl|'\n'
DECL|member|update_dhcp
dedent|''
dedent|''
dedent|''
name|'def'
name|'update_dhcp'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'ipam_tenant_id'
op|','
name|'network_ref'
op|','
name|'vif_ref'
op|','
nl|'\n'
name|'project_id'
op|')'
op|':'
newline|'\n'
comment|'# Figure out what subnet corresponds to this network/vif'
nl|'\n'
indent|'        '
name|'subnets'
op|'='
name|'self'
op|'.'
name|'ipam'
op|'.'
name|'get_subnets_by_net_id'
op|'('
name|'context'
op|','
nl|'\n'
name|'ipam_tenant_id'
op|','
name|'network_ref'
op|'['
string|"'uuid'"
op|']'
op|','
name|'vif_ref'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
name|'for'
name|'subnet'
name|'in'
name|'subnets'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'subnet'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
comment|'# Fill in some of the network fields that we would have'
nl|'\n'
comment|"# previously gotten from the network table (they'll be"
nl|'\n'
comment|'# passed to the linux_net functions).'
nl|'\n'
dedent|''
name|'if'
name|'subnet'
op|'['
string|"'cidr'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'network_ref'
op|'['
string|"'cidr'"
op|']'
op|'='
name|'subnet'
op|'['
string|"'cidr'"
op|']'
newline|'\n'
dedent|''
name|'n'
op|'='
name|'netaddr'
op|'.'
name|'IPNetwork'
op|'('
name|'network_ref'
op|'['
string|"'cidr'"
op|']'
op|')'
newline|'\n'
name|'network_ref'
op|'['
string|"'dhcp_server'"
op|']'
op|'='
name|'netaddr'
op|'.'
name|'IPAddress'
op|'('
name|'n'
op|'.'
name|'first'
op|'+'
number|'1'
op|')'
newline|'\n'
name|'network_ref'
op|'['
string|"'dhcp_start'"
op|']'
op|'='
name|'netaddr'
op|'.'
name|'IPAddress'
op|'('
name|'n'
op|'.'
name|'first'
op|'+'
number|'2'
op|')'
newline|'\n'
name|'network_ref'
op|'['
string|"'broadcast'"
op|']'
op|'='
name|'netaddr'
op|'.'
name|'IPAddress'
op|'('
name|'n'
op|'.'
name|'broadcast'
op|')'
newline|'\n'
name|'network_ref'
op|'['
string|"'gateway'"
op|']'
op|'='
name|'netaddr'
op|'.'
name|'IPAddress'
op|'('
name|'n'
op|'.'
name|'first'
op|'+'
number|'1'
op|')'
newline|'\n'
name|'dev'
op|'='
name|'self'
op|'.'
name|'_generate_gw_dev'
op|'('
name|'network_ref'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
comment|'# And remove the dhcp mappings for the subnet'
nl|'\n'
name|'hosts'
op|'='
name|'self'
op|'.'
name|'get_dhcp_hosts_text'
op|'('
name|'context'
op|','
nl|'\n'
name|'subnet'
op|'['
string|"'network_id'"
op|']'
op|','
name|'project_id'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'driver'
op|'.'
name|'update_dhcp_hostfile_with_text'
op|'('
name|'dev'
op|','
name|'hosts'
op|')'
newline|'\n'
comment|'# Restart dnsmasq'
nl|'\n'
name|'self'
op|'.'
name|'driver'
op|'.'
name|'kill_dhcp'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'driver'
op|'.'
name|'restart_dhcp'
op|'('
name|'context'
op|','
name|'dev'
op|','
name|'network_ref'
op|')'
newline|'\n'
nl|'\n'
DECL|member|validate_networks
dedent|''
dedent|''
name|'def'
name|'validate_networks'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'networks'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Validates that this tenant has quantum networks with the associated\n           UUIDs.  This is called by the \'os-create-server-ext\' API extension\n           code so that we can return an API error code to the caller if they\n           request an invalid network.\n        """'
newline|'\n'
name|'if'
name|'networks'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'project_id'
op|'='
name|'context'
op|'.'
name|'project_id'
newline|'\n'
name|'for'
op|'('
name|'net_id'
op|','
name|'_i'
op|')'
name|'in'
name|'networks'
op|':'
newline|'\n'
comment|'# TODO(bgh): At some point we should figure out whether or'
nl|'\n'
comment|'# not we want the verify_subnet_exists call to be optional.'
nl|'\n'
indent|'            '
name|'if'
name|'not'
name|'self'
op|'.'
name|'ipam'
op|'.'
name|'verify_subnet_exists'
op|'('
name|'context'
op|','
name|'project_id'
op|','
nl|'\n'
name|'net_id'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'NetworkNotFound'
op|'('
name|'network_id'
op|'='
name|'net_id'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'q_conn'
op|'.'
name|'network_exists'
op|'('
name|'project_id'
op|','
name|'net_id'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'NetworkNotFound'
op|'('
name|'network_id'
op|'='
name|'net_id'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(bgh): deallocate_for_instance will take care of this..  The reason'
nl|'\n'
comment|"# we're providing this is so that NetworkManager::release_fixed_ip() isn't"
nl|'\n'
comment|"# called.  It does some database operations that we don't want to happen"
nl|'\n'
comment|'# and since the majority of the stuff that it does is already taken care'
nl|'\n'
comment|"# of in our deallocate_for_instance call we don't need to do anything."
nl|'\n'
DECL|member|release_fixed_ip
dedent|''
dedent|''
dedent|''
name|'def'
name|'release_fixed_ip'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'address'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|get_dhcp_hosts_text
dedent|''
name|'def'
name|'get_dhcp_hosts_text'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'subnet_id'
op|','
name|'project_id'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'ips'
op|'='
name|'self'
op|'.'
name|'ipam'
op|'.'
name|'get_allocated_ips'
op|'('
name|'context'
op|','
name|'subnet_id'
op|','
name|'project_id'
op|')'
newline|'\n'
name|'hosts_text'
op|'='
string|'""'
newline|'\n'
name|'admin_context'
op|'='
name|'context'
op|'.'
name|'elevated'
op|'('
op|')'
newline|'\n'
name|'for'
name|'ip'
name|'in'
name|'ips'
op|':'
newline|'\n'
indent|'            '
name|'address'
op|','
name|'vif_id'
op|'='
name|'ip'
newline|'\n'
name|'vif'
op|'='
name|'db'
op|'.'
name|'virtual_interface_get_by_uuid'
op|'('
name|'admin_context'
op|','
name|'vif_id'
op|')'
newline|'\n'
name|'mac_address'
op|'='
name|'vif'
op|'['
string|"'address'"
op|']'
newline|'\n'
name|'text'
op|'='
string|'"%s,%s.%s,%s\\n"'
op|'%'
op|'('
name|'mac_address'
op|','
string|'"host-"'
op|'+'
name|'address'
op|','
nl|'\n'
name|'FLAGS'
op|'.'
name|'dhcp_domain'
op|','
name|'address'
op|')'
newline|'\n'
name|'hosts_text'
op|'+='
name|'text'
newline|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"DHCP hosts: %s"'
op|'%'
name|'hosts_text'
op|')'
newline|'\n'
name|'return'
name|'hosts_text'
newline|'\n'
nl|'\n'
DECL|member|get_dhcp_leases
dedent|''
name|'def'
name|'get_dhcp_leases'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'network_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a network\'s hosts config in dnsmasq leasefile format."""'
newline|'\n'
name|'subnet_id'
op|'='
name|'network_ref'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'project_id'
op|'='
name|'network_ref'
op|'['
string|"'project_id'"
op|']'
newline|'\n'
name|'ips'
op|'='
name|'self'
op|'.'
name|'ipam'
op|'.'
name|'get_allocated_ips'
op|'('
name|'context'
op|','
name|'subnet_id'
op|','
name|'project_id'
op|')'
newline|'\n'
name|'leases_text'
op|'='
string|'""'
newline|'\n'
name|'admin_context'
op|'='
name|'context'
op|'.'
name|'elevated'
op|'('
op|')'
newline|'\n'
name|'for'
name|'ip'
name|'in'
name|'ips'
op|':'
newline|'\n'
indent|'            '
name|'address'
op|','
name|'vif_id'
op|'='
name|'ip'
newline|'\n'
name|'vif'
op|'='
name|'db'
op|'.'
name|'virtual_interface_get_by_uuid'
op|'('
name|'admin_context'
op|','
name|'vif_id'
op|')'
newline|'\n'
name|'mac_address'
op|'='
name|'vif'
op|'['
string|"'address'"
op|']'
newline|'\n'
name|'text'
op|'='
string|'"%s %s %s %s *\\n"'
op|'%'
op|'('
name|'int'
op|'('
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|')'
op|'-'
name|'FLAGS'
op|'.'
name|'dhcp_lease_time'
op|','
nl|'\n'
name|'mac_address'
op|','
name|'address'
op|','
string|"'*'"
op|')'
newline|'\n'
name|'leases_text'
op|'+='
name|'text'
newline|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"DHCP leases: %s"'
op|'%'
name|'leases_text'
op|')'
newline|'\n'
name|'return'
name|'leases_text'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
