begin_unit
comment|'# Copyright 2010 United States Government as represented by the'
nl|'\n'
comment|'# Administrator of the National Aeronautics and Space Administration.'
nl|'\n'
comment|'# Copyright 2012 Hewlett-Packard Development Company, L.P.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'# not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'# a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#      http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'# License for the specific language governing permissions and limitations'
nl|'\n'
comment|'# under the License.'
nl|'\n'
nl|'\n'
string|'"""Matcher classes to be used inside of the testtools assertThat framework."""'
newline|'\n'
nl|'\n'
name|'import'
name|'pprint'
newline|'\n'
nl|'\n'
name|'from'
name|'lxml'
name|'import'
name|'etree'
newline|'\n'
name|'import'
name|'six'
newline|'\n'
name|'from'
name|'testtools'
name|'import'
name|'content'
newline|'\n'
name|'import'
name|'testtools'
op|'.'
name|'matchers'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DictKeysMismatch
name|'class'
name|'DictKeysMismatch'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'d1only'
op|','
name|'d2only'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'d1only'
op|'='
name|'d1only'
newline|'\n'
name|'self'
op|'.'
name|'d2only'
op|'='
name|'d2only'
newline|'\n'
nl|'\n'
DECL|member|describe
dedent|''
name|'def'
name|'describe'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
string|"'Keys in d1 and not d2: %(d1only)s.'"
nl|'\n'
string|"' Keys in d2 and not d1: %(d2only)s'"
op|'%'
nl|'\n'
op|'{'
string|"'d1only'"
op|':'
name|'self'
op|'.'
name|'d1only'
op|','
string|"'d2only'"
op|':'
name|'self'
op|'.'
name|'d2only'
op|'}'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_details
dedent|''
name|'def'
name|'get_details'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'{'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DictMismatch
dedent|''
dedent|''
name|'class'
name|'DictMismatch'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'key'
op|','
name|'d1_value'
op|','
name|'d2_value'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'key'
op|'='
name|'key'
newline|'\n'
name|'self'
op|'.'
name|'d1_value'
op|'='
name|'d1_value'
newline|'\n'
name|'self'
op|'.'
name|'d2_value'
op|'='
name|'d2_value'
newline|'\n'
nl|'\n'
DECL|member|describe
dedent|''
name|'def'
name|'describe'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
string|'"Dictionaries do not match at %(key)s."'
nl|'\n'
string|'" d1: %(d1_value)s d2: %(d2_value)s"'
op|'%'
nl|'\n'
op|'{'
string|"'key'"
op|':'
name|'self'
op|'.'
name|'key'
op|','
string|"'d1_value'"
op|':'
name|'self'
op|'.'
name|'d1_value'
op|','
nl|'\n'
string|"'d2_value'"
op|':'
name|'self'
op|'.'
name|'d2_value'
op|'}'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_details
dedent|''
name|'def'
name|'get_details'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'{'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DictMatches
dedent|''
dedent|''
name|'class'
name|'DictMatches'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'d1'
op|','
name|'approx_equal'
op|'='
name|'False'
op|','
name|'tolerance'
op|'='
number|'0.001'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'d1'
op|'='
name|'d1'
newline|'\n'
name|'self'
op|'.'
name|'approx_equal'
op|'='
name|'approx_equal'
newline|'\n'
name|'self'
op|'.'
name|'tolerance'
op|'='
name|'tolerance'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|"'DictMatches(%s)'"
op|'%'
op|'('
name|'pprint'
op|'.'
name|'pformat'
op|'('
name|'self'
op|'.'
name|'d1'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Useful assertions'
nl|'\n'
DECL|member|match
dedent|''
name|'def'
name|'match'
op|'('
name|'self'
op|','
name|'d2'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Assert two dicts are equivalent.\n\n        This is a \'deep\' match in the sense that it handles nested\n        dictionaries appropriately.\n\n        NOTE:\n\n            If you don\'t care (or don\'t know) a given value, you can specify\n            the string DONTCARE as the value. This will cause that dict-item\n            to be skipped.\n\n        """'
newline|'\n'
nl|'\n'
name|'d1keys'
op|'='
name|'set'
op|'('
name|'self'
op|'.'
name|'d1'
op|'.'
name|'keys'
op|'('
op|')'
op|')'
newline|'\n'
name|'d2keys'
op|'='
name|'set'
op|'('
name|'d2'
op|'.'
name|'keys'
op|'('
op|')'
op|')'
newline|'\n'
name|'if'
name|'d1keys'
op|'!='
name|'d2keys'
op|':'
newline|'\n'
indent|'            '
name|'d1only'
op|'='
name|'sorted'
op|'('
name|'d1keys'
op|'-'
name|'d2keys'
op|')'
newline|'\n'
name|'d2only'
op|'='
name|'sorted'
op|'('
name|'d2keys'
op|'-'
name|'d1keys'
op|')'
newline|'\n'
name|'return'
name|'DictKeysMismatch'
op|'('
name|'d1only'
op|','
name|'d2only'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'key'
name|'in'
name|'d1keys'
op|':'
newline|'\n'
indent|'            '
name|'d1value'
op|'='
name|'self'
op|'.'
name|'d1'
op|'['
name|'key'
op|']'
newline|'\n'
name|'d2value'
op|'='
name|'d2'
op|'['
name|'key'
op|']'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'error'
op|'='
name|'abs'
op|'('
name|'float'
op|'('
name|'d1value'
op|')'
op|'-'
name|'float'
op|'('
name|'d2value'
op|')'
op|')'
newline|'\n'
name|'within_tolerance'
op|'='
name|'error'
op|'<='
name|'self'
op|'.'
name|'tolerance'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'ValueError'
op|','
name|'TypeError'
op|')'
op|':'
newline|'\n'
comment|"# If both values aren't convertible to float, just ignore"
nl|'\n'
comment|"# ValueError if arg is a str, TypeError if it's something else"
nl|'\n'
comment|'# (like None)'
nl|'\n'
indent|'                '
name|'within_tolerance'
op|'='
name|'False'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'hasattr'
op|'('
name|'d1value'
op|','
string|"'keys'"
op|')'
name|'and'
name|'hasattr'
op|'('
name|'d2value'
op|','
string|"'keys'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'matcher'
op|'='
name|'DictMatches'
op|'('
name|'d1value'
op|')'
newline|'\n'
name|'did_match'
op|'='
name|'matcher'
op|'.'
name|'match'
op|'('
name|'d2value'
op|')'
newline|'\n'
name|'if'
name|'did_match'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'did_match'
newline|'\n'
dedent|''
dedent|''
name|'elif'
string|"'DONTCARE'"
name|'in'
op|'('
name|'d1value'
op|','
name|'d2value'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'approx_equal'
name|'and'
name|'within_tolerance'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'elif'
name|'d1value'
op|'!='
name|'d2value'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'DictMismatch'
op|'('
name|'key'
op|','
name|'d1value'
op|','
name|'d2value'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ListLengthMismatch
dedent|''
dedent|''
dedent|''
dedent|''
name|'class'
name|'ListLengthMismatch'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'len1'
op|','
name|'len2'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'len1'
op|'='
name|'len1'
newline|'\n'
name|'self'
op|'.'
name|'len2'
op|'='
name|'len2'
newline|'\n'
nl|'\n'
DECL|member|describe
dedent|''
name|'def'
name|'describe'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
string|"'Length mismatch: len(L1)=%(len1)d != '"
nl|'\n'
string|"'len(L2)=%(len2)d'"
op|'%'
op|'{'
string|"'len1'"
op|':'
name|'self'
op|'.'
name|'len1'
op|','
string|"'len2'"
op|':'
name|'self'
op|'.'
name|'len2'
op|'}'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_details
dedent|''
name|'def'
name|'get_details'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'{'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|DictListMatches
dedent|''
dedent|''
name|'class'
name|'DictListMatches'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'l1'
op|','
name|'approx_equal'
op|'='
name|'False'
op|','
name|'tolerance'
op|'='
number|'0.001'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'l1'
op|'='
name|'l1'
newline|'\n'
name|'self'
op|'.'
name|'approx_equal'
op|'='
name|'approx_equal'
newline|'\n'
name|'self'
op|'.'
name|'tolerance'
op|'='
name|'tolerance'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|"'DictListMatches(%s)'"
op|'%'
op|'('
name|'pprint'
op|'.'
name|'pformat'
op|'('
name|'self'
op|'.'
name|'l1'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Useful assertions'
nl|'\n'
DECL|member|match
dedent|''
name|'def'
name|'match'
op|'('
name|'self'
op|','
name|'l2'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Assert a list of dicts are equivalent."""'
newline|'\n'
nl|'\n'
name|'l1count'
op|'='
name|'len'
op|'('
name|'self'
op|'.'
name|'l1'
op|')'
newline|'\n'
name|'l2count'
op|'='
name|'len'
op|'('
name|'l2'
op|')'
newline|'\n'
name|'if'
name|'l1count'
op|'!='
name|'l2count'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'ListLengthMismatch'
op|'('
name|'l1count'
op|','
name|'l2count'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'d1'
op|','
name|'d2'
name|'in'
name|'zip'
op|'('
name|'self'
op|'.'
name|'l1'
op|','
name|'l2'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'matcher'
op|'='
name|'DictMatches'
op|'('
name|'d2'
op|','
nl|'\n'
name|'approx_equal'
op|'='
name|'self'
op|'.'
name|'approx_equal'
op|','
nl|'\n'
name|'tolerance'
op|'='
name|'self'
op|'.'
name|'tolerance'
op|')'
newline|'\n'
name|'did_match'
op|'='
name|'matcher'
op|'.'
name|'match'
op|'('
name|'d1'
op|')'
newline|'\n'
name|'if'
name|'did_match'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'did_match'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|SubDictMismatch
dedent|''
dedent|''
dedent|''
dedent|''
name|'class'
name|'SubDictMismatch'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
nl|'\n'
name|'key'
op|'='
name|'None'
op|','
nl|'\n'
name|'sub_value'
op|'='
name|'None'
op|','
nl|'\n'
name|'super_value'
op|'='
name|'None'
op|','
nl|'\n'
name|'keys'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'key'
op|'='
name|'key'
newline|'\n'
name|'self'
op|'.'
name|'sub_value'
op|'='
name|'sub_value'
newline|'\n'
name|'self'
op|'.'
name|'super_value'
op|'='
name|'super_value'
newline|'\n'
name|'self'
op|'.'
name|'keys'
op|'='
name|'keys'
newline|'\n'
nl|'\n'
DECL|member|describe
dedent|''
name|'def'
name|'describe'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'keys'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|'"Keys between dictionaries did not match"'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'('
string|'"Dictionaries do not match at %s. d1: %s d2: %s"'
nl|'\n'
op|'%'
op|'('
name|'self'
op|'.'
name|'key'
op|','
nl|'\n'
name|'self'
op|'.'
name|'super_value'
op|','
nl|'\n'
name|'self'
op|'.'
name|'sub_value'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_details
dedent|''
dedent|''
name|'def'
name|'get_details'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'{'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|IsSubDictOf
dedent|''
dedent|''
name|'class'
name|'IsSubDictOf'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'super_dict'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'super_dict'
op|'='
name|'super_dict'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|"'IsSubDictOf(%s)'"
op|'%'
op|'('
name|'self'
op|'.'
name|'super_dict'
op|')'
newline|'\n'
nl|'\n'
DECL|member|match
dedent|''
name|'def'
name|'match'
op|'('
name|'self'
op|','
name|'sub_dict'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Assert a sub_dict is subset of super_dict."""'
newline|'\n'
name|'if'
name|'not'
name|'set'
op|'('
name|'sub_dict'
op|'.'
name|'keys'
op|'('
op|')'
op|')'
op|'.'
name|'issubset'
op|'('
name|'set'
op|'('
name|'self'
op|'.'
name|'super_dict'
op|'.'
name|'keys'
op|'('
op|')'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'SubDictMismatch'
op|'('
name|'keys'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'k'
op|','
name|'sub_value'
name|'in'
name|'sub_dict'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'super_value'
op|'='
name|'self'
op|'.'
name|'super_dict'
op|'['
name|'k'
op|']'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'sub_value'
op|','
name|'dict'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'matcher'
op|'='
name|'IsSubDictOf'
op|'('
name|'super_value'
op|')'
newline|'\n'
name|'did_match'
op|'='
name|'matcher'
op|'.'
name|'match'
op|'('
name|'sub_value'
op|')'
newline|'\n'
name|'if'
name|'did_match'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'did_match'
newline|'\n'
dedent|''
dedent|''
name|'elif'
string|"'DONTCARE'"
name|'in'
op|'('
name|'sub_value'
op|','
name|'super_value'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'sub_value'
op|'!='
name|'super_value'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'SubDictMismatch'
op|'('
name|'k'
op|','
name|'sub_value'
op|','
name|'super_value'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|FunctionCallMatcher
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'class'
name|'FunctionCallMatcher'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'expected_func_calls'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'expected_func_calls'
op|'='
name|'expected_func_calls'
newline|'\n'
name|'self'
op|'.'
name|'actual_func_calls'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|call
dedent|''
name|'def'
name|'call'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'func_call'
op|'='
op|'{'
string|"'args'"
op|':'
name|'args'
op|','
string|"'kwargs'"
op|':'
name|'kwargs'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'actual_func_calls'
op|'.'
name|'append'
op|'('
name|'func_call'
op|')'
newline|'\n'
nl|'\n'
DECL|member|match
dedent|''
name|'def'
name|'match'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'dict_list_matcher'
op|'='
name|'DictListMatches'
op|'('
name|'self'
op|'.'
name|'expected_func_calls'
op|')'
newline|'\n'
name|'return'
name|'dict_list_matcher'
op|'.'
name|'match'
op|'('
name|'self'
op|'.'
name|'actual_func_calls'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|XMLMismatch
dedent|''
dedent|''
name|'class'
name|'XMLMismatch'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Superclass for XML mismatch."""'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'state'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'path'
op|'='
name|'str'
op|'('
name|'state'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'expected'
op|'='
name|'state'
op|'.'
name|'expected'
newline|'\n'
name|'self'
op|'.'
name|'actual'
op|'='
name|'state'
op|'.'
name|'actual'
newline|'\n'
nl|'\n'
DECL|member|describe
dedent|''
name|'def'
name|'describe'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|'"%(path)s: XML does not match"'
op|'%'
op|'{'
string|"'path'"
op|':'
name|'self'
op|'.'
name|'path'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|get_details
dedent|''
name|'def'
name|'get_details'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'{'
nl|'\n'
string|"'expected'"
op|':'
name|'content'
op|'.'
name|'text_content'
op|'('
name|'self'
op|'.'
name|'expected'
op|')'
op|','
nl|'\n'
string|"'actual'"
op|':'
name|'content'
op|'.'
name|'text_content'
op|'('
name|'self'
op|'.'
name|'actual'
op|')'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|XMLDocInfoMismatch
dedent|''
dedent|''
name|'class'
name|'XMLDocInfoMismatch'
op|'('
name|'XMLMismatch'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""XML version or encoding doesn\'t match."""'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'state'
op|','
name|'expected_doc_info'
op|','
name|'actual_doc_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'super'
op|'('
name|'XMLDocInfoMismatch'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'state'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'expected_doc_info'
op|'='
name|'expected_doc_info'
newline|'\n'
name|'self'
op|'.'
name|'actual_doc_info'
op|'='
name|'actual_doc_info'
newline|'\n'
nl|'\n'
DECL|member|describe
dedent|''
name|'def'
name|'describe'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
string|'"%(path)s: XML information mismatch(version, encoding) "'
nl|'\n'
string|'"expected version %(expected_version)s, "'
nl|'\n'
string|'"expected encoding %(expected_encoding)s; "'
nl|'\n'
string|'"actual version %(actual_version)s, "'
nl|'\n'
string|'"actual encoding %(actual_encoding)s"'
op|'%'
nl|'\n'
op|'{'
string|"'path'"
op|':'
name|'self'
op|'.'
name|'path'
op|','
nl|'\n'
string|"'expected_version'"
op|':'
name|'self'
op|'.'
name|'expected_doc_info'
op|'['
string|"'version'"
op|']'
op|','
nl|'\n'
string|"'expected_encoding'"
op|':'
name|'self'
op|'.'
name|'expected_doc_info'
op|'['
string|"'encoding'"
op|']'
op|','
nl|'\n'
string|"'actual_version'"
op|':'
name|'self'
op|'.'
name|'actual_doc_info'
op|'['
string|"'version'"
op|']'
op|','
nl|'\n'
string|"'actual_encoding'"
op|':'
name|'self'
op|'.'
name|'actual_doc_info'
op|'['
string|"'encoding'"
op|']'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|XMLTagMismatch
dedent|''
dedent|''
name|'class'
name|'XMLTagMismatch'
op|'('
name|'XMLMismatch'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""XML tags don\'t match."""'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'state'
op|','
name|'idx'
op|','
name|'expected_tag'
op|','
name|'actual_tag'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'super'
op|'('
name|'XMLTagMismatch'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'state'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'idx'
op|'='
name|'idx'
newline|'\n'
name|'self'
op|'.'
name|'expected_tag'
op|'='
name|'expected_tag'
newline|'\n'
name|'self'
op|'.'
name|'actual_tag'
op|'='
name|'actual_tag'
newline|'\n'
nl|'\n'
DECL|member|describe
dedent|''
name|'def'
name|'describe'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
string|'"%(path)s: XML tag mismatch at index %(idx)d: "'
nl|'\n'
string|'"expected tag <%(expected_tag)s>; "'
nl|'\n'
string|'"actual tag <%(actual_tag)s>"'
op|'%'
nl|'\n'
op|'{'
string|"'path'"
op|':'
name|'self'
op|'.'
name|'path'
op|','
string|"'idx'"
op|':'
name|'self'
op|'.'
name|'idx'
op|','
nl|'\n'
string|"'expected_tag'"
op|':'
name|'self'
op|'.'
name|'expected_tag'
op|','
nl|'\n'
string|"'actual_tag'"
op|':'
name|'self'
op|'.'
name|'actual_tag'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|XMLAttrKeysMismatch
dedent|''
dedent|''
name|'class'
name|'XMLAttrKeysMismatch'
op|'('
name|'XMLMismatch'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""XML attribute keys don\'t match."""'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'state'
op|','
name|'expected_only'
op|','
name|'actual_only'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'super'
op|'('
name|'XMLAttrKeysMismatch'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'state'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'expected_only'
op|'='
string|"', '"
op|'.'
name|'join'
op|'('
name|'sorted'
op|'('
name|'expected_only'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'actual_only'
op|'='
string|"', '"
op|'.'
name|'join'
op|'('
name|'sorted'
op|'('
name|'actual_only'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|describe
dedent|''
name|'def'
name|'describe'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
string|'"%(path)s: XML attributes mismatch: "'
nl|'\n'
string|'"keys only in expected: %(expected_only)s; "'
nl|'\n'
string|'"keys only in actual: %(actual_only)s"'
op|'%'
nl|'\n'
op|'{'
string|"'path'"
op|':'
name|'self'
op|'.'
name|'path'
op|','
string|"'expected_only'"
op|':'
name|'self'
op|'.'
name|'expected_only'
op|','
nl|'\n'
string|"'actual_only'"
op|':'
name|'self'
op|'.'
name|'actual_only'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|XMLAttrValueMismatch
dedent|''
dedent|''
name|'class'
name|'XMLAttrValueMismatch'
op|'('
name|'XMLMismatch'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""XML attribute values don\'t match."""'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'state'
op|','
name|'key'
op|','
name|'expected_value'
op|','
name|'actual_value'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'super'
op|'('
name|'XMLAttrValueMismatch'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'state'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'key'
op|'='
name|'key'
newline|'\n'
name|'self'
op|'.'
name|'expected_value'
op|'='
name|'expected_value'
newline|'\n'
name|'self'
op|'.'
name|'actual_value'
op|'='
name|'actual_value'
newline|'\n'
nl|'\n'
DECL|member|describe
dedent|''
name|'def'
name|'describe'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
string|'"%(path)s: XML attribute value mismatch: "'
nl|'\n'
string|'"expected value of attribute %(key)s: %(expected_value)r; "'
nl|'\n'
string|'"actual value: %(actual_value)r"'
op|'%'
nl|'\n'
op|'{'
string|"'path'"
op|':'
name|'self'
op|'.'
name|'path'
op|','
string|"'key'"
op|':'
name|'self'
op|'.'
name|'key'
op|','
nl|'\n'
string|"'expected_value'"
op|':'
name|'self'
op|'.'
name|'expected_value'
op|','
nl|'\n'
string|"'actual_value'"
op|':'
name|'self'
op|'.'
name|'actual_value'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|XMLTextValueMismatch
dedent|''
dedent|''
name|'class'
name|'XMLTextValueMismatch'
op|'('
name|'XMLMismatch'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""XML text values don\'t match."""'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'state'
op|','
name|'expected_text'
op|','
name|'actual_text'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'super'
op|'('
name|'XMLTextValueMismatch'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'state'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'expected_text'
op|'='
name|'expected_text'
newline|'\n'
name|'self'
op|'.'
name|'actual_text'
op|'='
name|'actual_text'
newline|'\n'
nl|'\n'
DECL|member|describe
dedent|''
name|'def'
name|'describe'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
string|'"%(path)s: XML text value mismatch: "'
nl|'\n'
string|'"expected text value: %(expected_text)r; "'
nl|'\n'
string|'"actual value: %(actual_text)r"'
op|'%'
nl|'\n'
op|'{'
string|"'path'"
op|':'
name|'self'
op|'.'
name|'path'
op|','
string|"'expected_text'"
op|':'
name|'self'
op|'.'
name|'expected_text'
op|','
nl|'\n'
string|"'actual_text'"
op|':'
name|'self'
op|'.'
name|'actual_text'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|XMLUnexpectedChild
dedent|''
dedent|''
name|'class'
name|'XMLUnexpectedChild'
op|'('
name|'XMLMismatch'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Unexpected child present in XML."""'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'state'
op|','
name|'tag'
op|','
name|'idx'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'super'
op|'('
name|'XMLUnexpectedChild'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'state'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'tag'
op|'='
name|'tag'
newline|'\n'
name|'self'
op|'.'
name|'idx'
op|'='
name|'idx'
newline|'\n'
nl|'\n'
DECL|member|describe
dedent|''
name|'def'
name|'describe'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
string|'"%(path)s: XML unexpected child element <%(tag)s> "'
nl|'\n'
string|'"present at index %(idx)d"'
op|'%'
nl|'\n'
op|'{'
string|"'path'"
op|':'
name|'self'
op|'.'
name|'path'
op|','
string|"'tag'"
op|':'
name|'self'
op|'.'
name|'tag'
op|','
string|"'idx'"
op|':'
name|'self'
op|'.'
name|'idx'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|XMLExpectedChild
dedent|''
dedent|''
name|'class'
name|'XMLExpectedChild'
op|'('
name|'XMLMismatch'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Expected child not present in XML."""'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'state'
op|','
name|'tag'
op|','
name|'idx'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'super'
op|'('
name|'XMLExpectedChild'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'state'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'tag'
op|'='
name|'tag'
newline|'\n'
name|'self'
op|'.'
name|'idx'
op|'='
name|'idx'
newline|'\n'
nl|'\n'
DECL|member|describe
dedent|''
name|'def'
name|'describe'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
string|'"%(path)s: XML expected child element <%(tag)s> "'
nl|'\n'
string|'"not present at index %(idx)d"'
op|'%'
nl|'\n'
op|'{'
string|"'path'"
op|':'
name|'self'
op|'.'
name|'path'
op|','
string|"'tag'"
op|':'
name|'self'
op|'.'
name|'tag'
op|','
string|"'idx'"
op|':'
name|'self'
op|'.'
name|'idx'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|XMLMatchState
dedent|''
dedent|''
name|'class'
name|'XMLMatchState'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Maintain some state for matching.\n\n    Tracks the XML node path and saves the expected and actual full\n    XML text, for use by the XMLMismatch subclasses.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'expected'
op|','
name|'actual'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'path'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'expected'
op|'='
name|'expected'
newline|'\n'
name|'self'
op|'.'
name|'actual'
op|'='
name|'actual'
newline|'\n'
nl|'\n'
DECL|member|__enter__
dedent|''
name|'def'
name|'__enter__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|__exit__
dedent|''
name|'def'
name|'__exit__'
op|'('
name|'self'
op|','
name|'exc_type'
op|','
name|'exc_value'
op|','
name|'exc_tb'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'path'
op|'.'
name|'pop'
op|'('
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|"'/'"
op|'+'
string|"'/'"
op|'.'
name|'join'
op|'('
name|'self'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|node
dedent|''
name|'def'
name|'node'
op|'('
name|'self'
op|','
name|'tag'
op|','
name|'idx'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Adds tag and index to the path; they will be popped off when\n        the corresponding \'with\' statement exits.\n\n        :param tag: The element tag\n        :param idx: If not None, the integer index of the element\n                    within its parent.  Not included in the path\n                    element if None.\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'idx'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'path'
op|'.'
name|'append'
op|'('
string|'"%s[%d]"'
op|'%'
op|'('
name|'tag'
op|','
name|'idx'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'path'
op|'.'
name|'append'
op|'('
name|'tag'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|XMLMatches
dedent|''
dedent|''
name|'class'
name|'XMLMatches'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Compare XML strings.  More complete than string comparison."""'
newline|'\n'
nl|'\n'
DECL|variable|SKIP_TAGS
name|'SKIP_TAGS'
op|'='
op|'('
name|'etree'
op|'.'
name|'Comment'
op|','
name|'etree'
op|'.'
name|'ProcessingInstruction'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'expected'
op|','
name|'allow_mixed_nodes'
op|'='
name|'False'
op|','
nl|'\n'
name|'skip_empty_text_nodes'
op|'='
name|'True'
op|','
name|'skip_values'
op|'='
op|'('
string|"'DONTCARE'"
op|','
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'expected_xml'
op|'='
name|'expected'
newline|'\n'
name|'self'
op|'.'
name|'expected'
op|'='
name|'etree'
op|'.'
name|'parse'
op|'('
name|'six'
op|'.'
name|'StringIO'
op|'('
name|'expected'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'allow_mixed_nodes'
op|'='
name|'allow_mixed_nodes'
newline|'\n'
name|'self'
op|'.'
name|'skip_empty_text_nodes'
op|'='
name|'skip_empty_text_nodes'
newline|'\n'
name|'self'
op|'.'
name|'skip_values'
op|'='
name|'set'
op|'('
name|'skip_values'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|"'XMLMatches(%r)'"
op|'%'
name|'self'
op|'.'
name|'expected_xml'
newline|'\n'
nl|'\n'
DECL|member|match
dedent|''
name|'def'
name|'match'
op|'('
name|'self'
op|','
name|'actual_xml'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'actual'
op|'='
name|'etree'
op|'.'
name|'parse'
op|'('
name|'six'
op|'.'
name|'StringIO'
op|'('
name|'actual_xml'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'state'
op|'='
name|'XMLMatchState'
op|'('
name|'self'
op|'.'
name|'expected_xml'
op|','
name|'actual_xml'
op|')'
newline|'\n'
name|'expected_doc_info'
op|'='
name|'self'
op|'.'
name|'_get_xml_docinfo'
op|'('
name|'self'
op|'.'
name|'expected'
op|')'
newline|'\n'
name|'actual_doc_info'
op|'='
name|'self'
op|'.'
name|'_get_xml_docinfo'
op|'('
name|'actual'
op|')'
newline|'\n'
name|'if'
name|'expected_doc_info'
op|'!='
name|'actual_doc_info'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'XMLDocInfoMismatch'
op|'('
name|'state'
op|','
name|'expected_doc_info'
op|','
nl|'\n'
name|'actual_doc_info'
op|')'
newline|'\n'
dedent|''
name|'result'
op|'='
name|'self'
op|'.'
name|'_compare_node'
op|'('
name|'self'
op|'.'
name|'expected'
op|'.'
name|'getroot'
op|'('
op|')'
op|','
nl|'\n'
name|'actual'
op|'.'
name|'getroot'
op|'('
op|')'
op|','
name|'state'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'result'
name|'is'
name|'False'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'XMLMismatch'
op|'('
name|'state'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'result'
name|'is'
name|'not'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'result'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_get_xml_docinfo
name|'def'
name|'_get_xml_docinfo'
op|'('
name|'xml_document'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'{'
string|"'version'"
op|':'
name|'xml_document'
op|'.'
name|'docinfo'
op|'.'
name|'xml_version'
op|','
nl|'\n'
string|"'encoding'"
op|':'
name|'xml_document'
op|'.'
name|'docinfo'
op|'.'
name|'encoding'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|_compare_text_nodes
dedent|''
name|'def'
name|'_compare_text_nodes'
op|'('
name|'self'
op|','
name|'expected'
op|','
name|'actual'
op|','
name|'state'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'expected_text'
op|'='
op|'['
name|'expected'
op|'.'
name|'text'
op|']'
newline|'\n'
name|'expected_text'
op|'.'
name|'extend'
op|'('
name|'child'
op|'.'
name|'tail'
name|'for'
name|'child'
name|'in'
name|'expected'
op|')'
newline|'\n'
name|'actual_text'
op|'='
op|'['
name|'actual'
op|'.'
name|'text'
op|']'
newline|'\n'
name|'actual_text'
op|'.'
name|'extend'
op|'('
name|'child'
op|'.'
name|'tail'
name|'for'
name|'child'
name|'in'
name|'actual'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'skip_empty_text_nodes'
op|':'
newline|'\n'
indent|'            '
name|'expected_text'
op|'='
op|'['
name|'text'
name|'for'
name|'text'
name|'in'
name|'expected_text'
nl|'\n'
name|'if'
name|'text'
name|'and'
name|'not'
name|'text'
op|'.'
name|'isspace'
op|'('
op|')'
op|']'
newline|'\n'
name|'actual_text'
op|'='
op|'['
name|'text'
name|'for'
name|'text'
name|'in'
name|'actual_text'
nl|'\n'
name|'if'
name|'text'
name|'and'
name|'not'
name|'text'
op|'.'
name|'isspace'
op|'('
op|')'
op|']'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'skip_values'
op|'.'
name|'intersection'
op|'('
nl|'\n'
name|'expected_text'
op|'+'
name|'actual_text'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'allow_mixed_nodes'
op|':'
newline|'\n'
comment|'# lets sort text nodes because they can be mixed'
nl|'\n'
indent|'            '
name|'expected_text'
op|'='
name|'sorted'
op|'('
name|'expected_text'
op|')'
newline|'\n'
name|'actual_text'
op|'='
name|'sorted'
op|'('
name|'actual_text'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'expected_text'
op|'!='
name|'actual_text'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'XMLTextValueMismatch'
op|'('
name|'state'
op|','
name|'expected_text'
op|','
name|'actual_text'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_compare_node
dedent|''
dedent|''
name|'def'
name|'_compare_node'
op|'('
name|'self'
op|','
name|'expected'
op|','
name|'actual'
op|','
name|'state'
op|','
name|'idx'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Recursively compares nodes within the XML tree."""'
newline|'\n'
nl|'\n'
comment|'# Start by comparing the tags'
nl|'\n'
name|'if'
name|'expected'
op|'.'
name|'tag'
op|'!='
name|'actual'
op|'.'
name|'tag'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'XMLTagMismatch'
op|'('
name|'state'
op|','
name|'idx'
op|','
name|'expected'
op|'.'
name|'tag'
op|','
name|'actual'
op|'.'
name|'tag'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'with'
name|'state'
op|'.'
name|'node'
op|'('
name|'expected'
op|'.'
name|'tag'
op|','
name|'idx'
op|')'
op|':'
newline|'\n'
comment|'# Compare the attribute keys'
nl|'\n'
indent|'            '
name|'expected_attrs'
op|'='
name|'set'
op|'('
name|'expected'
op|'.'
name|'attrib'
op|'.'
name|'keys'
op|'('
op|')'
op|')'
newline|'\n'
name|'actual_attrs'
op|'='
name|'set'
op|'('
name|'actual'
op|'.'
name|'attrib'
op|'.'
name|'keys'
op|'('
op|')'
op|')'
newline|'\n'
name|'if'
name|'expected_attrs'
op|'!='
name|'actual_attrs'
op|':'
newline|'\n'
indent|'                '
name|'expected_only'
op|'='
name|'expected_attrs'
op|'-'
name|'actual_attrs'
newline|'\n'
name|'actual_only'
op|'='
name|'actual_attrs'
op|'-'
name|'expected_attrs'
newline|'\n'
name|'return'
name|'XMLAttrKeysMismatch'
op|'('
name|'state'
op|','
name|'expected_only'
op|','
name|'actual_only'
op|')'
newline|'\n'
nl|'\n'
comment|'# Compare the attribute values'
nl|'\n'
dedent|''
name|'for'
name|'key'
name|'in'
name|'expected_attrs'
op|':'
newline|'\n'
indent|'                '
name|'expected_value'
op|'='
name|'expected'
op|'.'
name|'attrib'
op|'['
name|'key'
op|']'
newline|'\n'
name|'actual_value'
op|'='
name|'actual'
op|'.'
name|'attrib'
op|'['
name|'key'
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'skip_values'
op|'.'
name|'intersection'
op|'('
nl|'\n'
op|'['
name|'expected_value'
op|','
name|'actual_value'
op|']'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'elif'
name|'expected_value'
op|'!='
name|'actual_value'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'XMLAttrValueMismatch'
op|'('
name|'state'
op|','
name|'key'
op|','
name|'expected_value'
op|','
nl|'\n'
name|'actual_value'
op|')'
newline|'\n'
nl|'\n'
comment|'# Compare text nodes'
nl|'\n'
dedent|''
dedent|''
name|'text_nodes_mismatch'
op|'='
name|'self'
op|'.'
name|'_compare_text_nodes'
op|'('
nl|'\n'
name|'expected'
op|','
name|'actual'
op|','
name|'state'
op|')'
newline|'\n'
name|'if'
name|'text_nodes_mismatch'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'text_nodes_mismatch'
newline|'\n'
nl|'\n'
comment|'# Compare the contents of the node'
nl|'\n'
dedent|''
name|'matched_actual_child_idxs'
op|'='
name|'set'
op|'('
op|')'
newline|'\n'
comment|'# first_actual_child_idx - pointer to next actual child'
nl|'\n'
comment|'# used with allow_mixed_nodes=False ONLY'
nl|'\n'
comment|'# prevent to visit actual child nodes twice'
nl|'\n'
name|'first_actual_child_idx'
op|'='
number|'0'
newline|'\n'
name|'for'
name|'expected_child'
name|'in'
name|'expected'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'expected_child'
op|'.'
name|'tag'
name|'in'
name|'self'
op|'.'
name|'SKIP_TAGS'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'related_actual_child_idx'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'allow_mixed_nodes'
op|':'
newline|'\n'
indent|'                    '
name|'first_actual_child_idx'
op|'='
number|'0'
newline|'\n'
dedent|''
name|'for'
name|'actual_child_idx'
name|'in'
name|'range'
op|'('
nl|'\n'
name|'first_actual_child_idx'
op|','
name|'len'
op|'('
name|'actual'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'actual'
op|'['
name|'actual_child_idx'
op|']'
op|'.'
name|'tag'
name|'in'
name|'self'
op|'.'
name|'SKIP_TAGS'
op|':'
newline|'\n'
indent|'                        '
name|'first_actual_child_idx'
op|'+='
number|'1'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'if'
name|'actual_child_idx'
name|'in'
name|'matched_actual_child_idxs'
op|':'
newline|'\n'
indent|'                        '
name|'continue'
newline|'\n'
comment|'# Compare the nodes'
nl|'\n'
dedent|''
name|'result'
op|'='
name|'self'
op|'.'
name|'_compare_node'
op|'('
name|'expected_child'
op|','
nl|'\n'
name|'actual'
op|'['
name|'actual_child_idx'
op|']'
op|','
nl|'\n'
name|'state'
op|','
name|'actual_child_idx'
op|')'
newline|'\n'
name|'first_actual_child_idx'
op|'+='
number|'1'
newline|'\n'
name|'if'
name|'result'
name|'is'
name|'not'
name|'True'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'self'
op|'.'
name|'allow_mixed_nodes'
op|':'
newline|'\n'
indent|'                            '
name|'continue'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                            '
name|'return'
name|'result'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
comment|'# nodes match'
newline|'\n'
indent|'                        '
name|'related_actual_child_idx'
op|'='
name|'actual_child_idx'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'related_actual_child_idx'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'matched_actual_child_idxs'
op|'.'
name|'add'
op|'('
name|'actual_child_idx'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'XMLExpectedChild'
op|'('
name|'state'
op|','
name|'expected_child'
op|'.'
name|'tag'
op|','
nl|'\n'
name|'actual_child_idx'
op|'+'
number|'1'
op|')'
newline|'\n'
comment|'# Make sure we consumed all nodes in actual'
nl|'\n'
dedent|''
dedent|''
name|'for'
name|'actual_child_idx'
op|','
name|'actual_child'
name|'in'
name|'enumerate'
op|'('
name|'actual'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
op|'('
name|'actual_child'
op|'.'
name|'tag'
name|'not'
name|'in'
name|'self'
op|'.'
name|'SKIP_TAGS'
name|'and'
nl|'\n'
name|'actual_child_idx'
name|'not'
name|'in'
name|'matched_actual_child_idxs'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'XMLUnexpectedChild'
op|'('
name|'state'
op|','
name|'actual_child'
op|'.'
name|'tag'
op|','
nl|'\n'
name|'actual_child_idx'
op|')'
newline|'\n'
comment|'# The nodes match'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|EncodedByUTF8
dedent|''
dedent|''
name|'class'
name|'EncodedByUTF8'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
DECL|member|match
indent|'    '
name|'def'
name|'match'
op|'('
name|'self'
op|','
name|'obj'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'isinstance'
op|'('
name|'obj'
op|','
name|'six'
op|'.'
name|'binary_type'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'hasattr'
op|'('
name|'obj'
op|','
string|'"decode"'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'obj'
op|'.'
name|'decode'
op|'('
string|'"utf-8"'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'UnicodeDecodeError'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'testtools'
op|'.'
name|'matchers'
op|'.'
name|'Mismatch'
op|'('
nl|'\n'
string|'"%s is not encoded in UTF-8."'
op|'%'
name|'obj'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
op|'('
string|'"Type of \'%(obj)s\' is \'%(obj_type)s\', "'
nl|'\n'
string|'"should be \'%(correct_type)s\'."'
nl|'\n'
op|'%'
op|'{'
nl|'\n'
string|'"obj"'
op|':'
name|'obj'
op|','
nl|'\n'
string|'"obj_type"'
op|':'
name|'type'
op|'('
name|'obj'
op|')'
op|'.'
name|'__name__'
op|','
nl|'\n'
string|'"correct_type"'
op|':'
name|'six'
op|'.'
name|'binary_type'
op|'.'
name|'__name__'
nl|'\n'
op|'}'
op|')'
newline|'\n'
name|'return'
name|'testtools'
op|'.'
name|'matchers'
op|'.'
name|'Mismatch'
op|'('
name|'reason'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
