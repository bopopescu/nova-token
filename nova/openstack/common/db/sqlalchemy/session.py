begin_unit
comment|'# Copyright 2010 United States Government as represented by the'
nl|'\n'
comment|'# Administrator of the National Aeronautics and Space Administration.'
nl|'\n'
comment|'# All Rights Reserved.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
nl|'\n'
string|'"""Session Handling for SQLAlchemy backend.\n\nRecommended ways to use sessions within this framework:\n\n* Don\'t use them explicitly; this is like running with ``AUTOCOMMIT=1``.\n  `model_query()` will implicitly use a session when called without one\n  supplied. This is the ideal situation because it will allow queries\n  to be automatically retried if the database connection is interrupted.\n\n  .. note:: Automatic retry will be enabled in a future patch.\n\n  It is generally fine to issue several queries in a row like this. Even though\n  they may be run in separate transactions and/or separate sessions, each one\n  will see the data from the prior calls. If needed, undo- or rollback-like\n  functionality should be handled at a logical level. For an example, look at\n  the code around quotas and `reservation_rollback()`.\n\n  Examples:\n\n  .. code:: python\n\n    def get_foo(context, foo):\n        return (model_query(context, models.Foo).\n                filter_by(foo=foo).\n                first())\n\n    def update_foo(context, id, newfoo):\n        (model_query(context, models.Foo).\n                filter_by(id=id).\n                update({\'foo\': newfoo}))\n\n    def create_foo(context, values):\n        foo_ref = models.Foo()\n        foo_ref.update(values)\n        foo_ref.save()\n        return foo_ref\n\n\n* Within the scope of a single method, keep all the reads and writes within\n  the context managed by a single session. In this way, the session\'s\n  `__exit__` handler will take care of calling `flush()` and `commit()` for\n  you. If using this approach, you should not explicitly call `flush()` or\n  `commit()`. Any error within the context of the session will cause the\n  session to emit a `ROLLBACK`. Database errors like `IntegrityError` will be\n  raised in `session`\'s `__exit__` handler, and any try/except within the\n  context managed by `session` will not be triggered. And catching other\n  non-database errors in the session will not trigger the ROLLBACK, so\n  exception handlers should  always be outside the session, unless the\n  developer wants to do a partial commit on purpose. If the connection is\n  dropped before this is possible, the database will implicitly roll back the\n  transaction.\n\n  .. note:: Statements in the session scope will not be automatically retried.\n\n  If you create models within the session, they need to be added, but you\n  do not need to call `model.save()`:\n\n  .. code:: python\n\n    def create_many_foo(context, foos):\n        session = sessionmaker()\n        with session.begin():\n            for foo in foos:\n                foo_ref = models.Foo()\n                foo_ref.update(foo)\n                session.add(foo_ref)\n\n    def update_bar(context, foo_id, newbar):\n        session = sessionmaker()\n        with session.begin():\n            foo_ref = (model_query(context, models.Foo, session).\n                        filter_by(id=foo_id).\n                        first())\n            (model_query(context, models.Bar, session).\n                        filter_by(id=foo_ref[\'bar_id\']).\n                        update({\'bar\': newbar}))\n\n  .. note:: `update_bar` is a trivially simple example of using\n     ``with session.begin``. Whereas `create_many_foo` is a good example of\n     when a transaction is needed, it is always best to use as few queries as\n     possible.\n\n  The two queries in `update_bar` can be better expressed using a single query\n  which avoids the need for an explicit transaction. It can be expressed like\n  so:\n\n  .. code:: python\n\n    def update_bar(context, foo_id, newbar):\n        subq = (model_query(context, models.Foo.id).\n                filter_by(id=foo_id).\n                limit(1).\n                subquery())\n        (model_query(context, models.Bar).\n                filter_by(id=subq.as_scalar()).\n                update({\'bar\': newbar}))\n\n  For reference, this emits approximately the following SQL statement:\n\n  .. code:: sql\n\n    UPDATE bar SET bar = ${newbar}\n        WHERE id=(SELECT bar_id FROM foo WHERE id = ${foo_id} LIMIT 1);\n\n  .. note:: `create_duplicate_foo` is a trivially simple example of catching an\n     exception while using ``with session.begin``. Here create two duplicate\n     instances with same primary key, must catch the exception out of context\n     managed by a single session:\n\n  .. code:: python\n\n    def create_duplicate_foo(context):\n        foo1 = models.Foo()\n        foo2 = models.Foo()\n        foo1.id = foo2.id = 1\n        session = sessionmaker()\n        try:\n            with session.begin():\n                session.add(foo1)\n                session.add(foo2)\n        except exception.DBDuplicateEntry as e:\n            handle_error(e)\n\n* Passing an active session between methods. Sessions should only be passed\n  to private methods. The private method must use a subtransaction; otherwise\n  SQLAlchemy will throw an error when you call `session.begin()` on an existing\n  transaction. Public methods should not accept a session parameter and should\n  not be involved in sessions within the caller\'s scope.\n\n  Note that this incurs more overhead in SQLAlchemy than the above means\n  due to nesting transactions, and it is not possible to implicitly retry\n  failed database operations when using this approach.\n\n  This also makes code somewhat more difficult to read and debug, because a\n  single database transaction spans more than one method. Error handling\n  becomes less clear in this situation. When this is needed for code clarity,\n  it should be clearly documented.\n\n  .. code:: python\n\n    def myfunc(foo):\n        session = sessionmaker()\n        with session.begin():\n            # do some database things\n            bar = _private_func(foo, session)\n        return bar\n\n    def _private_func(foo, session=None):\n        if not session:\n            session = sessionmaker()\n        with session.begin(subtransaction=True):\n            # do some other database things\n        return bar\n\n\nThere are some things which it is best to avoid:\n\n* Don\'t keep a transaction open any longer than necessary.\n\n  This means that your ``with session.begin()`` block should be as short\n  as possible, while still containing all the related calls for that\n  transaction.\n\n* Avoid ``with_lockmode(\'UPDATE\')`` when possible.\n\n  In MySQL/InnoDB, when a ``SELECT ... FOR UPDATE`` query does not match\n  any rows, it will take a gap-lock. This is a form of write-lock on the\n  "gap" where no rows exist, and prevents any other writes to that space.\n  This can effectively prevent any INSERT into a table by locking the gap\n  at the end of the index. Similar problems will occur if the SELECT FOR UPDATE\n  has an overly broad WHERE clause, or doesn\'t properly use an index.\n\n  One idea proposed at ODS Fall \'12 was to use a normal SELECT to test the\n  number of rows matching a query, and if only one row is returned,\n  then issue the SELECT FOR UPDATE.\n\n  The better long-term solution is to use\n  ``INSERT .. ON DUPLICATE KEY UPDATE``.\n  However, this can not be done until the "deleted" columns are removed and\n  proper UNIQUE constraints are added to the tables.\n\n\nEnabling soft deletes:\n\n* To use/enable soft-deletes, the `SoftDeleteMixin` must be added\n  to your model class. For example:\n\n  .. code:: python\n\n      class NovaBase(models.SoftDeleteMixin, models.ModelBase):\n          pass\n\n\nEfficient use of soft deletes:\n\n* There are two possible ways to mark a record as deleted:\n  `model.soft_delete()` and `query.soft_delete()`.\n\n  The `model.soft_delete()` method works with a single already-fetched entry.\n  `query.soft_delete()` makes only one db request for all entries that\n  correspond to the query.\n\n* In almost all cases you should use `query.soft_delete()`. Some examples:\n\n  .. code:: python\n\n        def soft_delete_bar():\n            count = model_query(BarModel).find(some_condition).soft_delete()\n            if count == 0:\n                raise Exception("0 entries were soft deleted")\n\n        def complex_soft_delete_with_synchronization_bar(session=None):\n            if session is None:\n                session = sessionmaker()\n            with session.begin(subtransactions=True):\n                count = (model_query(BarModel).\n                            find(some_condition).\n                            soft_delete(synchronize_session=True))\n                            # Here synchronize_session is required, because we\n                            # don\'t know what is going on in outer session.\n                if count == 0:\n                    raise Exception("0 entries were soft deleted")\n\n* There is only one situation where `model.soft_delete()` is appropriate: when\n  you fetch a single record, work with it, and mark it as deleted in the same\n  transaction.\n\n  .. code:: python\n\n        def soft_delete_bar_model():\n            session = sessionmaker()\n            with session.begin():\n                bar_ref = model_query(BarModel).find(some_condition).first()\n                # Work with bar_ref\n                bar_ref.soft_delete(session=session)\n\n  However, if you need to work with all entries that correspond to query and\n  then soft delete them you should use the `query.soft_delete()` method:\n\n  .. code:: python\n\n        def soft_delete_multi_models():\n            session = sessionmaker()\n            with session.begin():\n                query = (model_query(BarModel, session=session).\n                            find(some_condition))\n                model_refs = query.all()\n                # Work with model_refs\n                query.soft_delete(synchronize_session=False)\n                # synchronize_session=False should be set if there is no outer\n                # session and these entries are not used after this.\n\n  When working with many rows, it is very important to use query.soft_delete,\n  which issues a single query. Using `model.soft_delete()`, as in the following\n  example, is very inefficient.\n\n  .. code:: python\n\n        for bar_ref in bar_refs:\n            bar_ref.soft_delete(session=session)\n        # This will produce count(bar_refs) db requests.\n\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'functools'
newline|'\n'
name|'import'
name|'logging'
newline|'\n'
name|'import'
name|'re'
newline|'\n'
name|'import'
name|'time'
newline|'\n'
nl|'\n'
name|'import'
name|'six'
newline|'\n'
name|'from'
name|'sqlalchemy'
name|'import'
name|'exc'
name|'as'
name|'sqla_exc'
newline|'\n'
name|'from'
name|'sqlalchemy'
op|'.'
name|'interfaces'
name|'import'
name|'PoolListener'
newline|'\n'
name|'import'
name|'sqlalchemy'
op|'.'
name|'orm'
newline|'\n'
name|'from'
name|'sqlalchemy'
op|'.'
name|'pool'
name|'import'
name|'NullPool'
op|','
name|'StaticPool'
newline|'\n'
name|'from'
name|'sqlalchemy'
op|'.'
name|'sql'
op|'.'
name|'expression'
name|'import'
name|'literal_column'
newline|'\n'
nl|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
op|'.'
name|'db'
name|'import'
name|'exception'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
op|'.'
name|'gettextutils'
name|'import'
name|'_LE'
op|','
name|'_LW'
op|','
name|'_LI'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'timeutils'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|LOG
name|'LOG'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|SqliteForeignKeysListener
name|'class'
name|'SqliteForeignKeysListener'
op|'('
name|'PoolListener'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Ensures that the foreign key constraints are enforced in SQLite.\n\n    The foreign key constraints are disabled by default in SQLite,\n    so the foreign key constraints will be enabled here for every\n    database connection\n    """'
newline|'\n'
DECL|member|connect
name|'def'
name|'connect'
op|'('
name|'self'
op|','
name|'dbapi_con'
op|','
name|'con_record'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'dbapi_con'
op|'.'
name|'execute'
op|'('
string|"'pragma foreign_keys=ON'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# note(boris-42): In current versions of DB backends unique constraint'
nl|'\n'
comment|'# violation messages follow the structure:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# sqlite:'
nl|'\n'
comment|'# 1 column - (IntegrityError) column c1 is not unique'
nl|'\n'
comment|'# N columns - (IntegrityError) column c1, c2, ..., N are not unique'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# sqlite since 3.7.16:'
nl|'\n'
comment|'# 1 column - (IntegrityError) UNIQUE constraint failed: tbl.k1'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# N columns - (IntegrityError) UNIQUE constraint failed: tbl.k1, tbl.k2'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# postgres:'
nl|'\n'
comment|'# 1 column - (IntegrityError) duplicate key value violates unique'
nl|'\n'
comment|'#               constraint "users_c1_key"'
nl|'\n'
comment|'# N columns - (IntegrityError) duplicate key value violates unique'
nl|'\n'
comment|'#               constraint "name_of_our_constraint"'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# mysql:'
nl|'\n'
comment|'# 1 column - (IntegrityError) (1062, "Duplicate entry \'value_of_c1\' for key'
nl|'\n'
comment|'#               \'c1\'")'
nl|'\n'
comment|'# N columns - (IntegrityError) (1062, "Duplicate entry \'values joined'
nl|'\n'
comment|'#               with -\' for key \'name_of_our_constraint\'")'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# ibm_db_sa:'
nl|'\n'
comment|'# N columns - (IntegrityError) SQL0803N  One or more values in the INSERT'
nl|'\n'
comment|'#                statement, UPDATE statement, or foreign key update caused by a'
nl|'\n'
comment|'#                DELETE statement are not valid because the primary key, unique'
nl|'\n'
comment|'#                constraint or unique index identified by "2" constrains table'
nl|'\n'
comment|'#                "NOVA.KEY_PAIRS" from having duplicate values for the index'
nl|'\n'
comment|'#                key.'
nl|'\n'
DECL|variable|_DUP_KEY_RE_DB
dedent|''
dedent|''
name|'_DUP_KEY_RE_DB'
op|'='
op|'{'
nl|'\n'
string|'"sqlite"'
op|':'
op|'('
name|'re'
op|'.'
name|'compile'
op|'('
string|'r"^.*columns?([^)]+)(is|are)\\s+not\\s+unique$"'
op|')'
op|','
nl|'\n'
name|'re'
op|'.'
name|'compile'
op|'('
string|'r"^.*UNIQUE\\s+constraint\\s+failed:\\s+(.+)$"'
op|')'
op|')'
op|','
nl|'\n'
string|'"postgresql"'
op|':'
op|'('
name|'re'
op|'.'
name|'compile'
op|'('
string|'r"^.*duplicate\\s+key.*\\"([^\\"]+)\\"\\s*\\n.*$"'
op|')'
op|','
op|')'
op|','
nl|'\n'
string|'"mysql"'
op|':'
op|'('
name|'re'
op|'.'
name|'compile'
op|'('
string|'r"^.*\\(1062,.*\'([^\\\']+)\'\\"\\)$"'
op|')'
op|','
op|')'
op|','
nl|'\n'
string|'"ibm_db_sa"'
op|':'
op|'('
name|'re'
op|'.'
name|'compile'
op|'('
string|'r"^.*SQL0803N.*$"'
op|')'
op|','
op|')'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_raise_if_duplicate_entry_error
name|'def'
name|'_raise_if_duplicate_entry_error'
op|'('
name|'integrity_error'
op|','
name|'engine_name'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Raise exception if two entries are duplicated.\n\n    In this function will be raised DBDuplicateEntry exception if integrity\n    error wrap unique constraint violation.\n    """'
newline|'\n'
nl|'\n'
DECL|function|get_columns_from_uniq_cons_or_name
name|'def'
name|'get_columns_from_uniq_cons_or_name'
op|'('
name|'columns'
op|')'
op|':'
newline|'\n'
comment|'# note(vsergeyev): UniqueConstraint name convention: "uniq_t0c10c2"'
nl|'\n'
comment|'#                  where `t` it is table name and columns `c1`, `c2`'
nl|'\n'
comment|'#                  are in UniqueConstraint.'
nl|'\n'
indent|'        '
name|'uniqbase'
op|'='
string|'"uniq_"'
newline|'\n'
name|'if'
name|'not'
name|'columns'
op|'.'
name|'startswith'
op|'('
name|'uniqbase'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'engine_name'
op|'=='
string|'"postgresql"'
op|':'
newline|'\n'
indent|'                '
name|'return'
op|'['
name|'columns'
op|'['
name|'columns'
op|'.'
name|'index'
op|'('
string|'"_"'
op|')'
op|'+'
number|'1'
op|':'
name|'columns'
op|'.'
name|'rindex'
op|'('
string|'"_"'
op|')'
op|']'
op|']'
newline|'\n'
dedent|''
name|'return'
op|'['
name|'columns'
op|']'
newline|'\n'
dedent|''
name|'return'
name|'columns'
op|'['
name|'len'
op|'('
name|'uniqbase'
op|')'
op|':'
op|']'
op|'.'
name|'split'
op|'('
string|'"0"'
op|')'
op|'['
number|'1'
op|':'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'engine_name'
name|'not'
name|'in'
op|'['
string|'"ibm_db_sa"'
op|','
string|'"mysql"'
op|','
string|'"sqlite"'
op|','
string|'"postgresql"'
op|']'
op|':'
newline|'\n'
indent|'        '
name|'return'
newline|'\n'
nl|'\n'
comment|'# FIXME(johannes): The usage of the .message attribute has been'
nl|'\n'
comment|'# deprecated since Python 2.6. However, the exceptions raised by'
nl|'\n'
comment|'# SQLAlchemy can differ when using unicode() and accessing .message.'
nl|'\n'
comment|'# An audit across all three supported engines will be necessary to'
nl|'\n'
comment|'# ensure there are no regressions.'
nl|'\n'
dedent|''
name|'for'
name|'pattern'
name|'in'
name|'_DUP_KEY_RE_DB'
op|'['
name|'engine_name'
op|']'
op|':'
newline|'\n'
indent|'        '
name|'match'
op|'='
name|'pattern'
op|'.'
name|'match'
op|'('
name|'integrity_error'
op|'.'
name|'message'
op|')'
newline|'\n'
name|'if'
name|'match'
op|':'
newline|'\n'
indent|'            '
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
newline|'\n'
nl|'\n'
comment|"# NOTE(mriedem): The ibm_db_sa integrity error message doesn't provide the"
nl|'\n'
comment|'# columns so we have to omit that from the DBDuplicateEntry error.'
nl|'\n'
dedent|''
name|'columns'
op|'='
string|"''"
newline|'\n'
nl|'\n'
name|'if'
name|'engine_name'
op|'!='
string|"'ibm_db_sa'"
op|':'
newline|'\n'
indent|'        '
name|'columns'
op|'='
name|'match'
op|'.'
name|'group'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'engine_name'
op|'=='
string|'"sqlite"'
op|':'
newline|'\n'
indent|'        '
name|'columns'
op|'='
op|'['
name|'c'
op|'.'
name|'split'
op|'('
string|"'.'"
op|')'
op|'['
op|'-'
number|'1'
op|']'
name|'for'
name|'c'
name|'in'
name|'columns'
op|'.'
name|'strip'
op|'('
op|')'
op|'.'
name|'split'
op|'('
string|'", "'
op|')'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'columns'
op|'='
name|'get_columns_from_uniq_cons_or_name'
op|'('
name|'columns'
op|')'
newline|'\n'
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'DBDuplicateEntry'
op|'('
name|'columns'
op|','
name|'integrity_error'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# NOTE(comstud): In current versions of DB backends, Deadlock violation'
nl|'\n'
comment|'# messages follow the structure:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# mysql:'
nl|'\n'
comment|"# (OperationalError) (1213, 'Deadlock found when trying to get lock; try '"
nl|'\n'
comment|"#                     'restarting transaction') <query_str> <query_args>"
nl|'\n'
DECL|variable|_DEADLOCK_RE_DB
dedent|''
name|'_DEADLOCK_RE_DB'
op|'='
op|'{'
nl|'\n'
string|'"mysql"'
op|':'
name|'re'
op|'.'
name|'compile'
op|'('
string|'r"^.*\\(1213, \'Deadlock.*"'
op|')'
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_raise_if_deadlock_error
name|'def'
name|'_raise_if_deadlock_error'
op|'('
name|'operational_error'
op|','
name|'engine_name'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Raise exception on deadlock condition.\n\n    Raise DBDeadlock exception if OperationalError contains a Deadlock\n    condition.\n    """'
newline|'\n'
name|'re'
op|'='
name|'_DEADLOCK_RE_DB'
op|'.'
name|'get'
op|'('
name|'engine_name'
op|')'
newline|'\n'
name|'if'
name|'re'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'return'
newline|'\n'
comment|'# FIXME(johannes): The usage of the .message attribute has been'
nl|'\n'
comment|'# deprecated since Python 2.6. However, the exceptions raised by'
nl|'\n'
comment|'# SQLAlchemy can differ when using unicode() and accessing .message.'
nl|'\n'
comment|'# An audit across all three supported engines will be necessary to'
nl|'\n'
comment|'# ensure there are no regressions.'
nl|'\n'
dedent|''
name|'m'
op|'='
name|'re'
op|'.'
name|'match'
op|'('
name|'operational_error'
op|'.'
name|'message'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'m'
op|':'
newline|'\n'
indent|'        '
name|'return'
newline|'\n'
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'DBDeadlock'
op|'('
name|'operational_error'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_wrap_db_error
dedent|''
name|'def'
name|'_wrap_db_error'
op|'('
name|'f'
op|')'
op|':'
newline|'\n'
comment|'#TODO(rpodolyaka): in a subsequent commit make this a class decorator to'
nl|'\n'
comment|'# ensure it can only applied to Session subclasses instances (as we use'
nl|'\n'
comment|'# Session instance bind attribute below)'
nl|'\n'
nl|'\n'
indent|'    '
op|'@'
name|'functools'
op|'.'
name|'wraps'
op|'('
name|'f'
op|')'
newline|'\n'
DECL|function|_wrap
name|'def'
name|'_wrap'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'f'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'UnicodeEncodeError'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'DBInvalidUnicodeParameter'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'sqla_exc'
op|'.'
name|'OperationalError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'_raise_if_db_connection_lost'
op|'('
name|'e'
op|','
name|'self'
op|'.'
name|'bind'
op|')'
newline|'\n'
name|'_raise_if_deadlock_error'
op|'('
name|'e'
op|','
name|'self'
op|'.'
name|'bind'
op|'.'
name|'dialect'
op|'.'
name|'name'
op|')'
newline|'\n'
comment|'# NOTE(comstud): A lot of code is checking for OperationalError'
nl|'\n'
comment|"# so let's not wrap it for now."
nl|'\n'
name|'raise'
newline|'\n'
comment|'# note(boris-42): We should catch unique constraint violation and'
nl|'\n'
comment|'# wrap it by our own DBDuplicateEntry exception. Unique constraint'
nl|'\n'
comment|'# violation is wrapped by IntegrityError.'
nl|'\n'
dedent|''
name|'except'
name|'sqla_exc'
op|'.'
name|'IntegrityError'
name|'as'
name|'e'
op|':'
newline|'\n'
comment|"# note(boris-42): SqlAlchemy doesn't unify errors from different"
nl|'\n'
comment|'# DBs so we must do this. Also in some tables (for example'
nl|'\n'
comment|'# instance_types) there are more than one unique constraint. This'
nl|'\n'
comment|'# means we should get names of columns, which values violate'
nl|'\n'
comment|'# unique constraint, from error message.'
nl|'\n'
indent|'            '
name|'_raise_if_duplicate_entry_error'
op|'('
name|'e'
op|','
name|'self'
op|'.'
name|'bind'
op|'.'
name|'dialect'
op|'.'
name|'name'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'DBError'
op|'('
name|'e'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'DB exception wrapped.'"
op|')'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'DBError'
op|'('
name|'e'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'_wrap'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_synchronous_switch_listener
dedent|''
name|'def'
name|'_synchronous_switch_listener'
op|'('
name|'dbapi_conn'
op|','
name|'connection_rec'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Switch sqlite connections to non-synchronous mode."""'
newline|'\n'
name|'dbapi_conn'
op|'.'
name|'execute'
op|'('
string|'"PRAGMA synchronous = OFF"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_add_regexp_listener
dedent|''
name|'def'
name|'_add_regexp_listener'
op|'('
name|'dbapi_con'
op|','
name|'con_record'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Add REGEXP function to sqlite connections."""'
newline|'\n'
nl|'\n'
DECL|function|regexp
name|'def'
name|'regexp'
op|'('
name|'expr'
op|','
name|'item'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'reg'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
name|'expr'
op|')'
newline|'\n'
name|'return'
name|'reg'
op|'.'
name|'search'
op|'('
name|'six'
op|'.'
name|'text_type'
op|'('
name|'item'
op|')'
op|')'
name|'is'
name|'not'
name|'None'
newline|'\n'
dedent|''
name|'dbapi_con'
op|'.'
name|'create_function'
op|'('
string|"'regexp'"
op|','
number|'2'
op|','
name|'regexp'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_thread_yield
dedent|''
name|'def'
name|'_thread_yield'
op|'('
name|'dbapi_con'
op|','
name|'con_record'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Ensure other greenthreads get a chance to be executed.\n\n    If we use eventlet.monkey_patch(), eventlet.greenthread.sleep(0) will\n    execute instead of time.sleep(0).\n    Force a context switch. With common database backends (eg MySQLdb and\n    sqlite), there is no implicit yield caused by network I/O since they are\n    implemented by C libraries that eventlet cannot monkey patch.\n    """'
newline|'\n'
name|'time'
op|'.'
name|'sleep'
op|'('
number|'0'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_ping_listener
dedent|''
name|'def'
name|'_ping_listener'
op|'('
name|'engine'
op|','
name|'dbapi_conn'
op|','
name|'connection_rec'
op|','
name|'connection_proxy'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Ensures that MySQL and DB2 connections are alive.\n\n    Borrowed from:\n    http://groups.google.com/group/sqlalchemy/msg/a4ce563d802c929f\n    """'
newline|'\n'
name|'cursor'
op|'='
name|'dbapi_conn'
op|'.'
name|'cursor'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'ping_sql'
op|'='
string|"'select 1'"
newline|'\n'
name|'if'
name|'engine'
op|'.'
name|'name'
op|'=='
string|"'ibm_db_sa'"
op|':'
newline|'\n'
comment|'# DB2 requires a table expression'
nl|'\n'
indent|'            '
name|'ping_sql'
op|'='
string|"'select 1 from (values (1)) AS t1'"
newline|'\n'
dedent|''
name|'cursor'
op|'.'
name|'execute'
op|'('
name|'ping_sql'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'engine'
op|'.'
name|'dialect'
op|'.'
name|'is_disconnect'
op|'('
name|'ex'
op|','
name|'dbapi_conn'
op|','
name|'cursor'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_LW'
op|'('
string|"'Database server has gone away: %s'"
op|')'
op|'%'
name|'ex'
newline|'\n'
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'msg'
op|')'
newline|'\n'
name|'raise'
name|'sqla_exc'
op|'.'
name|'DisconnectionError'
op|'('
name|'msg'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_set_mode_traditional
dedent|''
dedent|''
dedent|''
name|'def'
name|'_set_mode_traditional'
op|'('
name|'dbapi_con'
op|','
name|'connection_rec'
op|','
name|'connection_proxy'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Set engine mode to \'traditional\'.\n\n    Required to prevent silent truncates at insert or update operations\n    under MySQL. By default MySQL truncates inserted string if it longer\n    than a declared field just with warning. That is fraught with data\n    corruption.\n    """'
newline|'\n'
name|'_set_session_sql_mode'
op|'('
name|'dbapi_con'
op|','
name|'connection_rec'
op|','
nl|'\n'
name|'connection_proxy'
op|','
string|"'TRADITIONAL'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_set_session_sql_mode
dedent|''
name|'def'
name|'_set_session_sql_mode'
op|'('
name|'dbapi_con'
op|','
name|'connection_rec'
op|','
nl|'\n'
name|'connection_proxy'
op|','
name|'sql_mode'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Set the sql_mode session variable.\n\n    MySQL supports several server modes. The default is None, but sessions\n    may choose to enable server modes like TRADITIONAL, ANSI,\n    several STRICT_* modes and others.\n\n    Note: passing in \'\' (empty string) for sql_mode clears\n    the SQL mode for the session, overriding a potentially set\n    server default. Passing in None (the default) makes this\n    a no-op, meaning if a server-side SQL mode is set, it still applies.\n    """'
newline|'\n'
name|'cursor'
op|'='
name|'dbapi_con'
op|'.'
name|'cursor'
op|'('
op|')'
newline|'\n'
name|'if'
name|'sql_mode'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'cursor'
op|'.'
name|'execute'
op|'('
string|'"SET SESSION sql_mode = %s"'
op|','
op|'['
name|'sql_mode'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Check against the real effective SQL mode. Even when unset by'
nl|'\n'
comment|'# our own config, the server may still be operating in a specific'
nl|'\n'
comment|'# SQL mode as set by the server configuration'
nl|'\n'
dedent|''
name|'cursor'
op|'.'
name|'execute'
op|'('
string|'"SHOW VARIABLES LIKE \'sql_mode\'"'
op|')'
newline|'\n'
name|'row'
op|'='
name|'cursor'
op|'.'
name|'fetchone'
op|'('
op|')'
newline|'\n'
name|'if'
name|'row'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|"'Unable to detect effective SQL mode'"
op|')'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'realmode'
op|'='
name|'row'
op|'['
number|'1'
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'MySQL server mode set to %s'"
op|')'
op|'%'
name|'realmode'
op|')'
newline|'\n'
comment|"# 'TRADITIONAL' mode enables several other modes, so"
nl|'\n'
comment|'# we need a substring match here'
nl|'\n'
name|'if'
name|'not'
op|'('
string|"'TRADITIONAL'"
name|'in'
name|'realmode'
op|'.'
name|'upper'
op|'('
op|')'
name|'or'
nl|'\n'
string|"'STRICT_ALL_TABLES'"
name|'in'
name|'realmode'
op|'.'
name|'upper'
op|'('
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"MySQL SQL mode is \'%s\', "'
nl|'\n'
string|'"consider enabling TRADITIONAL or STRICT_ALL_TABLES"'
op|')'
nl|'\n'
op|'%'
name|'realmode'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_is_db_connection_error
dedent|''
dedent|''
name|'def'
name|'_is_db_connection_error'
op|'('
name|'args'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return True if error in connecting to db."""'
newline|'\n'
comment|'# NOTE(adam_g): This is currently MySQL specific and needs to be extended'
nl|'\n'
comment|'#               to support Postgres and others.'
nl|'\n'
comment|'# For the db2, the error code is -30081 since the db2 is still not ready'
nl|'\n'
name|'conn_err_codes'
op|'='
op|'('
string|"'2002'"
op|','
string|"'2003'"
op|','
string|"'2006'"
op|','
string|"'2013'"
op|','
string|"'-30081'"
op|')'
newline|'\n'
name|'for'
name|'err_code'
name|'in'
name|'conn_err_codes'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'args'
op|'.'
name|'find'
op|'('
name|'err_code'
op|')'
op|'!='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_raise_if_db_connection_lost
dedent|''
name|'def'
name|'_raise_if_db_connection_lost'
op|'('
name|'error'
op|','
name|'engine'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(vsergeyev): Function is_disconnect(e, connection, cursor)'
nl|'\n'
comment|'#                  requires connection and cursor in incoming parameters,'
nl|'\n'
comment|'#                  but we have no possibility to create connection if DB'
nl|'\n'
comment|'#                  is not available, so in such case reconnect fails.'
nl|'\n'
comment|'#                  But is_disconnect() ignores these parameters, so it'
nl|'\n'
comment|'#                  makes sense to pass to function None as placeholder'
nl|'\n'
comment|'#                  instead of connection and cursor.'
nl|'\n'
indent|'    '
name|'if'
name|'engine'
op|'.'
name|'dialect'
op|'.'
name|'is_disconnect'
op|'('
name|'error'
op|','
name|'None'
op|','
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'DBConnectionError'
op|'('
name|'error'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|create_engine
dedent|''
dedent|''
name|'def'
name|'create_engine'
op|'('
name|'sql_connection'
op|','
name|'sqlite_fk'
op|'='
name|'False'
op|','
name|'mysql_sql_mode'
op|'='
name|'None'
op|','
nl|'\n'
name|'mysql_traditional_mode'
op|'='
name|'False'
op|','
name|'idle_timeout'
op|'='
number|'3600'
op|','
nl|'\n'
name|'connection_debug'
op|'='
number|'0'
op|','
name|'max_pool_size'
op|'='
name|'None'
op|','
name|'max_overflow'
op|'='
name|'None'
op|','
nl|'\n'
name|'pool_timeout'
op|'='
name|'None'
op|','
name|'sqlite_synchronous'
op|'='
name|'True'
op|','
nl|'\n'
name|'connection_trace'
op|'='
name|'False'
op|','
name|'max_retries'
op|'='
number|'10'
op|','
name|'retry_interval'
op|'='
number|'10'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return a new SQLAlchemy engine."""'
newline|'\n'
nl|'\n'
name|'connection_dict'
op|'='
name|'sqlalchemy'
op|'.'
name|'engine'
op|'.'
name|'url'
op|'.'
name|'make_url'
op|'('
name|'sql_connection'
op|')'
newline|'\n'
nl|'\n'
name|'engine_args'
op|'='
op|'{'
nl|'\n'
string|'"pool_recycle"'
op|':'
name|'idle_timeout'
op|','
nl|'\n'
string|"'convert_unicode'"
op|':'
name|'True'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
name|'logger'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
string|"'sqlalchemy.engine'"
op|')'
newline|'\n'
nl|'\n'
comment|'# Map SQL debug level to Python log level'
nl|'\n'
name|'if'
name|'connection_debug'
op|'>='
number|'100'
op|':'
newline|'\n'
indent|'        '
name|'logger'
op|'.'
name|'setLevel'
op|'('
name|'logging'
op|'.'
name|'DEBUG'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'connection_debug'
op|'>='
number|'50'
op|':'
newline|'\n'
indent|'        '
name|'logger'
op|'.'
name|'setLevel'
op|'('
name|'logging'
op|'.'
name|'INFO'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'logger'
op|'.'
name|'setLevel'
op|'('
name|'logging'
op|'.'
name|'WARNING'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
string|'"sqlite"'
name|'in'
name|'connection_dict'
op|'.'
name|'drivername'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'sqlite_fk'
op|':'
newline|'\n'
indent|'            '
name|'engine_args'
op|'['
string|'"listeners"'
op|']'
op|'='
op|'['
name|'SqliteForeignKeysListener'
op|'('
op|')'
op|']'
newline|'\n'
dedent|''
name|'engine_args'
op|'['
string|'"poolclass"'
op|']'
op|'='
name|'NullPool'
newline|'\n'
nl|'\n'
name|'if'
name|'sql_connection'
op|'=='
string|'"sqlite://"'
op|':'
newline|'\n'
indent|'            '
name|'engine_args'
op|'['
string|'"poolclass"'
op|']'
op|'='
name|'StaticPool'
newline|'\n'
name|'engine_args'
op|'['
string|'"connect_args"'
op|']'
op|'='
op|'{'
string|"'check_same_thread'"
op|':'
name|'False'
op|'}'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'max_pool_size'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'engine_args'
op|'['
string|"'pool_size'"
op|']'
op|'='
name|'max_pool_size'
newline|'\n'
dedent|''
name|'if'
name|'max_overflow'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'engine_args'
op|'['
string|"'max_overflow'"
op|']'
op|'='
name|'max_overflow'
newline|'\n'
dedent|''
name|'if'
name|'pool_timeout'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'engine_args'
op|'['
string|"'pool_timeout'"
op|']'
op|'='
name|'pool_timeout'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'engine'
op|'='
name|'sqlalchemy'
op|'.'
name|'create_engine'
op|'('
name|'sql_connection'
op|','
op|'**'
name|'engine_args'
op|')'
newline|'\n'
nl|'\n'
name|'sqlalchemy'
op|'.'
name|'event'
op|'.'
name|'listen'
op|'('
name|'engine'
op|','
string|"'checkin'"
op|','
name|'_thread_yield'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'engine'
op|'.'
name|'name'
name|'in'
op|'['
string|"'mysql'"
op|','
string|"'ibm_db_sa'"
op|']'
op|':'
newline|'\n'
indent|'        '
name|'ping_callback'
op|'='
name|'functools'
op|'.'
name|'partial'
op|'('
name|'_ping_listener'
op|','
name|'engine'
op|')'
newline|'\n'
name|'sqlalchemy'
op|'.'
name|'event'
op|'.'
name|'listen'
op|'('
name|'engine'
op|','
string|"'checkout'"
op|','
name|'ping_callback'
op|')'
newline|'\n'
name|'if'
name|'engine'
op|'.'
name|'name'
op|'=='
string|"'mysql'"
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'mysql_traditional_mode'
op|':'
newline|'\n'
indent|'                '
name|'mysql_sql_mode'
op|'='
string|"'TRADITIONAL'"
newline|'\n'
dedent|''
name|'if'
name|'mysql_sql_mode'
op|':'
newline|'\n'
indent|'                '
name|'mode_callback'
op|'='
name|'functools'
op|'.'
name|'partial'
op|'('
name|'_set_session_sql_mode'
op|','
nl|'\n'
name|'sql_mode'
op|'='
name|'mysql_sql_mode'
op|')'
newline|'\n'
name|'sqlalchemy'
op|'.'
name|'event'
op|'.'
name|'listen'
op|'('
name|'engine'
op|','
string|"'checkout'"
op|','
name|'mode_callback'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'elif'
string|"'sqlite'"
name|'in'
name|'connection_dict'
op|'.'
name|'drivername'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'sqlite_synchronous'
op|':'
newline|'\n'
indent|'            '
name|'sqlalchemy'
op|'.'
name|'event'
op|'.'
name|'listen'
op|'('
name|'engine'
op|','
string|"'connect'"
op|','
nl|'\n'
name|'_synchronous_switch_listener'
op|')'
newline|'\n'
dedent|''
name|'sqlalchemy'
op|'.'
name|'event'
op|'.'
name|'listen'
op|'('
name|'engine'
op|','
string|"'connect'"
op|','
name|'_add_regexp_listener'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'connection_trace'
name|'and'
name|'engine'
op|'.'
name|'dialect'
op|'.'
name|'dbapi'
op|'.'
name|'__name__'
op|'=='
string|"'MySQLdb'"
op|':'
newline|'\n'
indent|'        '
name|'_patch_mysqldb_with_stacktrace_comments'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'engine'
op|'.'
name|'connect'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'sqla_exc'
op|'.'
name|'OperationalError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'_is_db_connection_error'
op|'('
name|'e'
op|'.'
name|'args'
op|'['
number|'0'
op|']'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
name|'remaining'
op|'='
name|'max_retries'
newline|'\n'
name|'if'
name|'remaining'
op|'=='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'remaining'
op|'='
string|"'infinite'"
newline|'\n'
dedent|''
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_LW'
op|'('
string|"'SQL connection failed. %s attempts left.'"
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'msg'
op|'%'
name|'remaining'
op|')'
newline|'\n'
name|'if'
name|'remaining'
op|'!='
string|"'infinite'"
op|':'
newline|'\n'
indent|'                '
name|'remaining'
op|'-='
number|'1'
newline|'\n'
dedent|''
name|'time'
op|'.'
name|'sleep'
op|'('
name|'retry_interval'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'engine'
op|'.'
name|'connect'
op|'('
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'except'
name|'sqla_exc'
op|'.'
name|'OperationalError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'if'
op|'('
name|'remaining'
op|'!='
string|"'infinite'"
name|'and'
name|'remaining'
op|'=='
number|'0'
op|')'
name|'or'
name|'not'
name|'_is_db_connection_error'
op|'('
name|'e'
op|'.'
name|'args'
op|'['
number|'0'
op|']'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'return'
name|'engine'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Query
dedent|''
name|'class'
name|'Query'
op|'('
name|'sqlalchemy'
op|'.'
name|'orm'
op|'.'
name|'query'
op|'.'
name|'Query'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Subclass of sqlalchemy.query with soft_delete() method."""'
newline|'\n'
DECL|member|soft_delete
name|'def'
name|'soft_delete'
op|'('
name|'self'
op|','
name|'synchronize_session'
op|'='
string|"'evaluate'"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'update'
op|'('
op|'{'
string|"'deleted'"
op|':'
name|'literal_column'
op|'('
string|"'id'"
op|')'
op|','
nl|'\n'
string|"'updated_at'"
op|':'
name|'literal_column'
op|'('
string|"'updated_at'"
op|')'
op|','
nl|'\n'
string|"'deleted_at'"
op|':'
name|'timeutils'
op|'.'
name|'utcnow'
op|'('
op|')'
op|'}'
op|','
nl|'\n'
name|'synchronize_session'
op|'='
name|'synchronize_session'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Session
dedent|''
dedent|''
name|'class'
name|'Session'
op|'('
name|'sqlalchemy'
op|'.'
name|'orm'
op|'.'
name|'session'
op|'.'
name|'Session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Custom Session class to avoid SqlAlchemy Session monkey patching."""'
newline|'\n'
op|'@'
name|'_wrap_db_error'
newline|'\n'
DECL|member|query
name|'def'
name|'query'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'super'
op|'('
name|'Session'
op|','
name|'self'
op|')'
op|'.'
name|'query'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'_wrap_db_error'
newline|'\n'
DECL|member|flush
name|'def'
name|'flush'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'super'
op|'('
name|'Session'
op|','
name|'self'
op|')'
op|'.'
name|'flush'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'_wrap_db_error'
newline|'\n'
DECL|member|execute
name|'def'
name|'execute'
op|'('
name|'self'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'super'
op|'('
name|'Session'
op|','
name|'self'
op|')'
op|'.'
name|'execute'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_maker
dedent|''
dedent|''
name|'def'
name|'get_maker'
op|'('
name|'engine'
op|','
name|'autocommit'
op|'='
name|'True'
op|','
name|'expire_on_commit'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return a SQLAlchemy sessionmaker using the given engine."""'
newline|'\n'
name|'return'
name|'sqlalchemy'
op|'.'
name|'orm'
op|'.'
name|'sessionmaker'
op|'('
name|'bind'
op|'='
name|'engine'
op|','
nl|'\n'
name|'class_'
op|'='
name|'Session'
op|','
nl|'\n'
name|'autocommit'
op|'='
name|'autocommit'
op|','
nl|'\n'
name|'expire_on_commit'
op|'='
name|'expire_on_commit'
op|','
nl|'\n'
name|'query_cls'
op|'='
name|'Query'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_patch_mysqldb_with_stacktrace_comments
dedent|''
name|'def'
name|'_patch_mysqldb_with_stacktrace_comments'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Adds current stack trace as a comment in queries.\n\n    Patches MySQLdb.cursors.BaseCursor._do_query.\n    """'
newline|'\n'
name|'import'
name|'MySQLdb'
op|'.'
name|'cursors'
newline|'\n'
name|'import'
name|'traceback'
newline|'\n'
nl|'\n'
name|'old_mysql_do_query'
op|'='
name|'MySQLdb'
op|'.'
name|'cursors'
op|'.'
name|'BaseCursor'
op|'.'
name|'_do_query'
newline|'\n'
nl|'\n'
DECL|function|_do_query
name|'def'
name|'_do_query'
op|'('
name|'self'
op|','
name|'q'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'stack'
op|'='
string|"''"
newline|'\n'
name|'for'
name|'filename'
op|','
name|'line'
op|','
name|'method'
op|','
name|'function'
name|'in'
name|'traceback'
op|'.'
name|'extract_stack'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# exclude various common things from trace'
nl|'\n'
indent|'            '
name|'if'
name|'filename'
op|'.'
name|'endswith'
op|'('
string|"'session.py'"
op|')'
name|'and'
name|'method'
op|'=='
string|"'_do_query'"
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'if'
name|'filename'
op|'.'
name|'endswith'
op|'('
string|"'api.py'"
op|')'
name|'and'
name|'method'
op|'=='
string|"'wrapper'"
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'if'
name|'filename'
op|'.'
name|'endswith'
op|'('
string|"'utils.py'"
op|')'
name|'and'
name|'method'
op|'=='
string|"'_inner'"
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'if'
name|'filename'
op|'.'
name|'endswith'
op|'('
string|"'exception.py'"
op|')'
name|'and'
name|'method'
op|'=='
string|"'_wrap'"
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
comment|'# db/api is just a wrapper around db/sqlalchemy/api'
nl|'\n'
dedent|''
name|'if'
name|'filename'
op|'.'
name|'endswith'
op|'('
string|"'db/api.py'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
comment|'# only trace inside nova'
nl|'\n'
dedent|''
name|'index'
op|'='
name|'filename'
op|'.'
name|'rfind'
op|'('
string|"'nova'"
op|')'
newline|'\n'
name|'if'
name|'index'
op|'=='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'stack'
op|'+='
string|'"File:%s:%s Method:%s() Line:%s | "'
op|'%'
op|'('
name|'filename'
op|'['
name|'index'
op|':'
op|']'
op|','
name|'line'
op|','
name|'method'
op|','
name|'function'
op|')'
newline|'\n'
nl|'\n'
comment|'# strip trailing " | " from stack'
nl|'\n'
dedent|''
name|'if'
name|'stack'
op|':'
newline|'\n'
indent|'            '
name|'stack'
op|'='
name|'stack'
op|'['
op|':'
op|'-'
number|'3'
op|']'
newline|'\n'
name|'qq'
op|'='
string|'"%s /* %s */"'
op|'%'
op|'('
name|'q'
op|','
name|'stack'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'qq'
op|'='
name|'q'
newline|'\n'
dedent|''
name|'old_mysql_do_query'
op|'('
name|'self'
op|','
name|'qq'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'setattr'
op|'('
name|'MySQLdb'
op|'.'
name|'cursors'
op|'.'
name|'BaseCursor'
op|','
string|"'_do_query'"
op|','
name|'_do_query'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|EngineFacade
dedent|''
name|'class'
name|'EngineFacade'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""A helper class for removing of global engine instances from nova.db.\n\n    As a library, nova.db can\'t decide where to store/when to create engine\n    and sessionmaker instances, so this must be left for a target application.\n\n    On the other hand, in order to simplify the adoption of nova.db changes,\n    we\'ll provide a helper class, which creates engine and sessionmaker\n    on its instantiation and provides get_engine()/get_session() methods\n    that are compatible with corresponding utility functions that currently\n    exist in target projects, e.g. in Nova.\n\n    engine/sessionmaker instances will still be global (and they are meant to\n    be global), but they will be stored in the app context, rather that in the\n    nova.db context.\n\n    Note: using of this helper is completely optional and you are encouraged to\n    integrate engine/sessionmaker instances into your apps any way you like\n    (e.g. one might want to bind a session to a request context). Two important\n    things to remember:\n        1. An Engine instance is effectively a pool of DB connections, so it\'s\n           meant to be shared (and it\'s thread-safe).\n        2. A Session instance is not meant to be shared and represents a DB\n           transactional context (i.e. it\'s not thread-safe). sessionmaker is\n           a factory of sessions.\n\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'sql_connection'
op|','
nl|'\n'
name|'sqlite_fk'
op|'='
name|'False'
op|','
name|'mysql_sql_mode'
op|'='
name|'None'
op|','
nl|'\n'
name|'autocommit'
op|'='
name|'True'
op|','
name|'expire_on_commit'
op|'='
name|'False'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Initialize engine and sessionmaker instances.\n\n        :param sqlite_fk: enable foreign keys in SQLite\n        :type sqlite_fk: bool\n\n        :param mysql_sql_mode: set SQL mode in MySQL\n        :type mysql_sql_mode: string\n\n        :param autocommit: use autocommit mode for created Session instances\n        :type autocommit: bool\n\n        :param expire_on_commit: expire session objects on commit\n        :type expire_on_commit: bool\n\n        Keyword arguments:\n\n        :keyword idle_timeout: timeout before idle sql connections are reaped\n                               (defaults to 3600)\n        :keyword connection_debug: verbosity of SQL debugging information.\n                                   0=None, 100=Everything (defaults to 0)\n        :keyword max_pool_size: maximum number of SQL connections to keep open\n                                in a pool (defaults to SQLAlchemy settings)\n        :keyword max_overflow: if set, use this value for max_overflow with\n                               sqlalchemy (defaults to SQLAlchemy settings)\n        :keyword pool_timeout: if set, use this value for pool_timeout with\n                               sqlalchemy (defaults to SQLAlchemy settings)\n        :keyword sqlite_synchronous: if True, SQLite uses synchronous mode\n                                     (defaults to True)\n        :keyword connection_trace: add python stack traces to SQL as comment\n                                   strings (defaults to False)\n        :keyword max_retries: maximum db connection retries during startup.\n                              (setting -1 implies an infinite retry count)\n                              (defaults to 10)\n        :keyword retry_interval: interval between retries of opening a sql\n                                 connection (defaults to 10)\n\n        """'
newline|'\n'
nl|'\n'
name|'super'
op|'('
name|'EngineFacade'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_engine'
op|'='
name|'create_engine'
op|'('
nl|'\n'
name|'sql_connection'
op|'='
name|'sql_connection'
op|','
nl|'\n'
name|'sqlite_fk'
op|'='
name|'sqlite_fk'
op|','
nl|'\n'
name|'mysql_sql_mode'
op|'='
name|'mysql_sql_mode'
op|','
nl|'\n'
name|'idle_timeout'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'idle_timeout'"
op|','
number|'3600'
op|')'
op|','
nl|'\n'
name|'connection_debug'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'connection_debug'"
op|','
number|'0'
op|')'
op|','
nl|'\n'
name|'max_pool_size'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'max_pool_size'"
op|')'
op|','
nl|'\n'
name|'max_overflow'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'max_overflow'"
op|')'
op|','
nl|'\n'
name|'pool_timeout'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'pool_timeout'"
op|')'
op|','
nl|'\n'
name|'sqlite_synchronous'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'sqlite_synchronous'"
op|','
name|'True'
op|')'
op|','
nl|'\n'
name|'connection_trace'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'connection_trace'"
op|','
name|'False'
op|')'
op|','
nl|'\n'
name|'max_retries'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'max_retries'"
op|','
number|'10'
op|')'
op|','
nl|'\n'
name|'retry_interval'
op|'='
name|'kwargs'
op|'.'
name|'get'
op|'('
string|"'retry_interval'"
op|','
number|'10'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session_maker'
op|'='
name|'get_maker'
op|'('
nl|'\n'
name|'engine'
op|'='
name|'self'
op|'.'
name|'_engine'
op|','
nl|'\n'
name|'autocommit'
op|'='
name|'autocommit'
op|','
nl|'\n'
name|'expire_on_commit'
op|'='
name|'expire_on_commit'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_engine
dedent|''
name|'def'
name|'get_engine'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the engine instance (note, that it\'s shared)."""'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'_engine'
newline|'\n'
nl|'\n'
DECL|member|get_session
dedent|''
name|'def'
name|'get_session'
op|'('
name|'self'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get a Session instance.\n\n        If passed, keyword arguments values override the ones used when the\n        sessionmaker instance was created.\n\n        :keyword autocommit: use autocommit mode for created Session instances\n        :type autocommit: bool\n\n        :keyword expire_on_commit: expire session objects on commit\n        :type expire_on_commit: bool\n\n        """'
newline|'\n'
nl|'\n'
name|'for'
name|'arg'
name|'in'
name|'kwargs'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'arg'
name|'not'
name|'in'
op|'('
string|"'autocommit'"
op|','
string|"'expire_on_commit'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'del'
name|'kwargs'
op|'['
name|'arg'
op|']'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'_session_maker'
op|'('
op|'**'
name|'kwargs'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
