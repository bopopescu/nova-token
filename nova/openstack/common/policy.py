begin_unit
comment|'# -*- coding: utf-8 -*-'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Copyright (c) 2012 OpenStack Foundation.'
nl|'\n'
comment|'# All Rights Reserved.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
nl|'\n'
string|'"""\nCommon Policy Engine Implementation\n\nPolicies can be expressed in one of two forms: A list of lists, or a\nstring written in the new policy language.\n\nIn the list-of-lists representation, each check inside the innermost\nlist is combined as with an "and" conjunction--for that check to pass,\nall the specified checks must pass.  These innermost lists are then\ncombined as with an "or" conjunction. As an example, take the following\nrule, expressed in the list-of-lists representation::\n\n    [["role:admin"], ["project_id:%(project_id)s", "role:projectadmin"]]\n\nThis is the original way of expressing policies, but there now exists a\nnew way: the policy language.\n\nIn the policy language, each check is specified the same way as in the\nlist-of-lists representation: a simple "a:b" pair that is matched to\nthe correct class to perform that check::\n\n +===========================================================================+\n |            TYPE                |                SYNTAX                    |\n +===========================================================================+\n |User\'s Role                     |              role:admin                  |\n +---------------------------------------------------------------------------+\n |Rules already defined on policy |          rule:admin_required             |\n +---------------------------------------------------------------------------+\n |Against URL\'s\xc2\xb9                  |         http://my-url.org/check          |\n +---------------------------------------------------------------------------+\n |User attributes\xc2\xb2                |    project_id:%(target.project.id)s      |\n +---------------------------------------------------------------------------+\n |Strings                         |        <variable>:\'xpto2035abc\'          |\n |                                |         \'myproject\':<variable>           |\n +---------------------------------------------------------------------------+\n |                                |         project_id:xpto2035abc           |\n |Literals                        |         domain_id:20                     |\n |                                |         True:%(user.enabled)s            |\n +===========================================================================+\n\n\xc2\xb9URL checking must return \'True\' to be valid\n\xc2\xb2User attributes (obtained through the token): user_id, domain_id or project_id\n\nConjunction operators are available, allowing for more expressiveness\nin crafting policies. So, in the policy language, the previous check in\nlist-of-lists becomes::\n\n    role:admin or (project_id:%(project_id)s and role:projectadmin)\n\nThe policy language also has the "not" operator, allowing a richer\npolicy rule::\n\n    project_id:%(project_id)s and not role:dunce\n\nAttributes sent along with API calls can be used by the policy engine\n(on the right side of the expression), by using the following syntax::\n\n    <some_value>:%(user.id)s\n\nContextual attributes of objects identified by their IDs are loaded\nfrom the database. They are also available to the policy engine and\ncan be checked through the `target` keyword::\n\n    <some_value>:%(target.role.name)s\n\nFinally, two special policy checks should be mentioned; the policy\ncheck "@" will always accept an access, and the policy check "!" will\nalways reject an access.  (Note that if a rule is either the empty\nlist ("[]") or the empty string, this is equivalent to the "@" policy\ncheck.)  Of these, the "!" policy check is probably the most useful,\nas it allows particular rules to be explicitly disabled.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'abc'
newline|'\n'
name|'import'
name|'ast'
newline|'\n'
name|'import'
name|'copy'
newline|'\n'
name|'import'
name|'logging'
newline|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'re'
newline|'\n'
nl|'\n'
name|'from'
name|'oslo_config'
name|'import'
name|'cfg'
newline|'\n'
name|'from'
name|'oslo_serialization'
name|'import'
name|'jsonutils'
newline|'\n'
name|'import'
name|'six'
newline|'\n'
name|'import'
name|'six'
op|'.'
name|'moves'
op|'.'
name|'urllib'
op|'.'
name|'parse'
name|'as'
name|'urlparse'
newline|'\n'
name|'import'
name|'six'
op|'.'
name|'moves'
op|'.'
name|'urllib'
op|'.'
name|'request'
name|'as'
name|'urlrequest'
newline|'\n'
nl|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
op|'.'
name|'_i18n'
name|'import'
name|'_'
op|','
name|'_LE'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'utils'
newline|'\n'
nl|'\n'
DECL|variable|policy_opts
name|'policy_opts'
op|'='
op|'['
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'policy_file'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'policy.json'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
name|'_'
op|'('
string|"'The JSON file that defines policies.'"
op|')'
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'policy_default_rule'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'default'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
name|'_'
op|'('
string|"'Default rule. Enforced when a requested rule is not '"
nl|'\n'
string|"'found.'"
op|')'
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'MultiStrOpt'
op|'('
string|"'policy_dirs'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
op|'['
string|"'policy.d'"
op|']'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
name|'_'
op|'('
string|"'Directories where policy configuration files are '"
nl|'\n'
string|"'stored. They can be relative to any directory '"
nl|'\n'
string|"'in the search path defined by the config_dir '"
nl|'\n'
string|"'option, or absolute paths. The file defined by '"
nl|'\n'
string|"'policy_file must exist for these directories to '"
nl|'\n'
string|"'be searched.  Missing or empty directories are '"
nl|'\n'
string|"'ignored.'"
op|')'
op|')'
op|','
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
DECL|variable|CONF
name|'CONF'
op|'='
name|'cfg'
op|'.'
name|'CONF'
newline|'\n'
name|'CONF'
op|'.'
name|'register_opts'
op|'('
name|'policy_opts'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|LOG
name|'LOG'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|_checks
name|'_checks'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|list_opts
name|'def'
name|'list_opts'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Entry point for oslo-config-generator."""'
newline|'\n'
name|'return'
op|'['
op|'('
name|'None'
op|','
name|'copy'
op|'.'
name|'deepcopy'
op|'('
name|'policy_opts'
op|')'
op|')'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|PolicyNotAuthorized
dedent|''
name|'class'
name|'PolicyNotAuthorized'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'rule'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'msg'
op|'='
name|'_'
op|'('
string|'"Policy doesn\'t allow %s to be performed."'
op|')'
op|'%'
name|'rule'
newline|'\n'
name|'super'
op|'('
name|'PolicyNotAuthorized'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Rules
dedent|''
dedent|''
name|'class'
name|'Rules'
op|'('
name|'dict'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""A store for rules. Handles the default_rule setting directly."""'
newline|'\n'
nl|'\n'
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|load_json
name|'def'
name|'load_json'
op|'('
name|'cls'
op|','
name|'data'
op|','
name|'default_rule'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Allow loading of JSON rule data."""'
newline|'\n'
nl|'\n'
comment|'# Suck in the JSON data and parse the rules'
nl|'\n'
name|'rules'
op|'='
name|'dict'
op|'('
op|'('
name|'k'
op|','
name|'parse_rule'
op|'('
name|'v'
op|')'
op|')'
name|'for'
name|'k'
op|','
name|'v'
name|'in'
nl|'\n'
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'data'
op|')'
op|'.'
name|'items'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'cls'
op|'('
name|'rules'
op|','
name|'default_rule'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__init__
dedent|''
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'rules'
op|'='
name|'None'
op|','
name|'default_rule'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Initialize the Rules store."""'
newline|'\n'
nl|'\n'
name|'super'
op|'('
name|'Rules'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'rules'
name|'or'
op|'{'
op|'}'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'default_rule'
op|'='
name|'default_rule'
newline|'\n'
nl|'\n'
DECL|member|__missing__
dedent|''
name|'def'
name|'__missing__'
op|'('
name|'self'
op|','
name|'key'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Implements the default rule handling."""'
newline|'\n'
nl|'\n'
name|'if'
name|'isinstance'
op|'('
name|'self'
op|'.'
name|'default_rule'
op|','
name|'dict'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'KeyError'
op|'('
name|'key'
op|')'
newline|'\n'
nl|'\n'
comment|"# If the default rule isn't actually defined, do something"
nl|'\n'
comment|'# reasonably intelligent'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'default_rule'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'KeyError'
op|'('
name|'key'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'isinstance'
op|'('
name|'self'
op|'.'
name|'default_rule'
op|','
name|'BaseCheck'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'default_rule'
newline|'\n'
nl|'\n'
comment|'# We need to check this or we can get infinite recursion'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'default_rule'
name|'not'
name|'in'
name|'self'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'KeyError'
op|'('
name|'key'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'isinstance'
op|'('
name|'self'
op|'.'
name|'default_rule'
op|','
name|'six'
op|'.'
name|'string_types'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'['
name|'self'
op|'.'
name|'default_rule'
op|']'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Dumps a string representation of the rules."""'
newline|'\n'
nl|'\n'
comment|'# Start by building the canonical strings for the rules'
nl|'\n'
name|'out_rules'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'key'
op|','
name|'value'
name|'in'
name|'self'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# Use empty string for singleton TrueCheck instances'
nl|'\n'
indent|'            '
name|'if'
name|'isinstance'
op|'('
name|'value'
op|','
name|'TrueCheck'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'out_rules'
op|'['
name|'key'
op|']'
op|'='
string|"''"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'out_rules'
op|'['
name|'key'
op|']'
op|'='
name|'str'
op|'('
name|'value'
op|')'
newline|'\n'
nl|'\n'
comment|'# Dump a pretty-printed JSON representation'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
name|'out_rules'
op|','
name|'indent'
op|'='
number|'4'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Enforcer
dedent|''
dedent|''
name|'class'
name|'Enforcer'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Responsible for loading and enforcing rules.\n\n    :param policy_file: Custom policy file to use, if none is\n                        specified, `CONF.policy_file` will be\n                        used.\n    :param rules: Default dictionary / Rules to use. It will be\n                  considered just in the first instantiation. If\n                  `load_rules(True)`, `clear()` or `set_rules(True)`\n                  is called this will be overwritten.\n    :param default_rule: Default rule to use, CONF.default_rule will\n                         be used if none is specified.\n    :param use_conf: Whether to load rules from cache or config file.\n    :param overwrite: Whether to overwrite existing rules when reload rules\n                      from config file.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'policy_file'
op|'='
name|'None'
op|','
name|'rules'
op|'='
name|'None'
op|','
nl|'\n'
name|'default_rule'
op|'='
name|'None'
op|','
name|'use_conf'
op|'='
name|'True'
op|','
name|'overwrite'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'default_rule'
op|'='
name|'default_rule'
name|'or'
name|'CONF'
op|'.'
name|'policy_default_rule'
newline|'\n'
name|'self'
op|'.'
name|'rules'
op|'='
name|'Rules'
op|'('
name|'rules'
op|','
name|'self'
op|'.'
name|'default_rule'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'policy_path'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'policy_file'
op|'='
name|'policy_file'
name|'or'
name|'CONF'
op|'.'
name|'policy_file'
newline|'\n'
name|'self'
op|'.'
name|'use_conf'
op|'='
name|'use_conf'
newline|'\n'
name|'self'
op|'.'
name|'overwrite'
op|'='
name|'overwrite'
newline|'\n'
nl|'\n'
DECL|member|set_rules
dedent|''
name|'def'
name|'set_rules'
op|'('
name|'self'
op|','
name|'rules'
op|','
name|'overwrite'
op|'='
name|'True'
op|','
name|'use_conf'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a new Rules object based on the provided dict of rules.\n\n        :param rules: New rules to use. It should be an instance of dict.\n        :param overwrite: Whether to overwrite current rules or update them\n                          with the new rules.\n        :param use_conf: Whether to reload rules from cache or config file.\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'rules'
op|','
name|'dict'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'TypeError'
op|'('
name|'_'
op|'('
string|'"Rules must be an instance of dict or Rules, "'
nl|'\n'
string|'"got %s instead"'
op|')'
op|'%'
name|'type'
op|'('
name|'rules'
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'use_conf'
op|'='
name|'use_conf'
newline|'\n'
name|'if'
name|'overwrite'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'rules'
op|'='
name|'Rules'
op|'('
name|'rules'
op|','
name|'self'
op|'.'
name|'default_rule'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'rules'
op|'.'
name|'update'
op|'('
name|'rules'
op|')'
newline|'\n'
nl|'\n'
DECL|member|clear
dedent|''
dedent|''
name|'def'
name|'clear'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Clears Enforcer rules, policy\'s cache and policy\'s path."""'
newline|'\n'
name|'self'
op|'.'
name|'set_rules'
op|'('
op|'{'
op|'}'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'delete_cached_file'
op|'('
name|'self'
op|'.'
name|'policy_path'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'default_rule'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'policy_path'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|load_rules
dedent|''
name|'def'
name|'load_rules'
op|'('
name|'self'
op|','
name|'force_reload'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Loads policy_path\'s rules.\n\n        Policy file is cached and will be reloaded if modified.\n\n        :param force_reload: Whether to reload rules from config file.\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'force_reload'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'use_conf'
op|'='
name|'force_reload'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'use_conf'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'self'
op|'.'
name|'policy_path'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'policy_path'
op|'='
name|'self'
op|'.'
name|'_get_policy_path'
op|'('
name|'self'
op|'.'
name|'policy_file'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_load_policy_file'
op|'('
name|'self'
op|'.'
name|'policy_path'
op|','
name|'force_reload'
op|','
nl|'\n'
name|'overwrite'
op|'='
name|'self'
op|'.'
name|'overwrite'
op|')'
newline|'\n'
name|'for'
name|'path'
name|'in'
name|'CONF'
op|'.'
name|'policy_dirs'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'path'
op|'='
name|'self'
op|'.'
name|'_get_policy_path'
op|'('
name|'path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'cfg'
op|'.'
name|'ConfigFilesNotFoundError'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_walk_through_policy_directory'
op|'('
name|'path'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_load_policy_file'
op|','
nl|'\n'
name|'force_reload'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_walk_through_policy_directory
name|'def'
name|'_walk_through_policy_directory'
op|'('
name|'path'
op|','
name|'func'
op|','
op|'*'
name|'args'
op|')'
op|':'
newline|'\n'
comment|'# We do not iterate over sub-directories.'
nl|'\n'
indent|'        '
name|'policy_files'
op|'='
name|'next'
op|'('
name|'os'
op|'.'
name|'walk'
op|'('
name|'path'
op|')'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'policy_files'
op|'.'
name|'sort'
op|'('
op|')'
newline|'\n'
name|'for'
name|'policy_file'
name|'in'
op|'['
name|'p'
name|'for'
name|'p'
name|'in'
name|'policy_files'
name|'if'
name|'not'
name|'p'
op|'.'
name|'startswith'
op|'('
string|"'.'"
op|')'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'func'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'path'
op|','
name|'policy_file'
op|')'
op|','
op|'*'
name|'args'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_load_policy_file
dedent|''
dedent|''
name|'def'
name|'_load_policy_file'
op|'('
name|'self'
op|','
name|'path'
op|','
name|'force_reload'
op|','
name|'overwrite'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'reloaded'
op|','
name|'data'
op|'='
name|'utils'
op|'.'
name|'read_cached_file'
op|'('
nl|'\n'
name|'path'
op|','
name|'force_reload'
op|'='
name|'force_reload'
op|')'
newline|'\n'
name|'if'
name|'reloaded'
name|'or'
name|'not'
name|'self'
op|'.'
name|'rules'
name|'or'
name|'not'
name|'overwrite'
op|':'
newline|'\n'
indent|'                '
name|'rules'
op|'='
name|'Rules'
op|'.'
name|'load_json'
op|'('
name|'data'
op|','
name|'self'
op|'.'
name|'default_rule'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'set_rules'
op|'('
name|'rules'
op|','
name|'overwrite'
op|'='
name|'overwrite'
op|','
name|'use_conf'
op|'='
name|'True'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Reloaded policy file: %(path)s"'
op|','
nl|'\n'
op|'{'
string|"'path'"
op|':'
name|'path'
op|'}'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_policy_path
dedent|''
dedent|''
name|'def'
name|'_get_policy_path'
op|'('
name|'self'
op|','
name|'path'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Locate the policy json data file/path.\n\n        :param path: It\'s value can be a full path or related path. When\n                     full path specified, this function just returns the full\n                     path. When related path specified, this function will\n                     search configuration directories to find one that exists.\n\n        :returns: The policy path\n\n        :raises: ConfigFilesNotFoundError if the file/path couldn\'t\n                 be located.\n        """'
newline|'\n'
name|'policy_path'
op|'='
name|'CONF'
op|'.'
name|'find_file'
op|'('
name|'path'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'policy_path'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'policy_path'
newline|'\n'
nl|'\n'
dedent|''
name|'raise'
name|'cfg'
op|'.'
name|'ConfigFilesNotFoundError'
op|'('
op|'('
name|'path'
op|','
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|enforce
dedent|''
name|'def'
name|'enforce'
op|'('
name|'self'
op|','
name|'rule'
op|','
name|'target'
op|','
name|'creds'
op|','
name|'do_raise'
op|'='
name|'False'
op|','
nl|'\n'
name|'exc'
op|'='
name|'None'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Checks authorization of a rule against the target and credentials.\n\n        :param rule: A string or BaseCheck instance specifying the rule\n                    to evaluate.\n        :param target: As much information about the object being operated\n                    on as possible, as a dictionary.\n        :param creds: As much information about the user performing the\n                    action as possible, as a dictionary.\n        :param do_raise: Whether to raise an exception or not if check\n                        fails.\n        :param exc: Class of the exception to raise if the check fails.\n                    Any remaining arguments passed to enforce() (both\n                    positional and keyword arguments) will be passed to\n                    the exception class. If not specified, PolicyNotAuthorized\n                    will be used.\n\n        :return: Returns False if the policy does not allow the action and\n                exc is not provided; otherwise, returns a value that\n                evaluates to True.  Note: for rules using the "case"\n                expression, this True value will be the specified string\n                from the expression.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'load_rules'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Allow the rule to be a Check tree'
nl|'\n'
name|'if'
name|'isinstance'
op|'('
name|'rule'
op|','
name|'BaseCheck'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'result'
op|'='
name|'rule'
op|'('
name|'target'
op|','
name|'creds'
op|','
name|'self'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'not'
name|'self'
op|'.'
name|'rules'
op|':'
newline|'\n'
comment|"# No rules to reference means we're going to fail closed"
nl|'\n'
indent|'            '
name|'result'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
comment|'# Evaluate the rule'
nl|'\n'
indent|'                '
name|'result'
op|'='
name|'self'
op|'.'
name|'rules'
op|'['
name|'rule'
op|']'
op|'('
name|'target'
op|','
name|'creds'
op|','
name|'self'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Rule [%s] doesn\'t exist"'
op|'%'
name|'rule'
op|')'
newline|'\n'
comment|"# If the rule doesn't exist, fail closed"
nl|'\n'
name|'result'
op|'='
name|'False'
newline|'\n'
nl|'\n'
comment|'# If it is False, raise the exception if requested'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'do_raise'
name|'and'
name|'not'
name|'result'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'exc'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exc'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'raise'
name|'PolicyNotAuthorized'
op|'('
name|'rule'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'six'
op|'.'
name|'add_metaclass'
op|'('
name|'abc'
op|'.'
name|'ABCMeta'
op|')'
newline|'\n'
DECL|class|BaseCheck
name|'class'
name|'BaseCheck'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Abstract base class for Check classes."""'
newline|'\n'
nl|'\n'
op|'@'
name|'abc'
op|'.'
name|'abstractmethod'
newline|'\n'
DECL|member|__str__
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""String representation of the Check tree rooted at this node."""'
newline|'\n'
nl|'\n'
name|'pass'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'abc'
op|'.'
name|'abstractmethod'
newline|'\n'
DECL|member|__call__
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'cred'
op|','
name|'enforcer'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Triggers if instance of the class is called.\n\n        Performs the check. Returns False to reject the access or a\n        true value (not necessary True) to accept the access.\n        """'
newline|'\n'
nl|'\n'
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|FalseCheck
dedent|''
dedent|''
name|'class'
name|'FalseCheck'
op|'('
name|'BaseCheck'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""A policy check that always returns False (disallow)."""'
newline|'\n'
nl|'\n'
DECL|member|__str__
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a string representation of this check."""'
newline|'\n'
nl|'\n'
name|'return'
string|'"!"'
newline|'\n'
nl|'\n'
DECL|member|__call__
dedent|''
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'cred'
op|','
name|'enforcer'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check the policy."""'
newline|'\n'
nl|'\n'
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|TrueCheck
dedent|''
dedent|''
name|'class'
name|'TrueCheck'
op|'('
name|'BaseCheck'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""A policy check that always returns True (allow)."""'
newline|'\n'
nl|'\n'
DECL|member|__str__
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a string representation of this check."""'
newline|'\n'
nl|'\n'
name|'return'
string|'"@"'
newline|'\n'
nl|'\n'
DECL|member|__call__
dedent|''
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'cred'
op|','
name|'enforcer'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check the policy."""'
newline|'\n'
nl|'\n'
name|'return'
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Check
dedent|''
dedent|''
name|'class'
name|'Check'
op|'('
name|'BaseCheck'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""A base class to allow for user-defined policy checks."""'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'kind'
op|','
name|'match'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Initiates Check instance.\n\n        :param kind: The kind of the check, i.e., the field before the\n                     \':\'.\n        :param match: The match of the check, i.e., the field after\n                      the \':\'.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'kind'
op|'='
name|'kind'
newline|'\n'
name|'self'
op|'.'
name|'match'
op|'='
name|'match'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a string representation of this check."""'
newline|'\n'
nl|'\n'
name|'return'
string|'"%s:%s"'
op|'%'
op|'('
name|'self'
op|'.'
name|'kind'
op|','
name|'self'
op|'.'
name|'match'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|NotCheck
dedent|''
dedent|''
name|'class'
name|'NotCheck'
op|'('
name|'BaseCheck'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Implements the "not" logical operator.\n\n    A policy check that inverts the result of another policy check.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'rule'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Initialize the \'not\' check.\n\n        :param rule: The rule to negate.  Must be a Check.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'rule'
op|'='
name|'rule'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a string representation of this check."""'
newline|'\n'
nl|'\n'
name|'return'
string|'"not %s"'
op|'%'
name|'self'
op|'.'
name|'rule'
newline|'\n'
nl|'\n'
DECL|member|__call__
dedent|''
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'cred'
op|','
name|'enforcer'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check the policy.\n\n        Returns the logical inverse of the wrapped check.\n        """'
newline|'\n'
nl|'\n'
name|'return'
name|'not'
name|'self'
op|'.'
name|'rule'
op|'('
name|'target'
op|','
name|'cred'
op|','
name|'enforcer'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|AndCheck
dedent|''
dedent|''
name|'class'
name|'AndCheck'
op|'('
name|'BaseCheck'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Implements the "and" logical operator.\n\n    A policy check that requires that a list of other checks all return True.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'rules'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Initialize the \'and\' check.\n\n        :param rules: A list of rules that will be tested.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'rules'
op|'='
name|'rules'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a string representation of this check."""'
newline|'\n'
nl|'\n'
name|'return'
string|'"(%s)"'
op|'%'
string|"' and '"
op|'.'
name|'join'
op|'('
name|'str'
op|'('
name|'r'
op|')'
name|'for'
name|'r'
name|'in'
name|'self'
op|'.'
name|'rules'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__call__
dedent|''
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'cred'
op|','
name|'enforcer'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check the policy.\n\n        Requires that all rules accept in order to return True.\n        """'
newline|'\n'
nl|'\n'
name|'for'
name|'rule'
name|'in'
name|'self'
op|'.'
name|'rules'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'rule'
op|'('
name|'target'
op|','
name|'cred'
op|','
name|'enforcer'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'True'
newline|'\n'
nl|'\n'
DECL|member|add_check
dedent|''
name|'def'
name|'add_check'
op|'('
name|'self'
op|','
name|'rule'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Adds rule to be tested.\n\n        Allows addition of another rule to the list of rules that will\n        be tested.  Returns the AndCheck object for convenience.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'rules'
op|'.'
name|'append'
op|'('
name|'rule'
op|')'
newline|'\n'
name|'return'
name|'self'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|OrCheck
dedent|''
dedent|''
name|'class'
name|'OrCheck'
op|'('
name|'BaseCheck'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Implements the "or" operator.\n\n    A policy check that requires that at least one of a list of other\n    checks returns True.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'rules'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Initialize the \'or\' check.\n\n        :param rules: A list of rules that will be tested.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'rules'
op|'='
name|'rules'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a string representation of this check."""'
newline|'\n'
nl|'\n'
name|'return'
string|'"(%s)"'
op|'%'
string|"' or '"
op|'.'
name|'join'
op|'('
name|'str'
op|'('
name|'r'
op|')'
name|'for'
name|'r'
name|'in'
name|'self'
op|'.'
name|'rules'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__call__
dedent|''
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'cred'
op|','
name|'enforcer'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check the policy.\n\n        Requires that at least one rule accept in order to return True.\n        """'
newline|'\n'
nl|'\n'
name|'for'
name|'rule'
name|'in'
name|'self'
op|'.'
name|'rules'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'rule'
op|'('
name|'target'
op|','
name|'cred'
op|','
name|'enforcer'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|add_check
dedent|''
name|'def'
name|'add_check'
op|'('
name|'self'
op|','
name|'rule'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Adds rule to be tested.\n\n        Allows addition of another rule to the list of rules that will\n        be tested.  Returns the OrCheck object for convenience.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'rules'
op|'.'
name|'append'
op|'('
name|'rule'
op|')'
newline|'\n'
name|'return'
name|'self'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_parse_check
dedent|''
dedent|''
name|'def'
name|'_parse_check'
op|'('
name|'rule'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Parse a single base check rule into an appropriate Check object."""'
newline|'\n'
nl|'\n'
comment|'# Handle the special checks'
nl|'\n'
name|'if'
name|'rule'
op|'=='
string|"'!'"
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'FalseCheck'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'rule'
op|'=='
string|"'@'"
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'TrueCheck'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'kind'
op|','
name|'match'
op|'='
name|'rule'
op|'.'
name|'split'
op|'('
string|"':'"
op|','
number|'1'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|'"Failed to understand rule %s"'
op|')'
op|'%'
name|'rule'
op|')'
newline|'\n'
comment|"# If the rule is invalid, we'll fail closed"
nl|'\n'
name|'return'
name|'FalseCheck'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Find what implements the check'
nl|'\n'
dedent|''
name|'if'
name|'kind'
name|'in'
name|'_checks'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'_checks'
op|'['
name|'kind'
op|']'
op|'('
name|'kind'
op|','
name|'match'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'None'
name|'in'
name|'_checks'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'_checks'
op|'['
name|'None'
op|']'
op|'('
name|'kind'
op|','
name|'match'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|'"No handler for matches of kind %s"'
op|')'
op|'%'
name|'kind'
op|')'
newline|'\n'
name|'return'
name|'FalseCheck'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_parse_list_rule
dedent|''
dedent|''
name|'def'
name|'_parse_list_rule'
op|'('
name|'rule'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Translates the old list-of-lists syntax into a tree of Check objects.\n\n    Provided for backwards compatibility.\n    """'
newline|'\n'
nl|'\n'
comment|'# Empty rule defaults to True'
nl|'\n'
name|'if'
name|'not'
name|'rule'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'TrueCheck'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Outer list is joined by "or"; inner list by "and"'
nl|'\n'
dedent|''
name|'or_list'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'inner_rule'
name|'in'
name|'rule'
op|':'
newline|'\n'
comment|'# Elide empty inner lists'
nl|'\n'
indent|'        '
name|'if'
name|'not'
name|'inner_rule'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
nl|'\n'
comment|'# Handle bare strings'
nl|'\n'
dedent|''
name|'if'
name|'isinstance'
op|'('
name|'inner_rule'
op|','
name|'six'
op|'.'
name|'string_types'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'inner_rule'
op|'='
op|'['
name|'inner_rule'
op|']'
newline|'\n'
nl|'\n'
comment|'# Parse the inner rules into Check objects'
nl|'\n'
dedent|''
name|'and_list'
op|'='
op|'['
name|'_parse_check'
op|'('
name|'r'
op|')'
name|'for'
name|'r'
name|'in'
name|'inner_rule'
op|']'
newline|'\n'
nl|'\n'
comment|'# Append the appropriate check to the or_list'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'and_list'
op|')'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'or_list'
op|'.'
name|'append'
op|'('
name|'and_list'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'or_list'
op|'.'
name|'append'
op|'('
name|'AndCheck'
op|'('
name|'and_list'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# If we have only one check, omit the "or"'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'or_list'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'FalseCheck'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'len'
op|'('
name|'or_list'
op|')'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'or_list'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'OrCheck'
op|'('
name|'or_list'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# Used for tokenizing the policy language'
nl|'\n'
DECL|variable|_tokenize_re
dedent|''
name|'_tokenize_re'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'\\s+'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_parse_tokenize
name|'def'
name|'_parse_tokenize'
op|'('
name|'rule'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Tokenizer for the policy language.\n\n    Most of the single-character tokens are specified in the\n    _tokenize_re; however, parentheses need to be handled specially,\n    because they can appear inside a check string.  Thankfully, those\n    parentheses that appear inside a check string can never occur at\n    the very beginning or end ("%(variable)s" is the correct syntax).\n    """'
newline|'\n'
nl|'\n'
name|'for'
name|'tok'
name|'in'
name|'_tokenize_re'
op|'.'
name|'split'
op|'('
name|'rule'
op|')'
op|':'
newline|'\n'
comment|'# Skip empty tokens'
nl|'\n'
indent|'        '
name|'if'
name|'not'
name|'tok'
name|'or'
name|'tok'
op|'.'
name|'isspace'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
nl|'\n'
comment|'# Handle leading parens on the token'
nl|'\n'
dedent|''
name|'clean'
op|'='
name|'tok'
op|'.'
name|'lstrip'
op|'('
string|"'('"
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'len'
op|'('
name|'tok'
op|')'
op|'-'
name|'len'
op|'('
name|'clean'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'yield'
string|"'('"
op|','
string|"'('"
newline|'\n'
nl|'\n'
comment|'# If it was only parentheses, continue'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'clean'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'tok'
op|'='
name|'clean'
newline|'\n'
nl|'\n'
comment|'# Handle trailing parens on the token'
nl|'\n'
dedent|''
name|'clean'
op|'='
name|'tok'
op|'.'
name|'rstrip'
op|'('
string|"')'"
op|')'
newline|'\n'
name|'trail'
op|'='
name|'len'
op|'('
name|'tok'
op|')'
op|'-'
name|'len'
op|'('
name|'clean'
op|')'
newline|'\n'
nl|'\n'
comment|'# Yield the cleaned token'
nl|'\n'
name|'lowered'
op|'='
name|'clean'
op|'.'
name|'lower'
op|'('
op|')'
newline|'\n'
name|'if'
name|'lowered'
name|'in'
op|'('
string|"'and'"
op|','
string|"'or'"
op|','
string|"'not'"
op|')'
op|':'
newline|'\n'
comment|'# Special tokens'
nl|'\n'
indent|'            '
name|'yield'
name|'lowered'
op|','
name|'clean'
newline|'\n'
dedent|''
name|'elif'
name|'clean'
op|':'
newline|'\n'
comment|"# Not a special token, but not composed solely of ')'"
nl|'\n'
indent|'            '
name|'if'
name|'len'
op|'('
name|'tok'
op|')'
op|'>='
number|'2'
name|'and'
op|'('
op|'('
name|'tok'
op|'['
number|'0'
op|']'
op|','
name|'tok'
op|'['
op|'-'
number|'1'
op|']'
op|')'
name|'in'
nl|'\n'
op|'['
op|'('
string|'\'"\''
op|','
string|'\'"\''
op|')'
op|','
op|'('
string|'"\'"'
op|','
string|'"\'"'
op|')'
op|']'
op|')'
op|':'
newline|'\n'
comment|"# It's a quoted string"
nl|'\n'
indent|'                '
name|'yield'
string|"'string'"
op|','
name|'tok'
op|'['
number|'1'
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'yield'
string|"'check'"
op|','
name|'_parse_check'
op|'('
name|'clean'
op|')'
newline|'\n'
nl|'\n'
comment|'# Yield the trailing parens'
nl|'\n'
dedent|''
dedent|''
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'trail'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'yield'
string|"')'"
op|','
string|"')'"
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ParseStateMeta
dedent|''
dedent|''
dedent|''
name|'class'
name|'ParseStateMeta'
op|'('
name|'type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Metaclass for the ParseState class.\n\n    Facilitates identifying reduction methods.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__new__
name|'def'
name|'__new__'
op|'('
name|'mcs'
op|','
name|'name'
op|','
name|'bases'
op|','
name|'cls_dict'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create the class.\n\n        Injects the \'reducers\' list, a list of tuples matching token sequences\n        to the names of the corresponding reduction methods.\n        """'
newline|'\n'
nl|'\n'
name|'reducers'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'key'
op|','
name|'value'
name|'in'
name|'cls_dict'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'hasattr'
op|'('
name|'value'
op|','
string|"'reducers'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'for'
name|'reduction'
name|'in'
name|'value'
op|'.'
name|'reducers'
op|':'
newline|'\n'
indent|'                '
name|'reducers'
op|'.'
name|'append'
op|'('
op|'('
name|'reduction'
op|','
name|'key'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'cls_dict'
op|'['
string|"'reducers'"
op|']'
op|'='
name|'reducers'
newline|'\n'
nl|'\n'
name|'return'
name|'super'
op|'('
name|'ParseStateMeta'
op|','
name|'mcs'
op|')'
op|'.'
name|'__new__'
op|'('
name|'mcs'
op|','
name|'name'
op|','
name|'bases'
op|','
name|'cls_dict'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|reducer
dedent|''
dedent|''
name|'def'
name|'reducer'
op|'('
op|'*'
name|'tokens'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Decorator for reduction methods.\n\n    Arguments are a sequence of tokens, in order, which should trigger running\n    this reduction method.\n    """'
newline|'\n'
nl|'\n'
DECL|function|decorator
name|'def'
name|'decorator'
op|'('
name|'func'
op|')'
op|':'
newline|'\n'
comment|'# Make sure we have a list of reducer sequences'
nl|'\n'
indent|'        '
name|'if'
name|'not'
name|'hasattr'
op|'('
name|'func'
op|','
string|"'reducers'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'func'
op|'.'
name|'reducers'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
comment|'# Add the tokens to the list of reducer sequences'
nl|'\n'
dedent|''
name|'func'
op|'.'
name|'reducers'
op|'.'
name|'append'
op|'('
name|'list'
op|'('
name|'tokens'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'func'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'decorator'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
op|'@'
name|'six'
op|'.'
name|'add_metaclass'
op|'('
name|'ParseStateMeta'
op|')'
newline|'\n'
DECL|class|ParseState
name|'class'
name|'ParseState'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Implement the core of parsing the policy language.\n\n    Uses a greedy reduction algorithm to reduce a sequence of tokens into\n    a single terminal, the value of which will be the root of the Check tree.\n\n    Note: error reporting is rather lacking.  The best we can get with\n    this parser formulation is an overall "parse failed" error.\n    Fortunately, the policy language is simple enough that this\n    shouldn\'t be that big a problem.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Initialize the ParseState."""'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'tokens'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'values'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|reduce
dedent|''
name|'def'
name|'reduce'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Perform a greedy reduction of the token stream.\n\n        If a reducer method matches, it will be executed, then the\n        reduce() method will be called recursively to search for any more\n        possible reductions.\n        """'
newline|'\n'
nl|'\n'
name|'for'
name|'reduction'
op|','
name|'methname'
name|'in'
name|'self'
op|'.'
name|'reducers'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'tokens'
op|')'
op|'>='
name|'len'
op|'('
name|'reduction'
op|')'
name|'and'
nl|'\n'
name|'self'
op|'.'
name|'tokens'
op|'['
op|'-'
name|'len'
op|'('
name|'reduction'
op|')'
op|':'
op|']'
op|'=='
name|'reduction'
op|')'
op|':'
newline|'\n'
comment|'# Get the reduction method'
nl|'\n'
indent|'                '
name|'meth'
op|'='
name|'getattr'
op|'('
name|'self'
op|','
name|'methname'
op|')'
newline|'\n'
nl|'\n'
comment|'# Reduce the token stream'
nl|'\n'
name|'results'
op|'='
name|'meth'
op|'('
op|'*'
name|'self'
op|'.'
name|'values'
op|'['
op|'-'
name|'len'
op|'('
name|'reduction'
op|')'
op|':'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Update the tokens and values'
nl|'\n'
name|'self'
op|'.'
name|'tokens'
op|'['
op|'-'
name|'len'
op|'('
name|'reduction'
op|')'
op|':'
op|']'
op|'='
op|'['
name|'r'
op|'['
number|'0'
op|']'
name|'for'
name|'r'
name|'in'
name|'results'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'values'
op|'['
op|'-'
name|'len'
op|'('
name|'reduction'
op|')'
op|':'
op|']'
op|'='
op|'['
name|'r'
op|'['
number|'1'
op|']'
name|'for'
name|'r'
name|'in'
name|'results'
op|']'
newline|'\n'
nl|'\n'
comment|'# Check for any more reductions'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'reduce'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|shift
dedent|''
dedent|''
dedent|''
name|'def'
name|'shift'
op|'('
name|'self'
op|','
name|'tok'
op|','
name|'value'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Adds one more token to the state.  Calls reduce()."""'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'tokens'
op|'.'
name|'append'
op|'('
name|'tok'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'values'
op|'.'
name|'append'
op|'('
name|'value'
op|')'
newline|'\n'
nl|'\n'
comment|'# Do a greedy reduce...'
nl|'\n'
name|'self'
op|'.'
name|'reduce'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|result
name|'def'
name|'result'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Obtain the final result of the parse.\n\n        Raises ValueError if the parse failed to reduce to a single result.\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'self'
op|'.'
name|'values'
op|')'
op|'!='
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|'"Could not parse rule"'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'values'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'reducer'
op|'('
string|"'('"
op|','
string|"'check'"
op|','
string|"')'"
op|')'
newline|'\n'
op|'@'
name|'reducer'
op|'('
string|"'('"
op|','
string|"'and_expr'"
op|','
string|"')'"
op|')'
newline|'\n'
op|'@'
name|'reducer'
op|'('
string|"'('"
op|','
string|"'or_expr'"
op|','
string|"')'"
op|')'
newline|'\n'
DECL|member|_wrap_check
name|'def'
name|'_wrap_check'
op|'('
name|'self'
op|','
name|'_p1'
op|','
name|'check'
op|','
name|'_p2'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Turn parenthesized expressions into a \'check\' token."""'
newline|'\n'
nl|'\n'
name|'return'
op|'['
op|'('
string|"'check'"
op|','
name|'check'
op|')'
op|']'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'reducer'
op|'('
string|"'check'"
op|','
string|"'and'"
op|','
string|"'check'"
op|')'
newline|'\n'
DECL|member|_make_and_expr
name|'def'
name|'_make_and_expr'
op|'('
name|'self'
op|','
name|'check1'
op|','
name|'_and'
op|','
name|'check2'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create an \'and_expr\'.\n\n        Join two checks by the \'and\' operator.\n        """'
newline|'\n'
nl|'\n'
name|'return'
op|'['
op|'('
string|"'and_expr'"
op|','
name|'AndCheck'
op|'('
op|'['
name|'check1'
op|','
name|'check2'
op|']'
op|')'
op|')'
op|']'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'reducer'
op|'('
string|"'and_expr'"
op|','
string|"'and'"
op|','
string|"'check'"
op|')'
newline|'\n'
DECL|member|_extend_and_expr
name|'def'
name|'_extend_and_expr'
op|'('
name|'self'
op|','
name|'and_expr'
op|','
name|'_and'
op|','
name|'check'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Extend an \'and_expr\' by adding one more check."""'
newline|'\n'
nl|'\n'
name|'return'
op|'['
op|'('
string|"'and_expr'"
op|','
name|'and_expr'
op|'.'
name|'add_check'
op|'('
name|'check'
op|')'
op|')'
op|']'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'reducer'
op|'('
string|"'check'"
op|','
string|"'or'"
op|','
string|"'check'"
op|')'
newline|'\n'
DECL|member|_make_or_expr
name|'def'
name|'_make_or_expr'
op|'('
name|'self'
op|','
name|'check1'
op|','
name|'_or'
op|','
name|'check2'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create an \'or_expr\'.\n\n        Join two checks by the \'or\' operator.\n        """'
newline|'\n'
nl|'\n'
name|'return'
op|'['
op|'('
string|"'or_expr'"
op|','
name|'OrCheck'
op|'('
op|'['
name|'check1'
op|','
name|'check2'
op|']'
op|')'
op|')'
op|']'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'reducer'
op|'('
string|"'or_expr'"
op|','
string|"'or'"
op|','
string|"'check'"
op|')'
newline|'\n'
DECL|member|_extend_or_expr
name|'def'
name|'_extend_or_expr'
op|'('
name|'self'
op|','
name|'or_expr'
op|','
name|'_or'
op|','
name|'check'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Extend an \'or_expr\' by adding one more check."""'
newline|'\n'
nl|'\n'
name|'return'
op|'['
op|'('
string|"'or_expr'"
op|','
name|'or_expr'
op|'.'
name|'add_check'
op|'('
name|'check'
op|')'
op|')'
op|']'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'reducer'
op|'('
string|"'not'"
op|','
string|"'check'"
op|')'
newline|'\n'
DECL|member|_make_not_expr
name|'def'
name|'_make_not_expr'
op|'('
name|'self'
op|','
name|'_not'
op|','
name|'check'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Invert the result of another check."""'
newline|'\n'
nl|'\n'
name|'return'
op|'['
op|'('
string|"'check'"
op|','
name|'NotCheck'
op|'('
name|'check'
op|')'
op|')'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_parse_text_rule
dedent|''
dedent|''
name|'def'
name|'_parse_text_rule'
op|'('
name|'rule'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Parses policy to the tree.\n\n    Translates a policy written in the policy language into a tree of\n    Check objects.\n    """'
newline|'\n'
nl|'\n'
comment|'# Empty rule means always accept'
nl|'\n'
name|'if'
name|'not'
name|'rule'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'TrueCheck'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Parse the token stream'
nl|'\n'
dedent|''
name|'state'
op|'='
name|'ParseState'
op|'('
op|')'
newline|'\n'
name|'for'
name|'tok'
op|','
name|'value'
name|'in'
name|'_parse_tokenize'
op|'('
name|'rule'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'state'
op|'.'
name|'shift'
op|'('
name|'tok'
op|','
name|'value'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'state'
op|'.'
name|'result'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
comment|"# Couldn't parse the rule"
nl|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|'"Failed to understand rule %s"'
op|')'
op|'%'
name|'rule'
op|')'
newline|'\n'
nl|'\n'
comment|'# Fail closed'
nl|'\n'
name|'return'
name|'FalseCheck'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|parse_rule
dedent|''
dedent|''
name|'def'
name|'parse_rule'
op|'('
name|'rule'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Parses a policy rule into a tree of Check objects."""'
newline|'\n'
nl|'\n'
comment|"# If the rule is a string, it's in the policy language"
nl|'\n'
name|'if'
name|'isinstance'
op|'('
name|'rule'
op|','
name|'six'
op|'.'
name|'string_types'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'_parse_text_rule'
op|'('
name|'rule'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'_parse_list_rule'
op|'('
name|'rule'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|register
dedent|''
name|'def'
name|'register'
op|'('
name|'name'
op|','
name|'func'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Register a function or Check class as a policy check.\n\n    :param name: Gives the name of the check type, e.g., \'rule\',\n                 \'role\', etc.  If name is None, a default check type\n                 will be registered.\n    :param func: If given, provides the function or class to register.\n                 If not given, returns a function taking one argument\n                 to specify the function or class to register,\n                 allowing use as a decorator.\n    """'
newline|'\n'
nl|'\n'
comment|'# Perform the actual decoration by registering the function or'
nl|'\n'
comment|'# class.  Returns the function or class for compliance with the'
nl|'\n'
comment|'# decorator interface.'
nl|'\n'
DECL|function|decorator
name|'def'
name|'decorator'
op|'('
name|'func'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'_checks'
op|'['
name|'name'
op|']'
op|'='
name|'func'
newline|'\n'
name|'return'
name|'func'
newline|'\n'
nl|'\n'
comment|'# If the function or class is given, do the registration'
nl|'\n'
dedent|''
name|'if'
name|'func'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'decorator'
op|'('
name|'func'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'decorator'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
op|'@'
name|'register'
op|'('
string|'"rule"'
op|')'
newline|'\n'
DECL|class|RuleCheck
name|'class'
name|'RuleCheck'
op|'('
name|'Check'
op|')'
op|':'
newline|'\n'
DECL|member|__call__
indent|'    '
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'creds'
op|','
name|'enforcer'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Recursively checks credentials based on the defined rules."""'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'enforcer'
op|'.'
name|'rules'
op|'['
name|'self'
op|'.'
name|'match'
op|']'
op|'('
name|'target'
op|','
name|'creds'
op|','
name|'enforcer'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
comment|"# We don't have any matching rule; fail closed"
nl|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
op|'@'
name|'register'
op|'('
string|'"role"'
op|')'
newline|'\n'
DECL|class|RoleCheck
name|'class'
name|'RoleCheck'
op|'('
name|'Check'
op|')'
op|':'
newline|'\n'
DECL|member|__call__
indent|'    '
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'creds'
op|','
name|'enforcer'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check that there is a matching role in the cred dict."""'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'match'
op|'.'
name|'lower'
op|'('
op|')'
name|'in'
op|'['
name|'x'
op|'.'
name|'lower'
op|'('
op|')'
name|'for'
name|'x'
name|'in'
name|'creds'
op|'['
string|"'roles'"
op|']'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'register'
op|'('
string|"'http'"
op|')'
newline|'\n'
DECL|class|HttpCheck
name|'class'
name|'HttpCheck'
op|'('
name|'Check'
op|')'
op|':'
newline|'\n'
DECL|member|__call__
indent|'    '
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'creds'
op|','
name|'enforcer'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check http: rules by calling to a remote server.\n\n        This example implementation simply verifies that the response\n        is exactly \'True\'.\n        """'
newline|'\n'
nl|'\n'
name|'url'
op|'='
op|'('
string|"'http:'"
op|'+'
name|'self'
op|'.'
name|'match'
op|')'
op|'%'
name|'target'
newline|'\n'
nl|'\n'
comment|'# Convert instances of object() in target temporarily to'
nl|'\n'
comment|'# empty dict to avoid circular reference detection'
nl|'\n'
comment|'# errors in jsonutils.dumps().'
nl|'\n'
name|'temp_target'
op|'='
name|'copy'
op|'.'
name|'deepcopy'
op|'('
name|'target'
op|')'
newline|'\n'
name|'for'
name|'key'
name|'in'
name|'target'
op|'.'
name|'keys'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'element'
op|'='
name|'target'
op|'.'
name|'get'
op|'('
name|'key'
op|')'
newline|'\n'
name|'if'
name|'type'
op|'('
name|'element'
op|')'
name|'is'
name|'object'
op|':'
newline|'\n'
indent|'                '
name|'temp_target'
op|'['
name|'key'
op|']'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'data'
op|'='
op|'{'
string|"'target'"
op|':'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
name|'temp_target'
op|')'
op|','
nl|'\n'
string|"'credentials'"
op|':'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
name|'creds'
op|')'
op|'}'
newline|'\n'
name|'post_data'
op|'='
name|'urlparse'
op|'.'
name|'urlencode'
op|'('
name|'data'
op|')'
newline|'\n'
name|'f'
op|'='
name|'urlrequest'
op|'.'
name|'urlopen'
op|'('
name|'url'
op|','
name|'post_data'
op|')'
newline|'\n'
name|'return'
name|'f'
op|'.'
name|'read'
op|'('
op|')'
op|'=='
string|'"True"'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'register'
op|'('
name|'None'
op|')'
newline|'\n'
DECL|class|GenericCheck
name|'class'
name|'GenericCheck'
op|'('
name|'Check'
op|')'
op|':'
newline|'\n'
DECL|member|__call__
indent|'    '
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'creds'
op|','
name|'enforcer'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check an individual match.\n\n        Matches look like:\n\n            tenant:%(tenant_id)s\n            role:compute:admin\n            True:%(user.enabled)s\n            \'Member\':%(role.name)s\n        """'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'match'
op|'='
name|'self'
op|'.'
name|'match'
op|'%'
name|'target'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
comment|'# While doing GenericCheck if key not'
nl|'\n'
comment|'# present in Target return false'
nl|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
comment|'# Try to interpret self.kind as a literal'
nl|'\n'
indent|'            '
name|'leftval'
op|'='
name|'ast'
op|'.'
name|'literal_eval'
op|'('
name|'self'
op|'.'
name|'kind'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'kind_parts'
op|'='
name|'self'
op|'.'
name|'kind'
op|'.'
name|'split'
op|'('
string|"'.'"
op|')'
newline|'\n'
name|'leftval'
op|'='
name|'creds'
newline|'\n'
name|'for'
name|'kind_part'
name|'in'
name|'kind_parts'
op|':'
newline|'\n'
indent|'                    '
name|'leftval'
op|'='
name|'leftval'
op|'['
name|'kind_part'
op|']'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'False'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'match'
op|'=='
name|'six'
op|'.'
name|'text_type'
op|'('
name|'leftval'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
