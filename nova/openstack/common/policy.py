begin_unit
comment|'# vim: tabstop=4 shiftwidth=4 softtabstop=4'
nl|'\n'
nl|'\n'
comment|'# Copyright (c) 2012 OpenStack Foundation.'
nl|'\n'
comment|'# All Rights Reserved.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
nl|'\n'
string|'"""\nCommon Policy Engine Implementation\n\nPolicies can be expressed in one of two forms: A list of lists, or a\nstring written in the new policy language.\n\nIn the list-of-lists representation, each check inside the innermost\nlist is combined as with an "and" conjunction--for that check to pass,\nall the specified checks must pass.  These innermost lists are then\ncombined as with an "or" conjunction.  This is the original way of\nexpressing policies, but there now exists a new way: the policy\nlanguage.\n\nIn the policy language, each check is specified the same way as in the\nlist-of-lists representation: a simple "a:b" pair that is matched to\nthe correct code to perform that check.  However, conjunction\noperators are available, allowing for more expressiveness in crafting\npolicies.\n\nAs an example, take the following rule, expressed in the list-of-lists\nrepresentation::\n\n    [["role:admin"], ["project_id:%(project_id)s", "role:projectadmin"]]\n\nIn the policy language, this becomes::\n\n    role:admin or (project_id:%(project_id)s and role:projectadmin)\n\nThe policy language also has the "not" operator, allowing a richer\npolicy rule::\n\n    project_id:%(project_id)s and not role:dunce\n\nFinally, two special policy checks should be mentioned; the policy\ncheck "@" will always accept an access, and the policy check "!" will\nalways reject an access.  (Note that if a rule is either the empty\nlist ("[]") or the empty string, this is equivalent to the "@" policy\ncheck.)  Of these, the "!" policy check is probably the most useful,\nas it allows particular rules to be explicitly disabled.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'abc'
newline|'\n'
name|'import'
name|'re'
newline|'\n'
name|'import'
name|'urllib'
newline|'\n'
nl|'\n'
name|'import'
name|'urllib2'
newline|'\n'
nl|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
op|'.'
name|'gettextutils'
name|'import'
name|'_'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'jsonutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'log'
name|'as'
name|'logging'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|LOG
name|'LOG'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|_rules
name|'_rules'
op|'='
name|'None'
newline|'\n'
DECL|variable|_checks
name|'_checks'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Rules
name|'class'
name|'Rules'
op|'('
name|'dict'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A store for rules.  Handles the default_rule setting directly.\n    """'
newline|'\n'
nl|'\n'
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|load_json
name|'def'
name|'load_json'
op|'('
name|'cls'
op|','
name|'data'
op|','
name|'default_rule'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Allow loading of JSON rule data.\n        """'
newline|'\n'
nl|'\n'
comment|'# Suck in the JSON data and parse the rules'
nl|'\n'
name|'rules'
op|'='
name|'dict'
op|'('
op|'('
name|'k'
op|','
name|'parse_rule'
op|'('
name|'v'
op|')'
op|')'
name|'for'
name|'k'
op|','
name|'v'
name|'in'
nl|'\n'
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'data'
op|')'
op|'.'
name|'items'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'cls'
op|'('
name|'rules'
op|','
name|'default_rule'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__init__
dedent|''
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'rules'
op|'='
name|'None'
op|','
name|'default_rule'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Initialize the Rules store."""'
newline|'\n'
nl|'\n'
name|'super'
op|'('
name|'Rules'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'rules'
name|'or'
op|'{'
op|'}'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'default_rule'
op|'='
name|'default_rule'
newline|'\n'
nl|'\n'
DECL|member|__missing__
dedent|''
name|'def'
name|'__missing__'
op|'('
name|'self'
op|','
name|'key'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Implements the default rule handling."""'
newline|'\n'
nl|'\n'
comment|"# If the default rule isn't actually defined, do something"
nl|'\n'
comment|'# reasonably intelligent'
nl|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'default_rule'
name|'or'
name|'self'
op|'.'
name|'default_rule'
name|'not'
name|'in'
name|'self'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'KeyError'
op|'('
name|'key'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'self'
op|'['
name|'self'
op|'.'
name|'default_rule'
op|']'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Dumps a string representation of the rules."""'
newline|'\n'
nl|'\n'
comment|'# Start by building the canonical strings for the rules'
nl|'\n'
name|'out_rules'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'key'
op|','
name|'value'
name|'in'
name|'self'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# Use empty string for singleton TrueCheck instances'
nl|'\n'
indent|'            '
name|'if'
name|'isinstance'
op|'('
name|'value'
op|','
name|'TrueCheck'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'out_rules'
op|'['
name|'key'
op|']'
op|'='
string|"''"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'out_rules'
op|'['
name|'key'
op|']'
op|'='
name|'str'
op|'('
name|'value'
op|')'
newline|'\n'
nl|'\n'
comment|'# Dump a pretty-printed JSON representation'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
name|'out_rules'
op|','
name|'indent'
op|'='
number|'4'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# Really have to figure out a way to deprecate this'
nl|'\n'
DECL|function|set_rules
dedent|''
dedent|''
name|'def'
name|'set_rules'
op|'('
name|'rules'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Set the rules in use for policy checks."""'
newline|'\n'
nl|'\n'
name|'global'
name|'_rules'
newline|'\n'
nl|'\n'
name|'_rules'
op|'='
name|'rules'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# Ditto'
nl|'\n'
DECL|function|reset
dedent|''
name|'def'
name|'reset'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Clear the rules used for policy checks."""'
newline|'\n'
nl|'\n'
name|'global'
name|'_rules'
newline|'\n'
nl|'\n'
name|'_rules'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|check
dedent|''
name|'def'
name|'check'
op|'('
name|'rule'
op|','
name|'target'
op|','
name|'creds'
op|','
name|'exc'
op|'='
name|'None'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Checks authorization of a rule against the target and credentials.\n\n    :param rule: The rule to evaluate.\n    :param target: As much information about the object being operated\n                   on as possible, as a dictionary.\n    :param creds: As much information about the user performing the\n                  action as possible, as a dictionary.\n    :param exc: Class of the exception to raise if the check fails.\n                Any remaining arguments passed to check() (both\n                positional and keyword arguments) will be passed to\n                the exception class.  If exc is not provided, returns\n                False.\n\n    :return: Returns False if the policy does not allow the action and\n             exc is not provided; otherwise, returns a value that\n             evaluates to True.  Note: for rules using the "case"\n             expression, this True value will be the specified string\n             from the expression.\n    """'
newline|'\n'
nl|'\n'
comment|'# Allow the rule to be a Check tree'
nl|'\n'
name|'if'
name|'isinstance'
op|'('
name|'rule'
op|','
name|'BaseCheck'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'result'
op|'='
name|'rule'
op|'('
name|'target'
op|','
name|'creds'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'not'
name|'_rules'
op|':'
newline|'\n'
comment|"# No rules to reference means we're going to fail closed"
nl|'\n'
indent|'        '
name|'result'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
comment|'# Evaluate the rule'
nl|'\n'
indent|'            '
name|'result'
op|'='
name|'_rules'
op|'['
name|'rule'
op|']'
op|'('
name|'target'
op|','
name|'creds'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
comment|"# If the rule doesn't exist, fail closed"
nl|'\n'
indent|'            '
name|'result'
op|'='
name|'False'
newline|'\n'
nl|'\n'
comment|'# If it is False, raise the exception if requested'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'exc'
name|'and'
name|'result'
name|'is'
name|'False'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exc'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|BaseCheck
dedent|''
name|'class'
name|'BaseCheck'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Abstract base class for Check classes.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|__metaclass__
name|'__metaclass__'
op|'='
name|'abc'
op|'.'
name|'ABCMeta'
newline|'\n'
nl|'\n'
op|'@'
name|'abc'
op|'.'
name|'abstractmethod'
newline|'\n'
DECL|member|__str__
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Retrieve a string representation of the Check tree rooted at\n        this node.\n        """'
newline|'\n'
nl|'\n'
name|'pass'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'abc'
op|'.'
name|'abstractmethod'
newline|'\n'
DECL|member|__call__
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'cred'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Perform the check.  Returns False to reject the access or a\n        true value (not necessary True) to accept the access.\n        """'
newline|'\n'
nl|'\n'
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|FalseCheck
dedent|''
dedent|''
name|'class'
name|'FalseCheck'
op|'('
name|'BaseCheck'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A policy check that always returns False (disallow).\n    """'
newline|'\n'
nl|'\n'
DECL|member|__str__
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a string representation of this check."""'
newline|'\n'
nl|'\n'
name|'return'
string|'"!"'
newline|'\n'
nl|'\n'
DECL|member|__call__
dedent|''
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'cred'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check the policy."""'
newline|'\n'
nl|'\n'
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|TrueCheck
dedent|''
dedent|''
name|'class'
name|'TrueCheck'
op|'('
name|'BaseCheck'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A policy check that always returns True (allow).\n    """'
newline|'\n'
nl|'\n'
DECL|member|__str__
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a string representation of this check."""'
newline|'\n'
nl|'\n'
name|'return'
string|'"@"'
newline|'\n'
nl|'\n'
DECL|member|__call__
dedent|''
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'cred'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check the policy."""'
newline|'\n'
nl|'\n'
name|'return'
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Check
dedent|''
dedent|''
name|'class'
name|'Check'
op|'('
name|'BaseCheck'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A base class to allow for user-defined policy checks.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'kind'
op|','
name|'match'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        :param kind: The kind of the check, i.e., the field before the\n                     \':\'.\n        :param match: The match of the check, i.e., the field after\n                      the \':\'.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'kind'
op|'='
name|'kind'
newline|'\n'
name|'self'
op|'.'
name|'match'
op|'='
name|'match'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a string representation of this check."""'
newline|'\n'
nl|'\n'
name|'return'
string|'"%s:%s"'
op|'%'
op|'('
name|'self'
op|'.'
name|'kind'
op|','
name|'self'
op|'.'
name|'match'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|NotCheck
dedent|''
dedent|''
name|'class'
name|'NotCheck'
op|'('
name|'BaseCheck'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A policy check that inverts the result of another policy check.\n    Implements the "not" operator.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'rule'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Initialize the \'not\' check.\n\n        :param rule: The rule to negate.  Must be a Check.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'rule'
op|'='
name|'rule'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a string representation of this check."""'
newline|'\n'
nl|'\n'
name|'return'
string|'"not %s"'
op|'%'
name|'self'
op|'.'
name|'rule'
newline|'\n'
nl|'\n'
DECL|member|__call__
dedent|''
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'cred'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check the policy.  Returns the logical inverse of the wrapped\n        check.\n        """'
newline|'\n'
nl|'\n'
name|'return'
name|'not'
name|'self'
op|'.'
name|'rule'
op|'('
name|'target'
op|','
name|'cred'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|AndCheck
dedent|''
dedent|''
name|'class'
name|'AndCheck'
op|'('
name|'BaseCheck'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A policy check that requires that a list of other checks all\n    return True.  Implements the "and" operator.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'rules'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Initialize the \'and\' check.\n\n        :param rules: A list of rules that will be tested.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'rules'
op|'='
name|'rules'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a string representation of this check."""'
newline|'\n'
nl|'\n'
name|'return'
string|'"(%s)"'
op|'%'
string|"' and '"
op|'.'
name|'join'
op|'('
name|'str'
op|'('
name|'r'
op|')'
name|'for'
name|'r'
name|'in'
name|'self'
op|'.'
name|'rules'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__call__
dedent|''
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'cred'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check the policy.  Requires that all rules accept in order to\n        return True.\n        """'
newline|'\n'
nl|'\n'
name|'for'
name|'rule'
name|'in'
name|'self'
op|'.'
name|'rules'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'rule'
op|'('
name|'target'
op|','
name|'cred'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'True'
newline|'\n'
nl|'\n'
DECL|member|add_check
dedent|''
name|'def'
name|'add_check'
op|'('
name|'self'
op|','
name|'rule'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Allows addition of another rule to the list of rules that will\n        be tested.  Returns the AndCheck object for convenience.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'rules'
op|'.'
name|'append'
op|'('
name|'rule'
op|')'
newline|'\n'
name|'return'
name|'self'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|OrCheck
dedent|''
dedent|''
name|'class'
name|'OrCheck'
op|'('
name|'BaseCheck'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    A policy check that requires that at least one of a list of other\n    checks returns True.  Implements the "or" operator.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'rules'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Initialize the \'or\' check.\n\n        :param rules: A list of rules that will be tested.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'rules'
op|'='
name|'rules'
newline|'\n'
nl|'\n'
DECL|member|__str__
dedent|''
name|'def'
name|'__str__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return a string representation of this check."""'
newline|'\n'
nl|'\n'
name|'return'
string|'"(%s)"'
op|'%'
string|"' or '"
op|'.'
name|'join'
op|'('
name|'str'
op|'('
name|'r'
op|')'
name|'for'
name|'r'
name|'in'
name|'self'
op|'.'
name|'rules'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__call__
dedent|''
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'cred'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check the policy.  Requires that at least one rule accept in\n        order to return True.\n        """'
newline|'\n'
nl|'\n'
name|'for'
name|'rule'
name|'in'
name|'self'
op|'.'
name|'rules'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'rule'
op|'('
name|'target'
op|','
name|'cred'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|add_check
dedent|''
name|'def'
name|'add_check'
op|'('
name|'self'
op|','
name|'rule'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Allows addition of another rule to the list of rules that will\n        be tested.  Returns the OrCheck object for convenience.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'rules'
op|'.'
name|'append'
op|'('
name|'rule'
op|')'
newline|'\n'
name|'return'
name|'self'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_parse_check
dedent|''
dedent|''
name|'def'
name|'_parse_check'
op|'('
name|'rule'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Parse a single base check rule into an appropriate Check object.\n    """'
newline|'\n'
nl|'\n'
comment|'# Handle the special checks'
nl|'\n'
name|'if'
name|'rule'
op|'=='
string|"'!'"
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'FalseCheck'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'rule'
op|'=='
string|"'@'"
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'TrueCheck'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'kind'
op|','
name|'match'
op|'='
name|'rule'
op|'.'
name|'split'
op|'('
string|"':'"
op|','
number|'1'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_'
op|'('
string|'"Failed to understand rule %(rule)s"'
op|')'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
comment|"# If the rule is invalid, we'll fail closed"
nl|'\n'
name|'return'
name|'FalseCheck'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Find what implements the check'
nl|'\n'
dedent|''
name|'if'
name|'kind'
name|'in'
name|'_checks'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'_checks'
op|'['
name|'kind'
op|']'
op|'('
name|'kind'
op|','
name|'match'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'None'
name|'in'
name|'_checks'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'_checks'
op|'['
name|'None'
op|']'
op|'('
name|'kind'
op|','
name|'match'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|'"No handler for matches of kind %s"'
op|')'
op|'%'
name|'kind'
op|')'
newline|'\n'
name|'return'
name|'FalseCheck'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_parse_list_rule
dedent|''
dedent|''
name|'def'
name|'_parse_list_rule'
op|'('
name|'rule'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Provided for backwards compatibility.  Translates the old\n    list-of-lists syntax into a tree of Check objects.\n    """'
newline|'\n'
nl|'\n'
comment|'# Empty rule defaults to True'
nl|'\n'
name|'if'
name|'not'
name|'rule'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'TrueCheck'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Outer list is joined by "or"; inner list by "and"'
nl|'\n'
dedent|''
name|'or_list'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'inner_rule'
name|'in'
name|'rule'
op|':'
newline|'\n'
comment|'# Elide empty inner lists'
nl|'\n'
indent|'        '
name|'if'
name|'not'
name|'inner_rule'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
nl|'\n'
comment|'# Handle bare strings'
nl|'\n'
dedent|''
name|'if'
name|'isinstance'
op|'('
name|'inner_rule'
op|','
name|'basestring'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'inner_rule'
op|'='
op|'['
name|'inner_rule'
op|']'
newline|'\n'
nl|'\n'
comment|'# Parse the inner rules into Check objects'
nl|'\n'
dedent|''
name|'and_list'
op|'='
op|'['
name|'_parse_check'
op|'('
name|'r'
op|')'
name|'for'
name|'r'
name|'in'
name|'inner_rule'
op|']'
newline|'\n'
nl|'\n'
comment|'# Append the appropriate check to the or_list'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'and_list'
op|')'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'or_list'
op|'.'
name|'append'
op|'('
name|'and_list'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'or_list'
op|'.'
name|'append'
op|'('
name|'AndCheck'
op|'('
name|'and_list'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# If we have only one check, omit the "or"'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'len'
op|'('
name|'or_list'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'FalseCheck'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'len'
op|'('
name|'or_list'
op|')'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'or_list'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'OrCheck'
op|'('
name|'or_list'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# Used for tokenizing the policy language'
nl|'\n'
DECL|variable|_tokenize_re
dedent|''
name|'_tokenize_re'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'\\s+'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_parse_tokenize
name|'def'
name|'_parse_tokenize'
op|'('
name|'rule'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Tokenizer for the policy language.\n\n    Most of the single-character tokens are specified in the\n    _tokenize_re; however, parentheses need to be handled specially,\n    because they can appear inside a check string.  Thankfully, those\n    parentheses that appear inside a check string can never occur at\n    the very beginning or end ("%(variable)s" is the correct syntax).\n    """'
newline|'\n'
nl|'\n'
name|'for'
name|'tok'
name|'in'
name|'_tokenize_re'
op|'.'
name|'split'
op|'('
name|'rule'
op|')'
op|':'
newline|'\n'
comment|'# Skip empty tokens'
nl|'\n'
indent|'        '
name|'if'
name|'not'
name|'tok'
name|'or'
name|'tok'
op|'.'
name|'isspace'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
nl|'\n'
comment|'# Handle leading parens on the token'
nl|'\n'
dedent|''
name|'clean'
op|'='
name|'tok'
op|'.'
name|'lstrip'
op|'('
string|"'('"
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'len'
op|'('
name|'tok'
op|')'
op|'-'
name|'len'
op|'('
name|'clean'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'yield'
string|"'('"
op|','
string|"'('"
newline|'\n'
nl|'\n'
comment|'# If it was only parentheses, continue'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'clean'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'tok'
op|'='
name|'clean'
newline|'\n'
nl|'\n'
comment|'# Handle trailing parens on the token'
nl|'\n'
dedent|''
name|'clean'
op|'='
name|'tok'
op|'.'
name|'rstrip'
op|'('
string|"')'"
op|')'
newline|'\n'
name|'trail'
op|'='
name|'len'
op|'('
name|'tok'
op|')'
op|'-'
name|'len'
op|'('
name|'clean'
op|')'
newline|'\n'
nl|'\n'
comment|'# Yield the cleaned token'
nl|'\n'
name|'lowered'
op|'='
name|'clean'
op|'.'
name|'lower'
op|'('
op|')'
newline|'\n'
name|'if'
name|'lowered'
name|'in'
op|'('
string|"'and'"
op|','
string|"'or'"
op|','
string|"'not'"
op|')'
op|':'
newline|'\n'
comment|'# Special tokens'
nl|'\n'
indent|'            '
name|'yield'
name|'lowered'
op|','
name|'clean'
newline|'\n'
dedent|''
name|'elif'
name|'clean'
op|':'
newline|'\n'
comment|"# Not a special token, but not composed solely of ')'"
nl|'\n'
indent|'            '
name|'if'
name|'len'
op|'('
name|'tok'
op|')'
op|'>='
number|'2'
name|'and'
op|'('
op|'('
name|'tok'
op|'['
number|'0'
op|']'
op|','
name|'tok'
op|'['
op|'-'
number|'1'
op|']'
op|')'
name|'in'
nl|'\n'
op|'['
op|'('
string|'\'"\''
op|','
string|'\'"\''
op|')'
op|','
op|'('
string|'"\'"'
op|','
string|'"\'"'
op|')'
op|']'
op|')'
op|':'
newline|'\n'
comment|"# It's a quoted string"
nl|'\n'
indent|'                '
name|'yield'
string|"'string'"
op|','
name|'tok'
op|'['
number|'1'
op|':'
op|'-'
number|'1'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'yield'
string|"'check'"
op|','
name|'_parse_check'
op|'('
name|'clean'
op|')'
newline|'\n'
nl|'\n'
comment|'# Yield the trailing parens'
nl|'\n'
dedent|''
dedent|''
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'trail'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'yield'
string|"')'"
op|','
string|"')'"
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ParseStateMeta
dedent|''
dedent|''
dedent|''
name|'class'
name|'ParseStateMeta'
op|'('
name|'type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Metaclass for the ParseState class.  Facilitates identifying\n    reduction methods.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__new__
name|'def'
name|'__new__'
op|'('
name|'mcs'
op|','
name|'name'
op|','
name|'bases'
op|','
name|'cls_dict'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create the class.  Injects the \'reducers\' list, a list of\n        tuples matching token sequences to the names of the\n        corresponding reduction methods.\n        """'
newline|'\n'
nl|'\n'
name|'reducers'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'key'
op|','
name|'value'
name|'in'
name|'cls_dict'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'hasattr'
op|'('
name|'value'
op|','
string|"'reducers'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'for'
name|'reduction'
name|'in'
name|'value'
op|'.'
name|'reducers'
op|':'
newline|'\n'
indent|'                '
name|'reducers'
op|'.'
name|'append'
op|'('
op|'('
name|'reduction'
op|','
name|'key'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'cls_dict'
op|'['
string|"'reducers'"
op|']'
op|'='
name|'reducers'
newline|'\n'
nl|'\n'
name|'return'
name|'super'
op|'('
name|'ParseStateMeta'
op|','
name|'mcs'
op|')'
op|'.'
name|'__new__'
op|'('
name|'mcs'
op|','
name|'name'
op|','
name|'bases'
op|','
name|'cls_dict'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|reducer
dedent|''
dedent|''
name|'def'
name|'reducer'
op|'('
op|'*'
name|'tokens'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Decorator for reduction methods.  Arguments are a sequence of\n    tokens, in order, which should trigger running this reduction\n    method.\n    """'
newline|'\n'
nl|'\n'
DECL|function|decorator
name|'def'
name|'decorator'
op|'('
name|'func'
op|')'
op|':'
newline|'\n'
comment|'# Make sure we have a list of reducer sequences'
nl|'\n'
indent|'        '
name|'if'
name|'not'
name|'hasattr'
op|'('
name|'func'
op|','
string|"'reducers'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'func'
op|'.'
name|'reducers'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
comment|'# Add the tokens to the list of reducer sequences'
nl|'\n'
dedent|''
name|'func'
op|'.'
name|'reducers'
op|'.'
name|'append'
op|'('
name|'list'
op|'('
name|'tokens'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'func'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'decorator'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ParseState
dedent|''
name|'class'
name|'ParseState'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Implement the core of parsing the policy language.  Uses a greedy\n    reduction algorithm to reduce a sequence of tokens into a single\n    terminal, the value of which will be the root of the Check tree.\n\n    Note: error reporting is rather lacking.  The best we can get with\n    this parser formulation is an overall "parse failed" error.\n    Fortunately, the policy language is simple enough that this\n    shouldn\'t be that big a problem.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|__metaclass__
name|'__metaclass__'
op|'='
name|'ParseStateMeta'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Initialize the ParseState."""'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'tokens'
op|'='
op|'['
op|']'
newline|'\n'
name|'self'
op|'.'
name|'values'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|reduce
dedent|''
name|'def'
name|'reduce'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Perform a greedy reduction of the token stream.  If a reducer\n        method matches, it will be executed, then the reduce() method\n        will be called recursively to search for any more possible\n        reductions.\n        """'
newline|'\n'
nl|'\n'
name|'for'
name|'reduction'
op|','
name|'methname'
name|'in'
name|'self'
op|'.'
name|'reducers'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
name|'len'
op|'('
name|'self'
op|'.'
name|'tokens'
op|')'
op|'>='
name|'len'
op|'('
name|'reduction'
op|')'
name|'and'
nl|'\n'
name|'self'
op|'.'
name|'tokens'
op|'['
op|'-'
name|'len'
op|'('
name|'reduction'
op|')'
op|':'
op|']'
op|'=='
name|'reduction'
op|')'
op|':'
newline|'\n'
comment|'# Get the reduction method'
nl|'\n'
indent|'                '
name|'meth'
op|'='
name|'getattr'
op|'('
name|'self'
op|','
name|'methname'
op|')'
newline|'\n'
nl|'\n'
comment|'# Reduce the token stream'
nl|'\n'
name|'results'
op|'='
name|'meth'
op|'('
op|'*'
name|'self'
op|'.'
name|'values'
op|'['
op|'-'
name|'len'
op|'('
name|'reduction'
op|')'
op|':'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Update the tokens and values'
nl|'\n'
name|'self'
op|'.'
name|'tokens'
op|'['
op|'-'
name|'len'
op|'('
name|'reduction'
op|')'
op|':'
op|']'
op|'='
op|'['
name|'r'
op|'['
number|'0'
op|']'
name|'for'
name|'r'
name|'in'
name|'results'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'values'
op|'['
op|'-'
name|'len'
op|'('
name|'reduction'
op|')'
op|':'
op|']'
op|'='
op|'['
name|'r'
op|'['
number|'1'
op|']'
name|'for'
name|'r'
name|'in'
name|'results'
op|']'
newline|'\n'
nl|'\n'
comment|'# Check for any more reductions'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'reduce'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|shift
dedent|''
dedent|''
dedent|''
name|'def'
name|'shift'
op|'('
name|'self'
op|','
name|'tok'
op|','
name|'value'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Adds one more token to the state.  Calls reduce()."""'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'tokens'
op|'.'
name|'append'
op|'('
name|'tok'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'values'
op|'.'
name|'append'
op|'('
name|'value'
op|')'
newline|'\n'
nl|'\n'
comment|'# Do a greedy reduce...'
nl|'\n'
name|'self'
op|'.'
name|'reduce'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|result
name|'def'
name|'result'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Obtain the final result of the parse.  Raises ValueError if\n        the parse failed to reduce to a single result.\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'self'
op|'.'
name|'values'
op|')'
op|'!='
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
string|'"Could not parse rule"'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'values'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'reducer'
op|'('
string|"'('"
op|','
string|"'check'"
op|','
string|"')'"
op|')'
newline|'\n'
op|'@'
name|'reducer'
op|'('
string|"'('"
op|','
string|"'and_expr'"
op|','
string|"')'"
op|')'
newline|'\n'
op|'@'
name|'reducer'
op|'('
string|"'('"
op|','
string|"'or_expr'"
op|','
string|"')'"
op|')'
newline|'\n'
DECL|member|_wrap_check
name|'def'
name|'_wrap_check'
op|'('
name|'self'
op|','
name|'_p1'
op|','
name|'check'
op|','
name|'_p2'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Turn parenthesized expressions into a \'check\' token."""'
newline|'\n'
nl|'\n'
name|'return'
op|'['
op|'('
string|"'check'"
op|','
name|'check'
op|')'
op|']'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'reducer'
op|'('
string|"'check'"
op|','
string|"'and'"
op|','
string|"'check'"
op|')'
newline|'\n'
DECL|member|_make_and_expr
name|'def'
name|'_make_and_expr'
op|'('
name|'self'
op|','
name|'check1'
op|','
name|'_and'
op|','
name|'check2'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create an \'and_expr\' from two checks joined by the \'and\'\n        operator.\n        """'
newline|'\n'
nl|'\n'
name|'return'
op|'['
op|'('
string|"'and_expr'"
op|','
name|'AndCheck'
op|'('
op|'['
name|'check1'
op|','
name|'check2'
op|']'
op|')'
op|')'
op|']'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'reducer'
op|'('
string|"'and_expr'"
op|','
string|"'and'"
op|','
string|"'check'"
op|')'
newline|'\n'
DECL|member|_extend_and_expr
name|'def'
name|'_extend_and_expr'
op|'('
name|'self'
op|','
name|'and_expr'
op|','
name|'_and'
op|','
name|'check'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Extend an \'and_expr\' by adding one more check.\n        """'
newline|'\n'
nl|'\n'
name|'return'
op|'['
op|'('
string|"'and_expr'"
op|','
name|'and_expr'
op|'.'
name|'add_check'
op|'('
name|'check'
op|')'
op|')'
op|']'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'reducer'
op|'('
string|"'check'"
op|','
string|"'or'"
op|','
string|"'check'"
op|')'
newline|'\n'
DECL|member|_make_or_expr
name|'def'
name|'_make_or_expr'
op|'('
name|'self'
op|','
name|'check1'
op|','
name|'_or'
op|','
name|'check2'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Create an \'or_expr\' from two checks joined by the \'or\'\n        operator.\n        """'
newline|'\n'
nl|'\n'
name|'return'
op|'['
op|'('
string|"'or_expr'"
op|','
name|'OrCheck'
op|'('
op|'['
name|'check1'
op|','
name|'check2'
op|']'
op|')'
op|')'
op|']'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'reducer'
op|'('
string|"'or_expr'"
op|','
string|"'or'"
op|','
string|"'check'"
op|')'
newline|'\n'
DECL|member|_extend_or_expr
name|'def'
name|'_extend_or_expr'
op|'('
name|'self'
op|','
name|'or_expr'
op|','
name|'_or'
op|','
name|'check'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Extend an \'or_expr\' by adding one more check.\n        """'
newline|'\n'
nl|'\n'
name|'return'
op|'['
op|'('
string|"'or_expr'"
op|','
name|'or_expr'
op|'.'
name|'add_check'
op|'('
name|'check'
op|')'
op|')'
op|']'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'reducer'
op|'('
string|"'not'"
op|','
string|"'check'"
op|')'
newline|'\n'
DECL|member|_make_not_expr
name|'def'
name|'_make_not_expr'
op|'('
name|'self'
op|','
name|'_not'
op|','
name|'check'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Invert the result of another check."""'
newline|'\n'
nl|'\n'
name|'return'
op|'['
op|'('
string|"'check'"
op|','
name|'NotCheck'
op|'('
name|'check'
op|')'
op|')'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_parse_text_rule
dedent|''
dedent|''
name|'def'
name|'_parse_text_rule'
op|'('
name|'rule'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Translates a policy written in the policy language into a tree of\n    Check objects.\n    """'
newline|'\n'
nl|'\n'
comment|'# Empty rule means always accept'
nl|'\n'
name|'if'
name|'not'
name|'rule'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'TrueCheck'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Parse the token stream'
nl|'\n'
dedent|''
name|'state'
op|'='
name|'ParseState'
op|'('
op|')'
newline|'\n'
name|'for'
name|'tok'
op|','
name|'value'
name|'in'
name|'_parse_tokenize'
op|'('
name|'rule'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'state'
op|'.'
name|'shift'
op|'('
name|'tok'
op|','
name|'value'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'state'
op|'.'
name|'result'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
comment|"# Couldn't parse the rule"
nl|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_'
op|'('
string|'"Failed to understand rule %(rule)r"'
op|')'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Fail closed'
nl|'\n'
name|'return'
name|'FalseCheck'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|parse_rule
dedent|''
dedent|''
name|'def'
name|'parse_rule'
op|'('
name|'rule'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Parses a policy rule into a tree of Check objects.\n    """'
newline|'\n'
nl|'\n'
comment|"# If the rule is a string, it's in the policy language"
nl|'\n'
name|'if'
name|'isinstance'
op|'('
name|'rule'
op|','
name|'basestring'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'_parse_text_rule'
op|'('
name|'rule'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'_parse_list_rule'
op|'('
name|'rule'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|register
dedent|''
name|'def'
name|'register'
op|'('
name|'name'
op|','
name|'func'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Register a function or Check class as a policy check.\n\n    :param name: Gives the name of the check type, e.g., \'rule\',\n                 \'role\', etc.  If name is None, a default check type\n                 will be registered.\n    :param func: If given, provides the function or class to register.\n                 If not given, returns a function taking one argument\n                 to specify the function or class to register,\n                 allowing use as a decorator.\n    """'
newline|'\n'
nl|'\n'
comment|'# Perform the actual decoration by registering the function or'
nl|'\n'
comment|'# class.  Returns the function or class for compliance with the'
nl|'\n'
comment|'# decorator interface.'
nl|'\n'
DECL|function|decorator
name|'def'
name|'decorator'
op|'('
name|'func'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'_checks'
op|'['
name|'name'
op|']'
op|'='
name|'func'
newline|'\n'
name|'return'
name|'func'
newline|'\n'
nl|'\n'
comment|'# If the function or class is given, do the registration'
nl|'\n'
dedent|''
name|'if'
name|'func'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'decorator'
op|'('
name|'func'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'decorator'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
op|'@'
name|'register'
op|'('
string|'"rule"'
op|')'
newline|'\n'
DECL|class|RuleCheck
name|'class'
name|'RuleCheck'
op|'('
name|'Check'
op|')'
op|':'
newline|'\n'
DECL|member|__call__
indent|'    '
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'creds'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Recursively checks credentials based on the defined rules.\n        """'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'_rules'
op|'['
name|'self'
op|'.'
name|'match'
op|']'
op|'('
name|'target'
op|','
name|'creds'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
comment|"# We don't have any matching rule; fail closed"
nl|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
op|'@'
name|'register'
op|'('
string|'"role"'
op|')'
newline|'\n'
DECL|class|RoleCheck
name|'class'
name|'RoleCheck'
op|'('
name|'Check'
op|')'
op|':'
newline|'\n'
DECL|member|__call__
indent|'    '
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'creds'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check that there is a matching role in the cred dict."""'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'match'
op|'.'
name|'lower'
op|'('
op|')'
name|'in'
op|'['
name|'x'
op|'.'
name|'lower'
op|'('
op|')'
name|'for'
name|'x'
name|'in'
name|'creds'
op|'['
string|"'roles'"
op|']'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'register'
op|'('
string|"'http'"
op|')'
newline|'\n'
DECL|class|HttpCheck
name|'class'
name|'HttpCheck'
op|'('
name|'Check'
op|')'
op|':'
newline|'\n'
DECL|member|__call__
indent|'    '
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'creds'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check http: rules by calling to a remote server.\n\n        This example implementation simply verifies that the response\n        is exactly \'True\'.\n        """'
newline|'\n'
nl|'\n'
name|'url'
op|'='
op|'('
string|"'http:'"
op|'+'
name|'self'
op|'.'
name|'match'
op|')'
op|'%'
name|'target'
newline|'\n'
name|'data'
op|'='
op|'{'
string|"'target'"
op|':'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
name|'target'
op|')'
op|','
nl|'\n'
string|"'credentials'"
op|':'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
name|'creds'
op|')'
op|'}'
newline|'\n'
name|'post_data'
op|'='
name|'urllib'
op|'.'
name|'urlencode'
op|'('
name|'data'
op|')'
newline|'\n'
name|'f'
op|'='
name|'urllib2'
op|'.'
name|'urlopen'
op|'('
name|'url'
op|','
name|'post_data'
op|')'
newline|'\n'
name|'return'
name|'f'
op|'.'
name|'read'
op|'('
op|')'
op|'=='
string|'"True"'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'register'
op|'('
name|'None'
op|')'
newline|'\n'
DECL|class|GenericCheck
name|'class'
name|'GenericCheck'
op|'('
name|'Check'
op|')'
op|':'
newline|'\n'
DECL|member|__call__
indent|'    '
name|'def'
name|'__call__'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'creds'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Check an individual match.\n\n        Matches look like:\n\n            tenant:%(tenant_id)s\n            role:compute:admin\n        """'
newline|'\n'
nl|'\n'
comment|'# TODO(termie): do dict inspection via dot syntax'
nl|'\n'
name|'match'
op|'='
name|'self'
op|'.'
name|'match'
op|'%'
name|'target'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'kind'
name|'in'
name|'creds'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'match'
op|'=='
name|'unicode'
op|'('
name|'creds'
op|'['
name|'self'
op|'.'
name|'kind'
op|']'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'False'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
