begin_unit
comment|'# vim: tabstop=4 shiftwidth=4 softtabstop=4'
nl|'\n'
nl|'\n'
comment|'# Copyright 2011 OpenStack Foundation.'
nl|'\n'
comment|'# All Rights Reserved.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
nl|'\n'
string|'"""\nSystem-level utilities and helper functions.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'sys'
newline|'\n'
nl|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
op|'.'
name|'gettextutils'
name|'import'
name|'_'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|TRUE_STRINGS
name|'TRUE_STRINGS'
op|'='
op|'('
string|"'1'"
op|','
string|"'t'"
op|','
string|"'true'"
op|','
string|"'on'"
op|','
string|"'y'"
op|','
string|"'yes'"
op|')'
newline|'\n'
DECL|variable|FALSE_STRINGS
name|'FALSE_STRINGS'
op|'='
op|'('
string|"'0'"
op|','
string|"'f'"
op|','
string|"'false'"
op|','
string|"'off'"
op|','
string|"'n'"
op|','
string|"'no'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|int_from_bool_as_string
name|'def'
name|'int_from_bool_as_string'
op|'('
name|'subject'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Interpret a string as a boolean and return either 1 or 0.\n\n    Any string value in:\n\n        (\'True\', \'true\', \'On\', \'on\', \'1\')\n\n    is interpreted as a boolean True.\n\n    Useful for JSON-decoded stuff and config file parsing\n    """'
newline|'\n'
name|'return'
name|'bool_from_string'
op|'('
name|'subject'
op|')'
name|'and'
number|'1'
name|'or'
number|'0'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|bool_from_string
dedent|''
name|'def'
name|'bool_from_string'
op|'('
name|'subject'
op|','
name|'strict'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Interpret a string as a boolean.\n\n    A case-insensitive match is performed such that strings matching \'t\',\n    \'true\', \'on\', \'y\', \'yes\', or \'1\' are considered True and, when\n    `strict=False`, anything else is considered False.\n\n    Useful for JSON-decoded stuff and config file parsing.\n\n    If `strict=True`, unrecognized values, including None, will raise a\n    ValueError which is useful when parsing values passed in from an API call.\n    Strings yielding False are \'f\', \'false\', \'off\', \'n\', \'no\', or \'0\'.\n    """'
newline|'\n'
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'subject'
op|','
name|'basestring'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'subject'
op|'='
name|'str'
op|'('
name|'subject'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'lowered'
op|'='
name|'subject'
op|'.'
name|'strip'
op|'('
op|')'
op|'.'
name|'lower'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'lowered'
name|'in'
name|'TRUE_STRINGS'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'elif'
name|'lowered'
name|'in'
name|'FALSE_STRINGS'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'elif'
name|'strict'
op|':'
newline|'\n'
indent|'        '
name|'acceptable'
op|'='
string|"', '"
op|'.'
name|'join'
op|'('
nl|'\n'
string|'"\'%s\'"'
op|'%'
name|'s'
name|'for'
name|'s'
name|'in'
name|'sorted'
op|'('
name|'TRUE_STRINGS'
op|'+'
name|'FALSE_STRINGS'
op|')'
op|')'
newline|'\n'
name|'msg'
op|'='
name|'_'
op|'('
string|'"Unrecognized value \'%(val)s\', acceptable values are:"'
nl|'\n'
string|'" %(acceptable)s"'
op|')'
op|'%'
op|'{'
string|"'val'"
op|':'
name|'subject'
op|','
nl|'\n'
string|"'acceptable'"
op|':'
name|'acceptable'
op|'}'
newline|'\n'
name|'raise'
name|'ValueError'
op|'('
name|'msg'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|safe_decode
dedent|''
dedent|''
name|'def'
name|'safe_decode'
op|'('
name|'text'
op|','
name|'incoming'
op|'='
name|'None'
op|','
name|'errors'
op|'='
string|"'strict'"
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Decodes incoming str using `incoming` if they\'re\n    not already unicode.\n\n    :param incoming: Text\'s current encoding\n    :param errors: Errors handling policy. See here for valid\n        values http://docs.python.org/2/library/codecs.html\n    :returns: text or a unicode `incoming` encoded\n                representation of it.\n    :raises TypeError: If text is not an isntance of basestring\n    """'
newline|'\n'
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'text'
op|','
name|'basestring'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'TypeError'
op|'('
string|'"%s can\'t be decoded"'
op|'%'
name|'type'
op|'('
name|'text'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'isinstance'
op|'('
name|'text'
op|','
name|'unicode'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'text'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'incoming'
op|':'
newline|'\n'
indent|'        '
name|'incoming'
op|'='
op|'('
name|'sys'
op|'.'
name|'stdin'
op|'.'
name|'encoding'
name|'or'
nl|'\n'
name|'sys'
op|'.'
name|'getdefaultencoding'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'text'
op|'.'
name|'decode'
op|'('
name|'incoming'
op|','
name|'errors'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'UnicodeDecodeError'
op|':'
newline|'\n'
comment|'# Note(flaper87) If we get here, it means that'
nl|'\n'
comment|'# sys.stdin.encoding / sys.getdefaultencoding'
nl|'\n'
comment|"# didn't return a suitable encoding to decode"
nl|'\n'
comment|'# text. This happens mostly when global LANG'
nl|'\n'
comment|"# var is not set correctly and there's no"
nl|'\n'
comment|'# default encoding. In this case, most likely'
nl|'\n'
comment|'# python will use ASCII or ANSI encoders as'
nl|'\n'
comment|"# default encodings but they won't be capable"
nl|'\n'
comment|'# of decoding non-ASCII characters.'
nl|'\n'
comment|'#'
nl|'\n'
comment|"# Also, UTF-8 is being used since it's an ASCII"
nl|'\n'
comment|'# extension.'
nl|'\n'
indent|'        '
name|'return'
name|'text'
op|'.'
name|'decode'
op|'('
string|"'utf-8'"
op|','
name|'errors'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|safe_encode
dedent|''
dedent|''
name|'def'
name|'safe_encode'
op|'('
name|'text'
op|','
name|'incoming'
op|'='
name|'None'
op|','
nl|'\n'
name|'encoding'
op|'='
string|"'utf-8'"
op|','
name|'errors'
op|'='
string|"'strict'"
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Encodes incoming str/unicode using `encoding`. If\n    incoming is not specified, text is expected to\n    be encoded with current python\'s default encoding.\n    (`sys.getdefaultencoding`)\n\n    :param incoming: Text\'s current encoding\n    :param encoding: Expected encoding for text (Default UTF-8)\n    :param errors: Errors handling policy. See here for valid\n        values http://docs.python.org/2/library/codecs.html\n    :returns: text or a bytestring `encoding` encoded\n                representation of it.\n    :raises TypeError: If text is not an isntance of basestring\n    """'
newline|'\n'
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'text'
op|','
name|'basestring'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'TypeError'
op|'('
string|'"%s can\'t be encoded"'
op|'%'
name|'type'
op|'('
name|'text'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'incoming'
op|':'
newline|'\n'
indent|'        '
name|'incoming'
op|'='
op|'('
name|'sys'
op|'.'
name|'stdin'
op|'.'
name|'encoding'
name|'or'
nl|'\n'
name|'sys'
op|'.'
name|'getdefaultencoding'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'isinstance'
op|'('
name|'text'
op|','
name|'unicode'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'text'
op|'.'
name|'encode'
op|'('
name|'encoding'
op|','
name|'errors'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'text'
name|'and'
name|'encoding'
op|'!='
name|'incoming'
op|':'
newline|'\n'
comment|'# Decode text before encoding it with `encoding`'
nl|'\n'
indent|'        '
name|'text'
op|'='
name|'safe_decode'
op|'('
name|'text'
op|','
name|'incoming'
op|','
name|'errors'
op|')'
newline|'\n'
name|'return'
name|'text'
op|'.'
name|'encode'
op|'('
name|'encoding'
op|','
name|'errors'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'text'
newline|'\n'
dedent|''
endmarker|''
end_unit
