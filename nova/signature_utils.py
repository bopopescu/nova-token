begin_unit
comment|'# Copyright (c) The Johns Hopkins University/Applied Physics Laboratory'
nl|'\n'
comment|'# All Rights Reserved.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
nl|'\n'
string|'"""Support signature verification."""'
newline|'\n'
nl|'\n'
name|'import'
name|'binascii'
newline|'\n'
nl|'\n'
name|'from'
name|'castellan'
op|'.'
name|'common'
op|'.'
name|'exception'
name|'import'
name|'KeyManagerError'
newline|'\n'
name|'from'
name|'castellan'
name|'import'
name|'key_manager'
newline|'\n'
name|'from'
name|'cryptography'
op|'.'
name|'hazmat'
op|'.'
name|'backends'
name|'import'
name|'default_backend'
newline|'\n'
name|'from'
name|'cryptography'
op|'.'
name|'hazmat'
op|'.'
name|'primitives'
op|'.'
name|'asymmetric'
name|'import'
name|'dsa'
newline|'\n'
name|'from'
name|'cryptography'
op|'.'
name|'hazmat'
op|'.'
name|'primitives'
op|'.'
name|'asymmetric'
name|'import'
name|'ec'
newline|'\n'
name|'from'
name|'cryptography'
op|'.'
name|'hazmat'
op|'.'
name|'primitives'
op|'.'
name|'asymmetric'
name|'import'
name|'padding'
newline|'\n'
name|'from'
name|'cryptography'
op|'.'
name|'hazmat'
op|'.'
name|'primitives'
op|'.'
name|'asymmetric'
name|'import'
name|'rsa'
newline|'\n'
name|'from'
name|'cryptography'
op|'.'
name|'hazmat'
op|'.'
name|'primitives'
name|'import'
name|'hashes'
newline|'\n'
name|'from'
name|'cryptography'
name|'import'
name|'x509'
newline|'\n'
name|'from'
name|'oslo_log'
name|'import'
name|'log'
name|'as'
name|'logging'
newline|'\n'
name|'from'
name|'oslo_serialization'
name|'import'
name|'base64'
newline|'\n'
name|'from'
name|'oslo_utils'
name|'import'
name|'encodeutils'
newline|'\n'
name|'from'
name|'oslo_utils'
name|'import'
name|'timeutils'
newline|'\n'
nl|'\n'
name|'from'
name|'nova'
name|'import'
name|'exception'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_'
op|','
name|'_LE'
newline|'\n'
nl|'\n'
DECL|variable|LOG
name|'LOG'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|HASH_METHODS
name|'HASH_METHODS'
op|'='
op|'{'
nl|'\n'
string|"'SHA-224'"
op|':'
name|'hashes'
op|'.'
name|'SHA224'
op|'('
op|')'
op|','
nl|'\n'
string|"'SHA-256'"
op|':'
name|'hashes'
op|'.'
name|'SHA256'
op|'('
op|')'
op|','
nl|'\n'
string|"'SHA-384'"
op|':'
name|'hashes'
op|'.'
name|'SHA384'
op|'('
op|')'
op|','
nl|'\n'
string|"'SHA-512'"
op|':'
name|'hashes'
op|'.'
name|'SHA512'
op|'('
op|')'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
comment|'# Currently supported signature key types'
nl|'\n'
comment|'# RSA Options'
nl|'\n'
DECL|variable|RSA_PSS
name|'RSA_PSS'
op|'='
string|"'RSA-PSS'"
newline|'\n'
comment|'# DSA Options'
nl|'\n'
DECL|variable|DSA
name|'DSA'
op|'='
string|"'DSA'"
newline|'\n'
nl|'\n'
comment|'# ECC curves -- note that only those with key sizes >=384 are included'
nl|'\n'
comment|'# Note also that some of these may not be supported by the cryptography backend'
nl|'\n'
DECL|variable|ECC_CURVES
name|'ECC_CURVES'
op|'='
op|'('
nl|'\n'
name|'ec'
op|'.'
name|'SECT571K1'
op|'('
op|')'
op|','
nl|'\n'
name|'ec'
op|'.'
name|'SECT409K1'
op|'('
op|')'
op|','
nl|'\n'
name|'ec'
op|'.'
name|'SECT571R1'
op|'('
op|')'
op|','
nl|'\n'
name|'ec'
op|'.'
name|'SECT409R1'
op|'('
op|')'
op|','
nl|'\n'
name|'ec'
op|'.'
name|'SECP521R1'
op|'('
op|')'
op|','
nl|'\n'
name|'ec'
op|'.'
name|'SECP384R1'
op|'('
op|')'
op|','
nl|'\n'
op|')'
newline|'\n'
nl|'\n'
comment|'# These are the currently supported certificate formats'
nl|'\n'
DECL|variable|X_509
name|'X_509'
op|'='
string|"'X.509'"
newline|'\n'
nl|'\n'
DECL|variable|CERTIFICATE_FORMATS
name|'CERTIFICATE_FORMATS'
op|'='
op|'{'
nl|'\n'
name|'X_509'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
comment|'# These are the currently supported MGF formats, used for RSA-PSS signatures'
nl|'\n'
DECL|variable|MASK_GEN_ALGORITHMS
name|'MASK_GEN_ALGORITHMS'
op|'='
op|'{'
nl|'\n'
string|"'MGF1'"
op|':'
name|'padding'
op|'.'
name|'MGF1'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|SignatureKeyType
name|'class'
name|'SignatureKeyType'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|_REGISTERED_TYPES
indent|'    '
name|'_REGISTERED_TYPES'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'name'
op|','
name|'public_key_type'
op|','
name|'create_verifier'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'name'
op|'='
name|'name'
newline|'\n'
name|'self'
op|'.'
name|'public_key_type'
op|'='
name|'public_key_type'
newline|'\n'
name|'self'
op|'.'
name|'create_verifier'
op|'='
name|'create_verifier'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|register
name|'def'
name|'register'
op|'('
name|'cls'
op|','
name|'name'
op|','
name|'public_key_type'
op|','
name|'create_verifier'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Register a signature key type.\n\n        :param name: the name of the signature key type\n        :param public_key_type: e.g. RSAPublicKey, DSAPublicKey, etc.\n        :param create_verifier: a function to create a verifier for this type\n        """'
newline|'\n'
name|'cls'
op|'.'
name|'_REGISTERED_TYPES'
op|'['
name|'name'
op|']'
op|'='
name|'cls'
op|'('
name|'name'
op|','
nl|'\n'
name|'public_key_type'
op|','
nl|'\n'
name|'create_verifier'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|lookup
name|'def'
name|'lookup'
op|'('
name|'cls'
op|','
name|'name'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Look up the signature key type.\n\n        :param name: the name of the signature key type\n        :returns: the SignatureKeyType object\n        :raises: SignatureVerificationError if signature key type is invalid\n        """'
newline|'\n'
name|'if'
name|'name'
name|'not'
name|'in'
name|'cls'
op|'.'
name|'_REGISTERED_TYPES'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'SignatureVerificationError'
op|'('
nl|'\n'
name|'reason'
op|'='
name|'_'
op|'('
string|"'Invalid signature key type: %s'"
op|')'
op|'%'
name|'name'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'cls'
op|'.'
name|'_REGISTERED_TYPES'
op|'['
name|'name'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# each key type will require its own verifier'
nl|'\n'
DECL|function|create_verifier_for_pss
dedent|''
dedent|''
name|'def'
name|'create_verifier_for_pss'
op|'('
name|'signature'
op|','
name|'hash_method'
op|','
name|'public_key'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Create the verifier to use when the key type is RSA-PSS.\n\n    :param signature: the decoded signature to use\n    :param hash_method: the hash method to use, as a cryptography object\n    :param public_key: the public key to use, as a cryptography object\n    :raises: SignatureVerificationError if the RSA-PSS specific properties\n                                        are invalid\n    :returns: the verifier to use to verify the signature for RSA-PSS\n    """'
newline|'\n'
comment|'# default to MGF1'
nl|'\n'
name|'mgf'
op|'='
name|'padding'
op|'.'
name|'MGF1'
op|'('
name|'hash_method'
op|')'
newline|'\n'
nl|'\n'
comment|'# default to max salt length'
nl|'\n'
name|'salt_length'
op|'='
name|'padding'
op|'.'
name|'PSS'
op|'.'
name|'MAX_LENGTH'
newline|'\n'
nl|'\n'
comment|'# return the verifier'
nl|'\n'
name|'return'
name|'public_key'
op|'.'
name|'verifier'
op|'('
nl|'\n'
name|'signature'
op|','
nl|'\n'
name|'padding'
op|'.'
name|'PSS'
op|'('
name|'mgf'
op|'='
name|'mgf'
op|','
name|'salt_length'
op|'='
name|'salt_length'
op|')'
op|','
nl|'\n'
name|'hash_method'
nl|'\n'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|create_verifier_for_ecc
dedent|''
name|'def'
name|'create_verifier_for_ecc'
op|'('
name|'signature'
op|','
name|'hash_method'
op|','
name|'public_key'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Create the verifier to use when the key type is ECC_*.\n\n    :param signature: the decoded signature to use\n    :param hash_method: the hash method to use, as a cryptography object\n    :param public_key: the public key to use, as a cryptography object\n    :returns: the verifier to use to verify the signature for ECC_*.\n    """'
newline|'\n'
comment|'# return the verifier'
nl|'\n'
name|'return'
name|'public_key'
op|'.'
name|'verifier'
op|'('
nl|'\n'
name|'signature'
op|','
nl|'\n'
name|'ec'
op|'.'
name|'ECDSA'
op|'('
name|'hash_method'
op|')'
nl|'\n'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|create_verifier_for_dsa
dedent|''
name|'def'
name|'create_verifier_for_dsa'
op|'('
name|'signature'
op|','
name|'hash_method'
op|','
name|'public_key'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Create the verifier to use when the key type is DSA\n\n    :param signature: the decoded signature to use\n    :param hash_method: the hash method to use, as a cryptography object\n    :param public_key: the public key to use, as a cryptography object\n    :returns: the verifier to use to verify the signature for DSA\n    """'
newline|'\n'
comment|'# return the verifier'
nl|'\n'
name|'return'
name|'public_key'
op|'.'
name|'verifier'
op|'('
nl|'\n'
name|'signature'
op|','
nl|'\n'
name|'hash_method'
nl|'\n'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
name|'SignatureKeyType'
op|'.'
name|'register'
op|'('
name|'RSA_PSS'
op|','
name|'rsa'
op|'.'
name|'RSAPublicKey'
op|','
name|'create_verifier_for_pss'
op|')'
newline|'\n'
name|'SignatureKeyType'
op|'.'
name|'register'
op|'('
name|'DSA'
op|','
name|'dsa'
op|'.'
name|'DSAPublicKey'
op|','
name|'create_verifier_for_dsa'
op|')'
newline|'\n'
nl|'\n'
comment|'# Register the elliptic curves which are supported by the backend'
nl|'\n'
name|'for'
name|'curve'
name|'in'
name|'ECC_CURVES'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'default_backend'
op|'('
op|')'
op|'.'
name|'elliptic_curve_supported'
op|'('
name|'curve'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'SignatureKeyType'
op|'.'
name|'register'
op|'('
string|"'ECC_'"
op|'+'
name|'curve'
op|'.'
name|'name'
op|'.'
name|'upper'
op|'('
op|')'
op|','
nl|'\n'
name|'ec'
op|'.'
name|'EllipticCurvePublicKey'
op|','
nl|'\n'
name|'create_verifier_for_ecc'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_verifier
dedent|''
dedent|''
name|'def'
name|'get_verifier'
op|'('
name|'context'
op|','
name|'img_signature_certificate_uuid'
op|','
nl|'\n'
name|'img_signature_hash_method'
op|','
name|'img_signature'
op|','
nl|'\n'
name|'img_signature_key_type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Instantiate signature properties and use them to create a verifier.\n\n    :param context: the user context for authentication\n    :param img_signature_certificate_uuid:\n    uuid of signing certificate stored in key manager\n    :param img_signature_hash_method:\n    string denoting hash method used to compute signature\n    :param img_signature: string of base64 encoding of signature\n    :param img_signature_key_type:\n    string denoting type of keypair used to compute signature\n    :returns: instance of\n    cryptography.hazmat.primitives.asymmetric.AsymmetricVerificationContext\n    :raises: SignatureVerificationError if we fail to build the verifier\n    """'
newline|'\n'
name|'image_meta_props'
op|'='
op|'{'
string|"'img_signature_uuid'"
op|':'
name|'img_signature_certificate_uuid'
op|','
nl|'\n'
string|"'img_signature_hash_method'"
op|':'
name|'img_signature_hash_method'
op|','
nl|'\n'
string|"'img_signature'"
op|':'
name|'img_signature'
op|','
nl|'\n'
string|"'img_signature_key_type'"
op|':'
name|'img_signature_key_type'
op|'}'
newline|'\n'
name|'for'
name|'key'
name|'in'
name|'image_meta_props'
op|'.'
name|'keys'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'image_meta_props'
op|'['
name|'key'
op|']'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'SignatureVerificationError'
op|'('
nl|'\n'
name|'reason'
op|'='
name|'_'
op|'('
string|"'Required image properties for signature verification'"
nl|'\n'
string|"' do not exist. Cannot verify signature. Missing'"
nl|'\n'
string|"' property: %s'"
op|')'
op|'%'
name|'key'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'signature'
op|'='
name|'get_signature'
op|'('
name|'img_signature'
op|')'
newline|'\n'
name|'hash_method'
op|'='
name|'get_hash_method'
op|'('
name|'img_signature_hash_method'
op|')'
newline|'\n'
name|'signature_key_type'
op|'='
name|'SignatureKeyType'
op|'.'
name|'lookup'
op|'('
name|'img_signature_key_type'
op|')'
newline|'\n'
name|'public_key'
op|'='
name|'get_public_key'
op|'('
name|'context'
op|','
nl|'\n'
name|'img_signature_certificate_uuid'
op|','
nl|'\n'
name|'signature_key_type'
op|')'
newline|'\n'
nl|'\n'
comment|'# create the verifier based on the signature key type'
nl|'\n'
name|'verifier'
op|'='
name|'signature_key_type'
op|'.'
name|'create_verifier'
op|'('
name|'signature'
op|','
nl|'\n'
name|'hash_method'
op|','
nl|'\n'
name|'public_key'
op|')'
newline|'\n'
name|'if'
name|'verifier'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'verifier'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Error creating the verifier'
nl|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'SignatureVerificationError'
op|'('
nl|'\n'
name|'reason'
op|'='
name|'_'
op|'('
string|"'Error occurred while creating the verifier'"
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_signature
dedent|''
dedent|''
name|'def'
name|'get_signature'
op|'('
name|'signature_data'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Decode the signature data and returns the signature.\n\n    :param siganture_data: the base64-encoded signature data\n    :returns: the decoded signature\n    :raises: SignatureVerificationError if the signature data is malformatted\n    """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'signature'
op|'='
name|'base64'
op|'.'
name|'decode_as_bytes'
op|'('
name|'signature_data'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'TypeError'
op|','
name|'binascii'
op|'.'
name|'Error'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'SignatureVerificationError'
op|'('
nl|'\n'
name|'reason'
op|'='
name|'_'
op|'('
string|"'The signature data was not properly '"
nl|'\n'
string|"'encoded using base64'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'signature'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_hash_method
dedent|''
name|'def'
name|'get_hash_method'
op|'('
name|'hash_method_name'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Verify the hash method name and create the hash method.\n\n    :param hash_method_name: the name of the hash method to retrieve\n    :returns: the hash method, a cryptography object\n    :raises: SignatureVerificationError if the hash method name is invalid\n    """'
newline|'\n'
name|'if'
name|'hash_method_name'
name|'not'
name|'in'
name|'HASH_METHODS'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'SignatureVerificationError'
op|'('
nl|'\n'
name|'reason'
op|'='
name|'_'
op|'('
string|"'Invalid signature hash method: %s'"
op|')'
op|'%'
name|'hash_method_name'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'HASH_METHODS'
op|'['
name|'hash_method_name'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_public_key
dedent|''
name|'def'
name|'get_public_key'
op|'('
name|'context'
op|','
name|'signature_certificate_uuid'
op|','
name|'signature_key_type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Create the public key object from a retrieved certificate.\n\n    :param context: the user context for authentication\n    :param signature_certificate_uuid: the uuid to use to retrieve the\n                                       certificate\n    :param signature_key_type: a SignatureKeyType object\n    :returns: the public key cryptography object\n    :raises: SignatureVerificationError if public key format is invalid\n    """'
newline|'\n'
name|'certificate'
op|'='
name|'get_certificate'
op|'('
name|'context'
op|','
name|'signature_certificate_uuid'
op|')'
newline|'\n'
nl|'\n'
comment|'# Note that this public key could either be'
nl|'\n'
comment|'# RSAPublicKey, DSAPublicKey, or EllipticCurvePublicKey'
nl|'\n'
name|'public_key'
op|'='
name|'certificate'
op|'.'
name|'public_key'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Confirm the type is of the type expected based on the signature key type'
nl|'\n'
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'public_key'
op|','
name|'signature_key_type'
op|'.'
name|'public_key_type'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'SignatureVerificationError'
op|'('
nl|'\n'
name|'reason'
op|'='
name|'_'
op|'('
string|"'Invalid public key type for signature key type: %s'"
op|')'
nl|'\n'
op|'%'
name|'signature_key_type'
op|'.'
name|'name'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'public_key'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_certificate
dedent|''
name|'def'
name|'get_certificate'
op|'('
name|'context'
op|','
name|'signature_certificate_uuid'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Create the certificate object from the retrieved certificate data.\n\n    :param context: the user context for authentication\n    :param signature_certificate_uuid: the uuid to use to retrieve the\n                                       certificate\n    :returns: the certificate cryptography object\n    :raises: SignatureVerificationError if the retrieval fails or the format\n             is invalid\n    """'
newline|'\n'
name|'keymgr_api'
op|'='
name|'key_manager'
op|'.'
name|'API'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# The certificate retrieved here is a castellan certificate object'
nl|'\n'
indent|'        '
name|'cert'
op|'='
name|'keymgr_api'
op|'.'
name|'get'
op|'('
name|'context'
op|','
name|'signature_certificate_uuid'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'KeyManagerError'
name|'as'
name|'e'
op|':'
newline|'\n'
comment|'# The problem encountered may be backend-specific, since castellan'
nl|'\n'
comment|'# can use different backends.  Rather than importing all possible'
nl|'\n'
comment|'# backends here, the generic "Exception" is used.'
nl|'\n'
indent|'        '
name|'msg'
op|'='
op|'('
name|'_LE'
op|'('
string|'"Unable to retrieve certificate with ID %(id)s: %(e)s"'
op|')'
nl|'\n'
op|'%'
op|'{'
string|"'id'"
op|':'
name|'signature_certificate_uuid'
op|','
nl|'\n'
string|"'e'"
op|':'
name|'encodeutils'
op|'.'
name|'exception_to_unicode'
op|'('
name|'e'
op|')'
op|'}'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'error'
op|'('
name|'msg'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'SignatureVerificationError'
op|'('
nl|'\n'
name|'reason'
op|'='
name|'_'
op|'('
string|"'Unable to retrieve certificate with ID: %s'"
op|')'
nl|'\n'
op|'%'
name|'signature_certificate_uuid'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'cert'
op|'.'
name|'format'
name|'not'
name|'in'
name|'CERTIFICATE_FORMATS'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'SignatureVerificationError'
op|'('
nl|'\n'
name|'reason'
op|'='
name|'_'
op|'('
string|"'Invalid certificate format: %s'"
op|')'
op|'%'
name|'cert'
op|'.'
name|'format'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'cert'
op|'.'
name|'format'
op|'=='
name|'X_509'
op|':'
newline|'\n'
comment|'# castellan always encodes certificates in DER format'
nl|'\n'
indent|'        '
name|'cert_data'
op|'='
name|'cert'
op|'.'
name|'get_encoded'
op|'('
op|')'
newline|'\n'
name|'certificate'
op|'='
name|'x509'
op|'.'
name|'load_der_x509_certificate'
op|'('
name|'cert_data'
op|','
nl|'\n'
name|'default_backend'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# verify the certificate'
nl|'\n'
dedent|''
name|'verify_certificate'
op|'('
name|'certificate'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'certificate'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|verify_certificate
dedent|''
name|'def'
name|'verify_certificate'
op|'('
name|'certificate'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Verify that the certificate has not expired.\n\n    :param certificate: the cryptography certificate object\n    :raises: SignatureVerificationError if the certificate valid time range\n             does not include now\n    """'
newline|'\n'
comment|'# Get now in UTC, since certificate returns times in UTC'
nl|'\n'
name|'now'
op|'='
name|'timeutils'
op|'.'
name|'utcnow'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Confirm the certificate valid time range includes now'
nl|'\n'
name|'if'
name|'now'
op|'<'
name|'certificate'
op|'.'
name|'not_valid_before'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'SignatureVerificationError'
op|'('
nl|'\n'
name|'reason'
op|'='
name|'_'
op|'('
string|"'Certificate is not valid before: %s UTC'"
op|')'
nl|'\n'
op|'%'
name|'certificate'
op|'.'
name|'not_valid_before'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'now'
op|'>'
name|'certificate'
op|'.'
name|'not_valid_after'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'SignatureVerificationError'
op|'('
nl|'\n'
name|'reason'
op|'='
name|'_'
op|'('
string|"'Certificate is not valid after: %s UTC'"
op|')'
nl|'\n'
op|'%'
name|'certificate'
op|'.'
name|'not_valid_after'
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
