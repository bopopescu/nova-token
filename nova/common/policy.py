begin_unit
comment|'# vim: tabstop=4 shiftwidth=4 softtabstop=4'
nl|'\n'
nl|'\n'
comment|'# Copyright (c) 2011 OpenStack, LLC.'
nl|'\n'
comment|'# All Rights Reserved.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
nl|'\n'
string|'"""Common Policy Engine Implementation"""'
newline|'\n'
nl|'\n'
name|'import'
name|'json'
newline|'\n'
name|'import'
name|'urllib'
newline|'\n'
name|'import'
name|'urllib2'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|NotAuthorized
name|'class'
name|'NotAuthorized'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|_BRAIN
dedent|''
name|'_BRAIN'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|set_brain
name|'def'
name|'set_brain'
op|'('
name|'brain'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Set the brain used by enforce().\n\n    Defaults use Brain() if not set.\n\n    """'
newline|'\n'
name|'global'
name|'_BRAIN'
newline|'\n'
name|'_BRAIN'
op|'='
name|'brain'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|reset
dedent|''
name|'def'
name|'reset'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Clear the brain used by enforce()."""'
newline|'\n'
name|'global'
name|'_BRAIN'
newline|'\n'
name|'_BRAIN'
op|'='
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|enforce
dedent|''
name|'def'
name|'enforce'
op|'('
name|'match_list'
op|','
name|'target_dict'
op|','
name|'credentials_dict'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Enforces authorization of some rules against credentials.\n\n    :param match_list: nested tuples of data to match against\n    The basic brain supports three types of match lists:\n        1) rules\n            looks like: (\'rule:compute:get_instance\',)\n            Retrieves the named rule from the rules dict and recursively\n            checks against the contents of the rule.\n        2) roles\n            looks like: (\'role:compute:admin\',)\n            Matches if the specified role is in credentials_dict[\'roles\'].\n        3) generic\n            (\'tenant_id:%(tenant_id)s\',)\n            Substitutes values from the target dict into the match using\n            the % operator and matches them against the creds dict.\n\n    Combining rules:\n        The brain returns True if any of the outer tuple of rules match\n        and also True if all of the inner tuples match. You can use this to\n        perform simple boolean logic.  For example, the following rule would\n        return True if the creds contain the role \'admin\' OR the if the\n        tenant_id matches the target dict AND the the creds contains the\n        role \'compute_sysadmin\':\n\n        {\n            "rule:combined": (\n                \'role:admin\',\n                (\'tenant_id:%(tenant_id)s\', \'role:compute_sysadmin\')\n            )\n        }\n\n\n    Note that rule and role are reserved words in the credentials match, so\n    you can\'t match against properties with those names. Custom brains may\n    also add new reserved words. For example, the HttpBrain adds http as a\n    reserved word.\n\n    :param target_dict: dict of object properties\n    Target dicts contain as much information as we can about the object being\n    operated on.\n\n    :param credentials_dict: dict of actor properties\n    Credentials dicts contain as much information as we can about the user\n    performing the action.\n\n    :raises NotAuthorized if the check fails\n\n    """'
newline|'\n'
name|'global'
name|'_BRAIN'
newline|'\n'
name|'if'
name|'not'
name|'_BRAIN'
op|':'
newline|'\n'
indent|'        '
name|'_BRAIN'
op|'='
name|'Brain'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'_BRAIN'
op|'.'
name|'check'
op|'('
name|'match_list'
op|','
name|'target_dict'
op|','
name|'credentials_dict'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'NotAuthorized'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Brain
dedent|''
dedent|''
name|'class'
name|'Brain'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Implements policy checking."""'
newline|'\n'
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|load_json
name|'def'
name|'load_json'
op|'('
name|'cls'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Init a brain using json instead of a rules dictionary."""'
newline|'\n'
name|'rules_dict'
op|'='
name|'json'
op|'.'
name|'loads'
op|'('
name|'data'
op|')'
newline|'\n'
name|'return'
name|'cls'
op|'('
name|'rules'
op|'='
name|'rules_dict'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__init__
dedent|''
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'rules'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'rules'
op|'='
name|'rules'
name|'or'
op|'{'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|add_rule
dedent|''
name|'def'
name|'add_rule'
op|'('
name|'self'
op|','
name|'key'
op|','
name|'match'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'rules'
op|'['
name|'key'
op|']'
op|'='
name|'match'
newline|'\n'
nl|'\n'
DECL|member|_check
dedent|''
name|'def'
name|'_check'
op|'('
name|'self'
op|','
name|'match'
op|','
name|'target_dict'
op|','
name|'cred_dict'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'match_kind'
op|','
name|'match_value'
op|'='
name|'match'
op|'.'
name|'split'
op|'('
string|"':'"
op|','
number|'1'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'='
name|'getattr'
op|'('
name|'self'
op|','
string|"'_check_%s'"
op|'%'
name|'match_kind'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'self'
op|'.'
name|'_check_generic'
op|'('
name|'match'
op|','
name|'target_dict'
op|','
name|'cred_dict'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'False'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'f'
op|'('
name|'match_value'
op|','
name|'target_dict'
op|','
name|'cred_dict'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'False'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'True'
newline|'\n'
nl|'\n'
DECL|member|check
dedent|''
name|'def'
name|'check'
op|'('
name|'self'
op|','
name|'match_list'
op|','
name|'target_dict'
op|','
name|'cred_dict'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Checks authorization of some rules against credentials.\n\n        Detailed description of the check with examples in policy.enforce().\n\n        :param match_list: nested tuples of data to match against\n        :param target_dict: dict of object properties\n        :param credentials_dict: dict of actor properties\n\n        :returns: True if the check passes\n\n        """'
newline|'\n'
name|'if'
name|'not'
name|'match_list'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'for'
name|'and_list'
name|'in'
name|'match_list'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'isinstance'
op|'('
name|'and_list'
op|','
name|'basestring'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'and_list'
op|'='
op|'('
name|'and_list'
op|','
op|')'
newline|'\n'
dedent|''
name|'if'
name|'all'
op|'('
op|'['
name|'self'
op|'.'
name|'_check'
op|'('
name|'item'
op|','
name|'target_dict'
op|','
name|'cred_dict'
op|')'
nl|'\n'
name|'for'
name|'item'
name|'in'
name|'and_list'
op|']'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|_check_rule
dedent|''
name|'def'
name|'_check_rule'
op|'('
name|'self'
op|','
name|'match'
op|','
name|'target_dict'
op|','
name|'cred_dict'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Recursively checks credentials based on the brains rules."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'new_match_list'
op|'='
name|'self'
op|'.'
name|'rules'
op|'['
name|'match'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'check'
op|'('
name|'new_match_list'
op|','
name|'target_dict'
op|','
name|'cred_dict'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_check_role
dedent|''
name|'def'
name|'_check_role'
op|'('
name|'self'
op|','
name|'match'
op|','
name|'target_dict'
op|','
name|'cred_dict'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check that there is a matching role in the cred dict."""'
newline|'\n'
name|'return'
name|'match'
name|'in'
name|'cred_dict'
op|'['
string|"'roles'"
op|']'
newline|'\n'
nl|'\n'
DECL|member|_check_generic
dedent|''
name|'def'
name|'_check_generic'
op|'('
name|'self'
op|','
name|'match'
op|','
name|'target_dict'
op|','
name|'cred_dict'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check an individual match.\n\n        Matches look like:\n\n            tenant:%(tenant_id)s\n            role:compute:admin\n\n        """'
newline|'\n'
nl|'\n'
comment|'# TODO(termie): do dict inspection via dot syntax'
nl|'\n'
name|'match'
op|'='
name|'match'
op|'%'
name|'target_dict'
newline|'\n'
name|'key'
op|','
name|'value'
op|'='
name|'match'
op|'.'
name|'split'
op|'('
string|"':'"
op|','
number|'1'
op|')'
newline|'\n'
name|'if'
name|'key'
name|'in'
name|'cred_dict'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'value'
op|'=='
name|'cred_dict'
op|'['
name|'key'
op|']'
newline|'\n'
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|HttpBrain
dedent|''
dedent|''
name|'class'
name|'HttpBrain'
op|'('
name|'Brain'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""A brain that can check external urls for policy.\n\n    Posts json blobs for target and credentials.\n\n    """'
newline|'\n'
nl|'\n'
DECL|member|_check_http
name|'def'
name|'_check_http'
op|'('
name|'self'
op|','
name|'match'
op|','
name|'target_dict'
op|','
name|'cred_dict'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check http: rules by calling to a remote server.\n\n        This example implementation simply verifies that the response is\n        exactly \'True\'. A custom brain using response codes could easily\n        be implemented.\n\n        """'
newline|'\n'
name|'url'
op|'='
name|'match'
op|'%'
name|'target_dict'
newline|'\n'
name|'data'
op|'='
op|'{'
string|"'target'"
op|':'
name|'json'
op|'.'
name|'dumps'
op|'('
name|'target_dict'
op|')'
op|','
nl|'\n'
string|"'credentials'"
op|':'
name|'json'
op|'.'
name|'dumps'
op|'('
name|'cred_dict'
op|')'
op|'}'
newline|'\n'
name|'post_data'
op|'='
name|'urllib'
op|'.'
name|'urlencode'
op|'('
name|'data'
op|')'
newline|'\n'
name|'f'
op|'='
name|'urllib2'
op|'.'
name|'urlopen'
op|'('
name|'url'
op|','
name|'post_data'
op|')'
newline|'\n'
name|'return'
name|'f'
op|'.'
name|'read'
op|'('
op|')'
op|'=='
string|'"True"'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
