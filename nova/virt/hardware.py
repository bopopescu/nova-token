begin_unit
comment|'# Copyright 2014 Red Hat, Inc'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'# not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'# a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#   http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'# License for the specific language governing permissions and limitations'
nl|'\n'
comment|'# under the License.'
nl|'\n'
nl|'\n'
name|'import'
name|'collections'
newline|'\n'
name|'import'
name|'itertools'
newline|'\n'
nl|'\n'
name|'from'
name|'oslo_config'
name|'import'
name|'cfg'
newline|'\n'
name|'from'
name|'oslo_log'
name|'import'
name|'log'
name|'as'
name|'logging'
newline|'\n'
name|'from'
name|'oslo_serialization'
name|'import'
name|'jsonutils'
newline|'\n'
name|'from'
name|'oslo_utils'
name|'import'
name|'units'
newline|'\n'
name|'import'
name|'six'
newline|'\n'
nl|'\n'
name|'from'
name|'nova'
name|'import'
name|'context'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'exception'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'objects'
newline|'\n'
nl|'\n'
DECL|variable|virt_cpu_opts
name|'virt_cpu_opts'
op|'='
op|'['
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'vcpu_pin_set'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Defines which pcpus that instance vcpus can use. '"
nl|'\n'
string|'\'For example, "4-12,^8,15"\''
op|')'
op|','
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
DECL|variable|CONF
name|'CONF'
op|'='
name|'cfg'
op|'.'
name|'CONF'
newline|'\n'
name|'CONF'
op|'.'
name|'register_opts'
op|'('
name|'virt_cpu_opts'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|LOG
name|'LOG'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|MEMPAGES_SMALL
name|'MEMPAGES_SMALL'
op|'='
op|'-'
number|'1'
newline|'\n'
DECL|variable|MEMPAGES_LARGE
name|'MEMPAGES_LARGE'
op|'='
op|'-'
number|'2'
newline|'\n'
DECL|variable|MEMPAGES_ANY
name|'MEMPAGES_ANY'
op|'='
op|'-'
number|'3'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_vcpu_pin_set
name|'def'
name|'get_vcpu_pin_set'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Parsing vcpu_pin_set config.\n\n    Returns a set of pcpu ids can be used by instances.\n    """'
newline|'\n'
name|'if'
name|'not'
name|'CONF'
op|'.'
name|'vcpu_pin_set'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'cpuset_ids'
op|'='
name|'parse_cpu_spec'
op|'('
name|'CONF'
op|'.'
name|'vcpu_pin_set'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'cpuset_ids'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'_'
op|'('
string|'"No CPUs available after parsing %r"'
op|')'
op|'%'
nl|'\n'
name|'CONF'
op|'.'
name|'vcpu_pin_set'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'cpuset_ids'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|parse_cpu_spec
dedent|''
name|'def'
name|'parse_cpu_spec'
op|'('
name|'spec'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Parse a CPU set specification.\n\n    :param spec: cpu set string eg "1-4,^3,6"\n\n    Each element in the list is either a single\n    CPU number, a range of CPU numbers, or a\n    caret followed by a CPU number to be excluded\n    from a previous range.\n\n    :returns: a set of CPU indexes\n    """'
newline|'\n'
nl|'\n'
name|'cpuset_ids'
op|'='
name|'set'
op|'('
op|')'
newline|'\n'
name|'cpuset_reject_ids'
op|'='
name|'set'
op|'('
op|')'
newline|'\n'
name|'for'
name|'rule'
name|'in'
name|'spec'
op|'.'
name|'split'
op|'('
string|"','"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'rule'
op|'='
name|'rule'
op|'.'
name|'strip'
op|'('
op|')'
newline|'\n'
comment|"# Handle multi ','"
nl|'\n'
name|'if'
name|'len'
op|'('
name|'rule'
op|')'
op|'<'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
comment|'# Note the count limit in the .split() call'
nl|'\n'
dedent|''
name|'range_parts'
op|'='
name|'rule'
op|'.'
name|'split'
op|'('
string|"'-'"
op|','
number|'1'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'range_parts'
op|')'
op|'>'
number|'1'
op|':'
newline|'\n'
comment|'# So, this was a range; start by converting the parts to ints'
nl|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'start'
op|','
name|'end'
op|'='
op|'['
name|'int'
op|'('
name|'p'
op|'.'
name|'strip'
op|'('
op|')'
op|')'
name|'for'
name|'p'
name|'in'
name|'range_parts'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'_'
op|'('
string|'"Invalid range expression %r"'
op|')'
nl|'\n'
op|'%'
name|'rule'
op|')'
newline|'\n'
comment|"# Make sure it's a valid range"
nl|'\n'
dedent|''
name|'if'
name|'start'
op|'>'
name|'end'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'_'
op|'('
string|'"Invalid range expression %r"'
op|')'
nl|'\n'
op|'%'
name|'rule'
op|')'
newline|'\n'
comment|'# Add available CPU ids to set'
nl|'\n'
dedent|''
name|'cpuset_ids'
op|'|='
name|'set'
op|'('
name|'range'
op|'('
name|'start'
op|','
name|'end'
op|'+'
number|'1'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'rule'
op|'['
number|'0'
op|']'
op|'=='
string|"'^'"
op|':'
newline|'\n'
comment|'# Not a range, the rule is an exclusion rule; convert to int'
nl|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'cpuset_reject_ids'
op|'.'
name|'add'
op|'('
name|'int'
op|'('
name|'rule'
op|'['
number|'1'
op|':'
op|']'
op|'.'
name|'strip'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'_'
op|'('
string|'"Invalid exclusion "'
nl|'\n'
string|'"expression %r"'
op|')'
op|'%'
name|'rule'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# OK, a single CPU to include; convert to int'
nl|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'cpuset_ids'
op|'.'
name|'add'
op|'('
name|'int'
op|'('
name|'rule'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'_'
op|'('
string|'"Invalid inclusion "'
nl|'\n'
string|'"expression %r"'
op|')'
op|'%'
name|'rule'
op|')'
newline|'\n'
nl|'\n'
comment|'# Use sets to handle the exclusion rules for us'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'cpuset_ids'
op|'-='
name|'cpuset_reject_ids'
newline|'\n'
nl|'\n'
name|'return'
name|'cpuset_ids'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|format_cpu_spec
dedent|''
name|'def'
name|'format_cpu_spec'
op|'('
name|'cpuset'
op|','
name|'allow_ranges'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Format a libvirt CPU range specification.\n\n    :param cpuset: set (or list) of CPU indexes\n\n    Format a set/list of CPU indexes as a libvirt CPU\n    range specification. It allow_ranges is true, it\n    will try to detect continuous ranges of CPUs,\n    otherwise it will just list each CPU index explicitly.\n\n    :returns: a formatted CPU range string\n    """'
newline|'\n'
nl|'\n'
comment|"# We attempt to detect ranges, but don't bother with"
nl|'\n'
comment|'# trying to do range negations to minimize the overall'
nl|'\n'
comment|'# spec string length'
nl|'\n'
name|'if'
name|'allow_ranges'
op|':'
newline|'\n'
indent|'        '
name|'ranges'
op|'='
op|'['
op|']'
newline|'\n'
name|'previndex'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'cpuindex'
name|'in'
name|'sorted'
op|'('
name|'cpuset'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'previndex'
name|'is'
name|'None'
name|'or'
name|'previndex'
op|'!='
op|'('
name|'cpuindex'
op|'-'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'ranges'
op|'.'
name|'append'
op|'('
op|'['
op|']'
op|')'
newline|'\n'
dedent|''
name|'ranges'
op|'['
op|'-'
number|'1'
op|']'
op|'.'
name|'append'
op|'('
name|'cpuindex'
op|')'
newline|'\n'
name|'previndex'
op|'='
name|'cpuindex'
newline|'\n'
nl|'\n'
dedent|''
name|'parts'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'entry'
name|'in'
name|'ranges'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'len'
op|'('
name|'entry'
op|')'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'parts'
op|'.'
name|'append'
op|'('
name|'str'
op|'('
name|'entry'
op|'['
number|'0'
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'parts'
op|'.'
name|'append'
op|'('
string|'"%d-%d"'
op|'%'
op|'('
name|'entry'
op|'['
number|'0'
op|']'
op|','
name|'entry'
op|'['
name|'len'
op|'('
name|'entry'
op|')'
op|'-'
number|'1'
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
string|'","'
op|'.'
name|'join'
op|'('
name|'parts'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|'","'
op|'.'
name|'join'
op|'('
name|'str'
op|'('
name|'id'
op|')'
name|'for'
name|'id'
name|'in'
name|'sorted'
op|'('
name|'cpuset'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_number_of_serial_ports
dedent|''
dedent|''
name|'def'
name|'get_number_of_serial_ports'
op|'('
name|'flavor'
op|','
name|'image_meta'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Get the number of serial consoles from the flavor or image\n\n    :param flavor: Flavor object to read extra specs from\n    :param image_meta: Image object to read image metadata from\n\n    If flavor extra specs is not set, then any image meta value is permitted.\n    If flavour extra specs *is* set, then this provides the default serial\n    port count. The image meta is permitted to override the extra specs, but\n    *only* with a lower value. ie\n\n    - flavor hw:serial_port_count=4\n      VM gets 4 serial ports\n    - flavor hw:serial_port_count=4 and image hw_serial_port_count=2\n      VM gets 2 serial ports\n    - image hw_serial_port_count=6\n      VM gets 6 serial ports\n    - flavor hw:serial_port_count=4 and image hw_serial_port_count=6\n      Abort guest boot - forbidden to exceed flavor value\n\n    :returns: number of serial ports\n    """'
newline|'\n'
nl|'\n'
DECL|function|get_number
name|'def'
name|'get_number'
op|'('
name|'obj'
op|','
name|'property'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'num_ports'
op|'='
name|'obj'
op|'.'
name|'get'
op|'('
name|'property'
op|')'
newline|'\n'
name|'if'
name|'num_ports'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'num_ports'
op|'='
name|'int'
op|'('
name|'num_ports'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'ImageSerialPortNumberInvalid'
op|'('
nl|'\n'
name|'num_ports'
op|'='
name|'num_ports'
op|','
name|'property'
op|'='
name|'property'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'num_ports'
newline|'\n'
nl|'\n'
dedent|''
name|'image_meta_prop'
op|'='
op|'('
name|'image_meta'
name|'or'
op|'{'
op|'}'
op|')'
op|'.'
name|'get'
op|'('
string|"'properties'"
op|','
op|'{'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'flavor_num_ports'
op|'='
name|'get_number'
op|'('
name|'flavor'
op|'.'
name|'extra_specs'
op|','
string|'"hw:serial_port_count"'
op|')'
newline|'\n'
name|'image_num_ports'
op|'='
name|'get_number'
op|'('
name|'image_meta_prop'
op|','
string|'"hw_serial_port_count"'
op|')'
newline|'\n'
nl|'\n'
name|'if'
op|'('
name|'flavor_num_ports'
name|'and'
name|'image_num_ports'
op|')'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'image_num_ports'
op|'>'
name|'flavor_num_ports'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'ImageSerialPortNumberExceedFlavorValue'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'image_num_ports'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'flavor_num_ports'
name|'or'
name|'image_num_ports'
name|'or'
number|'1'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|InstanceInfo
dedent|''
name|'class'
name|'InstanceInfo'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'state'
op|'='
name|'None'
op|','
name|'max_mem_kb'
op|'='
number|'0'
op|','
name|'mem_kb'
op|'='
number|'0'
op|','
name|'num_cpu'
op|'='
number|'0'
op|','
nl|'\n'
name|'cpu_time_ns'
op|'='
number|'0'
op|','
name|'id'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a new Instance Info object\n\n        :param state: the running state, one of the power_state codes\n        :param max_mem_kb: (int) the maximum memory in KBytes allowed\n        :param mem_kb: (int) the memory in KBytes used by the instance\n        :param num_cpu: (int) the number of virtual CPUs for the instance\n        :param cpu_time_ns: (int) the CPU time used in nanoseconds\n        :param id: a unique ID for the instance\n        """'
newline|'\n'
name|'self'
op|'.'
name|'state'
op|'='
name|'state'
newline|'\n'
name|'self'
op|'.'
name|'max_mem_kb'
op|'='
name|'max_mem_kb'
newline|'\n'
name|'self'
op|'.'
name|'mem_kb'
op|'='
name|'mem_kb'
newline|'\n'
name|'self'
op|'.'
name|'num_cpu'
op|'='
name|'num_cpu'
newline|'\n'
name|'self'
op|'.'
name|'cpu_time_ns'
op|'='
name|'cpu_time_ns'
newline|'\n'
name|'self'
op|'.'
name|'id'
op|'='
name|'id'
newline|'\n'
nl|'\n'
DECL|member|__eq__
dedent|''
name|'def'
name|'__eq__'
op|'('
name|'self'
op|','
name|'other'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
name|'self'
op|'.'
name|'__class__'
op|'=='
name|'other'
op|'.'
name|'__class__'
name|'and'
nl|'\n'
name|'self'
op|'.'
name|'__dict__'
op|'=='
name|'other'
op|'.'
name|'__dict__'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_score_cpu_topology
dedent|''
dedent|''
name|'def'
name|'_score_cpu_topology'
op|'('
name|'topology'
op|','
name|'wanttopology'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Calculate score for the topology against a desired configuration\n\n    :param wanttopology: nova.objects.VirtCPUTopology instance for\n                         preferred topology\n\n    Calculate a score indicating how well this topology\n    matches against a preferred topology. A score of 3\n    indicates an exact match for sockets, cores and threads.\n    A score of 2 indicates a match of sockets & cores or\n    sockets & threads or cores and threads. A score of 1\n    indicates a match of sockets or cores or threads. A\n    score of 0 indicates no match\n\n    :returns: score in range 0 (worst) to 3 (best)\n    """'
newline|'\n'
nl|'\n'
name|'score'
op|'='
number|'0'
newline|'\n'
name|'if'
op|'('
name|'wanttopology'
op|'.'
name|'sockets'
op|'!='
op|'-'
number|'1'
name|'and'
nl|'\n'
name|'topology'
op|'.'
name|'sockets'
op|'=='
name|'wanttopology'
op|'.'
name|'sockets'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'score'
op|'='
name|'score'
op|'+'
number|'1'
newline|'\n'
dedent|''
name|'if'
op|'('
name|'wanttopology'
op|'.'
name|'cores'
op|'!='
op|'-'
number|'1'
name|'and'
nl|'\n'
name|'topology'
op|'.'
name|'cores'
op|'=='
name|'wanttopology'
op|'.'
name|'cores'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'score'
op|'='
name|'score'
op|'+'
number|'1'
newline|'\n'
dedent|''
name|'if'
op|'('
name|'wanttopology'
op|'.'
name|'threads'
op|'!='
op|'-'
number|'1'
name|'and'
nl|'\n'
name|'topology'
op|'.'
name|'threads'
op|'=='
name|'wanttopology'
op|'.'
name|'threads'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'score'
op|'='
name|'score'
op|'+'
number|'1'
newline|'\n'
dedent|''
name|'return'
name|'score'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_cpu_topology_constraints
dedent|''
name|'def'
name|'_get_cpu_topology_constraints'
op|'('
name|'flavor'
op|','
name|'image_meta'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Get the topology constraints declared in flavor or image\n\n    :param flavor: Flavor object to read extra specs from\n    :param image_meta: Image object to read image metadata from\n\n    Gets the topology constraints from the configuration defined\n    in the flavor extra specs or the image metadata. In the flavor\n    this will look for\n\n     hw:cpu_sockets - preferred socket count\n     hw:cpu_cores - preferred core count\n     hw:cpu_threads - preferred thread count\n     hw:cpu_maxsockets - maximum socket count\n     hw:cpu_maxcores - maximum core count\n     hw:cpu_maxthreads - maximum thread count\n\n    In the image metadata this will look at\n\n     hw_cpu_sockets - preferred socket count\n     hw_cpu_cores - preferred core count\n     hw_cpu_threads - preferred thread count\n     hw_cpu_maxsockets - maximum socket count\n     hw_cpu_maxcores - maximum core count\n     hw_cpu_maxthreads - maximum thread count\n\n    The image metadata must be strictly lower than any values\n    set in the flavor. All values are, however, optional.\n\n    This will return a pair of nova.objects.VirtCPUTopology instances,\n    the first giving the preferred socket/core/thread counts,\n    and the second giving the upper limits on socket/core/\n    thread counts.\n\n    exception.ImageVCPULimitsRangeExceeded will be raised\n    if the maximum counts set against the image exceed\n    the maximum counts set against the flavor\n\n    exception.ImageVCPUTopologyRangeExceeded will be raised\n    if the preferred counts set against the image exceed\n    the maximum counts set against the image or flavor\n\n    :returns: (preferred topology, maximum topology)\n    """'
newline|'\n'
nl|'\n'
comment|'# Obtain the absolute limits from the flavor'
nl|'\n'
name|'flvmaxsockets'
op|'='
name|'int'
op|'('
name|'flavor'
op|'.'
name|'extra_specs'
op|'.'
name|'get'
op|'('
nl|'\n'
string|'"hw:cpu_max_sockets"'
op|','
number|'65536'
op|')'
op|')'
newline|'\n'
name|'flvmaxcores'
op|'='
name|'int'
op|'('
name|'flavor'
op|'.'
name|'extra_specs'
op|'.'
name|'get'
op|'('
nl|'\n'
string|'"hw:cpu_max_cores"'
op|','
number|'65536'
op|')'
op|')'
newline|'\n'
name|'flvmaxthreads'
op|'='
name|'int'
op|'('
name|'flavor'
op|'.'
name|'extra_specs'
op|'.'
name|'get'
op|'('
nl|'\n'
string|'"hw:cpu_max_threads"'
op|','
number|'65536'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Flavor limits %(sockets)d:%(cores)d:%(threads)d"'
op|','
nl|'\n'
op|'{'
string|'"sockets"'
op|':'
name|'flvmaxsockets'
op|','
nl|'\n'
string|'"cores"'
op|':'
name|'flvmaxcores'
op|','
nl|'\n'
string|'"threads"'
op|':'
name|'flvmaxthreads'
op|'}'
op|')'
newline|'\n'
nl|'\n'
comment|'# Get any customized limits from the image'
nl|'\n'
name|'maxsockets'
op|'='
name|'int'
op|'('
name|'image_meta'
op|'.'
name|'get'
op|'('
string|'"properties"'
op|','
op|'{'
op|'}'
op|')'
nl|'\n'
op|'.'
name|'get'
op|'('
string|'"hw_cpu_max_sockets"'
op|','
name|'flvmaxsockets'
op|')'
op|')'
newline|'\n'
name|'maxcores'
op|'='
name|'int'
op|'('
name|'image_meta'
op|'.'
name|'get'
op|'('
string|'"properties"'
op|','
op|'{'
op|'}'
op|')'
nl|'\n'
op|'.'
name|'get'
op|'('
string|'"hw_cpu_max_cores"'
op|','
name|'flvmaxcores'
op|')'
op|')'
newline|'\n'
name|'maxthreads'
op|'='
name|'int'
op|'('
name|'image_meta'
op|'.'
name|'get'
op|'('
string|'"properties"'
op|','
op|'{'
op|'}'
op|')'
nl|'\n'
op|'.'
name|'get'
op|'('
string|'"hw_cpu_max_threads"'
op|','
name|'flvmaxthreads'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Image limits %(sockets)d:%(cores)d:%(threads)d"'
op|','
nl|'\n'
op|'{'
string|'"sockets"'
op|':'
name|'maxsockets'
op|','
nl|'\n'
string|'"cores"'
op|':'
name|'maxcores'
op|','
nl|'\n'
string|'"threads"'
op|':'
name|'maxthreads'
op|'}'
op|')'
newline|'\n'
nl|'\n'
comment|'# Image limits are not permitted to exceed the flavor'
nl|'\n'
comment|'# limits. ie they can only lower what the flavor defines'
nl|'\n'
name|'if'
op|'('
op|'('
name|'maxsockets'
op|'>'
name|'flvmaxsockets'
op|')'
name|'or'
nl|'\n'
op|'('
name|'maxcores'
op|'>'
name|'flvmaxcores'
op|')'
name|'or'
nl|'\n'
op|'('
name|'maxthreads'
op|'>'
name|'flvmaxthreads'
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'ImageVCPULimitsRangeExceeded'
op|'('
nl|'\n'
name|'sockets'
op|'='
name|'maxsockets'
op|','
nl|'\n'
name|'cores'
op|'='
name|'maxcores'
op|','
nl|'\n'
name|'threads'
op|'='
name|'maxthreads'
op|','
nl|'\n'
name|'maxsockets'
op|'='
name|'flvmaxsockets'
op|','
nl|'\n'
name|'maxcores'
op|'='
name|'flvmaxcores'
op|','
nl|'\n'
name|'maxthreads'
op|'='
name|'flvmaxthreads'
op|')'
newline|'\n'
nl|'\n'
comment|'# Get any default preferred topology from the flavor'
nl|'\n'
dedent|''
name|'flvsockets'
op|'='
name|'int'
op|'('
name|'flavor'
op|'.'
name|'extra_specs'
op|'.'
name|'get'
op|'('
string|'"hw:cpu_sockets"'
op|','
op|'-'
number|'1'
op|')'
op|')'
newline|'\n'
name|'flvcores'
op|'='
name|'int'
op|'('
name|'flavor'
op|'.'
name|'extra_specs'
op|'.'
name|'get'
op|'('
string|'"hw:cpu_cores"'
op|','
op|'-'
number|'1'
op|')'
op|')'
newline|'\n'
name|'flvthreads'
op|'='
name|'int'
op|'('
name|'flavor'
op|'.'
name|'extra_specs'
op|'.'
name|'get'
op|'('
string|'"hw:cpu_threads"'
op|','
op|'-'
number|'1'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Flavor pref %(sockets)d:%(cores)d:%(threads)d"'
op|','
nl|'\n'
op|'{'
string|'"sockets"'
op|':'
name|'flvsockets'
op|','
nl|'\n'
string|'"cores"'
op|':'
name|'flvcores'
op|','
nl|'\n'
string|'"threads"'
op|':'
name|'flvthreads'
op|'}'
op|')'
newline|'\n'
nl|'\n'
comment|'# If the image limits have reduced the flavor limits'
nl|'\n'
comment|'# we might need to discard the preferred topology'
nl|'\n'
comment|'# from the flavor'
nl|'\n'
name|'if'
op|'('
op|'('
name|'flvsockets'
op|'>'
name|'maxsockets'
op|')'
name|'or'
nl|'\n'
op|'('
name|'flvcores'
op|'>'
name|'maxcores'
op|')'
name|'or'
nl|'\n'
op|'('
name|'flvthreads'
op|'>'
name|'maxthreads'
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'flvsockets'
op|'='
name|'flvcores'
op|'='
name|'flvthreads'
op|'='
op|'-'
number|'1'
newline|'\n'
nl|'\n'
comment|'# Finally see if the image has provided a preferred'
nl|'\n'
comment|'# topology to use'
nl|'\n'
dedent|''
name|'sockets'
op|'='
name|'int'
op|'('
name|'image_meta'
op|'.'
name|'get'
op|'('
string|'"properties"'
op|','
op|'{'
op|'}'
op|')'
nl|'\n'
op|'.'
name|'get'
op|'('
string|'"hw_cpu_sockets"'
op|','
op|'-'
number|'1'
op|')'
op|')'
newline|'\n'
name|'cores'
op|'='
name|'int'
op|'('
name|'image_meta'
op|'.'
name|'get'
op|'('
string|'"properties"'
op|','
op|'{'
op|'}'
op|')'
nl|'\n'
op|'.'
name|'get'
op|'('
string|'"hw_cpu_cores"'
op|','
op|'-'
number|'1'
op|')'
op|')'
newline|'\n'
name|'threads'
op|'='
name|'int'
op|'('
name|'image_meta'
op|'.'
name|'get'
op|'('
string|'"properties"'
op|','
op|'{'
op|'}'
op|')'
nl|'\n'
op|'.'
name|'get'
op|'('
string|'"hw_cpu_threads"'
op|','
op|'-'
number|'1'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Image pref %(sockets)d:%(cores)d:%(threads)d"'
op|','
nl|'\n'
op|'{'
string|'"sockets"'
op|':'
name|'sockets'
op|','
nl|'\n'
string|'"cores"'
op|':'
name|'cores'
op|','
nl|'\n'
string|'"threads"'
op|':'
name|'threads'
op|'}'
op|')'
newline|'\n'
nl|'\n'
comment|'# Image topology is not permitted to exceed image/flavor'
nl|'\n'
comment|'# limits'
nl|'\n'
name|'if'
op|'('
op|'('
name|'sockets'
op|'>'
name|'maxsockets'
op|')'
name|'or'
nl|'\n'
op|'('
name|'cores'
op|'>'
name|'maxcores'
op|')'
name|'or'
nl|'\n'
op|'('
name|'threads'
op|'>'
name|'maxthreads'
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'ImageVCPUTopologyRangeExceeded'
op|'('
nl|'\n'
name|'sockets'
op|'='
name|'sockets'
op|','
nl|'\n'
name|'cores'
op|'='
name|'cores'
op|','
nl|'\n'
name|'threads'
op|'='
name|'threads'
op|','
nl|'\n'
name|'maxsockets'
op|'='
name|'maxsockets'
op|','
nl|'\n'
name|'maxcores'
op|'='
name|'maxcores'
op|','
nl|'\n'
name|'maxthreads'
op|'='
name|'maxthreads'
op|')'
newline|'\n'
nl|'\n'
comment|'# If no preferred topology was set against the image'
nl|'\n'
comment|'# then use the preferred topology from the flavor'
nl|'\n'
comment|"# We use 'and' not 'or', since if any value is set"
nl|'\n'
comment|'# against the image this invalidates the entire set'
nl|'\n'
comment|'# of values from the flavor'
nl|'\n'
dedent|''
name|'if'
name|'sockets'
op|'=='
op|'-'
number|'1'
name|'and'
name|'cores'
op|'=='
op|'-'
number|'1'
name|'and'
name|'threads'
op|'=='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'sockets'
op|'='
name|'flvsockets'
newline|'\n'
name|'cores'
op|'='
name|'flvcores'
newline|'\n'
name|'threads'
op|'='
name|'flvthreads'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Chosen %(sockets)d:%(cores)d:%(threads)d limits "'
nl|'\n'
string|'"%(maxsockets)d:%(maxcores)d:%(maxthreads)d"'
op|','
nl|'\n'
op|'{'
string|'"sockets"'
op|':'
name|'sockets'
op|','
string|'"cores"'
op|':'
name|'cores'
op|','
nl|'\n'
string|'"threads"'
op|':'
name|'threads'
op|','
string|'"maxsockets"'
op|':'
name|'maxsockets'
op|','
nl|'\n'
string|'"maxcores"'
op|':'
name|'maxcores'
op|','
string|'"maxthreads"'
op|':'
name|'maxthreads'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'return'
op|'('
name|'objects'
op|'.'
name|'VirtCPUTopology'
op|'('
name|'sockets'
op|'='
name|'sockets'
op|','
name|'cores'
op|'='
name|'cores'
op|','
nl|'\n'
name|'threads'
op|'='
name|'threads'
op|')'
op|','
nl|'\n'
name|'objects'
op|'.'
name|'VirtCPUTopology'
op|'('
name|'sockets'
op|'='
name|'maxsockets'
op|','
name|'cores'
op|'='
name|'maxcores'
op|','
nl|'\n'
name|'threads'
op|'='
name|'maxthreads'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_possible_cpu_topologies
dedent|''
name|'def'
name|'_get_possible_cpu_topologies'
op|'('
name|'vcpus'
op|','
name|'maxtopology'
op|','
nl|'\n'
name|'allow_threads'
op|','
name|'specified_threads'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Get a list of possible topologies for a vCPU count\n    :param vcpus: total number of CPUs for guest instance\n    :param maxtopology: nova.objects.VirtCPUTopology for upper limits\n    :param allow_threads: if the hypervisor supports CPU threads\n    :param specified_threads: if there is a specific request for threads we\n                              should attempt to honour\n\n    Given a total desired vCPU count and constraints on the\n    maximum number of sockets, cores and threads, return a\n    list of nova.objects.VirtCPUTopology instances that represent every\n    possible topology that satisfies the constraints.\n\n    exception.ImageVCPULimitsRangeImpossible is raised if\n    it is impossible to achieve the total vcpu count given\n    the maximum limits on sockets, cores & threads.\n\n    :returns: list of nova.objects.VirtCPUTopology instances\n    """'
newline|'\n'
nl|'\n'
comment|'# Clamp limits to number of vcpus to prevent'
nl|'\n'
comment|'# iterating over insanely large list'
nl|'\n'
name|'maxsockets'
op|'='
name|'min'
op|'('
name|'vcpus'
op|','
name|'maxtopology'
op|'.'
name|'sockets'
op|')'
newline|'\n'
name|'maxcores'
op|'='
name|'min'
op|'('
name|'vcpus'
op|','
name|'maxtopology'
op|'.'
name|'cores'
op|')'
newline|'\n'
name|'maxthreads'
op|'='
name|'min'
op|'('
name|'vcpus'
op|','
name|'maxtopology'
op|'.'
name|'threads'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'allow_threads'
op|':'
newline|'\n'
comment|"# NOTE (ndipanov): If we don't support threads - it doesn't matter that"
nl|'\n'
comment|'# they are specified by the NUMA logic.'
nl|'\n'
indent|'        '
name|'specified_threads'
op|'='
name|'None'
newline|'\n'
name|'maxthreads'
op|'='
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Build topologies for %(vcpus)d vcpu(s) "'
nl|'\n'
string|'"%(maxsockets)d:%(maxcores)d:%(maxthreads)d"'
op|','
nl|'\n'
op|'{'
string|'"vcpus"'
op|':'
name|'vcpus'
op|','
string|'"maxsockets"'
op|':'
name|'maxsockets'
op|','
nl|'\n'
string|'"maxcores"'
op|':'
name|'maxcores'
op|','
string|'"maxthreads"'
op|':'
name|'maxthreads'
op|'}'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_get_topology_for_vcpus
name|'def'
name|'_get_topology_for_vcpus'
op|'('
name|'vcpus'
op|','
name|'sockets'
op|','
name|'cores'
op|','
name|'threads'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'threads'
op|'*'
name|'cores'
op|'*'
name|'sockets'
op|'=='
name|'vcpus'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'objects'
op|'.'
name|'VirtCPUTopology'
op|'('
name|'sockets'
op|'='
name|'sockets'
op|','
nl|'\n'
name|'cores'
op|'='
name|'cores'
op|','
nl|'\n'
name|'threads'
op|'='
name|'threads'
op|')'
newline|'\n'
nl|'\n'
comment|'# Figure out all possible topologies that match'
nl|'\n'
comment|'# the required vcpus count and satisfy the declared'
nl|'\n'
comment|'# limits. If the total vCPU count were very high'
nl|'\n'
comment|'# it might be more efficient to factorize the vcpu'
nl|'\n'
comment|'# count and then only iterate over its factors, but'
nl|'\n'
comment|"# that's overkill right now"
nl|'\n'
dedent|''
dedent|''
name|'possible'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'s'
name|'in'
name|'range'
op|'('
number|'1'
op|','
name|'maxsockets'
op|'+'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'c'
name|'in'
name|'range'
op|'('
number|'1'
op|','
name|'maxcores'
op|'+'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'specified_threads'
op|':'
newline|'\n'
indent|'                '
name|'o'
op|'='
name|'_get_topology_for_vcpus'
op|'('
name|'vcpus'
op|','
name|'s'
op|','
name|'c'
op|','
name|'specified_threads'
op|')'
newline|'\n'
name|'if'
name|'o'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'possible'
op|'.'
name|'append'
op|'('
name|'o'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'t'
name|'in'
name|'range'
op|'('
number|'1'
op|','
name|'maxthreads'
op|'+'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'o'
op|'='
name|'_get_topology_for_vcpus'
op|'('
name|'vcpus'
op|','
name|'s'
op|','
name|'c'
op|','
name|'t'
op|')'
newline|'\n'
name|'if'
name|'o'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                        '
name|'possible'
op|'.'
name|'append'
op|'('
name|'o'
op|')'
newline|'\n'
nl|'\n'
comment|'# We want to'
nl|'\n'
comment|'#  - Minimize threads (ie larger sockets * cores is best)'
nl|'\n'
comment|'#  - Prefer sockets over cores'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'possible'
op|'='
name|'sorted'
op|'('
name|'possible'
op|','
name|'reverse'
op|'='
name|'True'
op|','
nl|'\n'
name|'key'
op|'='
name|'lambda'
name|'x'
op|':'
op|'('
name|'x'
op|'.'
name|'sockets'
op|'*'
name|'x'
op|'.'
name|'cores'
op|','
nl|'\n'
name|'x'
op|'.'
name|'sockets'
op|','
nl|'\n'
name|'x'
op|'.'
name|'threads'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Got %d possible topologies"'
op|','
name|'len'
op|'('
name|'possible'
op|')'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'possible'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'ImageVCPULimitsRangeImpossible'
op|'('
name|'vcpus'
op|'='
name|'vcpus'
op|','
nl|'\n'
name|'sockets'
op|'='
name|'maxsockets'
op|','
nl|'\n'
name|'cores'
op|'='
name|'maxcores'
op|','
nl|'\n'
name|'threads'
op|'='
name|'maxthreads'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'possible'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_sort_possible_cpu_topologies
dedent|''
name|'def'
name|'_sort_possible_cpu_topologies'
op|'('
name|'possible'
op|','
name|'wanttopology'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Sort the topologies in order of preference\n    :param possible: list of nova.objects.VirtCPUTopology instances\n    :param wanttopology: nova.objects.VirtCPUTopology for preferred\n                         topology\n\n    This takes the list of possible topologies and resorts\n    it such that those configurations which most closely\n    match the preferred topology are first.\n\n    :returns: sorted list of nova.objects.VirtCPUTopology instances\n    """'
newline|'\n'
nl|'\n'
comment|'# Look at possible topologies and score them according'
nl|'\n'
comment|'# to how well they match the preferred topologies'
nl|'\n'
comment|"# We don't use python's sort(), since we want to"
nl|'\n'
comment|'# preserve the sorting done when populating the'
nl|'\n'
comment|"# 'possible' list originally"
nl|'\n'
name|'scores'
op|'='
name|'collections'
op|'.'
name|'defaultdict'
op|'('
name|'list'
op|')'
newline|'\n'
name|'for'
name|'topology'
name|'in'
name|'possible'
op|':'
newline|'\n'
indent|'        '
name|'score'
op|'='
name|'_score_cpu_topology'
op|'('
name|'topology'
op|','
name|'wanttopology'
op|')'
newline|'\n'
name|'scores'
op|'['
name|'score'
op|']'
op|'.'
name|'append'
op|'('
name|'topology'
op|')'
newline|'\n'
nl|'\n'
comment|'# Build list of all possible topologies sorted'
nl|'\n'
comment|'# by the match score, best match first'
nl|'\n'
dedent|''
name|'desired'
op|'='
op|'['
op|']'
newline|'\n'
name|'desired'
op|'.'
name|'extend'
op|'('
name|'scores'
op|'['
number|'3'
op|']'
op|')'
newline|'\n'
name|'desired'
op|'.'
name|'extend'
op|'('
name|'scores'
op|'['
number|'2'
op|']'
op|')'
newline|'\n'
name|'desired'
op|'.'
name|'extend'
op|'('
name|'scores'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
name|'desired'
op|'.'
name|'extend'
op|'('
name|'scores'
op|'['
number|'0'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'desired'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_threads_requested_by_user
dedent|''
name|'def'
name|'_threads_requested_by_user'
op|'('
name|'flavor'
op|','
name|'image_meta'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'keys'
op|'='
op|'('
string|'"cpu_threads"'
op|','
string|'"cpu_maxthreads"'
op|')'
newline|'\n'
name|'if'
name|'any'
op|'('
name|'flavor'
op|'.'
name|'extra_specs'
op|'.'
name|'get'
op|'('
string|'"hw:%s"'
op|'%'
name|'key'
op|')'
name|'for'
name|'key'
name|'in'
name|'keys'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'any'
op|'('
name|'image_meta'
op|'.'
name|'get'
op|'('
string|'"properties"'
op|','
op|'{'
op|'}'
op|')'
op|'.'
name|'get'
op|'('
string|'"hw_%s"'
op|'%'
name|'key'
op|')'
nl|'\n'
name|'for'
name|'key'
name|'in'
name|'keys'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_desirable_cpu_topologies
dedent|''
name|'def'
name|'_get_desirable_cpu_topologies'
op|'('
name|'flavor'
op|','
name|'image_meta'
op|','
name|'allow_threads'
op|'='
name|'True'
op|','
nl|'\n'
name|'numa_topology'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Get desired CPU topologies according to settings\n\n    :param flavor: Flavor object to query extra specs from\n    :param image_meta: ImageMeta object to query properties from\n    :param allow_threads: if the hypervisor supports CPU threads\n    :param numa_topology: InstanceNUMATopology object that may contain\n                          additional topology constraints (such as threading\n                          information) that we should consider\n\n    Look at the properties set in the flavor extra specs and\n    the image metadata and build up a list of all possible\n    valid CPU topologies that can be used in the guest. Then\n    return this list sorted in order of preference.\n\n    :returns: sorted list of nova.objects.VirtCPUTopology instances\n    """'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Getting desirable topologies for flavor %(flavor)s "'
nl|'\n'
string|'"and image_meta %(image_meta)s"'
op|','
nl|'\n'
op|'{'
string|'"flavor"'
op|':'
name|'flavor'
op|','
string|'"image_meta"'
op|':'
name|'image_meta'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'preferred'
op|','
name|'maximum'
op|'='
name|'_get_cpu_topology_constraints'
op|'('
name|'flavor'
op|','
name|'image_meta'
op|')'
newline|'\n'
nl|'\n'
name|'specified_threads'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'numa_topology'
op|':'
newline|'\n'
indent|'        '
name|'min_requested_threads'
op|'='
name|'None'
newline|'\n'
name|'cell_topologies'
op|'='
op|'['
name|'cell'
op|'.'
name|'cpu_topology'
name|'for'
name|'cell'
name|'in'
name|'numa_topology'
op|'.'
name|'cells'
nl|'\n'
name|'if'
name|'cell'
op|'.'
name|'cpu_topology'
op|']'
newline|'\n'
name|'if'
name|'cell_topologies'
op|':'
newline|'\n'
indent|'            '
name|'min_requested_threads'
op|'='
name|'min'
op|'('
nl|'\n'
name|'topo'
op|'.'
name|'threads'
name|'for'
name|'topo'
name|'in'
name|'cell_topologies'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'min_requested_threads'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'_threads_requested_by_user'
op|'('
name|'flavor'
op|','
name|'image_meta'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'min_requested_threads'
op|'='
name|'min'
op|'('
name|'preferred'
op|'.'
name|'threads'
op|','
nl|'\n'
name|'min_requested_threads'
op|')'
newline|'\n'
dedent|''
name|'specified_threads'
op|'='
name|'max'
op|'('
number|'1'
op|','
name|'min_requested_threads'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'possible'
op|'='
name|'_get_possible_cpu_topologies'
op|'('
name|'flavor'
op|'.'
name|'vcpus'
op|','
nl|'\n'
name|'maximum'
op|','
nl|'\n'
name|'allow_threads'
op|','
nl|'\n'
name|'specified_threads'
op|')'
newline|'\n'
name|'desired'
op|'='
name|'_sort_possible_cpu_topologies'
op|'('
name|'possible'
op|','
name|'preferred'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'desired'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_best_cpu_topology
dedent|''
name|'def'
name|'get_best_cpu_topology'
op|'('
name|'flavor'
op|','
name|'image_meta'
op|','
name|'allow_threads'
op|'='
name|'True'
op|','
nl|'\n'
name|'numa_topology'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Get best CPU topology according to settings\n\n    :param flavor: Flavor object to query extra specs from\n    :param image_meta: ImageMeta object to query properties from\n    :param allow_threads: if the hypervisor supports CPU threads\n    :param numa_topology: InstanceNUMATopology object that may contain\n                          additional topology constraints (such as threading\n                          information) that we should consider\n\n    Look at the properties set in the flavor extra specs and\n    the image metadata and build up a list of all possible\n    valid CPU topologies that can be used in the guest. Then\n    return the best topology to use\n\n    :returns: a nova.objects.VirtCPUTopology instance for best topology\n    """'
newline|'\n'
nl|'\n'
name|'return'
name|'_get_desirable_cpu_topologies'
op|'('
name|'flavor'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'allow_threads'
op|','
name|'numa_topology'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|VirtNUMATopologyCell
dedent|''
name|'class'
name|'VirtNUMATopologyCell'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Class for reporting NUMA resources in a cell\n\n    The VirtNUMATopologyCell class represents the\n    hardware resources present in a NUMA cell.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'id'
op|','
name|'cpuset'
op|','
name|'memory'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a new NUMA Cell\n\n        :param id: integer identifier of cell\n        :param cpuset: set containing list of CPU indexes\n        :param memory: RAM measured in MiB\n\n        Creates a new NUMA cell object to record the hardware\n        resources.\n\n        :returns: a new NUMA cell object\n        """'
newline|'\n'
nl|'\n'
name|'super'
op|'('
name|'VirtNUMATopologyCell'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'id'
op|'='
name|'id'
newline|'\n'
name|'self'
op|'.'
name|'cpuset'
op|'='
name|'cpuset'
newline|'\n'
name|'self'
op|'.'
name|'memory'
op|'='
name|'memory'
newline|'\n'
nl|'\n'
DECL|member|_to_dict
dedent|''
name|'def'
name|'_to_dict'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'{'
string|"'cpus'"
op|':'
name|'format_cpu_spec'
op|'('
name|'self'
op|'.'
name|'cpuset'
op|','
name|'allow_ranges'
op|'='
name|'False'
op|')'
op|','
nl|'\n'
string|"'mem'"
op|':'
op|'{'
string|"'total'"
op|':'
name|'self'
op|'.'
name|'memory'
op|'}'
op|','
nl|'\n'
string|"'id'"
op|':'
name|'self'
op|'.'
name|'id'
op|'}'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|_from_dict
name|'def'
name|'_from_dict'
op|'('
name|'cls'
op|','
name|'data_dict'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'cpuset'
op|'='
name|'parse_cpu_spec'
op|'('
name|'data_dict'
op|'.'
name|'get'
op|'('
string|"'cpus'"
op|','
string|"''"
op|')'
op|')'
newline|'\n'
name|'memory'
op|'='
name|'data_dict'
op|'.'
name|'get'
op|'('
string|"'mem'"
op|','
op|'{'
op|'}'
op|')'
op|'.'
name|'get'
op|'('
string|"'total'"
op|','
number|'0'
op|')'
newline|'\n'
name|'cell_id'
op|'='
name|'data_dict'
op|'.'
name|'get'
op|'('
string|"'id'"
op|')'
newline|'\n'
name|'return'
name|'cls'
op|'('
name|'cell_id'
op|','
name|'cpuset'
op|','
name|'memory'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|VirtNUMATopologyCellLimit
dedent|''
dedent|''
name|'class'
name|'VirtNUMATopologyCellLimit'
op|'('
name|'VirtNUMATopologyCell'
op|')'
op|':'
newline|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'id'
op|','
name|'cpuset'
op|','
name|'memory'
op|','
name|'cpu_limit'
op|','
name|'memory_limit'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a new NUMA Cell with usage\n\n        :param id: integer identifier of cell\n        :param cpuset: set containing list of CPU indexes\n        :param memory: RAM measured in MiB\n        :param cpu_limit: maximum number of  CPUs allocated\n        :param memory_limit: maxumum RAM allocated in MiB\n\n        Creates a new NUMA cell object to represent the max hardware\n        resources and utilization. The number of CPUs specified\n        by the @cpu_usage parameter may be larger than the number\n        of bits set in @cpuset if CPU overcommit is used. Likewise\n        the amount of RAM specified by the @memory_limit parameter\n        may be larger than the available RAM in @memory if RAM\n        overcommit is used.\n\n        :returns: a new NUMA cell object\n        """'
newline|'\n'
nl|'\n'
name|'super'
op|'('
name|'VirtNUMATopologyCellLimit'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
nl|'\n'
name|'id'
op|','
name|'cpuset'
op|','
name|'memory'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'cpu_limit'
op|'='
name|'cpu_limit'
newline|'\n'
name|'self'
op|'.'
name|'memory_limit'
op|'='
name|'memory_limit'
newline|'\n'
nl|'\n'
DECL|member|_to_dict
dedent|''
name|'def'
name|'_to_dict'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'data_dict'
op|'='
name|'super'
op|'('
name|'VirtNUMATopologyCellLimit'
op|','
name|'self'
op|')'
op|'.'
name|'_to_dict'
op|'('
op|')'
newline|'\n'
name|'data_dict'
op|'['
string|"'mem'"
op|']'
op|'['
string|"'limit'"
op|']'
op|'='
name|'self'
op|'.'
name|'memory_limit'
newline|'\n'
name|'data_dict'
op|'['
string|"'cpu_limit'"
op|']'
op|'='
name|'self'
op|'.'
name|'cpu_limit'
newline|'\n'
name|'return'
name|'data_dict'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|_from_dict
name|'def'
name|'_from_dict'
op|'('
name|'cls'
op|','
name|'data_dict'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'cpuset'
op|'='
name|'parse_cpu_spec'
op|'('
name|'data_dict'
op|'.'
name|'get'
op|'('
string|"'cpus'"
op|','
string|"''"
op|')'
op|')'
newline|'\n'
name|'memory'
op|'='
name|'data_dict'
op|'.'
name|'get'
op|'('
string|"'mem'"
op|','
op|'{'
op|'}'
op|')'
op|'.'
name|'get'
op|'('
string|"'total'"
op|','
number|'0'
op|')'
newline|'\n'
name|'cpu_limit'
op|'='
name|'data_dict'
op|'.'
name|'get'
op|'('
string|"'cpu_limit'"
op|','
name|'len'
op|'('
name|'cpuset'
op|')'
op|')'
newline|'\n'
name|'memory_limit'
op|'='
name|'data_dict'
op|'.'
name|'get'
op|'('
string|"'mem'"
op|','
op|'{'
op|'}'
op|')'
op|'.'
name|'get'
op|'('
string|"'limit'"
op|','
name|'memory'
op|')'
newline|'\n'
name|'cell_id'
op|'='
name|'data_dict'
op|'.'
name|'get'
op|'('
string|"'id'"
op|')'
newline|'\n'
name|'return'
name|'cls'
op|'('
name|'cell_id'
op|','
name|'cpuset'
op|','
name|'memory'
op|','
name|'cpu_limit'
op|','
name|'memory_limit'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_numa_cell_supports_pagesize_request
dedent|''
dedent|''
name|'def'
name|'_numa_cell_supports_pagesize_request'
op|'('
name|'host_cell'
op|','
name|'inst_cell'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Determines whether the cell can accept the request.\n\n    :param host_cell: host cell to fit the instance cell onto\n    :param inst_cell: instance cell we want to fit\n\n    :returns: The page size able to be handled by host_cell\n    """'
newline|'\n'
name|'avail_pagesize'
op|'='
op|'['
name|'page'
op|'.'
name|'size_kb'
name|'for'
name|'page'
name|'in'
name|'host_cell'
op|'.'
name|'mempages'
op|']'
newline|'\n'
name|'avail_pagesize'
op|'.'
name|'sort'
op|'('
name|'reverse'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
DECL|function|verify_pagesizes
name|'def'
name|'verify_pagesizes'
op|'('
name|'host_cell'
op|','
name|'inst_cell'
op|','
name|'avail_pagesize'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'inst_cell_mem'
op|'='
name|'inst_cell'
op|'.'
name|'memory'
op|'*'
name|'units'
op|'.'
name|'Ki'
newline|'\n'
name|'for'
name|'pagesize'
name|'in'
name|'avail_pagesize'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'host_cell'
op|'.'
name|'can_fit_hugepages'
op|'('
name|'pagesize'
op|','
name|'inst_cell_mem'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'pagesize'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'inst_cell'
op|'.'
name|'pagesize'
op|'=='
name|'MEMPAGES_SMALL'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'verify_pagesizes'
op|'('
name|'host_cell'
op|','
name|'inst_cell'
op|','
name|'avail_pagesize'
op|'['
op|'-'
number|'1'
op|':'
op|']'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'inst_cell'
op|'.'
name|'pagesize'
op|'=='
name|'MEMPAGES_LARGE'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'verify_pagesizes'
op|'('
name|'host_cell'
op|','
name|'inst_cell'
op|','
name|'avail_pagesize'
op|'['
op|':'
op|'-'
number|'1'
op|']'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'inst_cell'
op|'.'
name|'pagesize'
op|'=='
name|'MEMPAGES_ANY'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'verify_pagesizes'
op|'('
name|'host_cell'
op|','
name|'inst_cell'
op|','
name|'avail_pagesize'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'verify_pagesizes'
op|'('
name|'host_cell'
op|','
name|'inst_cell'
op|','
op|'['
name|'inst_cell'
op|'.'
name|'pagesize'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_pack_instance_onto_cores
dedent|''
dedent|''
name|'def'
name|'_pack_instance_onto_cores'
op|'('
name|'available_siblings'
op|','
name|'instance_cell'
op|','
name|'host_cell_id'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Pack an instance onto a set of siblings\n\n    :param available_siblings: list of sets of CPU id\'s - available\n                               siblings per core\n    :param instance_cell: An instance of objects.InstanceNUMACell describing\n                          the pinning requirements of the instance\n\n    :returns: An instance of objects.InstanceNUMACell containing the pinning\n              information, and potentially a new topology to be exposed to the\n              instance. None if there is no valid way to satisfy the sibling\n              requirements for the instance.\n\n    This method will calculate the pinning for the given instance and it\'s\n    topology, making sure that hyperthreads of the instance match up with\n    those of the host when the pinning takes effect.\n    """'
newline|'\n'
nl|'\n'
comment|"# We build up a data structure 'can_pack' that answers the question:"
nl|'\n'
comment|"# 'Given the number of threads I want to pack, give me a list of all"
nl|'\n'
comment|"# the available sibling sets that can accommodate it'"
nl|'\n'
name|'can_pack'
op|'='
name|'collections'
op|'.'
name|'defaultdict'
op|'('
name|'list'
op|')'
newline|'\n'
name|'for'
name|'sib'
name|'in'
name|'available_siblings'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'threads_no'
name|'in'
name|'range'
op|'('
number|'1'
op|','
name|'len'
op|'('
name|'sib'
op|')'
op|'+'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'can_pack'
op|'['
name|'threads_no'
op|']'
op|'.'
name|'append'
op|'('
name|'sib'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_can_pack_instance_cell
dedent|''
dedent|''
name|'def'
name|'_can_pack_instance_cell'
op|'('
name|'instance_cell'
op|','
name|'threads_per_core'
op|','
name|'cores_list'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Determines if instance cell can fit an avail set of cores."""'
newline|'\n'
nl|'\n'
name|'if'
name|'threads_per_core'
op|'*'
name|'len'
op|'('
name|'cores_list'
op|')'
op|'<'
name|'len'
op|'('
name|'instance_cell'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'if'
name|'instance_cell'
op|'.'
name|'siblings'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'instance_cell'
op|'.'
name|'cpu_topology'
op|'.'
name|'threads'
op|'<='
name|'threads_per_core'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'len'
op|'('
name|'instance_cell'
op|')'
op|'%'
name|'threads_per_core'
op|'=='
number|'0'
newline|'\n'
nl|'\n'
comment|'# We iterate over the can_pack dict in descending order of cores that'
nl|'\n'
comment|'# can be packed - an attempt to get even distribution over time'
nl|'\n'
dedent|''
dedent|''
name|'for'
name|'cores_per_sib'
op|','
name|'sib_list'
name|'in'
name|'sorted'
op|'('
nl|'\n'
op|'('
name|'t'
name|'for'
name|'t'
name|'in'
name|'can_pack'
op|'.'
name|'items'
op|'('
op|')'
op|')'
op|','
name|'reverse'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'_can_pack_instance_cell'
op|'('
name|'instance_cell'
op|','
nl|'\n'
name|'cores_per_sib'
op|','
name|'sib_list'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'sliced_sibs'
op|'='
name|'map'
op|'('
name|'lambda'
name|'s'
op|':'
name|'list'
op|'('
name|'s'
op|')'
op|'['
op|':'
name|'cores_per_sib'
op|']'
op|','
name|'sib_list'
op|')'
newline|'\n'
name|'if'
name|'instance_cell'
op|'.'
name|'siblings'
op|':'
newline|'\n'
indent|'                '
name|'pinning'
op|'='
name|'zip'
op|'('
name|'itertools'
op|'.'
name|'chain'
op|'('
op|'*'
name|'instance_cell'
op|'.'
name|'siblings'
op|')'
op|','
nl|'\n'
name|'itertools'
op|'.'
name|'chain'
op|'('
op|'*'
name|'sliced_sibs'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'pinning'
op|'='
name|'zip'
op|'('
name|'sorted'
op|'('
name|'instance_cell'
op|'.'
name|'cpuset'
op|')'
op|','
nl|'\n'
name|'itertools'
op|'.'
name|'chain'
op|'('
op|'*'
name|'sliced_sibs'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'topology'
op|'='
op|'('
name|'instance_cell'
op|'.'
name|'cpu_topology'
name|'or'
nl|'\n'
name|'objects'
op|'.'
name|'VirtCPUTopology'
op|'('
name|'sockets'
op|'='
number|'1'
op|','
nl|'\n'
name|'cores'
op|'='
name|'len'
op|'('
name|'sliced_sibs'
op|')'
op|','
nl|'\n'
name|'threads'
op|'='
name|'cores_per_sib'
op|')'
op|')'
newline|'\n'
name|'instance_cell'
op|'.'
name|'pin_vcpus'
op|'('
op|'*'
name|'pinning'
op|')'
newline|'\n'
name|'instance_cell'
op|'.'
name|'cpu_topology'
op|'='
name|'topology'
newline|'\n'
name|'instance_cell'
op|'.'
name|'id'
op|'='
name|'host_cell_id'
newline|'\n'
name|'return'
name|'instance_cell'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_numa_fit_instance_cell_with_pinning
dedent|''
dedent|''
dedent|''
name|'def'
name|'_numa_fit_instance_cell_with_pinning'
op|'('
name|'host_cell'
op|','
name|'instance_cell'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Figure out if cells can be pinned to a host cell and return details\n\n    :param host_cell: objects.NUMACell instance - the host cell that\n                      the isntance should be pinned to\n    :param instance_cell: objects.InstanceNUMACell instance without any\n                          pinning information\n\n    :returns: objects.InstanceNUMACell instance with pinning information,\n              or None if instance cannot be pinned to the given host\n    """'
newline|'\n'
name|'if'
op|'('
name|'host_cell'
op|'.'
name|'avail_cpus'
op|'<'
name|'len'
op|'('
name|'instance_cell'
op|'.'
name|'cpuset'
op|')'
name|'or'
nl|'\n'
name|'host_cell'
op|'.'
name|'avail_memory'
op|'<'
name|'instance_cell'
op|'.'
name|'memory'
op|')'
op|':'
newline|'\n'
comment|'# If we do not have enough CPUs available or not enough memory'
nl|'\n'
comment|'# on the host cell, we quit early (no oversubscription).'
nl|'\n'
indent|'        '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'host_cell'
op|'.'
name|'siblings'
op|':'
newline|'\n'
comment|"# Instance requires hyperthreading in it's topology"
nl|'\n'
indent|'        '
name|'if'
name|'instance_cell'
op|'.'
name|'cpu_topology'
name|'and'
name|'instance_cell'
op|'.'
name|'siblings'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'_pack_instance_onto_cores'
op|'('
name|'host_cell'
op|'.'
name|'free_siblings'
op|','
nl|'\n'
name|'instance_cell'
op|','
name|'host_cell'
op|'.'
name|'id'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Try to pack the instance cell in one core'
nl|'\n'
indent|'            '
name|'largest_free_sibling_set'
op|'='
name|'sorted'
op|'('
nl|'\n'
name|'host_cell'
op|'.'
name|'free_siblings'
op|','
name|'key'
op|'='
name|'len'
op|')'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
name|'if'
op|'('
name|'len'
op|'('
name|'instance_cell'
op|'.'
name|'cpuset'
op|')'
op|'<='
nl|'\n'
name|'len'
op|'('
name|'largest_free_sibling_set'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'_pack_instance_onto_cores'
op|'('
nl|'\n'
op|'['
name|'largest_free_sibling_set'
op|']'
op|','
name|'instance_cell'
op|','
name|'host_cell'
op|'.'
name|'id'
op|')'
newline|'\n'
nl|'\n'
comment|"# We can't to pack it onto one core so try with avail siblings"
nl|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'_pack_instance_onto_cores'
op|'('
nl|'\n'
name|'host_cell'
op|'.'
name|'free_siblings'
op|','
name|'instance_cell'
op|','
name|'host_cell'
op|'.'
name|'id'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Straightforward to pin to available cpus when there is no'
nl|'\n'
comment|'# hyperthreading on the host'
nl|'\n'
indent|'        '
name|'return'
name|'_pack_instance_onto_cores'
op|'('
nl|'\n'
op|'['
name|'host_cell'
op|'.'
name|'free_cpus'
op|']'
op|','
name|'instance_cell'
op|','
name|'host_cell'
op|'.'
name|'id'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_numa_fit_instance_cell
dedent|''
dedent|''
name|'def'
name|'_numa_fit_instance_cell'
op|'('
name|'host_cell'
op|','
name|'instance_cell'
op|','
name|'limit_cell'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Check if a instance cell can fit and set it\'s cell id\n\n    :param host_cell: host cell to fit the instance cell onto\n    :param instance_cell: instance cell we want to fit\n    :param limit_cell: cell with limits of the host_cell if any\n\n    Make sure we can fit the instance cell onto a host cell and if so,\n    return a new objects.InstanceNUMACell with the id set to that of\n    the host, or None if the cell exceeds the limits of the host\n\n    :returns: a new instance cell or None\n    """'
newline|'\n'
comment|'# NOTE (ndipanov): do not allow an instance to overcommit against'
nl|'\n'
comment|'# itself on any NUMA cell'
nl|'\n'
name|'if'
op|'('
name|'instance_cell'
op|'.'
name|'memory'
op|'>'
name|'host_cell'
op|'.'
name|'memory'
name|'or'
nl|'\n'
name|'len'
op|'('
name|'instance_cell'
op|'.'
name|'cpuset'
op|')'
op|'>'
name|'len'
op|'('
name|'host_cell'
op|'.'
name|'cpuset'
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'instance_cell'
op|'.'
name|'cpu_pinning_requested'
op|':'
newline|'\n'
indent|'        '
name|'new_instance_cell'
op|'='
name|'_numa_fit_instance_cell_with_pinning'
op|'('
nl|'\n'
name|'host_cell'
op|','
name|'instance_cell'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'new_instance_cell'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'new_instance_cell'
op|'.'
name|'pagesize'
op|'='
name|'instance_cell'
op|'.'
name|'pagesize'
newline|'\n'
name|'instance_cell'
op|'='
name|'new_instance_cell'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'limit_cell'
op|':'
newline|'\n'
indent|'        '
name|'memory_usage'
op|'='
name|'host_cell'
op|'.'
name|'memory_usage'
op|'+'
name|'instance_cell'
op|'.'
name|'memory'
newline|'\n'
name|'cpu_usage'
op|'='
name|'host_cell'
op|'.'
name|'cpu_usage'
op|'+'
name|'len'
op|'('
name|'instance_cell'
op|'.'
name|'cpuset'
op|')'
newline|'\n'
name|'if'
op|'('
name|'memory_usage'
op|'>'
name|'limit_cell'
op|'.'
name|'memory_limit'
name|'or'
nl|'\n'
name|'cpu_usage'
op|'>'
name|'limit_cell'
op|'.'
name|'cpu_limit'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'pagesize'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'instance_cell'
op|'.'
name|'pagesize'
op|':'
newline|'\n'
indent|'        '
name|'pagesize'
op|'='
name|'_numa_cell_supports_pagesize_request'
op|'('
nl|'\n'
name|'host_cell'
op|','
name|'instance_cell'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'pagesize'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'instance_cell'
op|'.'
name|'id'
op|'='
name|'host_cell'
op|'.'
name|'id'
newline|'\n'
name|'instance_cell'
op|'.'
name|'pagesize'
op|'='
name|'pagesize'
newline|'\n'
name|'return'
name|'instance_cell'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|VirtNUMATopology
dedent|''
name|'class'
name|'VirtNUMATopology'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Base class for tracking NUMA topology information\n\n    The VirtNUMATopology class represents the NUMA hardware\n    topology for memory and CPUs in any machine. It is\n    later specialized for handling either guest instance\n    or compute host NUMA topology.\n    """'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'cells'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a new NUMA topology object\n\n        :param cells: list of VirtNUMATopologyCell instances\n\n        """'
newline|'\n'
nl|'\n'
name|'super'
op|'('
name|'VirtNUMATopology'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'cells'
op|'='
name|'cells'
name|'or'
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|__len__
dedent|''
name|'def'
name|'__len__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Defined so that boolean testing works the same as for lists."""'
newline|'\n'
name|'return'
name|'len'
op|'('
name|'self'
op|'.'
name|'cells'
op|')'
newline|'\n'
nl|'\n'
DECL|member|__repr__
dedent|''
name|'def'
name|'__repr__'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|'"<%s: %s>"'
op|'%'
op|'('
name|'self'
op|'.'
name|'__class__'
op|'.'
name|'__name__'
op|','
name|'str'
op|'('
name|'self'
op|'.'
name|'_to_dict'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_to_dict
dedent|''
name|'def'
name|'_to_dict'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'{'
string|"'cells'"
op|':'
op|'['
name|'cell'
op|'.'
name|'_to_dict'
op|'('
op|')'
name|'for'
name|'cell'
name|'in'
name|'self'
op|'.'
name|'cells'
op|']'
op|'}'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|_from_dict
name|'def'
name|'_from_dict'
op|'('
name|'cls'
op|','
name|'data_dict'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'cls'
op|'('
name|'cells'
op|'='
op|'['
name|'cls'
op|'.'
name|'cell_class'
op|'.'
name|'_from_dict'
op|'('
name|'cell_dict'
op|')'
nl|'\n'
name|'for'
name|'cell_dict'
name|'in'
name|'data_dict'
op|'.'
name|'get'
op|'('
string|"'cells'"
op|','
op|'['
op|']'
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|to_json
dedent|''
name|'def'
name|'to_json'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
name|'self'
op|'.'
name|'_to_dict'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|from_json
name|'def'
name|'from_json'
op|'('
name|'cls'
op|','
name|'json_string'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'cls'
op|'.'
name|'_from_dict'
op|'('
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'json_string'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_numa_get_flavor_or_image_prop
dedent|''
dedent|''
name|'def'
name|'_numa_get_flavor_or_image_prop'
op|'('
name|'flavor'
op|','
name|'image_meta'
op|','
name|'propname'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the value of propname from flavor or image\n\n    :param flavor: a Flavor object or dict of instance type information\n    :param image_meta: a dict of image information\n\n    :returns: a value or None\n    """'
newline|'\n'
name|'flavor_val'
op|'='
name|'flavor'
op|'.'
name|'get'
op|'('
string|"'extra_specs'"
op|','
op|'{'
op|'}'
op|')'
op|'.'
name|'get'
op|'('
string|'"hw:"'
op|'+'
name|'propname'
op|')'
newline|'\n'
name|'image_val'
op|'='
op|'('
name|'image_meta'
name|'or'
op|'{'
op|'}'
op|')'
op|'.'
name|'get'
op|'('
string|'"properties"'
op|','
op|'{'
op|'}'
op|')'
op|'.'
name|'get'
op|'('
string|'"hw_"'
op|'+'
name|'propname'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'flavor_val'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'image_val'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'ImageNUMATopologyForbidden'
op|'('
nl|'\n'
name|'name'
op|'='
string|"'hw_'"
op|'+'
name|'propname'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'flavor_val'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'image_val'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_numa_get_pagesize_constraints
dedent|''
dedent|''
name|'def'
name|'_numa_get_pagesize_constraints'
op|'('
name|'flavor'
op|','
name|'image_meta'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the requested memory page size\n\n    :param flavor: a Flavor object to read extra specs from\n    :param image_meta: an Image object to read meta data from\n\n    :raises: MemoryPagesSizeInvalid or MemoryPageSizeForbidden\n    :returns: a page size requested or MEMPAGES_*\n    """'
newline|'\n'
nl|'\n'
DECL|function|check_and_return_pages_size
name|'def'
name|'check_and_return_pages_size'
op|'('
name|'request'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'request'
op|'=='
string|'"any"'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'MEMPAGES_ANY'
newline|'\n'
dedent|''
name|'elif'
name|'request'
op|'=='
string|'"large"'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'MEMPAGES_LARGE'
newline|'\n'
dedent|''
name|'elif'
name|'request'
op|'=='
string|'"small"'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'MEMPAGES_SMALL'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'request'
op|'='
name|'int'
op|'('
name|'request'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                '
name|'request'
op|'='
number|'0'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'request'
op|'<='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'MemoryPageSizeInvalid'
op|'('
name|'pagesize'
op|'='
name|'request'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'request'
newline|'\n'
nl|'\n'
dedent|''
name|'image_meta_prop'
op|'='
op|'('
name|'image_meta'
name|'or'
op|'{'
op|'}'
op|')'
op|'.'
name|'get'
op|'('
string|'"properties"'
op|','
op|'{'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'flavor_request'
op|'='
name|'flavor'
op|'.'
name|'get'
op|'('
string|"'extra_specs'"
op|','
op|'{'
op|'}'
op|')'
op|'.'
name|'get'
op|'('
string|'"hw:mem_page_size"'
op|','
string|'""'
op|')'
newline|'\n'
name|'image_request'
op|'='
name|'image_meta_prop'
op|'.'
name|'get'
op|'('
string|'"hw_mem_page_size"'
op|','
string|'""'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'flavor_request'
name|'and'
name|'image_request'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'MemoryPageSizeForbidden'
op|'('
nl|'\n'
name|'pagesize'
op|'='
name|'image_request'
op|','
nl|'\n'
name|'against'
op|'='
string|'"<empty>"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'flavor_request'
op|':'
newline|'\n'
comment|'# Nothing was specified for hugepages,'
nl|'\n'
comment|"# let's the default process running."
nl|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'pagesize'
op|'='
name|'check_and_return_pages_size'
op|'('
name|'flavor_request'
op|')'
newline|'\n'
name|'if'
name|'image_request'
name|'and'
op|'('
name|'pagesize'
name|'in'
op|'('
name|'MEMPAGES_ANY'
op|','
name|'MEMPAGES_LARGE'
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'check_and_return_pages_size'
op|'('
name|'image_request'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'image_request'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'MemoryPageSizeForbidden'
op|'('
nl|'\n'
name|'pagesize'
op|'='
name|'image_request'
op|','
nl|'\n'
name|'against'
op|'='
name|'flavor_request'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'pagesize'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_numa_get_constraints_manual
dedent|''
name|'def'
name|'_numa_get_constraints_manual'
op|'('
name|'nodes'
op|','
name|'flavor'
op|','
name|'image_meta'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'cells'
op|'='
op|'['
op|']'
newline|'\n'
name|'totalmem'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'availcpus'
op|'='
name|'set'
op|'('
name|'range'
op|'('
name|'flavor'
op|'['
string|"'vcpus'"
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'node'
name|'in'
name|'range'
op|'('
name|'nodes'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'cpus'
op|'='
name|'_numa_get_flavor_or_image_prop'
op|'('
nl|'\n'
name|'flavor'
op|','
name|'image_meta'
op|','
string|'"numa_cpus.%d"'
op|'%'
name|'node'
op|')'
newline|'\n'
name|'mem'
op|'='
name|'_numa_get_flavor_or_image_prop'
op|'('
nl|'\n'
name|'flavor'
op|','
name|'image_meta'
op|','
string|'"numa_mem.%d"'
op|'%'
name|'node'
op|')'
newline|'\n'
nl|'\n'
comment|"# We're expecting both properties set, so"
nl|'\n'
comment|'# raise an error if either is missing'
nl|'\n'
name|'if'
name|'cpus'
name|'is'
name|'None'
name|'or'
name|'mem'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'ImageNUMATopologyIncomplete'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'mem'
op|'='
name|'int'
op|'('
name|'mem'
op|')'
newline|'\n'
name|'cpuset'
op|'='
name|'parse_cpu_spec'
op|'('
name|'cpus'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'cpu'
name|'in'
name|'cpuset'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'cpu'
op|'>'
op|'('
name|'flavor'
op|'['
string|"'vcpus'"
op|']'
op|'-'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'ImageNUMATopologyCPUOutOfRange'
op|'('
nl|'\n'
name|'cpunum'
op|'='
name|'cpu'
op|','
name|'cpumax'
op|'='
op|'('
name|'flavor'
op|'['
string|"'vcpus'"
op|']'
op|'-'
number|'1'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'cpu'
name|'not'
name|'in'
name|'availcpus'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'ImageNUMATopologyCPUDuplicates'
op|'('
nl|'\n'
name|'cpunum'
op|'='
name|'cpu'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'availcpus'
op|'.'
name|'remove'
op|'('
name|'cpu'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'cells'
op|'.'
name|'append'
op|'('
name|'objects'
op|'.'
name|'InstanceNUMACell'
op|'('
nl|'\n'
name|'id'
op|'='
name|'node'
op|','
name|'cpuset'
op|'='
name|'cpuset'
op|','
name|'memory'
op|'='
name|'mem'
op|')'
op|')'
newline|'\n'
name|'totalmem'
op|'='
name|'totalmem'
op|'+'
name|'mem'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'availcpus'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'ImageNUMATopologyCPUsUnassigned'
op|'('
nl|'\n'
name|'cpuset'
op|'='
name|'str'
op|'('
name|'availcpus'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'totalmem'
op|'!='
name|'flavor'
op|'['
string|"'memory_mb'"
op|']'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'ImageNUMATopologyMemoryOutOfRange'
op|'('
nl|'\n'
name|'memsize'
op|'='
name|'totalmem'
op|','
nl|'\n'
name|'memtotal'
op|'='
name|'flavor'
op|'['
string|"'memory_mb'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'objects'
op|'.'
name|'InstanceNUMATopology'
op|'('
name|'cells'
op|'='
name|'cells'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_numa_get_constraints_auto
dedent|''
name|'def'
name|'_numa_get_constraints_auto'
op|'('
name|'nodes'
op|','
name|'flavor'
op|','
name|'image_meta'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
op|'('
op|'('
name|'flavor'
op|'['
string|"'vcpus'"
op|']'
op|'%'
name|'nodes'
op|')'
op|'>'
number|'0'
name|'or'
nl|'\n'
op|'('
name|'flavor'
op|'['
string|"'memory_mb'"
op|']'
op|'%'
name|'nodes'
op|')'
op|'>'
number|'0'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'ImageNUMATopologyAsymmetric'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'cells'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'node'
name|'in'
name|'range'
op|'('
name|'nodes'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'cpus'
op|'='
name|'_numa_get_flavor_or_image_prop'
op|'('
nl|'\n'
name|'flavor'
op|','
name|'image_meta'
op|','
string|'"numa_cpus.%d"'
op|'%'
name|'node'
op|')'
newline|'\n'
name|'mem'
op|'='
name|'_numa_get_flavor_or_image_prop'
op|'('
nl|'\n'
name|'flavor'
op|','
name|'image_meta'
op|','
string|'"numa_mem.%d"'
op|'%'
name|'node'
op|')'
newline|'\n'
nl|'\n'
comment|"# We're not expecting any properties set, so"
nl|'\n'
comment|'# raise an error if there are any'
nl|'\n'
name|'if'
name|'cpus'
name|'is'
name|'not'
name|'None'
name|'or'
name|'mem'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'ImageNUMATopologyIncomplete'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'ncpus'
op|'='
name|'int'
op|'('
name|'flavor'
op|'['
string|"'vcpus'"
op|']'
op|'/'
name|'nodes'
op|')'
newline|'\n'
name|'mem'
op|'='
name|'int'
op|'('
name|'flavor'
op|'['
string|"'memory_mb'"
op|']'
op|'/'
name|'nodes'
op|')'
newline|'\n'
name|'start'
op|'='
name|'node'
op|'*'
name|'ncpus'
newline|'\n'
name|'cpuset'
op|'='
name|'set'
op|'('
name|'range'
op|'('
name|'start'
op|','
name|'start'
op|'+'
name|'ncpus'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'cells'
op|'.'
name|'append'
op|'('
name|'objects'
op|'.'
name|'InstanceNUMACell'
op|'('
nl|'\n'
name|'id'
op|'='
name|'node'
op|','
name|'cpuset'
op|'='
name|'cpuset'
op|','
name|'memory'
op|'='
name|'mem'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'objects'
op|'.'
name|'InstanceNUMATopology'
op|'('
name|'cells'
op|'='
name|'cells'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_add_cpu_pinning_constraint
dedent|''
name|'def'
name|'_add_cpu_pinning_constraint'
op|'('
name|'flavor'
op|','
name|'image_meta'
op|','
name|'numa_topology'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'flavor_pinning'
op|'='
name|'flavor'
op|'.'
name|'get'
op|'('
string|"'extra_specs'"
op|','
op|'{'
op|'}'
op|')'
op|'.'
name|'get'
op|'('
string|'"hw:cpu_policy"'
op|')'
newline|'\n'
name|'image_pinning'
op|'='
name|'image_meta'
op|'.'
name|'get'
op|'('
string|"'properties'"
op|','
op|'{'
op|'}'
op|')'
op|'.'
name|'get'
op|'('
string|'"hw_cpu_policy"'
op|')'
newline|'\n'
name|'if'
name|'flavor_pinning'
op|'=='
string|'"dedicated"'
op|':'
newline|'\n'
indent|'        '
name|'requested'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'elif'
name|'flavor_pinning'
op|'=='
string|'"shared"'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'image_pinning'
op|'=='
string|'"dedicated"'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'ImageCPUPinningForbidden'
op|'('
op|')'
newline|'\n'
dedent|''
name|'requested'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'requested'
op|'='
name|'image_pinning'
op|'=='
string|'"dedicated"'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'requested'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'numa_topology'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'numa_topology'
op|':'
newline|'\n'
comment|'# NOTE(ndipanov) Setting the cpu_pinning attribute to a non-None value'
nl|'\n'
comment|'# means CPU pinning was requested'
nl|'\n'
indent|'        '
name|'for'
name|'cell'
name|'in'
name|'numa_topology'
op|'.'
name|'cells'
op|':'
newline|'\n'
indent|'            '
name|'cell'
op|'.'
name|'cpu_pinning'
op|'='
op|'{'
op|'}'
newline|'\n'
dedent|''
name|'return'
name|'numa_topology'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'single_cell'
op|'='
name|'objects'
op|'.'
name|'InstanceNUMACell'
op|'('
nl|'\n'
name|'id'
op|'='
number|'0'
op|','
nl|'\n'
name|'cpuset'
op|'='
name|'set'
op|'('
name|'range'
op|'('
name|'flavor'
op|'['
string|"'vcpus'"
op|']'
op|')'
op|')'
op|','
nl|'\n'
name|'memory'
op|'='
name|'flavor'
op|'['
string|"'memory_mb'"
op|']'
op|','
nl|'\n'
name|'cpu_pinning'
op|'='
op|'{'
op|'}'
op|')'
newline|'\n'
name|'numa_topology'
op|'='
name|'objects'
op|'.'
name|'InstanceNUMATopology'
op|'('
name|'cells'
op|'='
op|'['
name|'single_cell'
op|']'
op|')'
newline|'\n'
name|'return'
name|'numa_topology'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# TODO(sahid): Move numa related to hardward/numa.py'
nl|'\n'
DECL|function|numa_get_constraints
dedent|''
dedent|''
name|'def'
name|'numa_get_constraints'
op|'('
name|'flavor'
op|','
name|'image_meta'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return topology related to input request\n\n    :param flavor: Flavor object to read extra specs from\n    :param image_meta: Image object to read image metadata from\n\n    :returns: InstanceNUMATopology or None\n    """'
newline|'\n'
name|'nodes'
op|'='
name|'_numa_get_flavor_or_image_prop'
op|'('
nl|'\n'
name|'flavor'
op|','
name|'image_meta'
op|','
string|'"numa_nodes"'
op|')'
newline|'\n'
name|'pagesize'
op|'='
name|'_numa_get_pagesize_constraints'
op|'('
nl|'\n'
name|'flavor'
op|','
name|'image_meta'
op|')'
newline|'\n'
nl|'\n'
name|'numa_topology'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'nodes'
name|'or'
name|'pagesize'
op|':'
newline|'\n'
indent|'        '
name|'nodes'
op|'='
name|'nodes'
name|'and'
name|'int'
op|'('
name|'nodes'
op|')'
name|'or'
number|'1'
newline|'\n'
comment|"# We'll pick what path to go down based on whether"
nl|'\n'
comment|'# anything is set for the first node. Both paths'
nl|'\n'
comment|'# have logic to cope with inconsistent property usage'
nl|'\n'
name|'auto'
op|'='
name|'_numa_get_flavor_or_image_prop'
op|'('
nl|'\n'
name|'flavor'
op|','
name|'image_meta'
op|','
string|'"numa_cpus.0"'
op|')'
name|'is'
name|'None'
newline|'\n'
nl|'\n'
name|'if'
name|'auto'
op|':'
newline|'\n'
indent|'            '
name|'numa_topology'
op|'='
name|'_numa_get_constraints_auto'
op|'('
nl|'\n'
name|'nodes'
op|','
name|'flavor'
op|','
name|'image_meta'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'numa_topology'
op|'='
name|'_numa_get_constraints_manual'
op|'('
nl|'\n'
name|'nodes'
op|','
name|'flavor'
op|','
name|'image_meta'
op|')'
newline|'\n'
nl|'\n'
comment|'# We currently support same pagesize for all cells.'
nl|'\n'
dedent|''
op|'['
name|'setattr'
op|'('
name|'c'
op|','
string|"'pagesize'"
op|','
name|'pagesize'
op|')'
name|'for'
name|'c'
name|'in'
name|'numa_topology'
op|'.'
name|'cells'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'_add_cpu_pinning_constraint'
op|'('
name|'flavor'
op|','
name|'image_meta'
op|','
name|'numa_topology'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|VirtNUMALimitTopology
dedent|''
name|'class'
name|'VirtNUMALimitTopology'
op|'('
name|'VirtNUMATopology'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Class to represent the max resources of a compute node used\n    for checking oversubscription limits.\n    """'
newline|'\n'
nl|'\n'
DECL|variable|cell_class
name|'cell_class'
op|'='
name|'VirtNUMATopologyCellLimit'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|numa_fit_instance_to_host
dedent|''
name|'def'
name|'numa_fit_instance_to_host'
op|'('
nl|'\n'
name|'host_topology'
op|','
name|'instance_topology'
op|','
name|'limits_topology'
op|'='
name|'None'
op|','
nl|'\n'
name|'pci_requests'
op|'='
name|'None'
op|','
name|'pci_stats'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Fit the instance topology onto the host topology given the limits\n\n    :param host_topology: objects.NUMATopology object to fit an instance on\n    :param instance_topology: objects.InstanceNUMATopology to be fitted\n    :param limits_topology: VirtNUMALimitTopology that defines limits\n    :param pci_requests: instance pci_requests\n    :param pci_stats: pci_stats for the host\n\n    Given a host and instance topology and optionally limits - this method\n    will attempt to fit instance cells onto all permutations of host cells\n    by calling the _numa_fit_instance_cell method, and return a new\n    InstanceNUMATopology with it\'s cell ids set to host cell id\'s of\n    the first successful permutation, or None.\n    """'
newline|'\n'
name|'if'
op|'('
name|'not'
op|'('
name|'host_topology'
name|'and'
name|'instance_topology'
op|')'
name|'or'
nl|'\n'
name|'len'
op|'('
name|'host_topology'
op|')'
op|'<'
name|'len'
op|'('
name|'instance_topology'
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'limits_topology'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'limits_topology_cells'
op|'='
name|'itertools'
op|'.'
name|'repeat'
op|'('
nl|'\n'
name|'None'
op|','
name|'len'
op|'('
name|'host_topology'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'limits_topology_cells'
op|'='
name|'limits_topology'
op|'.'
name|'cells'
newline|'\n'
comment|'# TODO(ndipanov): We may want to sort permutations differently'
nl|'\n'
comment|'# depending on whether we want packing/spreading over NUMA nodes'
nl|'\n'
dedent|''
name|'for'
name|'host_cell_perm'
name|'in'
name|'itertools'
op|'.'
name|'permutations'
op|'('
nl|'\n'
name|'zip'
op|'('
name|'host_topology'
op|'.'
name|'cells'
op|','
name|'limits_topology_cells'
op|')'
op|','
nl|'\n'
name|'len'
op|'('
name|'instance_topology'
op|')'
nl|'\n'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'cells'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
op|'('
name|'host_cell'
op|','
name|'limit_cell'
op|')'
op|','
name|'instance_cell'
name|'in'
name|'zip'
op|'('
nl|'\n'
name|'host_cell_perm'
op|','
name|'instance_topology'
op|'.'
name|'cells'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'got_cell'
op|'='
name|'_numa_fit_instance_cell'
op|'('
nl|'\n'
name|'host_cell'
op|','
name|'instance_cell'
op|','
name|'limit_cell'
op|')'
newline|'\n'
name|'if'
name|'got_cell'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'break'
newline|'\n'
dedent|''
name|'cells'
op|'.'
name|'append'
op|'('
name|'got_cell'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'len'
op|'('
name|'cells'
op|')'
op|'=='
name|'len'
op|'('
name|'host_cell_perm'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'not'
name|'pci_requests'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'objects'
op|'.'
name|'InstanceNUMATopology'
op|'('
name|'cells'
op|'='
name|'cells'
op|')'
newline|'\n'
dedent|''
name|'elif'
op|'('
op|'('
name|'pci_stats'
name|'is'
name|'not'
name|'None'
op|')'
name|'and'
nl|'\n'
name|'pci_stats'
op|'.'
name|'support_requests'
op|'('
name|'pci_requests'
op|','
nl|'\n'
name|'cells'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'objects'
op|'.'
name|'InstanceNUMATopology'
op|'('
name|'cells'
op|'='
name|'cells'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_numa_pagesize_usage_from_cell
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_numa_pagesize_usage_from_cell'
op|'('
name|'hostcell'
op|','
name|'instancecell'
op|','
name|'sign'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'topo'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'pages'
name|'in'
name|'hostcell'
op|'.'
name|'mempages'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'pages'
op|'.'
name|'size_kb'
op|'=='
name|'instancecell'
op|'.'
name|'pagesize'
op|':'
newline|'\n'
indent|'            '
name|'topo'
op|'.'
name|'append'
op|'('
name|'objects'
op|'.'
name|'NUMAPagesTopology'
op|'('
nl|'\n'
name|'size_kb'
op|'='
name|'pages'
op|'.'
name|'size_kb'
op|','
nl|'\n'
name|'total'
op|'='
name|'pages'
op|'.'
name|'total'
op|','
nl|'\n'
name|'used'
op|'='
name|'max'
op|'('
number|'0'
op|','
name|'pages'
op|'.'
name|'used'
op|'+'
nl|'\n'
name|'instancecell'
op|'.'
name|'memory'
op|'*'
name|'units'
op|'.'
name|'Ki'
op|'/'
nl|'\n'
name|'pages'
op|'.'
name|'size_kb'
op|'*'
name|'sign'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'topo'
op|'.'
name|'append'
op|'('
name|'pages'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'topo'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|numa_usage_from_instances
dedent|''
name|'def'
name|'numa_usage_from_instances'
op|'('
name|'host'
op|','
name|'instances'
op|','
name|'free'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Get host topology usage\n\n    :param host: objects.NUMATopology with usage information\n    :param instances: list of objects.InstanceNUMATopology\n    :param free: If True usage of the host will be decreased\n\n    Sum the usage from all @instances to report the overall\n    host topology usage\n\n    :returns: objects.NUMATopology including usage information\n    """'
newline|'\n'
nl|'\n'
name|'if'
name|'host'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'instances'
op|'='
name|'instances'
name|'or'
op|'['
op|']'
newline|'\n'
name|'cells'
op|'='
op|'['
op|']'
newline|'\n'
name|'sign'
op|'='
op|'-'
number|'1'
name|'if'
name|'free'
name|'else'
number|'1'
newline|'\n'
name|'for'
name|'hostcell'
name|'in'
name|'host'
op|'.'
name|'cells'
op|':'
newline|'\n'
indent|'        '
name|'memory_usage'
op|'='
name|'hostcell'
op|'.'
name|'memory_usage'
newline|'\n'
name|'cpu_usage'
op|'='
name|'hostcell'
op|'.'
name|'cpu_usage'
newline|'\n'
nl|'\n'
name|'newcell'
op|'='
name|'objects'
op|'.'
name|'NUMACell'
op|'('
nl|'\n'
name|'id'
op|'='
name|'hostcell'
op|'.'
name|'id'
op|','
name|'cpuset'
op|'='
name|'hostcell'
op|'.'
name|'cpuset'
op|','
name|'memory'
op|'='
name|'hostcell'
op|'.'
name|'memory'
op|','
nl|'\n'
name|'cpu_usage'
op|'='
number|'0'
op|','
name|'memory_usage'
op|'='
number|'0'
op|','
name|'mempages'
op|'='
name|'hostcell'
op|'.'
name|'mempages'
op|','
nl|'\n'
name|'pinned_cpus'
op|'='
name|'hostcell'
op|'.'
name|'pinned_cpus'
op|','
name|'siblings'
op|'='
name|'hostcell'
op|'.'
name|'siblings'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'instance'
name|'in'
name|'instances'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'instancecell'
name|'in'
name|'instance'
op|'.'
name|'cells'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'instancecell'
op|'.'
name|'id'
op|'=='
name|'hostcell'
op|'.'
name|'id'
op|':'
newline|'\n'
indent|'                    '
name|'memory_usage'
op|'='
op|'('
nl|'\n'
name|'memory_usage'
op|'+'
name|'sign'
op|'*'
name|'instancecell'
op|'.'
name|'memory'
op|')'
newline|'\n'
name|'cpu_usage'
op|'='
name|'cpu_usage'
op|'+'
name|'sign'
op|'*'
name|'len'
op|'('
name|'instancecell'
op|'.'
name|'cpuset'
op|')'
newline|'\n'
name|'if'
name|'instancecell'
op|'.'
name|'pagesize'
name|'and'
name|'instancecell'
op|'.'
name|'pagesize'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                        '
name|'newcell'
op|'.'
name|'mempages'
op|'='
name|'_numa_pagesize_usage_from_cell'
op|'('
nl|'\n'
name|'hostcell'
op|','
name|'instancecell'
op|','
name|'sign'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'instance'
op|'.'
name|'cpu_pinning_requested'
op|':'
newline|'\n'
indent|'                        '
name|'pinned_cpus'
op|'='
name|'set'
op|'('
name|'instancecell'
op|'.'
name|'cpu_pinning'
op|'.'
name|'values'
op|'('
op|')'
op|')'
newline|'\n'
name|'if'
name|'free'
op|':'
newline|'\n'
indent|'                            '
name|'newcell'
op|'.'
name|'unpin_cpus'
op|'('
name|'pinned_cpus'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                            '
name|'newcell'
op|'.'
name|'pin_cpus'
op|'('
name|'pinned_cpus'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'newcell'
op|'.'
name|'cpu_usage'
op|'='
name|'max'
op|'('
number|'0'
op|','
name|'cpu_usage'
op|')'
newline|'\n'
name|'newcell'
op|'.'
name|'memory_usage'
op|'='
name|'max'
op|'('
number|'0'
op|','
name|'memory_usage'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'cells'
op|'.'
name|'append'
op|'('
name|'newcell'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'objects'
op|'.'
name|'NUMATopology'
op|'('
name|'cells'
op|'='
name|'cells'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# TODO(ndipanov): Remove when all code paths are using objects'
nl|'\n'
DECL|function|instance_topology_from_instance
dedent|''
name|'def'
name|'instance_topology_from_instance'
op|'('
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Convenience method for getting the numa_topology out of instances\n\n    Since we may get an Instance as either a dict, a db object, or an actual\n    Instance object, this makes sure we get beck either None, or an instance\n    of objects.InstanceNUMATopology class.\n    """'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'instance'
op|','
name|'objects'
op|'.'
name|'Instance'
op|')'
op|':'
newline|'\n'
comment|'# NOTE (ndipanov): This may cause a lazy-load of the attribute'
nl|'\n'
indent|'        '
name|'instance_numa_topology'
op|'='
name|'instance'
op|'.'
name|'numa_topology'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'if'
string|"'numa_topology'"
name|'in'
name|'instance'
op|':'
newline|'\n'
indent|'            '
name|'instance_numa_topology'
op|'='
name|'instance'
op|'['
string|"'numa_topology'"
op|']'
newline|'\n'
dedent|''
name|'elif'
string|"'uuid'"
name|'in'
name|'instance'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'instance_numa_topology'
op|'='
op|'('
nl|'\n'
name|'objects'
op|'.'
name|'InstanceNUMATopology'
op|'.'
name|'get_by_instance_uuid'
op|'('
nl|'\n'
name|'context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
op|','
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
nl|'\n'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'NumaTopologyNotFound'
op|':'
newline|'\n'
indent|'                '
name|'instance_numa_topology'
op|'='
name|'None'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'instance_numa_topology'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'instance_numa_topology'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'isinstance'
op|'('
name|'instance_numa_topology'
op|','
name|'six'
op|'.'
name|'string_types'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'instance_numa_topology'
op|'='
op|'('
nl|'\n'
name|'objects'
op|'.'
name|'InstanceNUMATopology'
op|'.'
name|'obj_from_primitive'
op|'('
nl|'\n'
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'instance_numa_topology'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'isinstance'
op|'('
name|'instance_numa_topology'
op|','
name|'dict'
op|')'
op|':'
newline|'\n'
comment|'# NOTE (ndipanov): A horrible hack so that we can use'
nl|'\n'
comment|'# this in the scheduler, since the'
nl|'\n'
comment|'# InstanceNUMATopology object is serialized raw using'
nl|'\n'
comment|'# the obj_base.obj_to_primitive, (which is buggy and'
nl|'\n'
comment|'# will give us a dict with a list of InstanceNUMACell'
nl|'\n'
comment|'# objects), and then passed to jsonutils.to_primitive,'
nl|'\n'
comment|'# which will make a dict out of those objects. All of'
nl|'\n'
comment|'# this is done by scheduler.utils.build_request_spec'
nl|'\n'
comment|'# called in the conductor.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Remove when request_spec is a proper object itself!'
nl|'\n'
indent|'            '
name|'dict_cells'
op|'='
name|'instance_numa_topology'
op|'.'
name|'get'
op|'('
string|"'cells'"
op|')'
newline|'\n'
name|'if'
name|'dict_cells'
op|':'
newline|'\n'
indent|'                '
name|'cells'
op|'='
op|'['
name|'objects'
op|'.'
name|'InstanceNUMACell'
op|'('
nl|'\n'
name|'id'
op|'='
name|'cell'
op|'['
string|"'id'"
op|']'
op|','
nl|'\n'
name|'cpuset'
op|'='
name|'set'
op|'('
name|'cell'
op|'['
string|"'cpuset'"
op|']'
op|')'
op|','
nl|'\n'
name|'memory'
op|'='
name|'cell'
op|'['
string|"'memory'"
op|']'
op|','
nl|'\n'
name|'pagesize'
op|'='
name|'cell'
op|'.'
name|'get'
op|'('
string|"'pagesize'"
op|')'
op|')'
nl|'\n'
name|'for'
name|'cell'
name|'in'
name|'dict_cells'
op|']'
newline|'\n'
name|'instance_numa_topology'
op|'='
name|'objects'
op|'.'
name|'InstanceNUMATopology'
op|'('
nl|'\n'
name|'cells'
op|'='
name|'cells'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'instance_numa_topology'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# TODO(ndipanov): Remove when all code paths are using objects'
nl|'\n'
DECL|function|host_topology_and_format_from_host
dedent|''
name|'def'
name|'host_topology_and_format_from_host'
op|'('
name|'host'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Convenience method for getting the numa_topology out of hosts\n\n    Since we may get a host as either a dict, a db object, or an actual\n    ComputeNode object, or an instance of HostState class, this makes sure we\n    get beck either None, or an instance of objects.NUMATopology class.\n\n    :returns: A two-tuple, first element is the topology itself or None, second\n              is a boolean set to True if topology was in json format.\n    """'
newline|'\n'
name|'was_json'
op|'='
name|'False'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'host_numa_topology'
op|'='
name|'host'
op|'.'
name|'get'
op|'('
string|"'numa_topology'"
op|')'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'        '
name|'host_numa_topology'
op|'='
name|'host'
op|'.'
name|'numa_topology'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'host_numa_topology'
name|'is'
name|'not'
name|'None'
name|'and'
name|'isinstance'
op|'('
nl|'\n'
name|'host_numa_topology'
op|','
name|'six'
op|'.'
name|'string_types'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'was_json'
op|'='
name|'True'
newline|'\n'
nl|'\n'
name|'host_numa_topology'
op|'='
op|'('
name|'objects'
op|'.'
name|'NUMATopology'
op|'.'
name|'obj_from_db_obj'
op|'('
nl|'\n'
name|'host_numa_topology'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'host_numa_topology'
op|','
name|'was_json'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# TODO(ndipanov): Remove when all code paths are using objects'
nl|'\n'
DECL|function|get_host_numa_usage_from_instance
dedent|''
name|'def'
name|'get_host_numa_usage_from_instance'
op|'('
name|'host'
op|','
name|'instance'
op|','
name|'free'
op|'='
name|'False'
op|','
nl|'\n'
name|'never_serialize_result'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Calculate new \'numa_usage\' of \'host\' from \'instance\' NUMA usage\n\n    This is a convenience method to help us handle the fact that we use several\n    different types throughout the code (ComputeNode and Instance objects,\n    dicts, scheduler HostState) which may have both json and deserialized\n    versions of VirtNUMATopology classes.\n\n    Handles all the complexity without polluting the class method with it.\n\n    :param host: nova.objects.ComputeNode instance, or a db object or dict\n    :param instance: nova.objects.Instance instance, or a db object or dict\n    :param free: if True the the returned topology will have it\'s usage\n                 decreased instead.\n    :param never_serialize_result: if True result will always be an instance of\n                                   objects.NUMATopology class.\n\n    :returns: numa_usage in the format it was on the host or\n              objects.NUMATopology instance if never_serialize_result was True\n    """'
newline|'\n'
name|'instance_numa_topology'
op|'='
name|'instance_topology_from_instance'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'instance_numa_topology'
op|':'
newline|'\n'
indent|'        '
name|'instance_numa_topology'
op|'='
op|'['
name|'instance_numa_topology'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'host_numa_topology'
op|','
name|'jsonify_result'
op|'='
name|'host_topology_and_format_from_host'
op|'('
nl|'\n'
name|'host'
op|')'
newline|'\n'
nl|'\n'
name|'updated_numa_topology'
op|'='
op|'('
nl|'\n'
name|'numa_usage_from_instances'
op|'('
nl|'\n'
name|'host_numa_topology'
op|','
name|'instance_numa_topology'
op|','
name|'free'
op|'='
name|'free'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'updated_numa_topology'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'jsonify_result'
name|'and'
name|'not'
name|'never_serialize_result'
op|':'
newline|'\n'
indent|'            '
name|'updated_numa_topology'
op|'='
name|'updated_numa_topology'
op|'.'
name|'_to_json'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'updated_numa_topology'
newline|'\n'
dedent|''
endmarker|''
end_unit
