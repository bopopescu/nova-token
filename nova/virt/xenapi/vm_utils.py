begin_unit
comment|'# Copyright (c) 2010 Citrix Systems, Inc.'
nl|'\n'
comment|'# Copyright 2011 Piston Cloud Computing, Inc.'
nl|'\n'
comment|'# Copyright 2012 OpenStack Foundation'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
nl|'\n'
string|'"""\nHelper methods for operations related to the management of VM records and\ntheir attributes like VDIs, VIFs, as well as their lookup functions.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'contextlib'
newline|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'time'
newline|'\n'
name|'import'
name|'urllib'
newline|'\n'
name|'import'
name|'uuid'
newline|'\n'
name|'from'
name|'xml'
op|'.'
name|'dom'
name|'import'
name|'minidom'
newline|'\n'
name|'from'
name|'xml'
op|'.'
name|'parsers'
name|'import'
name|'expat'
newline|'\n'
nl|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'greenthread'
newline|'\n'
name|'from'
name|'oslo_concurrency'
name|'import'
name|'processutils'
newline|'\n'
name|'from'
name|'oslo_config'
name|'import'
name|'cfg'
newline|'\n'
name|'from'
name|'oslo_log'
name|'import'
name|'log'
name|'as'
name|'logging'
newline|'\n'
name|'from'
name|'oslo_utils'
name|'import'
name|'excutils'
newline|'\n'
name|'from'
name|'oslo_utils'
name|'import'
name|'importutils'
newline|'\n'
name|'from'
name|'oslo_utils'
name|'import'
name|'strutils'
newline|'\n'
name|'from'
name|'oslo_utils'
name|'import'
name|'timeutils'
newline|'\n'
name|'from'
name|'oslo_utils'
name|'import'
name|'units'
newline|'\n'
name|'from'
name|'oslo_utils'
name|'import'
name|'versionutils'
newline|'\n'
name|'import'
name|'six'
newline|'\n'
name|'from'
name|'six'
op|'.'
name|'moves'
name|'import'
name|'range'
newline|'\n'
name|'import'
name|'six'
op|'.'
name|'moves'
op|'.'
name|'urllib'
op|'.'
name|'parse'
name|'as'
name|'urlparse'
newline|'\n'
nl|'\n'
name|'from'
name|'nova'
op|'.'
name|'api'
op|'.'
name|'metadata'
name|'import'
name|'base'
name|'as'
name|'instance_metadata'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'power_state'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'task_states'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'vm_mode'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'exception'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_'
op|','
name|'_LE'
op|','
name|'_LI'
op|','
name|'_LW'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'network'
name|'import'
name|'model'
name|'as'
name|'network_model'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'utils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'configdrive'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'diagnostics'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'disk'
name|'import'
name|'api'
name|'as'
name|'disk'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'disk'
op|'.'
name|'vfs'
name|'import'
name|'localfs'
name|'as'
name|'vfsimpl'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'hardware'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'image'
name|'import'
name|'model'
name|'as'
name|'imgmodel'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'netutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'xenapi'
name|'import'
name|'agent'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'xenapi'
op|'.'
name|'image'
name|'import'
name|'utils'
name|'as'
name|'image_utils'
newline|'\n'
nl|'\n'
DECL|variable|LOG
name|'LOG'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|xenapi_vm_utils_opts
name|'xenapi_vm_utils_opts'
op|'='
op|'['
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'cache_images'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'all'"
op|','
nl|'\n'
DECL|variable|choices
name|'choices'
op|'='
op|'('
string|"'all'"
op|','
string|"'some'"
op|','
string|"'none'"
op|')'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Cache glance images locally. `all` will cache all'"
nl|'\n'
string|"' images, `some` will only cache images that have the'"
nl|'\n'
string|"' image_property `cache_in_nova=True`, and `none` turns'"
nl|'\n'
string|"' off caching entirely'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'image_compression_level'"
op|','
nl|'\n'
DECL|variable|min
name|'min'
op|'='
number|'1'
op|','
nl|'\n'
DECL|variable|max
name|'max'
op|'='
number|'9'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Compression level for images, e.g., 9 for gzip -9.'"
nl|'\n'
string|"' Range is 1-9, 9 being most compressed but most CPU'"
nl|'\n'
string|"' intensive on dom0.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'default_os_type'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'linux'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Default OS type'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'block_device_creation_timeout'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'10'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Time to wait for a block device to be created'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'max_kernel_ramdisk_size'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'16'
op|'*'
name|'units'
op|'.'
name|'Mi'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Maximum size in bytes of kernel or ramdisk images'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'sr_matching_filter'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'default-sr:true'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Filter for finding the SR to be used to install guest '"
nl|'\n'
string|"'instances on. To use the Local Storage in default '"
nl|'\n'
string|"'XenServer/XCP installations set this flag to '"
nl|'\n'
string|"'other-config:i18n-key=local-storage. To select an SR '"
nl|'\n'
string|"'with a different matching criteria, you could set it to '"
nl|'\n'
string|"'other-config:my_favorite_sr=true. On the other hand, to '"
nl|'\n'
string|"'fall back on the Default SR, as displayed by XenCenter, '"
nl|'\n'
string|"'set this flag to: default-sr:true'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'BoolOpt'
op|'('
string|"'sparse_copy'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
name|'True'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Whether to use sparse_copy for copying data on a '"
nl|'\n'
string|"'resize down (False will use standard dd). This speeds '"
nl|'\n'
string|"'up resizes down considerably since large runs of zeros '"
nl|'\n'
string|"'won\\'t have to be rsynced'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'num_vbd_unplug_retries'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'10'
op|','
nl|'\n'
name|'help'
op|'='
string|"'Maximum number of retries to unplug VBD. if <=0, '"
nl|'\n'
string|"'should try once and no retry'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'torrent_images'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'none'"
op|','
nl|'\n'
DECL|variable|choices
name|'choices'
op|'='
op|'('
string|"'all'"
op|','
string|"'some'"
op|','
string|"'none'"
op|')'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Whether or not to download images via Bit Torrent.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'ipxe_network_name'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Name of network to use for booting iPXE ISOs'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'ipxe_boot_menu_url'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'URL to the iPXE boot menu'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'ipxe_mkisofs_cmd'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'mkisofs'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Name and optionally path of the tool used for '"
nl|'\n'
string|"'ISO image creation'"
op|')'
op|','
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
DECL|variable|CONF
name|'CONF'
op|'='
name|'cfg'
op|'.'
name|'CONF'
newline|'\n'
name|'CONF'
op|'.'
name|'register_opts'
op|'('
name|'xenapi_vm_utils_opts'
op|','
string|"'xenserver'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'default_ephemeral_format'"
op|','
string|"'nova.virt.driver'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'use_cow_images'"
op|','
string|"'nova.virt.driver'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'use_ipv6'"
op|','
string|"'nova.netconf'"
op|')'
newline|'\n'
nl|'\n'
DECL|variable|XENAPI_POWER_STATE
name|'XENAPI_POWER_STATE'
op|'='
op|'{'
nl|'\n'
string|"'Halted'"
op|':'
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|','
nl|'\n'
string|"'Running'"
op|':'
name|'power_state'
op|'.'
name|'RUNNING'
op|','
nl|'\n'
string|"'Paused'"
op|':'
name|'power_state'
op|'.'
name|'PAUSED'
op|','
nl|'\n'
string|"'Suspended'"
op|':'
name|'power_state'
op|'.'
name|'SUSPENDED'
op|','
nl|'\n'
string|"'Crashed'"
op|':'
name|'power_state'
op|'.'
name|'CRASHED'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|SECTOR_SIZE
name|'SECTOR_SIZE'
op|'='
number|'512'
newline|'\n'
DECL|variable|MBR_SIZE_SECTORS
name|'MBR_SIZE_SECTORS'
op|'='
number|'63'
newline|'\n'
DECL|variable|MBR_SIZE_BYTES
name|'MBR_SIZE_BYTES'
op|'='
name|'MBR_SIZE_SECTORS'
op|'*'
name|'SECTOR_SIZE'
newline|'\n'
DECL|variable|KERNEL_DIR
name|'KERNEL_DIR'
op|'='
string|"'/boot/guest'"
newline|'\n'
DECL|variable|MAX_VDI_CHAIN_SIZE
name|'MAX_VDI_CHAIN_SIZE'
op|'='
number|'16'
newline|'\n'
DECL|variable|PROGRESS_INTERVAL_SECONDS
name|'PROGRESS_INTERVAL_SECONDS'
op|'='
number|'300'
newline|'\n'
nl|'\n'
comment|'# Fudge factor to allow for the VHD chain to be slightly larger than'
nl|'\n'
comment|'# the partitioned space. Otherwise, legitimate images near their'
nl|'\n'
comment|'# maximum allowed size can fail on build with FlavorDiskTooSmall.'
nl|'\n'
DECL|variable|VHD_SIZE_CHECK_FUDGE_FACTOR_GB
name|'VHD_SIZE_CHECK_FUDGE_FACTOR_GB'
op|'='
number|'10'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ImageType
name|'class'
name|'ImageType'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Enumeration class for distinguishing different image types\n\n    | 0 - kernel image (goes on dom0\'s filesystem)\n    | 1 - ramdisk image (goes on dom0\'s filesystem)\n    | 2 - disk image (local SR, partitioned by objectstore plugin)\n    | 3 - raw disk image (local SR, NOT partitioned by plugin)\n    | 4 - vhd disk image (local SR, NOT inspected by XS, PV assumed for\n    |     linux, HVM assumed for Windows)\n    | 5 - ISO disk image (local SR, NOT partitioned by plugin)\n    | 6 - config drive\n    """'
newline|'\n'
nl|'\n'
DECL|variable|KERNEL
name|'KERNEL'
op|'='
number|'0'
newline|'\n'
DECL|variable|RAMDISK
name|'RAMDISK'
op|'='
number|'1'
newline|'\n'
DECL|variable|DISK
name|'DISK'
op|'='
number|'2'
newline|'\n'
DECL|variable|DISK_RAW
name|'DISK_RAW'
op|'='
number|'3'
newline|'\n'
DECL|variable|DISK_VHD
name|'DISK_VHD'
op|'='
number|'4'
newline|'\n'
DECL|variable|DISK_ISO
name|'DISK_ISO'
op|'='
number|'5'
newline|'\n'
DECL|variable|DISK_CONFIGDRIVE
name|'DISK_CONFIGDRIVE'
op|'='
number|'6'
newline|'\n'
DECL|variable|_ids
name|'_ids'
op|'='
op|'('
name|'KERNEL'
op|','
name|'RAMDISK'
op|','
name|'DISK'
op|','
name|'DISK_RAW'
op|','
name|'DISK_VHD'
op|','
name|'DISK_ISO'
op|','
nl|'\n'
name|'DISK_CONFIGDRIVE'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|KERNEL_STR
name|'KERNEL_STR'
op|'='
string|'"kernel"'
newline|'\n'
DECL|variable|RAMDISK_STR
name|'RAMDISK_STR'
op|'='
string|'"ramdisk"'
newline|'\n'
DECL|variable|DISK_STR
name|'DISK_STR'
op|'='
string|'"root"'
newline|'\n'
DECL|variable|DISK_RAW_STR
name|'DISK_RAW_STR'
op|'='
string|'"os_raw"'
newline|'\n'
DECL|variable|DISK_VHD_STR
name|'DISK_VHD_STR'
op|'='
string|'"vhd"'
newline|'\n'
DECL|variable|DISK_ISO_STR
name|'DISK_ISO_STR'
op|'='
string|'"iso"'
newline|'\n'
DECL|variable|DISK_CONFIGDRIVE_STR
name|'DISK_CONFIGDRIVE_STR'
op|'='
string|'"configdrive"'
newline|'\n'
DECL|variable|_strs
name|'_strs'
op|'='
op|'('
name|'KERNEL_STR'
op|','
name|'RAMDISK_STR'
op|','
name|'DISK_STR'
op|','
name|'DISK_RAW_STR'
op|','
name|'DISK_VHD_STR'
op|','
nl|'\n'
name|'DISK_ISO_STR'
op|','
name|'DISK_CONFIGDRIVE_STR'
op|')'
newline|'\n'
nl|'\n'
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|to_string
name|'def'
name|'to_string'
op|'('
name|'cls'
op|','
name|'image_type'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'dict'
op|'('
name|'zip'
op|'('
name|'cls'
op|'.'
name|'_ids'
op|','
name|'ImageType'
op|'.'
name|'_strs'
op|')'
op|')'
op|'.'
name|'get'
op|'('
name|'image_type'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|get_role
name|'def'
name|'get_role'
op|'('
name|'cls'
op|','
name|'image_type_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the role played by the image, based on its type."""'
newline|'\n'
name|'return'
op|'{'
nl|'\n'
name|'cls'
op|'.'
name|'KERNEL'
op|':'
string|"'kernel'"
op|','
nl|'\n'
name|'cls'
op|'.'
name|'RAMDISK'
op|':'
string|"'ramdisk'"
op|','
nl|'\n'
name|'cls'
op|'.'
name|'DISK'
op|':'
string|"'root'"
op|','
nl|'\n'
name|'cls'
op|'.'
name|'DISK_RAW'
op|':'
string|"'root'"
op|','
nl|'\n'
name|'cls'
op|'.'
name|'DISK_VHD'
op|':'
string|"'root'"
op|','
nl|'\n'
name|'cls'
op|'.'
name|'DISK_ISO'
op|':'
string|"'iso'"
op|','
nl|'\n'
name|'cls'
op|'.'
name|'DISK_CONFIGDRIVE'
op|':'
string|"'configdrive'"
nl|'\n'
op|'}'
op|'.'
name|'get'
op|'('
name|'image_type_id'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_vm_device_id
dedent|''
dedent|''
name|'def'
name|'get_vm_device_id'
op|'('
name|'session'
op|','
name|'image_meta'
op|')'
op|':'
newline|'\n'
comment|'# NOTE: device_id should be 2 for windows VMs which run new xentools'
nl|'\n'
comment|'# (>=6.1). Refer to http://support.citrix.com/article/CTX135099 for more'
nl|'\n'
comment|'# information.'
nl|'\n'
indent|'    '
name|'device_id'
op|'='
name|'image_meta'
op|'.'
name|'properties'
op|'.'
name|'get'
op|'('
string|"'hw_device_id'"
op|')'
newline|'\n'
nl|'\n'
comment|'# The device_id is required to be set for hypervisor version 6.1 and above'
nl|'\n'
name|'if'
name|'device_id'
op|':'
newline|'\n'
indent|'        '
name|'hypervisor_version'
op|'='
name|'session'
op|'.'
name|'product_version'
newline|'\n'
name|'if'
name|'_hypervisor_supports_device_id'
op|'('
name|'hypervisor_version'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'device_id'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|'"Device id %(id)s specified is not supported by "'
nl|'\n'
string|'"hypervisor version %(version)s"'
op|')'
op|'%'
op|'{'
string|"'id'"
op|':'
name|'device_id'
op|','
nl|'\n'
string|"'version'"
op|':'
name|'hypervisor_version'
op|'}'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_hypervisor_supports_device_id
dedent|''
dedent|''
dedent|''
name|'def'
name|'_hypervisor_supports_device_id'
op|'('
name|'version'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'version_as_string'
op|'='
string|"'.'"
op|'.'
name|'join'
op|'('
name|'str'
op|'('
name|'v'
op|')'
name|'for'
name|'v'
name|'in'
name|'version'
op|')'
newline|'\n'
name|'return'
op|'('
name|'versionutils'
op|'.'
name|'is_compatible'
op|'('
string|"'6.1'"
op|','
name|'version_as_string'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|create_vm
dedent|''
name|'def'
name|'create_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'kernel'
op|','
name|'ramdisk'
op|','
nl|'\n'
name|'use_pv_kernel'
op|'='
name|'False'
op|','
name|'device_id'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Create a VM record.  Returns new VM reference.\n    the use_pv_kernel flag indicates whether the guest is HVM or PV\n\n    There are 3 scenarios:\n\n        1. Using paravirtualization, kernel passed in\n\n        2. Using paravirtualization, kernel within the image\n\n        3. Using hardware virtualization\n    """'
newline|'\n'
name|'flavor'
op|'='
name|'instance'
op|'.'
name|'get_flavor'
op|'('
op|')'
newline|'\n'
name|'mem'
op|'='
name|'str'
op|'('
name|'long'
op|'('
name|'flavor'
op|'.'
name|'memory_mb'
op|')'
op|'*'
name|'units'
op|'.'
name|'Mi'
op|')'
newline|'\n'
name|'vcpus'
op|'='
name|'str'
op|'('
name|'flavor'
op|'.'
name|'vcpus'
op|')'
newline|'\n'
nl|'\n'
name|'vcpu_weight'
op|'='
name|'flavor'
op|'.'
name|'vcpu_weight'
newline|'\n'
name|'vcpu_params'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'if'
name|'vcpu_weight'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
comment|'# NOTE(johngarbutt) bug in XenServer 6.1 and 6.2 means'
nl|'\n'
comment|'# we need to specify both weight and cap for either to apply'
nl|'\n'
indent|'        '
name|'vcpu_params'
op|'='
op|'{'
string|'"weight"'
op|':'
name|'str'
op|'('
name|'vcpu_weight'
op|')'
op|','
string|'"cap"'
op|':'
string|'"0"'
op|'}'
newline|'\n'
nl|'\n'
dedent|''
name|'cpu_mask_list'
op|'='
name|'hardware'
op|'.'
name|'get_vcpu_pin_set'
op|'('
op|')'
newline|'\n'
name|'if'
name|'cpu_mask_list'
op|':'
newline|'\n'
indent|'        '
name|'cpu_mask'
op|'='
name|'hardware'
op|'.'
name|'format_cpu_spec'
op|'('
name|'cpu_mask_list'
op|','
nl|'\n'
name|'allow_ranges'
op|'='
name|'False'
op|')'
newline|'\n'
name|'vcpu_params'
op|'['
string|'"mask"'
op|']'
op|'='
name|'cpu_mask'
newline|'\n'
nl|'\n'
dedent|''
name|'viridian'
op|'='
string|"'true'"
name|'if'
name|'instance'
op|'['
string|"'os_type'"
op|']'
op|'=='
string|"'windows'"
name|'else'
string|"'false'"
newline|'\n'
nl|'\n'
name|'rec'
op|'='
op|'{'
nl|'\n'
string|"'actions_after_crash'"
op|':'
string|"'destroy'"
op|','
nl|'\n'
string|"'actions_after_reboot'"
op|':'
string|"'restart'"
op|','
nl|'\n'
string|"'actions_after_shutdown'"
op|':'
string|"'destroy'"
op|','
nl|'\n'
string|"'affinity'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'blocked_operations'"
op|':'
op|'{'
op|'}'
op|','
nl|'\n'
string|"'ha_always_run'"
op|':'
name|'False'
op|','
nl|'\n'
string|"'ha_restart_priority'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'HVM_boot_params'"
op|':'
op|'{'
op|'}'
op|','
nl|'\n'
string|"'HVM_boot_policy'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'is_a_template'"
op|':'
name|'False'
op|','
nl|'\n'
string|"'memory_dynamic_min'"
op|':'
name|'mem'
op|','
nl|'\n'
string|"'memory_dynamic_max'"
op|':'
name|'mem'
op|','
nl|'\n'
string|"'memory_static_min'"
op|':'
string|"'0'"
op|','
nl|'\n'
string|"'memory_static_max'"
op|':'
name|'mem'
op|','
nl|'\n'
string|"'memory_target'"
op|':'
name|'mem'
op|','
nl|'\n'
string|"'name_description'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'name_label'"
op|':'
name|'name_label'
op|','
nl|'\n'
string|"'other_config'"
op|':'
op|'{'
string|"'nova_uuid'"
op|':'
name|'str'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
op|'}'
op|','
nl|'\n'
string|"'PCI_bus'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'platform'"
op|':'
op|'{'
string|"'acpi'"
op|':'
string|"'true'"
op|','
string|"'apic'"
op|':'
string|"'true'"
op|','
string|"'pae'"
op|':'
string|"'true'"
op|','
nl|'\n'
string|"'viridian'"
op|':'
name|'viridian'
op|','
string|"'timeoffset'"
op|':'
string|"'0'"
op|'}'
op|','
nl|'\n'
string|"'PV_args'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'PV_bootloader'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'PV_bootloader_args'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'PV_kernel'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'PV_legacy_args'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'PV_ramdisk'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'recommendations'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'tags'"
op|':'
op|'['
op|']'
op|','
nl|'\n'
string|"'user_version'"
op|':'
string|"'0'"
op|','
nl|'\n'
string|"'VCPUs_at_startup'"
op|':'
name|'vcpus'
op|','
nl|'\n'
string|"'VCPUs_max'"
op|':'
name|'vcpus'
op|','
nl|'\n'
string|"'VCPUs_params'"
op|':'
name|'vcpu_params'
op|','
nl|'\n'
string|"'xenstore_data'"
op|':'
op|'{'
string|"'vm-data/allowvssprovider'"
op|':'
string|"'false'"
op|'}'
op|'}'
newline|'\n'
nl|'\n'
comment|'# Complete VM configuration record according to the image type'
nl|'\n'
comment|'# non-raw/raw with PV kernel/raw in HVM mode'
nl|'\n'
name|'if'
name|'use_pv_kernel'
op|':'
newline|'\n'
indent|'        '
name|'rec'
op|'['
string|"'platform'"
op|']'
op|'['
string|"'nx'"
op|']'
op|'='
string|"'false'"
newline|'\n'
name|'if'
name|'instance'
op|'['
string|"'kernel_id'"
op|']'
op|':'
newline|'\n'
comment|'# 1. Kernel explicitly passed in, use that'
nl|'\n'
indent|'            '
name|'rec'
op|'['
string|"'PV_args'"
op|']'
op|'='
string|"'root=/dev/xvda1'"
newline|'\n'
name|'rec'
op|'['
string|"'PV_kernel'"
op|']'
op|'='
name|'kernel'
newline|'\n'
name|'rec'
op|'['
string|"'PV_ramdisk'"
op|']'
op|'='
name|'ramdisk'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# 2. Use kernel within the image'
nl|'\n'
indent|'            '
name|'rec'
op|'['
string|"'PV_bootloader'"
op|']'
op|'='
string|"'pygrub'"
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# 3. Using hardware virtualization'
nl|'\n'
indent|'        '
name|'rec'
op|'['
string|"'platform'"
op|']'
op|'['
string|"'nx'"
op|']'
op|'='
string|"'true'"
newline|'\n'
name|'rec'
op|'['
string|"'HVM_boot_params'"
op|']'
op|'='
op|'{'
string|"'order'"
op|':'
string|"'dc'"
op|'}'
newline|'\n'
name|'rec'
op|'['
string|"'HVM_boot_policy'"
op|']'
op|'='
string|"'BIOS order'"
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'device_id'
op|':'
newline|'\n'
indent|'        '
name|'rec'
op|'['
string|"'platform'"
op|']'
op|'['
string|"'device_id'"
op|']'
op|'='
name|'device_id'
newline|'\n'
nl|'\n'
dedent|''
name|'vm_ref'
op|'='
name|'session'
op|'.'
name|'VM'
op|'.'
name|'create'
op|'('
name|'rec'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Created VM'"
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'vm_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|destroy_vm
dedent|''
name|'def'
name|'destroy_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Destroys a VM record."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'VM'
op|'.'
name|'destroy'
op|'('
name|'vm_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Destroy VM failed'"
op|')'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"VM destroyed"'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|clean_shutdown_vm
dedent|''
name|'def'
name|'clean_shutdown_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'is_vm_shutdown'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"VM already halted, skipping shutdown..."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Shutting down VM (cleanly)"'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VM.clean_shutdown'"
op|','
name|'vm_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Shutting down VM (cleanly) failed.'"
op|')'
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'return'
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|hard_shutdown_vm
dedent|''
name|'def'
name|'hard_shutdown_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'is_vm_shutdown'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"VM already halted, skipping shutdown..."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Shutting down VM (hard)"'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VM.hard_shutdown'"
op|','
name|'vm_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Shutting down VM (hard) failed'"
op|')'
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'return'
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|is_vm_shutdown
dedent|''
name|'def'
name|'is_vm_shutdown'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'state'
op|'='
name|'get_power_state'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|is_enough_free_mem
dedent|''
name|'def'
name|'is_enough_free_mem'
op|'('
name|'session'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'flavor'
op|'='
name|'instance'
op|'.'
name|'get_flavor'
op|'('
op|')'
newline|'\n'
name|'mem'
op|'='
name|'long'
op|'('
name|'flavor'
op|'.'
name|'memory_mb'
op|')'
op|'*'
name|'units'
op|'.'
name|'Mi'
newline|'\n'
name|'host_free_mem'
op|'='
name|'long'
op|'('
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"host.compute_free_memory"'
op|','
nl|'\n'
name|'session'
op|'.'
name|'host_ref'
op|')'
op|')'
newline|'\n'
name|'return'
name|'host_free_mem'
op|'>='
name|'mem'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_should_retry_unplug_vbd
dedent|''
name|'def'
name|'_should_retry_unplug_vbd'
op|'('
name|'err'
op|')'
op|':'
newline|'\n'
comment|'# Retry if unplug failed with DEVICE_DETACH_REJECTED'
nl|'\n'
comment|"# For reasons which we don't understand,"
nl|'\n'
comment|"# we're seeing the device still in use, even when all processes"
nl|'\n'
comment|'# using the device should be dead.'
nl|'\n'
comment|'# Since XenServer 6.2, we also need to retry if we get'
nl|'\n'
comment|'# INTERNAL_ERROR, as that error goes away when you retry.'
nl|'\n'
indent|'    '
name|'return'
op|'('
name|'err'
op|'=='
string|"'DEVICE_DETACH_REJECTED'"
nl|'\n'
name|'or'
nl|'\n'
name|'err'
op|'=='
string|"'INTERNAL_ERROR'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|unplug_vbd
dedent|''
name|'def'
name|'unplug_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|','
name|'this_vm_ref'
op|')'
op|':'
newline|'\n'
comment|'# make sure that perform at least once'
nl|'\n'
indent|'    '
name|'max_attempts'
op|'='
name|'max'
op|'('
number|'0'
op|','
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'num_vbd_unplug_retries'
op|')'
op|'+'
number|'1'
newline|'\n'
name|'for'
name|'num_attempt'
name|'in'
name|'range'
op|'('
number|'1'
op|','
name|'max_attempts'
op|'+'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'num_attempt'
op|'>'
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'greenthread'
op|'.'
name|'sleep'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'session'
op|'.'
name|'VBD'
op|'.'
name|'unplug'
op|'('
name|'vbd_ref'
op|','
name|'this_vm_ref'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'            '
name|'err'
op|'='
name|'len'
op|'('
name|'exc'
op|'.'
name|'details'
op|')'
op|'>'
number|'0'
name|'and'
name|'exc'
op|'.'
name|'details'
op|'['
number|'0'
op|']'
newline|'\n'
name|'if'
name|'err'
op|'=='
string|"'DEVICE_ALREADY_DETACHED'"
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'VBD %s already detached'"
op|')'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'elif'
name|'_should_retry_unplug_vbd'
op|'('
name|'err'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'\'VBD %(vbd_ref)s uplug failed with "%(err)s", \''
nl|'\n'
string|"'attempt %(num_attempt)d/%(max_attempts)d'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'vbd_ref'"
op|':'
name|'vbd_ref'
op|','
string|"'num_attempt'"
op|':'
name|'num_attempt'
op|','
nl|'\n'
string|"'max_attempts'"
op|':'
name|'max_attempts'
op|','
string|"'err'"
op|':'
name|'err'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Unable to unplug VBD'"
op|')'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'StorageError'
op|'('
nl|'\n'
name|'reason'
op|'='
name|'_'
op|'('
string|"'Unable to unplug VBD %s'"
op|')'
op|'%'
name|'vbd_ref'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'StorageError'
op|'('
nl|'\n'
name|'reason'
op|'='
name|'_'
op|'('
string|"'Reached maximum number of retries '"
nl|'\n'
string|"'trying to unplug VBD %s'"
op|')'
nl|'\n'
op|'%'
name|'vbd_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|destroy_vbd
dedent|''
name|'def'
name|'destroy_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Destroy VBD from host database."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VBD.destroy'"
op|','
name|'vbd_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Unable to destroy VBD'"
op|')'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'StorageError'
op|'('
nl|'\n'
name|'reason'
op|'='
name|'_'
op|'('
string|"'Unable to destroy VBD %s'"
op|')'
op|'%'
name|'vbd_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|create_vbd
dedent|''
dedent|''
name|'def'
name|'create_vbd'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'vdi_ref'
op|','
name|'userdevice'
op|','
name|'vbd_type'
op|'='
string|"'disk'"
op|','
nl|'\n'
name|'read_only'
op|'='
name|'False'
op|','
name|'bootable'
op|'='
name|'False'
op|','
name|'osvol'
op|'='
name|'False'
op|','
nl|'\n'
name|'empty'
op|'='
name|'False'
op|','
name|'unpluggable'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Create a VBD record and returns its reference."""'
newline|'\n'
name|'vbd_rec'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'VM'"
op|']'
op|'='
name|'vm_ref'
newline|'\n'
name|'if'
name|'vdi_ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'vdi_ref'
op|'='
string|"'OpaqueRef:NULL'"
newline|'\n'
dedent|''
name|'vbd_rec'
op|'['
string|"'VDI'"
op|']'
op|'='
name|'vdi_ref'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'userdevice'"
op|']'
op|'='
name|'str'
op|'('
name|'userdevice'
op|')'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'bootable'"
op|']'
op|'='
name|'bootable'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'mode'"
op|']'
op|'='
name|'read_only'
name|'and'
string|"'RO'"
name|'or'
string|"'RW'"
newline|'\n'
name|'vbd_rec'
op|'['
string|"'type'"
op|']'
op|'='
name|'vbd_type'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'unpluggable'"
op|']'
op|'='
name|'unpluggable'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'empty'"
op|']'
op|'='
name|'empty'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'other_config'"
op|']'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'qos_algorithm_type'"
op|']'
op|'='
string|"''"
newline|'\n'
name|'vbd_rec'
op|'['
string|"'qos_algorithm_params'"
op|']'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'qos_supported_algorithms'"
op|']'
op|'='
op|'['
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Creating %(vbd_type)s-type VBD for VM %(vm_ref)s,'"
nl|'\n'
string|"' VDI %(vdi_ref)s ... '"
op|','
nl|'\n'
op|'{'
string|"'vbd_type'"
op|':'
name|'vbd_type'
op|','
string|"'vm_ref'"
op|':'
name|'vm_ref'
op|','
string|"'vdi_ref'"
op|':'
name|'vdi_ref'
op|'}'
op|')'
newline|'\n'
name|'vbd_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VBD.create'"
op|','
name|'vbd_rec'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Created VBD %(vbd_ref)s for VM %(vm_ref)s,'"
nl|'\n'
string|"' VDI %(vdi_ref)s.'"
op|','
nl|'\n'
op|'{'
string|"'vbd_ref'"
op|':'
name|'vbd_ref'
op|','
string|"'vm_ref'"
op|':'
name|'vm_ref'
op|','
string|"'vdi_ref'"
op|':'
name|'vdi_ref'
op|'}'
op|')'
newline|'\n'
name|'if'
name|'osvol'
op|':'
newline|'\n'
comment|'# set osvol=True in other-config to indicate this is an'
nl|'\n'
comment|'# attached nova (or cinder) volume'
nl|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VBD.add_to_other_config'"
op|','
nl|'\n'
name|'vbd_ref'
op|','
string|"'osvol'"
op|','
string|"'True'"
op|')'
newline|'\n'
dedent|''
name|'return'
name|'vbd_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|attach_cd
dedent|''
name|'def'
name|'attach_cd'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'vdi_ref'
op|','
name|'userdevice'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Create an empty VBD, then insert the CD."""'
newline|'\n'
name|'vbd_ref'
op|'='
name|'create_vbd'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'None'
op|','
name|'userdevice'
op|','
nl|'\n'
name|'vbd_type'
op|'='
string|"'cd'"
op|','
name|'read_only'
op|'='
name|'True'
op|','
nl|'\n'
name|'bootable'
op|'='
name|'True'
op|','
name|'empty'
op|'='
name|'True'
op|','
nl|'\n'
name|'unpluggable'
op|'='
name|'False'
op|')'
newline|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VBD.insert'"
op|','
name|'vbd_ref'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'return'
name|'vbd_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|destroy_vdi
dedent|''
name|'def'
name|'destroy_vdi'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.destroy'"
op|','
name|'vdi_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|':'
newline|'\n'
indent|'        '
name|'msg'
op|'='
string|'"Unable to destroy VDI %s"'
op|'%'
name|'vdi_ref'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'msg'
op|','
name|'exc_info'
op|'='
name|'True'
op|')'
newline|'\n'
name|'msg'
op|'='
name|'_'
op|'('
string|'"Unable to destroy VDI %s"'
op|')'
op|'%'
name|'vdi_ref'
newline|'\n'
name|'LOG'
op|'.'
name|'error'
op|'('
name|'msg'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'StorageError'
op|'('
name|'reason'
op|'='
name|'msg'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|safe_destroy_vdis
dedent|''
dedent|''
name|'def'
name|'safe_destroy_vdis'
op|'('
name|'session'
op|','
name|'vdi_refs'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Tries to destroy the requested VDIs, but ignores any errors."""'
newline|'\n'
name|'for'
name|'vdi_ref'
name|'in'
name|'vdi_refs'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'destroy_vdi'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'StorageError'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
string|'"Ignoring error while destroying VDI: %s"'
op|'%'
name|'vdi_ref'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|create_vdi
dedent|''
dedent|''
dedent|''
name|'def'
name|'create_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'disk_type'
op|','
name|'virtual_size'
op|','
nl|'\n'
name|'read_only'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Create a VDI record and returns its reference."""'
newline|'\n'
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.create"'
op|','
nl|'\n'
op|'{'
string|"'name_label'"
op|':'
name|'name_label'
op|','
nl|'\n'
string|"'name_description'"
op|':'
name|'disk_type'
op|','
nl|'\n'
string|"'SR'"
op|':'
name|'sr_ref'
op|','
nl|'\n'
string|"'virtual_size'"
op|':'
name|'str'
op|'('
name|'virtual_size'
op|')'
op|','
nl|'\n'
string|"'type'"
op|':'
string|"'User'"
op|','
nl|'\n'
string|"'sharable'"
op|':'
name|'False'
op|','
nl|'\n'
string|"'read_only'"
op|':'
name|'read_only'
op|','
nl|'\n'
string|"'xenstore_data'"
op|':'
op|'{'
op|'}'
op|','
nl|'\n'
string|"'other_config'"
op|':'
name|'_get_vdi_other_config'
op|'('
name|'disk_type'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
op|','
nl|'\n'
string|"'sm_config'"
op|':'
op|'{'
op|'}'
op|','
nl|'\n'
string|"'tags'"
op|':'
op|'['
op|']'
op|'}'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Created VDI %(vdi_ref)s (%(name_label)s,'"
nl|'\n'
string|"' %(virtual_size)s, %(read_only)s) on %(sr_ref)s.'"
op|','
nl|'\n'
op|'{'
string|"'vdi_ref'"
op|':'
name|'vdi_ref'
op|','
string|"'name_label'"
op|':'
name|'name_label'
op|','
nl|'\n'
string|"'virtual_size'"
op|':'
name|'virtual_size'
op|','
string|"'read_only'"
op|':'
name|'read_only'
op|','
nl|'\n'
string|"'sr_ref'"
op|':'
name|'sr_ref'
op|'}'
op|')'
newline|'\n'
name|'return'
name|'vdi_ref'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
op|'@'
name|'contextlib'
op|'.'
name|'contextmanager'
newline|'\n'
DECL|function|_dummy_vm
name|'def'
name|'_dummy_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vdi_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""This creates a temporary VM so that we can snapshot a VDI.\n\n    VDI\'s can\'t be snapshotted directly since the API expects a `vm_ref`. To\n    work around this, we need to create a temporary VM and then map the VDI to\n    the VM using a temporary VBD.\n    """'
newline|'\n'
name|'name_label'
op|'='
string|'"dummy"'
newline|'\n'
name|'vm_ref'
op|'='
name|'create_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'vbd_ref'
op|'='
name|'create_vbd'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'vdi_ref'
op|','
string|"'autodetect'"
op|','
nl|'\n'
name|'read_only'
op|'='
name|'True'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'yield'
name|'vm_ref'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'destroy_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'StorageError'
op|':'
newline|'\n'
comment|'# destroy_vbd() will log error'
nl|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'        '
name|'destroy_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_safe_copy_vdi
dedent|''
dedent|''
name|'def'
name|'_safe_copy_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
name|'vdi_to_copy_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Copy a VDI and return the new VDIs reference.\n\n    This function differs from the XenAPI `VDI.copy` call in that the copy is\n    atomic and isolated, meaning we don\'t see half-downloaded images. It\n    accomplishes this by copying the VDI\'s into a temporary directory and then\n    atomically renaming them into the SR when the copy is completed.\n\n    The correct long term solution is to fix `VDI.copy` so that it is atomic\n    and isolated.\n    """'
newline|'\n'
name|'with'
name|'_dummy_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vdi_to_copy_ref'
op|')'
name|'as'
name|'vm_ref'
op|':'
newline|'\n'
indent|'        '
name|'label'
op|'='
string|'"snapshot"'
newline|'\n'
name|'with'
name|'snapshot_attached_here'
op|'('
nl|'\n'
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'label'
op|')'
name|'as'
name|'vdi_uuids'
op|':'
newline|'\n'
indent|'            '
name|'imported_vhds'
op|'='
name|'session'
op|'.'
name|'call_plugin_serialized'
op|'('
nl|'\n'
string|"'workarounds'"
op|','
string|"'safe_copy_vdis'"
op|','
nl|'\n'
name|'sr_path'
op|'='
name|'get_sr_path'
op|'('
name|'session'
op|','
name|'sr_ref'
op|'='
name|'sr_ref'
op|')'
op|','
nl|'\n'
name|'vdi_uuids'
op|'='
name|'vdi_uuids'
op|','
name|'uuid_stack'
op|'='
name|'_make_uuid_stack'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'root_uuid'
op|'='
name|'imported_vhds'
op|'['
string|"'root'"
op|']'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
nl|'\n'
comment|'# rescan to discover new VHDs'
nl|'\n'
name|'scan_default_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_by_uuid'"
op|','
name|'root_uuid'
op|')'
newline|'\n'
name|'return'
name|'vdi_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_clone_vdi
dedent|''
name|'def'
name|'_clone_vdi'
op|'('
name|'session'
op|','
name|'vdi_to_clone_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Clones a VDI and return the new VDIs reference."""'
newline|'\n'
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.clone'"
op|','
name|'vdi_to_clone_ref'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Cloned VDI %(vdi_ref)s from VDI '"
nl|'\n'
string|"'%(vdi_to_clone_ref)s'"
op|','
nl|'\n'
op|'{'
string|"'vdi_ref'"
op|':'
name|'vdi_ref'
op|','
string|"'vdi_to_clone_ref'"
op|':'
name|'vdi_to_clone_ref'
op|'}'
op|')'
newline|'\n'
name|'return'
name|'vdi_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_vdi_other_config
dedent|''
name|'def'
name|'_get_vdi_other_config'
op|'('
name|'disk_type'
op|','
name|'instance'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return metadata to store in VDI\'s other_config attribute.\n\n    `nova_instance_uuid` is used to associate a VDI with a particular instance\n    so that, if it becomes orphaned from an unclean shutdown of a\n    compute-worker, we can safely detach it.\n    """'
newline|'\n'
name|'other_config'
op|'='
op|'{'
string|"'nova_disk_type'"
op|':'
name|'disk_type'
op|'}'
newline|'\n'
nl|'\n'
comment|'# create_vdi may be called simply while creating a volume'
nl|'\n'
comment|'# hence information about instance may or may not be present'
nl|'\n'
name|'if'
name|'instance'
op|':'
newline|'\n'
indent|'        '
name|'other_config'
op|'['
string|"'nova_instance_uuid'"
op|']'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'other_config'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_set_vdi_info
dedent|''
name|'def'
name|'_set_vdi_info'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'vdi_type'
op|','
name|'name_label'
op|','
name|'description'
op|','
nl|'\n'
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'existing_other_config'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_other_config'"
op|','
nl|'\n'
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.set_name_label'"
op|','
name|'vdi_ref'
op|','
name|'name_label'
op|')'
newline|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.set_name_description'"
op|','
name|'vdi_ref'
op|','
name|'description'
op|')'
newline|'\n'
nl|'\n'
name|'other_config'
op|'='
name|'_get_vdi_other_config'
op|'('
name|'vdi_type'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'for'
name|'key'
op|','
name|'value'
name|'in'
name|'six'
op|'.'
name|'iteritems'
op|'('
name|'other_config'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'key'
name|'not'
name|'in'
name|'existing_other_config'
op|':'
newline|'\n'
indent|'            '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
nl|'\n'
string|'"VDI.add_to_other_config"'
op|','
name|'vdi_ref'
op|','
name|'key'
op|','
name|'value'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_vm_get_vbd_refs
dedent|''
dedent|''
dedent|''
name|'def'
name|'_vm_get_vbd_refs'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'return'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_VBDs"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_vbd_get_rec
dedent|''
name|'def'
name|'_vbd_get_rec'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'return'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VBD.get_record"'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_vdi_get_rec
dedent|''
name|'def'
name|'_vdi_get_rec'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'return'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_record"'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_vdi_get_uuid
dedent|''
name|'def'
name|'_vdi_get_uuid'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'return'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_uuid"'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_vdi_snapshot
dedent|''
name|'def'
name|'_vdi_snapshot'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'return'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.snapshot"'
op|','
name|'vdi_ref'
op|','
op|'{'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_vdi_for_vm_safely
dedent|''
name|'def'
name|'get_vdi_for_vm_safely'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'userdevice'
op|'='
string|"'0'"
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Retrieves the primary VDI for a VM."""'
newline|'\n'
name|'vbd_refs'
op|'='
name|'_vm_get_vbd_refs'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'for'
name|'vbd_ref'
name|'in'
name|'vbd_refs'
op|':'
newline|'\n'
indent|'        '
name|'vbd_rec'
op|'='
name|'_vbd_get_rec'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
comment|'# Convention dictates the primary VDI will be userdevice 0'
nl|'\n'
name|'if'
name|'vbd_rec'
op|'['
string|"'userdevice'"
op|']'
op|'=='
name|'userdevice'
op|':'
newline|'\n'
indent|'            '
name|'vdi_ref'
op|'='
name|'vbd_rec'
op|'['
string|"'VDI'"
op|']'
newline|'\n'
name|'vdi_rec'
op|'='
name|'_vdi_get_rec'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'return'
name|'vdi_ref'
op|','
name|'vdi_rec'
newline|'\n'
dedent|''
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'_'
op|'('
string|'"No primary VDI found for %s"'
op|')'
op|'%'
name|'vm_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_all_vdi_uuids_for_vm
dedent|''
name|'def'
name|'get_all_vdi_uuids_for_vm'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'min_userdevice'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vbd_refs'
op|'='
name|'_vm_get_vbd_refs'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'for'
name|'vbd_ref'
name|'in'
name|'vbd_refs'
op|':'
newline|'\n'
indent|'        '
name|'vbd_rec'
op|'='
name|'_vbd_get_rec'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'if'
name|'int'
op|'('
name|'vbd_rec'
op|'['
string|"'userdevice'"
op|']'
op|')'
op|'>='
name|'min_userdevice'
op|':'
newline|'\n'
indent|'            '
name|'vdi_ref'
op|'='
name|'vbd_rec'
op|'['
string|"'VDI'"
op|']'
newline|'\n'
name|'yield'
name|'_vdi_get_uuid'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_try_strip_base_mirror_from_vdi
dedent|''
dedent|''
dedent|''
name|'def'
name|'_try_strip_base_mirror_from_vdi'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.remove_from_sm_config"'
op|','
name|'vdi_ref'
op|','
nl|'\n'
string|'"base_mirror"'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Error while removing sm_config"'
op|','
name|'exc_info'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|strip_base_mirror_from_vdis
dedent|''
dedent|''
name|'def'
name|'strip_base_mirror_from_vdis'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(johngarbutt) part of workaround for XenServer bug CA-98606'
nl|'\n'
indent|'    '
name|'vbd_refs'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_VBDs"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'for'
name|'vbd_ref'
name|'in'
name|'vbd_refs'
op|':'
newline|'\n'
indent|'        '
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VBD.get_VDI"'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'_try_strip_base_mirror_from_vdi'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_delete_snapshots_in_vdi_chain
dedent|''
dedent|''
name|'def'
name|'_delete_snapshots_in_vdi_chain'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vdi_uuid_chain'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'possible_snapshot_parents'
op|'='
name|'vdi_uuid_chain'
op|'['
number|'1'
op|':'
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'possible_snapshot_parents'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"No VHD chain."'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'snapshot_uuids'
op|'='
name|'_child_vhds'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'possible_snapshot_parents'
op|','
nl|'\n'
name|'old_snapshots_only'
op|'='
name|'True'
op|')'
newline|'\n'
name|'number_of_snapshots'
op|'='
name|'len'
op|'('
name|'snapshot_uuids'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'number_of_snapshots'
op|'<='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"No snapshots to remove."'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'vdi_refs'
op|'='
op|'['
name|'session'
op|'.'
name|'VDI'
op|'.'
name|'get_by_uuid'
op|'('
name|'vdi_uuid'
op|')'
nl|'\n'
name|'for'
name|'vdi_uuid'
name|'in'
name|'snapshot_uuids'
op|']'
newline|'\n'
name|'safe_destroy_vdis'
op|'('
name|'session'
op|','
name|'vdi_refs'
op|')'
newline|'\n'
nl|'\n'
comment|'# ensure garbage collector has been run'
nl|'\n'
name|'_scan_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Deleted %s snapshots."'
op|')'
op|'%'
name|'number_of_snapshots'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|remove_old_snapshots
dedent|''
name|'def'
name|'remove_old_snapshots'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""See if there is an snapshot present that should be removed."""'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Starting remove_old_snapshots for VM"'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'vm_vdi_ref'
op|','
name|'vm_vdi_rec'
op|'='
name|'get_vdi_for_vm_safely'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'chain'
op|'='
name|'_walk_vdi_chain'
op|'('
name|'session'
op|','
name|'vm_vdi_rec'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
name|'vdi_uuid_chain'
op|'='
op|'['
name|'vdi_rec'
op|'['
string|"'uuid'"
op|']'
name|'for'
name|'vdi_rec'
name|'in'
name|'chain'
op|']'
newline|'\n'
name|'sr_ref'
op|'='
name|'vm_vdi_rec'
op|'['
string|'"SR"'
op|']'
newline|'\n'
name|'_delete_snapshots_in_vdi_chain'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vdi_uuid_chain'
op|','
name|'sr_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
op|'@'
name|'contextlib'
op|'.'
name|'contextmanager'
newline|'\n'
DECL|function|snapshot_attached_here
name|'def'
name|'snapshot_attached_here'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'label'
op|','
name|'userdevice'
op|'='
string|"'0'"
op|','
nl|'\n'
name|'post_snapshot_callback'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
comment|'# impl method allow easier patching for tests'
nl|'\n'
indent|'    '
name|'return'
name|'_snapshot_attached_here_impl'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'label'
op|','
nl|'\n'
name|'userdevice'
op|','
name|'post_snapshot_callback'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_snapshot_attached_here_impl
dedent|''
name|'def'
name|'_snapshot_attached_here_impl'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'label'
op|','
name|'userdevice'
op|','
nl|'\n'
name|'post_snapshot_callback'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Snapshot the root disk only.  Return a list of uuids for the vhds\n    in the chain.\n    """'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Starting snapshot for VM"'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# Memorize the VDI chain so we can poll for coalesce'
nl|'\n'
name|'vm_vdi_ref'
op|','
name|'vm_vdi_rec'
op|'='
name|'get_vdi_for_vm_safely'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
nl|'\n'
name|'userdevice'
op|')'
newline|'\n'
name|'chain'
op|'='
name|'_walk_vdi_chain'
op|'('
name|'session'
op|','
name|'vm_vdi_rec'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
name|'vdi_uuid_chain'
op|'='
op|'['
name|'vdi_rec'
op|'['
string|"'uuid'"
op|']'
name|'for'
name|'vdi_rec'
name|'in'
name|'chain'
op|']'
newline|'\n'
name|'sr_ref'
op|'='
name|'vm_vdi_rec'
op|'['
string|'"SR"'
op|']'
newline|'\n'
nl|'\n'
comment|'# clean up after any interrupted snapshot attempts'
nl|'\n'
name|'_delete_snapshots_in_vdi_chain'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vdi_uuid_chain'
op|','
name|'sr_ref'
op|')'
newline|'\n'
nl|'\n'
name|'snapshot_ref'
op|'='
name|'_vdi_snapshot'
op|'('
name|'session'
op|','
name|'vm_vdi_ref'
op|')'
newline|'\n'
name|'if'
name|'post_snapshot_callback'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'post_snapshot_callback'
op|'('
name|'task_state'
op|'='
name|'task_states'
op|'.'
name|'IMAGE_PENDING_UPLOAD'
op|')'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
comment|'# When the VDI snapshot is taken a new parent is introduced.'
nl|'\n'
comment|'# If we have taken a snapshot before, the new parent can be coalesced.'
nl|'\n'
comment|'# We need to wait for this to happen before trying to copy the chain.'
nl|'\n'
indent|'        '
name|'_wait_for_vhd_coalesce'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'sr_ref'
op|','
name|'vm_vdi_ref'
op|','
nl|'\n'
name|'vdi_uuid_chain'
op|')'
newline|'\n'
nl|'\n'
name|'snapshot_uuid'
op|'='
name|'_vdi_get_uuid'
op|'('
name|'session'
op|','
name|'snapshot_ref'
op|')'
newline|'\n'
name|'chain'
op|'='
name|'_walk_vdi_chain'
op|'('
name|'session'
op|','
name|'snapshot_uuid'
op|')'
newline|'\n'
name|'vdi_uuids'
op|'='
op|'['
name|'vdi_rec'
op|'['
string|"'uuid'"
op|']'
name|'for'
name|'vdi_rec'
name|'in'
name|'chain'
op|']'
newline|'\n'
name|'yield'
name|'vdi_uuids'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'        '
name|'safe_destroy_vdis'
op|'('
name|'session'
op|','
op|'['
name|'snapshot_ref'
op|']'
op|')'
newline|'\n'
comment|'# TODO(johngarbut) we need to check the snapshot has been coalesced'
nl|'\n'
comment|'# now its associated VDI has been deleted.'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_sr_path
dedent|''
dedent|''
name|'def'
name|'get_sr_path'
op|'('
name|'session'
op|','
name|'sr_ref'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the path to our storage repository\n\n    This is used when we\'re dealing with VHDs directly, either by taking\n    snapshots or by restoring an image in the DISK_VHD format.\n    """'
newline|'\n'
name|'if'
name|'sr_ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'sr_ref'
op|'='
name|'safe_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
dedent|''
name|'pbd_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"PBD.get_all_records_where"'
op|','
nl|'\n'
string|'\'field "host"="%s" and \''
nl|'\n'
string|'\'field "SR"="%s"\''
op|'%'
nl|'\n'
op|'('
name|'session'
op|'.'
name|'host_ref'
op|','
name|'sr_ref'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(bobball): There can only be one PBD for a host/SR pair, but path is'
nl|'\n'
comment|'# not always present - older versions of XS do not set it.'
nl|'\n'
name|'pbd_ref'
op|'='
name|'pbd_rec'
op|'.'
name|'keys'
op|'('
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'device_config'
op|'='
name|'pbd_rec'
op|'['
name|'pbd_ref'
op|']'
op|'['
string|"'device_config'"
op|']'
newline|'\n'
name|'if'
string|"'path'"
name|'in'
name|'device_config'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'device_config'
op|'['
string|"'path'"
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'sr_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"SR.get_record"'
op|','
name|'sr_ref'
op|')'
newline|'\n'
name|'sr_uuid'
op|'='
name|'sr_rec'
op|'['
string|'"uuid"'
op|']'
newline|'\n'
name|'if'
name|'sr_rec'
op|'['
string|'"type"'
op|']'
name|'not'
name|'in'
op|'['
string|'"ext"'
op|','
string|'"nfs"'
op|']'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
nl|'\n'
name|'_'
op|'('
string|'"Only file-based SRs (ext/NFS) are supported by this feature."'
nl|'\n'
string|'"  SR %(uuid)s is of type %(type)s"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|'"uuid"'
op|':'
name|'sr_uuid'
op|','
string|'"type"'
op|':'
name|'sr_rec'
op|'['
string|'"type"'
op|']'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'sr_base_path'
op|','
name|'sr_uuid'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|destroy_cached_images
dedent|''
name|'def'
name|'destroy_cached_images'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'all_cached'
op|'='
name|'False'
op|','
name|'dry_run'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Destroy used or unused cached images.\n\n    A cached image that is being used by at least one VM is said to be \'used\'.\n\n    In the case of an \'unused\' image, the cached image will be the only\n    descendent of the base-copy. So when we delete the cached-image, the\n    refcount will drop to zero and XenServer will automatically destroy the\n    base-copy for us.\n\n    The default behavior of this function is to destroy only \'unused\' cached\n    images. To destroy all cached images, use the `all_cached=True` kwarg.\n    """'
newline|'\n'
name|'cached_images'
op|'='
name|'_find_cached_images'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
newline|'\n'
name|'destroyed'
op|'='
name|'set'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|destroy_cached_vdi
name|'def'
name|'destroy_cached_vdi'
op|'('
name|'vdi_uuid'
op|','
name|'vdi_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Destroying cached VDI \'%(vdi_uuid)s\'"'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'dry_run'
op|':'
newline|'\n'
indent|'            '
name|'destroy_vdi'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
dedent|''
name|'destroyed'
op|'.'
name|'add'
op|'('
name|'vdi_uuid'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'vdi_ref'
name|'in'
name|'cached_images'
op|'.'
name|'values'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'vdi_uuid'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_uuid'"
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'all_cached'
op|':'
newline|'\n'
indent|'            '
name|'destroy_cached_vdi'
op|'('
name|'vdi_uuid'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
comment|'# Unused-Only: Search for siblings'
nl|'\n'
nl|'\n'
comment|'# Chain length greater than two implies a VM must be holding a ref to'
nl|'\n'
comment|'# the base-copy (otherwise it would have coalesced), so consider this'
nl|'\n'
comment|'# cached image used.'
nl|'\n'
dedent|''
name|'chain'
op|'='
name|'list'
op|'('
name|'_walk_vdi_chain'
op|'('
name|'session'
op|','
name|'vdi_uuid'
op|')'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'chain'
op|')'
op|'>'
number|'2'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
dedent|''
name|'elif'
name|'len'
op|'('
name|'chain'
op|')'
op|'=='
number|'2'
op|':'
newline|'\n'
comment|'# Siblings imply cached image is used'
nl|'\n'
indent|'            '
name|'root_vdi_rec'
op|'='
name|'chain'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
name|'children'
op|'='
name|'_child_vhds'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
op|'['
name|'root_vdi_rec'
op|'['
string|"'uuid'"
op|']'
op|']'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'children'
op|')'
op|'>'
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'destroy_cached_vdi'
op|'('
name|'vdi_uuid'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'destroyed'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_find_cached_images
dedent|''
name|'def'
name|'_find_cached_images'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return a dict(uuid=vdi_ref) representing all cached images."""'
newline|'\n'
name|'cached_images'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'vdi_ref'
op|','
name|'vdi_rec'
name|'in'
name|'_get_all_vdis_in_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'image_id'
op|'='
name|'vdi_rec'
op|'['
string|"'other_config'"
op|']'
op|'['
string|"'image-id'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'cached_images'
op|'['
name|'image_id'
op|']'
op|'='
name|'vdi_ref'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'cached_images'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_find_cached_image
dedent|''
name|'def'
name|'_find_cached_image'
op|'('
name|'session'
op|','
name|'image_id'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Returns the vdi-ref of the cached image."""'
newline|'\n'
name|'name_label'
op|'='
name|'_get_image_vdi_label'
op|'('
name|'image_id'
op|')'
newline|'\n'
name|'recs'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_all_records_where"'
op|','
nl|'\n'
string|'\'field "name__label"="%s"\''
nl|'\n'
op|'%'
name|'name_label'
op|')'
newline|'\n'
name|'number_found'
op|'='
name|'len'
op|'('
name|'recs'
op|')'
newline|'\n'
name|'if'
name|'number_found'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'number_found'
op|'>'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"Multiple base images for image: %s"'
op|')'
op|','
name|'image_id'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'recs'
op|'.'
name|'keys'
op|'('
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_resize_func_name
dedent|''
dedent|''
name|'def'
name|'_get_resize_func_name'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'brand'
op|'='
name|'session'
op|'.'
name|'product_brand'
newline|'\n'
name|'version'
op|'='
name|'session'
op|'.'
name|'product_version'
newline|'\n'
nl|'\n'
comment|'# To maintain backwards compatibility. All recent versions'
nl|'\n'
comment|'# should use VDI.resize'
nl|'\n'
name|'if'
name|'version'
name|'and'
name|'brand'
op|':'
newline|'\n'
indent|'        '
name|'xcp'
op|'='
name|'brand'
op|'=='
string|"'XCP'"
newline|'\n'
name|'r1_2_or_above'
op|'='
op|'('
name|'version'
op|'['
number|'0'
op|']'
op|'=='
number|'1'
name|'and'
name|'version'
op|'['
number|'1'
op|']'
op|'>'
number|'1'
op|')'
name|'or'
name|'version'
op|'['
number|'0'
op|']'
op|'>'
number|'1'
newline|'\n'
nl|'\n'
name|'xenserver'
op|'='
name|'brand'
op|'=='
string|"'XenServer'"
newline|'\n'
name|'r6_or_above'
op|'='
name|'version'
op|'['
number|'0'
op|']'
op|'>'
number|'5'
newline|'\n'
nl|'\n'
name|'if'
op|'('
name|'xcp'
name|'and'
name|'not'
name|'r1_2_or_above'
op|')'
name|'or'
op|'('
name|'xenserver'
name|'and'
name|'not'
name|'r6_or_above'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
string|"'VDI.resize_online'"
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
string|"'VDI.resize'"
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_vdi_get_virtual_size
dedent|''
name|'def'
name|'_vdi_get_virtual_size'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'size'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_virtual_size'"
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'return'
name|'int'
op|'('
name|'size'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_vdi_resize
dedent|''
name|'def'
name|'_vdi_resize'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'new_size'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'resize_func_name'
op|'='
name|'_get_resize_func_name'
op|'('
name|'session'
op|')'
newline|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
name|'resize_func_name'
op|','
name|'vdi_ref'
op|','
name|'str'
op|'('
name|'new_size'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|update_vdi_virtual_size
dedent|''
name|'def'
name|'update_vdi_virtual_size'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vdi_ref'
op|','
name|'new_gb'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'virtual_size'
op|'='
name|'_vdi_get_virtual_size'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'new_disk_size'
op|'='
name|'new_gb'
op|'*'
name|'units'
op|'.'
name|'Gi'
newline|'\n'
nl|'\n'
name|'msg'
op|'='
op|'('
string|'"Resizing up VDI %(vdi_ref)s from %(virtual_size)d "'
nl|'\n'
string|'"to %(new_disk_size)d"'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'msg'
op|','
op|'{'
string|"'vdi_ref'"
op|':'
name|'vdi_ref'
op|','
string|"'virtual_size'"
op|':'
name|'virtual_size'
op|','
nl|'\n'
string|"'new_disk_size'"
op|':'
name|'new_disk_size'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'virtual_size'
op|'<'
name|'new_disk_size'
op|':'
newline|'\n'
comment|'# For resize up. Simple VDI resize will do the trick'
nl|'\n'
indent|'        '
name|'_vdi_resize'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'new_disk_size'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'virtual_size'
op|'=='
name|'new_disk_size'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"No need to change vdi virtual size."'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# NOTE(johngarbutt): we should never get here'
nl|'\n'
comment|"# but if we don't raise an exception, a user might be able to use"
nl|'\n'
comment|'# more storage than allowed by their chosen instance flavor'
nl|'\n'
indent|'        '
name|'msg'
op|'='
name|'_'
op|'('
string|'"VDI %(vdi_ref)s is %(virtual_size)d bytes which is larger "'
nl|'\n'
string|'"than flavor size of %(new_disk_size)d bytes."'
op|')'
newline|'\n'
name|'msg'
op|'='
name|'msg'
op|'%'
op|'{'
string|"'vdi_ref'"
op|':'
name|'vdi_ref'
op|','
string|"'virtual_size'"
op|':'
name|'virtual_size'
op|','
nl|'\n'
string|"'new_disk_size'"
op|':'
name|'new_disk_size'
op|'}'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'msg'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'ResizeError'
op|'('
name|'reason'
op|'='
name|'msg'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|resize_disk
dedent|''
dedent|''
name|'def'
name|'resize_disk'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vdi_ref'
op|','
name|'flavor'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'size_gb'
op|'='
name|'flavor'
op|'.'
name|'root_gb'
newline|'\n'
name|'if'
name|'size_gb'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'reason'
op|'='
name|'_'
op|'('
string|'"Can\'t resize a disk to 0 GB."'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'ResizeError'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'sr_ref'
op|'='
name|'safe_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'clone_ref'
op|'='
name|'_clone_vdi'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# Resize partition and filesystem down'
nl|'\n'
indent|'        '
name|'_auto_configure_disk'
op|'('
name|'session'
op|','
name|'clone_ref'
op|','
name|'size_gb'
op|')'
newline|'\n'
nl|'\n'
comment|'# Create new VDI'
nl|'\n'
name|'vdi_size'
op|'='
name|'size_gb'
op|'*'
name|'units'
op|'.'
name|'Gi'
newline|'\n'
comment|'# NOTE(johannes): No resizing allowed for rescue instances, so'
nl|'\n'
comment|"# using instance['name'] is safe here"
nl|'\n'
name|'new_ref'
op|'='
name|'create_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
name|'instance'
op|'['
string|"'name'"
op|']'
op|','
nl|'\n'
string|"'root'"
op|','
name|'vdi_size'
op|')'
newline|'\n'
nl|'\n'
name|'new_uuid'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_uuid'"
op|','
name|'new_ref'
op|')'
newline|'\n'
nl|'\n'
comment|'# Manually copy contents over'
nl|'\n'
name|'virtual_size'
op|'='
name|'size_gb'
op|'*'
name|'units'
op|'.'
name|'Gi'
newline|'\n'
name|'_copy_partition'
op|'('
name|'session'
op|','
name|'clone_ref'
op|','
name|'new_ref'
op|','
number|'1'
op|','
name|'virtual_size'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'new_ref'
op|','
name|'new_uuid'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'        '
name|'destroy_vdi'
op|'('
name|'session'
op|','
name|'clone_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_auto_configure_disk
dedent|''
dedent|''
name|'def'
name|'_auto_configure_disk'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'new_gb'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Partition and resize FS to match the size specified by\n    flavors.root_gb.\n\n    This is a fail-safe to prevent accidentally destroying data on a disk\n    erroneously marked as auto_disk_config=True.\n\n    The criteria for allowing resize are:\n\n        1. \'auto_disk_config\' must be true for the instance (and image).\n           (If we\'ve made it here, then auto_disk_config=True.)\n\n        2. The disk must have only one partition.\n\n        3. The file-system on the one partition must be ext3 or ext4.\n    """'
newline|'\n'
name|'if'
name|'new_gb'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Skipping auto_config_disk as destination size is 0GB"'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
name|'as'
name|'dev'
op|':'
newline|'\n'
indent|'        '
name|'partitions'
op|'='
name|'_get_partitions'
op|'('
name|'dev'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'partitions'
op|')'
op|'!='
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
name|'_'
op|'('
string|"'Disk must have only one partition.'"
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'CannotResizeDisk'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'num'
op|','
name|'start'
op|','
name|'old_sectors'
op|','
name|'fstype'
op|','
name|'name'
op|','
name|'flags'
op|'='
name|'partitions'
op|'['
number|'0'
op|']'
newline|'\n'
name|'if'
name|'fstype'
name|'not'
name|'in'
op|'('
string|"'ext3'"
op|','
string|"'ext4'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
name|'_'
op|'('
string|"'Disk contains a filesystem '"
nl|'\n'
string|"'we are unable to resize: %s'"
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'CannotResizeDisk'
op|'('
name|'reason'
op|'='
op|'('
name|'reason'
op|'%'
name|'fstype'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'num'
op|'!='
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
name|'_'
op|'('
string|"'The only partition should be partition 1.'"
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'CannotResizeDisk'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'new_sectors'
op|'='
name|'new_gb'
op|'*'
name|'units'
op|'.'
name|'Gi'
op|'/'
name|'SECTOR_SIZE'
newline|'\n'
name|'_resize_part_and_fs'
op|'('
name|'dev'
op|','
name|'start'
op|','
name|'old_sectors'
op|','
name|'new_sectors'
op|','
name|'flags'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|try_auto_configure_disk
dedent|''
dedent|''
name|'def'
name|'try_auto_configure_disk'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'new_gb'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'_auto_configure_disk'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'new_gb'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'CannotResizeDisk'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'msg'
op|'='
name|'_LW'
op|'('
string|"'Attempted auto_configure_disk failed because: %s'"
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'msg'
op|'%'
name|'e'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_make_partition
dedent|''
dedent|''
name|'def'
name|'_make_partition'
op|'('
name|'session'
op|','
name|'dev'
op|','
name|'partition_start'
op|','
name|'partition_end'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(bobball) If this runs in Dom0, parted will error trying'
nl|'\n'
comment|'# to re-read the partition table and return a generic error'
nl|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'parted'"
op|','
string|"'--script'"
op|','
name|'dev_path'
op|','
nl|'\n'
string|"'mklabel'"
op|','
string|"'msdos'"
op|','
name|'run_as_root'
op|'='
name|'True'
op|','
nl|'\n'
name|'check_exit_code'
op|'='
name|'not'
name|'session'
op|'.'
name|'is_local_connection'
op|')'
newline|'\n'
nl|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'parted'"
op|','
string|"'--script'"
op|','
name|'dev_path'
op|','
string|"'--'"
op|','
nl|'\n'
string|"'mkpart'"
op|','
string|"'primary'"
op|','
nl|'\n'
name|'partition_start'
op|','
nl|'\n'
name|'partition_end'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|','
nl|'\n'
name|'check_exit_code'
op|'='
name|'not'
name|'session'
op|'.'
name|'is_local_connection'
op|')'
newline|'\n'
nl|'\n'
name|'partition_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|','
name|'partition'
op|'='
number|'1'
op|')'
newline|'\n'
name|'if'
name|'session'
op|'.'
name|'is_local_connection'
op|':'
newline|'\n'
comment|'# Need to refresh the partitions'
nl|'\n'
indent|'        '
name|'utils'
op|'.'
name|'trycmd'
op|'('
string|"'kpartx'"
op|','
string|"'-a'"
op|','
name|'dev_path'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|','
nl|'\n'
name|'discard_warnings'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
comment|'# Sometimes the partition gets created under /dev/mapper, depending'
nl|'\n'
comment|'# on the setup in dom0.'
nl|'\n'
name|'mapper_path'
op|'='
string|"'/dev/mapper/%s'"
op|'%'
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'partition_path'
op|')'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'mapper_path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'mapper_path'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'partition_path'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_generate_disk
dedent|''
name|'def'
name|'_generate_disk'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'userdevice'
op|','
name|'name_label'
op|','
nl|'\n'
name|'disk_type'
op|','
name|'size_mb'
op|','
name|'fs_type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Steps to programmatically generate a disk:\n\n        1. Create VDI of desired size\n\n        2. Attach VDI to compute worker\n\n        3. Create partition\n\n        4. Create VBD between instance VM and VDI\n    """'
newline|'\n'
comment|'# 1. Create VDI'
nl|'\n'
name|'sr_ref'
op|'='
name|'safe_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'ONE_MEG'
op|'='
name|'units'
op|'.'
name|'Mi'
newline|'\n'
name|'virtual_size'
op|'='
name|'size_mb'
op|'*'
name|'ONE_MEG'
newline|'\n'
name|'vdi_ref'
op|'='
name|'create_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'disk_type'
op|','
nl|'\n'
name|'virtual_size'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# 2. Attach VDI to compute worker (VBD hotplug)'
nl|'\n'
indent|'        '
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
name|'as'
name|'dev'
op|':'
newline|'\n'
comment|'# 3. Create partition'
nl|'\n'
indent|'            '
name|'partition_start'
op|'='
string|'"2048s"'
newline|'\n'
name|'partition_end'
op|'='
string|'"-0"'
newline|'\n'
nl|'\n'
name|'partition_path'
op|'='
name|'_make_partition'
op|'('
name|'session'
op|','
name|'dev'
op|','
nl|'\n'
name|'partition_start'
op|','
name|'partition_end'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'fs_type'
op|'=='
string|"'linux-swap'"
op|':'
newline|'\n'
indent|'                '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mkswap'"
op|','
name|'partition_path'
op|','
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'fs_type'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mkfs'"
op|','
string|"'-t'"
op|','
name|'fs_type'
op|','
name|'partition_path'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
comment|'# 4. Create VBD between instance VM and VDI'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'vm_ref'
op|':'
newline|'\n'
indent|'            '
name|'create_vbd'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'vdi_ref'
op|','
name|'userdevice'
op|','
name|'bootable'
op|'='
name|'False'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
string|'"Error while generating disk number: %s"'
op|'%'
name|'userdevice'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'msg'
op|','
name|'instance'
op|'='
name|'instance'
op|','
name|'exc_info'
op|'='
name|'True'
op|')'
newline|'\n'
name|'safe_destroy_vdis'
op|'('
name|'session'
op|','
op|'['
name|'vdi_ref'
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'vdi_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|generate_swap
dedent|''
name|'def'
name|'generate_swap'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'userdevice'
op|','
name|'name_label'
op|','
name|'swap_mb'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(jk0): We use a FAT32 filesystem for the Windows swap'
nl|'\n'
comment|'# partition because that is what parted supports.'
nl|'\n'
indent|'    '
name|'is_windows'
op|'='
name|'instance'
op|'['
string|"'os_type'"
op|']'
op|'=='
string|'"windows"'
newline|'\n'
name|'fs_type'
op|'='
string|'"vfat"'
name|'if'
name|'is_windows'
name|'else'
string|'"linux-swap"'
newline|'\n'
nl|'\n'
name|'_generate_disk'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'userdevice'
op|','
name|'name_label'
op|','
nl|'\n'
string|"'swap'"
op|','
name|'swap_mb'
op|','
name|'fs_type'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_ephemeral_disk_sizes
dedent|''
name|'def'
name|'get_ephemeral_disk_sizes'
op|'('
name|'total_size_gb'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'not'
name|'total_size_gb'
op|':'
newline|'\n'
indent|'        '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'max_size_gb'
op|'='
number|'2000'
newline|'\n'
name|'if'
name|'total_size_gb'
op|'%'
number|'1024'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'max_size_gb'
op|'='
number|'1024'
newline|'\n'
nl|'\n'
dedent|''
name|'left_to_allocate'
op|'='
name|'total_size_gb'
newline|'\n'
name|'while'
name|'left_to_allocate'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'size_gb'
op|'='
name|'min'
op|'('
name|'max_size_gb'
op|','
name|'left_to_allocate'
op|')'
newline|'\n'
name|'yield'
name|'size_gb'
newline|'\n'
name|'left_to_allocate'
op|'-='
name|'size_gb'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|generate_single_ephemeral
dedent|''
dedent|''
name|'def'
name|'generate_single_ephemeral'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'userdevice'
op|','
nl|'\n'
name|'size_gb'
op|','
name|'instance_name_label'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'instance_name_label'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'instance_name_label'
op|'='
name|'instance'
op|'['
string|'"name"'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'name_label'
op|'='
string|'"%s ephemeral"'
op|'%'
name|'instance_name_label'
newline|'\n'
comment|'# TODO(johngarbutt) need to move DEVICE_EPHEMERAL from vmops to use it here'
nl|'\n'
name|'label_number'
op|'='
name|'int'
op|'('
name|'userdevice'
op|')'
op|'-'
number|'4'
newline|'\n'
name|'if'
name|'label_number'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'name_label'
op|'='
string|'"%s (%d)"'
op|'%'
op|'('
name|'name_label'
op|','
name|'label_number'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'_generate_disk'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'str'
op|'('
name|'userdevice'
op|')'
op|','
nl|'\n'
name|'name_label'
op|','
string|"'ephemeral'"
op|','
name|'size_gb'
op|'*'
number|'1024'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'default_ephemeral_format'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|generate_ephemeral
dedent|''
name|'def'
name|'generate_ephemeral'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'first_userdevice'
op|','
nl|'\n'
name|'instance_name_label'
op|','
name|'total_size_gb'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(johngarbutt): max possible size of a VHD disk is 2043GB'
nl|'\n'
indent|'    '
name|'sizes'
op|'='
name|'get_ephemeral_disk_sizes'
op|'('
name|'total_size_gb'
op|')'
newline|'\n'
name|'first_userdevice'
op|'='
name|'int'
op|'('
name|'first_userdevice'
op|')'
newline|'\n'
nl|'\n'
name|'vdi_refs'
op|'='
op|'['
op|']'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'userdevice'
op|','
name|'size_gb'
name|'in'
name|'enumerate'
op|'('
name|'sizes'
op|','
name|'start'
op|'='
name|'first_userdevice'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'ref'
op|'='
name|'generate_single_ephemeral'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
nl|'\n'
name|'userdevice'
op|','
name|'size_gb'
op|','
nl|'\n'
name|'instance_name_label'
op|')'
newline|'\n'
name|'vdi_refs'
op|'.'
name|'append'
op|'('
name|'ref'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Error when generating ephemeral disk. "'
nl|'\n'
string|'"Device: %(userdevice)s Size GB: %(size_gb)s "'
nl|'\n'
string|'"Error: %(exc)s"'
op|','
op|'{'
nl|'\n'
string|"'userdevice'"
op|':'
name|'userdevice'
op|','
nl|'\n'
string|"'size_gb'"
op|':'
name|'size_gb'
op|','
nl|'\n'
string|"'exc'"
op|':'
name|'exc'
op|'}'
op|')'
newline|'\n'
name|'safe_destroy_vdis'
op|'('
name|'session'
op|','
name|'vdi_refs'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|generate_iso_blank_root_disk
dedent|''
dedent|''
dedent|''
name|'def'
name|'generate_iso_blank_root_disk'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'userdevice'
op|','
nl|'\n'
name|'name_label'
op|','
name|'size_gb'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'_generate_disk'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'userdevice'
op|','
name|'name_label'
op|','
nl|'\n'
string|"'user'"
op|','
name|'size_gb'
op|'*'
number|'1024'
op|','
name|'CONF'
op|'.'
name|'default_ephemeral_format'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|generate_configdrive
dedent|''
name|'def'
name|'generate_configdrive'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'userdevice'
op|','
nl|'\n'
name|'network_info'
op|','
name|'admin_password'
op|'='
name|'None'
op|','
name|'files'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'sr_ref'
op|'='
name|'safe_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'vdi_ref'
op|'='
name|'create_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
string|"'config-2'"
op|','
nl|'\n'
string|"'configdrive'"
op|','
name|'configdrive'
op|'.'
name|'CONFIGDRIVESIZE_BYTES'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
name|'as'
name|'dev'
op|':'
newline|'\n'
indent|'            '
name|'extra_md'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'if'
name|'admin_password'
op|':'
newline|'\n'
indent|'                '
name|'extra_md'
op|'['
string|"'admin_pass'"
op|']'
op|'='
name|'admin_password'
newline|'\n'
dedent|''
name|'inst_md'
op|'='
name|'instance_metadata'
op|'.'
name|'InstanceMetadata'
op|'('
name|'instance'
op|','
nl|'\n'
name|'content'
op|'='
name|'files'
op|','
name|'extra_md'
op|'='
name|'extra_md'
op|','
nl|'\n'
name|'network_info'
op|'='
name|'network_info'
op|')'
newline|'\n'
name|'with'
name|'configdrive'
op|'.'
name|'ConfigDriveBuilder'
op|'('
name|'instance_md'
op|'='
name|'inst_md'
op|')'
name|'as'
name|'cdb'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'utils'
op|'.'
name|'tempdir'
op|'('
op|')'
name|'as'
name|'tmp_path'
op|':'
newline|'\n'
indent|'                    '
name|'tmp_file'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'tmp_path'
op|','
string|"'configdrive'"
op|')'
newline|'\n'
name|'cdb'
op|'.'
name|'make_drive'
op|'('
name|'tmp_file'
op|')'
newline|'\n'
nl|'\n'
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'dd'"
op|','
nl|'\n'
string|"'if=%s'"
op|'%'
name|'tmp_file'
op|','
nl|'\n'
string|"'of=%s'"
op|'%'
name|'dev_path'
op|','
nl|'\n'
string|"'oflag=direct,sync'"
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'create_vbd'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'vdi_ref'
op|','
name|'userdevice'
op|','
name|'bootable'
op|'='
name|'False'
op|','
nl|'\n'
name|'read_only'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
string|'"Error while generating config drive"'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'msg'
op|','
name|'instance'
op|'='
name|'instance'
op|','
name|'exc_info'
op|'='
name|'True'
op|')'
newline|'\n'
name|'safe_destroy_vdis'
op|'('
name|'session'
op|','
op|'['
name|'vdi_ref'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_create_kernel_image
dedent|''
dedent|''
dedent|''
name|'def'
name|'_create_kernel_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'image_id'
op|','
nl|'\n'
name|'image_type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Creates kernel/ramdisk file from the image stored in the cache.\n    If the image is not present in the cache, it streams it from glance.\n\n    Returns: A list of dictionaries that describe VDIs\n    """'
newline|'\n'
name|'filename'
op|'='
string|'""'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'cache_images'
op|':'
newline|'\n'
indent|'        '
name|'args'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'args'
op|'['
string|"'cached-image'"
op|']'
op|'='
name|'image_id'
newline|'\n'
name|'args'
op|'['
string|"'new-image-uuid'"
op|']'
op|'='
name|'str'
op|'('
name|'uuid'
op|'.'
name|'uuid4'
op|'('
op|')'
op|')'
newline|'\n'
name|'filename'
op|'='
name|'session'
op|'.'
name|'call_plugin'
op|'('
string|"'kernel'"
op|','
string|"'create_kernel_ramdisk'"
op|','
name|'args'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'filename'
op|'=='
string|'""'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'_fetch_disk_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_id'
op|','
name|'image_type'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'vdi_type'
op|'='
name|'ImageType'
op|'.'
name|'to_string'
op|'('
name|'image_type'
op|')'
newline|'\n'
name|'return'
op|'{'
name|'vdi_type'
op|':'
name|'dict'
op|'('
name|'uuid'
op|'='
name|'None'
op|','
name|'file'
op|'='
name|'filename'
op|')'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|create_kernel_and_ramdisk
dedent|''
dedent|''
name|'def'
name|'create_kernel_and_ramdisk'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'kernel_file'
op|'='
name|'None'
newline|'\n'
name|'ramdisk_file'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'instance'
op|'['
string|"'kernel_id'"
op|']'
op|':'
newline|'\n'
indent|'        '
name|'vdis'
op|'='
name|'_create_kernel_image'
op|'('
name|'context'
op|','
name|'session'
op|','
nl|'\n'
name|'instance'
op|','
name|'name_label'
op|','
name|'instance'
op|'['
string|"'kernel_id'"
op|']'
op|','
nl|'\n'
name|'ImageType'
op|'.'
name|'KERNEL'
op|')'
newline|'\n'
name|'kernel_file'
op|'='
name|'vdis'
op|'['
string|"'kernel'"
op|']'
op|'.'
name|'get'
op|'('
string|"'file'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'instance'
op|'['
string|"'ramdisk_id'"
op|']'
op|':'
newline|'\n'
indent|'        '
name|'vdis'
op|'='
name|'_create_kernel_image'
op|'('
name|'context'
op|','
name|'session'
op|','
nl|'\n'
name|'instance'
op|','
name|'name_label'
op|','
name|'instance'
op|'['
string|"'ramdisk_id'"
op|']'
op|','
nl|'\n'
name|'ImageType'
op|'.'
name|'RAMDISK'
op|')'
newline|'\n'
name|'ramdisk_file'
op|'='
name|'vdis'
op|'['
string|"'ramdisk'"
op|']'
op|'.'
name|'get'
op|'('
string|"'file'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'kernel_file'
op|','
name|'ramdisk_file'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|destroy_kernel_ramdisk
dedent|''
name|'def'
name|'destroy_kernel_ramdisk'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'kernel'
op|','
name|'ramdisk'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'args'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'if'
name|'kernel'
op|':'
newline|'\n'
indent|'        '
name|'args'
op|'['
string|"'kernel-file'"
op|']'
op|'='
name|'kernel'
newline|'\n'
dedent|''
name|'if'
name|'ramdisk'
op|':'
newline|'\n'
indent|'        '
name|'args'
op|'['
string|"'ramdisk-file'"
op|']'
op|'='
name|'ramdisk'
newline|'\n'
dedent|''
name|'if'
name|'args'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Removing kernel/ramdisk files from dom0"'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'session'
op|'.'
name|'call_plugin'
op|'('
string|"'kernel'"
op|','
string|"'remove_kernel_ramdisk'"
op|','
name|'args'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_image_vdi_label
dedent|''
dedent|''
name|'def'
name|'_get_image_vdi_label'
op|'('
name|'image_id'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'return'
string|"'Glance Image %s'"
op|'%'
name|'image_id'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_create_cached_image
dedent|''
name|'def'
name|'_create_cached_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_id'
op|','
name|'image_type'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'sr_ref'
op|'='
name|'safe_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'sr_type'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'SR.get_type'"
op|','
name|'sr_ref'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'use_cow_images'
name|'and'
name|'sr_type'
op|'!='
string|'"ext"'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"Fast cloning is only supported on default local SR "'
nl|'\n'
string|'"of type ext. SR on this system was found to be of "'
nl|'\n'
string|'"type %s. Ignoring the cow flag."'
op|')'
op|','
name|'sr_type'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'utils'
op|'.'
name|'synchronized'
op|'('
string|"'xenapi-image-cache'"
op|'+'
name|'image_id'
op|')'
newline|'\n'
DECL|function|_create_cached_image_impl
name|'def'
name|'_create_cached_image_impl'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_id'
op|','
name|'image_type'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'cache_vdi_ref'
op|'='
name|'_find_cached_image'
op|'('
name|'session'
op|','
name|'image_id'
op|','
name|'sr_ref'
op|')'
newline|'\n'
name|'downloaded'
op|'='
name|'False'
newline|'\n'
name|'if'
name|'cache_vdi_ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'downloaded'
op|'='
name|'True'
newline|'\n'
name|'vdis'
op|'='
name|'_fetch_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_id'
op|','
name|'image_type'
op|')'
newline|'\n'
nl|'\n'
name|'cache_vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
nl|'\n'
string|"'VDI.get_by_uuid'"
op|','
name|'vdis'
op|'['
string|"'root'"
op|']'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.set_name_label'"
op|','
name|'cache_vdi_ref'
op|','
nl|'\n'
name|'_get_image_vdi_label'
op|'('
name|'image_id'
op|')'
op|')'
newline|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.set_name_description'"
op|','
name|'cache_vdi_ref'
op|','
nl|'\n'
string|"'root'"
op|')'
newline|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.add_to_other_config'"
op|','
nl|'\n'
name|'cache_vdi_ref'
op|','
string|"'image-id'"
op|','
name|'str'
op|'('
name|'image_id'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'use_cow_images'
op|':'
newline|'\n'
indent|'            '
name|'new_vdi_ref'
op|'='
name|'_clone_vdi'
op|'('
name|'session'
op|','
name|'cache_vdi_ref'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'sr_type'
op|'=='
string|"'ext'"
op|':'
newline|'\n'
indent|'            '
name|'new_vdi_ref'
op|'='
name|'_safe_copy_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
nl|'\n'
name|'cache_vdi_ref'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'new_vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.copy"'
op|','
name|'cache_vdi_ref'
op|','
nl|'\n'
name|'sr_ref'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.set_name_label'"
op|','
name|'new_vdi_ref'
op|','
string|"''"
op|')'
newline|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.set_name_description'"
op|','
name|'new_vdi_ref'
op|','
string|"''"
op|')'
newline|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.remove_from_other_config'"
op|','
nl|'\n'
name|'new_vdi_ref'
op|','
string|"'image-id'"
op|')'
newline|'\n'
nl|'\n'
name|'vdi_uuid'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_uuid'"
op|','
name|'new_vdi_ref'
op|')'
newline|'\n'
name|'return'
name|'downloaded'
op|','
name|'vdi_uuid'
newline|'\n'
nl|'\n'
dedent|''
name|'downloaded'
op|','
name|'vdi_uuid'
op|'='
name|'_create_cached_image_impl'
op|'('
name|'context'
op|','
name|'session'
op|','
nl|'\n'
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_id'
op|','
name|'image_type'
op|','
nl|'\n'
name|'sr_ref'
op|')'
newline|'\n'
nl|'\n'
name|'vdis'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'vdi_type'
op|'='
name|'ImageType'
op|'.'
name|'get_role'
op|'('
name|'image_type'
op|')'
newline|'\n'
name|'vdis'
op|'['
name|'vdi_type'
op|']'
op|'='
name|'dict'
op|'('
name|'uuid'
op|'='
name|'vdi_uuid'
op|','
name|'file'
op|'='
name|'None'
op|')'
newline|'\n'
name|'return'
name|'downloaded'
op|','
name|'vdis'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|create_image
dedent|''
name|'def'
name|'create_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'image_id'
op|','
nl|'\n'
name|'image_type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Creates VDI from the image stored in the local cache. If the image\n    is not present in the cache, it streams it from glance.\n\n    Returns: A list of dictionaries that describe VDIs\n    """'
newline|'\n'
name|'cache_images'
op|'='
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'cache_images'
op|'.'
name|'lower'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Determine if the image is cacheable'
nl|'\n'
name|'if'
name|'image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK_ISO'
op|':'
newline|'\n'
indent|'        '
name|'cache'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'elif'
name|'cache_images'
op|'=='
string|"'all'"
op|':'
newline|'\n'
indent|'        '
name|'cache'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'elif'
name|'cache_images'
op|'=='
string|"'some'"
op|':'
newline|'\n'
indent|'        '
name|'sys_meta'
op|'='
name|'utils'
op|'.'
name|'instance_sys_meta'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'cache'
op|'='
name|'strutils'
op|'.'
name|'bool_from_string'
op|'('
name|'sys_meta'
op|'['
string|"'image_cache_in_nova'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'            '
name|'cache'
op|'='
name|'False'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'cache_images'
op|'=='
string|"'none'"
op|':'
newline|'\n'
indent|'        '
name|'cache'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"Unrecognized cache_images value \'%s\', defaulting to"'
nl|'\n'
string|'" True"'
op|')'
op|','
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'cache_images'
op|')'
newline|'\n'
name|'cache'
op|'='
name|'True'
newline|'\n'
nl|'\n'
comment|'# Fetch (and cache) the image'
nl|'\n'
dedent|''
name|'start_time'
op|'='
name|'timeutils'
op|'.'
name|'utcnow'
op|'('
op|')'
newline|'\n'
name|'if'
name|'cache'
op|':'
newline|'\n'
indent|'        '
name|'downloaded'
op|','
name|'vdis'
op|'='
name|'_create_cached_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
nl|'\n'
name|'name_label'
op|','
name|'image_id'
op|','
nl|'\n'
name|'image_type'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'vdis'
op|'='
name|'_fetch_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_id'
op|','
name|'image_type'
op|')'
newline|'\n'
name|'downloaded'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'duration'
op|'='
name|'timeutils'
op|'.'
name|'delta_seconds'
op|'('
name|'start_time'
op|','
name|'timeutils'
op|'.'
name|'utcnow'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Image creation data, cacheable: %(cache)s, "'
nl|'\n'
string|'"downloaded: %(downloaded)s duration: %(duration).2f secs "'
nl|'\n'
string|'"for image %(image_id)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'image_id'"
op|':'
name|'image_id'
op|','
string|"'cache'"
op|':'
name|'cache'
op|','
string|"'downloaded'"
op|':'
name|'downloaded'
op|','
nl|'\n'
string|"'duration'"
op|':'
name|'duration'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'vdi_type'
op|','
name|'vdi'
name|'in'
name|'six'
op|'.'
name|'iteritems'
op|'('
name|'vdis'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_by_uuid'"
op|','
name|'vdi'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
name|'_set_vdi_info'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'vdi_type'
op|','
name|'name_label'
op|','
name|'vdi_type'
op|','
nl|'\n'
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'vdis'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_fetch_image
dedent|''
name|'def'
name|'_fetch_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'image_id'
op|','
name|'image_type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Fetch image from glance based on image type.\n\n    Returns: A single filename if image_type is KERNEL or RAMDISK\n             A list of dictionaries that describe VDIs, otherwise\n    """'
newline|'\n'
name|'if'
name|'image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK_VHD'
op|':'
newline|'\n'
indent|'        '
name|'vdis'
op|'='
name|'_fetch_vhd_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'image_id'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'vdis'
op|'='
name|'_fetch_disk_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_id'
op|','
name|'image_type'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'vdi_type'
op|','
name|'vdi'
name|'in'
name|'six'
op|'.'
name|'iteritems'
op|'('
name|'vdis'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'vdi_uuid'
op|'='
name|'vdi'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Fetched VDIs of type \'%(vdi_type)s\' with UUID"'
nl|'\n'
string|'" \'%(vdi_uuid)s\'"'
op|','
nl|'\n'
op|'{'
string|"'vdi_type'"
op|':'
name|'vdi_type'
op|','
string|"'vdi_uuid'"
op|':'
name|'vdi_uuid'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'vdis'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_make_uuid_stack
dedent|''
name|'def'
name|'_make_uuid_stack'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# NOTE(sirp): The XenAPI plugins run under Python 2.4'
nl|'\n'
comment|'# which does not have the `uuid` module. To work around this,'
nl|'\n'
comment|'# we generate the uuids here (under Python 2.6+) and'
nl|'\n'
comment|'# pass them as arguments'
nl|'\n'
indent|'    '
name|'return'
op|'['
name|'str'
op|'('
name|'uuid'
op|'.'
name|'uuid4'
op|'('
op|')'
op|')'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'MAX_VDI_CHAIN_SIZE'
op|')'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_image_uses_bittorrent
dedent|''
name|'def'
name|'_image_uses_bittorrent'
op|'('
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'bittorrent'
op|'='
name|'False'
newline|'\n'
name|'torrent_images'
op|'='
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'torrent_images'
op|'.'
name|'lower'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'torrent_images'
op|'=='
string|"'all'"
op|':'
newline|'\n'
indent|'        '
name|'bittorrent'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'elif'
name|'torrent_images'
op|'=='
string|"'some'"
op|':'
newline|'\n'
indent|'        '
name|'sys_meta'
op|'='
name|'utils'
op|'.'
name|'instance_sys_meta'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'bittorrent'
op|'='
name|'strutils'
op|'.'
name|'bool_from_string'
op|'('
nl|'\n'
name|'sys_meta'
op|'['
string|"'image_bittorrent'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'torrent_images'
op|'=='
string|"'none'"
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"Invalid value \'%s\' for torrent_images"'
op|')'
op|','
nl|'\n'
name|'torrent_images'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'bittorrent'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_default_download_handler
dedent|''
name|'def'
name|'_default_download_handler'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# TODO(sirp):  This should be configurable like upload_handler'
nl|'\n'
indent|'    '
name|'return'
name|'importutils'
op|'.'
name|'import_object'
op|'('
nl|'\n'
string|"'nova.virt.xenapi.image.glance.GlanceStore'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_choose_download_handler
dedent|''
name|'def'
name|'_choose_download_handler'
op|'('
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'_image_uses_bittorrent'
op|'('
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'importutils'
op|'.'
name|'import_object'
op|'('
nl|'\n'
string|"'nova.virt.xenapi.image.bittorrent.BittorrentStore'"
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'_default_download_handler'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_compression_level
dedent|''
dedent|''
name|'def'
name|'get_compression_level'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
name|'level'
op|'='
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'image_compression_level'
newline|'\n'
name|'if'
name|'level'
name|'is'
name|'not'
name|'None'
name|'and'
op|'('
name|'level'
op|'<'
number|'1'
name|'or'
name|'level'
op|'>'
number|'9'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"Invalid value \'%d\' for image_compression_level"'
op|')'
op|','
nl|'\n'
name|'level'
op|')'
newline|'\n'
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'return'
name|'level'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_fetch_vhd_image
dedent|''
name|'def'
name|'_fetch_vhd_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'image_id'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Tell glance to download an image and put the VHDs into the SR\n\n    Returns: A list of dictionaries that describe VDIs\n    """'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Asking xapi to fetch vhd image %s"'
op|','
name|'image_id'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'handler'
op|'='
name|'_choose_download_handler'
op|'('
name|'context'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'vdis'
op|'='
name|'handler'
op|'.'
name|'download_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'image_id'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'        '
name|'default_handler'
op|'='
name|'_default_download_handler'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|"# Using type() instead of isinstance() so instance of subclass doesn't"
nl|'\n'
comment|'# test as equivalent'
nl|'\n'
name|'if'
name|'type'
op|'('
name|'handler'
op|')'
op|'=='
name|'type'
op|'('
name|'default_handler'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|'"Download handler \'%(handler)s\' raised an"'
nl|'\n'
string|'" exception, falling back to default handler"'
nl|'\n'
string|'" \'%(default_handler)s\'"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'handler'"
op|':'
name|'handler'
op|','
nl|'\n'
string|"'default_handler'"
op|':'
name|'default_handler'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'vdis'
op|'='
name|'default_handler'
op|'.'
name|'download_image'
op|'('
nl|'\n'
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'image_id'
op|')'
newline|'\n'
nl|'\n'
comment|'# Ensure we can see the import VHDs as VDIs'
nl|'\n'
dedent|''
name|'scan_default_sr'
op|'('
name|'session'
op|')'
newline|'\n'
nl|'\n'
name|'vdi_uuid'
op|'='
name|'vdis'
op|'['
string|"'root'"
op|']'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'_check_vdi_size'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'vdi_uuid'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
string|'"Error while checking vdi size"'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'msg'
op|','
name|'instance'
op|'='
name|'instance'
op|','
name|'exc_info'
op|'='
name|'True'
op|')'
newline|'\n'
name|'for'
name|'vdi'
name|'in'
name|'vdis'
op|'.'
name|'values'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'vdi_uuid'
op|'='
name|'vdi'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_by_uuid'"
op|','
name|'vdi_uuid'
op|')'
newline|'\n'
name|'safe_destroy_vdis'
op|'('
name|'session'
op|','
op|'['
name|'vdi_ref'
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'vdis'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_vdi_chain_size
dedent|''
name|'def'
name|'_get_vdi_chain_size'
op|'('
name|'session'
op|','
name|'vdi_uuid'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Compute the total size of a VDI chain, starting with the specified\n    VDI UUID.\n\n    This will walk the VDI chain to the root, add the size of each VDI into\n    the total.\n    """'
newline|'\n'
name|'size_bytes'
op|'='
number|'0'
newline|'\n'
name|'for'
name|'vdi_rec'
name|'in'
name|'_walk_vdi_chain'
op|'('
name|'session'
op|','
name|'vdi_uuid'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'cur_vdi_uuid'
op|'='
name|'vdi_rec'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'vdi_size_bytes'
op|'='
name|'int'
op|'('
name|'vdi_rec'
op|'['
string|"'physical_utilisation'"
op|']'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'vdi_uuid=%(cur_vdi_uuid)s vdi_size_bytes='"
nl|'\n'
string|"'%(vdi_size_bytes)d'"
op|','
nl|'\n'
op|'{'
string|"'cur_vdi_uuid'"
op|':'
name|'cur_vdi_uuid'
op|','
nl|'\n'
string|"'vdi_size_bytes'"
op|':'
name|'vdi_size_bytes'
op|'}'
op|')'
newline|'\n'
name|'size_bytes'
op|'+='
name|'vdi_size_bytes'
newline|'\n'
dedent|''
name|'return'
name|'size_bytes'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_check_vdi_size
dedent|''
name|'def'
name|'_check_vdi_size'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'vdi_uuid'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'flavor'
op|'='
name|'instance'
op|'.'
name|'get_flavor'
op|'('
op|')'
newline|'\n'
name|'allowed_size'
op|'='
op|'('
name|'flavor'
op|'.'
name|'root_gb'
op|'+'
nl|'\n'
name|'VHD_SIZE_CHECK_FUDGE_FACTOR_GB'
op|')'
op|'*'
name|'units'
op|'.'
name|'Gi'
newline|'\n'
name|'if'
name|'not'
name|'flavor'
op|'.'
name|'root_gb'
op|':'
newline|'\n'
comment|"# root_gb=0 indicates that we're disabling size checks"
nl|'\n'
indent|'        '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'size'
op|'='
name|'_get_vdi_chain_size'
op|'('
name|'session'
op|','
name|'vdi_uuid'
op|')'
newline|'\n'
name|'if'
name|'size'
op|'>'
name|'allowed_size'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|'"Image size %(size)d exceeded flavor "'
nl|'\n'
string|'"allowed size %(allowed_size)d"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'size'"
op|':'
name|'size'
op|','
string|"'allowed_size'"
op|':'
name|'allowed_size'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'raise'
name|'exception'
op|'.'
name|'FlavorDiskTooSmall'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_fetch_disk_image
dedent|''
dedent|''
name|'def'
name|'_fetch_disk_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'image_id'
op|','
nl|'\n'
name|'image_type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Fetch the image from Glance\n\n    NOTE:\n    Unlike _fetch_vhd_image, this method does not use the Glance\n    plugin; instead, it streams the disks through domU to the VDI\n    directly.\n\n    Returns: A single filename if image_type is KERNEL_RAMDISK\n             A list of dictionaries that describe VDIs, otherwise\n    """'
newline|'\n'
comment|'# FIXME(sirp): Since the Glance plugin seems to be required for the'
nl|'\n'
comment|'# VHD disk, it may be worth using the plugin for both VHD and RAW and'
nl|'\n'
comment|'# DISK restores'
nl|'\n'
name|'image_type_str'
op|'='
name|'ImageType'
op|'.'
name|'to_string'
op|'('
name|'image_type'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Fetching image %(image_id)s, type %(image_type_str)s"'
op|','
nl|'\n'
op|'{'
string|"'image_id'"
op|':'
name|'image_id'
op|','
string|"'image_type_str'"
op|':'
name|'image_type_str'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK_ISO'
op|':'
newline|'\n'
indent|'        '
name|'sr_ref'
op|'='
name|'_safe_find_iso_sr'
op|'('
name|'session'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'sr_ref'
op|'='
name|'safe_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'glance_image'
op|'='
name|'image_utils'
op|'.'
name|'GlanceImage'
op|'('
name|'context'
op|','
name|'image_id'
op|')'
newline|'\n'
name|'if'
name|'glance_image'
op|'.'
name|'is_raw_tgz'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'image'
op|'='
name|'image_utils'
op|'.'
name|'RawTGZImage'
op|'('
name|'glance_image'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'image'
op|'='
name|'image_utils'
op|'.'
name|'RawImage'
op|'('
name|'glance_image'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'virtual_size'
op|'='
name|'image'
op|'.'
name|'get_size'
op|'('
op|')'
newline|'\n'
name|'vdi_size'
op|'='
name|'virtual_size'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Size for image %(image_id)s: %(virtual_size)d"'
op|','
nl|'\n'
op|'{'
string|"'image_id'"
op|':'
name|'image_id'
op|','
string|"'virtual_size'"
op|':'
name|'virtual_size'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK'
op|':'
newline|'\n'
comment|'# Make room for MBR.'
nl|'\n'
indent|'        '
name|'vdi_size'
op|'+='
name|'MBR_SIZE_BYTES'
newline|'\n'
dedent|''
name|'elif'
op|'('
name|'image_type'
name|'in'
op|'('
name|'ImageType'
op|'.'
name|'KERNEL'
op|','
name|'ImageType'
op|'.'
name|'RAMDISK'
op|')'
name|'and'
nl|'\n'
name|'vdi_size'
op|'>'
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'max_kernel_ramdisk_size'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'max_size'
op|'='
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'max_kernel_ramdisk_size'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
nl|'\n'
name|'_'
op|'('
string|'"Kernel/Ramdisk image is too large: %(vdi_size)d bytes, "'
nl|'\n'
string|'"max %(max_size)d bytes"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'vdi_size'"
op|':'
name|'vdi_size'
op|','
string|"'max_size'"
op|':'
name|'max_size'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'vdi_ref'
op|'='
name|'create_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_type_str'
op|','
name|'vdi_size'
op|')'
newline|'\n'
comment|'# From this point we have a VDI on Xen host;'
nl|'\n'
comment|'# If anything goes wrong, we need to remember its uuid.'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'filename'
op|'='
name|'None'
newline|'\n'
name|'vdi_uuid'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_uuid"'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
name|'as'
name|'dev'
op|':'
newline|'\n'
indent|'            '
name|'_stream_disk'
op|'('
nl|'\n'
name|'session'
op|','
name|'image'
op|'.'
name|'stream_to'
op|','
name|'image_type'
op|','
name|'virtual_size'
op|','
name|'dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'image_type'
name|'in'
op|'('
name|'ImageType'
op|'.'
name|'KERNEL'
op|','
name|'ImageType'
op|'.'
name|'RAMDISK'
op|')'
op|':'
newline|'\n'
comment|'# We need to invoke a plugin for copying the'
nl|'\n'
comment|'# content of the VDI into the proper path.'
nl|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Copying VDI %s to /boot/guest on dom0"'
op|','
nl|'\n'
name|'vdi_ref'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'args'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'args'
op|'['
string|"'vdi-ref'"
op|']'
op|'='
name|'vdi_ref'
newline|'\n'
nl|'\n'
comment|'# Let the plugin copy the correct number of bytes.'
nl|'\n'
name|'args'
op|'['
string|"'image-size'"
op|']'
op|'='
name|'str'
op|'('
name|'vdi_size'
op|')'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'cache_images'
op|':'
newline|'\n'
indent|'                '
name|'args'
op|'['
string|"'cached-image'"
op|']'
op|'='
name|'image_id'
newline|'\n'
dedent|''
name|'filename'
op|'='
name|'session'
op|'.'
name|'call_plugin'
op|'('
string|"'kernel'"
op|','
string|"'copy_vdi'"
op|','
name|'args'
op|')'
newline|'\n'
nl|'\n'
comment|'# Remove the VDI as it is not needed anymore.'
nl|'\n'
name|'destroy_vdi'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Kernel/Ramdisk VDI %s destroyed"'
op|','
name|'vdi_ref'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'vdi_role'
op|'='
name|'ImageType'
op|'.'
name|'get_role'
op|'('
name|'image_type'
op|')'
newline|'\n'
name|'return'
op|'{'
name|'vdi_role'
op|':'
name|'dict'
op|'('
name|'uuid'
op|'='
name|'None'
op|','
name|'file'
op|'='
name|'filename'
op|')'
op|'}'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'vdi_role'
op|'='
name|'ImageType'
op|'.'
name|'get_role'
op|'('
name|'image_type'
op|')'
newline|'\n'
name|'return'
op|'{'
name|'vdi_role'
op|':'
name|'dict'
op|'('
name|'uuid'
op|'='
name|'vdi_uuid'
op|','
name|'file'
op|'='
name|'None'
op|')'
op|'}'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|'('
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|','
name|'IOError'
op|','
name|'OSError'
op|')'
name|'as'
name|'e'
op|':'
newline|'\n'
comment|'# We look for XenAPI and OS failures.'
nl|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|'"Failed to fetch glance image"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'e'
op|'.'
name|'args'
op|'='
name|'e'
op|'.'
name|'args'
op|'+'
op|'('
op|'['
name|'dict'
op|'('
name|'type'
op|'='
name|'ImageType'
op|'.'
name|'to_string'
op|'('
name|'image_type'
op|')'
op|','
nl|'\n'
name|'uuid'
op|'='
name|'vdi_uuid'
op|','
nl|'\n'
name|'file'
op|'='
name|'filename'
op|')'
op|']'
op|','
op|')'
newline|'\n'
name|'raise'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|determine_disk_image_type
dedent|''
dedent|''
name|'def'
name|'determine_disk_image_type'
op|'('
name|'image_meta'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Disk Image Types are used to determine where the kernel will reside\n    within an image. To figure out which type we\'re dealing with, we use\n    the following rules:\n\n    1. If we\'re using Glance, we can use the image_type field to\n       determine the image_type\n\n    2. If we\'re not using Glance, then we need to deduce this based on\n       whether a kernel_id is specified.\n    """'
newline|'\n'
name|'if'
name|'not'
name|'image_meta'
op|'.'
name|'obj_attr_is_set'
op|'('
string|'"disk_format"'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'disk_format_map'
op|'='
op|'{'
nl|'\n'
string|"'ami'"
op|':'
name|'ImageType'
op|'.'
name|'DISK'
op|','
nl|'\n'
string|"'aki'"
op|':'
name|'ImageType'
op|'.'
name|'KERNEL'
op|','
nl|'\n'
string|"'ari'"
op|':'
name|'ImageType'
op|'.'
name|'RAMDISK'
op|','
nl|'\n'
string|"'raw'"
op|':'
name|'ImageType'
op|'.'
name|'DISK_RAW'
op|','
nl|'\n'
string|"'vhd'"
op|':'
name|'ImageType'
op|'.'
name|'DISK_VHD'
op|','
nl|'\n'
string|"'iso'"
op|':'
name|'ImageType'
op|'.'
name|'DISK_ISO'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'image_type'
op|'='
name|'disk_format_map'
op|'['
name|'image_meta'
op|'.'
name|'disk_format'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'InvalidDiskFormat'
op|'('
name|'disk_format'
op|'='
name|'image_meta'
op|'.'
name|'disk_format'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Detected %(type)s format for image %(image)s"'
op|','
nl|'\n'
op|'{'
string|"'type'"
op|':'
name|'ImageType'
op|'.'
name|'to_string'
op|'('
name|'image_type'
op|')'
op|','
nl|'\n'
string|"'image'"
op|':'
name|'image_meta'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'image_type'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|determine_vm_mode
dedent|''
name|'def'
name|'determine_vm_mode'
op|'('
name|'instance'
op|','
name|'disk_image_type'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'current_mode'
op|'='
name|'vm_mode'
op|'.'
name|'get_from_instance'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'current_mode'
op|'=='
name|'vm_mode'
op|'.'
name|'XEN'
name|'or'
name|'current_mode'
op|'=='
name|'vm_mode'
op|'.'
name|'HVM'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'current_mode'
newline|'\n'
nl|'\n'
dedent|''
name|'os_type'
op|'='
name|'instance'
op|'['
string|"'os_type'"
op|']'
newline|'\n'
name|'if'
name|'os_type'
op|'=='
string|'"linux"'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'vm_mode'
op|'.'
name|'XEN'
newline|'\n'
dedent|''
name|'if'
name|'os_type'
op|'=='
string|'"windows"'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'vm_mode'
op|'.'
name|'HVM'
newline|'\n'
nl|'\n'
comment|'# disk_image_type specific default for backwards compatibility'
nl|'\n'
dedent|''
name|'if'
name|'disk_image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK_VHD'
name|'or'
name|'disk_image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'vm_mode'
op|'.'
name|'XEN'
newline|'\n'
nl|'\n'
comment|'# most images run OK as HVM'
nl|'\n'
dedent|''
name|'return'
name|'vm_mode'
op|'.'
name|'HVM'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|set_vm_name_label
dedent|''
name|'def'
name|'set_vm_name_label'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'name_label'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.set_name_label"'
op|','
name|'vm_ref'
op|','
name|'name_label'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|list_vms
dedent|''
name|'def'
name|'list_vms'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vms'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_all_records_where"'
op|','
nl|'\n'
string|'\'field "is_control_domain"="false" and \''
nl|'\n'
string|'\'field "is_a_template"="false" and \''
nl|'\n'
string|'\'field "resident_on"="%s"\''
op|'%'
name|'session'
op|'.'
name|'host_ref'
op|')'
newline|'\n'
name|'for'
name|'vm_ref'
name|'in'
name|'vms'
op|'.'
name|'keys'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'yield'
name|'vm_ref'
op|','
name|'vms'
op|'['
name|'vm_ref'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|lookup_vm_vdis
dedent|''
dedent|''
name|'def'
name|'lookup_vm_vdis'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Look for the VDIs that are attached to the VM."""'
newline|'\n'
comment|'# Firstly we get the VBDs, then the VDIs.'
nl|'\n'
comment|'# TODO(Armando): do we leave the read-only devices?'
nl|'\n'
name|'vbd_refs'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_VBDs"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'vdi_refs'
op|'='
op|'['
op|']'
newline|'\n'
name|'if'
name|'vbd_refs'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'vbd_ref'
name|'in'
name|'vbd_refs'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VBD.get_VDI"'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
comment|'# Test valid VDI'
nl|'\n'
name|'vdi_uuid'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_uuid"'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'VDI %s is still available'"
op|','
name|'vdi_uuid'
op|')'
newline|'\n'
name|'vbd_other_config'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VBD.get_other_config"'
op|','
nl|'\n'
name|'vbd_ref'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'vbd_other_config'
op|'.'
name|'get'
op|'('
string|"'osvol'"
op|')'
op|':'
newline|'\n'
comment|'# This is not an attached volume'
nl|'\n'
indent|'                    '
name|'vdi_refs'
op|'.'
name|'append'
op|'('
name|'vdi_ref'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|'\'"Look for the VDIs failed\''
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'vdi_refs'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|lookup
dedent|''
name|'def'
name|'lookup'
op|'('
name|'session'
op|','
name|'name_label'
op|','
name|'check_rescue'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Look the instance up and return it if available.\n    :param:check_rescue: if True will return the \'name\'-rescue vm if it\n    exists, instead of just \'name\'\n    """'
newline|'\n'
name|'if'
name|'check_rescue'
op|':'
newline|'\n'
indent|'        '
name|'result'
op|'='
name|'lookup'
op|'('
name|'session'
op|','
name|'name_label'
op|'+'
string|"'-rescue'"
op|','
name|'False'
op|')'
newline|'\n'
name|'if'
name|'result'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'result'
newline|'\n'
dedent|''
dedent|''
name|'vm_refs'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_by_name_label"'
op|','
name|'name_label'
op|')'
newline|'\n'
name|'n'
op|'='
name|'len'
op|'('
name|'vm_refs'
op|')'
newline|'\n'
name|'if'
name|'n'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'elif'
name|'n'
op|'>'
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'InstanceExists'
op|'('
name|'name'
op|'='
name|'name_label'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'vm_refs'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|preconfigure_instance
dedent|''
dedent|''
name|'def'
name|'preconfigure_instance'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vdi_ref'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Makes alterations to the image before launching as part of spawn.\n    """'
newline|'\n'
name|'key'
op|'='
name|'str'
op|'('
name|'instance'
op|'['
string|"'key_data'"
op|']'
op|')'
newline|'\n'
name|'net'
op|'='
name|'netutils'
op|'.'
name|'get_injected_network_template'
op|'('
name|'network_info'
op|')'
newline|'\n'
name|'metadata'
op|'='
name|'instance'
op|'['
string|"'metadata'"
op|']'
newline|'\n'
nl|'\n'
comment|'# As mounting the image VDI is expensive, we only want do it once,'
nl|'\n'
comment|"# if at all, so determine whether it's required first, and then do"
nl|'\n'
comment|'# everything'
nl|'\n'
name|'mount_required'
op|'='
name|'key'
name|'or'
name|'net'
name|'or'
name|'metadata'
newline|'\n'
name|'if'
name|'not'
name|'mount_required'
op|':'
newline|'\n'
indent|'        '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
name|'as'
name|'dev'
op|':'
newline|'\n'
indent|'        '
name|'_mounted_processing'
op|'('
name|'dev'
op|','
name|'key'
op|','
name|'net'
op|','
name|'metadata'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|lookup_kernel_ramdisk
dedent|''
dedent|''
name|'def'
name|'lookup_kernel_ramdisk'
op|'('
name|'session'
op|','
name|'vm'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vm_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_record"'
op|','
name|'vm'
op|')'
newline|'\n'
name|'if'
string|"'PV_kernel'"
name|'in'
name|'vm_rec'
name|'and'
string|"'PV_ramdisk'"
name|'in'
name|'vm_rec'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
name|'vm_rec'
op|'['
string|"'PV_kernel'"
op|']'
op|','
name|'vm_rec'
op|'['
string|"'PV_ramdisk'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|is_snapshot
dedent|''
dedent|''
name|'def'
name|'is_snapshot'
op|'('
name|'session'
op|','
name|'vm'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vm_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_record"'
op|','
name|'vm'
op|')'
newline|'\n'
name|'if'
string|"'is_a_template'"
name|'in'
name|'vm_rec'
name|'and'
string|"'is_a_snapshot'"
name|'in'
name|'vm_rec'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'vm_rec'
op|'['
string|"'is_a_template'"
op|']'
name|'and'
name|'vm_rec'
op|'['
string|"'is_a_snapshot'"
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_power_state
dedent|''
dedent|''
name|'def'
name|'get_power_state'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'xapi_state'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_power_state"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'return'
name|'XENAPI_POWER_STATE'
op|'['
name|'xapi_state'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|compile_info
dedent|''
name|'def'
name|'compile_info'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Fill record with VM status information."""'
newline|'\n'
name|'power_state'
op|'='
name|'get_power_state'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'max_mem'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_memory_static_max"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'mem'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_memory_dynamic_max"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'num_cpu'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_VCPUs_max"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'hardware'
op|'.'
name|'InstanceInfo'
op|'('
name|'state'
op|'='
name|'power_state'
op|','
nl|'\n'
name|'max_mem_kb'
op|'='
name|'long'
op|'('
name|'max_mem'
op|')'
op|'>>'
number|'10'
op|','
nl|'\n'
name|'mem_kb'
op|'='
name|'long'
op|'('
name|'mem'
op|')'
op|'>>'
number|'10'
op|','
nl|'\n'
name|'num_cpu'
op|'='
name|'num_cpu'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|compile_instance_diagnostics
dedent|''
name|'def'
name|'compile_instance_diagnostics'
op|'('
name|'instance'
op|','
name|'vm_rec'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vm_power_state_int'
op|'='
name|'XENAPI_POWER_STATE'
op|'['
name|'vm_rec'
op|'['
string|"'power_state'"
op|']'
op|']'
newline|'\n'
name|'vm_power_state'
op|'='
name|'power_state'
op|'.'
name|'STATE_MAP'
op|'['
name|'vm_power_state_int'
op|']'
newline|'\n'
name|'config_drive'
op|'='
name|'configdrive'
op|'.'
name|'required_by'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'diags'
op|'='
name|'diagnostics'
op|'.'
name|'Diagnostics'
op|'('
name|'state'
op|'='
name|'vm_power_state'
op|','
nl|'\n'
name|'driver'
op|'='
string|"'xenapi'"
op|','
nl|'\n'
name|'config_drive'
op|'='
name|'config_drive'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'cpu_num'
name|'in'
name|'range'
op|'('
number|'0'
op|','
name|'long'
op|'('
name|'vm_rec'
op|'['
string|"'VCPUs_max'"
op|']'
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'diags'
op|'.'
name|'add_cpu'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'vif'
name|'in'
name|'vm_rec'
op|'['
string|"'VIFs'"
op|']'
op|':'
newline|'\n'
indent|'        '
name|'diags'
op|'.'
name|'add_nic'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'vbd'
name|'in'
name|'vm_rec'
op|'['
string|"'VBDs'"
op|']'
op|':'
newline|'\n'
indent|'        '
name|'diags'
op|'.'
name|'add_disk'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'max_mem_bytes'
op|'='
name|'long'
op|'('
name|'vm_rec'
op|'['
string|"'memory_dynamic_max'"
op|']'
op|')'
newline|'\n'
name|'diags'
op|'.'
name|'memory_details'
op|'.'
name|'maximum'
op|'='
name|'max_mem_bytes'
op|'/'
name|'units'
op|'.'
name|'Mi'
newline|'\n'
nl|'\n'
name|'return'
name|'diags'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|compile_diagnostics
dedent|''
name|'def'
name|'compile_diagnostics'
op|'('
name|'vm_rec'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Compile VM diagnostics data."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'keys'
op|'='
op|'['
op|']'
newline|'\n'
name|'diags'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'vm_uuid'
op|'='
name|'vm_rec'
op|'['
string|'"uuid"'
op|']'
newline|'\n'
name|'xml'
op|'='
name|'_get_rrd'
op|'('
name|'_get_rrd_server'
op|'('
op|')'
op|','
name|'vm_uuid'
op|')'
newline|'\n'
name|'if'
name|'xml'
op|':'
newline|'\n'
indent|'            '
name|'rrd'
op|'='
name|'minidom'
op|'.'
name|'parseString'
op|'('
name|'xml'
op|')'
newline|'\n'
name|'for'
name|'i'
op|','
name|'node'
name|'in'
name|'enumerate'
op|'('
name|'rrd'
op|'.'
name|'firstChild'
op|'.'
name|'childNodes'
op|')'
op|':'
newline|'\n'
comment|'# Provide the last update of the information'
nl|'\n'
indent|'                '
name|'if'
name|'node'
op|'.'
name|'localName'
op|'=='
string|"'lastupdate'"
op|':'
newline|'\n'
indent|'                    '
name|'diags'
op|'['
string|"'last_update'"
op|']'
op|'='
name|'node'
op|'.'
name|'firstChild'
op|'.'
name|'data'
newline|'\n'
nl|'\n'
comment|'# Create a list of the diagnostic keys (in their order)'
nl|'\n'
dedent|''
name|'if'
name|'node'
op|'.'
name|'localName'
op|'=='
string|"'ds'"
op|':'
newline|'\n'
indent|'                    '
name|'ref'
op|'='
name|'node'
op|'.'
name|'childNodes'
newline|'\n'
comment|'# Name and Value'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'ref'
op|')'
op|'>'
number|'6'
op|':'
newline|'\n'
indent|'                        '
name|'keys'
op|'.'
name|'append'
op|'('
name|'ref'
op|'['
number|'0'
op|']'
op|'.'
name|'firstChild'
op|'.'
name|'data'
op|')'
newline|'\n'
nl|'\n'
comment|'# Read the last row of the first RRA to get the latest info'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'node'
op|'.'
name|'localName'
op|'=='
string|"'rra'"
op|':'
newline|'\n'
indent|'                    '
name|'rows'
op|'='
name|'node'
op|'.'
name|'childNodes'
op|'['
number|'4'
op|']'
op|'.'
name|'childNodes'
newline|'\n'
name|'last_row'
op|'='
name|'rows'
op|'['
name|'rows'
op|'.'
name|'length'
op|'-'
number|'1'
op|']'
op|'.'
name|'childNodes'
newline|'\n'
name|'for'
name|'j'
op|','
name|'value'
name|'in'
name|'enumerate'
op|'('
name|'last_row'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'diags'
op|'['
name|'keys'
op|'['
name|'j'
op|']'
op|']'
op|'='
name|'value'
op|'.'
name|'firstChild'
op|'.'
name|'data'
newline|'\n'
dedent|''
name|'break'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'diags'
newline|'\n'
dedent|''
name|'except'
name|'expat'
op|'.'
name|'ExpatError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Unable to parse rrd of %s'"
op|')'
op|','
name|'e'
op|')'
newline|'\n'
name|'return'
op|'{'
string|'"Unable to retrieve diagnostics"'
op|':'
name|'e'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|fetch_bandwidth
dedent|''
dedent|''
name|'def'
name|'fetch_bandwidth'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'bw'
op|'='
name|'session'
op|'.'
name|'call_plugin_serialized'
op|'('
string|"'bandwidth'"
op|','
string|"'fetch_all_bandwidth'"
op|')'
newline|'\n'
name|'return'
name|'bw'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_scan_sr
dedent|''
name|'def'
name|'_scan_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|'='
name|'None'
op|','
name|'max_attempts'
op|'='
number|'4'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'sr_ref'
op|':'
newline|'\n'
comment|'# NOTE(johngarbutt) xenapi will collapse any duplicate requests'
nl|'\n'
comment|'# for SR.scan if there is already a scan in progress.'
nl|'\n'
comment|"# However, we don't want that, because the scan may have started"
nl|'\n'
comment|'# before we modified the underlying VHDs on disk through a plugin.'
nl|'\n'
comment|'# Using our own mutex will reduce cases where our periodic SR scan'
nl|'\n'
comment|'# in host.update_status starts racing the sr.scan after a plugin call.'
nl|'\n'
indent|'        '
op|'@'
name|'utils'
op|'.'
name|'synchronized'
op|'('
string|"'sr-scan-'"
op|'+'
name|'sr_ref'
op|')'
newline|'\n'
DECL|function|do_scan
name|'def'
name|'do_scan'
op|'('
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Scanning SR %s"'
op|','
name|'sr_ref'
op|')'
newline|'\n'
nl|'\n'
name|'attempt'
op|'='
number|'1'
newline|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'SR.scan'"
op|','
name|'sr_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'                    '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
name|'as'
name|'ctxt'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'exc'
op|'.'
name|'details'
op|'['
number|'0'
op|']'
op|'=='
string|"'SR_BACKEND_FAILURE_40'"
op|':'
newline|'\n'
indent|'                            '
name|'if'
name|'attempt'
op|'<'
name|'max_attempts'
op|':'
newline|'\n'
indent|'                                '
name|'ctxt'
op|'.'
name|'reraise'
op|'='
name|'False'
newline|'\n'
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"Retry SR scan due to error: "'
nl|'\n'
string|'"%s"'
op|')'
op|','
name|'exc'
op|')'
newline|'\n'
name|'greenthread'
op|'.'
name|'sleep'
op|'('
number|'2'
op|'**'
name|'attempt'
op|')'
newline|'\n'
name|'attempt'
op|'+='
number|'1'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'do_scan'
op|'('
name|'sr_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|scan_default_sr
dedent|''
dedent|''
name|'def'
name|'scan_default_sr'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Looks for the system default SR and triggers a re-scan."""'
newline|'\n'
name|'sr_ref'
op|'='
name|'safe_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'_scan_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
newline|'\n'
name|'return'
name|'sr_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|safe_find_sr
dedent|''
name|'def'
name|'safe_find_sr'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Same as _find_sr except raises a NotFound exception if SR cannot be\n    determined\n    """'
newline|'\n'
name|'sr_ref'
op|'='
name|'_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'if'
name|'sr_ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'StorageRepositoryNotFound'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'sr_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_find_sr
dedent|''
name|'def'
name|'_find_sr'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the storage repository to hold VM images."""'
newline|'\n'
name|'host'
op|'='
name|'session'
op|'.'
name|'host_ref'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'tokens'
op|'='
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'sr_matching_filter'
op|'.'
name|'split'
op|'('
string|"':'"
op|')'
newline|'\n'
name|'filter_criteria'
op|'='
name|'tokens'
op|'['
number|'0'
op|']'
newline|'\n'
name|'filter_pattern'
op|'='
name|'tokens'
op|'['
number|'1'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'IndexError'
op|':'
newline|'\n'
comment|'# oops, flag is invalid'
nl|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"Flag sr_matching_filter \'%s\' does not respect "'
nl|'\n'
string|'"formatting convention"'
op|')'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'sr_matching_filter'
op|')'
newline|'\n'
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'filter_criteria'
op|'=='
string|"'other-config'"
op|':'
newline|'\n'
indent|'        '
name|'key'
op|','
name|'value'
op|'='
name|'filter_pattern'
op|'.'
name|'split'
op|'('
string|"'='"
op|','
number|'1'
op|')'
newline|'\n'
name|'for'
name|'sr_ref'
op|','
name|'sr_rec'
name|'in'
name|'session'
op|'.'
name|'get_all_refs_and_recs'
op|'('
string|"'SR'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
op|'('
name|'key'
name|'in'
name|'sr_rec'
op|'['
string|"'other_config'"
op|']'
name|'and'
nl|'\n'
name|'sr_rec'
op|'['
string|"'other_config'"
op|']'
op|'['
name|'key'
op|']'
op|'=='
name|'value'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'for'
name|'pbd_ref'
name|'in'
name|'sr_rec'
op|'['
string|"'PBDs'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'pbd_rec'
op|'='
name|'session'
op|'.'
name|'get_rec'
op|'('
string|"'PBD'"
op|','
name|'pbd_ref'
op|')'
newline|'\n'
name|'if'
name|'pbd_rec'
name|'and'
name|'pbd_rec'
op|'['
string|"'host'"
op|']'
op|'=='
name|'host'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'sr_ref'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'elif'
name|'filter_criteria'
op|'=='
string|"'default-sr'"
name|'and'
name|'filter_pattern'
op|'=='
string|"'true'"
op|':'
newline|'\n'
indent|'        '
name|'pool_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'pool.get_all'"
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'sr_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'pool.get_default_SR'"
op|','
name|'pool_ref'
op|')'
newline|'\n'
name|'if'
name|'sr_ref'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'sr_ref'
newline|'\n'
comment|'# No SR found!'
nl|'\n'
dedent|''
dedent|''
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|'"XenAPI is unable to find a Storage Repository to "'
nl|'\n'
string|'"install guest instances on. Please check your "'
nl|'\n'
string|'"configuration (e.g. set a default SR for the pool) "'
nl|'\n'
string|'"and/or configure the flag \'sr_matching_filter\'."'
op|')'
op|')'
newline|'\n'
name|'return'
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_safe_find_iso_sr
dedent|''
name|'def'
name|'_safe_find_iso_sr'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Same as _find_iso_sr except raises a NotFound exception if SR\n    cannot be determined\n    """'
newline|'\n'
name|'sr_ref'
op|'='
name|'_find_iso_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'if'
name|'sr_ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'NotFound'
op|'('
name|'_'
op|'('
string|"'Cannot find SR of content-type ISO'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'sr_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_find_iso_sr
dedent|''
name|'def'
name|'_find_iso_sr'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the storage repository to hold ISO images."""'
newline|'\n'
name|'host'
op|'='
name|'session'
op|'.'
name|'host_ref'
newline|'\n'
name|'for'
name|'sr_ref'
op|','
name|'sr_rec'
name|'in'
name|'session'
op|'.'
name|'get_all_refs_and_recs'
op|'('
string|"'SR'"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"ISO: looking at SR %s"'
op|','
name|'sr_rec'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'sr_rec'
op|'['
string|"'content_type'"
op|']'
op|'=='
string|"'iso'"
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"ISO: not iso content"'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'if'
string|"'i18n-key'"
name|'not'
name|'in'
name|'sr_rec'
op|'['
string|"'other_config'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"ISO: iso content_type, no \'i18n-key\' key"'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'sr_rec'
op|'['
string|"'other_config'"
op|']'
op|'['
string|"'i18n-key'"
op|']'
op|'=='
string|"'local-storage-iso'"
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"ISO: iso content_type, i18n-key value not "'
nl|'\n'
string|'"\'local-storage-iso\'"'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"ISO: SR MATCHing our criteria"'
op|')'
newline|'\n'
name|'for'
name|'pbd_ref'
name|'in'
name|'sr_rec'
op|'['
string|"'PBDs'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"ISO: ISO, looking to see if it is host local"'
op|')'
newline|'\n'
name|'pbd_rec'
op|'='
name|'session'
op|'.'
name|'get_rec'
op|'('
string|"'PBD'"
op|','
name|'pbd_ref'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'pbd_rec'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"ISO: PBD %s disappeared"'
op|','
name|'pbd_ref'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'pbd_rec_host'
op|'='
name|'pbd_rec'
op|'['
string|"'host'"
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"ISO: PBD matching, want %(pbd_rec)s, have %(host)s"'
op|','
nl|'\n'
op|'{'
string|"'pbd_rec'"
op|':'
name|'pbd_rec'
op|','
string|"'host'"
op|':'
name|'host'
op|'}'
op|')'
newline|'\n'
name|'if'
name|'pbd_rec_host'
op|'=='
name|'host'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"ISO: SR with local PBD"'
op|')'
newline|'\n'
name|'return'
name|'sr_ref'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_rrd_server
dedent|''
name|'def'
name|'_get_rrd_server'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return server\'s scheme and address to use for retrieving RRD XMLs."""'
newline|'\n'
name|'xs_url'
op|'='
name|'urlparse'
op|'.'
name|'urlparse'
op|'('
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'connection_url'
op|')'
newline|'\n'
name|'return'
op|'['
name|'xs_url'
op|'.'
name|'scheme'
op|','
name|'xs_url'
op|'.'
name|'netloc'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_rrd
dedent|''
name|'def'
name|'_get_rrd'
op|'('
name|'server'
op|','
name|'vm_uuid'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the VM RRD XML as a string."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'xml'
op|'='
name|'urllib'
op|'.'
name|'urlopen'
op|'('
string|'"%s://%s:%s@%s/vm_rrd?uuid=%s"'
op|'%'
op|'('
nl|'\n'
name|'server'
op|'['
number|'0'
op|']'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'connection_username'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'connection_password'
op|','
nl|'\n'
name|'server'
op|'['
number|'1'
op|']'
op|','
nl|'\n'
name|'vm_uuid'
op|')'
op|')'
newline|'\n'
name|'return'
name|'xml'
op|'.'
name|'read'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'IOError'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Unable to obtain RRD XML for VM %(vm_uuid)s with '"
nl|'\n'
string|"'server details: %(server)s.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'vm_uuid'"
op|':'
name|'vm_uuid'
op|','
string|"'server'"
op|':'
name|'server'
op|'}'
op|')'
newline|'\n'
name|'return'
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_all_vdis_in_sr
dedent|''
dedent|''
name|'def'
name|'_get_all_vdis_in_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'for'
name|'vdi_ref'
name|'in'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'SR.get_VDIs'"
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'vdi_rec'
op|'='
name|'session'
op|'.'
name|'get_rec'
op|'('
string|"'VDI'"
op|','
name|'vdi_ref'
op|')'
newline|'\n'
comment|'# Check to make sure the record still exists. It may have'
nl|'\n'
comment|'# been deleted between the get_all call and get_rec call'
nl|'\n'
name|'if'
name|'vdi_rec'
op|':'
newline|'\n'
indent|'            '
name|'yield'
name|'vdi_ref'
op|','
name|'vdi_rec'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_instance_vdis_for_sr
dedent|''
dedent|''
dedent|''
name|'def'
name|'get_instance_vdis_for_sr'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return opaqueRef for all the vdis which live on sr."""'
newline|'\n'
name|'for'
name|'vbd_ref'
name|'in'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VM.get_VBDs'"
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VBD.get_VDI'"
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'if'
name|'sr_ref'
op|'=='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_SR'"
op|','
name|'vdi_ref'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'yield'
name|'vdi_ref'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_vhd_parent_uuid
dedent|''
dedent|''
dedent|''
name|'def'
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'vdi_rec'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'vdi_rec'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'vdi_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_record"'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
string|"'vhd-parent'"
name|'not'
name|'in'
name|'vdi_rec'
op|'['
string|"'sm_config'"
op|']'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'parent_uuid'
op|'='
name|'vdi_rec'
op|'['
string|"'sm_config'"
op|']'
op|'['
string|"'vhd-parent'"
op|']'
newline|'\n'
name|'vdi_uuid'
op|'='
name|'vdi_rec'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'VHD %(vdi_uuid)s has parent %(parent_uuid)s'"
op|','
nl|'\n'
op|'{'
string|"'vdi_uuid'"
op|':'
name|'vdi_uuid'
op|','
string|"'parent_uuid'"
op|':'
name|'parent_uuid'
op|'}'
op|')'
newline|'\n'
name|'return'
name|'parent_uuid'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_walk_vdi_chain
dedent|''
name|'def'
name|'_walk_vdi_chain'
op|'('
name|'session'
op|','
name|'vdi_uuid'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Yield vdi_recs for each element in a VDI chain."""'
newline|'\n'
name|'scan_default_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'        '
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_by_uuid"'
op|','
name|'vdi_uuid'
op|')'
newline|'\n'
name|'vdi_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_record"'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'yield'
name|'vdi_rec'
newline|'\n'
nl|'\n'
name|'parent_uuid'
op|'='
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'vdi_rec'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'parent_uuid'
op|':'
newline|'\n'
indent|'            '
name|'break'
newline|'\n'
nl|'\n'
dedent|''
name|'vdi_uuid'
op|'='
name|'parent_uuid'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_is_vdi_a_snapshot
dedent|''
dedent|''
name|'def'
name|'_is_vdi_a_snapshot'
op|'('
name|'vdi_rec'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Ensure VDI is a snapshot, and not cached image."""'
newline|'\n'
name|'is_a_snapshot'
op|'='
name|'vdi_rec'
op|'['
string|"'is_a_snapshot'"
op|']'
newline|'\n'
name|'image_id'
op|'='
name|'vdi_rec'
op|'['
string|"'other_config'"
op|']'
op|'.'
name|'get'
op|'('
string|"'image-id'"
op|')'
newline|'\n'
name|'return'
name|'is_a_snapshot'
name|'and'
name|'not'
name|'image_id'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_child_vhds
dedent|''
name|'def'
name|'_child_vhds'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'vdi_uuid_list'
op|','
name|'old_snapshots_only'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the immediate children of a given VHD.\n\n    This is not recursive, only the immediate children are returned.\n    """'
newline|'\n'
name|'children'
op|'='
name|'set'
op|'('
op|')'
newline|'\n'
name|'for'
name|'ref'
op|','
name|'rec'
name|'in'
name|'_get_all_vdis_in_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'rec_uuid'
op|'='
name|'rec'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'rec_uuid'
name|'in'
name|'vdi_uuid_list'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'parent_uuid'
op|'='
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'ref'
op|','
name|'rec'
op|')'
newline|'\n'
name|'if'
name|'parent_uuid'
name|'not'
name|'in'
name|'vdi_uuid_list'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'old_snapshots_only'
name|'and'
name|'not'
name|'_is_vdi_a_snapshot'
op|'('
name|'rec'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'children'
op|'.'
name|'add'
op|'('
name|'rec_uuid'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'list'
op|'('
name|'children'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_count_children
dedent|''
name|'def'
name|'_count_children'
op|'('
name|'session'
op|','
name|'parent_vdi_uuid'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
comment|'# Search for any other vdi which has the same parent as us to work out'
nl|'\n'
comment|'# whether we have siblings and therefore if coalesce is possible'
nl|'\n'
indent|'    '
name|'children'
op|'='
number|'0'
newline|'\n'
name|'for'
name|'_ref'
op|','
name|'rec'
name|'in'
name|'_get_all_vdis_in_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
op|'('
name|'rec'
op|'['
string|"'sm_config'"
op|']'
op|'.'
name|'get'
op|'('
string|"'vhd-parent'"
op|')'
op|'=='
name|'parent_vdi_uuid'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'children'
op|'='
name|'children'
op|'+'
number|'1'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'children'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_wait_for_vhd_coalesce
dedent|''
name|'def'
name|'_wait_for_vhd_coalesce'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'sr_ref'
op|','
name|'vdi_ref'
op|','
nl|'\n'
name|'vdi_uuid_list'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Spin until the parent VHD is coalesced into one of the VDIs in the list\n\n    vdi_uuid_list is a list of acceptable final parent VDIs for vdi_ref; once\n    the parent of vdi_ref is in vdi_uuid_chain we consider the coalesce over.\n\n    The use case is there are any number of VDIs between those in\n    vdi_uuid_list and vdi_ref that we expect to be coalesced, but any of those\n    in vdi_uuid_list may also be coalesced (except the base UUID - which is\n    guaranteed to remain)\n    """'
newline|'\n'
comment|'# If the base disk was a leaf node, there will be no coalescing'
nl|'\n'
comment|'# after a VDI snapshot.'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'vdi_uuid_list'
op|')'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Old chain is single VHD, coalesce not possible."'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
comment|'# If the parent of the original disk has other children,'
nl|'\n'
comment|'# there will be no coalesce because of the VDI snapshot.'
nl|'\n'
comment|'# For example, the first snapshot for an instance that has been'
nl|'\n'
comment|'# spawned from a cached image, will not coalesce, because of this rule.'
nl|'\n'
dedent|''
name|'parent_vdi_uuid'
op|'='
name|'vdi_uuid_list'
op|'['
number|'1'
op|']'
newline|'\n'
name|'if'
name|'_count_children'
op|'('
name|'session'
op|','
name|'parent_vdi_uuid'
op|','
name|'sr_ref'
op|')'
op|'>'
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Parent has other children, coalesce is unlikely."'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
comment|'# When the VDI snapshot is taken, a new parent is created.'
nl|'\n'
comment|'# Assuming it is not one of the above cases, that new parent'
nl|'\n'
comment|'# can be coalesced, so we need to wait for that to happen.'
nl|'\n'
dedent|''
name|'max_attempts'
op|'='
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'vhd_coalesce_max_attempts'
newline|'\n'
comment|'# Remove the leaf node from list, to get possible good parents'
nl|'\n'
comment|'# when the coalesce has completed.'
nl|'\n'
comment|'# Its possible that other coalesce operation happen, so we need'
nl|'\n'
comment|'# to consider the full chain, rather than just the most recent parent.'
nl|'\n'
name|'good_parent_uuids'
op|'='
name|'vdi_uuid_list'
op|'['
number|'1'
op|':'
op|']'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'max_attempts'
op|')'
op|':'
newline|'\n'
comment|"# NOTE(sirp): This rescan is necessary to ensure the VM's `sm_config`"
nl|'\n'
comment|'# matches the underlying VHDs.'
nl|'\n'
comment|'# This can also kick XenServer into performing a pending coalesce.'
nl|'\n'
indent|'        '
name|'_scan_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
newline|'\n'
name|'parent_uuid'
op|'='
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'if'
name|'parent_uuid'
name|'and'
op|'('
name|'parent_uuid'
name|'not'
name|'in'
name|'good_parent_uuids'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Parent %(parent_uuid)s not yet in parent list"'
nl|'\n'
string|'" %(good_parent_uuids)s, waiting for coalesce..."'
op|','
nl|'\n'
op|'{'
string|"'parent_uuid'"
op|':'
name|'parent_uuid'
op|','
nl|'\n'
string|"'good_parent_uuids'"
op|':'
name|'good_parent_uuids'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Coalesce detected, because parent is: %s"'
op|'%'
name|'parent_uuid'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'greenthread'
op|'.'
name|'sleep'
op|'('
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'vhd_coalesce_poll_interval'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|'"VHD coalesce attempts exceeded (%d)"'
nl|'\n'
string|'", giving up..."'
op|')'
op|'%'
name|'max_attempts'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_remap_vbd_dev
dedent|''
name|'def'
name|'_remap_vbd_dev'
op|'('
name|'dev'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the appropriate location for a plugged-in VBD device\n\n    Ubuntu Maverick moved xvd? -> sd?. This is considered a bug and will be\n    fixed in future versions:\n        https://bugs.launchpad.net/ubuntu/+source/linux/+bug/684875\n\n    For now, we work around it by just doing a string replace.\n    """'
newline|'\n'
comment|'# NOTE(sirp): This hack can go away when we pull support for Maverick'
nl|'\n'
name|'should_remap'
op|'='
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'remap_vbd_dev'
newline|'\n'
name|'if'
name|'not'
name|'should_remap'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'dev'
newline|'\n'
nl|'\n'
dedent|''
name|'old_prefix'
op|'='
string|"'xvd'"
newline|'\n'
name|'new_prefix'
op|'='
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'remap_vbd_dev_prefix'
newline|'\n'
name|'remapped_dev'
op|'='
name|'dev'
op|'.'
name|'replace'
op|'('
name|'old_prefix'
op|','
name|'new_prefix'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'remapped_dev'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_wait_for_device
dedent|''
name|'def'
name|'_wait_for_device'
op|'('
name|'dev'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Wait for device node to appear."""'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
number|'0'
op|','
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'block_device_creation_timeout'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'dev_path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'time'
op|'.'
name|'sleep'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'StorageError'
op|'('
nl|'\n'
name|'reason'
op|'='
name|'_'
op|'('
string|"'Timeout waiting for device %s to be created'"
op|')'
op|'%'
name|'dev'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|cleanup_attached_vdis
dedent|''
name|'def'
name|'cleanup_attached_vdis'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Unplug any instance VDIs left after an unclean restart."""'
newline|'\n'
name|'this_vm_ref'
op|'='
name|'_get_this_vm_ref'
op|'('
name|'session'
op|')'
newline|'\n'
nl|'\n'
name|'vbd_refs'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VM.get_VBDs'"
op|','
name|'this_vm_ref'
op|')'
newline|'\n'
name|'for'
name|'vbd_ref'
name|'in'
name|'vbd_refs'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VBD.get_VDI'"
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'vdi_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_record'"
op|','
name|'vdi_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'e'
op|'.'
name|'details'
op|'['
number|'0'
op|']'
op|'!='
string|"'HANDLE_INVALID'"
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
dedent|''
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
string|"'nova_instance_uuid'"
name|'in'
name|'vdi_rec'
op|'['
string|"'other_config'"
op|']'
op|':'
newline|'\n'
comment|'# Belongs to an instance and probably left over after an'
nl|'\n'
comment|'# unclean restart'
nl|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Disconnecting stale VDI %s from compute domU'"
op|')'
op|','
nl|'\n'
name|'vdi_rec'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
name|'unplug_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|','
name|'this_vm_ref'
op|')'
newline|'\n'
name|'destroy_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
op|'@'
name|'contextlib'
op|'.'
name|'contextmanager'
newline|'\n'
DECL|function|vdi_attached_here
name|'def'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'this_vm_ref'
op|'='
name|'_get_this_vm_ref'
op|'('
name|'session'
op|')'
newline|'\n'
nl|'\n'
name|'vbd_ref'
op|'='
name|'create_vbd'
op|'('
name|'session'
op|','
name|'this_vm_ref'
op|','
name|'vdi_ref'
op|','
string|"'autodetect'"
op|','
nl|'\n'
name|'read_only'
op|'='
name|'read_only'
op|','
name|'bootable'
op|'='
name|'False'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Plugging VBD %s ... '"
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'session'
op|'.'
name|'VBD'
op|'.'
name|'plug'
op|'('
name|'vbd_ref'
op|','
name|'this_vm_ref'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Plugging VBD %s done.'"
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'orig_dev'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VBD.get_device"'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'VBD %(vbd_ref)s plugged as %(orig_dev)s'"
op|','
nl|'\n'
op|'{'
string|"'vbd_ref'"
op|':'
name|'vbd_ref'
op|','
string|"'orig_dev'"
op|':'
name|'orig_dev'
op|'}'
op|')'
newline|'\n'
name|'dev'
op|'='
name|'_remap_vbd_dev'
op|'('
name|'orig_dev'
op|')'
newline|'\n'
name|'if'
name|'dev'
op|'!='
name|'orig_dev'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'VBD %(vbd_ref)s plugged into wrong dev, '"
nl|'\n'
string|"'remapping to %(dev)s'"
op|','
nl|'\n'
op|'{'
string|"'vbd_ref'"
op|':'
name|'vbd_ref'
op|','
string|"'dev'"
op|':'
name|'dev'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'_wait_for_device'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'yield'
name|'dev'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'sync'"
op|','
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Destroying VBD for VDI %s ... '"
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'unplug_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|','
name|'this_vm_ref'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'destroy_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'StorageError'
op|':'
newline|'\n'
comment|'# destroy_vbd() will log error'
nl|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Destroying VBD for VDI %s done.'"
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_sys_hypervisor_uuid
dedent|''
dedent|''
name|'def'
name|'_get_sys_hypervisor_uuid'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
name|'with'
name|'file'
op|'('
string|"'/sys/hypervisor/uuid'"
op|')'
name|'as'
name|'f'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'f'
op|'.'
name|'readline'
op|'('
op|')'
op|'.'
name|'strip'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_this_vm_uuid
dedent|''
dedent|''
name|'def'
name|'get_this_vm_uuid'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'session'
name|'and'
name|'session'
op|'.'
name|'is_local_connection'
op|':'
newline|'\n'
comment|'# UUID is the control domain running on this host'
nl|'\n'
indent|'        '
name|'vms'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_all_records_where"'
op|','
nl|'\n'
string|'\'field "is_control_domain"="true" and \''
nl|'\n'
string|'\'field "resident_on"="%s"\''
op|'%'
nl|'\n'
name|'session'
op|'.'
name|'host_ref'
op|')'
newline|'\n'
name|'return'
name|'vms'
op|'['
name|'vms'
op|'.'
name|'keys'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|']'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'_get_sys_hypervisor_uuid'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'IOError'
op|':'
newline|'\n'
comment|'# Some guest kernels (without 5c13f8067745efc15f6ad0158b58d57c44104c25)'
nl|'\n'
comment|'# cannot read from uuid after a reboot.  Fall back to trying xenstore.'
nl|'\n'
comment|'# See https://bugs.launchpad.net/ubuntu/+source/xen-api/+bug/1081182'
nl|'\n'
indent|'        '
name|'domid'
op|','
name|'_'
op|'='
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'xenstore-read'"
op|','
string|"'domid'"
op|','
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
name|'vm_key'
op|','
name|'_'
op|'='
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'xenstore-read'"
op|','
nl|'\n'
string|"'/local/domain/%s/vm'"
op|'%'
name|'domid'
op|'.'
name|'strip'
op|'('
op|')'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
name|'return'
name|'vm_key'
op|'.'
name|'strip'
op|'('
op|')'
op|'['
number|'4'
op|':'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_this_vm_ref
dedent|''
dedent|''
name|'def'
name|'_get_this_vm_ref'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'return'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_by_uuid"'
op|','
name|'get_this_vm_uuid'
op|'('
name|'session'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_partitions
dedent|''
name|'def'
name|'_get_partitions'
op|'('
name|'dev'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return partition information (num, size, type) for a device."""'
newline|'\n'
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'out'
op|','
name|'_err'
op|'='
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'parted'"
op|','
string|"'--script'"
op|','
string|"'--machine'"
op|','
nl|'\n'
name|'dev_path'
op|','
string|"'unit s'"
op|','
string|"'print'"
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
name|'lines'
op|'='
op|'['
name|'line'
name|'for'
name|'line'
name|'in'
name|'out'
op|'.'
name|'split'
op|'('
string|"'\\n'"
op|')'
name|'if'
name|'line'
op|']'
newline|'\n'
name|'partitions'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Partitions:"'
op|')'
newline|'\n'
name|'for'
name|'line'
name|'in'
name|'lines'
op|'['
number|'2'
op|':'
op|']'
op|':'
newline|'\n'
indent|'        '
name|'line'
op|'='
name|'line'
op|'.'
name|'rstrip'
op|'('
string|"';'"
op|')'
newline|'\n'
name|'num'
op|','
name|'start'
op|','
name|'end'
op|','
name|'size'
op|','
name|'fstype'
op|','
name|'name'
op|','
name|'flags'
op|'='
name|'line'
op|'.'
name|'split'
op|'('
string|"':'"
op|')'
newline|'\n'
name|'num'
op|'='
name|'int'
op|'('
name|'num'
op|')'
newline|'\n'
name|'start'
op|'='
name|'int'
op|'('
name|'start'
op|'.'
name|'rstrip'
op|'('
string|"'s'"
op|')'
op|')'
newline|'\n'
name|'end'
op|'='
name|'int'
op|'('
name|'end'
op|'.'
name|'rstrip'
op|'('
string|"'s'"
op|')'
op|')'
newline|'\n'
name|'size'
op|'='
name|'int'
op|'('
name|'size'
op|'.'
name|'rstrip'
op|'('
string|"'s'"
op|')'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"  %(num)s: %(fstype)s %(size)d sectors"'
op|','
nl|'\n'
op|'{'
string|"'num'"
op|':'
name|'num'
op|','
string|"'fstype'"
op|':'
name|'fstype'
op|','
string|"'size'"
op|':'
name|'size'
op|'}'
op|')'
newline|'\n'
name|'partitions'
op|'.'
name|'append'
op|'('
op|'('
name|'num'
op|','
name|'start'
op|','
name|'size'
op|','
name|'fstype'
op|','
name|'name'
op|','
name|'flags'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'partitions'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_stream_disk
dedent|''
name|'def'
name|'_stream_disk'
op|'('
name|'session'
op|','
name|'image_service_func'
op|','
name|'image_type'
op|','
name|'virtual_size'
op|','
name|'dev'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'offset'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK'
op|':'
newline|'\n'
indent|'        '
name|'offset'
op|'='
name|'MBR_SIZE_BYTES'
newline|'\n'
name|'_write_partition'
op|'('
name|'session'
op|','
name|'virtual_size'
op|','
name|'dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
nl|'\n'
name|'with'
name|'utils'
op|'.'
name|'temporary_chown'
op|'('
name|'dev_path'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'open'
op|'('
name|'dev_path'
op|','
string|"'wb'"
op|')'
name|'as'
name|'f'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'.'
name|'seek'
op|'('
name|'offset'
op|')'
newline|'\n'
name|'image_service_func'
op|'('
name|'f'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_write_partition
dedent|''
dedent|''
dedent|''
name|'def'
name|'_write_partition'
op|'('
name|'session'
op|','
name|'virtual_size'
op|','
name|'dev'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'primary_first'
op|'='
name|'MBR_SIZE_SECTORS'
newline|'\n'
name|'primary_last'
op|'='
name|'MBR_SIZE_SECTORS'
op|'+'
op|'('
name|'virtual_size'
op|'/'
name|'SECTOR_SIZE'
op|')'
op|'-'
number|'1'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Writing partition table %(primary_first)d %(primary_last)d'"
nl|'\n'
string|"' to %(dev_path)s...'"
op|','
nl|'\n'
op|'{'
string|"'primary_first'"
op|':'
name|'primary_first'
op|','
string|"'primary_last'"
op|':'
name|'primary_last'
op|','
nl|'\n'
string|"'dev_path'"
op|':'
name|'dev_path'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'_make_partition'
op|'('
name|'session'
op|','
name|'dev'
op|','
string|'"%ds"'
op|'%'
name|'primary_first'
op|','
string|'"%ds"'
op|'%'
name|'primary_last'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Writing partition table %s done.'"
op|','
name|'dev_path'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_repair_filesystem
dedent|''
name|'def'
name|'_repair_filesystem'
op|'('
name|'partition_path'
op|')'
op|':'
newline|'\n'
comment|'# Exit Code 1 = File system errors corrected'
nl|'\n'
comment|'#           2 = File system errors corrected, system needs a reboot'
nl|'\n'
indent|'    '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'e2fsck'"
op|','
string|"'-f'"
op|','
string|"'-y'"
op|','
name|'partition_path'
op|','
name|'run_as_root'
op|'='
name|'True'
op|','
nl|'\n'
name|'check_exit_code'
op|'='
op|'['
number|'0'
op|','
number|'1'
op|','
number|'2'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_resize_part_and_fs
dedent|''
name|'def'
name|'_resize_part_and_fs'
op|'('
name|'dev'
op|','
name|'start'
op|','
name|'old_sectors'
op|','
name|'new_sectors'
op|','
name|'flags'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Resize partition and fileystem.\n\n    This assumes we are dealing with a single primary partition and using\n    ext3 or ext4.\n    """'
newline|'\n'
name|'size'
op|'='
name|'new_sectors'
op|'-'
name|'start'
newline|'\n'
name|'end'
op|'='
name|'new_sectors'
op|'-'
number|'1'
newline|'\n'
nl|'\n'
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'partition_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|','
name|'partition'
op|'='
number|'1'
op|')'
newline|'\n'
nl|'\n'
comment|"# Replay journal if FS wasn't cleanly unmounted"
nl|'\n'
name|'_repair_filesystem'
op|'('
name|'partition_path'
op|')'
newline|'\n'
nl|'\n'
comment|'# Remove ext3 journal (making it ext2)'
nl|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'tune2fs'"
op|','
string|"'-O ^has_journal'"
op|','
name|'partition_path'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'new_sectors'
op|'<'
name|'old_sectors'
op|':'
newline|'\n'
comment|'# Resizing down, resize filesystem before partition resize'
nl|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'resize2fs'"
op|','
name|'partition_path'
op|','
string|"'%ds'"
op|'%'
name|'size'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'processutils'
op|'.'
name|'ProcessExecutionError'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'six'
op|'.'
name|'text_type'
op|'('
name|'exc'
op|')'
op|')'
newline|'\n'
name|'reason'
op|'='
name|'_'
op|'('
string|'"Shrinking the filesystem down with resize2fs "'
nl|'\n'
string|'"has failed, please check if you have "'
nl|'\n'
string|'"enough free space on your disk."'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'ResizeError'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'parted'"
op|','
string|"'--script'"
op|','
name|'dev_path'
op|','
string|"'rm'"
op|','
string|"'1'"
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'parted'"
op|','
string|"'--script'"
op|','
name|'dev_path'
op|','
string|"'mkpart'"
op|','
nl|'\n'
string|"'primary'"
op|','
nl|'\n'
string|"'%ds'"
op|'%'
name|'start'
op|','
nl|'\n'
string|"'%ds'"
op|'%'
name|'end'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
name|'if'
string|'"boot"'
name|'in'
name|'flags'
op|'.'
name|'lower'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'parted'"
op|','
string|"'--script'"
op|','
name|'dev_path'
op|','
nl|'\n'
string|"'set'"
op|','
string|"'1'"
op|','
string|"'boot'"
op|','
string|"'on'"
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'new_sectors'
op|'>'
name|'old_sectors'
op|':'
newline|'\n'
comment|'# Resizing up, resize filesystem after partition resize'
nl|'\n'
indent|'        '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'resize2fs'"
op|','
name|'partition_path'
op|','
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
comment|'# Add back journal'
nl|'\n'
dedent|''
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'tune2fs'"
op|','
string|"'-j'"
op|','
name|'partition_path'
op|','
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_log_progress_if_required
dedent|''
name|'def'
name|'_log_progress_if_required'
op|'('
name|'left'
op|','
name|'last_log_time'
op|','
name|'virtual_size'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'timeutils'
op|'.'
name|'is_older_than'
op|'('
name|'last_log_time'
op|','
name|'PROGRESS_INTERVAL_SECONDS'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'last_log_time'
op|'='
name|'timeutils'
op|'.'
name|'utcnow'
op|'('
op|')'
newline|'\n'
name|'complete_pct'
op|'='
name|'float'
op|'('
name|'virtual_size'
op|'-'
name|'left'
op|')'
op|'/'
name|'virtual_size'
op|'*'
number|'100'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Sparse copy in progress, "'
nl|'\n'
string|'"%(complete_pct).2f%% complete. "'
nl|'\n'
string|'"%(left)s bytes left to copy"'
op|','
nl|'\n'
op|'{'
string|'"complete_pct"'
op|':'
name|'complete_pct'
op|','
string|'"left"'
op|':'
name|'left'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'last_log_time'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_sparse_copy
dedent|''
name|'def'
name|'_sparse_copy'
op|'('
name|'src_path'
op|','
name|'dst_path'
op|','
name|'virtual_size'
op|','
name|'block_size'
op|'='
number|'4096'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Copy data, skipping long runs of zeros to create a sparse file."""'
newline|'\n'
name|'start_time'
op|'='
name|'last_log_time'
op|'='
name|'timeutils'
op|'.'
name|'utcnow'
op|'('
op|')'
newline|'\n'
name|'EMPTY_BLOCK'
op|'='
string|"'\\0'"
op|'*'
name|'block_size'
newline|'\n'
name|'bytes_read'
op|'='
number|'0'
newline|'\n'
name|'skipped_bytes'
op|'='
number|'0'
newline|'\n'
name|'left'
op|'='
name|'virtual_size'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Starting sparse_copy src=%(src_path)s dst=%(dst_path)s "'
nl|'\n'
string|'"virtual_size=%(virtual_size)d block_size=%(block_size)d"'
op|','
nl|'\n'
op|'{'
string|"'src_path'"
op|':'
name|'src_path'
op|','
string|"'dst_path'"
op|':'
name|'dst_path'
op|','
nl|'\n'
string|"'virtual_size'"
op|':'
name|'virtual_size'
op|','
string|"'block_size'"
op|':'
name|'block_size'
op|'}'
op|')'
newline|'\n'
nl|'\n'
comment|"# NOTE(sirp): we need read/write access to the devices; since we don't have"
nl|'\n'
comment|"# the luxury of shelling out to a sudo'd command, we temporarily take"
nl|'\n'
comment|'# ownership of the devices.'
nl|'\n'
name|'with'
name|'utils'
op|'.'
name|'temporary_chown'
op|'('
name|'src_path'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'utils'
op|'.'
name|'temporary_chown'
op|'('
name|'dst_path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'open'
op|'('
name|'src_path'
op|','
string|'"r"'
op|')'
name|'as'
name|'src'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'open'
op|'('
name|'dst_path'
op|','
string|'"w"'
op|')'
name|'as'
name|'dst'
op|':'
newline|'\n'
indent|'                    '
name|'data'
op|'='
name|'src'
op|'.'
name|'read'
op|'('
name|'min'
op|'('
name|'block_size'
op|','
name|'left'
op|')'
op|')'
newline|'\n'
name|'while'
name|'data'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'data'
op|'=='
name|'EMPTY_BLOCK'
op|':'
newline|'\n'
indent|'                            '
name|'dst'
op|'.'
name|'seek'
op|'('
name|'block_size'
op|','
name|'os'
op|'.'
name|'SEEK_CUR'
op|')'
newline|'\n'
name|'left'
op|'-='
name|'block_size'
newline|'\n'
name|'bytes_read'
op|'+='
name|'block_size'
newline|'\n'
name|'skipped_bytes'
op|'+='
name|'block_size'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                            '
name|'dst'
op|'.'
name|'write'
op|'('
name|'data'
op|')'
newline|'\n'
name|'data_len'
op|'='
name|'len'
op|'('
name|'data'
op|')'
newline|'\n'
name|'left'
op|'-='
name|'data_len'
newline|'\n'
name|'bytes_read'
op|'+='
name|'data_len'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'left'
op|'<='
number|'0'
op|':'
newline|'\n'
indent|'                            '
name|'break'
newline|'\n'
nl|'\n'
dedent|''
name|'data'
op|'='
name|'src'
op|'.'
name|'read'
op|'('
name|'min'
op|'('
name|'block_size'
op|','
name|'left'
op|')'
op|')'
newline|'\n'
name|'greenthread'
op|'.'
name|'sleep'
op|'('
number|'0'
op|')'
newline|'\n'
name|'last_log_time'
op|'='
name|'_log_progress_if_required'
op|'('
nl|'\n'
name|'left'
op|','
name|'last_log_time'
op|','
name|'virtual_size'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'duration'
op|'='
name|'timeutils'
op|'.'
name|'delta_seconds'
op|'('
name|'start_time'
op|','
name|'timeutils'
op|'.'
name|'utcnow'
op|'('
op|')'
op|')'
newline|'\n'
name|'compression_pct'
op|'='
name|'float'
op|'('
name|'skipped_bytes'
op|')'
op|'/'
name|'bytes_read'
op|'*'
number|'100'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Finished sparse_copy in %(duration).2f secs, "'
nl|'\n'
string|'"%(compression_pct).2f%% reduction in size"'
op|','
nl|'\n'
op|'{'
string|"'duration'"
op|':'
name|'duration'
op|','
string|"'compression_pct'"
op|':'
name|'compression_pct'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_copy_partition
dedent|''
name|'def'
name|'_copy_partition'
op|'('
name|'session'
op|','
name|'src_ref'
op|','
name|'dst_ref'
op|','
name|'partition'
op|','
name|'virtual_size'
op|')'
op|':'
newline|'\n'
comment|'# Part of disk taken up by MBR'
nl|'\n'
indent|'    '
name|'virtual_size'
op|'-='
name|'MBR_SIZE_BYTES'
newline|'\n'
nl|'\n'
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'src_ref'
op|','
name|'read_only'
op|'='
name|'True'
op|')'
name|'as'
name|'src'
op|':'
newline|'\n'
indent|'        '
name|'src_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'src'
op|','
name|'partition'
op|'='
name|'partition'
op|')'
newline|'\n'
nl|'\n'
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'dst_ref'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
name|'as'
name|'dst'
op|':'
newline|'\n'
indent|'            '
name|'dst_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dst'
op|','
name|'partition'
op|'='
name|'partition'
op|')'
newline|'\n'
nl|'\n'
name|'_write_partition'
op|'('
name|'session'
op|','
name|'virtual_size'
op|','
name|'dst'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'sparse_copy'
op|':'
newline|'\n'
indent|'                '
name|'_sparse_copy'
op|'('
name|'src_path'
op|','
name|'dst_path'
op|','
name|'virtual_size'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'num_blocks'
op|'='
name|'virtual_size'
op|'/'
name|'SECTOR_SIZE'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'dd'"
op|','
nl|'\n'
string|"'if=%s'"
op|'%'
name|'src_path'
op|','
nl|'\n'
string|"'of=%s'"
op|'%'
name|'dst_path'
op|','
nl|'\n'
string|"'count=%d'"
op|'%'
name|'num_blocks'
op|','
nl|'\n'
string|"'iflag=direct,sync'"
op|','
nl|'\n'
string|"'oflag=direct,sync'"
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_mount_filesystem
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_mount_filesystem'
op|'('
name|'dev_path'
op|','
name|'dir'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""mounts the device specified by dev_path in dir."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'_out'
op|','
name|'err'
op|'='
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mount'"
op|','
nl|'\n'
string|"'-t'"
op|','
string|"'ext2,ext3,ext4,reiserfs'"
op|','
nl|'\n'
name|'dev_path'
op|','
name|'dir'
op|','
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'processutils'
op|'.'
name|'ProcessExecutionError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'err'
op|'='
name|'six'
op|'.'
name|'text_type'
op|'('
name|'e'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'err'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_mounted_processing
dedent|''
name|'def'
name|'_mounted_processing'
op|'('
name|'device'
op|','
name|'key'
op|','
name|'net'
op|','
name|'metadata'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Callback which runs with the image VDI attached."""'
newline|'\n'
comment|'# NB: Partition 1 hardcoded'
nl|'\n'
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'device'
op|','
name|'partition'
op|'='
number|'1'
op|')'
newline|'\n'
name|'with'
name|'utils'
op|'.'
name|'tempdir'
op|'('
op|')'
name|'as'
name|'tmpdir'
op|':'
newline|'\n'
comment|'# Mount only Linux filesystems, to avoid disturbing NTFS images'
nl|'\n'
indent|'        '
name|'err'
op|'='
name|'_mount_filesystem'
op|'('
name|'dev_path'
op|','
name|'tmpdir'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
comment|'# This try block ensures that the umount occurs'
nl|'\n'
indent|'                '
name|'if'
name|'not'
name|'agent'
op|'.'
name|'find_guest_agent'
op|'('
name|'tmpdir'
op|')'
op|':'
newline|'\n'
comment|'# TODO(berrange) passing in a None filename is'
nl|'\n'
comment|"# rather dubious. We shouldn't be re-implementing"
nl|'\n'
comment|'# the mount/unmount logic here either, when the'
nl|'\n'
comment|'# VFSLocalFS impl has direct support for mount'
nl|'\n'
comment|'# and unmount handling if it were passed a'
nl|'\n'
comment|'# non-None filename'
nl|'\n'
indent|'                    '
name|'vfs'
op|'='
name|'vfsimpl'
op|'.'
name|'VFSLocalFS'
op|'('
nl|'\n'
name|'imgmodel'
op|'.'
name|'LocalFileImage'
op|'('
name|'None'
op|','
name|'imgmodel'
op|'.'
name|'FORMAT_RAW'
op|')'
op|','
nl|'\n'
name|'imgdir'
op|'='
name|'tmpdir'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Manipulating interface files directly'"
op|')'
op|')'
newline|'\n'
comment|"# for xenapi, we don't 'inject' admin_password here,"
nl|'\n'
comment|"# it's handled at instance startup time, nor do we"
nl|'\n'
comment|'# support injecting arbitrary files here.'
nl|'\n'
name|'disk'
op|'.'
name|'inject_data_into_fs'
op|'('
name|'vfs'
op|','
nl|'\n'
name|'key'
op|','
name|'net'
op|','
name|'metadata'
op|','
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'                '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'umount'"
op|','
name|'dev_path'
op|','
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Failed to mount filesystem (expected for '"
nl|'\n'
string|"'non-linux instances): %s'"
op|')'
op|','
name|'err'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|ensure_correct_host
dedent|''
dedent|''
dedent|''
name|'def'
name|'ensure_correct_host'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Ensure we\'re connected to the host we\'re running on. This is the\n    required configuration for anything that uses vdi_attached_here.\n    """'
newline|'\n'
name|'this_vm_uuid'
op|'='
name|'get_this_vm_uuid'
op|'('
name|'session'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VM.get_by_uuid'"
op|','
name|'this_vm_uuid'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'exc'
op|'.'
name|'details'
op|'['
number|'0'
op|']'
op|'!='
string|"'UUID_INVALID'"
op|':'
newline|'\n'
indent|'            '
name|'raise'
newline|'\n'
dedent|''
name|'raise'
name|'Exception'
op|'('
name|'_'
op|'('
string|"'This domU must be running on the host '"
nl|'\n'
string|"'specified by connection_url'"
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|import_all_migrated_disks
dedent|''
dedent|''
name|'def'
name|'import_all_migrated_disks'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'import_root'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'root_vdi'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'import_root'
op|':'
newline|'\n'
indent|'        '
name|'root_vdi'
op|'='
name|'_import_migrated_root_disk'
op|'('
name|'session'
op|','
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'eph_vdis'
op|'='
name|'_import_migrate_ephemeral_disks'
op|'('
name|'session'
op|','
name|'instance'
op|')'
newline|'\n'
name|'return'
op|'{'
string|"'root'"
op|':'
name|'root_vdi'
op|','
string|"'ephemerals'"
op|':'
name|'eph_vdis'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_import_migrated_root_disk
dedent|''
name|'def'
name|'_import_migrated_root_disk'
op|'('
name|'session'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'chain_label'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'vdi_label'
op|'='
name|'instance'
op|'['
string|"'name'"
op|']'
newline|'\n'
name|'return'
name|'_import_migrated_vhds'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'chain_label'
op|','
string|'"root"'
op|','
nl|'\n'
name|'vdi_label'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_import_migrate_ephemeral_disks
dedent|''
name|'def'
name|'_import_migrate_ephemeral_disks'
op|'('
name|'session'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'ephemeral_vdis'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'instance_uuid'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'ephemeral_gb'
op|'='
name|'instance'
op|'.'
name|'old_flavor'
op|'.'
name|'ephemeral_gb'
newline|'\n'
name|'disk_sizes'
op|'='
name|'get_ephemeral_disk_sizes'
op|'('
name|'ephemeral_gb'
op|')'
newline|'\n'
name|'for'
name|'chain_number'
op|','
name|'_size'
name|'in'
name|'enumerate'
op|'('
name|'disk_sizes'
op|','
name|'start'
op|'='
number|'1'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'chain_label'
op|'='
name|'instance_uuid'
op|'+'
string|'"_ephemeral_%d"'
op|'%'
name|'chain_number'
newline|'\n'
name|'vdi_label'
op|'='
string|'"%(name)s ephemeral (%(number)d)"'
op|'%'
name|'dict'
op|'('
nl|'\n'
name|'name'
op|'='
name|'instance'
op|'['
string|"'name'"
op|']'
op|','
name|'number'
op|'='
name|'chain_number'
op|')'
newline|'\n'
name|'ephemeral_vdi'
op|'='
name|'_import_migrated_vhds'
op|'('
name|'session'
op|','
name|'instance'
op|','
nl|'\n'
name|'chain_label'
op|','
string|'"ephemeral"'
op|','
nl|'\n'
name|'vdi_label'
op|')'
newline|'\n'
name|'userdevice'
op|'='
number|'3'
op|'+'
name|'chain_number'
newline|'\n'
name|'ephemeral_vdis'
op|'['
name|'str'
op|'('
name|'userdevice'
op|')'
op|']'
op|'='
name|'ephemeral_vdi'
newline|'\n'
dedent|''
name|'return'
name|'ephemeral_vdis'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_import_migrated_vhds
dedent|''
name|'def'
name|'_import_migrated_vhds'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'chain_label'
op|','
name|'disk_type'
op|','
nl|'\n'
name|'vdi_label'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Move and possibly link VHDs via the XAPI plugin."""'
newline|'\n'
comment|'# TODO(johngarbutt) tidy up plugin params'
nl|'\n'
name|'imported_vhds'
op|'='
name|'session'
op|'.'
name|'call_plugin_serialized'
op|'('
nl|'\n'
string|"'migration'"
op|','
string|"'move_vhds_into_sr'"
op|','
name|'instance_uuid'
op|'='
name|'chain_label'
op|','
nl|'\n'
name|'sr_path'
op|'='
name|'get_sr_path'
op|'('
name|'session'
op|')'
op|','
name|'uuid_stack'
op|'='
name|'_make_uuid_stack'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Now we rescan the SR so we find the VHDs'
nl|'\n'
name|'scan_default_sr'
op|'('
name|'session'
op|')'
newline|'\n'
nl|'\n'
name|'vdi_uuid'
op|'='
name|'imported_vhds'
op|'['
string|"'root'"
op|']'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_by_uuid'"
op|','
name|'vdi_uuid'
op|')'
newline|'\n'
nl|'\n'
comment|'# Set name-label so we can find if we need to clean up a failed migration'
nl|'\n'
name|'_set_vdi_info'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'disk_type'
op|','
name|'vdi_label'
op|','
nl|'\n'
name|'disk_type'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'return'
op|'{'
string|"'uuid'"
op|':'
name|'vdi_uuid'
op|','
string|"'ref'"
op|':'
name|'vdi_ref'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|migrate_vhd
dedent|''
name|'def'
name|'migrate_vhd'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vdi_uuid'
op|','
name|'dest'
op|','
name|'sr_path'
op|','
name|'seq_num'
op|','
nl|'\n'
name|'ephemeral_number'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Migrating VHD \'%(vdi_uuid)s\' with seq_num %(seq_num)d"'
op|','
nl|'\n'
op|'{'
string|"'vdi_uuid'"
op|':'
name|'vdi_uuid'
op|','
string|"'seq_num'"
op|':'
name|'seq_num'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'chain_label'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'if'
name|'ephemeral_number'
op|':'
newline|'\n'
indent|'        '
name|'chain_label'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|'+'
string|'"_ephemeral_%d"'
op|'%'
name|'ephemeral_number'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
comment|'# TODO(johngarbutt) tidy up plugin params'
nl|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_plugin_serialized'
op|'('
string|"'migration'"
op|','
string|"'transfer_vhd'"
op|','
nl|'\n'
name|'instance_uuid'
op|'='
name|'chain_label'
op|','
name|'host'
op|'='
name|'dest'
op|','
name|'vdi_uuid'
op|'='
name|'vdi_uuid'
op|','
nl|'\n'
name|'sr_path'
op|'='
name|'sr_path'
op|','
name|'seq_num'
op|'='
name|'seq_num'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|':'
newline|'\n'
indent|'        '
name|'msg'
op|'='
string|'"Failed to transfer vhd to new host"'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'msg'
op|','
name|'instance'
op|'='
name|'instance'
op|','
name|'exc_info'
op|'='
name|'True'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'MigrationError'
op|'('
name|'reason'
op|'='
name|'msg'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|vm_ref_or_raise
dedent|''
dedent|''
name|'def'
name|'vm_ref_or_raise'
op|'('
name|'session'
op|','
name|'instance_name'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vm_ref'
op|'='
name|'lookup'
op|'('
name|'session'
op|','
name|'instance_name'
op|')'
newline|'\n'
name|'if'
name|'vm_ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|'('
name|'instance_id'
op|'='
name|'instance_name'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'vm_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|handle_ipxe_iso
dedent|''
name|'def'
name|'handle_ipxe_iso'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'cd_vdi'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""iPXE ISOs are a mechanism to allow the customer to roll their own\n    image.\n\n    To use this feature, a service provider needs to configure the\n    appropriate Nova flags, roll an iPXE ISO, then distribute that image\n    to customers via Glance.\n\n    NOTE: `mkisofs` is not present by default in the Dom0, so the service\n    provider can either add that package manually to Dom0 or include the\n    `mkisofs` binary in the image itself.\n    """'
newline|'\n'
name|'boot_menu_url'
op|'='
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'ipxe_boot_menu_url'
newline|'\n'
name|'if'
name|'not'
name|'boot_menu_url'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|"'ipxe_boot_menu_url not set, user will have to'"
nl|'\n'
string|"' enter URL manually...'"
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'network_name'
op|'='
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'ipxe_network_name'
newline|'\n'
name|'if'
name|'not'
name|'network_name'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|"'ipxe_network_name not set, user will have to'"
nl|'\n'
string|"' enter IP manually...'"
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'network'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'vif'
op|'['
string|"'network'"
op|']'
op|'['
string|"'label'"
op|']'
op|'=='
name|'network_name'
op|':'
newline|'\n'
indent|'            '
name|'network'
op|'='
name|'vif'
op|'['
string|"'network'"
op|']'
newline|'\n'
name|'break'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'network'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"Unable to find network matching \'%(network_name)s\', "'
nl|'\n'
string|'"user will have to enter IP manually..."'
op|')'
op|','
nl|'\n'
op|'{'
string|"'network_name'"
op|':'
name|'network_name'
op|'}'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'sr_path'
op|'='
name|'get_sr_path'
op|'('
name|'session'
op|')'
newline|'\n'
nl|'\n'
comment|'# Unpack IPv4 network info'
nl|'\n'
name|'subnet'
op|'='
op|'['
name|'sn'
name|'for'
name|'sn'
name|'in'
name|'network'
op|'['
string|"'subnets'"
op|']'
nl|'\n'
name|'if'
name|'sn'
op|'['
string|"'version'"
op|']'
op|'=='
number|'4'
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
name|'ip'
op|'='
name|'subnet'
op|'['
string|"'ips'"
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
name|'ip_address'
op|'='
name|'ip'
op|'['
string|"'address'"
op|']'
newline|'\n'
name|'netmask'
op|'='
name|'network_model'
op|'.'
name|'get_netmask'
op|'('
name|'ip'
op|','
name|'subnet'
op|')'
newline|'\n'
name|'gateway'
op|'='
name|'subnet'
op|'['
string|"'gateway'"
op|']'
op|'['
string|"'address'"
op|']'
newline|'\n'
name|'dns'
op|'='
name|'subnet'
op|'['
string|"'dns'"
op|']'
op|'['
number|'0'
op|']'
op|'['
string|"'address'"
op|']'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_plugin_serialized'
op|'('
string|'"ipxe"'
op|','
string|'"inject"'
op|','
name|'sr_path'
op|','
nl|'\n'
name|'cd_vdi'
op|'['
string|"'uuid'"
op|']'
op|','
name|'boot_menu_url'
op|','
name|'ip_address'
op|','
name|'netmask'
op|','
nl|'\n'
name|'gateway'
op|','
name|'dns'
op|','
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'ipxe_mkisofs_cmd'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'_type'
op|','
name|'_method'
op|','
name|'error'
op|'='
name|'exc'
op|'.'
name|'details'
op|'['
op|':'
number|'3'
op|']'
newline|'\n'
name|'if'
name|'error'
op|'=='
string|"'CommandNotFound'"
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"ISO creation tool \'%s\' does not exist."'
op|')'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'xenserver'
op|'.'
name|'ipxe_mkisofs_cmd'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|set_other_config_pci
dedent|''
dedent|''
dedent|''
name|'def'
name|'set_other_config_pci'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'params'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Set the pci key of other-config parameter to params."""'
newline|'\n'
name|'other_config'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_other_config"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'other_config'
op|'['
string|"'pci'"
op|']'
op|'='
name|'params'
newline|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.set_other_config"'
op|','
name|'vm_ref'
op|','
name|'other_config'
op|')'
newline|'\n'
dedent|''
endmarker|''
end_unit
