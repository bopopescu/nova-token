begin_unit
comment|'# vim: tabstop=4 shiftwidth=4 softtabstop=4'
nl|'\n'
nl|'\n'
comment|'# Copyright (c) 2010 Citrix Systems, Inc.'
nl|'\n'
comment|'# Copyright 2011 Piston Cloud Computing, Inc.'
nl|'\n'
comment|'# Copyright 2012 OpenStack, LLC.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
nl|'\n'
string|'"""\nHelper methods for operations related to the management of VM records and\ntheir attributes like VDIs, VIFs, as well as their lookup functions.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'contextlib'
newline|'\n'
name|'import'
name|'decimal'
newline|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'re'
newline|'\n'
name|'import'
name|'time'
newline|'\n'
name|'import'
name|'urllib'
newline|'\n'
name|'import'
name|'urlparse'
newline|'\n'
name|'import'
name|'uuid'
newline|'\n'
name|'from'
name|'xml'
op|'.'
name|'dom'
name|'import'
name|'minidom'
newline|'\n'
name|'from'
name|'xml'
op|'.'
name|'parsers'
name|'import'
name|'expat'
newline|'\n'
nl|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'greenthread'
newline|'\n'
nl|'\n'
name|'from'
name|'nova'
name|'import'
name|'block_device'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'instance_types'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'power_state'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'db'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'exception'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'flags'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'image'
name|'import'
name|'glance'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'cfg'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'excutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'log'
name|'as'
name|'logging'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'utils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'disk'
name|'import'
name|'api'
name|'as'
name|'disk'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'driver'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'xenapi'
name|'import'
name|'volume_utils'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|LOG
name|'LOG'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|xenapi_vm_utils_opts
name|'xenapi_vm_utils_opts'
op|'='
op|'['
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'default_os_type'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'linux'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Default OS type'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'block_device_creation_timeout'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'10'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Time to wait for a block device to be created'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'max_kernel_ramdisk_size'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'16'
op|'*'
number|'1024'
op|'*'
number|'1024'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Maximum size in bytes of kernel or ramdisk images'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'sr_matching_filter'"
op|','
nl|'\n'
name|'default'
op|'='
string|"'other-config:i18n-key=local-storage'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Filter for finding the SR to be used to install guest '"
nl|'\n'
string|"'instances on. The default value is the Local Storage in '"
nl|'\n'
string|"'default XenServer/XCP installations. To select an SR '"
nl|'\n'
string|"'with a different matching criteria, you could set it to '"
nl|'\n'
string|"'other-config:my_favorite_sr=true. On the other hand, to '"
nl|'\n'
string|"'fall back on the Default SR, as displayed by XenCenter, '"
nl|'\n'
string|"'set this flag to: default-sr:true'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'BoolOpt'
op|'('
string|"'xenapi_sparse_copy'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
name|'True'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Whether to use sparse_copy for copying data on a '"
nl|'\n'
string|"'resize down (False will use standard dd). This speeds '"
nl|'\n'
string|"'up resizes down considerably since large runs of zeros '"
nl|'\n'
string|"'won\\'t have to be rsynced'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'xenapi_num_vbd_unplug_retries'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'10'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Maximum number of retries to unplug VBD'"
op|')'
op|','
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
DECL|variable|FLAGS
name|'FLAGS'
op|'='
name|'flags'
op|'.'
name|'FLAGS'
newline|'\n'
name|'FLAGS'
op|'.'
name|'register_opts'
op|'('
name|'xenapi_vm_utils_opts'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|XENAPI_POWER_STATE
name|'XENAPI_POWER_STATE'
op|'='
op|'{'
nl|'\n'
string|"'Halted'"
op|':'
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|','
nl|'\n'
string|"'Running'"
op|':'
name|'power_state'
op|'.'
name|'RUNNING'
op|','
nl|'\n'
string|"'Paused'"
op|':'
name|'power_state'
op|'.'
name|'PAUSED'
op|','
nl|'\n'
string|"'Suspended'"
op|':'
name|'power_state'
op|'.'
name|'SUSPENDED'
op|','
nl|'\n'
string|"'Crashed'"
op|':'
name|'power_state'
op|'.'
name|'CRASHED'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|SECTOR_SIZE
name|'SECTOR_SIZE'
op|'='
number|'512'
newline|'\n'
DECL|variable|MBR_SIZE_SECTORS
name|'MBR_SIZE_SECTORS'
op|'='
number|'63'
newline|'\n'
DECL|variable|MBR_SIZE_BYTES
name|'MBR_SIZE_BYTES'
op|'='
name|'MBR_SIZE_SECTORS'
op|'*'
name|'SECTOR_SIZE'
newline|'\n'
DECL|variable|KERNEL_DIR
name|'KERNEL_DIR'
op|'='
string|"'/boot/guest'"
newline|'\n'
DECL|variable|MAX_VDI_CHAIN_SIZE
name|'MAX_VDI_CHAIN_SIZE'
op|'='
number|'16'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ImageType
name|'class'
name|'ImageType'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Enumeration class for distinguishing different image types\n\n    | 0 - kernel image (goes on dom0\'s filesystem)\n    | 1 - ramdisk image (goes on dom0\'s filesystem)\n    | 2 - disk image (local SR, partitioned by objectstore plugin)\n    | 3 - raw disk image (local SR, NOT partitioned by plugin)\n    | 4 - vhd disk image (local SR, NOT inspected by XS, PV assumed for\n    |     linux, HVM assumed for Windows)\n    | 5 - ISO disk image (local SR, NOT partitioned by plugin)\n    """'
newline|'\n'
nl|'\n'
DECL|variable|KERNEL
name|'KERNEL'
op|'='
number|'0'
newline|'\n'
DECL|variable|RAMDISK
name|'RAMDISK'
op|'='
number|'1'
newline|'\n'
DECL|variable|DISK
name|'DISK'
op|'='
number|'2'
newline|'\n'
DECL|variable|DISK_RAW
name|'DISK_RAW'
op|'='
number|'3'
newline|'\n'
DECL|variable|DISK_VHD
name|'DISK_VHD'
op|'='
number|'4'
newline|'\n'
DECL|variable|DISK_ISO
name|'DISK_ISO'
op|'='
number|'5'
newline|'\n'
DECL|variable|_ids
name|'_ids'
op|'='
op|'('
name|'KERNEL'
op|','
name|'RAMDISK'
op|','
name|'DISK'
op|','
name|'DISK_RAW'
op|','
name|'DISK_VHD'
op|','
name|'DISK_ISO'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|KERNEL_STR
name|'KERNEL_STR'
op|'='
string|'"kernel"'
newline|'\n'
DECL|variable|RAMDISK_STR
name|'RAMDISK_STR'
op|'='
string|'"ramdisk"'
newline|'\n'
DECL|variable|DISK_STR
name|'DISK_STR'
op|'='
string|'"root"'
newline|'\n'
DECL|variable|DISK_RAW_STR
name|'DISK_RAW_STR'
op|'='
string|'"os_raw"'
newline|'\n'
DECL|variable|DISK_VHD_STR
name|'DISK_VHD_STR'
op|'='
string|'"vhd"'
newline|'\n'
DECL|variable|DISK_ISO_STR
name|'DISK_ISO_STR'
op|'='
string|'"iso"'
newline|'\n'
DECL|variable|_strs
name|'_strs'
op|'='
op|'('
name|'KERNEL_STR'
op|','
name|'RAMDISK_STR'
op|','
name|'DISK_STR'
op|','
name|'DISK_RAW_STR'
op|','
name|'DISK_VHD_STR'
op|','
nl|'\n'
name|'DISK_ISO_STR'
op|')'
newline|'\n'
nl|'\n'
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|to_string
name|'def'
name|'to_string'
op|'('
name|'cls'
op|','
name|'image_type'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'dict'
op|'('
name|'zip'
op|'('
name|'ImageType'
op|'.'
name|'_ids'
op|','
name|'ImageType'
op|'.'
name|'_strs'
op|')'
op|')'
op|'.'
name|'get'
op|'('
name|'image_type'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|from_string
name|'def'
name|'from_string'
op|'('
name|'cls'
op|','
name|'image_type_str'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'dict'
op|'('
name|'zip'
op|'('
name|'ImageType'
op|'.'
name|'_strs'
op|','
name|'ImageType'
op|'.'
name|'_ids'
op|')'
op|')'
op|'.'
name|'get'
op|'('
name|'image_type_str'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|create_vm
dedent|''
dedent|''
name|'def'
name|'create_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'kernel'
op|','
name|'ramdisk'
op|','
nl|'\n'
name|'use_pv_kernel'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Create a VM record.  Returns new VM reference.\n    the use_pv_kernel flag indicates whether the guest is HVM or PV\n\n    There are 3 scenarios:\n\n        1. Using paravirtualization, kernel passed in\n\n        2. Using paravirtualization, kernel within the image\n\n        3. Using hardware virtualization\n    """'
newline|'\n'
name|'inst_type_id'
op|'='
name|'instance'
op|'['
string|"'instance_type_id'"
op|']'
newline|'\n'
name|'instance_type'
op|'='
name|'instance_types'
op|'.'
name|'get_instance_type'
op|'('
name|'inst_type_id'
op|')'
newline|'\n'
name|'mem'
op|'='
name|'str'
op|'('
name|'long'
op|'('
name|'instance_type'
op|'['
string|"'memory_mb'"
op|']'
op|')'
op|'*'
number|'1024'
op|'*'
number|'1024'
op|')'
newline|'\n'
name|'vcpus'
op|'='
name|'str'
op|'('
name|'instance_type'
op|'['
string|"'vcpus'"
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'rec'
op|'='
op|'{'
nl|'\n'
string|"'actions_after_crash'"
op|':'
string|"'destroy'"
op|','
nl|'\n'
string|"'actions_after_reboot'"
op|':'
string|"'restart'"
op|','
nl|'\n'
string|"'actions_after_shutdown'"
op|':'
string|"'destroy'"
op|','
nl|'\n'
string|"'affinity'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'blocked_operations'"
op|':'
op|'{'
op|'}'
op|','
nl|'\n'
string|"'ha_always_run'"
op|':'
name|'False'
op|','
nl|'\n'
string|"'ha_restart_priority'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'HVM_boot_params'"
op|':'
op|'{'
op|'}'
op|','
nl|'\n'
string|"'HVM_boot_policy'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'is_a_template'"
op|':'
name|'False'
op|','
nl|'\n'
string|"'memory_dynamic_min'"
op|':'
name|'mem'
op|','
nl|'\n'
string|"'memory_dynamic_max'"
op|':'
name|'mem'
op|','
nl|'\n'
string|"'memory_static_min'"
op|':'
string|"'0'"
op|','
nl|'\n'
string|"'memory_static_max'"
op|':'
name|'mem'
op|','
nl|'\n'
string|"'memory_target'"
op|':'
name|'mem'
op|','
nl|'\n'
string|"'name_description'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'name_label'"
op|':'
name|'name_label'
op|','
nl|'\n'
string|"'other_config'"
op|':'
op|'{'
string|"'allowvssprovider'"
op|':'
name|'str'
op|'('
name|'False'
op|')'
op|','
nl|'\n'
string|"'nova_uuid'"
op|':'
name|'str'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
op|'}'
op|','
nl|'\n'
string|"'PCI_bus'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'platform'"
op|':'
op|'{'
string|"'acpi'"
op|':'
string|"'true'"
op|','
string|"'apic'"
op|':'
string|"'true'"
op|','
string|"'pae'"
op|':'
string|"'true'"
op|','
nl|'\n'
string|"'viridian'"
op|':'
string|"'true'"
op|','
string|"'timeoffset'"
op|':'
string|"'0'"
op|'}'
op|','
nl|'\n'
string|"'PV_args'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'PV_bootloader'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'PV_bootloader_args'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'PV_kernel'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'PV_legacy_args'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'PV_ramdisk'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'recommendations'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'tags'"
op|':'
op|'['
op|']'
op|','
nl|'\n'
string|"'user_version'"
op|':'
string|"'0'"
op|','
nl|'\n'
string|"'VCPUs_at_startup'"
op|':'
name|'vcpus'
op|','
nl|'\n'
string|"'VCPUs_max'"
op|':'
name|'vcpus'
op|','
nl|'\n'
string|"'VCPUs_params'"
op|':'
op|'{'
op|'}'
op|','
nl|'\n'
string|"'xenstore_data'"
op|':'
op|'{'
op|'}'
op|'}'
newline|'\n'
nl|'\n'
comment|'# Complete VM configuration record according to the image type'
nl|'\n'
comment|'# non-raw/raw with PV kernel/raw in HVM mode'
nl|'\n'
name|'if'
name|'use_pv_kernel'
op|':'
newline|'\n'
indent|'        '
name|'rec'
op|'['
string|"'platform'"
op|']'
op|'['
string|"'nx'"
op|']'
op|'='
string|"'false'"
newline|'\n'
name|'if'
name|'instance'
op|'['
string|"'kernel_id'"
op|']'
op|':'
newline|'\n'
comment|'# 1. Kernel explicitly passed in, use that'
nl|'\n'
indent|'            '
name|'rec'
op|'['
string|"'PV_args'"
op|']'
op|'='
string|"'root=/dev/xvda1'"
newline|'\n'
name|'rec'
op|'['
string|"'PV_kernel'"
op|']'
op|'='
name|'kernel'
newline|'\n'
name|'rec'
op|'['
string|"'PV_ramdisk'"
op|']'
op|'='
name|'ramdisk'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# 2. Use kernel within the image'
nl|'\n'
indent|'            '
name|'rec'
op|'['
string|"'PV_bootloader'"
op|']'
op|'='
string|"'pygrub'"
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# 3. Using hardware virtualization'
nl|'\n'
indent|'        '
name|'rec'
op|'['
string|"'platform'"
op|']'
op|'['
string|"'nx'"
op|']'
op|'='
string|"'true'"
newline|'\n'
name|'rec'
op|'['
string|"'HVM_boot_params'"
op|']'
op|'='
op|'{'
string|"'order'"
op|':'
string|"'dc'"
op|'}'
newline|'\n'
name|'rec'
op|'['
string|"'HVM_boot_policy'"
op|']'
op|'='
string|"'BIOS order'"
newline|'\n'
nl|'\n'
dedent|''
name|'vm_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VM.create'"
op|','
name|'rec'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Created VM'"
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'vm_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|destroy_vm
dedent|''
name|'def'
name|'destroy_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Destroys a VM record."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VM.destroy'"
op|','
name|'vm_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|','
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'exc'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"VM destroyed"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|shutdown_vm
dedent|''
name|'def'
name|'shutdown_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'hard'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vm_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_record"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'state'
op|'='
name|'compile_info'
op|'('
name|'vm_rec'
op|')'
op|'['
string|"'state'"
op|']'
newline|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|'"VM already halted, skipping shutdown..."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Shutting down VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'hard'
op|':'
newline|'\n'
indent|'            '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VM.hard_shutdown'"
op|','
name|'vm_ref'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VM.clean_shutdown'"
op|','
name|'vm_ref'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|','
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'exc'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|ensure_free_mem
dedent|''
dedent|''
name|'def'
name|'ensure_free_mem'
op|'('
name|'session'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'inst_type_id'
op|'='
name|'instance'
op|'['
string|"'instance_type_id'"
op|']'
newline|'\n'
name|'instance_type'
op|'='
name|'instance_types'
op|'.'
name|'get_instance_type'
op|'('
name|'inst_type_id'
op|')'
newline|'\n'
name|'mem'
op|'='
name|'long'
op|'('
name|'instance_type'
op|'['
string|"'memory_mb'"
op|']'
op|')'
op|'*'
number|'1024'
op|'*'
number|'1024'
newline|'\n'
name|'host'
op|'='
name|'session'
op|'.'
name|'get_xenapi_host'
op|'('
op|')'
newline|'\n'
name|'host_free_mem'
op|'='
name|'long'
op|'('
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"host.compute_free_memory"'
op|','
nl|'\n'
name|'host'
op|')'
op|')'
newline|'\n'
name|'return'
name|'host_free_mem'
op|'>='
name|'mem'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|find_vbd_by_number
dedent|''
name|'def'
name|'find_vbd_by_number'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'number'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Get the VBD reference from the device number"""'
newline|'\n'
name|'vbd_refs'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_VBDs"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'if'
name|'vbd_refs'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'vbd_ref'
name|'in'
name|'vbd_refs'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'vbd_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VBD.get_record"'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'if'
name|'vbd_rec'
op|'['
string|"'userdevice'"
op|']'
op|'=='
name|'str'
op|'('
name|'number'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'vbd_ref'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|','
name|'exc'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'exc'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'raise'
name|'volume_utils'
op|'.'
name|'StorageError'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'VBD not found in instance %s'"
op|')'
op|'%'
name|'vm_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|unplug_vbd
dedent|''
name|'def'
name|'unplug_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Unplug VBD from VM"""'
newline|'\n'
comment|'# Call VBD.unplug on the given VBD, with a retry if we get'
nl|'\n'
comment|"# DEVICE_DETACH_REJECTED.  For reasons which we don't understand,"
nl|'\n'
comment|"# we're seeing the device still in use, even when all processes"
nl|'\n'
comment|'# using the device should be dead.'
nl|'\n'
name|'max_attempts'
op|'='
name|'FLAGS'
op|'.'
name|'xenapi_num_vbd_unplug_retries'
op|'+'
number|'1'
newline|'\n'
name|'for'
name|'num_attempt'
name|'in'
name|'xrange'
op|'('
number|'1'
op|','
name|'max_attempts'
op|'+'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VBD.unplug'"
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|','
name|'exc'
op|':'
newline|'\n'
indent|'            '
name|'err'
op|'='
name|'len'
op|'('
name|'exc'
op|'.'
name|'details'
op|')'
op|'>'
number|'0'
name|'and'
name|'exc'
op|'.'
name|'details'
op|'['
number|'0'
op|']'
newline|'\n'
name|'if'
name|'err'
op|'=='
string|"'DEVICE_ALREADY_DETACHED'"
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'VBD %s already detached'"
op|')'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'elif'
name|'err'
op|'=='
string|"'DEVICE_DETACH_REJECTED'"
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'VBD %(vbd_ref)s detach rejected, attempt'"
nl|'\n'
string|"' %(num_attempt)d/%(max_attempts)d'"
op|')'
op|','
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'exc'
op|')'
newline|'\n'
name|'raise'
name|'volume_utils'
op|'.'
name|'StorageError'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Unable to unplug VBD %s'"
op|')'
op|'%'
name|'vbd_ref'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'greenthread'
op|'.'
name|'sleep'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'raise'
name|'volume_utils'
op|'.'
name|'StorageError'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Reached maximum number of retries trying to unplug VBD %s'"
op|')'
nl|'\n'
op|'%'
name|'vbd_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|destroy_vbd
dedent|''
name|'def'
name|'destroy_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Destroy VBD from host database"""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VBD.destroy'"
op|','
name|'vbd_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|','
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'exc'
op|')'
newline|'\n'
name|'raise'
name|'volume_utils'
op|'.'
name|'StorageError'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Unable to destroy VBD %s'"
op|')'
op|'%'
name|'vbd_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|create_vbd
dedent|''
dedent|''
name|'def'
name|'create_vbd'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'vdi_ref'
op|','
name|'userdevice'
op|','
name|'vbd_type'
op|'='
string|"'disk'"
op|','
nl|'\n'
name|'read_only'
op|'='
name|'False'
op|','
name|'bootable'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Create a VBD record and returns its reference."""'
newline|'\n'
name|'vbd_rec'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'VM'"
op|']'
op|'='
name|'vm_ref'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'VDI'"
op|']'
op|'='
name|'vdi_ref'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'userdevice'"
op|']'
op|'='
name|'str'
op|'('
name|'userdevice'
op|')'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'bootable'"
op|']'
op|'='
name|'bootable'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'mode'"
op|']'
op|'='
name|'read_only'
name|'and'
string|"'RO'"
name|'or'
string|"'RW'"
newline|'\n'
name|'vbd_rec'
op|'['
string|"'type'"
op|']'
op|'='
name|'vbd_type'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'unpluggable'"
op|']'
op|'='
name|'True'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'empty'"
op|']'
op|'='
name|'False'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'other_config'"
op|']'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'qos_algorithm_type'"
op|']'
op|'='
string|"''"
newline|'\n'
name|'vbd_rec'
op|'['
string|"'qos_algorithm_params'"
op|']'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'qos_supported_algorithms'"
op|']'
op|'='
op|'['
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Creating %(vbd_type)s-type VBD for VM %(vm_ref)s,'"
nl|'\n'
string|"' VDI %(vdi_ref)s ... '"
op|')'
op|','
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
name|'vbd_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VBD.create'"
op|','
name|'vbd_rec'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Created VBD %(vbd_ref)s for VM %(vm_ref)s,'"
nl|'\n'
string|"' VDI %(vdi_ref)s.'"
op|')'
op|','
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
name|'return'
name|'vbd_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|destroy_vdi
dedent|''
name|'def'
name|'destroy_vdi'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.destroy'"
op|','
name|'vdi_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|','
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'exc'
op|')'
newline|'\n'
name|'raise'
name|'volume_utils'
op|'.'
name|'StorageError'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Unable to destroy VDI %s'"
op|')'
op|'%'
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|safe_destroy_vdis
dedent|''
dedent|''
name|'def'
name|'safe_destroy_vdis'
op|'('
name|'session'
op|','
name|'vdi_refs'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Destroys the requested VDIs, logging any StorageError exceptions."""'
newline|'\n'
name|'for'
name|'vdi_ref'
name|'in'
name|'vdi_refs'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'destroy_vdi'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'volume_utils'
op|'.'
name|'StorageError'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'exc'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|create_vdi
dedent|''
dedent|''
dedent|''
name|'def'
name|'create_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'disk_type'
op|','
name|'virtual_size'
op|','
nl|'\n'
name|'read_only'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Create a VDI record and returns its reference."""'
newline|'\n'
comment|'# create_vdi may be called simply while creating a volume'
nl|'\n'
comment|'# hence information about instance may or may not be present'
nl|'\n'
name|'otherconf'
op|'='
op|'{'
string|"'nova_disk_type'"
op|':'
name|'disk_type'
op|'}'
newline|'\n'
name|'if'
name|'instance'
op|':'
newline|'\n'
indent|'        '
name|'otherconf'
op|'['
string|"'nova_instance_uuid'"
op|']'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
dedent|''
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.create"'
op|','
nl|'\n'
op|'{'
string|"'name_label'"
op|':'
name|'name_label'
op|','
nl|'\n'
string|"'name_description'"
op|':'
name|'disk_type'
op|','
nl|'\n'
string|"'SR'"
op|':'
name|'sr_ref'
op|','
nl|'\n'
string|"'virtual_size'"
op|':'
name|'str'
op|'('
name|'virtual_size'
op|')'
op|','
nl|'\n'
string|"'type'"
op|':'
string|"'User'"
op|','
nl|'\n'
string|"'sharable'"
op|':'
name|'False'
op|','
nl|'\n'
string|"'read_only'"
op|':'
name|'read_only'
op|','
nl|'\n'
string|"'xenstore_data'"
op|':'
op|'{'
op|'}'
op|','
nl|'\n'
string|"'other_config'"
op|':'
name|'otherconf'
op|','
nl|'\n'
string|"'sm_config'"
op|':'
op|'{'
op|'}'
op|','
nl|'\n'
string|"'tags'"
op|':'
op|'['
op|']'
op|'}'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Created VDI %(vdi_ref)s (%(name_label)s,'"
nl|'\n'
string|"' %(virtual_size)s, %(read_only)s) on %(sr_ref)s.'"
op|')'
op|','
nl|'\n'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
name|'return'
name|'vdi_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_vdis_for_boot_from_vol
dedent|''
name|'def'
name|'get_vdis_for_boot_from_vol'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'dev_params'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vdis'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'sr_uuid'
op|'='
name|'dev_params'
op|'['
string|"'sr_uuid'"
op|']'
newline|'\n'
name|'sr_ref'
op|'='
name|'volume_utils'
op|'.'
name|'find_sr_by_uuid'
op|'('
name|'session'
op|','
nl|'\n'
name|'sr_uuid'
op|')'
newline|'\n'
name|'if'
name|'sr_ref'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"SR.scan"'
op|','
name|'sr_ref'
op|')'
newline|'\n'
name|'return'
op|'{'
string|"'root'"
op|':'
name|'dict'
op|'('
name|'uuid'
op|'='
name|'dev_params'
op|'['
string|"'vdi_uuid'"
op|']'
op|','
nl|'\n'
name|'file'
op|'='
name|'None'
op|')'
op|'}'
newline|'\n'
dedent|''
name|'return'
name|'vdis'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_volume_in_mapping
dedent|''
name|'def'
name|'_volume_in_mapping'
op|'('
name|'mount_device'
op|','
name|'block_device_info'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'block_device_list'
op|'='
op|'['
name|'block_device'
op|'.'
name|'strip_prefix'
op|'('
name|'vol'
op|'['
string|"'mount_device'"
op|']'
op|')'
nl|'\n'
name|'for'
name|'vol'
name|'in'
nl|'\n'
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
op|']'
newline|'\n'
name|'swap'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_swap'
op|'('
name|'block_device_info'
op|')'
newline|'\n'
name|'if'
name|'driver'
op|'.'
name|'swap_is_usable'
op|'('
name|'swap'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'swap_dev'
op|'='
name|'swap'
op|'['
string|"'device_name'"
op|']'
newline|'\n'
name|'block_device_list'
op|'.'
name|'append'
op|'('
name|'block_device'
op|'.'
name|'strip_prefix'
op|'('
name|'swap_dev'
op|')'
op|')'
newline|'\n'
dedent|''
name|'block_device_list'
op|'+='
op|'['
name|'block_device'
op|'.'
name|'strip_prefix'
op|'('
name|'ephemeral'
op|'['
string|"'device_name'"
op|']'
op|')'
nl|'\n'
name|'for'
name|'ephemeral'
name|'in'
nl|'\n'
name|'driver'
op|'.'
name|'block_device_info_get_ephemerals'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"block_device_list %s"'
op|')'
op|','
name|'block_device_list'
op|')'
newline|'\n'
name|'return'
name|'block_device'
op|'.'
name|'strip_prefix'
op|'('
name|'mount_device'
op|')'
name|'in'
name|'block_device_list'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_vdis_for_instance
dedent|''
name|'def'
name|'get_vdis_for_instance'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'image'
op|','
nl|'\n'
name|'image_type'
op|','
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'block_device_info'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"block device info: %s"'
op|')'
op|','
name|'block_device_info'
op|')'
newline|'\n'
name|'rootdev'
op|'='
name|'block_device_info'
op|'['
string|"'root_device_name'"
op|']'
newline|'\n'
name|'if'
name|'_volume_in_mapping'
op|'('
name|'rootdev'
op|','
name|'block_device_info'
op|')'
op|':'
newline|'\n'
comment|'# call function to return the vdi in connection info of block'
nl|'\n'
comment|'# device.'
nl|'\n'
comment|'# make it a point to return from here.'
nl|'\n'
indent|'            '
name|'bdm_root_dev'
op|'='
name|'block_device_info'
op|'['
string|"'block_device_mapping'"
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
name|'dev_params'
op|'='
name|'bdm_root_dev'
op|'['
string|"'connection_info'"
op|']'
op|'['
string|"'data'"
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'dev_params'
op|')'
newline|'\n'
name|'return'
name|'get_vdis_for_boot_from_vol'
op|'('
name|'session'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'dev_params'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'_create_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'image'
op|','
nl|'\n'
name|'image_type'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
op|'@'
name|'contextlib'
op|'.'
name|'contextmanager'
newline|'\n'
DECL|function|_dummy_vm
name|'def'
name|'_dummy_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vdi_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""This creates a temporary VM so that we can snapshot a VDI.\n\n    VDI\'s can\'t be snapshotted directly since the API expects a `vm_ref`. To\n    work around this, we need to create a temporary VM and then map the VDI to\n    the VM using a temporary VBD.\n    """'
newline|'\n'
name|'name_label'
op|'='
string|'"dummy"'
newline|'\n'
name|'vm_ref'
op|'='
name|'create_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'vbd_ref'
op|'='
name|'create_vbd'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'vdi_ref'
op|','
string|"'autodetect'"
op|','
nl|'\n'
name|'read_only'
op|'='
name|'True'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'yield'
name|'vm_ref'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'destroy_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'volume_utils'
op|'.'
name|'StorageError'
op|':'
newline|'\n'
comment|'# destroy_vbd() will log error'
nl|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'        '
name|'destroy_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_safe_copy_vdi
dedent|''
dedent|''
name|'def'
name|'_safe_copy_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
name|'vdi_to_copy_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Copy a VDI and return the new VDIs reference.\n\n    This function differs from the XenAPI `VDI.copy` call in that the copy is\n    atomic and isolated, meaning we don\'t see half-downloaded images. It\n    accomplishes this by copying the VDI\'s into a temporary directory and then\n    atomically renaming them into the SR when the copy is completed.\n\n    The correct long term solution is to fix `VDI.copy` so that it is atomic\n    and isolated.\n    """'
newline|'\n'
name|'with'
name|'_dummy_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vdi_to_copy_ref'
op|')'
name|'as'
name|'vm_ref'
op|':'
newline|'\n'
indent|'        '
name|'label'
op|'='
string|'"snapshot"'
newline|'\n'
name|'with'
name|'snapshot_attached_here'
op|'('
nl|'\n'
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'label'
op|')'
name|'as'
name|'vdi_uuids'
op|':'
newline|'\n'
indent|'            '
name|'imported_vhds'
op|'='
name|'session'
op|'.'
name|'call_plugin_serialized'
op|'('
nl|'\n'
string|"'workarounds'"
op|','
string|"'safe_copy_vdis'"
op|','
name|'sr_path'
op|'='
name|'get_sr_path'
op|'('
name|'session'
op|')'
op|','
nl|'\n'
name|'vdi_uuids'
op|'='
name|'vdi_uuids'
op|','
name|'uuid_stack'
op|'='
name|'_make_uuid_stack'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'root_uuid'
op|'='
name|'imported_vhds'
op|'['
string|"'root'"
op|']'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
nl|'\n'
comment|'# TODO(sirp): for safety, we should probably re-scan the SR after every'
nl|'\n'
comment|'# call to a dom0 plugin, since there is a possibility that the underlying'
nl|'\n'
comment|'# VHDs changed'
nl|'\n'
name|'scan_default_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_by_uuid'"
op|','
name|'root_uuid'
op|')'
newline|'\n'
name|'return'
name|'vdi_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_clone_vdi
dedent|''
name|'def'
name|'_clone_vdi'
op|'('
name|'session'
op|','
name|'vdi_to_clone_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Clones a VDI and return the new VDIs reference."""'
newline|'\n'
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.clone'"
op|','
name|'vdi_to_clone_ref'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Cloned VDI %(vdi_ref)s from VDI '"
nl|'\n'
string|"'%(vdi_to_clone_ref)s'"
op|')'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
name|'return'
name|'vdi_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|set_vdi_name
dedent|''
name|'def'
name|'set_vdi_name'
op|'('
name|'session'
op|','
name|'vdi_uuid'
op|','
name|'label'
op|','
name|'description'
op|','
name|'vdi_ref'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vdi_ref'
op|'='
name|'vdi_ref'
name|'or'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_by_uuid'"
op|','
name|'vdi_uuid'
op|')'
newline|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.set_name_label'"
op|','
name|'vdi_ref'
op|','
name|'label'
op|')'
newline|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.set_name_description'"
op|','
name|'vdi_ref'
op|','
name|'description'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_vdi_for_vm_safely
dedent|''
name|'def'
name|'get_vdi_for_vm_safely'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Retrieves the primary VDI for a VM"""'
newline|'\n'
name|'vbd_refs'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_VBDs"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'for'
name|'vbd'
name|'in'
name|'vbd_refs'
op|':'
newline|'\n'
indent|'        '
name|'vbd_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VBD.get_record"'
op|','
name|'vbd'
op|')'
newline|'\n'
comment|'# Convention dictates the primary VDI will be userdevice 0'
nl|'\n'
name|'if'
name|'vbd_rec'
op|'['
string|"'userdevice'"
op|']'
op|'=='
string|"'0'"
op|':'
newline|'\n'
indent|'            '
name|'vdi_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_record"'
op|','
name|'vbd_rec'
op|'['
string|"'VDI'"
op|']'
op|')'
newline|'\n'
name|'return'
name|'vbd_rec'
op|'['
string|"'VDI'"
op|']'
op|','
name|'vdi_rec'
newline|'\n'
dedent|''
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'_'
op|'('
string|'"No primary VDI found for %(vm_ref)s"'
op|')'
nl|'\n'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
op|'@'
name|'contextlib'
op|'.'
name|'contextmanager'
newline|'\n'
DECL|function|snapshot_attached_here
name|'def'
name|'snapshot_attached_here'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'label'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Starting snapshot for VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# Memorize the original_parent_uuid so we can poll for coalesce'
nl|'\n'
name|'vm_vdi_ref'
op|','
name|'vm_vdi_rec'
op|'='
name|'get_vdi_for_vm_safely'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'original_parent_uuid'
op|'='
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'vm_vdi_ref'
op|')'
newline|'\n'
nl|'\n'
name|'template_vm_ref'
op|','
name|'template_vdi_uuid'
op|'='
name|'_create_snapshot'
op|'('
nl|'\n'
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'label'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'sr_ref'
op|'='
name|'vm_vdi_rec'
op|'['
string|'"SR"'
op|']'
newline|'\n'
name|'parent_uuid'
op|','
name|'base_uuid'
op|'='
name|'_wait_for_vhd_coalesce'
op|'('
nl|'\n'
name|'session'
op|','
name|'instance'
op|','
name|'sr_ref'
op|','
name|'vm_vdi_ref'
op|','
name|'original_parent_uuid'
op|')'
newline|'\n'
nl|'\n'
name|'vdi_uuids'
op|'='
op|'['
name|'vdi_rec'
op|'['
string|"'uuid'"
op|']'
name|'for'
name|'vdi_rec'
name|'in'
nl|'\n'
name|'_walk_vdi_chain'
op|'('
name|'session'
op|','
name|'template_vdi_uuid'
op|')'
op|']'
newline|'\n'
nl|'\n'
name|'yield'
name|'vdi_uuids'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'        '
name|'_destroy_snapshot'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'template_vm_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_create_snapshot
dedent|''
dedent|''
name|'def'
name|'_create_snapshot'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'label'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'template_vm_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VM.snapshot'"
op|','
name|'vm_ref'
op|','
name|'label'
op|')'
newline|'\n'
name|'template_vdi_rec'
op|'='
name|'get_vdi_for_vm_safely'
op|'('
name|'session'
op|','
name|'template_vm_ref'
op|')'
op|'['
number|'1'
op|']'
newline|'\n'
name|'template_vdi_uuid'
op|'='
name|'template_vdi_rec'
op|'['
string|'"uuid"'
op|']'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Created snapshot %(template_vdi_uuid)s with label"'
nl|'\n'
string|'" \'%(label)s\'"'
op|')'
op|','
name|'locals'
op|'('
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'template_vm_ref'
op|','
name|'template_vdi_uuid'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_destroy_snapshot
dedent|''
name|'def'
name|'_destroy_snapshot'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vdi_refs'
op|'='
name|'lookup_vm_vdis'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'safe_destroy_vdis'
op|'('
name|'session'
op|','
name|'vdi_refs'
op|')'
newline|'\n'
nl|'\n'
name|'destroy_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_sr_path
dedent|''
name|'def'
name|'get_sr_path'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the path to our storage repository\n\n    This is used when we\'re dealing with VHDs directly, either by taking\n    snapshots or by restoring an image in the DISK_VHD format.\n    """'
newline|'\n'
name|'sr_ref'
op|'='
name|'safe_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'sr_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"SR.get_record"'
op|','
name|'sr_ref'
op|')'
newline|'\n'
name|'sr_uuid'
op|'='
name|'sr_rec'
op|'['
string|'"uuid"'
op|']'
newline|'\n'
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'FLAGS'
op|'.'
name|'xenapi_sr_base_path'
op|','
name|'sr_uuid'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|destroy_cached_images
dedent|''
name|'def'
name|'destroy_cached_images'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'all_cached'
op|'='
name|'False'
op|','
name|'dry_run'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Destroy used or unused cached images.\n\n    A cached image that is being used by at least one VM is said to be \'used\'.\n\n    In the case of an \'unused\' image, the cached image will be the only\n    descendent of the base-copy. So when we delete the cached-image, the\n    refcount will drop to zero and XenServer will automatically destroy the\n    base-copy for us.\n\n    The default behavior of this function is to destroy only \'unused\' cached\n    images. To destroy all cached images, use the `all_cached=True` kwarg.\n    """'
newline|'\n'
name|'cached_images'
op|'='
name|'_find_cached_images'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
newline|'\n'
name|'destroyed'
op|'='
name|'set'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|destroy_cached_vdi
name|'def'
name|'destroy_cached_vdi'
op|'('
name|'vdi_uuid'
op|','
name|'vdi_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Destroying cached VDI \'%(vdi_uuid)s\'"'
op|')'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'dry_run'
op|':'
newline|'\n'
indent|'            '
name|'destroy_vdi'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
dedent|''
name|'destroyed'
op|'.'
name|'add'
op|'('
name|'vdi_uuid'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'vdi_ref'
name|'in'
name|'cached_images'
op|'.'
name|'values'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'vdi_uuid'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_uuid'"
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'all_cached'
op|':'
newline|'\n'
indent|'            '
name|'destroy_cached_vdi'
op|'('
name|'vdi_uuid'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
comment|'# Unused-Only: Search for siblings'
nl|'\n'
nl|'\n'
comment|'# Chain length greater than two implies a VM must be holding a ref to'
nl|'\n'
comment|'# the base-copy (otherwise it would have coalesced), so consider this'
nl|'\n'
comment|'# cached image used.'
nl|'\n'
dedent|''
name|'chain'
op|'='
name|'list'
op|'('
name|'_walk_vdi_chain'
op|'('
name|'session'
op|','
name|'vdi_uuid'
op|')'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'chain'
op|')'
op|'>'
number|'2'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
dedent|''
name|'elif'
name|'len'
op|'('
name|'chain'
op|')'
op|'=='
number|'2'
op|':'
newline|'\n'
comment|'# Siblings imply cached image is used'
nl|'\n'
indent|'            '
name|'root_vdi_rec'
op|'='
name|'chain'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
name|'children'
op|'='
name|'_child_vhds'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'root_vdi_rec'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'children'
op|')'
op|'>'
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'destroy_cached_vdi'
op|'('
name|'vdi_uuid'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'destroyed'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_find_cached_images
dedent|''
name|'def'
name|'_find_cached_images'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return a dict(uuid=vdi_ref) representing all cached images."""'
newline|'\n'
name|'cached_images'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'vdi_ref'
op|','
name|'vdi_rec'
name|'in'
name|'_get_all_vdis_in_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'image_id'
op|'='
name|'vdi_rec'
op|'['
string|"'other_config'"
op|']'
op|'['
string|"'image-id'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'cached_images'
op|'['
name|'image_id'
op|']'
op|'='
name|'vdi_ref'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'cached_images'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_find_cached_image
dedent|''
name|'def'
name|'_find_cached_image'
op|'('
name|'session'
op|','
name|'image_id'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Returns the vdi-ref of the cached image."""'
newline|'\n'
name|'cached_images'
op|'='
name|'_find_cached_images'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
newline|'\n'
name|'return'
name|'cached_images'
op|'.'
name|'get'
op|'('
name|'image_id'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|upload_image
dedent|''
name|'def'
name|'upload_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'vdi_uuids'
op|','
name|'image_id'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Requests that the Glance plugin bundle the specified VDIs and\n    push them into Glance using the specified human-friendly name.\n    """'
newline|'\n'
comment|'# NOTE(sirp): Currently we only support uploading images as VHD, there'
nl|'\n'
comment|'# is no RAW equivalent (yet)'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Asking xapi to upload %(vdi_uuids)s as"'
nl|'\n'
string|'" ID %(image_id)s"'
op|')'
op|','
name|'locals'
op|'('
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'glance_api_servers'
op|'='
name|'glance'
op|'.'
name|'get_api_servers'
op|'('
op|')'
newline|'\n'
name|'glance_host'
op|','
name|'glance_port'
op|','
name|'glance_use_ssl'
op|'='
name|'glance_api_servers'
op|'.'
name|'next'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(sirp): this inherit-image-property code should probably go in'
nl|'\n'
comment|'# nova/compute/manager so it can be shared across hypervisors'
nl|'\n'
name|'sys_meta'
op|'='
name|'db'
op|'.'
name|'instance_system_metadata_get'
op|'('
name|'context'
op|','
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
name|'properties'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'prefix'
op|'='
string|"'image_'"
newline|'\n'
name|'for'
name|'key'
op|','
name|'value'
name|'in'
name|'sys_meta'
op|'.'
name|'iteritems'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'key'
op|'.'
name|'startswith'
op|'('
name|'prefix'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'key'
op|'='
name|'key'
op|'['
name|'len'
op|'('
name|'prefix'
op|')'
op|':'
op|']'
newline|'\n'
dedent|''
name|'if'
name|'key'
name|'in'
name|'FLAGS'
op|'.'
name|'non_inheritable_image_properties'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
dedent|''
name|'properties'
op|'['
name|'key'
op|']'
op|'='
name|'value'
newline|'\n'
dedent|''
name|'properties'
op|'['
string|"'auto_disk_config'"
op|']'
op|'='
name|'instance'
op|'['
string|"'auto_disk_config'"
op|']'
newline|'\n'
name|'properties'
op|'['
string|"'os_type'"
op|']'
op|'='
name|'instance'
op|'['
string|"'os_type'"
op|']'
name|'or'
name|'FLAGS'
op|'.'
name|'default_os_type'
newline|'\n'
nl|'\n'
name|'params'
op|'='
op|'{'
string|"'vdi_uuids'"
op|':'
name|'vdi_uuids'
op|','
nl|'\n'
string|"'image_id'"
op|':'
name|'image_id'
op|','
nl|'\n'
string|"'glance_host'"
op|':'
name|'glance_host'
op|','
nl|'\n'
string|"'glance_port'"
op|':'
name|'glance_port'
op|','
nl|'\n'
string|"'glance_use_ssl'"
op|':'
name|'glance_use_ssl'
op|','
nl|'\n'
string|"'sr_path'"
op|':'
name|'get_sr_path'
op|'('
name|'session'
op|')'
op|','
nl|'\n'
string|"'auth_token'"
op|':'
name|'getattr'
op|'('
name|'context'
op|','
string|"'auth_token'"
op|','
name|'None'
op|')'
op|','
nl|'\n'
string|"'properties'"
op|':'
name|'properties'
op|'}'
newline|'\n'
nl|'\n'
name|'session'
op|'.'
name|'call_plugin_serialized'
op|'('
string|"'glance'"
op|','
string|"'upload_vhd'"
op|','
op|'**'
name|'params'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|resize_disk
dedent|''
name|'def'
name|'resize_disk'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vdi_ref'
op|','
name|'instance_type'
op|')'
op|':'
newline|'\n'
comment|'# Copy VDI over to something we can resize'
nl|'\n'
comment|'# NOTE(jerdfelt): Would be nice to just set vdi_ref to read/write'
nl|'\n'
indent|'    '
name|'sr_ref'
op|'='
name|'safe_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'copy_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.copy'"
op|','
name|'vdi_ref'
op|','
name|'sr_ref'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# Resize partition and filesystem down'
nl|'\n'
indent|'        '
name|'auto_configure_disk'
op|'('
name|'session'
op|','
name|'copy_ref'
op|','
name|'instance_type'
op|'['
string|"'root_gb'"
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Create new VDI'
nl|'\n'
name|'vdi_size'
op|'='
name|'instance_type'
op|'['
string|"'root_gb'"
op|']'
op|'*'
number|'1024'
op|'*'
number|'1024'
op|'*'
number|'1024'
newline|'\n'
comment|'# NOTE(johannes): No resizing allowed for rescue instances, so'
nl|'\n'
comment|"# using instance['name'] is safe here"
nl|'\n'
name|'new_ref'
op|'='
name|'create_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
name|'instance'
op|'['
string|"'name'"
op|']'
op|','
nl|'\n'
string|"'root'"
op|','
name|'vdi_size'
op|')'
newline|'\n'
nl|'\n'
name|'new_uuid'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_uuid'"
op|','
name|'new_ref'
op|')'
newline|'\n'
nl|'\n'
comment|'# Manually copy contents over'
nl|'\n'
name|'virtual_size'
op|'='
name|'instance_type'
op|'['
string|"'root_gb'"
op|']'
op|'*'
number|'1024'
op|'*'
number|'1024'
op|'*'
number|'1024'
newline|'\n'
name|'_copy_partition'
op|'('
name|'session'
op|','
name|'copy_ref'
op|','
name|'new_ref'
op|','
number|'1'
op|','
name|'virtual_size'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'new_ref'
op|','
name|'new_uuid'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'        '
name|'destroy_vdi'
op|'('
name|'session'
op|','
name|'copy_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|auto_configure_disk
dedent|''
dedent|''
name|'def'
name|'auto_configure_disk'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'new_gb'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Partition and resize FS to match the size specified by\n    instance_types.root_gb.\n\n    This is a fail-safe to prevent accidentally destroying data on a disk\n    erroneously marked as auto_disk_config=True.\n\n    The criteria for allowing resize are:\n\n        1. \'auto_disk_config\' must be true for the instance (and image).\n           (If we\'ve made it here, then auto_disk_config=True.)\n\n        2. The disk must have only one partition.\n\n        3. The file-system on the one partition must be ext3 or ext4.\n    """'
newline|'\n'
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
name|'as'
name|'dev'
op|':'
newline|'\n'
indent|'        '
name|'partitions'
op|'='
name|'_get_partitions'
op|'('
name|'dev'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'partitions'
op|')'
op|'!='
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'_num'
op|','
name|'start'
op|','
name|'old_sectors'
op|','
name|'ptype'
op|'='
name|'partitions'
op|'['
number|'0'
op|']'
newline|'\n'
name|'if'
name|'ptype'
name|'in'
op|'('
string|"'ext3'"
op|','
string|"'ext4'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'new_sectors'
op|'='
name|'new_gb'
op|'*'
number|'1024'
op|'*'
number|'1024'
op|'*'
number|'1024'
op|'/'
name|'SECTOR_SIZE'
newline|'\n'
name|'_resize_part_and_fs'
op|'('
name|'dev'
op|','
name|'start'
op|','
name|'old_sectors'
op|','
name|'new_sectors'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_generate_disk
dedent|''
dedent|''
dedent|''
name|'def'
name|'_generate_disk'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'userdevice'
op|','
name|'name_label'
op|','
nl|'\n'
name|'disk_type'
op|','
name|'size_mb'
op|','
name|'fs_type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Steps to programmatically generate a disk:\n\n        1. Create VDI of desired size\n\n        2. Attach VDI to compute worker\n\n        3. Create partition\n\n        4. Create VBD between instance VM and VDI\n    """'
newline|'\n'
comment|'# 1. Create VDI'
nl|'\n'
name|'sr_ref'
op|'='
name|'safe_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'ONE_MEG'
op|'='
number|'1024'
op|'*'
number|'1024'
newline|'\n'
name|'virtual_size'
op|'='
name|'size_mb'
op|'*'
name|'ONE_MEG'
newline|'\n'
name|'vdi_ref'
op|'='
name|'create_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'disk_type'
op|','
nl|'\n'
name|'virtual_size'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# 2. Attach VDI to compute worker (VBD hotplug)'
nl|'\n'
indent|'        '
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
name|'as'
name|'dev'
op|':'
newline|'\n'
comment|'# 3. Create partition'
nl|'\n'
indent|'            '
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'parted'"
op|','
string|"'--script'"
op|','
name|'dev_path'
op|','
nl|'\n'
string|"'mklabel'"
op|','
string|"'msdos'"
op|','
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
name|'partition_start'
op|'='
number|'0'
newline|'\n'
name|'partition_end'
op|'='
name|'size_mb'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'parted'"
op|','
string|"'--script'"
op|','
name|'dev_path'
op|','
nl|'\n'
string|"'mkpart'"
op|','
string|"'primary'"
op|','
nl|'\n'
name|'str'
op|'('
name|'partition_start'
op|')'
op|','
nl|'\n'
name|'str'
op|'('
name|'partition_end'
op|')'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
name|'partition_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|','
name|'partition'
op|'='
number|'1'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'fs_type'
op|'=='
string|"'linux-swap'"
op|':'
newline|'\n'
indent|'                '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mkswap'"
op|','
name|'partition_path'
op|','
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'fs_type'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mkfs'"
op|','
string|"'-t'"
op|','
name|'fs_type'
op|','
name|'partition_path'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
comment|'# 4. Create VBD between instance VM and swap VDI'
nl|'\n'
dedent|''
dedent|''
name|'create_vbd'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'vdi_ref'
op|','
name|'userdevice'
op|','
name|'bootable'
op|'='
name|'False'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'destroy_vdi'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|generate_swap
dedent|''
dedent|''
dedent|''
name|'def'
name|'generate_swap'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'userdevice'
op|','
name|'name_label'
op|','
name|'swap_mb'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(jk0): We use a FAT32 filesystem for the Windows swap'
nl|'\n'
comment|'# partition because that is what parted supports.'
nl|'\n'
indent|'    '
name|'is_windows'
op|'='
name|'instance'
op|'['
string|"'os_type'"
op|']'
op|'=='
string|'"windows"'
newline|'\n'
name|'fs_type'
op|'='
string|'"vfat"'
name|'if'
name|'is_windows'
name|'else'
string|'"linux-swap"'
newline|'\n'
nl|'\n'
name|'_generate_disk'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'userdevice'
op|','
name|'name_label'
op|','
nl|'\n'
string|"'swap'"
op|','
name|'swap_mb'
op|','
name|'fs_type'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|generate_ephemeral
dedent|''
name|'def'
name|'generate_ephemeral'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'userdevice'
op|','
name|'name_label'
op|','
nl|'\n'
name|'size_gb'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'_generate_disk'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'userdevice'
op|','
name|'name_label'
op|','
nl|'\n'
string|"'ephemeral'"
op|','
name|'size_gb'
op|'*'
number|'1024'
op|','
nl|'\n'
name|'FLAGS'
op|'.'
name|'default_ephemeral_format'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|create_kernel_image
dedent|''
name|'def'
name|'create_kernel_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'image_id'
op|','
nl|'\n'
name|'image_type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Creates kernel/ramdisk file from the image stored in the cache.\n    If the image is not present in the cache, it streams it from glance.\n\n    Returns: A list of dictionaries that describe VDIs\n    """'
newline|'\n'
name|'filename'
op|'='
string|'""'
newline|'\n'
name|'if'
name|'FLAGS'
op|'.'
name|'cache_images'
op|':'
newline|'\n'
indent|'        '
name|'args'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'args'
op|'['
string|"'cached-image'"
op|']'
op|'='
name|'image_id'
newline|'\n'
name|'args'
op|'['
string|"'new-image-uuid'"
op|']'
op|'='
name|'str'
op|'('
name|'uuid'
op|'.'
name|'uuid4'
op|'('
op|')'
op|')'
newline|'\n'
name|'filename'
op|'='
name|'session'
op|'.'
name|'call_plugin'
op|'('
string|"'kernel'"
op|','
string|"'create_kernel_ramdisk'"
op|','
name|'args'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'filename'
op|'=='
string|'""'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'_fetch_disk_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_id'
op|','
name|'image_type'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'vdi_type'
op|'='
name|'ImageType'
op|'.'
name|'to_string'
op|'('
name|'image_type'
op|')'
newline|'\n'
name|'return'
op|'{'
name|'vdi_type'
op|':'
name|'dict'
op|'('
name|'uuid'
op|'='
name|'None'
op|','
name|'file'
op|'='
name|'filename'
op|')'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|destroy_kernel_ramdisk
dedent|''
dedent|''
name|'def'
name|'destroy_kernel_ramdisk'
op|'('
name|'session'
op|','
name|'kernel'
op|','
name|'ramdisk'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'args'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'if'
name|'kernel'
op|':'
newline|'\n'
indent|'        '
name|'args'
op|'['
string|"'kernel-file'"
op|']'
op|'='
name|'kernel'
newline|'\n'
dedent|''
name|'if'
name|'ramdisk'
op|':'
newline|'\n'
indent|'        '
name|'args'
op|'['
string|"'ramdisk-file'"
op|']'
op|'='
name|'ramdisk'
newline|'\n'
dedent|''
name|'session'
op|'.'
name|'call_plugin'
op|'('
string|"'kernel'"
op|','
string|"'remove_kernel_ramdisk'"
op|','
name|'args'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_create_cached_image
dedent|''
name|'def'
name|'_create_cached_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_id'
op|','
name|'image_type'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'sr_ref'
op|'='
name|'safe_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'sr_type'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'SR.get_record'"
op|','
name|'sr_ref'
op|')'
op|'['
string|'"type"'
op|']'
newline|'\n'
name|'vdis'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
name|'if'
name|'FLAGS'
op|'.'
name|'use_cow_images'
name|'and'
name|'sr_type'
op|'!='
string|'"ext"'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_'
op|'('
string|'"Fast cloning is only supported on default local SR "'
nl|'\n'
string|'"of type ext. SR on this system was found to be of "'
nl|'\n'
string|'"type %(sr_type)s. Ignoring the cow flag."'
op|')'
nl|'\n'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'root_vdi_ref'
op|'='
name|'_find_cached_image'
op|'('
name|'session'
op|','
name|'image_id'
op|','
name|'sr_ref'
op|')'
newline|'\n'
name|'if'
name|'root_vdi_ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'vdis'
op|'='
name|'_fetch_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_id'
op|','
name|'image_type'
op|')'
newline|'\n'
name|'root_vdi'
op|'='
name|'vdis'
op|'['
string|"'root'"
op|']'
newline|'\n'
name|'root_vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_by_uuid'"
op|','
nl|'\n'
name|'root_vdi'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
name|'set_vdi_name'
op|'('
name|'session'
op|','
name|'root_vdi'
op|'['
string|"'uuid'"
op|']'
op|','
string|"'Glance Image %s'"
op|'%'
name|'image_id'
op|','
nl|'\n'
string|"'root'"
op|','
name|'vdi_ref'
op|'='
name|'root_vdi_ref'
op|')'
newline|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.add_to_other_config'"
op|','
nl|'\n'
name|'root_vdi_ref'
op|','
string|"'image-id'"
op|','
name|'str'
op|'('
name|'image_id'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'swap_vdi'
op|'='
name|'vdis'
op|'.'
name|'get'
op|'('
string|"'swap'"
op|')'
newline|'\n'
name|'if'
name|'swap_vdi'
op|':'
newline|'\n'
indent|'            '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
nl|'\n'
string|"'VDI.add_to_other_config'"
op|','
name|'root_vdi_ref'
op|','
string|"'swap-disk'"
op|','
nl|'\n'
name|'str'
op|'('
name|'swap_vdi'
op|'['
string|"'uuid'"
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'FLAGS'
op|'.'
name|'use_cow_images'
name|'and'
name|'sr_type'
op|'=='
string|"'ext'"
op|':'
newline|'\n'
indent|'        '
name|'new_vdi_ref'
op|'='
name|'_clone_vdi'
op|'('
name|'session'
op|','
name|'root_vdi_ref'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'new_vdi_ref'
op|'='
name|'_safe_copy_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
name|'root_vdi_ref'
op|')'
newline|'\n'
nl|'\n'
comment|'# Set the name label for the image we just created and remove image id'
nl|'\n'
comment|'# field from other-config.'
nl|'\n'
dedent|''
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.remove_from_other_config'"
op|','
nl|'\n'
name|'new_vdi_ref'
op|','
string|"'image-id'"
op|')'
newline|'\n'
nl|'\n'
name|'vdi_type'
op|'='
op|'('
string|'"root"'
name|'if'
name|'image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK_VHD'
nl|'\n'
name|'else'
name|'ImageType'
op|'.'
name|'to_string'
op|'('
name|'image_type'
op|')'
op|')'
newline|'\n'
name|'vdi_uuid'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_uuid'"
op|','
name|'new_vdi_ref'
op|')'
newline|'\n'
name|'vdis'
op|'['
name|'vdi_type'
op|']'
op|'='
name|'dict'
op|'('
name|'uuid'
op|'='
name|'vdi_uuid'
op|','
name|'file'
op|'='
name|'None'
op|')'
newline|'\n'
nl|'\n'
comment|'# Create a swap disk if the glance image had one associated with it.'
nl|'\n'
name|'vdi_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_record'"
op|','
name|'root_vdi_ref'
op|')'
newline|'\n'
name|'if'
string|"'swap-disk'"
name|'in'
name|'vdi_rec'
op|'['
string|"'other_config'"
op|']'
op|':'
newline|'\n'
indent|'        '
name|'swap_disk_uuid'
op|'='
name|'vdi_rec'
op|'['
string|"'other_config'"
op|']'
op|'['
string|"'swap-disk'"
op|']'
newline|'\n'
name|'swap_vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_by_uuid'"
op|','
nl|'\n'
name|'swap_disk_uuid'
op|')'
newline|'\n'
name|'new_swap_vdi_ref'
op|'='
name|'_safe_copy_vdi'
op|'('
nl|'\n'
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
name|'swap_vdi_ref'
op|')'
newline|'\n'
name|'new_swap_vdi_uuid'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_uuid'"
op|','
nl|'\n'
name|'new_swap_vdi_ref'
op|')'
newline|'\n'
name|'vdis'
op|'['
string|"'swap'"
op|']'
op|'='
name|'dict'
op|'('
name|'uuid'
op|'='
name|'new_swap_vdi_uuid'
op|','
name|'file'
op|'='
name|'None'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'vdis'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_create_image
dedent|''
name|'def'
name|'_create_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'image_id'
op|','
nl|'\n'
name|'image_type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Creates VDI from the image stored in the local cache. If the image\n    is not present in the cache, it streams it from glance.\n\n    Returns: A list of dictionaries that describe VDIs\n    """'
newline|'\n'
name|'cache_images'
op|'='
name|'FLAGS'
op|'.'
name|'cache_images'
op|'.'
name|'lower'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Deterimine if the image is cacheable'
nl|'\n'
name|'if'
name|'image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK_ISO'
op|':'
newline|'\n'
indent|'        '
name|'cache'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'elif'
name|'cache_images'
op|'=='
string|"'all'"
op|':'
newline|'\n'
indent|'        '
name|'cache'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'elif'
name|'cache_images'
op|'=='
string|"'some'"
op|':'
newline|'\n'
comment|'# FIXME(sirp): This should be eager loaded like instance metadata'
nl|'\n'
indent|'        '
name|'sys_meta'
op|'='
name|'db'
op|'.'
name|'instance_system_metadata_get'
op|'('
name|'context'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'cache'
op|'='
name|'utils'
op|'.'
name|'bool_from_str'
op|'('
name|'sys_meta'
op|'['
string|"'image_cache_in_nova'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'            '
name|'cache'
op|'='
name|'False'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'cache_images'
op|'=='
string|"'none'"
op|':'
newline|'\n'
indent|'        '
name|'cache'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_'
op|'('
string|'"Unrecognized cache_images value \'%s\', defaulting to"'
nl|'\n'
string|'" True"'
op|')'
op|','
name|'FLAGS'
op|'.'
name|'cache_images'
op|')'
newline|'\n'
name|'cache'
op|'='
name|'True'
newline|'\n'
nl|'\n'
comment|'# Fetch (and cache) the image'
nl|'\n'
dedent|''
name|'if'
name|'cache'
op|':'
newline|'\n'
indent|'        '
name|'vdis'
op|'='
name|'_create_cached_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_id'
op|','
name|'image_type'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'vdis'
op|'='
name|'_fetch_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_id'
op|','
name|'image_type'
op|')'
newline|'\n'
nl|'\n'
comment|'# Set the name label and description to easily identify what'
nl|'\n'
comment|"# instance and disk it's for"
nl|'\n'
dedent|''
name|'for'
name|'vdi_type'
op|','
name|'vdi'
name|'in'
name|'vdis'
op|'.'
name|'iteritems'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'set_vdi_name'
op|'('
name|'session'
op|','
name|'vdi'
op|'['
string|"'uuid'"
op|']'
op|','
name|'name_label'
op|','
name|'vdi_type'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'vdis'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_fetch_image
dedent|''
name|'def'
name|'_fetch_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'image_id'
op|','
name|'image_type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Fetch image from glance based on image type.\n\n    Returns: A single filename if image_type is KERNEL or RAMDISK\n             A list of dictionaries that describe VDIs, otherwise\n    """'
newline|'\n'
name|'if'
name|'image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK_VHD'
op|':'
newline|'\n'
indent|'        '
name|'vdis'
op|'='
name|'_fetch_vhd_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'image_id'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'vdis'
op|'='
name|'_fetch_disk_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_id'
op|','
name|'image_type'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'vdi_type'
op|','
name|'vdi'
name|'in'
name|'vdis'
op|'.'
name|'iteritems'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'vdi_uuid'
op|'='
name|'vdi'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Fetched VDIs of type \'%(vdi_type)s\' with UUID"'
nl|'\n'
string|'" \'%(vdi_uuid)s\'"'
op|')'
op|','
nl|'\n'
name|'locals'
op|'('
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'vdis'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_fetch_using_dom0_plugin_with_retry
dedent|''
name|'def'
name|'_fetch_using_dom0_plugin_with_retry'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'image_id'
op|','
nl|'\n'
name|'plugin_name'
op|','
name|'params'
op|','
name|'callback'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'max_attempts'
op|'='
name|'FLAGS'
op|'.'
name|'glance_num_retries'
op|'+'
number|'1'
newline|'\n'
name|'sleep_time'
op|'='
number|'0.5'
newline|'\n'
name|'for'
name|'attempt_num'
name|'in'
name|'xrange'
op|'('
number|'1'
op|','
name|'max_attempts'
op|'+'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'download_vhd %(image_id)s, '"
nl|'\n'
string|"'attempt %(attempt_num)d/%(max_attempts)d, '"
nl|'\n'
string|"'params: %(params)s'"
op|')'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'callback'
op|':'
newline|'\n'
indent|'                '
name|'callback'
op|'('
name|'params'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'session'
op|'.'
name|'call_plugin_serialized'
op|'('
nl|'\n'
name|'plugin_name'
op|','
string|"'download_vhd'"
op|','
op|'**'
name|'params'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'            '
name|'_type'
op|','
name|'_method'
op|','
name|'error'
op|'='
name|'exc'
op|'.'
name|'details'
op|'['
op|':'
number|'3'
op|']'
newline|'\n'
name|'if'
name|'error'
op|'=='
string|"'RetryableError'"
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|"'download_vhd failed: %r'"
op|')'
op|'%'
nl|'\n'
op|'('
name|'exc'
op|'.'
name|'details'
op|'['
number|'3'
op|':'
op|']'
op|','
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'time'
op|'.'
name|'sleep'
op|'('
name|'sleep_time'
op|')'
newline|'\n'
name|'sleep_time'
op|'='
name|'min'
op|'('
number|'2'
op|'*'
name|'sleep_time'
op|','
number|'15'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'CouldNotFetchImage'
op|'('
name|'image_id'
op|'='
name|'image_id'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_make_uuid_stack
dedent|''
name|'def'
name|'_make_uuid_stack'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# NOTE(sirp): The XenAPI plugins run under Python 2.4'
nl|'\n'
comment|'# which does not have the `uuid` module. To work around this,'
nl|'\n'
comment|'# we generate the uuids here (under Python 2.6+) and'
nl|'\n'
comment|'# pass them as arguments'
nl|'\n'
indent|'    '
name|'return'
op|'['
name|'str'
op|'('
name|'uuid'
op|'.'
name|'uuid4'
op|'('
op|')'
op|')'
name|'for'
name|'i'
name|'in'
name|'xrange'
op|'('
name|'MAX_VDI_CHAIN_SIZE'
op|')'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_fetch_vhd_image
dedent|''
name|'def'
name|'_fetch_vhd_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'image_id'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Tell glance to download an image and put the VHDs into the SR\n\n    Returns: A list of dictionaries that describe VDIs\n    """'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Asking xapi to fetch vhd image %(image_id)s"'
op|')'
op|','
name|'locals'
op|'('
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'params'
op|'='
op|'{'
string|"'image_id'"
op|':'
name|'image_id'
op|','
nl|'\n'
string|"'uuid_stack'"
op|':'
name|'_make_uuid_stack'
op|'('
op|')'
op|','
nl|'\n'
string|"'sr_path'"
op|':'
name|'get_sr_path'
op|'('
name|'session'
op|')'
op|','
nl|'\n'
string|"'auth_token'"
op|':'
name|'getattr'
op|'('
name|'context'
op|','
string|"'auth_token'"
op|','
name|'None'
op|')'
op|'}'
newline|'\n'
nl|'\n'
name|'glance_api_servers'
op|'='
name|'glance'
op|'.'
name|'get_api_servers'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|pick_glance
name|'def'
name|'pick_glance'
op|'('
name|'params'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'glance_host'
op|','
name|'glance_port'
op|','
name|'glance_use_ssl'
op|'='
name|'glance_api_servers'
op|'.'
name|'next'
op|'('
op|')'
newline|'\n'
name|'params'
op|'['
string|"'glance_host'"
op|']'
op|'='
name|'glance_host'
newline|'\n'
name|'params'
op|'['
string|"'glance_port'"
op|']'
op|'='
name|'glance_port'
newline|'\n'
name|'params'
op|'['
string|"'glance_use_ssl'"
op|']'
op|'='
name|'glance_use_ssl'
newline|'\n'
nl|'\n'
dedent|''
name|'plugin_name'
op|'='
string|"'glance'"
newline|'\n'
name|'vdis'
op|'='
name|'_fetch_using_dom0_plugin_with_retry'
op|'('
nl|'\n'
name|'context'
op|','
name|'session'
op|','
name|'image_id'
op|','
name|'plugin_name'
op|','
name|'params'
op|','
nl|'\n'
name|'callback'
op|'='
name|'pick_glance'
op|')'
newline|'\n'
nl|'\n'
name|'sr_ref'
op|'='
name|'safe_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'_scan_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
newline|'\n'
nl|'\n'
comment|'# Pull out the UUID of the root VDI'
nl|'\n'
name|'root_vdi_uuid'
op|'='
name|'vdis'
op|'['
string|"'root'"
op|']'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
nl|'\n'
comment|'# Set the name-label to ease debugging'
nl|'\n'
name|'set_vdi_name'
op|'('
name|'session'
op|','
name|'root_vdi_uuid'
op|','
name|'instance'
op|'['
string|"'name'"
op|']'
op|','
string|"'root'"
op|')'
newline|'\n'
nl|'\n'
name|'_check_vdi_size'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'root_vdi_uuid'
op|')'
newline|'\n'
name|'return'
name|'vdis'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_vdi_chain_size
dedent|''
name|'def'
name|'_get_vdi_chain_size'
op|'('
name|'session'
op|','
name|'vdi_uuid'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Compute the total size of a VDI chain, starting with the specified\n    VDI UUID.\n\n    This will walk the VDI chain to the root, add the size of each VDI into\n    the total.\n    """'
newline|'\n'
name|'size_bytes'
op|'='
number|'0'
newline|'\n'
name|'for'
name|'vdi_rec'
name|'in'
name|'_walk_vdi_chain'
op|'('
name|'session'
op|','
name|'vdi_uuid'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'cur_vdi_uuid'
op|'='
name|'vdi_rec'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'vdi_size_bytes'
op|'='
name|'int'
op|'('
name|'vdi_rec'
op|'['
string|"'physical_utilisation'"
op|']'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'vdi_uuid=%(cur_vdi_uuid)s vdi_size_bytes='"
nl|'\n'
string|"'%(vdi_size_bytes)d'"
op|')'
op|','
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
name|'size_bytes'
op|'+='
name|'vdi_size_bytes'
newline|'\n'
dedent|''
name|'return'
name|'size_bytes'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_check_vdi_size
dedent|''
name|'def'
name|'_check_vdi_size'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'vdi_uuid'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'size_bytes'
op|'='
name|'_get_vdi_chain_size'
op|'('
name|'session'
op|','
name|'vdi_uuid'
op|')'
newline|'\n'
nl|'\n'
comment|"# FIXME(jk0): this was copied directly from compute.manager.py, let's"
nl|'\n'
comment|'# refactor this to a common area'
nl|'\n'
name|'instance_type_id'
op|'='
name|'instance'
op|'['
string|"'instance_type_id'"
op|']'
newline|'\n'
name|'instance_type'
op|'='
name|'instance_types'
op|'.'
name|'get_instance_type'
op|'('
name|'instance_type_id'
op|')'
newline|'\n'
name|'allowed_size_gb'
op|'='
name|'instance_type'
op|'['
string|"'root_gb'"
op|']'
newline|'\n'
name|'allowed_size_bytes'
op|'='
name|'allowed_size_gb'
op|'*'
number|'1024'
op|'*'
number|'1024'
op|'*'
number|'1024'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"image_size_bytes=%(size_bytes)d, allowed_size_bytes="'
nl|'\n'
string|'"%(allowed_size_bytes)d"'
op|')'
op|','
name|'locals'
op|'('
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'size_bytes'
op|'>'
name|'allowed_size_bytes'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"Image size %(size_bytes)d exceeded instance_type "'
nl|'\n'
string|'"allowed size %(allowed_size_bytes)d"'
op|')'
op|','
nl|'\n'
name|'locals'
op|'('
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'ImageTooLarge'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_fetch_disk_image
dedent|''
dedent|''
name|'def'
name|'_fetch_disk_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'image_id'
op|','
nl|'\n'
name|'image_type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Fetch the image from Glance\n\n    NOTE:\n    Unlike _fetch_vhd_image, this method does not use the Glance\n    plugin; instead, it streams the disks through domU to the VDI\n    directly.\n\n    Returns: A single filename if image_type is KERNEL_RAMDISK\n             A list of dictionaries that describe VDIs, otherwise\n    """'
newline|'\n'
comment|'# FIXME(sirp): Since the Glance plugin seems to be required for the'
nl|'\n'
comment|'# VHD disk, it may be worth using the plugin for both VHD and RAW and'
nl|'\n'
comment|'# DISK restores'
nl|'\n'
name|'image_type_str'
op|'='
name|'ImageType'
op|'.'
name|'to_string'
op|'('
name|'image_type'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Fetching image %(image_id)s, type %(image_type_str)s"'
op|')'
op|','
nl|'\n'
name|'locals'
op|'('
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK_ISO'
op|':'
newline|'\n'
indent|'        '
name|'sr_ref'
op|'='
name|'_safe_find_iso_sr'
op|'('
name|'session'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'sr_ref'
op|'='
name|'safe_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'image_service'
op|','
name|'image_id'
op|'='
name|'glance'
op|'.'
name|'get_remote_image_service'
op|'('
nl|'\n'
name|'context'
op|','
name|'image_id'
op|')'
newline|'\n'
name|'meta'
op|'='
name|'image_service'
op|'.'
name|'show'
op|'('
name|'context'
op|','
name|'image_id'
op|')'
newline|'\n'
name|'virtual_size'
op|'='
name|'int'
op|'('
name|'meta'
op|'['
string|"'size'"
op|']'
op|')'
newline|'\n'
name|'vdi_size'
op|'='
name|'virtual_size'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Size for image %(image_id)s: %(virtual_size)d"'
op|')'
op|','
name|'locals'
op|'('
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK'
op|':'
newline|'\n'
comment|'# Make room for MBR.'
nl|'\n'
indent|'        '
name|'vdi_size'
op|'+='
name|'MBR_SIZE_BYTES'
newline|'\n'
dedent|''
name|'elif'
op|'('
name|'image_type'
name|'in'
op|'('
name|'ImageType'
op|'.'
name|'KERNEL'
op|','
name|'ImageType'
op|'.'
name|'RAMDISK'
op|')'
name|'and'
nl|'\n'
name|'vdi_size'
op|'>'
name|'FLAGS'
op|'.'
name|'max_kernel_ramdisk_size'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'max_size'
op|'='
name|'FLAGS'
op|'.'
name|'max_kernel_ramdisk_size'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
nl|'\n'
name|'_'
op|'('
string|'"Kernel/Ramdisk image is too large: %(vdi_size)d bytes, "'
nl|'\n'
string|'"max %(max_size)d bytes"'
op|')'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'vdi_ref'
op|'='
name|'create_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_type_str'
op|','
name|'vdi_size'
op|')'
newline|'\n'
comment|'# From this point we have a VDI on Xen host;'
nl|'\n'
comment|'# If anything goes wrong, we need to remember its uuid.'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'filename'
op|'='
name|'None'
newline|'\n'
name|'vdi_uuid'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_uuid"'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
name|'as'
name|'dev'
op|':'
newline|'\n'
indent|'            '
name|'stream_func'
op|'='
name|'lambda'
name|'f'
op|':'
name|'image_service'
op|'.'
name|'download'
op|'('
nl|'\n'
name|'context'
op|','
name|'image_id'
op|','
name|'f'
op|')'
newline|'\n'
name|'_stream_disk'
op|'('
name|'stream_func'
op|','
name|'image_type'
op|','
name|'virtual_size'
op|','
name|'dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'image_type'
name|'in'
op|'('
name|'ImageType'
op|'.'
name|'KERNEL'
op|','
name|'ImageType'
op|'.'
name|'RAMDISK'
op|')'
op|':'
newline|'\n'
comment|'# We need to invoke a plugin for copying the'
nl|'\n'
comment|'# content of the VDI into the proper path.'
nl|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Copying VDI %s to /boot/guest on dom0"'
op|')'
op|','
nl|'\n'
name|'vdi_ref'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'args'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'args'
op|'['
string|"'vdi-ref'"
op|']'
op|'='
name|'vdi_ref'
newline|'\n'
nl|'\n'
comment|'# Let the plugin copy the correct number of bytes.'
nl|'\n'
name|'args'
op|'['
string|"'image-size'"
op|']'
op|'='
name|'str'
op|'('
name|'vdi_size'
op|')'
newline|'\n'
name|'if'
name|'FLAGS'
op|'.'
name|'cache_images'
op|':'
newline|'\n'
indent|'                '
name|'args'
op|'['
string|"'cached-image'"
op|']'
op|'='
name|'image_id'
newline|'\n'
dedent|''
name|'filename'
op|'='
name|'session'
op|'.'
name|'call_plugin'
op|'('
string|"'kernel'"
op|','
string|"'copy_vdi'"
op|','
name|'args'
op|')'
newline|'\n'
nl|'\n'
comment|'# Remove the VDI as it is not needed anymore.'
nl|'\n'
name|'destroy_vdi'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Kernel/Ramdisk VDI %s destroyed"'
op|')'
op|','
name|'vdi_ref'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'vdi_type'
op|'='
name|'ImageType'
op|'.'
name|'to_string'
op|'('
name|'image_type'
op|')'
newline|'\n'
name|'return'
op|'{'
name|'vdi_type'
op|':'
name|'dict'
op|'('
name|'uuid'
op|'='
name|'None'
op|','
name|'file'
op|'='
name|'filename'
op|')'
op|'}'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'vdi_type'
op|'='
name|'ImageType'
op|'.'
name|'to_string'
op|'('
name|'image_type'
op|')'
newline|'\n'
name|'return'
op|'{'
name|'vdi_type'
op|':'
name|'dict'
op|'('
name|'uuid'
op|'='
name|'vdi_uuid'
op|','
name|'file'
op|'='
name|'None'
op|')'
op|'}'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|'('
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|','
name|'IOError'
op|','
name|'OSError'
op|')'
name|'as'
name|'e'
op|':'
newline|'\n'
comment|'# We look for XenAPI and OS failures.'
nl|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_'
op|'('
string|'"Failed to fetch glance image"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'e'
op|'.'
name|'args'
op|'='
name|'e'
op|'.'
name|'args'
op|'+'
op|'('
op|'['
name|'dict'
op|'('
name|'type'
op|'='
name|'ImageType'
op|'.'
name|'to_string'
op|'('
name|'image_type'
op|')'
op|','
nl|'\n'
name|'uuid'
op|'='
name|'vdi_uuid'
op|','
nl|'\n'
name|'file'
op|'='
name|'filename'
op|')'
op|']'
op|','
op|')'
newline|'\n'
name|'raise'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|determine_disk_image_type
dedent|''
dedent|''
name|'def'
name|'determine_disk_image_type'
op|'('
name|'image_meta'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Disk Image Types are used to determine where the kernel will reside\n    within an image. To figure out which type we\'re dealing with, we use\n    the following rules:\n\n    1. If we\'re using Glance, we can use the image_type field to\n       determine the image_type\n\n    2. If we\'re not using Glance, then we need to deduce this based on\n       whether a kernel_id is specified.\n    """'
newline|'\n'
name|'disk_format'
op|'='
name|'image_meta'
op|'['
string|"'disk_format'"
op|']'
newline|'\n'
nl|'\n'
name|'disk_format_map'
op|'='
op|'{'
nl|'\n'
string|"'ami'"
op|':'
string|"'DISK'"
op|','
nl|'\n'
string|"'aki'"
op|':'
string|"'KERNEL'"
op|','
nl|'\n'
string|"'ari'"
op|':'
string|"'RAMDISK'"
op|','
nl|'\n'
string|"'raw'"
op|':'
string|"'DISK_RAW'"
op|','
nl|'\n'
string|"'vhd'"
op|':'
string|"'DISK_VHD'"
op|','
nl|'\n'
string|"'iso'"
op|':'
string|"'DISK_ISO'"
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'image_type_str'
op|'='
name|'disk_format_map'
op|'['
name|'disk_format'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'InvalidDiskFormat'
op|'('
name|'disk_format'
op|'='
name|'disk_format'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'image_type'
op|'='
name|'getattr'
op|'('
name|'ImageType'
op|','
name|'image_type_str'
op|')'
newline|'\n'
nl|'\n'
name|'image_ref'
op|'='
name|'image_meta'
op|'['
string|"'id'"
op|']'
newline|'\n'
name|'msg'
op|'='
name|'_'
op|'('
string|'"Detected %(image_type_str)s format for image %(image_ref)s"'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'msg'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'image_type'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|determine_is_pv
dedent|''
name|'def'
name|'determine_is_pv'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'disk_image_type'
op|','
name|'os_type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Determine whether the VM will use a paravirtualized kernel or if it\n    will use hardware virtualization.\n\n        1. Glance (VHD): then we use `os_type`, raise if not set\n\n        2. Glance (DISK_RAW): use Pygrub to figure out if pv kernel is\n           available\n\n        3. Glance (DISK): pv is assumed\n\n        4. Glance (DISK_ISO): no pv is assumed\n    """'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Looking up vdi %s for PV kernel"'
op|')'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'if'
name|'disk_image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK_VHD'
op|':'
newline|'\n'
comment|'# 1. VHD'
nl|'\n'
indent|'        '
name|'if'
name|'os_type'
op|'=='
string|"'windows'"
op|':'
newline|'\n'
indent|'            '
name|'is_pv'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'is_pv'
op|'='
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'disk_image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK_RAW'
op|':'
newline|'\n'
comment|'# 2. RAW'
nl|'\n'
indent|'        '
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'read_only'
op|'='
name|'True'
op|')'
name|'as'
name|'dev'
op|':'
newline|'\n'
indent|'            '
name|'is_pv'
op|'='
name|'_is_vdi_pv'
op|'('
name|'dev'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'disk_image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK'
op|':'
newline|'\n'
comment|'# 3. Disk'
nl|'\n'
indent|'        '
name|'is_pv'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'elif'
name|'disk_image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK_ISO'
op|':'
newline|'\n'
comment|'# 4. ISO'
nl|'\n'
indent|'        '
name|'is_pv'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'msg'
op|'='
name|'_'
op|'('
string|'"Unknown image format %(disk_image_type)s"'
op|')'
op|'%'
name|'locals'
op|'('
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'is_pv'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|set_vm_name_label
dedent|''
name|'def'
name|'set_vm_name_label'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'name_label'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.set_name_label"'
op|','
name|'vm_ref'
op|','
name|'name_label'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|list_vms
dedent|''
name|'def'
name|'list_vms'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'for'
name|'vm_ref'
op|','
name|'vm_rec'
name|'in'
name|'session'
op|'.'
name|'get_all_refs_and_recs'
op|'('
string|"'VM'"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
op|'('
name|'vm_rec'
op|'['
string|'"resident_on"'
op|']'
op|'!='
name|'session'
op|'.'
name|'get_xenapi_host'
op|'('
op|')'
name|'or'
nl|'\n'
name|'vm_rec'
op|'['
string|'"is_a_template"'
op|']'
name|'or'
name|'vm_rec'
op|'['
string|'"is_control_domain"'
op|']'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'yield'
name|'vm_ref'
op|','
name|'vm_rec'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|lookup_vm_vdis
dedent|''
dedent|''
dedent|''
name|'def'
name|'lookup_vm_vdis'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Look for the VDIs that are attached to the VM"""'
newline|'\n'
comment|'# Firstly we get the VBDs, then the VDIs.'
nl|'\n'
comment|'# TODO(Armando): do we leave the read-only devices?'
nl|'\n'
name|'vbd_refs'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_VBDs"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'vdi_refs'
op|'='
op|'['
op|']'
newline|'\n'
name|'if'
name|'vbd_refs'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'vbd_ref'
name|'in'
name|'vbd_refs'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VBD.get_VDI"'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
comment|'# Test valid VDI'
nl|'\n'
name|'record'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_record"'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'VDI %s is still available'"
op|')'
op|','
name|'record'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
name|'vbd_other_config'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VBD.get_other_config"'
op|','
nl|'\n'
name|'vbd_ref'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'vbd_other_config'
op|'.'
name|'get'
op|'('
string|"'osvol'"
op|')'
op|':'
newline|'\n'
comment|'# This is not an attached volume'
nl|'\n'
indent|'                    '
name|'vdi_refs'
op|'.'
name|'append'
op|'('
name|'vdi_ref'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|','
name|'exc'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'exc'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'vdi_refs'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|lookup
dedent|''
name|'def'
name|'lookup'
op|'('
name|'session'
op|','
name|'name_label'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Look the instance up and return it if available"""'
newline|'\n'
name|'vm_refs'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_by_name_label"'
op|','
name|'name_label'
op|')'
newline|'\n'
name|'n'
op|'='
name|'len'
op|'('
name|'vm_refs'
op|')'
newline|'\n'
name|'if'
name|'n'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'elif'
name|'n'
op|'>'
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'InstanceExists'
op|'('
name|'name'
op|'='
name|'name_label'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'vm_refs'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|preconfigure_instance
dedent|''
dedent|''
name|'def'
name|'preconfigure_instance'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vdi_ref'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Makes alterations to the image before launching as part of spawn.\n    """'
newline|'\n'
nl|'\n'
comment|'# As mounting the image VDI is expensive, we only want do do it once,'
nl|'\n'
comment|"# if at all, so determine whether it's required first, and then do"
nl|'\n'
comment|'# everything'
nl|'\n'
name|'mount_required'
op|'='
name|'False'
newline|'\n'
name|'key'
op|','
name|'net'
op|','
name|'metadata'
op|'='
name|'_prepare_injectables'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'mount_required'
op|'='
name|'key'
name|'or'
name|'net'
name|'or'
name|'metadata'
newline|'\n'
name|'if'
name|'not'
name|'mount_required'
op|':'
newline|'\n'
indent|'        '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
name|'as'
name|'dev'
op|':'
newline|'\n'
indent|'        '
name|'_mounted_processing'
op|'('
name|'dev'
op|','
name|'key'
op|','
name|'net'
op|','
name|'metadata'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|lookup_kernel_ramdisk
dedent|''
dedent|''
name|'def'
name|'lookup_kernel_ramdisk'
op|'('
name|'session'
op|','
name|'vm'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vm_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_record"'
op|','
name|'vm'
op|')'
newline|'\n'
name|'if'
string|"'PV_kernel'"
name|'in'
name|'vm_rec'
name|'and'
string|"'PV_ramdisk'"
name|'in'
name|'vm_rec'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
name|'vm_rec'
op|'['
string|"'PV_kernel'"
op|']'
op|','
name|'vm_rec'
op|'['
string|"'PV_ramdisk'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|is_snapshot
dedent|''
dedent|''
name|'def'
name|'is_snapshot'
op|'('
name|'session'
op|','
name|'vm'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vm_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_record"'
op|','
name|'vm'
op|')'
newline|'\n'
name|'if'
string|"'is_a_template'"
name|'in'
name|'vm_rec'
name|'and'
string|"'is_a_snapshot'"
name|'in'
name|'vm_rec'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'vm_rec'
op|'['
string|"'is_a_template'"
op|']'
name|'and'
name|'vm_rec'
op|'['
string|"'is_a_snapshot'"
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|compile_info
dedent|''
dedent|''
name|'def'
name|'compile_info'
op|'('
name|'record'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Fill record with VM status information"""'
newline|'\n'
name|'return'
op|'{'
string|"'state'"
op|':'
name|'XENAPI_POWER_STATE'
op|'['
name|'record'
op|'['
string|"'power_state'"
op|']'
op|']'
op|','
nl|'\n'
string|"'max_mem'"
op|':'
name|'long'
op|'('
name|'record'
op|'['
string|"'memory_static_max'"
op|']'
op|')'
op|'>>'
number|'10'
op|','
nl|'\n'
string|"'mem'"
op|':'
name|'long'
op|'('
name|'record'
op|'['
string|"'memory_dynamic_max'"
op|']'
op|')'
op|'>>'
number|'10'
op|','
nl|'\n'
string|"'num_cpu'"
op|':'
name|'record'
op|'['
string|"'VCPUs_max'"
op|']'
op|','
nl|'\n'
string|"'cpu_time'"
op|':'
number|'0'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|compile_diagnostics
dedent|''
name|'def'
name|'compile_diagnostics'
op|'('
name|'record'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Compile VM diagnostics data"""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'keys'
op|'='
op|'['
op|']'
newline|'\n'
name|'diags'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'vm_uuid'
op|'='
name|'record'
op|'['
string|'"uuid"'
op|']'
newline|'\n'
name|'xml'
op|'='
name|'_get_rrd'
op|'('
name|'_get_rrd_server'
op|'('
op|')'
op|','
name|'vm_uuid'
op|')'
newline|'\n'
name|'if'
name|'xml'
op|':'
newline|'\n'
indent|'            '
name|'rrd'
op|'='
name|'minidom'
op|'.'
name|'parseString'
op|'('
name|'xml'
op|')'
newline|'\n'
name|'for'
name|'i'
op|','
name|'node'
name|'in'
name|'enumerate'
op|'('
name|'rrd'
op|'.'
name|'firstChild'
op|'.'
name|'childNodes'
op|')'
op|':'
newline|'\n'
comment|'# Provide the last update of the information'
nl|'\n'
indent|'                '
name|'if'
name|'node'
op|'.'
name|'localName'
op|'=='
string|"'lastupdate'"
op|':'
newline|'\n'
indent|'                    '
name|'diags'
op|'['
string|"'last_update'"
op|']'
op|'='
name|'node'
op|'.'
name|'firstChild'
op|'.'
name|'data'
newline|'\n'
nl|'\n'
comment|'# Create a list of the diagnostic keys (in their order)'
nl|'\n'
dedent|''
name|'if'
name|'node'
op|'.'
name|'localName'
op|'=='
string|"'ds'"
op|':'
newline|'\n'
indent|'                    '
name|'ref'
op|'='
name|'node'
op|'.'
name|'childNodes'
newline|'\n'
comment|'# Name and Value'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'ref'
op|')'
op|'>'
number|'6'
op|':'
newline|'\n'
indent|'                        '
name|'keys'
op|'.'
name|'append'
op|'('
name|'ref'
op|'['
number|'0'
op|']'
op|'.'
name|'firstChild'
op|'.'
name|'data'
op|')'
newline|'\n'
nl|'\n'
comment|'# Read the last row of the first RRA to get the latest info'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'node'
op|'.'
name|'localName'
op|'=='
string|"'rra'"
op|':'
newline|'\n'
indent|'                    '
name|'rows'
op|'='
name|'node'
op|'.'
name|'childNodes'
op|'['
number|'4'
op|']'
op|'.'
name|'childNodes'
newline|'\n'
name|'last_row'
op|'='
name|'rows'
op|'['
name|'rows'
op|'.'
name|'length'
op|'-'
number|'1'
op|']'
op|'.'
name|'childNodes'
newline|'\n'
name|'for'
name|'j'
op|','
name|'value'
name|'in'
name|'enumerate'
op|'('
name|'last_row'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'diags'
op|'['
name|'keys'
op|'['
name|'j'
op|']'
op|']'
op|'='
name|'value'
op|'.'
name|'firstChild'
op|'.'
name|'data'
newline|'\n'
dedent|''
name|'break'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'diags'
newline|'\n'
dedent|''
name|'except'
name|'expat'
op|'.'
name|'ExpatError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_'
op|'('
string|"'Unable to parse rrd of %(vm_uuid)s'"
op|')'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
name|'return'
op|'{'
string|'"Unable to retrieve diagnostics"'
op|':'
name|'e'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|compile_metrics
dedent|''
dedent|''
name|'def'
name|'compile_metrics'
op|'('
name|'start_time'
op|','
name|'stop_time'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Compile bandwidth usage, cpu, and disk metrics for all VMs on\n       this host"""'
newline|'\n'
name|'start_time'
op|'='
name|'int'
op|'('
name|'start_time'
op|')'
newline|'\n'
nl|'\n'
name|'xml'
op|'='
name|'_get_rrd_updates'
op|'('
name|'_get_rrd_server'
op|'('
op|')'
op|','
name|'start_time'
op|')'
newline|'\n'
name|'if'
name|'xml'
op|':'
newline|'\n'
indent|'        '
name|'doc'
op|'='
name|'minidom'
op|'.'
name|'parseString'
op|'('
name|'xml'
op|')'
newline|'\n'
name|'return'
name|'_parse_rrd_update'
op|'('
name|'doc'
op|','
name|'start_time'
op|','
name|'stop_time'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'CouldNotFetchMetrics'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_scan_sr
dedent|''
name|'def'
name|'_scan_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Scans the SR specified by sr_ref"""'
newline|'\n'
name|'if'
name|'sr_ref'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Re-scanning SR %s"'
op|')'
op|','
name|'sr_ref'
op|')'
newline|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'SR.scan'"
op|','
name|'sr_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|scan_default_sr
dedent|''
dedent|''
name|'def'
name|'scan_default_sr'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Looks for the system default SR and triggers a re-scan"""'
newline|'\n'
name|'_scan_sr'
op|'('
name|'session'
op|','
name|'_find_sr'
op|'('
name|'session'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|safe_find_sr
dedent|''
name|'def'
name|'safe_find_sr'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Same as _find_sr except raises a NotFound exception if SR cannot be\n    determined\n    """'
newline|'\n'
name|'sr_ref'
op|'='
name|'_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'if'
name|'sr_ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'StorageRepositoryNotFound'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'sr_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_find_sr
dedent|''
name|'def'
name|'_find_sr'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the storage repository to hold VM images"""'
newline|'\n'
name|'host'
op|'='
name|'session'
op|'.'
name|'get_xenapi_host'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'tokens'
op|'='
name|'FLAGS'
op|'.'
name|'sr_matching_filter'
op|'.'
name|'split'
op|'('
string|"':'"
op|')'
newline|'\n'
name|'filter_criteria'
op|'='
name|'tokens'
op|'['
number|'0'
op|']'
newline|'\n'
name|'filter_pattern'
op|'='
name|'tokens'
op|'['
number|'1'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'IndexError'
op|':'
newline|'\n'
comment|'# oops, flag is invalid'
nl|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_'
op|'('
string|'"Flag sr_matching_filter \'%s\' does not respect "'
nl|'\n'
string|'"formatting convention"'
op|')'
op|','
name|'FLAGS'
op|'.'
name|'sr_matching_filter'
op|')'
newline|'\n'
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'filter_criteria'
op|'=='
string|"'other-config'"
op|':'
newline|'\n'
indent|'        '
name|'key'
op|','
name|'value'
op|'='
name|'filter_pattern'
op|'.'
name|'split'
op|'('
string|"'='"
op|','
number|'1'
op|')'
newline|'\n'
name|'for'
name|'sr_ref'
op|','
name|'sr_rec'
name|'in'
name|'session'
op|'.'
name|'get_all_refs_and_recs'
op|'('
string|"'SR'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
op|'('
name|'key'
name|'in'
name|'sr_rec'
op|'['
string|"'other_config'"
op|']'
name|'and'
nl|'\n'
name|'sr_rec'
op|'['
string|"'other_config'"
op|']'
op|'['
name|'key'
op|']'
op|'=='
name|'value'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'for'
name|'pbd_ref'
name|'in'
name|'sr_rec'
op|'['
string|"'PBDs'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'pbd_rec'
op|'='
name|'session'
op|'.'
name|'get_rec'
op|'('
string|"'PBD'"
op|','
name|'pbd_ref'
op|')'
newline|'\n'
name|'if'
name|'pbd_rec'
name|'and'
name|'pbd_rec'
op|'['
string|"'host'"
op|']'
op|'=='
name|'host'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'sr_ref'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'elif'
name|'filter_criteria'
op|'=='
string|"'default-sr'"
name|'and'
name|'filter_pattern'
op|'=='
string|"'true'"
op|':'
newline|'\n'
indent|'        '
name|'pool_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'pool.get_all'"
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'return'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'pool.get_default_SR'"
op|','
name|'pool_ref'
op|')'
newline|'\n'
comment|'# No SR found!'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_'
op|'('
string|'"XenAPI is unable to find a Storage Repository to "'
nl|'\n'
string|'"install guest instances on. Please check your "'
nl|'\n'
string|'"configuration and/or configure the flag "'
nl|'\n'
string|'"\'sr_matching_filter\'"'
op|')'
op|')'
newline|'\n'
name|'return'
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_safe_find_iso_sr
dedent|''
name|'def'
name|'_safe_find_iso_sr'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Same as _find_iso_sr except raises a NotFound exception if SR\n    cannot be determined\n    """'
newline|'\n'
name|'sr_ref'
op|'='
name|'_find_iso_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'if'
name|'sr_ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'NotFound'
op|'('
name|'_'
op|'('
string|"'Cannot find SR of content-type ISO'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'sr_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_find_iso_sr
dedent|''
name|'def'
name|'_find_iso_sr'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the storage repository to hold ISO images"""'
newline|'\n'
name|'host'
op|'='
name|'session'
op|'.'
name|'get_xenapi_host'
op|'('
op|')'
newline|'\n'
name|'for'
name|'sr_ref'
op|','
name|'sr_rec'
name|'in'
name|'session'
op|'.'
name|'get_all_refs_and_recs'
op|'('
string|"'SR'"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"ISO: looking at SR %(sr_rec)s"'
op|')'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'sr_rec'
op|'['
string|"'content_type'"
op|']'
op|'=='
string|"'iso'"
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"ISO: not iso content"'
op|')'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'if'
name|'not'
string|"'i18n-key'"
name|'in'
name|'sr_rec'
op|'['
string|"'other_config'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"ISO: iso content_type, no \'i18n-key\' key"'
op|')'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'sr_rec'
op|'['
string|"'other_config'"
op|']'
op|'['
string|"'i18n-key'"
op|']'
op|'=='
string|"'local-storage-iso'"
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"ISO: iso content_type, i18n-key value not "'
nl|'\n'
string|'"\'local-storage-iso\'"'
op|')'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"ISO: SR MATCHing our criteria"'
op|')'
op|')'
newline|'\n'
name|'for'
name|'pbd_ref'
name|'in'
name|'sr_rec'
op|'['
string|"'PBDs'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"ISO: ISO, looking to see if it is host local"'
op|')'
op|')'
newline|'\n'
name|'pbd_rec'
op|'='
name|'session'
op|'.'
name|'get_rec'
op|'('
string|"'PBD'"
op|','
name|'pbd_ref'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'pbd_rec'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"ISO: PBD %(pbd_ref)s disappeared"'
op|')'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'pbd_rec_host'
op|'='
name|'pbd_rec'
op|'['
string|"'host'"
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"ISO: PBD matching, want %(pbd_rec)s, "'
nl|'\n'
string|'"have %(host)s"'
op|')'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
name|'if'
name|'pbd_rec_host'
op|'=='
name|'host'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"ISO: SR with local PBD"'
op|')'
op|')'
newline|'\n'
name|'return'
name|'sr_ref'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_rrd_server
dedent|''
name|'def'
name|'_get_rrd_server'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return server\'s scheme and address to use for retrieving RRD XMLs."""'
newline|'\n'
name|'xs_url'
op|'='
name|'urlparse'
op|'.'
name|'urlparse'
op|'('
name|'FLAGS'
op|'.'
name|'xenapi_connection_url'
op|')'
newline|'\n'
name|'return'
op|'['
name|'xs_url'
op|'.'
name|'scheme'
op|','
name|'xs_url'
op|'.'
name|'netloc'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_rrd
dedent|''
name|'def'
name|'_get_rrd'
op|'('
name|'server'
op|','
name|'vm_uuid'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the VM RRD XML as a string"""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'xml'
op|'='
name|'urllib'
op|'.'
name|'urlopen'
op|'('
string|'"%s://%s:%s@%s/vm_rrd?uuid=%s"'
op|'%'
op|'('
nl|'\n'
name|'server'
op|'['
number|'0'
op|']'
op|','
nl|'\n'
name|'FLAGS'
op|'.'
name|'xenapi_connection_username'
op|','
nl|'\n'
name|'FLAGS'
op|'.'
name|'xenapi_connection_password'
op|','
nl|'\n'
name|'server'
op|'['
number|'1'
op|']'
op|','
nl|'\n'
name|'vm_uuid'
op|')'
op|')'
newline|'\n'
name|'return'
name|'xml'
op|'.'
name|'read'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'IOError'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_'
op|'('
string|"'Unable to obtain RRD XML for VM %(vm_uuid)s with '"
nl|'\n'
string|"'server details: %(server)s.'"
op|')'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
name|'return'
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_rrd_updates
dedent|''
dedent|''
name|'def'
name|'_get_rrd_updates'
op|'('
name|'server'
op|','
name|'start_time'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the RRD updates XML as a string"""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'xml'
op|'='
name|'urllib'
op|'.'
name|'urlopen'
op|'('
string|'"%s://%s:%s@%s/rrd_updates?start=%s"'
op|'%'
op|'('
nl|'\n'
name|'server'
op|'['
number|'0'
op|']'
op|','
nl|'\n'
name|'FLAGS'
op|'.'
name|'xenapi_connection_username'
op|','
nl|'\n'
name|'FLAGS'
op|'.'
name|'xenapi_connection_password'
op|','
nl|'\n'
name|'server'
op|'['
number|'1'
op|']'
op|','
nl|'\n'
name|'start_time'
op|')'
op|')'
newline|'\n'
name|'return'
name|'xml'
op|'.'
name|'read'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'IOError'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_'
op|'('
string|"'Unable to obtain RRD XML updates with '"
nl|'\n'
string|"'server details: %(server)s.'"
op|')'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
name|'return'
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_parse_rrd_meta
dedent|''
dedent|''
name|'def'
name|'_parse_rrd_meta'
op|'('
name|'doc'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'data'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'meta'
op|'='
name|'doc'
op|'.'
name|'getElementsByTagName'
op|'('
string|"'meta'"
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'for'
name|'tag'
name|'in'
op|'('
string|"'start'"
op|','
string|"'end'"
op|','
string|"'step'"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'data'
op|'['
name|'tag'
op|']'
op|'='
name|'int'
op|'('
name|'meta'
op|'.'
name|'getElementsByTagName'
op|'('
name|'tag'
op|')'
op|'['
number|'0'
op|']'
op|'.'
name|'firstChild'
op|'.'
name|'data'
op|')'
newline|'\n'
dedent|''
name|'legend'
op|'='
name|'meta'
op|'.'
name|'getElementsByTagName'
op|'('
string|"'legend'"
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'data'
op|'['
string|"'legend'"
op|']'
op|'='
op|'['
name|'child'
op|'.'
name|'firstChild'
op|'.'
name|'data'
name|'for'
name|'child'
name|'in'
name|'legend'
op|'.'
name|'childNodes'
op|']'
newline|'\n'
name|'return'
name|'data'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_parse_rrd_data
dedent|''
name|'def'
name|'_parse_rrd_data'
op|'('
name|'doc'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'dnode'
op|'='
name|'doc'
op|'.'
name|'getElementsByTagName'
op|'('
string|"'data'"
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'return'
op|'['
name|'dict'
op|'('
nl|'\n'
name|'time'
op|'='
name|'int'
op|'('
name|'child'
op|'.'
name|'getElementsByTagName'
op|'('
string|"'t'"
op|')'
op|'['
number|'0'
op|']'
op|'.'
name|'firstChild'
op|'.'
name|'data'
op|')'
op|','
nl|'\n'
name|'values'
op|'='
op|'['
name|'decimal'
op|'.'
name|'Decimal'
op|'('
name|'valnode'
op|'.'
name|'firstChild'
op|'.'
name|'data'
op|')'
nl|'\n'
name|'for'
name|'valnode'
name|'in'
name|'child'
op|'.'
name|'getElementsByTagName'
op|'('
string|"'v'"
op|')'
op|']'
op|')'
nl|'\n'
name|'for'
name|'child'
name|'in'
name|'dnode'
op|'.'
name|'childNodes'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_parse_rrd_update
dedent|''
name|'def'
name|'_parse_rrd_update'
op|'('
name|'doc'
op|','
name|'start'
op|','
name|'until'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'sum_data'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'meta'
op|'='
name|'_parse_rrd_meta'
op|'('
name|'doc'
op|')'
newline|'\n'
name|'data'
op|'='
name|'_parse_rrd_data'
op|'('
name|'doc'
op|')'
newline|'\n'
name|'for'
name|'col'
op|','
name|'collabel'
name|'in'
name|'enumerate'
op|'('
name|'meta'
op|'['
string|"'legend'"
op|']'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'_datatype'
op|','
name|'_objtype'
op|','
name|'uuid'
op|','
name|'name'
op|'='
name|'collabel'
op|'.'
name|'split'
op|'('
string|"':'"
op|')'
newline|'\n'
name|'vm_data'
op|'='
name|'sum_data'
op|'.'
name|'get'
op|'('
name|'uuid'
op|','
name|'dict'
op|'('
op|')'
op|')'
newline|'\n'
name|'if'
name|'name'
op|'.'
name|'startswith'
op|'('
string|"'vif'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'vm_data'
op|'['
name|'name'
op|']'
op|'='
name|'_integrate_series'
op|'('
name|'data'
op|','
name|'col'
op|','
name|'start'
op|','
name|'until'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'vm_data'
op|'['
name|'name'
op|']'
op|'='
name|'_average_series'
op|'('
name|'data'
op|','
name|'col'
op|','
name|'until'
op|')'
newline|'\n'
dedent|''
name|'sum_data'
op|'['
name|'uuid'
op|']'
op|'='
name|'vm_data'
newline|'\n'
dedent|''
name|'return'
name|'sum_data'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_average_series
dedent|''
name|'def'
name|'_average_series'
op|'('
name|'data'
op|','
name|'col'
op|','
name|'until'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vals'
op|'='
op|'['
name|'row'
op|'['
string|"'values'"
op|']'
op|'['
name|'col'
op|']'
name|'for'
name|'row'
name|'in'
name|'data'
nl|'\n'
name|'if'
op|'('
name|'not'
name|'until'
name|'or'
op|'('
name|'row'
op|'['
string|"'time'"
op|']'
op|'<='
name|'until'
op|')'
op|')'
name|'and'
nl|'\n'
name|'row'
op|'['
string|"'values'"
op|']'
op|'['
name|'col'
op|']'
op|'.'
name|'is_finite'
op|'('
op|')'
op|']'
newline|'\n'
name|'if'
name|'vals'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'('
name|'sum'
op|'('
name|'vals'
op|')'
op|'/'
name|'len'
op|'('
name|'vals'
op|')'
op|')'
op|'.'
name|'quantize'
op|'('
name|'decimal'
op|'.'
name|'Decimal'
op|'('
string|"'1.0000'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'decimal'
op|'.'
name|'InvalidOperation'
op|':'
newline|'\n'
comment|'# (mdragon) Xenserver occasionally returns odd values in'
nl|'\n'
comment|'# data that will throw an error on averaging (see bug 918490)'
nl|'\n'
comment|'# These are hard to find, since, whatever those values are,'
nl|'\n'
comment|'# Decimal seems to think they are a valid number, sortof.'
nl|'\n'
comment|"# We *think* we've got the the cases covered, but just in"
nl|'\n'
comment|"# case, log and return NaN, so we don't break reporting of"
nl|'\n'
comment|'# other statistics.'
nl|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|'"Invalid statistics data from Xenserver: %s"'
op|')'
nl|'\n'
op|'%'
name|'str'
op|'('
name|'vals'
op|')'
op|')'
newline|'\n'
name|'return'
name|'decimal'
op|'.'
name|'Decimal'
op|'('
string|"'NaN'"
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'decimal'
op|'.'
name|'Decimal'
op|'('
string|"'0.0000'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_integrate_series
dedent|''
dedent|''
name|'def'
name|'_integrate_series'
op|'('
name|'data'
op|','
name|'col'
op|','
name|'start'
op|','
name|'until'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'total'
op|'='
name|'decimal'
op|'.'
name|'Decimal'
op|'('
string|"'0.0000'"
op|')'
newline|'\n'
name|'prev_time'
op|'='
name|'int'
op|'('
name|'start'
op|')'
newline|'\n'
name|'prev_val'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'row'
name|'in'
name|'reversed'
op|'('
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'until'
name|'or'
op|'('
name|'row'
op|'['
string|"'time'"
op|']'
op|'<='
name|'until'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'time'
op|'='
name|'row'
op|'['
string|"'time'"
op|']'
newline|'\n'
name|'val'
op|'='
name|'row'
op|'['
string|"'values'"
op|']'
op|'['
name|'col'
op|']'
newline|'\n'
name|'if'
name|'val'
op|'.'
name|'is_nan'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'val'
op|'='
name|'decimal'
op|'.'
name|'Decimal'
op|'('
string|"'0.0000'"
op|')'
newline|'\n'
dedent|''
name|'if'
name|'prev_val'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'prev_val'
op|'='
name|'val'
newline|'\n'
dedent|''
name|'if'
name|'prev_val'
op|'>='
name|'val'
op|':'
newline|'\n'
indent|'                '
name|'total'
op|'+='
op|'('
op|'('
name|'val'
op|'*'
op|'('
name|'time'
op|'-'
name|'prev_time'
op|')'
op|')'
op|'+'
nl|'\n'
op|'('
name|'decimal'
op|'.'
name|'Decimal'
op|'('
string|"'0.5000'"
op|')'
op|'*'
op|'('
name|'prev_val'
op|'-'
name|'val'
op|')'
op|'*'
nl|'\n'
op|'('
name|'time'
op|'-'
name|'prev_time'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'total'
op|'+='
op|'('
op|'('
name|'prev_val'
op|'*'
op|'('
name|'time'
op|'-'
name|'prev_time'
op|')'
op|')'
op|'+'
nl|'\n'
op|'('
name|'decimal'
op|'.'
name|'Decimal'
op|'('
string|"'0.5000'"
op|')'
op|'*'
op|'('
name|'val'
op|'-'
name|'prev_val'
op|')'
op|'*'
nl|'\n'
op|'('
name|'time'
op|'-'
name|'prev_time'
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'prev_time'
op|'='
name|'time'
newline|'\n'
name|'prev_val'
op|'='
name|'val'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'total'
op|'.'
name|'quantize'
op|'('
name|'decimal'
op|'.'
name|'Decimal'
op|'('
string|"'1.0000'"
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_all_vdis_in_sr
dedent|''
name|'def'
name|'_get_all_vdis_in_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'for'
name|'vdi_ref'
name|'in'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'SR.get_VDIs'"
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'vdi_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_record'"
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'yield'
name|'vdi_ref'
op|','
name|'vdi_rec'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_instance_vdis_for_sr
dedent|''
dedent|''
dedent|''
name|'def'
name|'get_instance_vdis_for_sr'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return opaqueRef for all the vdis which live on sr"""'
newline|'\n'
name|'for'
name|'vbd_ref'
name|'in'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VM.get_VBDs'"
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VBD.get_VDI'"
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'if'
name|'sr_ref'
op|'=='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_SR'"
op|','
name|'vdi_ref'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'yield'
name|'vdi_ref'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_vhd_parent_uuid
dedent|''
dedent|''
dedent|''
name|'def'
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vdi_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_record"'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
name|'if'
string|"'vhd-parent'"
name|'not'
name|'in'
name|'vdi_rec'
op|'['
string|"'sm_config'"
op|']'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'parent_uuid'
op|'='
name|'vdi_rec'
op|'['
string|"'sm_config'"
op|']'
op|'['
string|"'vhd-parent'"
op|']'
newline|'\n'
name|'vdi_uuid'
op|'='
name|'vdi_rec'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"VHD %(vdi_uuid)s has parent %(parent_uuid)s"'
op|')'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
name|'return'
name|'parent_uuid'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_walk_vdi_chain
dedent|''
name|'def'
name|'_walk_vdi_chain'
op|'('
name|'session'
op|','
name|'vdi_uuid'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Yield vdi_recs for each element in a VDI chain"""'
newline|'\n'
name|'scan_default_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'        '
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_by_uuid"'
op|','
name|'vdi_uuid'
op|')'
newline|'\n'
name|'vdi_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_record"'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'yield'
name|'vdi_rec'
newline|'\n'
nl|'\n'
name|'parent_uuid'
op|'='
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'parent_uuid'
op|':'
newline|'\n'
indent|'            '
name|'break'
newline|'\n'
nl|'\n'
dedent|''
name|'vdi_uuid'
op|'='
name|'parent_uuid'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_child_vhds
dedent|''
dedent|''
name|'def'
name|'_child_vhds'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'vdi_uuid'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the immediate children of a given VHD.\n\n    This is not recursive, only the immediate children are returned.\n    """'
newline|'\n'
name|'children'
op|'='
name|'set'
op|'('
op|')'
newline|'\n'
name|'for'
name|'ref'
op|','
name|'rec'
name|'in'
name|'_get_all_vdis_in_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'rec_uuid'
op|'='
name|'rec'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'rec_uuid'
op|'=='
name|'vdi_uuid'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'parent_uuid'
op|'='
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'ref'
op|')'
newline|'\n'
name|'if'
name|'parent_uuid'
op|'!='
name|'vdi_uuid'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'children'
op|'.'
name|'add'
op|'('
name|'rec_uuid'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'children'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_wait_for_vhd_coalesce
dedent|''
name|'def'
name|'_wait_for_vhd_coalesce'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'sr_ref'
op|','
name|'vdi_ref'
op|','
nl|'\n'
name|'original_parent_uuid'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Spin until the parent VHD is coalesced into its parent VHD\n\n    Before coalesce:\n        * original_parent_vhd\n            * parent_vhd\n                snapshot\n\n    After coalesce:\n        * parent_vhd\n            snapshot\n    """'
newline|'\n'
DECL|function|_another_child_vhd
name|'def'
name|'_another_child_vhd'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'original_parent_uuid'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
comment|'# Search for any other vdi which parents to original parent and is not'
nl|'\n'
comment|'# in the active vm/instance vdi chain.'
nl|'\n'
dedent|''
name|'vdi_uuid'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_record'"
op|','
name|'vdi_ref'
op|')'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'parent_vdi_uuid'
op|'='
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'for'
name|'_ref'
op|','
name|'rec'
name|'in'
name|'_get_all_vdis_in_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
op|'('
name|'rec'
op|'['
string|"'uuid'"
op|']'
op|'!='
name|'vdi_uuid'
op|')'
name|'and'
nl|'\n'
op|'('
name|'rec'
op|'['
string|"'uuid'"
op|']'
op|'!='
name|'parent_vdi_uuid'
op|')'
name|'and'
nl|'\n'
op|'('
name|'rec'
op|'['
string|"'sm_config'"
op|']'
op|'.'
name|'get'
op|'('
string|"'vhd-parent'"
op|')'
op|'=='
name|'original_parent_uuid'
op|')'
op|')'
op|':'
newline|'\n'
comment|'# Found another vhd which too parents to original parent.'
nl|'\n'
indent|'                '
name|'return'
name|'True'
newline|'\n'
comment|'# Found no other vdi with the same parent.'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
comment|'# Check if original parent has any other child. If so, coalesce will'
nl|'\n'
comment|'# not take place.'
nl|'\n'
dedent|''
name|'if'
name|'_another_child_vhd'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'parent_uuid'
op|'='
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'parent_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_by_uuid"'
op|','
name|'parent_uuid'
op|')'
newline|'\n'
name|'base_uuid'
op|'='
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'parent_ref'
op|')'
newline|'\n'
name|'return'
name|'parent_uuid'
op|','
name|'base_uuid'
newline|'\n'
nl|'\n'
comment|"# NOTE(sirp): This rescan is necessary to ensure the VM's `sm_config`"
nl|'\n'
comment|'# matches the underlying VHDs.'
nl|'\n'
dedent|''
name|'_scan_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
newline|'\n'
nl|'\n'
name|'max_attempts'
op|'='
name|'FLAGS'
op|'.'
name|'xenapi_vhd_coalesce_max_attempts'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'xrange'
op|'('
name|'max_attempts'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'_scan_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
newline|'\n'
name|'parent_uuid'
op|'='
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'if'
name|'original_parent_uuid'
name|'and'
op|'('
name|'parent_uuid'
op|'!='
name|'original_parent_uuid'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Parent %(parent_uuid)s doesn\'t match original parent"'
nl|'\n'
string|'" %(original_parent_uuid)s, waiting for coalesce..."'
op|')'
op|','
nl|'\n'
name|'locals'
op|'('
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'parent_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_by_uuid"'
op|','
name|'parent_uuid'
op|')'
newline|'\n'
name|'base_uuid'
op|'='
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'parent_ref'
op|')'
newline|'\n'
name|'return'
name|'parent_uuid'
op|','
name|'base_uuid'
newline|'\n'
nl|'\n'
dedent|''
name|'greenthread'
op|'.'
name|'sleep'
op|'('
name|'FLAGS'
op|'.'
name|'xenapi_vhd_coalesce_poll_interval'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|'"VHD coalesce attempts exceeded (%(max_attempts)d)"'
nl|'\n'
string|'", giving up..."'
op|')'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_remap_vbd_dev
dedent|''
name|'def'
name|'_remap_vbd_dev'
op|'('
name|'dev'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the appropriate location for a plugged-in VBD device\n\n    Ubuntu Maverick moved xvd? -> sd?. This is considered a bug and will be\n    fixed in future versions:\n        https://bugs.launchpad.net/ubuntu/+source/linux/+bug/684875\n\n    For now, we work around it by just doing a string replace.\n    """'
newline|'\n'
comment|'# NOTE(sirp): This hack can go away when we pull support for Maverick'
nl|'\n'
name|'should_remap'
op|'='
name|'FLAGS'
op|'.'
name|'xenapi_remap_vbd_dev'
newline|'\n'
name|'if'
name|'not'
name|'should_remap'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'dev'
newline|'\n'
nl|'\n'
dedent|''
name|'old_prefix'
op|'='
string|"'xvd'"
newline|'\n'
name|'new_prefix'
op|'='
name|'FLAGS'
op|'.'
name|'xenapi_remap_vbd_dev_prefix'
newline|'\n'
name|'remapped_dev'
op|'='
name|'dev'
op|'.'
name|'replace'
op|'('
name|'old_prefix'
op|','
name|'new_prefix'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'remapped_dev'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_wait_for_device
dedent|''
name|'def'
name|'_wait_for_device'
op|'('
name|'dev'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Wait for device node to appear"""'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'xrange'
op|'('
number|'0'
op|','
name|'FLAGS'
op|'.'
name|'block_device_creation_timeout'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'dev_path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'time'
op|'.'
name|'sleep'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'raise'
name|'volume_utils'
op|'.'
name|'StorageError'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Timeout waiting for device %s to be created'"
op|')'
op|'%'
name|'dev'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|cleanup_attached_vdis
dedent|''
name|'def'
name|'cleanup_attached_vdis'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Unplug any instance VDIs left after an unclean restart"""'
newline|'\n'
name|'this_vm_ref'
op|'='
name|'_get_this_vm_ref'
op|'('
name|'session'
op|')'
newline|'\n'
nl|'\n'
name|'vbd_refs'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VM.get_VBDs'"
op|','
name|'this_vm_ref'
op|')'
newline|'\n'
name|'for'
name|'vbd_ref'
name|'in'
name|'vbd_refs'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'vbd_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VBD.get_record'"
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'vdi_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_record'"
op|','
name|'vbd_rec'
op|'['
string|"'VDI'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|','
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'e'
op|'.'
name|'details'
op|'['
number|'0'
op|']'
op|'!='
string|"'HANDLE_INVALID'"
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
dedent|''
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
string|"'nova_instance_uuid'"
name|'in'
name|'vdi_rec'
op|'['
string|"'other_config'"
op|']'
op|':'
newline|'\n'
comment|'# Belongs to an instance and probably left over after an'
nl|'\n'
comment|'# unclean restart'
nl|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'Disconnecting stale VDI %s from compute domU'"
op|')'
op|','
nl|'\n'
name|'vdi_rec'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
name|'unplug_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'destroy_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
op|'@'
name|'contextlib'
op|'.'
name|'contextmanager'
newline|'\n'
DECL|function|vdi_attached_here
name|'def'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'this_vm_ref'
op|'='
name|'_get_this_vm_ref'
op|'('
name|'session'
op|')'
newline|'\n'
nl|'\n'
name|'vbd_ref'
op|'='
name|'create_vbd'
op|'('
name|'session'
op|','
name|'this_vm_ref'
op|','
name|'vdi_ref'
op|','
string|"'autodetect'"
op|','
nl|'\n'
name|'read_only'
op|'='
name|'read_only'
op|','
name|'bootable'
op|'='
name|'False'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Plugging VBD %s ... '"
op|')'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VBD.plug"'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Plugging VBD %s done.'"
op|')'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'orig_dev'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VBD.get_device"'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'VBD %(vbd_ref)s plugged as %(orig_dev)s'"
op|')'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
name|'dev'
op|'='
name|'_remap_vbd_dev'
op|'('
name|'orig_dev'
op|')'
newline|'\n'
name|'if'
name|'dev'
op|'!='
name|'orig_dev'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'VBD %(vbd_ref)s plugged into wrong dev, '"
nl|'\n'
string|"'remapping to %(dev)s'"
op|')'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'_wait_for_device'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'yield'
name|'dev'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Destroying VBD for VDI %s ... '"
op|')'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'unplug_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'destroy_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'volume_utils'
op|'.'
name|'StorageError'
op|':'
newline|'\n'
comment|'# destroy_vbd() will log error'
nl|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Destroying VBD for VDI %s done.'"
op|')'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_this_vm_uuid
dedent|''
dedent|''
name|'def'
name|'get_this_vm_uuid'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
name|'with'
name|'file'
op|'('
string|"'/sys/hypervisor/uuid'"
op|')'
name|'as'
name|'f'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'f'
op|'.'
name|'readline'
op|'('
op|')'
op|'.'
name|'strip'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_this_vm_ref
dedent|''
dedent|''
name|'def'
name|'_get_this_vm_ref'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'return'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_by_uuid"'
op|','
name|'get_this_vm_uuid'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_is_vdi_pv
dedent|''
name|'def'
name|'_is_vdi_pv'
op|'('
name|'dev'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Running pygrub against %s"'
op|')'
op|','
name|'dev'
op|')'
newline|'\n'
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'output'
op|'='
name|'os'
op|'.'
name|'popen'
op|'('
string|"'pygrub -qn %s'"
op|'%'
name|'dev_path'
op|')'
newline|'\n'
name|'for'
name|'line'
name|'in'
name|'output'
op|'.'
name|'readlines'
op|'('
op|')'
op|':'
newline|'\n'
comment|'#try to find kernel string'
nl|'\n'
indent|'        '
name|'m'
op|'='
name|'re'
op|'.'
name|'search'
op|'('
string|"'(?<=kernel:)/.*(?:>)'"
op|','
name|'line'
op|')'
newline|'\n'
name|'if'
name|'m'
name|'and'
name|'m'
op|'.'
name|'group'
op|'('
number|'0'
op|')'
op|'.'
name|'find'
op|'('
string|"'xen'"
op|')'
op|'!='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Found Xen kernel %s"'
op|')'
op|'%'
name|'m'
op|'.'
name|'group'
op|'('
number|'0'
op|')'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"No Xen kernel found.  Booting HVM."'
op|')'
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_partitions
dedent|''
name|'def'
name|'_get_partitions'
op|'('
name|'dev'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return partition information (num, size, type) for a device."""'
newline|'\n'
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'out'
op|','
name|'_err'
op|'='
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'parted'"
op|','
string|"'--script'"
op|','
string|"'--machine'"
op|','
nl|'\n'
name|'dev_path'
op|','
string|"'unit s'"
op|','
string|"'print'"
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
name|'lines'
op|'='
op|'['
name|'line'
name|'for'
name|'line'
name|'in'
name|'out'
op|'.'
name|'split'
op|'('
string|"'\\n'"
op|')'
name|'if'
name|'line'
op|']'
newline|'\n'
name|'partitions'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Partitions:"'
op|')'
op|')'
newline|'\n'
name|'for'
name|'line'
name|'in'
name|'lines'
op|'['
number|'2'
op|':'
op|']'
op|':'
newline|'\n'
indent|'        '
name|'num'
op|','
name|'start'
op|','
name|'end'
op|','
name|'size'
op|','
name|'ptype'
op|'='
name|'line'
op|'.'
name|'split'
op|'('
string|"':'"
op|')'
op|'['
op|':'
number|'5'
op|']'
newline|'\n'
name|'start'
op|'='
name|'int'
op|'('
name|'start'
op|'.'
name|'rstrip'
op|'('
string|"'s'"
op|')'
op|')'
newline|'\n'
name|'end'
op|'='
name|'int'
op|'('
name|'end'
op|'.'
name|'rstrip'
op|'('
string|"'s'"
op|')'
op|')'
newline|'\n'
name|'size'
op|'='
name|'int'
op|'('
name|'size'
op|'.'
name|'rstrip'
op|'('
string|"'s'"
op|')'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"  %(num)s: %(ptype)s %(size)d sectors"'
op|')'
op|'%'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
name|'partitions'
op|'.'
name|'append'
op|'('
op|'('
name|'num'
op|','
name|'start'
op|','
name|'size'
op|','
name|'ptype'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'partitions'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_stream_disk
dedent|''
name|'def'
name|'_stream_disk'
op|'('
name|'image_service_func'
op|','
name|'image_type'
op|','
name|'virtual_size'
op|','
name|'dev'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'offset'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK'
op|':'
newline|'\n'
indent|'        '
name|'offset'
op|'='
name|'MBR_SIZE_BYTES'
newline|'\n'
name|'_write_partition'
op|'('
name|'virtual_size'
op|','
name|'dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
nl|'\n'
name|'with'
name|'utils'
op|'.'
name|'temporary_chown'
op|'('
name|'dev_path'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'open'
op|'('
name|'dev_path'
op|','
string|"'wb'"
op|')'
name|'as'
name|'f'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'.'
name|'seek'
op|'('
name|'offset'
op|')'
newline|'\n'
name|'image_service_func'
op|'('
name|'f'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_write_partition
dedent|''
dedent|''
dedent|''
name|'def'
name|'_write_partition'
op|'('
name|'virtual_size'
op|','
name|'dev'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'primary_first'
op|'='
name|'MBR_SIZE_SECTORS'
newline|'\n'
name|'primary_last'
op|'='
name|'MBR_SIZE_SECTORS'
op|'+'
op|'('
name|'virtual_size'
op|'/'
name|'SECTOR_SIZE'
op|')'
op|'-'
number|'1'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Writing partition table %(primary_first)d %(primary_last)d'"
nl|'\n'
string|"' to %(dev_path)s...'"
op|')'
op|','
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|execute
name|'def'
name|'execute'
op|'('
op|'*'
name|'cmd'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'utils'
op|'.'
name|'execute'
op|'('
op|'*'
name|'cmd'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'execute'
op|'('
string|"'parted'"
op|','
string|"'--script'"
op|','
name|'dev_path'
op|','
string|"'mklabel'"
op|','
string|"'msdos'"
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
name|'execute'
op|'('
string|"'parted'"
op|','
string|"'--script'"
op|','
name|'dev_path'
op|','
string|"'mkpart'"
op|','
string|"'primary'"
op|','
nl|'\n'
string|"'%ds'"
op|'%'
name|'primary_first'
op|','
nl|'\n'
string|"'%ds'"
op|'%'
name|'primary_last'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Writing partition table %s done.'"
op|')'
op|','
name|'dev_path'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_resize_part_and_fs
dedent|''
name|'def'
name|'_resize_part_and_fs'
op|'('
name|'dev'
op|','
name|'start'
op|','
name|'old_sectors'
op|','
name|'new_sectors'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Resize partition and fileystem.\n\n    This assumes we are dealing with a single primary partition and using\n    ext3 or ext4.\n    """'
newline|'\n'
name|'size'
op|'='
name|'new_sectors'
op|'-'
name|'start'
newline|'\n'
name|'end'
op|'='
name|'new_sectors'
op|'-'
number|'1'
newline|'\n'
nl|'\n'
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'partition_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|','
name|'partition'
op|'='
number|'1'
op|')'
newline|'\n'
nl|'\n'
comment|"# Replay journal if FS wasn't cleanly unmounted"
nl|'\n'
comment|'# Exit Code 1 = File system errors corrected'
nl|'\n'
comment|'#           2 = File system errors corrected, system needs a reboot'
nl|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'e2fsck'"
op|','
string|"'-f'"
op|','
string|"'-y'"
op|','
name|'partition_path'
op|','
name|'run_as_root'
op|'='
name|'True'
op|','
nl|'\n'
name|'check_exit_code'
op|'='
op|'['
number|'0'
op|','
number|'1'
op|','
number|'2'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Remove ext3 journal (making it ext2)'
nl|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'tune2fs'"
op|','
string|"'-O ^has_journal'"
op|','
name|'partition_path'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'new_sectors'
op|'<'
name|'old_sectors'
op|':'
newline|'\n'
comment|'# Resizing down, resize filesystem before partition resize'
nl|'\n'
indent|'        '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'resize2fs'"
op|','
name|'partition_path'
op|','
string|"'%ds'"
op|'%'
name|'size'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'parted'"
op|','
string|"'--script'"
op|','
name|'dev_path'
op|','
string|"'rm'"
op|','
string|"'1'"
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'parted'"
op|','
string|"'--script'"
op|','
name|'dev_path'
op|','
string|"'mkpart'"
op|','
nl|'\n'
string|"'primary'"
op|','
nl|'\n'
string|"'%ds'"
op|'%'
name|'start'
op|','
nl|'\n'
string|"'%ds'"
op|'%'
name|'end'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'new_sectors'
op|'>'
name|'old_sectors'
op|':'
newline|'\n'
comment|'# Resizing up, resize filesystem after partition resize'
nl|'\n'
indent|'        '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'resize2fs'"
op|','
name|'partition_path'
op|','
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
comment|'# Add back journal'
nl|'\n'
dedent|''
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'tune2fs'"
op|','
string|"'-j'"
op|','
name|'partition_path'
op|','
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_sparse_copy
dedent|''
name|'def'
name|'_sparse_copy'
op|'('
name|'src_path'
op|','
name|'dst_path'
op|','
name|'virtual_size'
op|','
name|'block_size'
op|'='
number|'4096'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Copy data, skipping long runs of zeros to create a sparse file."""'
newline|'\n'
name|'start_time'
op|'='
name|'time'
op|'.'
name|'time'
op|'('
op|')'
newline|'\n'
name|'EMPTY_BLOCK'
op|'='
string|"'\\0'"
op|'*'
name|'block_size'
newline|'\n'
name|'bytes_read'
op|'='
number|'0'
newline|'\n'
name|'skipped_bytes'
op|'='
number|'0'
newline|'\n'
name|'left'
op|'='
name|'virtual_size'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Starting sparse_copy src=%(src_path)s dst=%(dst_path)s "'
nl|'\n'
string|'"virtual_size=%(virtual_size)d block_size=%(block_size)d"'
op|')'
op|','
nl|'\n'
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|"# NOTE(sirp): we need read/write access to the devices; since we don't have"
nl|'\n'
comment|"# the luxury of shelling out to a sudo'd command, we temporarily take"
nl|'\n'
comment|'# ownership of the devices.'
nl|'\n'
name|'with'
name|'utils'
op|'.'
name|'temporary_chown'
op|'('
name|'src_path'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'utils'
op|'.'
name|'temporary_chown'
op|'('
name|'dst_path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'open'
op|'('
name|'src_path'
op|','
string|'"r"'
op|')'
name|'as'
name|'src'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'open'
op|'('
name|'dst_path'
op|','
string|'"w"'
op|')'
name|'as'
name|'dst'
op|':'
newline|'\n'
indent|'                    '
name|'data'
op|'='
name|'src'
op|'.'
name|'read'
op|'('
name|'min'
op|'('
name|'block_size'
op|','
name|'left'
op|')'
op|')'
newline|'\n'
name|'while'
name|'data'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'data'
op|'=='
name|'EMPTY_BLOCK'
op|':'
newline|'\n'
indent|'                            '
name|'dst'
op|'.'
name|'seek'
op|'('
name|'block_size'
op|','
name|'os'
op|'.'
name|'SEEK_CUR'
op|')'
newline|'\n'
name|'left'
op|'-='
name|'block_size'
newline|'\n'
name|'bytes_read'
op|'+='
name|'block_size'
newline|'\n'
name|'skipped_bytes'
op|'+='
name|'block_size'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                            '
name|'dst'
op|'.'
name|'write'
op|'('
name|'data'
op|')'
newline|'\n'
name|'data_len'
op|'='
name|'len'
op|'('
name|'data'
op|')'
newline|'\n'
name|'left'
op|'-='
name|'data_len'
newline|'\n'
name|'bytes_read'
op|'+='
name|'data_len'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'left'
op|'<='
number|'0'
op|':'
newline|'\n'
indent|'                            '
name|'break'
newline|'\n'
nl|'\n'
dedent|''
name|'data'
op|'='
name|'src'
op|'.'
name|'read'
op|'('
name|'min'
op|'('
name|'block_size'
op|','
name|'left'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'duration'
op|'='
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|'-'
name|'start_time'
newline|'\n'
name|'compression_pct'
op|'='
name|'float'
op|'('
name|'skipped_bytes'
op|')'
op|'/'
name|'bytes_read'
op|'*'
number|'100'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Finished sparse_copy in %(duration).2f secs, "'
nl|'\n'
string|'"%(compression_pct).2f%% reduction in size"'
op|')'
op|','
name|'locals'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_copy_partition
dedent|''
name|'def'
name|'_copy_partition'
op|'('
name|'session'
op|','
name|'src_ref'
op|','
name|'dst_ref'
op|','
name|'partition'
op|','
name|'virtual_size'
op|')'
op|':'
newline|'\n'
comment|'# Part of disk taken up by MBR'
nl|'\n'
indent|'    '
name|'virtual_size'
op|'-='
name|'MBR_SIZE_BYTES'
newline|'\n'
nl|'\n'
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'src_ref'
op|','
name|'read_only'
op|'='
name|'True'
op|')'
name|'as'
name|'src'
op|':'
newline|'\n'
indent|'        '
name|'src_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'src'
op|','
name|'partition'
op|'='
name|'partition'
op|')'
newline|'\n'
nl|'\n'
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'dst_ref'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
name|'as'
name|'dst'
op|':'
newline|'\n'
indent|'            '
name|'dst_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dst'
op|','
name|'partition'
op|'='
name|'partition'
op|')'
newline|'\n'
nl|'\n'
name|'_write_partition'
op|'('
name|'virtual_size'
op|','
name|'dst'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'FLAGS'
op|'.'
name|'xenapi_sparse_copy'
op|':'
newline|'\n'
indent|'                '
name|'_sparse_copy'
op|'('
name|'src_path'
op|','
name|'dst_path'
op|','
name|'virtual_size'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'num_blocks'
op|'='
name|'virtual_size'
op|'/'
name|'SECTOR_SIZE'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'dd'"
op|','
nl|'\n'
string|"'if=%s'"
op|'%'
name|'src_path'
op|','
nl|'\n'
string|"'of=%s'"
op|'%'
name|'dst_path'
op|','
nl|'\n'
string|"'count=%d'"
op|'%'
name|'num_blocks'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_mount_filesystem
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_mount_filesystem'
op|'('
name|'dev_path'
op|','
name|'dir'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""mounts the device specified by dev_path in dir"""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'_out'
op|','
name|'err'
op|'='
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mount'"
op|','
nl|'\n'
string|"'-t'"
op|','
string|"'ext2,ext3,ext4,reiserfs'"
op|','
nl|'\n'
name|'dev_path'
op|','
name|'dir'
op|','
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'ProcessExecutionError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'err'
op|'='
name|'str'
op|'('
name|'e'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'err'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_find_guest_agent
dedent|''
name|'def'
name|'_find_guest_agent'
op|'('
name|'base_dir'
op|','
name|'agent_rel_path'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    tries to locate a guest agent at the path\n    specificed by agent_rel_path\n    """'
newline|'\n'
name|'agent_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'base_dir'
op|','
name|'agent_rel_path'
op|')'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'isfile'
op|'('
name|'agent_path'
op|')'
op|':'
newline|'\n'
comment|'# The presence of the guest agent'
nl|'\n'
comment|'# file indicates that this instance can'
nl|'\n'
comment|'# reconfigure the network from xenstore data,'
nl|'\n'
comment|'# so manipulation of files in /etc is not'
nl|'\n'
comment|'# required'
nl|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'XenServer tools installed in this '"
nl|'\n'
string|"'image are capable of network injection.  '"
nl|'\n'
string|"'Networking files will not be'"
nl|'\n'
string|"'manipulated'"
op|')'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'xe_daemon_filename'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'base_dir'
op|','
nl|'\n'
string|"'usr'"
op|','
string|"'sbin'"
op|','
string|"'xe-daemon'"
op|')'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'isfile'
op|'('
name|'xe_daemon_filename'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'XenServer tools are present '"
nl|'\n'
string|"'in this image but are not capable '"
nl|'\n'
string|"'of network injection'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'XenServer tools are not '"
nl|'\n'
string|"'installed in this image'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_mounted_processing
dedent|''
name|'def'
name|'_mounted_processing'
op|'('
name|'device'
op|','
name|'key'
op|','
name|'net'
op|','
name|'metadata'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Callback which runs with the image VDI attached"""'
newline|'\n'
comment|'# NB: Partition 1 hardcoded'
nl|'\n'
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'device'
op|','
name|'partition'
op|'='
number|'1'
op|')'
newline|'\n'
name|'with'
name|'utils'
op|'.'
name|'tempdir'
op|'('
op|')'
name|'as'
name|'tmpdir'
op|':'
newline|'\n'
comment|'# Mount only Linux filesystems, to avoid disturbing NTFS images'
nl|'\n'
indent|'        '
name|'err'
op|'='
name|'_mount_filesystem'
op|'('
name|'dev_path'
op|','
name|'tmpdir'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
comment|'# This try block ensures that the umount occurs'
nl|'\n'
indent|'                '
name|'if'
name|'not'
name|'_find_guest_agent'
op|'('
name|'tmpdir'
op|','
name|'FLAGS'
op|'.'
name|'xenapi_agent_path'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'Manipulating interface files directly'"
op|')'
op|')'
newline|'\n'
comment|"# for xenapi, we don't 'inject' admin_password here,"
nl|'\n'
comment|"# it's handled at instance startup time, nor do we"
nl|'\n'
comment|'# support injecting arbitrary files here.'
nl|'\n'
name|'disk'
op|'.'
name|'inject_data_into_fs'
op|'('
name|'tmpdir'
op|','
nl|'\n'
name|'key'
op|','
name|'net'
op|','
name|'metadata'
op|','
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'                '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'umount'"
op|','
name|'dev_path'
op|','
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'Failed to mount filesystem (expected for '"
nl|'\n'
string|"'non-linux instances): %s'"
op|')'
op|'%'
name|'err'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_prepare_injectables
dedent|''
dedent|''
dedent|''
name|'def'
name|'_prepare_injectables'
op|'('
name|'inst'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    prepares the ssh key and the network configuration file to be\n    injected into the disk image\n    """'
newline|'\n'
comment|'#do the import here - Cheetah.Template will be loaded'
nl|'\n'
comment|'#only if injection is performed'
nl|'\n'
name|'from'
name|'Cheetah'
name|'import'
name|'Template'
name|'as'
name|'t'
newline|'\n'
name|'template'
op|'='
name|'t'
op|'.'
name|'Template'
newline|'\n'
name|'template_data'
op|'='
name|'open'
op|'('
name|'FLAGS'
op|'.'
name|'injected_network_template'
op|')'
op|'.'
name|'read'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'metadata'
op|'='
name|'inst'
op|'['
string|"'metadata'"
op|']'
newline|'\n'
name|'key'
op|'='
name|'str'
op|'('
name|'inst'
op|'['
string|"'key_data'"
op|']'
op|')'
newline|'\n'
name|'net'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'network_info'
op|':'
newline|'\n'
indent|'        '
name|'ifc_num'
op|'='
op|'-'
number|'1'
newline|'\n'
name|'interfaces_info'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
indent|'            '
name|'ifc_num'
op|'+='
number|'1'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'not'
name|'vif'
op|'['
string|"'network'"
op|']'
op|'.'
name|'get_meta'
op|'('
string|"'injected'"
op|')'
op|':'
newline|'\n'
comment|'# network is not specified injected'
nl|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
comment|'# vif network is None'
nl|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
comment|'# NOTE(tr3buchet): using all subnets in case dns is stored in a'
nl|'\n'
comment|"#                  subnet that isn't chosen as first v4 or v6"
nl|'\n'
comment|'#                  subnet in the case where there is more than one'
nl|'\n'
comment|'# dns = list of address of each dns entry from each vif subnet'
nl|'\n'
dedent|''
name|'dns'
op|'='
op|'['
name|'ip'
op|'['
string|"'address'"
op|']'
name|'for'
name|'subnet'
name|'in'
name|'vif'
op|'['
string|"'network'"
op|']'
op|'['
string|"'subnets'"
op|']'
nl|'\n'
name|'for'
name|'ip'
name|'in'
name|'subnet'
op|'['
string|"'dns'"
op|']'
op|']'
newline|'\n'
name|'dns'
op|'='
string|"' '"
op|'.'
name|'join'
op|'('
name|'dns'
op|')'
op|'.'
name|'strip'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'interface_info'
op|'='
op|'{'
string|"'name'"
op|':'
string|"'eth%d'"
op|'%'
name|'ifc_num'
op|','
nl|'\n'
string|"'address'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'netmask'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'gateway'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'broadcast'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'dns'"
op|':'
name|'dns'
name|'or'
string|"''"
op|','
nl|'\n'
string|"'address_v6'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'netmask_v6'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'gateway_v6'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'use_ipv6'"
op|':'
name|'FLAGS'
op|'.'
name|'use_ipv6'
op|'}'
newline|'\n'
nl|'\n'
comment|'# NOTE(tr3buchet): the original code used the old network_info'
nl|'\n'
comment|'#                  which only supported a single ipv4 subnet'
nl|'\n'
comment|'#                  (and optionally, a single ipv6 subnet).'
nl|'\n'
comment|'#                  I modified it to use the new network info model,'
nl|'\n'
comment|'#                  which adds support for multiple v4 or v6'
nl|'\n'
comment|'#                  subnets. I chose to ignore any additional'
nl|'\n'
comment|'#                  subnets, just as the original code ignored'
nl|'\n'
comment|'#                  additional IP information'
nl|'\n'
nl|'\n'
comment|'# populate v4 info if v4 subnet and ip exist'
nl|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# grab the first v4 subnet (or it raises)'
nl|'\n'
indent|'                '
name|'subnet'
op|'='
op|'['
name|'s'
name|'for'
name|'s'
name|'in'
name|'vif'
op|'['
string|"'network'"
op|']'
op|'['
string|"'subnets'"
op|']'
nl|'\n'
name|'if'
name|'s'
op|'['
string|"'version'"
op|']'
op|'=='
number|'4'
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
comment|"# get the subnet's first ip (or it raises)"
nl|'\n'
name|'ip'
op|'='
name|'subnet'
op|'['
string|"'ips'"
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
comment|'# populate interface_info'
nl|'\n'
name|'subnet_netaddr'
op|'='
name|'subnet'
op|'.'
name|'as_netaddr'
op|'('
op|')'
newline|'\n'
name|'interface_info'
op|'['
string|"'address'"
op|']'
op|'='
name|'ip'
op|'['
string|"'address'"
op|']'
newline|'\n'
name|'interface_info'
op|'['
string|"'netmask'"
op|']'
op|'='
name|'subnet_netaddr'
op|'.'
name|'netmask'
newline|'\n'
name|'interface_info'
op|'['
string|"'gateway'"
op|']'
op|'='
name|'subnet'
op|'['
string|"'gateway'"
op|']'
op|'['
string|"'address'"
op|']'
newline|'\n'
name|'interface_info'
op|'['
string|"'broadcast'"
op|']'
op|'='
name|'subnet_netaddr'
op|'.'
name|'broadcast'
newline|'\n'
dedent|''
name|'except'
name|'IndexError'
op|':'
newline|'\n'
comment|"# there isn't a v4 subnet or there are no ips"
nl|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
comment|'# populate v6 info if v6 subnet and ip exist'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
comment|'# grab the first v6 subnet (or it raises)'
nl|'\n'
indent|'                '
name|'subnet'
op|'='
op|'['
name|'s'
name|'for'
name|'s'
name|'in'
name|'vif'
op|'['
string|"'network'"
op|']'
op|'['
string|"'subnets'"
op|']'
nl|'\n'
name|'if'
name|'s'
op|'['
string|"'version'"
op|']'
op|'=='
number|'6'
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
comment|"# get the subnet's first ip (or it raises)"
nl|'\n'
name|'ip'
op|'='
name|'subnet'
op|'['
string|"'ips'"
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
comment|'# populate interface_info'
nl|'\n'
name|'interface_info'
op|'['
string|"'address_v6'"
op|']'
op|'='
name|'ip'
op|'['
string|"'address'"
op|']'
newline|'\n'
name|'interface_info'
op|'['
string|"'netmask_v6'"
op|']'
op|'='
name|'subnet'
op|'.'
name|'as_netaddr'
op|'('
op|')'
op|'.'
name|'netmask'
newline|'\n'
name|'interface_info'
op|'['
string|"'gateway_v6'"
op|']'
op|'='
name|'subnet'
op|'['
string|"'gateway'"
op|']'
op|'['
string|"'address'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'IndexError'
op|':'
newline|'\n'
comment|"# there isn't a v6 subnet or there are no ips"
nl|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
dedent|''
name|'interfaces_info'
op|'.'
name|'append'
op|'('
name|'interface_info'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'interfaces_info'
op|':'
newline|'\n'
indent|'            '
name|'net'
op|'='
name|'str'
op|'('
name|'template'
op|'('
name|'template_data'
op|','
nl|'\n'
name|'searchList'
op|'='
op|'['
op|'{'
string|"'interfaces'"
op|':'
name|'interfaces_info'
op|','
nl|'\n'
string|"'use_ipv6'"
op|':'
name|'FLAGS'
op|'.'
name|'use_ipv6'
op|'}'
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'key'
op|','
name|'net'
op|','
name|'metadata'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|ensure_correct_host
dedent|''
name|'def'
name|'ensure_correct_host'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Ensure we\'re connected to the host we\'re running on. This is the\n    required configuration for anything that uses vdi_attached_here."""'
newline|'\n'
name|'this_vm_uuid'
op|'='
name|'get_this_vm_uuid'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VM.get_by_uuid'"
op|','
name|'this_vm_uuid'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'exc'
op|'.'
name|'details'
op|'['
number|'0'
op|']'
op|'!='
string|"'UUID_INVALID'"
op|':'
newline|'\n'
indent|'            '
name|'raise'
newline|'\n'
dedent|''
name|'raise'
name|'Exception'
op|'('
name|'_'
op|'('
string|"'This domU must be running on the host '"
nl|'\n'
string|"'specified by xenapi_connection_url'"
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|move_disks
dedent|''
dedent|''
name|'def'
name|'move_disks'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'disk_info'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Move and possibly link VHDs via the XAPI plugin."""'
newline|'\n'
name|'imported_vhds'
op|'='
name|'session'
op|'.'
name|'call_plugin_serialized'
op|'('
nl|'\n'
string|"'migration'"
op|','
string|"'move_vhds_into_sr'"
op|','
name|'instance_uuid'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
name|'sr_path'
op|'='
name|'get_sr_path'
op|'('
name|'session'
op|')'
op|','
name|'uuid_stack'
op|'='
name|'_make_uuid_stack'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Now we rescan the SR so we find the VHDs'
nl|'\n'
name|'scan_default_sr'
op|'('
name|'session'
op|')'
newline|'\n'
nl|'\n'
comment|'# Set name-label so we can find if we need to clean up a failed'
nl|'\n'
comment|'# migration'
nl|'\n'
name|'root_uuid'
op|'='
name|'imported_vhds'
op|'['
string|"'root'"
op|']'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'set_vdi_name'
op|'('
name|'session'
op|','
name|'root_uuid'
op|','
name|'instance'
op|'['
string|"'name'"
op|']'
op|','
string|"'root'"
op|')'
newline|'\n'
nl|'\n'
name|'root_vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_by_uuid'"
op|','
name|'root_uuid'
op|')'
newline|'\n'
nl|'\n'
name|'return'
op|'{'
string|"'uuid'"
op|':'
name|'root_uuid'
op|','
string|"'ref'"
op|':'
name|'root_vdi_ref'
op|'}'
newline|'\n'
dedent|''
endmarker|''
end_unit
