begin_unit
comment|'# vim: tabstop=4 shiftwidth=4 softtabstop=4'
nl|'\n'
nl|'\n'
comment|'# Copyright (c) 2010 Citrix Systems, Inc.'
nl|'\n'
comment|'# Copyright 2011 Piston Cloud Computing, Inc.'
nl|'\n'
comment|'# Copyright 2012 OpenStack Foundation'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
nl|'\n'
string|'"""\nHelper methods for operations related to the management of VM records and\ntheir attributes like VDIs, VIFs, as well as their lookup functions.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'contextlib'
newline|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'re'
newline|'\n'
name|'import'
name|'time'
newline|'\n'
name|'import'
name|'urllib'
newline|'\n'
name|'import'
name|'urlparse'
newline|'\n'
name|'import'
name|'uuid'
newline|'\n'
name|'from'
name|'xml'
op|'.'
name|'parsers'
name|'import'
name|'expat'
newline|'\n'
nl|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'greenthread'
newline|'\n'
name|'from'
name|'oslo'
op|'.'
name|'config'
name|'import'
name|'cfg'
newline|'\n'
nl|'\n'
name|'from'
name|'nova'
op|'.'
name|'api'
op|'.'
name|'metadata'
name|'import'
name|'base'
name|'as'
name|'instance_metadata'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'block_device'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'flavors'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'power_state'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'task_states'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'exception'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'network'
name|'import'
name|'model'
name|'as'
name|'network_model'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'excutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
op|'.'
name|'gettextutils'
name|'import'
name|'_'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'importutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'log'
name|'as'
name|'logging'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'processutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'strutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'timeutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'xmlutils'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'utils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'configdrive'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'disk'
name|'import'
name|'api'
name|'as'
name|'disk'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'disk'
op|'.'
name|'vfs'
name|'import'
name|'localfs'
name|'as'
name|'vfsimpl'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'xenapi'
name|'import'
name|'agent'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'xenapi'
op|'.'
name|'image'
name|'import'
name|'utils'
name|'as'
name|'image_utils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'xenapi'
name|'import'
name|'volume_utils'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|LOG
name|'LOG'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|xenapi_vm_utils_opts
name|'xenapi_vm_utils_opts'
op|'='
op|'['
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'cache_images'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'all'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Cache glance images locally. `all` will cache all'"
nl|'\n'
string|"' images, `some` will only cache images that have the'"
nl|'\n'
string|"' image_property `cache_in_nova=True`, and `none` turns'"
nl|'\n'
string|"' off caching entirely'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'xenapi_image_compression_level'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Compression level for images, e.g., 9 for gzip -9.'"
nl|'\n'
string|"' Range is 1-9, 9 being most compressed but most CPU'"
nl|'\n'
string|"' intensive on dom0.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'default_os_type'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'linux'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Default OS type'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'block_device_creation_timeout'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'10'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Time to wait for a block device to be created'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'max_kernel_ramdisk_size'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'16'
op|'*'
number|'1024'
op|'*'
number|'1024'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Maximum size in bytes of kernel or ramdisk images'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'sr_matching_filter'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'default-sr:true'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Filter for finding the SR to be used to install guest '"
nl|'\n'
string|"'instances on. To use the Local Storage in default '"
nl|'\n'
string|"'XenServer/XCP installations set this flag to '"
nl|'\n'
string|"'other-config:i18n-key=local-storage. To select an SR '"
nl|'\n'
string|"'with a different matching criteria, you could set it to '"
nl|'\n'
string|"'other-config:my_favorite_sr=true. On the other hand, to '"
nl|'\n'
string|"'fall back on the Default SR, as displayed by XenCenter, '"
nl|'\n'
string|"'set this flag to: default-sr:true'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'BoolOpt'
op|'('
string|"'xenapi_sparse_copy'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
name|'True'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Whether to use sparse_copy for copying data on a '"
nl|'\n'
string|"'resize down (False will use standard dd). This speeds '"
nl|'\n'
string|"'up resizes down considerably since large runs of zeros '"
nl|'\n'
string|"'won\\'t have to be rsynced'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'xenapi_num_vbd_unplug_retries'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'10'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Maximum number of retries to unplug VBD'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'xenapi_torrent_images'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'none'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Whether or not to download images via Bit Torrent '"
nl|'\n'
string|"'(all|some|none).'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'xenapi_ipxe_network_name'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Name of network to use for booting iPXE ISOs'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'xenapi_ipxe_boot_menu_url'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'URL to the iPXE boot menu'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'xenapi_ipxe_mkisofs_cmd'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'mkisofs'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Name and optionally path of the tool used for '"
nl|'\n'
string|"'ISO image creation'"
op|')'
op|','
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
DECL|variable|CONF
name|'CONF'
op|'='
name|'cfg'
op|'.'
name|'CONF'
newline|'\n'
name|'CONF'
op|'.'
name|'register_opts'
op|'('
name|'xenapi_vm_utils_opts'
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'default_ephemeral_format'"
op|','
string|"'nova.virt.driver'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'use_cow_images'"
op|','
string|"'nova.virt.driver'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'glance_num_retries'"
op|','
string|"'nova.image.glance'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'use_ipv6'"
op|','
string|"'nova.netconf'"
op|')'
newline|'\n'
nl|'\n'
DECL|variable|XENAPI_POWER_STATE
name|'XENAPI_POWER_STATE'
op|'='
op|'{'
nl|'\n'
string|"'Halted'"
op|':'
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|','
nl|'\n'
string|"'Running'"
op|':'
name|'power_state'
op|'.'
name|'RUNNING'
op|','
nl|'\n'
string|"'Paused'"
op|':'
name|'power_state'
op|'.'
name|'PAUSED'
op|','
nl|'\n'
string|"'Suspended'"
op|':'
name|'power_state'
op|'.'
name|'SUSPENDED'
op|','
nl|'\n'
string|"'Crashed'"
op|':'
name|'power_state'
op|'.'
name|'CRASHED'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|SECTOR_SIZE
name|'SECTOR_SIZE'
op|'='
number|'512'
newline|'\n'
DECL|variable|MBR_SIZE_SECTORS
name|'MBR_SIZE_SECTORS'
op|'='
number|'63'
newline|'\n'
DECL|variable|MBR_SIZE_BYTES
name|'MBR_SIZE_BYTES'
op|'='
name|'MBR_SIZE_SECTORS'
op|'*'
name|'SECTOR_SIZE'
newline|'\n'
DECL|variable|KERNEL_DIR
name|'KERNEL_DIR'
op|'='
string|"'/boot/guest'"
newline|'\n'
DECL|variable|MAX_VDI_CHAIN_SIZE
name|'MAX_VDI_CHAIN_SIZE'
op|'='
number|'16'
newline|'\n'
DECL|variable|PROGRESS_INTERVAL_SECONDS
name|'PROGRESS_INTERVAL_SECONDS'
op|'='
number|'300'
newline|'\n'
nl|'\n'
comment|'# Fudge factor to allow for the VHD chain to be slightly larger than'
nl|'\n'
comment|'# the partitioned space. Otherwise, legitimate images near their'
nl|'\n'
comment|'# maximum allowed size can fail on build with InstanceDiskTypeTooSmall.'
nl|'\n'
DECL|variable|VHD_SIZE_CHECK_FUDGE_FACTOR_GB
name|'VHD_SIZE_CHECK_FUDGE_FACTOR_GB'
op|'='
number|'10'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ImageType
name|'class'
name|'ImageType'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Enumeration class for distinguishing different image types\n\n    | 0 - kernel image (goes on dom0\'s filesystem)\n    | 1 - ramdisk image (goes on dom0\'s filesystem)\n    | 2 - disk image (local SR, partitioned by objectstore plugin)\n    | 3 - raw disk image (local SR, NOT partitioned by plugin)\n    | 4 - vhd disk image (local SR, NOT inspected by XS, PV assumed for\n    |     linux, HVM assumed for Windows)\n    | 5 - ISO disk image (local SR, NOT partitioned by plugin)\n    | 6 - config drive\n    """'
newline|'\n'
nl|'\n'
DECL|variable|KERNEL
name|'KERNEL'
op|'='
number|'0'
newline|'\n'
DECL|variable|RAMDISK
name|'RAMDISK'
op|'='
number|'1'
newline|'\n'
DECL|variable|DISK
name|'DISK'
op|'='
number|'2'
newline|'\n'
DECL|variable|DISK_RAW
name|'DISK_RAW'
op|'='
number|'3'
newline|'\n'
DECL|variable|DISK_VHD
name|'DISK_VHD'
op|'='
number|'4'
newline|'\n'
DECL|variable|DISK_ISO
name|'DISK_ISO'
op|'='
number|'5'
newline|'\n'
DECL|variable|DISK_CONFIGDRIVE
name|'DISK_CONFIGDRIVE'
op|'='
number|'6'
newline|'\n'
DECL|variable|_ids
name|'_ids'
op|'='
op|'('
name|'KERNEL'
op|','
name|'RAMDISK'
op|','
name|'DISK'
op|','
name|'DISK_RAW'
op|','
name|'DISK_VHD'
op|','
name|'DISK_ISO'
op|','
nl|'\n'
name|'DISK_CONFIGDRIVE'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|KERNEL_STR
name|'KERNEL_STR'
op|'='
string|'"kernel"'
newline|'\n'
DECL|variable|RAMDISK_STR
name|'RAMDISK_STR'
op|'='
string|'"ramdisk"'
newline|'\n'
DECL|variable|DISK_STR
name|'DISK_STR'
op|'='
string|'"root"'
newline|'\n'
DECL|variable|DISK_RAW_STR
name|'DISK_RAW_STR'
op|'='
string|'"os_raw"'
newline|'\n'
DECL|variable|DISK_VHD_STR
name|'DISK_VHD_STR'
op|'='
string|'"vhd"'
newline|'\n'
DECL|variable|DISK_ISO_STR
name|'DISK_ISO_STR'
op|'='
string|'"iso"'
newline|'\n'
DECL|variable|DISK_CONFIGDRIVE_STR
name|'DISK_CONFIGDRIVE_STR'
op|'='
string|'"configdrive"'
newline|'\n'
DECL|variable|_strs
name|'_strs'
op|'='
op|'('
name|'KERNEL_STR'
op|','
name|'RAMDISK_STR'
op|','
name|'DISK_STR'
op|','
name|'DISK_RAW_STR'
op|','
name|'DISK_VHD_STR'
op|','
nl|'\n'
name|'DISK_ISO_STR'
op|','
name|'DISK_CONFIGDRIVE_STR'
op|')'
newline|'\n'
nl|'\n'
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|to_string
name|'def'
name|'to_string'
op|'('
name|'cls'
op|','
name|'image_type'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'dict'
op|'('
name|'zip'
op|'('
name|'cls'
op|'.'
name|'_ids'
op|','
name|'ImageType'
op|'.'
name|'_strs'
op|')'
op|')'
op|'.'
name|'get'
op|'('
name|'image_type'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'classmethod'
newline|'\n'
DECL|member|get_role
name|'def'
name|'get_role'
op|'('
name|'cls'
op|','
name|'image_type_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the role played by the image, based on its type."""'
newline|'\n'
name|'return'
op|'{'
nl|'\n'
name|'cls'
op|'.'
name|'KERNEL'
op|':'
string|"'kernel'"
op|','
nl|'\n'
name|'cls'
op|'.'
name|'RAMDISK'
op|':'
string|"'ramdisk'"
op|','
nl|'\n'
name|'cls'
op|'.'
name|'DISK'
op|':'
string|"'root'"
op|','
nl|'\n'
name|'cls'
op|'.'
name|'DISK_RAW'
op|':'
string|"'root'"
op|','
nl|'\n'
name|'cls'
op|'.'
name|'DISK_VHD'
op|':'
string|"'root'"
op|','
nl|'\n'
name|'cls'
op|'.'
name|'DISK_ISO'
op|':'
string|"'iso'"
op|','
nl|'\n'
name|'cls'
op|'.'
name|'DISK_CONFIGDRIVE'
op|':'
string|"'configdrive'"
nl|'\n'
op|'}'
op|'.'
name|'get'
op|'('
name|'image_type_id'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|create_vm
dedent|''
dedent|''
name|'def'
name|'create_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'kernel'
op|','
name|'ramdisk'
op|','
nl|'\n'
name|'use_pv_kernel'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Create a VM record.  Returns new VM reference.\n    the use_pv_kernel flag indicates whether the guest is HVM or PV\n\n    There are 3 scenarios:\n\n        1. Using paravirtualization, kernel passed in\n\n        2. Using paravirtualization, kernel within the image\n\n        3. Using hardware virtualization\n    """'
newline|'\n'
name|'instance_type'
op|'='
name|'flavors'
op|'.'
name|'extract_flavor'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'mem'
op|'='
name|'str'
op|'('
name|'long'
op|'('
name|'instance_type'
op|'['
string|"'memory_mb'"
op|']'
op|')'
op|'*'
number|'1024'
op|'*'
number|'1024'
op|')'
newline|'\n'
name|'vcpus'
op|'='
name|'str'
op|'('
name|'instance_type'
op|'['
string|"'vcpus'"
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'vcpu_weight'
op|'='
name|'instance_type'
op|'['
string|"'vcpu_weight'"
op|']'
newline|'\n'
name|'vcpu_params'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'if'
name|'vcpu_weight'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'vcpu_params'
op|'='
op|'{'
string|'"weight"'
op|':'
name|'str'
op|'('
name|'vcpu_weight'
op|')'
op|'}'
newline|'\n'
nl|'\n'
dedent|''
name|'rec'
op|'='
op|'{'
nl|'\n'
string|"'actions_after_crash'"
op|':'
string|"'destroy'"
op|','
nl|'\n'
string|"'actions_after_reboot'"
op|':'
string|"'restart'"
op|','
nl|'\n'
string|"'actions_after_shutdown'"
op|':'
string|"'destroy'"
op|','
nl|'\n'
string|"'affinity'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'blocked_operations'"
op|':'
op|'{'
op|'}'
op|','
nl|'\n'
string|"'ha_always_run'"
op|':'
name|'False'
op|','
nl|'\n'
string|"'ha_restart_priority'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'HVM_boot_params'"
op|':'
op|'{'
op|'}'
op|','
nl|'\n'
string|"'HVM_boot_policy'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'is_a_template'"
op|':'
name|'False'
op|','
nl|'\n'
string|"'memory_dynamic_min'"
op|':'
name|'mem'
op|','
nl|'\n'
string|"'memory_dynamic_max'"
op|':'
name|'mem'
op|','
nl|'\n'
string|"'memory_static_min'"
op|':'
string|"'0'"
op|','
nl|'\n'
string|"'memory_static_max'"
op|':'
name|'mem'
op|','
nl|'\n'
string|"'memory_target'"
op|':'
name|'mem'
op|','
nl|'\n'
string|"'name_description'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'name_label'"
op|':'
name|'name_label'
op|','
nl|'\n'
string|"'other_config'"
op|':'
op|'{'
string|"'nova_uuid'"
op|':'
name|'str'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
op|'}'
op|','
nl|'\n'
string|"'PCI_bus'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'platform'"
op|':'
op|'{'
string|"'acpi'"
op|':'
string|"'true'"
op|','
string|"'apic'"
op|':'
string|"'true'"
op|','
string|"'pae'"
op|':'
string|"'true'"
op|','
nl|'\n'
string|"'viridian'"
op|':'
string|"'true'"
op|','
string|"'timeoffset'"
op|':'
string|"'0'"
op|'}'
op|','
nl|'\n'
string|"'PV_args'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'PV_bootloader'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'PV_bootloader_args'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'PV_kernel'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'PV_legacy_args'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'PV_ramdisk'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'recommendations'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'tags'"
op|':'
op|'['
op|']'
op|','
nl|'\n'
string|"'user_version'"
op|':'
string|"'0'"
op|','
nl|'\n'
string|"'VCPUs_at_startup'"
op|':'
name|'vcpus'
op|','
nl|'\n'
string|"'VCPUs_max'"
op|':'
name|'vcpus'
op|','
nl|'\n'
string|"'VCPUs_params'"
op|':'
name|'vcpu_params'
op|','
nl|'\n'
string|"'xenstore_data'"
op|':'
op|'{'
string|"'allowvssprovider'"
op|':'
string|"'false'"
op|'}'
op|'}'
newline|'\n'
nl|'\n'
comment|'# Complete VM configuration record according to the image type'
nl|'\n'
comment|'# non-raw/raw with PV kernel/raw in HVM mode'
nl|'\n'
name|'if'
name|'use_pv_kernel'
op|':'
newline|'\n'
indent|'        '
name|'rec'
op|'['
string|"'platform'"
op|']'
op|'['
string|"'nx'"
op|']'
op|'='
string|"'false'"
newline|'\n'
name|'if'
name|'instance'
op|'['
string|"'kernel_id'"
op|']'
op|':'
newline|'\n'
comment|'# 1. Kernel explicitly passed in, use that'
nl|'\n'
indent|'            '
name|'rec'
op|'['
string|"'PV_args'"
op|']'
op|'='
string|"'root=/dev/xvda1'"
newline|'\n'
name|'rec'
op|'['
string|"'PV_kernel'"
op|']'
op|'='
name|'kernel'
newline|'\n'
name|'rec'
op|'['
string|"'PV_ramdisk'"
op|']'
op|'='
name|'ramdisk'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# 2. Use kernel within the image'
nl|'\n'
indent|'            '
name|'rec'
op|'['
string|"'PV_bootloader'"
op|']'
op|'='
string|"'pygrub'"
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# 3. Using hardware virtualization'
nl|'\n'
indent|'        '
name|'rec'
op|'['
string|"'platform'"
op|']'
op|'['
string|"'nx'"
op|']'
op|'='
string|"'true'"
newline|'\n'
name|'rec'
op|'['
string|"'HVM_boot_params'"
op|']'
op|'='
op|'{'
string|"'order'"
op|':'
string|"'dc'"
op|'}'
newline|'\n'
name|'rec'
op|'['
string|"'HVM_boot_policy'"
op|']'
op|'='
string|"'BIOS order'"
newline|'\n'
nl|'\n'
dedent|''
name|'vm_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VM.create'"
op|','
name|'rec'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Created VM'"
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'vm_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|destroy_vm
dedent|''
name|'def'
name|'destroy_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Destroys a VM record."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VM.destroy'"
op|','
name|'vm_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'exc'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"VM destroyed"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|clean_shutdown_vm
dedent|''
name|'def'
name|'clean_shutdown_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'is_vm_shutdown'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|'"VM already halted, skipping shutdown..."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Shutting down VM (cleanly)"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VM.clean_shutdown'"
op|','
name|'vm_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'exc'
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'return'
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|hard_shutdown_vm
dedent|''
name|'def'
name|'hard_shutdown_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'is_vm_shutdown'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|'"VM already halted, skipping shutdown..."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Shutting down VM (hard)"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VM.hard_shutdown'"
op|','
name|'vm_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'exc'
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'return'
name|'True'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|is_vm_shutdown
dedent|''
name|'def'
name|'is_vm_shutdown'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vm_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_record"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'state'
op|'='
name|'compile_info'
op|'('
name|'vm_rec'
op|')'
op|'['
string|"'state'"
op|']'
newline|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|ensure_free_mem
dedent|''
name|'def'
name|'ensure_free_mem'
op|'('
name|'session'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'instance_type'
op|'='
name|'flavors'
op|'.'
name|'extract_flavor'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'mem'
op|'='
name|'long'
op|'('
name|'instance_type'
op|'['
string|"'memory_mb'"
op|']'
op|')'
op|'*'
number|'1024'
op|'*'
number|'1024'
newline|'\n'
name|'host'
op|'='
name|'session'
op|'.'
name|'get_xenapi_host'
op|'('
op|')'
newline|'\n'
name|'host_free_mem'
op|'='
name|'long'
op|'('
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"host.compute_free_memory"'
op|','
nl|'\n'
name|'host'
op|')'
op|')'
newline|'\n'
name|'return'
name|'host_free_mem'
op|'>='
name|'mem'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|find_vbd_by_number
dedent|''
name|'def'
name|'find_vbd_by_number'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'number'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Get the VBD reference from the device number."""'
newline|'\n'
name|'vbd_refs'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_VBDs"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'if'
name|'vbd_refs'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'vbd_ref'
name|'in'
name|'vbd_refs'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'vbd_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VBD.get_record"'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'if'
name|'vbd_rec'
op|'['
string|"'userdevice'"
op|']'
op|'=='
name|'str'
op|'('
name|'number'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'vbd_ref'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'exc'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'raise'
name|'volume_utils'
op|'.'
name|'StorageError'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'VBD not found in instance %s'"
op|')'
op|'%'
name|'vm_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|unplug_vbd
dedent|''
name|'def'
name|'unplug_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Unplug VBD from VM."""'
newline|'\n'
comment|'# Call VBD.unplug on the given VBD, with a retry if we get'
nl|'\n'
comment|"# DEVICE_DETACH_REJECTED.  For reasons which we don't understand,"
nl|'\n'
comment|"# we're seeing the device still in use, even when all processes"
nl|'\n'
comment|'# using the device should be dead.'
nl|'\n'
name|'max_attempts'
op|'='
name|'CONF'
op|'.'
name|'xenapi_num_vbd_unplug_retries'
op|'+'
number|'1'
newline|'\n'
name|'for'
name|'num_attempt'
name|'in'
name|'xrange'
op|'('
number|'1'
op|','
name|'max_attempts'
op|'+'
number|'1'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VBD.unplug'"
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'            '
name|'err'
op|'='
name|'len'
op|'('
name|'exc'
op|'.'
name|'details'
op|')'
op|'>'
number|'0'
name|'and'
name|'exc'
op|'.'
name|'details'
op|'['
number|'0'
op|']'
newline|'\n'
name|'if'
name|'err'
op|'=='
string|"'DEVICE_ALREADY_DETACHED'"
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'VBD %s already detached'"
op|')'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'elif'
name|'err'
op|'=='
string|"'DEVICE_DETACH_REJECTED'"
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'VBD %(vbd_ref)s detach rejected, attempt'"
nl|'\n'
string|"' %(num_attempt)d/%(max_attempts)d'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'vbd_ref'"
op|':'
name|'vbd_ref'
op|','
string|"'num_attempt'"
op|':'
name|'num_attempt'
op|','
nl|'\n'
string|"'max_attempts'"
op|':'
name|'max_attempts'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'exc'
op|')'
newline|'\n'
name|'raise'
name|'volume_utils'
op|'.'
name|'StorageError'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Unable to unplug VBD %s'"
op|')'
op|'%'
name|'vbd_ref'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'greenthread'
op|'.'
name|'sleep'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'raise'
name|'volume_utils'
op|'.'
name|'StorageError'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Reached maximum number of retries trying to unplug VBD %s'"
op|')'
nl|'\n'
op|'%'
name|'vbd_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|destroy_vbd
dedent|''
name|'def'
name|'destroy_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Destroy VBD from host database."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VBD.destroy'"
op|','
name|'vbd_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'exc'
op|')'
newline|'\n'
name|'raise'
name|'volume_utils'
op|'.'
name|'StorageError'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Unable to destroy VBD %s'"
op|')'
op|'%'
name|'vbd_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|create_vbd
dedent|''
dedent|''
name|'def'
name|'create_vbd'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'vdi_ref'
op|','
name|'userdevice'
op|','
name|'vbd_type'
op|'='
string|"'disk'"
op|','
nl|'\n'
name|'read_only'
op|'='
name|'False'
op|','
name|'bootable'
op|'='
name|'False'
op|','
name|'osvol'
op|'='
name|'False'
op|','
nl|'\n'
name|'empty'
op|'='
name|'False'
op|','
name|'unpluggable'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Create a VBD record and returns its reference."""'
newline|'\n'
name|'vbd_rec'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'VM'"
op|']'
op|'='
name|'vm_ref'
newline|'\n'
name|'if'
name|'vdi_ref'
op|'=='
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'vdi_ref'
op|'='
string|"'OpaqueRef:NULL'"
newline|'\n'
dedent|''
name|'vbd_rec'
op|'['
string|"'VDI'"
op|']'
op|'='
name|'vdi_ref'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'userdevice'"
op|']'
op|'='
name|'str'
op|'('
name|'userdevice'
op|')'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'bootable'"
op|']'
op|'='
name|'bootable'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'mode'"
op|']'
op|'='
name|'read_only'
name|'and'
string|"'RO'"
name|'or'
string|"'RW'"
newline|'\n'
name|'vbd_rec'
op|'['
string|"'type'"
op|']'
op|'='
name|'vbd_type'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'unpluggable'"
op|']'
op|'='
name|'unpluggable'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'empty'"
op|']'
op|'='
name|'empty'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'other_config'"
op|']'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'qos_algorithm_type'"
op|']'
op|'='
string|"''"
newline|'\n'
name|'vbd_rec'
op|'['
string|"'qos_algorithm_params'"
op|']'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'vbd_rec'
op|'['
string|"'qos_supported_algorithms'"
op|']'
op|'='
op|'['
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Creating %(vbd_type)s-type VBD for VM %(vm_ref)s,'"
nl|'\n'
string|"' VDI %(vdi_ref)s ... '"
op|')'
op|','
nl|'\n'
op|'{'
string|"'vbd_type'"
op|':'
name|'vbd_type'
op|','
string|"'vm_ref'"
op|':'
name|'vm_ref'
op|','
string|"'vdi_ref'"
op|':'
name|'vdi_ref'
op|'}'
op|')'
newline|'\n'
name|'vbd_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VBD.create'"
op|','
name|'vbd_rec'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Created VBD %(vbd_ref)s for VM %(vm_ref)s,'"
nl|'\n'
string|"' VDI %(vdi_ref)s.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'vbd_ref'"
op|':'
name|'vbd_ref'
op|','
string|"'vm_ref'"
op|':'
name|'vm_ref'
op|','
string|"'vdi_ref'"
op|':'
name|'vdi_ref'
op|'}'
op|')'
newline|'\n'
name|'if'
name|'osvol'
op|':'
newline|'\n'
comment|'# set osvol=True in other-config to indicate this is an'
nl|'\n'
comment|'# attached nova (or cinder) volume'
nl|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VBD.add_to_other_config'"
op|','
nl|'\n'
name|'vbd_ref'
op|','
string|"'osvol'"
op|','
string|"'True'"
op|')'
newline|'\n'
dedent|''
name|'return'
name|'vbd_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|attach_cd
dedent|''
name|'def'
name|'attach_cd'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'vdi_ref'
op|','
name|'userdevice'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Create an empty VBD, then insert the CD."""'
newline|'\n'
name|'vbd_ref'
op|'='
name|'create_vbd'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'None'
op|','
name|'userdevice'
op|','
nl|'\n'
name|'vbd_type'
op|'='
string|"'cd'"
op|','
name|'read_only'
op|'='
name|'True'
op|','
nl|'\n'
name|'bootable'
op|'='
name|'True'
op|','
name|'empty'
op|'='
name|'True'
op|','
nl|'\n'
name|'unpluggable'
op|'='
name|'False'
op|')'
newline|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VBD.insert'"
op|','
name|'vbd_ref'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'return'
name|'vbd_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|destroy_vdi
dedent|''
name|'def'
name|'destroy_vdi'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.destroy'"
op|','
name|'vdi_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'exc'
op|')'
newline|'\n'
name|'raise'
name|'volume_utils'
op|'.'
name|'StorageError'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Unable to destroy VDI %s'"
op|')'
op|'%'
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|safe_destroy_vdis
dedent|''
dedent|''
name|'def'
name|'safe_destroy_vdis'
op|'('
name|'session'
op|','
name|'vdi_refs'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Destroys the requested VDIs, logging any StorageError exceptions."""'
newline|'\n'
name|'for'
name|'vdi_ref'
name|'in'
name|'vdi_refs'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'destroy_vdi'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'volume_utils'
op|'.'
name|'StorageError'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'exc'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|create_vdi
dedent|''
dedent|''
dedent|''
name|'def'
name|'create_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'disk_type'
op|','
name|'virtual_size'
op|','
nl|'\n'
name|'read_only'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Create a VDI record and returns its reference."""'
newline|'\n'
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.create"'
op|','
nl|'\n'
op|'{'
string|"'name_label'"
op|':'
name|'name_label'
op|','
nl|'\n'
string|"'name_description'"
op|':'
name|'disk_type'
op|','
nl|'\n'
string|"'SR'"
op|':'
name|'sr_ref'
op|','
nl|'\n'
string|"'virtual_size'"
op|':'
name|'str'
op|'('
name|'virtual_size'
op|')'
op|','
nl|'\n'
string|"'type'"
op|':'
string|"'User'"
op|','
nl|'\n'
string|"'sharable'"
op|':'
name|'False'
op|','
nl|'\n'
string|"'read_only'"
op|':'
name|'read_only'
op|','
nl|'\n'
string|"'xenstore_data'"
op|':'
op|'{'
op|'}'
op|','
nl|'\n'
string|"'other_config'"
op|':'
name|'_get_vdi_other_config'
op|'('
name|'disk_type'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
op|','
nl|'\n'
string|"'sm_config'"
op|':'
op|'{'
op|'}'
op|','
nl|'\n'
string|"'tags'"
op|':'
op|'['
op|']'
op|'}'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Created VDI %(vdi_ref)s (%(name_label)s,'"
nl|'\n'
string|"' %(virtual_size)s, %(read_only)s) on %(sr_ref)s.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'vdi_ref'"
op|':'
name|'vdi_ref'
op|','
string|"'name_label'"
op|':'
name|'name_label'
op|','
nl|'\n'
string|"'virtual_size'"
op|':'
name|'virtual_size'
op|','
string|"'read_only'"
op|':'
name|'read_only'
op|','
nl|'\n'
string|"'sr_ref'"
op|':'
name|'sr_ref'
op|'}'
op|')'
newline|'\n'
name|'return'
name|'vdi_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_vdi_uuid_for_volume
dedent|''
name|'def'
name|'get_vdi_uuid_for_volume'
op|'('
name|'session'
op|','
name|'connection_data'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'sr_uuid'
op|','
name|'label'
op|','
name|'sr_params'
op|'='
name|'volume_utils'
op|'.'
name|'parse_sr_info'
op|'('
name|'connection_data'
op|')'
newline|'\n'
name|'sr_ref'
op|'='
name|'volume_utils'
op|'.'
name|'find_sr_by_uuid'
op|'('
name|'session'
op|','
name|'sr_uuid'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'sr_ref'
op|':'
newline|'\n'
indent|'        '
name|'sr_ref'
op|'='
name|'volume_utils'
op|'.'
name|'introduce_sr'
op|'('
name|'session'
op|','
name|'sr_uuid'
op|','
name|'label'
op|','
name|'sr_params'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'sr_ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'_'
op|'('
string|"'SR not present and could not be '"
nl|'\n'
string|"'introduced'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'vdi_uuid'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'if'
string|"'vdi_uuid'"
name|'in'
name|'connection_data'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"SR.scan"'
op|','
name|'sr_ref'
op|')'
newline|'\n'
name|'vdi_uuid'
op|'='
name|'connection_data'
op|'['
string|"'vdi_uuid'"
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'vdi_ref'
op|'='
name|'volume_utils'
op|'.'
name|'introduce_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
newline|'\n'
name|'vdi_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_record"'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'vdi_uuid'
op|'='
name|'vdi_rec'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'volume_utils'
op|'.'
name|'StorageError'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'exc'
op|')'
newline|'\n'
name|'volume_utils'
op|'.'
name|'forget_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'vdi_uuid'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_vdis_for_instance
dedent|''
name|'def'
name|'get_vdis_for_instance'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'image'
op|','
nl|'\n'
name|'image_type'
op|','
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vdis'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
name|'if'
name|'block_device_info'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"block device info: %s"'
op|')'
op|','
name|'block_device_info'
op|')'
newline|'\n'
name|'root_device_name'
op|'='
name|'block_device_info'
op|'['
string|"'root_device_name'"
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'bdm'
name|'in'
name|'block_device_info'
op|'['
string|"'block_device_mapping'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
name|'block_device'
op|'.'
name|'strip_prefix'
op|'('
name|'bdm'
op|'['
string|"'mount_device'"
op|']'
op|')'
op|'=='
nl|'\n'
name|'block_device'
op|'.'
name|'strip_prefix'
op|'('
name|'root_device_name'
op|')'
op|')'
op|':'
newline|'\n'
comment|"# If we're a root-device, record that fact so we don't download"
nl|'\n'
comment|'# a root image via Glance'
nl|'\n'
indent|'                '
name|'type_'
op|'='
string|"'root'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Otherwise, use mount_device as `type_` so that we have easy'
nl|'\n'
comment|'# access to it in _attach_disks to create the VBD'
nl|'\n'
indent|'                '
name|'type_'
op|'='
name|'bdm'
op|'['
string|"'mount_device'"
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'connection_data'
op|'='
name|'bdm'
op|'['
string|"'connection_info'"
op|']'
op|'['
string|"'data'"
op|']'
newline|'\n'
name|'vdi_uuid'
op|'='
name|'get_vdi_uuid_for_volume'
op|'('
name|'session'
op|','
name|'connection_data'
op|')'
newline|'\n'
name|'if'
name|'vdi_uuid'
op|':'
newline|'\n'
indent|'                '
name|'vdis'
op|'['
name|'type_'
op|']'
op|'='
name|'dict'
op|'('
name|'uuid'
op|'='
name|'vdi_uuid'
op|','
name|'file'
op|'='
name|'None'
op|','
name|'osvol'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
comment|"# If we didn't get a root VDI from volumes, then use the Glance image as"
nl|'\n'
comment|'# the root device'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
string|"'root'"
name|'not'
name|'in'
name|'vdis'
op|':'
newline|'\n'
indent|'        '
name|'create_image_vdis'
op|'='
name|'_create_image'
op|'('
nl|'\n'
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'image'
op|','
name|'image_type'
op|')'
newline|'\n'
name|'vdis'
op|'.'
name|'update'
op|'('
name|'create_image_vdis'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'vdis'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
op|'@'
name|'contextlib'
op|'.'
name|'contextmanager'
newline|'\n'
DECL|function|_dummy_vm
name|'def'
name|'_dummy_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vdi_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""This creates a temporary VM so that we can snapshot a VDI.\n\n    VDI\'s can\'t be snapshotted directly since the API expects a `vm_ref`. To\n    work around this, we need to create a temporary VM and then map the VDI to\n    the VM using a temporary VBD.\n    """'
newline|'\n'
name|'name_label'
op|'='
string|'"dummy"'
newline|'\n'
name|'vm_ref'
op|'='
name|'create_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'vbd_ref'
op|'='
name|'create_vbd'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'vdi_ref'
op|','
string|"'autodetect'"
op|','
nl|'\n'
name|'read_only'
op|'='
name|'True'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'yield'
name|'vm_ref'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'destroy_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'volume_utils'
op|'.'
name|'StorageError'
op|':'
newline|'\n'
comment|'# destroy_vbd() will log error'
nl|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'        '
name|'destroy_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_safe_copy_vdi
dedent|''
dedent|''
name|'def'
name|'_safe_copy_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
name|'vdi_to_copy_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Copy a VDI and return the new VDIs reference.\n\n    This function differs from the XenAPI `VDI.copy` call in that the copy is\n    atomic and isolated, meaning we don\'t see half-downloaded images. It\n    accomplishes this by copying the VDI\'s into a temporary directory and then\n    atomically renaming them into the SR when the copy is completed.\n\n    The correct long term solution is to fix `VDI.copy` so that it is atomic\n    and isolated.\n    """'
newline|'\n'
name|'with'
name|'_dummy_vm'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vdi_to_copy_ref'
op|')'
name|'as'
name|'vm_ref'
op|':'
newline|'\n'
indent|'        '
name|'label'
op|'='
string|'"snapshot"'
newline|'\n'
name|'with'
name|'snapshot_attached_here'
op|'('
nl|'\n'
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'label'
op|')'
name|'as'
name|'vdi_uuids'
op|':'
newline|'\n'
indent|'            '
name|'imported_vhds'
op|'='
name|'session'
op|'.'
name|'call_plugin_serialized'
op|'('
nl|'\n'
string|"'workarounds'"
op|','
string|"'safe_copy_vdis'"
op|','
nl|'\n'
name|'sr_path'
op|'='
name|'get_sr_path'
op|'('
name|'session'
op|','
name|'sr_ref'
op|'='
name|'sr_ref'
op|')'
op|','
nl|'\n'
name|'vdi_uuids'
op|'='
name|'vdi_uuids'
op|','
name|'uuid_stack'
op|'='
name|'_make_uuid_stack'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'root_uuid'
op|'='
name|'imported_vhds'
op|'['
string|"'root'"
op|']'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
nl|'\n'
comment|'# TODO(sirp): for safety, we should probably re-scan the SR after every'
nl|'\n'
comment|'# call to a dom0 plugin, since there is a possibility that the underlying'
nl|'\n'
comment|'# VHDs changed'
nl|'\n'
name|'scan_default_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_by_uuid'"
op|','
name|'root_uuid'
op|')'
newline|'\n'
name|'return'
name|'vdi_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_clone_vdi
dedent|''
name|'def'
name|'_clone_vdi'
op|'('
name|'session'
op|','
name|'vdi_to_clone_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Clones a VDI and return the new VDIs reference."""'
newline|'\n'
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.clone'"
op|','
name|'vdi_to_clone_ref'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Cloned VDI %(vdi_ref)s from VDI '"
nl|'\n'
string|"'%(vdi_to_clone_ref)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'vdi_ref'"
op|':'
name|'vdi_ref'
op|','
string|"'vdi_to_clone_ref'"
op|':'
name|'vdi_to_clone_ref'
op|'}'
op|')'
newline|'\n'
name|'return'
name|'vdi_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_vdi_other_config
dedent|''
name|'def'
name|'_get_vdi_other_config'
op|'('
name|'disk_type'
op|','
name|'instance'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return metadata to store in VDI\'s other_config attribute.\n\n    `nova_instance_uuid` is used to associate a VDI with a particular instance\n    so that, if it becomes orphaned from an unclean shutdown of a\n    compute-worker, we can safely detach it.\n    """'
newline|'\n'
name|'other_config'
op|'='
op|'{'
string|"'nova_disk_type'"
op|':'
name|'disk_type'
op|'}'
newline|'\n'
nl|'\n'
comment|'# create_vdi may be called simply while creating a volume'
nl|'\n'
comment|'# hence information about instance may or may not be present'
nl|'\n'
name|'if'
name|'instance'
op|':'
newline|'\n'
indent|'        '
name|'other_config'
op|'['
string|"'nova_instance_uuid'"
op|']'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'other_config'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_set_vdi_info
dedent|''
name|'def'
name|'_set_vdi_info'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'vdi_type'
op|','
name|'name_label'
op|','
name|'description'
op|','
nl|'\n'
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vdi_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_record'"
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.set_name_label'"
op|','
name|'vdi_ref'
op|','
name|'name_label'
op|')'
newline|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.set_name_description'"
op|','
name|'vdi_ref'
op|','
name|'description'
op|')'
newline|'\n'
nl|'\n'
name|'other_config'
op|'='
name|'_get_vdi_other_config'
op|'('
name|'vdi_type'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'for'
name|'key'
op|','
name|'value'
name|'in'
name|'other_config'
op|'.'
name|'iteritems'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'key'
name|'not'
name|'in'
name|'vdi_rec'
op|'['
string|"'other_config'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
nl|'\n'
string|'"VDI.add_to_other_config"'
op|','
name|'vdi_ref'
op|','
name|'key'
op|','
name|'value'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_vdi_for_vm_safely
dedent|''
dedent|''
dedent|''
name|'def'
name|'get_vdi_for_vm_safely'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Retrieves the primary VDI for a VM."""'
newline|'\n'
name|'vbd_refs'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_VBDs"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'for'
name|'vbd'
name|'in'
name|'vbd_refs'
op|':'
newline|'\n'
indent|'        '
name|'vbd_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VBD.get_record"'
op|','
name|'vbd'
op|')'
newline|'\n'
comment|'# Convention dictates the primary VDI will be userdevice 0'
nl|'\n'
name|'if'
name|'vbd_rec'
op|'['
string|"'userdevice'"
op|']'
op|'=='
string|"'0'"
op|':'
newline|'\n'
indent|'            '
name|'vdi_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_record"'
op|','
name|'vbd_rec'
op|'['
string|"'VDI'"
op|']'
op|')'
newline|'\n'
name|'return'
name|'vbd_rec'
op|'['
string|"'VDI'"
op|']'
op|','
name|'vdi_rec'
newline|'\n'
dedent|''
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'_'
op|'('
string|'"No primary VDI found for %s"'
op|')'
op|'%'
name|'vm_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
op|'@'
name|'contextlib'
op|'.'
name|'contextmanager'
newline|'\n'
DECL|function|snapshot_attached_here
name|'def'
name|'snapshot_attached_here'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'label'
op|','
op|'*'
name|'args'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'update_task_state'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'args'
op|')'
op|'=='
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'update_task_state'
op|'='
name|'args'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
dedent|''
string|'"""Snapshot the root disk only.  Return a list of uuids for the vhds\n    in the chain.\n    """'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Starting snapshot for VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# Memorize the original_parent_uuid so we can poll for coalesce'
nl|'\n'
name|'vm_vdi_ref'
op|','
name|'vm_vdi_rec'
op|'='
name|'get_vdi_for_vm_safely'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'original_parent_uuid'
op|'='
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'vm_vdi_ref'
op|')'
newline|'\n'
name|'sr_ref'
op|'='
name|'vm_vdi_rec'
op|'['
string|'"SR"'
op|']'
newline|'\n'
nl|'\n'
name|'snapshot_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.snapshot"'
op|','
name|'vm_vdi_ref'
op|','
op|'{'
op|'}'
op|')'
newline|'\n'
name|'if'
name|'update_task_state'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'update_task_state'
op|'('
name|'task_state'
op|'='
name|'task_states'
op|'.'
name|'IMAGE_PENDING_UPLOAD'
op|')'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'snapshot_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_record"'
op|','
name|'snapshot_ref'
op|')'
newline|'\n'
name|'_wait_for_vhd_coalesce'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'sr_ref'
op|','
name|'vm_vdi_ref'
op|','
nl|'\n'
name|'original_parent_uuid'
op|')'
newline|'\n'
name|'vdi_uuids'
op|'='
op|'['
name|'vdi_rec'
op|'['
string|"'uuid'"
op|']'
name|'for'
name|'vdi_rec'
name|'in'
nl|'\n'
name|'_walk_vdi_chain'
op|'('
name|'session'
op|','
name|'snapshot_rec'
op|'['
string|"'uuid'"
op|']'
op|')'
op|']'
newline|'\n'
name|'yield'
name|'vdi_uuids'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'        '
name|'safe_destroy_vdis'
op|'('
name|'session'
op|','
op|'['
name|'snapshot_ref'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_sr_path
dedent|''
dedent|''
name|'def'
name|'get_sr_path'
op|'('
name|'session'
op|','
name|'sr_ref'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the path to our storage repository\n\n    This is used when we\'re dealing with VHDs directly, either by taking\n    snapshots or by restoring an image in the DISK_VHD format.\n    """'
newline|'\n'
name|'if'
name|'sr_ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'sr_ref'
op|'='
name|'safe_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
dedent|''
name|'host_ref'
op|'='
name|'session'
op|'.'
name|'get_xenapi_host'
op|'('
op|')'
newline|'\n'
name|'pbd_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"PBD.get_all_records_where"'
op|','
nl|'\n'
string|'\'field "host"="%s" and \''
nl|'\n'
string|'\'field "SR"="%s"\''
op|'%'
op|'('
name|'host_ref'
op|','
name|'sr_ref'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(bobball): There can only be one PBD for a host/SR pair, but path is'
nl|'\n'
comment|'# not always present - older versions of XS do not set it.'
nl|'\n'
name|'pbd_ref'
op|'='
name|'pbd_rec'
op|'.'
name|'keys'
op|'('
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'device_config'
op|'='
name|'pbd_rec'
op|'['
name|'pbd_ref'
op|']'
op|'['
string|"'device_config'"
op|']'
newline|'\n'
name|'if'
string|"'path'"
name|'in'
name|'device_config'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'device_config'
op|'['
string|"'path'"
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'sr_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"SR.get_record"'
op|','
name|'sr_ref'
op|')'
newline|'\n'
name|'sr_uuid'
op|'='
name|'sr_rec'
op|'['
string|'"uuid"'
op|']'
newline|'\n'
name|'if'
name|'sr_rec'
op|'['
string|'"type"'
op|']'
name|'not'
name|'in'
op|'['
string|'"ext"'
op|','
string|'"nfs"'
op|']'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
nl|'\n'
name|'_'
op|'('
string|'"Only file-based SRs (ext/NFS) are supported by this feature."'
nl|'\n'
string|'"  SR %(uuid)s is of type %(type)s"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|'"uuid"'
op|':'
name|'sr_uuid'
op|','
string|'"type"'
op|':'
name|'sr_rec'
op|'['
string|'"type"'
op|']'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'CONF'
op|'.'
name|'xenapi_sr_base_path'
op|','
name|'sr_uuid'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|destroy_cached_images
dedent|''
name|'def'
name|'destroy_cached_images'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'all_cached'
op|'='
name|'False'
op|','
name|'dry_run'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Destroy used or unused cached images.\n\n    A cached image that is being used by at least one VM is said to be \'used\'.\n\n    In the case of an \'unused\' image, the cached image will be the only\n    descendent of the base-copy. So when we delete the cached-image, the\n    refcount will drop to zero and XenServer will automatically destroy the\n    base-copy for us.\n\n    The default behavior of this function is to destroy only \'unused\' cached\n    images. To destroy all cached images, use the `all_cached=True` kwarg.\n    """'
newline|'\n'
name|'cached_images'
op|'='
name|'_find_cached_images'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
newline|'\n'
name|'destroyed'
op|'='
name|'set'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|destroy_cached_vdi
name|'def'
name|'destroy_cached_vdi'
op|'('
name|'vdi_uuid'
op|','
name|'vdi_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Destroying cached VDI \'%(vdi_uuid)s\'"'
op|')'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'dry_run'
op|':'
newline|'\n'
indent|'            '
name|'destroy_vdi'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
dedent|''
name|'destroyed'
op|'.'
name|'add'
op|'('
name|'vdi_uuid'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'vdi_ref'
name|'in'
name|'cached_images'
op|'.'
name|'values'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'vdi_uuid'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_uuid'"
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'all_cached'
op|':'
newline|'\n'
indent|'            '
name|'destroy_cached_vdi'
op|'('
name|'vdi_uuid'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
comment|'# Unused-Only: Search for siblings'
nl|'\n'
nl|'\n'
comment|'# Chain length greater than two implies a VM must be holding a ref to'
nl|'\n'
comment|'# the base-copy (otherwise it would have coalesced), so consider this'
nl|'\n'
comment|'# cached image used.'
nl|'\n'
dedent|''
name|'chain'
op|'='
name|'list'
op|'('
name|'_walk_vdi_chain'
op|'('
name|'session'
op|','
name|'vdi_uuid'
op|')'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'chain'
op|')'
op|'>'
number|'2'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
dedent|''
name|'elif'
name|'len'
op|'('
name|'chain'
op|')'
op|'=='
number|'2'
op|':'
newline|'\n'
comment|'# Siblings imply cached image is used'
nl|'\n'
indent|'            '
name|'root_vdi_rec'
op|'='
name|'chain'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
name|'children'
op|'='
name|'_child_vhds'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'root_vdi_rec'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'children'
op|')'
op|'>'
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'destroy_cached_vdi'
op|'('
name|'vdi_uuid'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'destroyed'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_find_cached_images
dedent|''
name|'def'
name|'_find_cached_images'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return a dict(uuid=vdi_ref) representing all cached images."""'
newline|'\n'
name|'cached_images'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'vdi_ref'
op|','
name|'vdi_rec'
name|'in'
name|'_get_all_vdis_in_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'image_id'
op|'='
name|'vdi_rec'
op|'['
string|"'other_config'"
op|']'
op|'['
string|"'image-id'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'cached_images'
op|'['
name|'image_id'
op|']'
op|'='
name|'vdi_ref'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'cached_images'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_find_cached_image
dedent|''
name|'def'
name|'_find_cached_image'
op|'('
name|'session'
op|','
name|'image_id'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Returns the vdi-ref of the cached image."""'
newline|'\n'
name|'cached_images'
op|'='
name|'_find_cached_images'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
newline|'\n'
name|'return'
name|'cached_images'
op|'.'
name|'get'
op|'('
name|'image_id'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|resize_disk
dedent|''
name|'def'
name|'resize_disk'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vdi_ref'
op|','
name|'instance_type'
op|')'
op|':'
newline|'\n'
comment|'# Copy VDI over to something we can resize'
nl|'\n'
comment|'# NOTE(jerdfelt): Would be nice to just set vdi_ref to read/write'
nl|'\n'
indent|'    '
name|'sr_ref'
op|'='
name|'safe_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'copy_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.copy'"
op|','
name|'vdi_ref'
op|','
name|'sr_ref'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# Resize partition and filesystem down'
nl|'\n'
indent|'        '
name|'_auto_configure_disk'
op|'('
name|'session'
op|','
name|'copy_ref'
op|','
name|'instance_type'
op|'['
string|"'root_gb'"
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Create new VDI'
nl|'\n'
name|'vdi_size'
op|'='
name|'instance_type'
op|'['
string|"'root_gb'"
op|']'
op|'*'
number|'1024'
op|'*'
number|'1024'
op|'*'
number|'1024'
newline|'\n'
comment|'# NOTE(johannes): No resizing allowed for rescue instances, so'
nl|'\n'
comment|"# using instance['name'] is safe here"
nl|'\n'
name|'new_ref'
op|'='
name|'create_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
name|'instance'
op|'['
string|"'name'"
op|']'
op|','
nl|'\n'
string|"'root'"
op|','
name|'vdi_size'
op|')'
newline|'\n'
nl|'\n'
name|'new_uuid'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_uuid'"
op|','
name|'new_ref'
op|')'
newline|'\n'
nl|'\n'
comment|'# Manually copy contents over'
nl|'\n'
name|'virtual_size'
op|'='
name|'instance_type'
op|'['
string|"'root_gb'"
op|']'
op|'*'
number|'1024'
op|'*'
number|'1024'
op|'*'
number|'1024'
newline|'\n'
name|'_copy_partition'
op|'('
name|'session'
op|','
name|'copy_ref'
op|','
name|'new_ref'
op|','
number|'1'
op|','
name|'virtual_size'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'new_ref'
op|','
name|'new_uuid'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'        '
name|'destroy_vdi'
op|'('
name|'session'
op|','
name|'copy_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_auto_configure_disk
dedent|''
dedent|''
name|'def'
name|'_auto_configure_disk'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'new_gb'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Partition and resize FS to match the size specified by\n    flavors.root_gb.\n\n    This is a fail-safe to prevent accidentally destroying data on a disk\n    erroneously marked as auto_disk_config=True.\n\n    The criteria for allowing resize are:\n\n        1. \'auto_disk_config\' must be true for the instance (and image).\n           (If we\'ve made it here, then auto_disk_config=True.)\n\n        2. The disk must have only one partition.\n\n        3. The file-system on the one partition must be ext3 or ext4.\n    """'
newline|'\n'
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
name|'as'
name|'dev'
op|':'
newline|'\n'
indent|'        '
name|'partitions'
op|'='
name|'_get_partitions'
op|'('
name|'dev'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'partitions'
op|')'
op|'!='
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
name|'_'
op|'('
string|"'Disk must have only one partition.'"
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'CannotResizeDisk'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'_num'
op|','
name|'start'
op|','
name|'old_sectors'
op|','
name|'ptype'
op|'='
name|'partitions'
op|'['
number|'0'
op|']'
newline|'\n'
name|'if'
name|'ptype'
name|'in'
op|'('
string|"'ext3'"
op|','
string|"'ext4'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'new_sectors'
op|'='
name|'new_gb'
op|'*'
number|'1024'
op|'*'
number|'1024'
op|'*'
number|'1024'
op|'/'
name|'SECTOR_SIZE'
newline|'\n'
name|'_resize_part_and_fs'
op|'('
name|'dev'
op|','
name|'start'
op|','
name|'old_sectors'
op|','
name|'new_sectors'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
name|'_'
op|'('
string|"'Disk contains a filesystem '"
nl|'\n'
string|"'we are unable to resize: %s'"
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'CannotResizeDisk'
op|'('
name|'reason'
op|'='
op|'('
name|'reason'
op|'%'
name|'ptype'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|try_auto_configure_disk
dedent|''
dedent|''
dedent|''
name|'def'
name|'try_auto_configure_disk'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'new_gb'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'_auto_configure_disk'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'new_gb'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'CannotResizeDisk'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'msg'
op|'='
name|'_'
op|'('
string|"'Attempted auto_configure_disk failed because: %s'"
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'msg'
op|'%'
name|'e'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_make_partition
dedent|''
dedent|''
name|'def'
name|'_make_partition'
op|'('
name|'session'
op|','
name|'dev'
op|','
name|'partition_start'
op|','
name|'partition_end'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(bobball) If this runs in Dom0, parted will error trying'
nl|'\n'
comment|'# to re-read the partition table and return a generic error'
nl|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'parted'"
op|','
string|"'--script'"
op|','
name|'dev_path'
op|','
nl|'\n'
string|"'mklabel'"
op|','
string|"'msdos'"
op|','
name|'run_as_root'
op|'='
name|'True'
op|','
nl|'\n'
name|'check_exit_code'
op|'='
name|'not'
name|'session'
op|'.'
name|'is_local_connection'
op|')'
newline|'\n'
nl|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'parted'"
op|','
string|"'--script'"
op|','
name|'dev_path'
op|','
nl|'\n'
string|"'mkpart'"
op|','
string|"'primary'"
op|','
nl|'\n'
name|'partition_start'
op|','
nl|'\n'
name|'partition_end'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|','
nl|'\n'
name|'check_exit_code'
op|'='
name|'not'
name|'session'
op|'.'
name|'is_local_connection'
op|')'
newline|'\n'
nl|'\n'
name|'partition_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|','
name|'partition'
op|'='
number|'1'
op|')'
newline|'\n'
name|'if'
name|'session'
op|'.'
name|'is_local_connection'
op|':'
newline|'\n'
comment|'# Need to refresh the partitions'
nl|'\n'
indent|'        '
name|'utils'
op|'.'
name|'trycmd'
op|'('
string|"'kpartx'"
op|','
string|"'-a'"
op|','
name|'dev_path'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|','
nl|'\n'
name|'discard_warnings'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
comment|'# Sometimes the partition gets created under /dev/mapper, depending'
nl|'\n'
comment|'# on the setup in dom0.'
nl|'\n'
name|'mapper_path'
op|'='
string|"'/dev/mapper/%s'"
op|'%'
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'partition_path'
op|')'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'mapper_path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'mapper_path'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'partition_path'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_generate_disk
dedent|''
name|'def'
name|'_generate_disk'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'userdevice'
op|','
name|'name_label'
op|','
nl|'\n'
name|'disk_type'
op|','
name|'size_mb'
op|','
name|'fs_type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Steps to programmatically generate a disk:\n\n        1. Create VDI of desired size\n\n        2. Attach VDI to compute worker\n\n        3. Create partition\n\n        4. Create VBD between instance VM and VDI\n    """'
newline|'\n'
comment|'# 1. Create VDI'
nl|'\n'
name|'sr_ref'
op|'='
name|'safe_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'ONE_MEG'
op|'='
number|'1024'
op|'*'
number|'1024'
newline|'\n'
name|'virtual_size'
op|'='
name|'size_mb'
op|'*'
name|'ONE_MEG'
newline|'\n'
name|'vdi_ref'
op|'='
name|'create_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'disk_type'
op|','
nl|'\n'
name|'virtual_size'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# 2. Attach VDI to compute worker (VBD hotplug)'
nl|'\n'
indent|'        '
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
name|'as'
name|'dev'
op|':'
newline|'\n'
comment|'# 3. Create partition'
nl|'\n'
indent|'            '
name|'partition_start'
op|'='
number|'0'
newline|'\n'
name|'partition_end'
op|'='
name|'size_mb'
newline|'\n'
nl|'\n'
name|'partition_path'
op|'='
name|'_make_partition'
op|'('
name|'session'
op|','
name|'dev'
op|','
nl|'\n'
string|'"%d"'
op|'%'
name|'partition_start'
op|','
nl|'\n'
string|'"%d"'
op|'%'
name|'partition_end'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'fs_type'
op|'=='
string|"'linux-swap'"
op|':'
newline|'\n'
indent|'                '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mkswap'"
op|','
name|'partition_path'
op|','
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'fs_type'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mkfs'"
op|','
string|"'-t'"
op|','
name|'fs_type'
op|','
name|'partition_path'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
comment|'# 4. Create VBD between instance VM and VDI'
nl|'\n'
dedent|''
dedent|''
name|'create_vbd'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'vdi_ref'
op|','
name|'userdevice'
op|','
name|'bootable'
op|'='
name|'False'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'destroy_vdi'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'vdi_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|generate_swap
dedent|''
name|'def'
name|'generate_swap'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'userdevice'
op|','
name|'name_label'
op|','
name|'swap_mb'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(jk0): We use a FAT32 filesystem for the Windows swap'
nl|'\n'
comment|'# partition because that is what parted supports.'
nl|'\n'
indent|'    '
name|'is_windows'
op|'='
name|'instance'
op|'['
string|"'os_type'"
op|']'
op|'=='
string|'"windows"'
newline|'\n'
name|'fs_type'
op|'='
string|'"vfat"'
name|'if'
name|'is_windows'
name|'else'
string|'"linux-swap"'
newline|'\n'
nl|'\n'
name|'_generate_disk'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'userdevice'
op|','
name|'name_label'
op|','
nl|'\n'
string|"'swap'"
op|','
name|'swap_mb'
op|','
name|'fs_type'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|generate_ephemeral
dedent|''
name|'def'
name|'generate_ephemeral'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'first_userdevice'
op|','
nl|'\n'
name|'initial_name_label'
op|','
name|'total_size_gb'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(johngarbutt): max possible size of a VHD disk is 2043GB'
nl|'\n'
indent|'    '
name|'if'
name|'total_size_gb'
op|'%'
number|'1024'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'max_size_gb'
op|'='
number|'1024'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'max_size_gb'
op|'='
number|'2000'
newline|'\n'
nl|'\n'
dedent|''
name|'left_to_allocate'
op|'='
name|'total_size_gb'
newline|'\n'
name|'first_userdevice'
op|'='
name|'int'
op|'('
name|'first_userdevice'
op|')'
newline|'\n'
name|'userdevice'
op|'='
name|'first_userdevice'
newline|'\n'
name|'name_label'
op|'='
name|'initial_name_label'
newline|'\n'
nl|'\n'
name|'vdi_refs'
op|'='
op|'['
op|']'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'while'
name|'left_to_allocate'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'size_gb'
op|'='
name|'min'
op|'('
name|'max_size_gb'
op|','
name|'left_to_allocate'
op|')'
newline|'\n'
nl|'\n'
name|'ref'
op|'='
name|'_generate_disk'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'str'
op|'('
name|'userdevice'
op|')'
op|','
nl|'\n'
name|'name_label'
op|','
string|"'ephemeral'"
op|','
name|'size_gb'
op|'*'
number|'1024'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'default_ephemeral_format'
op|')'
newline|'\n'
name|'vdi_refs'
op|'.'
name|'append'
op|'('
name|'ref'
op|')'
newline|'\n'
nl|'\n'
name|'left_to_allocate'
op|'-='
name|'size_gb'
newline|'\n'
name|'userdevice'
op|'+='
number|'1'
newline|'\n'
name|'label_number'
op|'='
name|'userdevice'
op|'-'
name|'first_userdevice'
newline|'\n'
name|'name_label'
op|'='
string|'"%s (%d)"'
op|'%'
op|'('
name|'initial_name_label'
op|','
name|'label_number'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Error when generating ephemeral disk. "'
nl|'\n'
string|'"Device: %(userdevice)s Size GB: %(size_gb)s "'
nl|'\n'
string|'"Error: %(exc)s"'
op|')'
op|','
op|'{'
nl|'\n'
name|'userdevice'
op|':'
name|'userdevice'
op|','
nl|'\n'
name|'size_gb'
op|':'
name|'size_gb'
op|','
nl|'\n'
name|'exc'
op|':'
name|'exc'
op|'}'
op|')'
newline|'\n'
name|'safe_destroy_vdis'
op|'('
name|'session'
op|','
name|'vdi_refs'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|generate_iso_blank_root_disk
dedent|''
dedent|''
dedent|''
name|'def'
name|'generate_iso_blank_root_disk'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'userdevice'
op|','
nl|'\n'
name|'name_label'
op|','
name|'size_gb'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'_generate_disk'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'userdevice'
op|','
name|'name_label'
op|','
nl|'\n'
string|"'user'"
op|','
name|'size_gb'
op|'*'
number|'1024'
op|','
name|'CONF'
op|'.'
name|'default_ephemeral_format'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|generate_configdrive
dedent|''
name|'def'
name|'generate_configdrive'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vm_ref'
op|','
name|'userdevice'
op|','
nl|'\n'
name|'admin_password'
op|'='
name|'None'
op|','
name|'files'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'sr_ref'
op|'='
name|'safe_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'vdi_ref'
op|'='
name|'create_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
string|"'config-2'"
op|','
nl|'\n'
string|"'configdrive'"
op|','
name|'configdrive'
op|'.'
name|'CONFIGDRIVESIZE_BYTES'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
name|'as'
name|'dev'
op|':'
newline|'\n'
indent|'            '
name|'extra_md'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'if'
name|'admin_password'
op|':'
newline|'\n'
indent|'                '
name|'extra_md'
op|'['
string|"'admin_pass'"
op|']'
op|'='
name|'admin_password'
newline|'\n'
dedent|''
name|'inst_md'
op|'='
name|'instance_metadata'
op|'.'
name|'InstanceMetadata'
op|'('
name|'instance'
op|','
nl|'\n'
name|'content'
op|'='
name|'files'
op|','
nl|'\n'
name|'extra_md'
op|'='
name|'extra_md'
op|')'
newline|'\n'
name|'with'
name|'configdrive'
op|'.'
name|'ConfigDriveBuilder'
op|'('
name|'instance_md'
op|'='
name|'inst_md'
op|')'
name|'as'
name|'cdb'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'utils'
op|'.'
name|'tempdir'
op|'('
op|')'
name|'as'
name|'tmp_path'
op|':'
newline|'\n'
indent|'                    '
name|'tmp_file'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'tmp_path'
op|','
string|"'configdrive'"
op|')'
newline|'\n'
name|'cdb'
op|'.'
name|'make_drive'
op|'('
name|'tmp_file'
op|')'
newline|'\n'
nl|'\n'
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'dd'"
op|','
nl|'\n'
string|"'if=%s'"
op|'%'
name|'tmp_file'
op|','
nl|'\n'
string|"'of=%s'"
op|'%'
name|'dev_path'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'create_vbd'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'vdi_ref'
op|','
name|'userdevice'
op|','
name|'bootable'
op|'='
name|'False'
op|','
nl|'\n'
name|'read_only'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'destroy_vdi'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_create_kernel_image
dedent|''
dedent|''
dedent|''
name|'def'
name|'_create_kernel_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'image_id'
op|','
nl|'\n'
name|'image_type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Creates kernel/ramdisk file from the image stored in the cache.\n    If the image is not present in the cache, it streams it from glance.\n\n    Returns: A list of dictionaries that describe VDIs\n    """'
newline|'\n'
name|'filename'
op|'='
string|'""'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'cache_images'
op|':'
newline|'\n'
indent|'        '
name|'args'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'args'
op|'['
string|"'cached-image'"
op|']'
op|'='
name|'image_id'
newline|'\n'
name|'args'
op|'['
string|"'new-image-uuid'"
op|']'
op|'='
name|'str'
op|'('
name|'uuid'
op|'.'
name|'uuid4'
op|'('
op|')'
op|')'
newline|'\n'
name|'filename'
op|'='
name|'session'
op|'.'
name|'call_plugin'
op|'('
string|"'kernel'"
op|','
string|"'create_kernel_ramdisk'"
op|','
name|'args'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'filename'
op|'=='
string|'""'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'_fetch_disk_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_id'
op|','
name|'image_type'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'vdi_type'
op|'='
name|'ImageType'
op|'.'
name|'to_string'
op|'('
name|'image_type'
op|')'
newline|'\n'
name|'return'
op|'{'
name|'vdi_type'
op|':'
name|'dict'
op|'('
name|'uuid'
op|'='
name|'None'
op|','
name|'file'
op|'='
name|'filename'
op|')'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|create_kernel_and_ramdisk
dedent|''
dedent|''
name|'def'
name|'create_kernel_and_ramdisk'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'kernel_file'
op|'='
name|'None'
newline|'\n'
name|'ramdisk_file'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'instance'
op|'['
string|"'kernel_id'"
op|']'
op|':'
newline|'\n'
indent|'        '
name|'vdis'
op|'='
name|'_create_kernel_image'
op|'('
name|'context'
op|','
name|'session'
op|','
nl|'\n'
name|'instance'
op|','
name|'name_label'
op|','
name|'instance'
op|'['
string|"'kernel_id'"
op|']'
op|','
nl|'\n'
name|'ImageType'
op|'.'
name|'KERNEL'
op|')'
newline|'\n'
name|'kernel_file'
op|'='
name|'vdis'
op|'['
string|"'kernel'"
op|']'
op|'.'
name|'get'
op|'('
string|"'file'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'instance'
op|'['
string|"'ramdisk_id'"
op|']'
op|':'
newline|'\n'
indent|'        '
name|'vdis'
op|'='
name|'_create_kernel_image'
op|'('
name|'context'
op|','
name|'session'
op|','
nl|'\n'
name|'instance'
op|','
name|'name_label'
op|','
name|'instance'
op|'['
string|"'ramdisk_id'"
op|']'
op|','
nl|'\n'
name|'ImageType'
op|'.'
name|'RAMDISK'
op|')'
newline|'\n'
name|'ramdisk_file'
op|'='
name|'vdis'
op|'['
string|"'ramdisk'"
op|']'
op|'.'
name|'get'
op|'('
string|"'file'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'kernel_file'
op|','
name|'ramdisk_file'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|destroy_kernel_ramdisk
dedent|''
name|'def'
name|'destroy_kernel_ramdisk'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'kernel'
op|','
name|'ramdisk'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'args'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'if'
name|'kernel'
op|':'
newline|'\n'
indent|'        '
name|'args'
op|'['
string|"'kernel-file'"
op|']'
op|'='
name|'kernel'
newline|'\n'
dedent|''
name|'if'
name|'ramdisk'
op|':'
newline|'\n'
indent|'        '
name|'args'
op|'['
string|"'ramdisk-file'"
op|']'
op|'='
name|'ramdisk'
newline|'\n'
dedent|''
name|'if'
name|'args'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Removing kernel/ramdisk files from dom0"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'session'
op|'.'
name|'call_plugin'
op|'('
string|"'kernel'"
op|','
string|"'remove_kernel_ramdisk'"
op|','
name|'args'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_create_cached_image
dedent|''
dedent|''
name|'def'
name|'_create_cached_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_id'
op|','
name|'image_type'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'sr_ref'
op|'='
name|'safe_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'sr_type'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'SR.get_record'"
op|','
name|'sr_ref'
op|')'
op|'['
string|'"type"'
op|']'
newline|'\n'
name|'vdis'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'use_cow_images'
name|'and'
name|'sr_type'
op|'!='
string|'"ext"'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_'
op|'('
string|'"Fast cloning is only supported on default local SR "'
nl|'\n'
string|'"of type ext. SR on this system was found to be of "'
nl|'\n'
string|'"type %s. Ignoring the cow flag."'
op|')'
op|','
name|'sr_type'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'cache_vdi_ref'
op|'='
name|'_find_cached_image'
op|'('
name|'session'
op|','
name|'image_id'
op|','
name|'sr_ref'
op|')'
newline|'\n'
name|'if'
name|'cache_vdi_ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'vdis'
op|'='
name|'_fetch_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_id'
op|','
name|'image_type'
op|')'
newline|'\n'
nl|'\n'
name|'cache_vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
nl|'\n'
string|"'VDI.get_by_uuid'"
op|','
name|'vdis'
op|'['
string|"'root'"
op|']'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.set_name_label'"
op|','
name|'cache_vdi_ref'
op|','
nl|'\n'
string|"'Glance Image %s'"
op|'%'
name|'image_id'
op|')'
newline|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.set_name_description'"
op|','
name|'cache_vdi_ref'
op|','
string|"'root'"
op|')'
newline|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.add_to_other_config'"
op|','
nl|'\n'
name|'cache_vdi_ref'
op|','
string|"'image-id'"
op|','
name|'str'
op|'('
name|'image_id'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'use_cow_images'
name|'and'
name|'sr_type'
op|'=='
string|"'ext'"
op|':'
newline|'\n'
indent|'        '
name|'new_vdi_ref'
op|'='
name|'_clone_vdi'
op|'('
name|'session'
op|','
name|'cache_vdi_ref'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'sr_type'
op|'=='
string|"'ext'"
op|':'
newline|'\n'
indent|'        '
name|'new_vdi_ref'
op|'='
name|'_safe_copy_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
name|'cache_vdi_ref'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'new_vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.copy"'
op|','
name|'cache_vdi_ref'
op|','
name|'sr_ref'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.remove_from_other_config'"
op|','
nl|'\n'
name|'new_vdi_ref'
op|','
string|"'image-id'"
op|')'
newline|'\n'
nl|'\n'
name|'vdi_type'
op|'='
name|'ImageType'
op|'.'
name|'get_role'
op|'('
name|'image_type'
op|')'
newline|'\n'
name|'vdi_uuid'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_uuid'"
op|','
name|'new_vdi_ref'
op|')'
newline|'\n'
name|'vdis'
op|'['
name|'vdi_type'
op|']'
op|'='
name|'dict'
op|'('
name|'uuid'
op|'='
name|'vdi_uuid'
op|','
name|'file'
op|'='
name|'None'
op|')'
newline|'\n'
name|'return'
name|'vdis'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_create_image
dedent|''
name|'def'
name|'_create_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'image_id'
op|','
nl|'\n'
name|'image_type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Creates VDI from the image stored in the local cache. If the image\n    is not present in the cache, it streams it from glance.\n\n    Returns: A list of dictionaries that describe VDIs\n    """'
newline|'\n'
name|'cache_images'
op|'='
name|'CONF'
op|'.'
name|'cache_images'
op|'.'
name|'lower'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Deterimine if the image is cacheable'
nl|'\n'
name|'if'
name|'image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK_ISO'
op|':'
newline|'\n'
indent|'        '
name|'cache'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'elif'
name|'cache_images'
op|'=='
string|"'all'"
op|':'
newline|'\n'
indent|'        '
name|'cache'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'elif'
name|'cache_images'
op|'=='
string|"'some'"
op|':'
newline|'\n'
indent|'        '
name|'sys_meta'
op|'='
name|'utils'
op|'.'
name|'instance_sys_meta'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'cache'
op|'='
name|'strutils'
op|'.'
name|'bool_from_string'
op|'('
name|'sys_meta'
op|'['
string|"'image_cache_in_nova'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'            '
name|'cache'
op|'='
name|'False'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'cache_images'
op|'=='
string|"'none'"
op|':'
newline|'\n'
indent|'        '
name|'cache'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_'
op|'('
string|'"Unrecognized cache_images value \'%s\', defaulting to"'
nl|'\n'
string|'" True"'
op|')'
op|','
name|'CONF'
op|'.'
name|'cache_images'
op|')'
newline|'\n'
name|'cache'
op|'='
name|'True'
newline|'\n'
nl|'\n'
comment|'# Fetch (and cache) the image'
nl|'\n'
dedent|''
name|'if'
name|'cache'
op|':'
newline|'\n'
indent|'        '
name|'vdis'
op|'='
name|'_create_cached_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_id'
op|','
name|'image_type'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'vdis'
op|'='
name|'_fetch_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_id'
op|','
name|'image_type'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'vdi_type'
op|','
name|'vdi'
name|'in'
name|'vdis'
op|'.'
name|'iteritems'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_by_uuid'"
op|','
name|'vdi'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
name|'_set_vdi_info'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'vdi_type'
op|','
name|'name_label'
op|','
name|'vdi_type'
op|','
nl|'\n'
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'vdis'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_fetch_image
dedent|''
name|'def'
name|'_fetch_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'image_id'
op|','
name|'image_type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Fetch image from glance based on image type.\n\n    Returns: A single filename if image_type is KERNEL or RAMDISK\n             A list of dictionaries that describe VDIs, otherwise\n    """'
newline|'\n'
name|'if'
name|'image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK_VHD'
op|':'
newline|'\n'
indent|'        '
name|'vdis'
op|'='
name|'_fetch_vhd_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'image_id'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'vdis'
op|'='
name|'_fetch_disk_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_id'
op|','
name|'image_type'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'vdi_type'
op|','
name|'vdi'
name|'in'
name|'vdis'
op|'.'
name|'iteritems'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'vdi_uuid'
op|'='
name|'vdi'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Fetched VDIs of type \'%(vdi_type)s\' with UUID"'
nl|'\n'
string|'" \'%(vdi_uuid)s\'"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'vdi_type'"
op|':'
name|'vdi_type'
op|','
string|"'vdi_uuid'"
op|':'
name|'vdi_uuid'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'vdis'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_make_uuid_stack
dedent|''
name|'def'
name|'_make_uuid_stack'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# NOTE(sirp): The XenAPI plugins run under Python 2.4'
nl|'\n'
comment|'# which does not have the `uuid` module. To work around this,'
nl|'\n'
comment|'# we generate the uuids here (under Python 2.6+) and'
nl|'\n'
comment|'# pass them as arguments'
nl|'\n'
indent|'    '
name|'return'
op|'['
name|'str'
op|'('
name|'uuid'
op|'.'
name|'uuid4'
op|'('
op|')'
op|')'
name|'for'
name|'i'
name|'in'
name|'xrange'
op|'('
name|'MAX_VDI_CHAIN_SIZE'
op|')'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_image_uses_bittorrent
dedent|''
name|'def'
name|'_image_uses_bittorrent'
op|'('
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'bittorrent'
op|'='
name|'False'
newline|'\n'
name|'xenapi_torrent_images'
op|'='
name|'CONF'
op|'.'
name|'xenapi_torrent_images'
op|'.'
name|'lower'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'xenapi_torrent_images'
op|'=='
string|"'all'"
op|':'
newline|'\n'
indent|'        '
name|'bittorrent'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'elif'
name|'xenapi_torrent_images'
op|'=='
string|"'some'"
op|':'
newline|'\n'
indent|'        '
name|'sys_meta'
op|'='
name|'utils'
op|'.'
name|'instance_sys_meta'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'bittorrent'
op|'='
name|'strutils'
op|'.'
name|'bool_from_string'
op|'('
nl|'\n'
name|'sys_meta'
op|'['
string|"'image_bittorrent'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'xenapi_torrent_images'
op|'=='
string|"'none'"
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_'
op|'('
string|'"Invalid value \'%s\' for xenapi_torrent_images"'
op|')'
op|','
nl|'\n'
name|'xenapi_torrent_images'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'bittorrent'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_default_download_handler
dedent|''
name|'def'
name|'_default_download_handler'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# TODO(sirp):  This should be configurable like upload_handler'
nl|'\n'
indent|'    '
name|'return'
name|'importutils'
op|'.'
name|'import_object'
op|'('
nl|'\n'
string|"'nova.virt.xenapi.image.glance.GlanceStore'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_choose_download_handler
dedent|''
name|'def'
name|'_choose_download_handler'
op|'('
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'_image_uses_bittorrent'
op|'('
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'importutils'
op|'.'
name|'import_object'
op|'('
nl|'\n'
string|"'nova.virt.xenapi.image.bittorrent.BittorrentStore'"
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'_default_download_handler'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_compression_level
dedent|''
dedent|''
name|'def'
name|'get_compression_level'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
name|'level'
op|'='
name|'CONF'
op|'.'
name|'xenapi_image_compression_level'
newline|'\n'
name|'if'
name|'level'
name|'is'
name|'not'
name|'None'
name|'and'
op|'('
name|'level'
op|'<'
number|'1'
name|'or'
name|'level'
op|'>'
number|'9'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|'"Invalid value \'%d\' for xenapi_image_compression_level"'
op|')'
op|','
nl|'\n'
name|'level'
op|')'
newline|'\n'
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'return'
name|'level'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_fetch_vhd_image
dedent|''
name|'def'
name|'_fetch_vhd_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'image_id'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Tell glance to download an image and put the VHDs into the SR\n\n    Returns: A list of dictionaries that describe VDIs\n    """'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Asking xapi to fetch vhd image %s"'
op|')'
op|','
name|'image_id'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'handler'
op|'='
name|'_choose_download_handler'
op|'('
name|'context'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'vdis'
op|'='
name|'handler'
op|'.'
name|'download_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'image_id'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'default_handler'
op|'='
name|'_default_download_handler'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|"# Using type() instead of isinstance() so instance of subclass doesn't"
nl|'\n'
comment|'# test as equivalent'
nl|'\n'
name|'if'
name|'type'
op|'('
name|'handler'
op|')'
op|'=='
name|'type'
op|'('
name|'default_handler'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_'
op|'('
string|'"Download handler \'%(handler)s\' raised an"'
nl|'\n'
string|'" exception, falling back to default handler"'
nl|'\n'
string|'" \'%(default_handler)s\'"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'handler'"
op|':'
name|'handler'
op|','
nl|'\n'
string|"'default_handler'"
op|':'
name|'default_handler'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'vdis'
op|'='
name|'default_handler'
op|'.'
name|'download_image'
op|'('
nl|'\n'
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'image_id'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'sr_ref'
op|'='
name|'safe_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'_scan_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'_check_vdi_size'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'vdis'
op|'['
string|"'root'"
op|']'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'key'
name|'in'
name|'vdis'
op|':'
newline|'\n'
indent|'                '
name|'vdi'
op|'='
name|'vdis'
op|'['
name|'key'
op|']'
newline|'\n'
name|'vdi_uuid'
op|'='
name|'vdi'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_by_uuid'"
op|','
name|'vdi_uuid'
op|')'
newline|'\n'
name|'destroy_vdi'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'vdis'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_vdi_chain_size
dedent|''
name|'def'
name|'_get_vdi_chain_size'
op|'('
name|'session'
op|','
name|'vdi_uuid'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Compute the total size of a VDI chain, starting with the specified\n    VDI UUID.\n\n    This will walk the VDI chain to the root, add the size of each VDI into\n    the total.\n    """'
newline|'\n'
name|'size_bytes'
op|'='
number|'0'
newline|'\n'
name|'for'
name|'vdi_rec'
name|'in'
name|'_walk_vdi_chain'
op|'('
name|'session'
op|','
name|'vdi_uuid'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'cur_vdi_uuid'
op|'='
name|'vdi_rec'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'vdi_size_bytes'
op|'='
name|'int'
op|'('
name|'vdi_rec'
op|'['
string|"'physical_utilisation'"
op|']'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'vdi_uuid=%(cur_vdi_uuid)s vdi_size_bytes='"
nl|'\n'
string|"'%(vdi_size_bytes)d'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'cur_vdi_uuid'"
op|':'
name|'cur_vdi_uuid'
op|','
nl|'\n'
string|"'vdi_size_bytes'"
op|':'
name|'vdi_size_bytes'
op|'}'
op|')'
newline|'\n'
name|'size_bytes'
op|'+='
name|'vdi_size_bytes'
newline|'\n'
dedent|''
name|'return'
name|'size_bytes'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_check_vdi_size
dedent|''
name|'def'
name|'_check_vdi_size'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'vdi_uuid'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'instance_type'
op|'='
name|'flavors'
op|'.'
name|'extract_flavor'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'allowed_size'
op|'='
op|'('
name|'instance_type'
op|'['
string|"'root_gb'"
op|']'
op|'+'
nl|'\n'
name|'VHD_SIZE_CHECK_FUDGE_FACTOR_GB'
op|')'
op|'*'
op|'('
number|'1024'
op|'**'
number|'3'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'instance_type'
op|'['
string|"'root_gb'"
op|']'
op|':'
newline|'\n'
comment|"# root_gb=0 indicates that we're disabling size checks"
nl|'\n'
indent|'        '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'size'
op|'='
name|'_get_vdi_chain_size'
op|'('
name|'session'
op|','
name|'vdi_uuid'
op|')'
newline|'\n'
name|'if'
name|'size'
op|'>'
name|'allowed_size'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|'"Image size %(size)d exceeded instance_type "'
nl|'\n'
string|'"allowed size %(allowed_size)d"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'size'"
op|':'
name|'size'
op|','
string|"'allowed_size'"
op|':'
name|'allowed_size'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstanceTypeDiskTooSmall'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_fetch_disk_image
dedent|''
dedent|''
name|'def'
name|'_fetch_disk_image'
op|'('
name|'context'
op|','
name|'session'
op|','
name|'instance'
op|','
name|'name_label'
op|','
name|'image_id'
op|','
nl|'\n'
name|'image_type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Fetch the image from Glance\n\n    NOTE:\n    Unlike _fetch_vhd_image, this method does not use the Glance\n    plugin; instead, it streams the disks through domU to the VDI\n    directly.\n\n    Returns: A single filename if image_type is KERNEL_RAMDISK\n             A list of dictionaries that describe VDIs, otherwise\n    """'
newline|'\n'
comment|'# FIXME(sirp): Since the Glance plugin seems to be required for the'
nl|'\n'
comment|'# VHD disk, it may be worth using the plugin for both VHD and RAW and'
nl|'\n'
comment|'# DISK restores'
nl|'\n'
name|'image_type_str'
op|'='
name|'ImageType'
op|'.'
name|'to_string'
op|'('
name|'image_type'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Fetching image %(image_id)s, type %(image_type_str)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'image_id'"
op|':'
name|'image_id'
op|','
string|"'image_type_str'"
op|':'
name|'image_type_str'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK_ISO'
op|':'
newline|'\n'
indent|'        '
name|'sr_ref'
op|'='
name|'_safe_find_iso_sr'
op|'('
name|'session'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'sr_ref'
op|'='
name|'safe_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'glance_image'
op|'='
name|'image_utils'
op|'.'
name|'GlanceImage'
op|'('
name|'context'
op|','
name|'image_id'
op|')'
newline|'\n'
name|'if'
name|'glance_image'
op|'.'
name|'is_raw_tgz'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'image'
op|'='
name|'image_utils'
op|'.'
name|'RawTGZImage'
op|'('
name|'glance_image'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'image'
op|'='
name|'image_utils'
op|'.'
name|'RawImage'
op|'('
name|'glance_image'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'virtual_size'
op|'='
name|'image'
op|'.'
name|'get_size'
op|'('
op|')'
newline|'\n'
name|'vdi_size'
op|'='
name|'virtual_size'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Size for image %(image_id)s: %(virtual_size)d"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'image_id'"
op|':'
name|'image_id'
op|','
string|"'virtual_size'"
op|':'
name|'virtual_size'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK'
op|':'
newline|'\n'
comment|'# Make room for MBR.'
nl|'\n'
indent|'        '
name|'vdi_size'
op|'+='
name|'MBR_SIZE_BYTES'
newline|'\n'
dedent|''
name|'elif'
op|'('
name|'image_type'
name|'in'
op|'('
name|'ImageType'
op|'.'
name|'KERNEL'
op|','
name|'ImageType'
op|'.'
name|'RAMDISK'
op|')'
name|'and'
nl|'\n'
name|'vdi_size'
op|'>'
name|'CONF'
op|'.'
name|'max_kernel_ramdisk_size'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'max_size'
op|'='
name|'CONF'
op|'.'
name|'max_kernel_ramdisk_size'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
nl|'\n'
name|'_'
op|'('
string|'"Kernel/Ramdisk image is too large: %(vdi_size)d bytes, "'
nl|'\n'
string|'"max %(max_size)d bytes"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'vdi_size'"
op|':'
name|'vdi_size'
op|','
string|"'max_size'"
op|':'
name|'max_size'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'vdi_ref'
op|'='
name|'create_vdi'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'instance'
op|','
name|'name_label'
op|','
nl|'\n'
name|'image_type_str'
op|','
name|'vdi_size'
op|')'
newline|'\n'
comment|'# From this point we have a VDI on Xen host;'
nl|'\n'
comment|'# If anything goes wrong, we need to remember its uuid.'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'filename'
op|'='
name|'None'
newline|'\n'
name|'vdi_uuid'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_uuid"'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
name|'as'
name|'dev'
op|':'
newline|'\n'
indent|'            '
name|'_stream_disk'
op|'('
nl|'\n'
name|'session'
op|','
name|'image'
op|'.'
name|'stream_to'
op|','
name|'image_type'
op|','
name|'virtual_size'
op|','
name|'dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'image_type'
name|'in'
op|'('
name|'ImageType'
op|'.'
name|'KERNEL'
op|','
name|'ImageType'
op|'.'
name|'RAMDISK'
op|')'
op|':'
newline|'\n'
comment|'# We need to invoke a plugin for copying the'
nl|'\n'
comment|'# content of the VDI into the proper path.'
nl|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Copying VDI %s to /boot/guest on dom0"'
op|')'
op|','
nl|'\n'
name|'vdi_ref'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'args'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'args'
op|'['
string|"'vdi-ref'"
op|']'
op|'='
name|'vdi_ref'
newline|'\n'
nl|'\n'
comment|'# Let the plugin copy the correct number of bytes.'
nl|'\n'
name|'args'
op|'['
string|"'image-size'"
op|']'
op|'='
name|'str'
op|'('
name|'vdi_size'
op|')'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'cache_images'
op|':'
newline|'\n'
indent|'                '
name|'args'
op|'['
string|"'cached-image'"
op|']'
op|'='
name|'image_id'
newline|'\n'
dedent|''
name|'filename'
op|'='
name|'session'
op|'.'
name|'call_plugin'
op|'('
string|"'kernel'"
op|','
string|"'copy_vdi'"
op|','
name|'args'
op|')'
newline|'\n'
nl|'\n'
comment|'# Remove the VDI as it is not needed anymore.'
nl|'\n'
name|'destroy_vdi'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Kernel/Ramdisk VDI %s destroyed"'
op|')'
op|','
name|'vdi_ref'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'vdi_role'
op|'='
name|'ImageType'
op|'.'
name|'get_role'
op|'('
name|'image_type'
op|')'
newline|'\n'
name|'return'
op|'{'
name|'vdi_role'
op|':'
name|'dict'
op|'('
name|'uuid'
op|'='
name|'None'
op|','
name|'file'
op|'='
name|'filename'
op|')'
op|'}'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'vdi_role'
op|'='
name|'ImageType'
op|'.'
name|'get_role'
op|'('
name|'image_type'
op|')'
newline|'\n'
name|'return'
op|'{'
name|'vdi_role'
op|':'
name|'dict'
op|'('
name|'uuid'
op|'='
name|'vdi_uuid'
op|','
name|'file'
op|'='
name|'None'
op|')'
op|'}'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|'('
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|','
name|'IOError'
op|','
name|'OSError'
op|')'
name|'as'
name|'e'
op|':'
newline|'\n'
comment|'# We look for XenAPI and OS failures.'
nl|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_'
op|'('
string|'"Failed to fetch glance image"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'e'
op|'.'
name|'args'
op|'='
name|'e'
op|'.'
name|'args'
op|'+'
op|'('
op|'['
name|'dict'
op|'('
name|'type'
op|'='
name|'ImageType'
op|'.'
name|'to_string'
op|'('
name|'image_type'
op|')'
op|','
nl|'\n'
name|'uuid'
op|'='
name|'vdi_uuid'
op|','
nl|'\n'
name|'file'
op|'='
name|'filename'
op|')'
op|']'
op|','
op|')'
newline|'\n'
name|'raise'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|determine_disk_image_type
dedent|''
dedent|''
name|'def'
name|'determine_disk_image_type'
op|'('
name|'image_meta'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Disk Image Types are used to determine where the kernel will reside\n    within an image. To figure out which type we\'re dealing with, we use\n    the following rules:\n\n    1. If we\'re using Glance, we can use the image_type field to\n       determine the image_type\n\n    2. If we\'re not using Glance, then we need to deduce this based on\n       whether a kernel_id is specified.\n    """'
newline|'\n'
name|'if'
name|'not'
name|'image_meta'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'disk_format'
op|'='
name|'image_meta'
op|'['
string|"'disk_format'"
op|']'
newline|'\n'
nl|'\n'
name|'disk_format_map'
op|'='
op|'{'
nl|'\n'
string|"'ami'"
op|':'
name|'ImageType'
op|'.'
name|'DISK'
op|','
nl|'\n'
string|"'aki'"
op|':'
name|'ImageType'
op|'.'
name|'KERNEL'
op|','
nl|'\n'
string|"'ari'"
op|':'
name|'ImageType'
op|'.'
name|'RAMDISK'
op|','
nl|'\n'
string|"'raw'"
op|':'
name|'ImageType'
op|'.'
name|'DISK_RAW'
op|','
nl|'\n'
string|"'vhd'"
op|':'
name|'ImageType'
op|'.'
name|'DISK_VHD'
op|','
nl|'\n'
string|"'iso'"
op|':'
name|'ImageType'
op|'.'
name|'DISK_ISO'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'image_type'
op|'='
name|'disk_format_map'
op|'['
name|'disk_format'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'InvalidDiskFormat'
op|'('
name|'disk_format'
op|'='
name|'disk_format'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'image_ref'
op|'='
name|'image_meta'
op|'.'
name|'get'
op|'('
string|"'id'"
op|')'
newline|'\n'
nl|'\n'
name|'params'
op|'='
op|'{'
nl|'\n'
string|"'image_type_str'"
op|':'
name|'ImageType'
op|'.'
name|'to_string'
op|'('
name|'image_type'
op|')'
op|','
nl|'\n'
string|"'image_ref'"
op|':'
name|'image_ref'
nl|'\n'
op|'}'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Detected %(image_type_str)s format for image %(image_ref)s"'
op|')'
op|','
nl|'\n'
name|'params'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'image_type'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|determine_is_pv
dedent|''
name|'def'
name|'determine_is_pv'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'disk_image_type'
op|','
name|'os_type'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    Determine whether the VM will use a paravirtualized kernel or if it\n    will use hardware virtualization.\n\n        1. Glance (VHD): if `os_type` is windows, HVM, otherwise PV\n\n        2. Glance (DISK_RAW): HVM\n\n        3. Glance (DISK): PV\n\n        4. Glance (DISK_ISO): HVM\n\n        5. Boot From Volume - without image metadata (None): use HVM\n           NOTE: if disk_image_type is not specified, instances launched\n           from remote volumes will have to include kernel and ramdisk\n           because external kernel and ramdisk will not be fetched.\n    """'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Looking up vdi %s for PV kernel"'
op|')'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'if'
name|'disk_image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK_VHD'
op|':'
newline|'\n'
comment|'# 1. VHD'
nl|'\n'
indent|'        '
name|'if'
name|'os_type'
op|'=='
string|"'windows'"
op|':'
newline|'\n'
indent|'            '
name|'is_pv'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'is_pv'
op|'='
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'disk_image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK_RAW'
op|':'
newline|'\n'
comment|'# 2. RAW'
nl|'\n'
indent|'        '
name|'is_pv'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'elif'
name|'disk_image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK'
op|':'
newline|'\n'
comment|'# 3. Disk'
nl|'\n'
indent|'        '
name|'is_pv'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'elif'
name|'disk_image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK_ISO'
op|':'
newline|'\n'
comment|'# 4. ISO'
nl|'\n'
indent|'        '
name|'is_pv'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'elif'
name|'not'
name|'disk_image_type'
op|':'
newline|'\n'
indent|'        '
name|'is_pv'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'_'
op|'('
string|'"Unknown image format %s"'
op|')'
op|'%'
nl|'\n'
name|'disk_image_type'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'is_pv'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|set_vm_name_label
dedent|''
name|'def'
name|'set_vm_name_label'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'name_label'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.set_name_label"'
op|','
name|'vm_ref'
op|','
name|'name_label'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|list_vms
dedent|''
name|'def'
name|'list_vms'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'for'
name|'vm_ref'
op|','
name|'vm_rec'
name|'in'
name|'session'
op|'.'
name|'get_all_refs_and_recs'
op|'('
string|"'VM'"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
op|'('
name|'vm_rec'
op|'['
string|'"resident_on"'
op|']'
op|'!='
name|'session'
op|'.'
name|'get_xenapi_host'
op|'('
op|')'
name|'or'
nl|'\n'
name|'vm_rec'
op|'['
string|'"is_a_template"'
op|']'
name|'or'
name|'vm_rec'
op|'['
string|'"is_control_domain"'
op|']'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'yield'
name|'vm_ref'
op|','
name|'vm_rec'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|lookup_vm_vdis
dedent|''
dedent|''
dedent|''
name|'def'
name|'lookup_vm_vdis'
op|'('
name|'session'
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Look for the VDIs that are attached to the VM."""'
newline|'\n'
comment|'# Firstly we get the VBDs, then the VDIs.'
nl|'\n'
comment|'# TODO(Armando): do we leave the read-only devices?'
nl|'\n'
name|'vbd_refs'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_VBDs"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'vdi_refs'
op|'='
op|'['
op|']'
newline|'\n'
name|'if'
name|'vbd_refs'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'vbd_ref'
name|'in'
name|'vbd_refs'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VBD.get_VDI"'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
comment|'# Test valid VDI'
nl|'\n'
name|'record'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_record"'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'VDI %s is still available'"
op|')'
op|','
name|'record'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
name|'vbd_other_config'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VBD.get_other_config"'
op|','
nl|'\n'
name|'vbd_ref'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'vbd_other_config'
op|'.'
name|'get'
op|'('
string|"'osvol'"
op|')'
op|':'
newline|'\n'
comment|'# This is not an attached volume'
nl|'\n'
indent|'                    '
name|'vdi_refs'
op|'.'
name|'append'
op|'('
name|'vdi_ref'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'exc'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'vdi_refs'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|lookup
dedent|''
name|'def'
name|'lookup'
op|'('
name|'session'
op|','
name|'name_label'
op|','
name|'check_rescue'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Look the instance up and return it if available.\n    :param check_rescue: if True will return the \'name\'-rescue vm if it\n                         exists, instead of just \'name\'\n    """'
newline|'\n'
name|'if'
name|'check_rescue'
op|':'
newline|'\n'
indent|'        '
name|'result'
op|'='
name|'lookup'
op|'('
name|'session'
op|','
name|'name_label'
op|'+'
string|"'-rescue'"
op|','
name|'False'
op|')'
newline|'\n'
name|'if'
name|'result'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'result'
newline|'\n'
dedent|''
dedent|''
name|'vm_refs'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_by_name_label"'
op|','
name|'name_label'
op|')'
newline|'\n'
name|'n'
op|'='
name|'len'
op|'('
name|'vm_refs'
op|')'
newline|'\n'
name|'if'
name|'n'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'elif'
name|'n'
op|'>'
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'InstanceExists'
op|'('
name|'name'
op|'='
name|'name_label'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'vm_refs'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|preconfigure_instance
dedent|''
dedent|''
name|'def'
name|'preconfigure_instance'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'vdi_ref'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Makes alterations to the image before launching as part of spawn.\n    """'
newline|'\n'
nl|'\n'
comment|'# As mounting the image VDI is expensive, we only want do do it once,'
nl|'\n'
comment|"# if at all, so determine whether it's required first, and then do"
nl|'\n'
comment|'# everything'
nl|'\n'
name|'mount_required'
op|'='
name|'False'
newline|'\n'
name|'key'
op|','
name|'net'
op|','
name|'metadata'
op|'='
name|'_prepare_injectables'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'mount_required'
op|'='
name|'key'
name|'or'
name|'net'
name|'or'
name|'metadata'
newline|'\n'
name|'if'
name|'not'
name|'mount_required'
op|':'
newline|'\n'
indent|'        '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
name|'as'
name|'dev'
op|':'
newline|'\n'
indent|'        '
name|'_mounted_processing'
op|'('
name|'dev'
op|','
name|'key'
op|','
name|'net'
op|','
name|'metadata'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|lookup_kernel_ramdisk
dedent|''
dedent|''
name|'def'
name|'lookup_kernel_ramdisk'
op|'('
name|'session'
op|','
name|'vm'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vm_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_record"'
op|','
name|'vm'
op|')'
newline|'\n'
name|'if'
string|"'PV_kernel'"
name|'in'
name|'vm_rec'
name|'and'
string|"'PV_ramdisk'"
name|'in'
name|'vm_rec'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
name|'vm_rec'
op|'['
string|"'PV_kernel'"
op|']'
op|','
name|'vm_rec'
op|'['
string|"'PV_ramdisk'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|is_snapshot
dedent|''
dedent|''
name|'def'
name|'is_snapshot'
op|'('
name|'session'
op|','
name|'vm'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vm_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_record"'
op|','
name|'vm'
op|')'
newline|'\n'
name|'if'
string|"'is_a_template'"
name|'in'
name|'vm_rec'
name|'and'
string|"'is_a_snapshot'"
name|'in'
name|'vm_rec'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'vm_rec'
op|'['
string|"'is_a_template'"
op|']'
name|'and'
name|'vm_rec'
op|'['
string|"'is_a_snapshot'"
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|compile_info
dedent|''
dedent|''
name|'def'
name|'compile_info'
op|'('
name|'record'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Fill record with VM status information."""'
newline|'\n'
name|'return'
op|'{'
string|"'state'"
op|':'
name|'XENAPI_POWER_STATE'
op|'['
name|'record'
op|'['
string|"'power_state'"
op|']'
op|']'
op|','
nl|'\n'
string|"'max_mem'"
op|':'
name|'long'
op|'('
name|'record'
op|'['
string|"'memory_static_max'"
op|']'
op|')'
op|'>>'
number|'10'
op|','
nl|'\n'
string|"'mem'"
op|':'
name|'long'
op|'('
name|'record'
op|'['
string|"'memory_dynamic_max'"
op|']'
op|')'
op|'>>'
number|'10'
op|','
nl|'\n'
string|"'num_cpu'"
op|':'
name|'record'
op|'['
string|"'VCPUs_max'"
op|']'
op|','
nl|'\n'
string|"'cpu_time'"
op|':'
number|'0'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|compile_diagnostics
dedent|''
name|'def'
name|'compile_diagnostics'
op|'('
name|'record'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Compile VM diagnostics data."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'keys'
op|'='
op|'['
op|']'
newline|'\n'
name|'diags'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'vm_uuid'
op|'='
name|'record'
op|'['
string|'"uuid"'
op|']'
newline|'\n'
name|'xml'
op|'='
name|'_get_rrd'
op|'('
name|'_get_rrd_server'
op|'('
op|')'
op|','
name|'vm_uuid'
op|')'
newline|'\n'
name|'if'
name|'xml'
op|':'
newline|'\n'
indent|'            '
name|'rrd'
op|'='
name|'xmlutils'
op|'.'
name|'safe_minidom_parse_string'
op|'('
name|'xml'
op|')'
newline|'\n'
name|'for'
name|'i'
op|','
name|'node'
name|'in'
name|'enumerate'
op|'('
name|'rrd'
op|'.'
name|'firstChild'
op|'.'
name|'childNodes'
op|')'
op|':'
newline|'\n'
comment|'# Provide the last update of the information'
nl|'\n'
indent|'                '
name|'if'
name|'node'
op|'.'
name|'localName'
op|'=='
string|"'lastupdate'"
op|':'
newline|'\n'
indent|'                    '
name|'diags'
op|'['
string|"'last_update'"
op|']'
op|'='
name|'node'
op|'.'
name|'firstChild'
op|'.'
name|'data'
newline|'\n'
nl|'\n'
comment|'# Create a list of the diagnostic keys (in their order)'
nl|'\n'
dedent|''
name|'if'
name|'node'
op|'.'
name|'localName'
op|'=='
string|"'ds'"
op|':'
newline|'\n'
indent|'                    '
name|'ref'
op|'='
name|'node'
op|'.'
name|'childNodes'
newline|'\n'
comment|'# Name and Value'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'ref'
op|')'
op|'>'
number|'6'
op|':'
newline|'\n'
indent|'                        '
name|'keys'
op|'.'
name|'append'
op|'('
name|'ref'
op|'['
number|'0'
op|']'
op|'.'
name|'firstChild'
op|'.'
name|'data'
op|')'
newline|'\n'
nl|'\n'
comment|'# Read the last row of the first RRA to get the latest info'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'node'
op|'.'
name|'localName'
op|'=='
string|"'rra'"
op|':'
newline|'\n'
indent|'                    '
name|'rows'
op|'='
name|'node'
op|'.'
name|'childNodes'
op|'['
number|'4'
op|']'
op|'.'
name|'childNodes'
newline|'\n'
name|'last_row'
op|'='
name|'rows'
op|'['
name|'rows'
op|'.'
name|'length'
op|'-'
number|'1'
op|']'
op|'.'
name|'childNodes'
newline|'\n'
name|'for'
name|'j'
op|','
name|'value'
name|'in'
name|'enumerate'
op|'('
name|'last_row'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'diags'
op|'['
name|'keys'
op|'['
name|'j'
op|']'
op|']'
op|'='
name|'value'
op|'.'
name|'firstChild'
op|'.'
name|'data'
newline|'\n'
dedent|''
name|'break'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'diags'
newline|'\n'
dedent|''
name|'except'
name|'expat'
op|'.'
name|'ExpatError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_'
op|'('
string|"'Unable to parse rrd of %s'"
op|')'
op|','
name|'e'
op|')'
newline|'\n'
name|'return'
op|'{'
string|'"Unable to retrieve diagnostics"'
op|':'
name|'e'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|fetch_bandwidth
dedent|''
dedent|''
name|'def'
name|'fetch_bandwidth'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'bw'
op|'='
name|'session'
op|'.'
name|'call_plugin_serialized'
op|'('
string|"'bandwidth'"
op|','
string|"'fetch_all_bandwidth'"
op|')'
newline|'\n'
name|'return'
name|'bw'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_scan_sr
dedent|''
name|'def'
name|'_scan_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Scans the SR specified by sr_ref."""'
newline|'\n'
name|'if'
name|'sr_ref'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Re-scanning SR %s"'
op|')'
op|','
name|'sr_ref'
op|')'
newline|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'SR.scan'"
op|','
name|'sr_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|scan_default_sr
dedent|''
dedent|''
name|'def'
name|'scan_default_sr'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Looks for the system default SR and triggers a re-scan."""'
newline|'\n'
name|'_scan_sr'
op|'('
name|'session'
op|','
name|'_find_sr'
op|'('
name|'session'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|safe_find_sr
dedent|''
name|'def'
name|'safe_find_sr'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Same as _find_sr except raises a NotFound exception if SR cannot be\n    determined\n    """'
newline|'\n'
name|'sr_ref'
op|'='
name|'_find_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'if'
name|'sr_ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'StorageRepositoryNotFound'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'sr_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_find_sr
dedent|''
name|'def'
name|'_find_sr'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the storage repository to hold VM images."""'
newline|'\n'
name|'host'
op|'='
name|'session'
op|'.'
name|'get_xenapi_host'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'tokens'
op|'='
name|'CONF'
op|'.'
name|'sr_matching_filter'
op|'.'
name|'split'
op|'('
string|"':'"
op|')'
newline|'\n'
name|'filter_criteria'
op|'='
name|'tokens'
op|'['
number|'0'
op|']'
newline|'\n'
name|'filter_pattern'
op|'='
name|'tokens'
op|'['
number|'1'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'IndexError'
op|':'
newline|'\n'
comment|'# oops, flag is invalid'
nl|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_'
op|'('
string|'"Flag sr_matching_filter \'%s\' does not respect "'
nl|'\n'
string|'"formatting convention"'
op|')'
op|','
name|'CONF'
op|'.'
name|'sr_matching_filter'
op|')'
newline|'\n'
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'filter_criteria'
op|'=='
string|"'other-config'"
op|':'
newline|'\n'
indent|'        '
name|'key'
op|','
name|'value'
op|'='
name|'filter_pattern'
op|'.'
name|'split'
op|'('
string|"'='"
op|','
number|'1'
op|')'
newline|'\n'
name|'for'
name|'sr_ref'
op|','
name|'sr_rec'
name|'in'
name|'session'
op|'.'
name|'get_all_refs_and_recs'
op|'('
string|"'SR'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
op|'('
name|'key'
name|'in'
name|'sr_rec'
op|'['
string|"'other_config'"
op|']'
name|'and'
nl|'\n'
name|'sr_rec'
op|'['
string|"'other_config'"
op|']'
op|'['
name|'key'
op|']'
op|'=='
name|'value'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'for'
name|'pbd_ref'
name|'in'
name|'sr_rec'
op|'['
string|"'PBDs'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'pbd_rec'
op|'='
name|'session'
op|'.'
name|'get_rec'
op|'('
string|"'PBD'"
op|','
name|'pbd_ref'
op|')'
newline|'\n'
name|'if'
name|'pbd_rec'
name|'and'
name|'pbd_rec'
op|'['
string|"'host'"
op|']'
op|'=='
name|'host'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'sr_ref'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'elif'
name|'filter_criteria'
op|'=='
string|"'default-sr'"
name|'and'
name|'filter_pattern'
op|'=='
string|"'true'"
op|':'
newline|'\n'
indent|'        '
name|'pool_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'pool.get_all'"
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'sr_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'pool.get_default_SR'"
op|','
name|'pool_ref'
op|')'
newline|'\n'
name|'if'
name|'sr_ref'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'sr_ref'
newline|'\n'
comment|'# No SR found!'
nl|'\n'
dedent|''
dedent|''
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|'"XenAPI is unable to find a Storage Repository to "'
nl|'\n'
string|'"install guest instances on. Please check your "'
nl|'\n'
string|'"configuration (e.g. set a default SR for the pool) "'
nl|'\n'
string|'"and/or configure the flag \'sr_matching_filter\'."'
op|')'
op|')'
newline|'\n'
name|'return'
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_safe_find_iso_sr
dedent|''
name|'def'
name|'_safe_find_iso_sr'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Same as _find_iso_sr except raises a NotFound exception if SR\n    cannot be determined\n    """'
newline|'\n'
name|'sr_ref'
op|'='
name|'_find_iso_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'if'
name|'sr_ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'NotFound'
op|'('
name|'_'
op|'('
string|"'Cannot find SR of content-type ISO'"
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'sr_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_find_iso_sr
dedent|''
name|'def'
name|'_find_iso_sr'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the storage repository to hold ISO images."""'
newline|'\n'
name|'host'
op|'='
name|'session'
op|'.'
name|'get_xenapi_host'
op|'('
op|')'
newline|'\n'
name|'for'
name|'sr_ref'
op|','
name|'sr_rec'
name|'in'
name|'session'
op|'.'
name|'get_all_refs_and_recs'
op|'('
string|"'SR'"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"ISO: looking at SR %s"'
op|')'
op|','
name|'sr_rec'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'sr_rec'
op|'['
string|"'content_type'"
op|']'
op|'=='
string|"'iso'"
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"ISO: not iso content"'
op|')'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'if'
string|"'i18n-key'"
name|'not'
name|'in'
name|'sr_rec'
op|'['
string|"'other_config'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"ISO: iso content_type, no \'i18n-key\' key"'
op|')'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'sr_rec'
op|'['
string|"'other_config'"
op|']'
op|'['
string|"'i18n-key'"
op|']'
op|'=='
string|"'local-storage-iso'"
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"ISO: iso content_type, i18n-key value not "'
nl|'\n'
string|'"\'local-storage-iso\'"'
op|')'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"ISO: SR MATCHing our criteria"'
op|')'
op|')'
newline|'\n'
name|'for'
name|'pbd_ref'
name|'in'
name|'sr_rec'
op|'['
string|"'PBDs'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"ISO: ISO, looking to see if it is host local"'
op|')'
op|')'
newline|'\n'
name|'pbd_rec'
op|'='
name|'session'
op|'.'
name|'get_rec'
op|'('
string|"'PBD'"
op|','
name|'pbd_ref'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'pbd_rec'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"ISO: PBD %s disappeared"'
op|')'
op|','
name|'pbd_ref'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'pbd_rec_host'
op|'='
name|'pbd_rec'
op|'['
string|"'host'"
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"ISO: PBD matching, want %(pbd_rec)s, have %(host)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'pbd_rec'"
op|':'
name|'pbd_rec'
op|','
string|"'host'"
op|':'
name|'host'
op|'}'
op|')'
newline|'\n'
name|'if'
name|'pbd_rec_host'
op|'=='
name|'host'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"ISO: SR with local PBD"'
op|')'
op|')'
newline|'\n'
name|'return'
name|'sr_ref'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_rrd_server
dedent|''
name|'def'
name|'_get_rrd_server'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return server\'s scheme and address to use for retrieving RRD XMLs."""'
newline|'\n'
name|'xs_url'
op|'='
name|'urlparse'
op|'.'
name|'urlparse'
op|'('
name|'CONF'
op|'.'
name|'xenapi_connection_url'
op|')'
newline|'\n'
name|'return'
op|'['
name|'xs_url'
op|'.'
name|'scheme'
op|','
name|'xs_url'
op|'.'
name|'netloc'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_rrd
dedent|''
name|'def'
name|'_get_rrd'
op|'('
name|'server'
op|','
name|'vm_uuid'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the VM RRD XML as a string."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'xml'
op|'='
name|'urllib'
op|'.'
name|'urlopen'
op|'('
string|'"%s://%s:%s@%s/vm_rrd?uuid=%s"'
op|'%'
op|'('
nl|'\n'
name|'server'
op|'['
number|'0'
op|']'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'xenapi_connection_username'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'xenapi_connection_password'
op|','
nl|'\n'
name|'server'
op|'['
number|'1'
op|']'
op|','
nl|'\n'
name|'vm_uuid'
op|')'
op|')'
newline|'\n'
name|'return'
name|'xml'
op|'.'
name|'read'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'IOError'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_'
op|'('
string|"'Unable to obtain RRD XML for VM %(vm_uuid)s with '"
nl|'\n'
string|"'server details: %(server)s.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'vm_uuid'"
op|':'
name|'vm_uuid'
op|','
string|"'server'"
op|':'
name|'server'
op|'}'
op|')'
newline|'\n'
name|'return'
name|'None'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_all_vdis_in_sr
dedent|''
dedent|''
name|'def'
name|'_get_all_vdis_in_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'for'
name|'vdi_ref'
name|'in'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'SR.get_VDIs'"
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'vdi_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_record'"
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'yield'
name|'vdi_ref'
op|','
name|'vdi_rec'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_instance_vdis_for_sr
dedent|''
dedent|''
dedent|''
name|'def'
name|'get_instance_vdis_for_sr'
op|'('
name|'session'
op|','
name|'vm_ref'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return opaqueRef for all the vdis which live on sr."""'
newline|'\n'
name|'for'
name|'vbd_ref'
name|'in'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VM.get_VBDs'"
op|','
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VBD.get_VDI'"
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'if'
name|'sr_ref'
op|'=='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_SR'"
op|','
name|'vdi_ref'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'yield'
name|'vdi_ref'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_vhd_parent_uuid
dedent|''
dedent|''
dedent|''
name|'def'
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vdi_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_record"'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
name|'if'
string|"'vhd-parent'"
name|'not'
name|'in'
name|'vdi_rec'
op|'['
string|"'sm_config'"
op|']'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'parent_uuid'
op|'='
name|'vdi_rec'
op|'['
string|"'sm_config'"
op|']'
op|'['
string|"'vhd-parent'"
op|']'
newline|'\n'
name|'vdi_uuid'
op|'='
name|'vdi_rec'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'VHD %(vdi_uuid)s has parent %(parent_uuid)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'vdi_uuid'"
op|':'
name|'vdi_uuid'
op|','
string|"'parent_uuid'"
op|':'
name|'parent_uuid'
op|'}'
op|')'
newline|'\n'
name|'return'
name|'parent_uuid'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_walk_vdi_chain
dedent|''
name|'def'
name|'_walk_vdi_chain'
op|'('
name|'session'
op|','
name|'vdi_uuid'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Yield vdi_recs for each element in a VDI chain."""'
newline|'\n'
name|'scan_default_sr'
op|'('
name|'session'
op|')'
newline|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'        '
name|'vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_by_uuid"'
op|','
name|'vdi_uuid'
op|')'
newline|'\n'
name|'vdi_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_record"'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'yield'
name|'vdi_rec'
newline|'\n'
nl|'\n'
name|'parent_uuid'
op|'='
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'parent_uuid'
op|':'
newline|'\n'
indent|'            '
name|'break'
newline|'\n'
nl|'\n'
dedent|''
name|'vdi_uuid'
op|'='
name|'parent_uuid'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_child_vhds
dedent|''
dedent|''
name|'def'
name|'_child_vhds'
op|'('
name|'session'
op|','
name|'sr_ref'
op|','
name|'vdi_uuid'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the immediate children of a given VHD.\n\n    This is not recursive, only the immediate children are returned.\n    """'
newline|'\n'
name|'children'
op|'='
name|'set'
op|'('
op|')'
newline|'\n'
name|'for'
name|'ref'
op|','
name|'rec'
name|'in'
name|'_get_all_vdis_in_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'rec_uuid'
op|'='
name|'rec'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'rec_uuid'
op|'=='
name|'vdi_uuid'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'parent_uuid'
op|'='
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'ref'
op|')'
newline|'\n'
name|'if'
name|'parent_uuid'
op|'!='
name|'vdi_uuid'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'children'
op|'.'
name|'add'
op|'('
name|'rec_uuid'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'children'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_wait_for_vhd_coalesce
dedent|''
name|'def'
name|'_wait_for_vhd_coalesce'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'sr_ref'
op|','
name|'vdi_ref'
op|','
nl|'\n'
name|'original_parent_uuid'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Spin until the parent VHD is coalesced into its parent VHD\n\n    Before coalesce:\n        * original_parent_vhd\n            * parent_vhd\n                snapshot\n\n    After coalesce:\n        * parent_vhd\n            snapshot\n    """'
newline|'\n'
comment|"# NOTE(sirp): If we don't have an original_parent_uuid, then the snapshot"
nl|'\n'
comment|"# doesn't have a grandparent to coalesce into, so we can skip waiting"
nl|'\n'
name|'if'
name|'not'
name|'original_parent_uuid'
op|':'
newline|'\n'
indent|'        '
name|'return'
newline|'\n'
nl|'\n'
DECL|function|_another_child_vhd
dedent|''
name|'def'
name|'_another_child_vhd'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# Search for any other vdi which parents to original parent and is not'
nl|'\n'
comment|'# in the active vm/instance vdi chain.'
nl|'\n'
indent|'        '
name|'vdi_uuid'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_record'"
op|','
name|'vdi_ref'
op|')'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'parent_vdi_uuid'
op|'='
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'for'
name|'_ref'
op|','
name|'rec'
name|'in'
name|'_get_all_vdis_in_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
op|'('
name|'rec'
op|'['
string|"'uuid'"
op|']'
op|'!='
name|'vdi_uuid'
op|')'
name|'and'
nl|'\n'
op|'('
name|'rec'
op|'['
string|"'uuid'"
op|']'
op|'!='
name|'parent_vdi_uuid'
op|')'
name|'and'
nl|'\n'
op|'('
name|'rec'
op|'['
string|"'sm_config'"
op|']'
op|'.'
name|'get'
op|'('
string|"'vhd-parent'"
op|')'
op|'=='
name|'original_parent_uuid'
op|')'
op|')'
op|':'
newline|'\n'
comment|'# Found another vhd which too parents to original parent.'
nl|'\n'
indent|'                '
name|'return'
name|'True'
newline|'\n'
comment|'# Found no other vdi with the same parent.'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
comment|'# Check if original parent has any other child. If so, coalesce will'
nl|'\n'
comment|'# not take place.'
nl|'\n'
dedent|''
name|'if'
name|'_another_child_vhd'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'parent_uuid'
op|'='
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'parent_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_by_uuid"'
op|','
name|'parent_uuid'
op|')'
newline|'\n'
name|'base_uuid'
op|'='
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'parent_ref'
op|')'
newline|'\n'
name|'return'
name|'parent_uuid'
op|','
name|'base_uuid'
newline|'\n'
nl|'\n'
comment|"# NOTE(sirp): This rescan is necessary to ensure the VM's `sm_config`"
nl|'\n'
comment|'# matches the underlying VHDs.'
nl|'\n'
dedent|''
name|'_scan_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
newline|'\n'
nl|'\n'
name|'max_attempts'
op|'='
name|'CONF'
op|'.'
name|'xenapi_vhd_coalesce_max_attempts'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'xrange'
op|'('
name|'max_attempts'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'_scan_sr'
op|'('
name|'session'
op|','
name|'sr_ref'
op|')'
newline|'\n'
name|'parent_uuid'
op|'='
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'if'
name|'parent_uuid'
name|'and'
op|'('
name|'parent_uuid'
op|'!='
name|'original_parent_uuid'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Parent %(parent_uuid)s doesn\'t match original parent"'
nl|'\n'
string|'" %(original_parent_uuid)s, waiting for coalesce..."'
op|')'
op|','
nl|'\n'
op|'{'
string|"'parent_uuid'"
op|':'
name|'parent_uuid'
op|','
nl|'\n'
string|"'original_parent_uuid'"
op|':'
name|'original_parent_uuid'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'parent_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VDI.get_by_uuid"'
op|','
name|'parent_uuid'
op|')'
newline|'\n'
name|'base_uuid'
op|'='
name|'_get_vhd_parent_uuid'
op|'('
name|'session'
op|','
name|'parent_ref'
op|')'
newline|'\n'
name|'return'
name|'parent_uuid'
op|','
name|'base_uuid'
newline|'\n'
nl|'\n'
dedent|''
name|'greenthread'
op|'.'
name|'sleep'
op|'('
name|'CONF'
op|'.'
name|'xenapi_vhd_coalesce_poll_interval'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|'"VHD coalesce attempts exceeded (%d)"'
nl|'\n'
string|'", giving up..."'
op|')'
op|'%'
name|'max_attempts'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_remap_vbd_dev
dedent|''
name|'def'
name|'_remap_vbd_dev'
op|'('
name|'dev'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return the appropriate location for a plugged-in VBD device\n\n    Ubuntu Maverick moved xvd? -> sd?. This is considered a bug and will be\n    fixed in future versions:\n        https://bugs.launchpad.net/ubuntu/+source/linux/+bug/684875\n\n    For now, we work around it by just doing a string replace.\n    """'
newline|'\n'
comment|'# NOTE(sirp): This hack can go away when we pull support for Maverick'
nl|'\n'
name|'should_remap'
op|'='
name|'CONF'
op|'.'
name|'xenapi_remap_vbd_dev'
newline|'\n'
name|'if'
name|'not'
name|'should_remap'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'dev'
newline|'\n'
nl|'\n'
dedent|''
name|'old_prefix'
op|'='
string|"'xvd'"
newline|'\n'
name|'new_prefix'
op|'='
name|'CONF'
op|'.'
name|'xenapi_remap_vbd_dev_prefix'
newline|'\n'
name|'remapped_dev'
op|'='
name|'dev'
op|'.'
name|'replace'
op|'('
name|'old_prefix'
op|','
name|'new_prefix'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'remapped_dev'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_wait_for_device
dedent|''
name|'def'
name|'_wait_for_device'
op|'('
name|'dev'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Wait for device node to appear."""'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'xrange'
op|'('
number|'0'
op|','
name|'CONF'
op|'.'
name|'block_device_creation_timeout'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'dev_path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'time'
op|'.'
name|'sleep'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'raise'
name|'volume_utils'
op|'.'
name|'StorageError'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Timeout waiting for device %s to be created'"
op|')'
op|'%'
name|'dev'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|cleanup_attached_vdis
dedent|''
name|'def'
name|'cleanup_attached_vdis'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Unplug any instance VDIs left after an unclean restart."""'
newline|'\n'
name|'this_vm_ref'
op|'='
name|'_get_this_vm_ref'
op|'('
name|'session'
op|')'
newline|'\n'
nl|'\n'
name|'vbd_refs'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VM.get_VBDs'"
op|','
name|'this_vm_ref'
op|')'
newline|'\n'
name|'for'
name|'vbd_ref'
name|'in'
name|'vbd_refs'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'vbd_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VBD.get_record'"
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'vdi_rec'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_record'"
op|','
name|'vbd_rec'
op|'['
string|"'VDI'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'e'
op|'.'
name|'details'
op|'['
number|'0'
op|']'
op|'!='
string|"'HANDLE_INVALID'"
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
dedent|''
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
string|"'nova_instance_uuid'"
name|'in'
name|'vdi_rec'
op|'['
string|"'other_config'"
op|']'
op|':'
newline|'\n'
comment|'# Belongs to an instance and probably left over after an'
nl|'\n'
comment|'# unclean restart'
nl|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'Disconnecting stale VDI %s from compute domU'"
op|')'
op|','
nl|'\n'
name|'vdi_rec'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
name|'unplug_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'destroy_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
op|'@'
name|'contextlib'
op|'.'
name|'contextmanager'
newline|'\n'
DECL|function|vdi_attached_here
name|'def'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'vdi_ref'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'this_vm_ref'
op|'='
name|'_get_this_vm_ref'
op|'('
name|'session'
op|')'
newline|'\n'
nl|'\n'
name|'vbd_ref'
op|'='
name|'create_vbd'
op|'('
name|'session'
op|','
name|'this_vm_ref'
op|','
name|'vdi_ref'
op|','
string|"'autodetect'"
op|','
nl|'\n'
name|'read_only'
op|'='
name|'read_only'
op|','
name|'bootable'
op|'='
name|'False'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Plugging VBD %s ... '"
op|')'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VBD.plug"'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Plugging VBD %s done.'"
op|')'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'orig_dev'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VBD.get_device"'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'VBD %(vbd_ref)s plugged as %(orig_dev)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'vbd_ref'"
op|':'
name|'vbd_ref'
op|','
string|"'orig_dev'"
op|':'
name|'orig_dev'
op|'}'
op|')'
newline|'\n'
name|'dev'
op|'='
name|'_remap_vbd_dev'
op|'('
name|'orig_dev'
op|')'
newline|'\n'
name|'if'
name|'dev'
op|'!='
name|'orig_dev'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'VBD %(vbd_ref)s plugged into wrong dev, '"
nl|'\n'
string|"'remapping to %(dev)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'vbd_ref'"
op|':'
name|'vbd_ref'
op|','
string|"'dev'"
op|':'
name|'dev'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'_wait_for_device'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'yield'
name|'dev'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Destroying VBD for VDI %s ... '"
op|')'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
name|'unplug_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'destroy_vbd'
op|'('
name|'session'
op|','
name|'vbd_ref'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'volume_utils'
op|'.'
name|'StorageError'
op|':'
newline|'\n'
comment|'# destroy_vbd() will log error'
nl|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Destroying VBD for VDI %s done.'"
op|')'
op|','
name|'vdi_ref'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_sys_hypervisor_uuid
dedent|''
dedent|''
name|'def'
name|'_get_sys_hypervisor_uuid'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
name|'with'
name|'file'
op|'('
string|"'/sys/hypervisor/uuid'"
op|')'
name|'as'
name|'f'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'f'
op|'.'
name|'readline'
op|'('
op|')'
op|'.'
name|'strip'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|get_this_vm_uuid
dedent|''
dedent|''
name|'def'
name|'get_this_vm_uuid'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'session'
name|'and'
name|'session'
op|'.'
name|'is_local_connection'
op|':'
newline|'\n'
comment|'# UUID is the control domain running on this host'
nl|'\n'
indent|'        '
name|'host_ref'
op|'='
name|'session'
op|'.'
name|'get_xenapi_host'
op|'('
op|')'
newline|'\n'
name|'vms'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_all_records_where"'
op|','
nl|'\n'
string|'\'field "is_control_domain"="true" and \''
nl|'\n'
string|'\'field "resident_on"="%s"\''
op|'%'
name|'host_ref'
op|')'
newline|'\n'
name|'return'
name|'vms'
op|'['
name|'vms'
op|'.'
name|'keys'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|']'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'_get_sys_hypervisor_uuid'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'IOError'
op|':'
newline|'\n'
comment|'# Some guest kernels (without 5c13f8067745efc15f6ad0158b58d57c44104c25)'
nl|'\n'
comment|'# cannot read from uuid after a reboot.  Fall back to trying xenstore.'
nl|'\n'
comment|'# See https://bugs.launchpad.net/ubuntu/+source/xen-api/+bug/1081182'
nl|'\n'
indent|'        '
name|'domid'
op|','
name|'_'
op|'='
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'xenstore-read'"
op|','
string|"'domid'"
op|','
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
name|'vm_key'
op|','
name|'_'
op|'='
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'xenstore-read'"
op|','
nl|'\n'
string|"'/local/domain/%s/vm'"
op|'%'
name|'domid'
op|'.'
name|'strip'
op|'('
op|')'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
name|'return'
name|'vm_key'
op|'.'
name|'strip'
op|'('
op|')'
op|'['
number|'4'
op|':'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_this_vm_ref
dedent|''
dedent|''
name|'def'
name|'_get_this_vm_ref'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'return'
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|'"VM.get_by_uuid"'
op|','
name|'get_this_vm_uuid'
op|'('
name|'session'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_partitions
dedent|''
name|'def'
name|'_get_partitions'
op|'('
name|'dev'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return partition information (num, size, type) for a device."""'
newline|'\n'
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'out'
op|','
name|'_err'
op|'='
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'parted'"
op|','
string|"'--script'"
op|','
string|"'--machine'"
op|','
nl|'\n'
name|'dev_path'
op|','
string|"'unit s'"
op|','
string|"'print'"
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
name|'lines'
op|'='
op|'['
name|'line'
name|'for'
name|'line'
name|'in'
name|'out'
op|'.'
name|'split'
op|'('
string|"'\\n'"
op|')'
name|'if'
name|'line'
op|']'
newline|'\n'
name|'partitions'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Partitions:"'
op|')'
op|')'
newline|'\n'
name|'for'
name|'line'
name|'in'
name|'lines'
op|'['
number|'2'
op|':'
op|']'
op|':'
newline|'\n'
indent|'        '
name|'num'
op|','
name|'start'
op|','
name|'end'
op|','
name|'size'
op|','
name|'ptype'
op|'='
name|'line'
op|'.'
name|'split'
op|'('
string|"':'"
op|')'
op|'['
op|':'
number|'5'
op|']'
newline|'\n'
name|'start'
op|'='
name|'int'
op|'('
name|'start'
op|'.'
name|'rstrip'
op|'('
string|"'s'"
op|')'
op|')'
newline|'\n'
name|'end'
op|'='
name|'int'
op|'('
name|'end'
op|'.'
name|'rstrip'
op|'('
string|"'s'"
op|')'
op|')'
newline|'\n'
name|'size'
op|'='
name|'int'
op|'('
name|'size'
op|'.'
name|'rstrip'
op|'('
string|"'s'"
op|')'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"  %(num)s: %(ptype)s %(size)d sectors"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'num'"
op|':'
name|'num'
op|','
string|"'ptype'"
op|':'
name|'ptype'
op|','
string|"'size'"
op|':'
name|'size'
op|'}'
op|')'
newline|'\n'
name|'partitions'
op|'.'
name|'append'
op|'('
op|'('
name|'num'
op|','
name|'start'
op|','
name|'size'
op|','
name|'ptype'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'partitions'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_stream_disk
dedent|''
name|'def'
name|'_stream_disk'
op|'('
name|'session'
op|','
name|'image_service_func'
op|','
name|'image_type'
op|','
name|'virtual_size'
op|','
name|'dev'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'offset'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'image_type'
op|'=='
name|'ImageType'
op|'.'
name|'DISK'
op|':'
newline|'\n'
indent|'        '
name|'offset'
op|'='
name|'MBR_SIZE_BYTES'
newline|'\n'
name|'_write_partition'
op|'('
name|'session'
op|','
name|'virtual_size'
op|','
name|'dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
nl|'\n'
name|'with'
name|'utils'
op|'.'
name|'temporary_chown'
op|'('
name|'dev_path'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'open'
op|'('
name|'dev_path'
op|','
string|"'wb'"
op|')'
name|'as'
name|'f'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'.'
name|'seek'
op|'('
name|'offset'
op|')'
newline|'\n'
name|'image_service_func'
op|'('
name|'f'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_write_partition
dedent|''
dedent|''
dedent|''
name|'def'
name|'_write_partition'
op|'('
name|'session'
op|','
name|'virtual_size'
op|','
name|'dev'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'primary_first'
op|'='
name|'MBR_SIZE_SECTORS'
newline|'\n'
name|'primary_last'
op|'='
name|'MBR_SIZE_SECTORS'
op|'+'
op|'('
name|'virtual_size'
op|'/'
name|'SECTOR_SIZE'
op|')'
op|'-'
number|'1'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Writing partition table %(primary_first)d %(primary_last)d'"
nl|'\n'
string|"' to %(dev_path)s...'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'primary_first'"
op|':'
name|'primary_first'
op|','
string|"'primary_last'"
op|':'
name|'primary_last'
op|','
nl|'\n'
string|"'dev_path'"
op|':'
name|'dev_path'
op|'}'
op|')'
newline|'\n'
nl|'\n'
DECL|function|execute
name|'def'
name|'execute'
op|'('
op|'*'
name|'cmd'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'utils'
op|'.'
name|'execute'
op|'('
op|'*'
name|'cmd'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'_make_partition'
op|'('
name|'session'
op|','
name|'dev'
op|','
string|'"%ds"'
op|'%'
name|'primary_first'
op|','
string|'"%ds"'
op|'%'
name|'primary_last'
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Writing partition table %s done.'"
op|')'
op|','
name|'dev_path'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_min_sectors
dedent|''
name|'def'
name|'_get_min_sectors'
op|'('
name|'partition_path'
op|','
name|'block_size'
op|'='
number|'4096'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'stdout'
op|','
name|'_err'
op|'='
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'resize2fs'"
op|','
string|"'-P'"
op|','
name|'partition_path'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
name|'min_size_blocks'
op|'='
name|'long'
op|'('
name|'re'
op|'.'
name|'sub'
op|'('
string|"'[^0-9]'"
op|','
string|"''"
op|','
name|'stdout'
op|')'
op|')'
newline|'\n'
name|'min_size_bytes'
op|'='
name|'min_size_blocks'
op|'*'
name|'block_size'
newline|'\n'
name|'return'
name|'min_size_bytes'
op|'/'
name|'SECTOR_SIZE'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_repair_filesystem
dedent|''
name|'def'
name|'_repair_filesystem'
op|'('
name|'partition_path'
op|')'
op|':'
newline|'\n'
comment|'# Exit Code 1 = File system errors corrected'
nl|'\n'
comment|'#           2 = File system errors corrected, system needs a reboot'
nl|'\n'
indent|'    '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'e2fsck'"
op|','
string|"'-f'"
op|','
string|"'-y'"
op|','
name|'partition_path'
op|','
name|'run_as_root'
op|'='
name|'True'
op|','
nl|'\n'
name|'check_exit_code'
op|'='
op|'['
number|'0'
op|','
number|'1'
op|','
number|'2'
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_resize_part_and_fs
dedent|''
name|'def'
name|'_resize_part_and_fs'
op|'('
name|'dev'
op|','
name|'start'
op|','
name|'old_sectors'
op|','
name|'new_sectors'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Resize partition and fileystem.\n\n    This assumes we are dealing with a single primary partition and using\n    ext3 or ext4.\n    """'
newline|'\n'
name|'size'
op|'='
name|'new_sectors'
op|'-'
name|'start'
newline|'\n'
name|'end'
op|'='
name|'new_sectors'
op|'-'
number|'1'
newline|'\n'
nl|'\n'
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|')'
newline|'\n'
name|'partition_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dev'
op|','
name|'partition'
op|'='
number|'1'
op|')'
newline|'\n'
nl|'\n'
comment|"# Replay journal if FS wasn't cleanly unmounted"
nl|'\n'
name|'_repair_filesystem'
op|'('
name|'partition_path'
op|')'
newline|'\n'
nl|'\n'
comment|'# Remove ext3 journal (making it ext2)'
nl|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'tune2fs'"
op|','
string|"'-O ^has_journal'"
op|','
name|'partition_path'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'new_sectors'
op|'<'
name|'old_sectors'
op|':'
newline|'\n'
comment|'# Resizing down, resize filesystem before partition resize'
nl|'\n'
indent|'        '
name|'min_sectors'
op|'='
name|'_get_min_sectors'
op|'('
name|'partition_path'
op|')'
newline|'\n'
name|'if'
name|'min_sectors'
op|'>='
name|'new_sectors'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
op|'('
name|'_'
op|'('
string|"'Resize down not allowed because minimum '"
nl|'\n'
string|"'filesystem sectors %(min_sectors)d is too big '"
nl|'\n'
string|"'for target sectors %(new_sectors)d'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'min_sectors'"
op|':'
name|'min_sectors'
op|','
string|"'new_sectors'"
op|':'
name|'new_sectors'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'ResizeError'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
dedent|''
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'resize2fs'"
op|','
name|'partition_path'
op|','
string|"'%ds'"
op|'%'
name|'size'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'parted'"
op|','
string|"'--script'"
op|','
name|'dev_path'
op|','
string|"'rm'"
op|','
string|"'1'"
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'parted'"
op|','
string|"'--script'"
op|','
name|'dev_path'
op|','
string|"'mkpart'"
op|','
nl|'\n'
string|"'primary'"
op|','
nl|'\n'
string|"'%ds'"
op|'%'
name|'start'
op|','
nl|'\n'
string|"'%ds'"
op|'%'
name|'end'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'new_sectors'
op|'>'
name|'old_sectors'
op|':'
newline|'\n'
comment|'# Resizing up, resize filesystem after partition resize'
nl|'\n'
indent|'        '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'resize2fs'"
op|','
name|'partition_path'
op|','
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
comment|'# Add back journal'
nl|'\n'
dedent|''
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'tune2fs'"
op|','
string|"'-j'"
op|','
name|'partition_path'
op|','
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_log_progress_if_required
dedent|''
name|'def'
name|'_log_progress_if_required'
op|'('
name|'left'
op|','
name|'last_log_time'
op|','
name|'virtual_size'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'if'
name|'timeutils'
op|'.'
name|'is_older_than'
op|'('
name|'last_log_time'
op|','
name|'PROGRESS_INTERVAL_SECONDS'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'last_log_time'
op|'='
name|'timeutils'
op|'.'
name|'utcnow'
op|'('
op|')'
newline|'\n'
name|'complete_pct'
op|'='
name|'float'
op|'('
name|'virtual_size'
op|'-'
name|'left'
op|')'
op|'/'
name|'virtual_size'
op|'*'
number|'100'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Sparse copy in progress, "'
nl|'\n'
string|'"%(complete_pct).2f%% complete. "'
nl|'\n'
string|'"%(left)s bytes left to copy"'
op|')'
op|','
nl|'\n'
op|'{'
string|'"complete_pct"'
op|':'
name|'complete_pct'
op|','
string|'"left"'
op|':'
name|'left'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'last_log_time'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_sparse_copy
dedent|''
name|'def'
name|'_sparse_copy'
op|'('
name|'src_path'
op|','
name|'dst_path'
op|','
name|'virtual_size'
op|','
name|'block_size'
op|'='
number|'4096'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Copy data, skipping long runs of zeros to create a sparse file."""'
newline|'\n'
name|'start_time'
op|'='
name|'last_log_time'
op|'='
name|'timeutils'
op|'.'
name|'utcnow'
op|'('
op|')'
newline|'\n'
name|'EMPTY_BLOCK'
op|'='
string|"'\\0'"
op|'*'
name|'block_size'
newline|'\n'
name|'bytes_read'
op|'='
number|'0'
newline|'\n'
name|'skipped_bytes'
op|'='
number|'0'
newline|'\n'
name|'left'
op|'='
name|'virtual_size'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Starting sparse_copy src=%(src_path)s dst=%(dst_path)s "'
nl|'\n'
string|'"virtual_size=%(virtual_size)d block_size=%(block_size)d"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'src_path'"
op|':'
name|'src_path'
op|','
string|"'dst_path'"
op|':'
name|'dst_path'
op|','
nl|'\n'
string|"'virtual_size'"
op|':'
name|'virtual_size'
op|','
string|"'block_size'"
op|':'
name|'block_size'
op|'}'
op|')'
newline|'\n'
nl|'\n'
comment|"# NOTE(sirp): we need read/write access to the devices; since we don't have"
nl|'\n'
comment|"# the luxury of shelling out to a sudo'd command, we temporarily take"
nl|'\n'
comment|'# ownership of the devices.'
nl|'\n'
name|'with'
name|'utils'
op|'.'
name|'temporary_chown'
op|'('
name|'src_path'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'utils'
op|'.'
name|'temporary_chown'
op|'('
name|'dst_path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'open'
op|'('
name|'src_path'
op|','
string|'"r"'
op|')'
name|'as'
name|'src'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'open'
op|'('
name|'dst_path'
op|','
string|'"w"'
op|')'
name|'as'
name|'dst'
op|':'
newline|'\n'
indent|'                    '
name|'data'
op|'='
name|'src'
op|'.'
name|'read'
op|'('
name|'min'
op|'('
name|'block_size'
op|','
name|'left'
op|')'
op|')'
newline|'\n'
name|'while'
name|'data'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'data'
op|'=='
name|'EMPTY_BLOCK'
op|':'
newline|'\n'
indent|'                            '
name|'dst'
op|'.'
name|'seek'
op|'('
name|'block_size'
op|','
name|'os'
op|'.'
name|'SEEK_CUR'
op|')'
newline|'\n'
name|'left'
op|'-='
name|'block_size'
newline|'\n'
name|'bytes_read'
op|'+='
name|'block_size'
newline|'\n'
name|'skipped_bytes'
op|'+='
name|'block_size'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                            '
name|'dst'
op|'.'
name|'write'
op|'('
name|'data'
op|')'
newline|'\n'
name|'data_len'
op|'='
name|'len'
op|'('
name|'data'
op|')'
newline|'\n'
name|'left'
op|'-='
name|'data_len'
newline|'\n'
name|'bytes_read'
op|'+='
name|'data_len'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'left'
op|'<='
number|'0'
op|':'
newline|'\n'
indent|'                            '
name|'break'
newline|'\n'
nl|'\n'
dedent|''
name|'data'
op|'='
name|'src'
op|'.'
name|'read'
op|'('
name|'min'
op|'('
name|'block_size'
op|','
name|'left'
op|')'
op|')'
newline|'\n'
name|'greenthread'
op|'.'
name|'sleep'
op|'('
number|'0'
op|')'
newline|'\n'
name|'last_log_time'
op|'='
name|'_log_progress_if_required'
op|'('
nl|'\n'
name|'left'
op|','
name|'last_log_time'
op|','
name|'virtual_size'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'duration'
op|'='
name|'timeutils'
op|'.'
name|'delta_seconds'
op|'('
name|'start_time'
op|','
name|'timeutils'
op|'.'
name|'utcnow'
op|'('
op|')'
op|')'
newline|'\n'
name|'compression_pct'
op|'='
name|'float'
op|'('
name|'skipped_bytes'
op|')'
op|'/'
name|'bytes_read'
op|'*'
number|'100'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Finished sparse_copy in %(duration).2f secs, "'
nl|'\n'
string|'"%(compression_pct).2f%% reduction in size"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'duration'"
op|':'
name|'duration'
op|','
string|"'compression_pct'"
op|':'
name|'compression_pct'
op|'}'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_copy_partition
dedent|''
name|'def'
name|'_copy_partition'
op|'('
name|'session'
op|','
name|'src_ref'
op|','
name|'dst_ref'
op|','
name|'partition'
op|','
name|'virtual_size'
op|')'
op|':'
newline|'\n'
comment|'# Part of disk taken up by MBR'
nl|'\n'
indent|'    '
name|'virtual_size'
op|'-='
name|'MBR_SIZE_BYTES'
newline|'\n'
nl|'\n'
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'src_ref'
op|','
name|'read_only'
op|'='
name|'True'
op|')'
name|'as'
name|'src'
op|':'
newline|'\n'
indent|'        '
name|'src_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'src'
op|','
name|'partition'
op|'='
name|'partition'
op|')'
newline|'\n'
nl|'\n'
name|'with'
name|'vdi_attached_here'
op|'('
name|'session'
op|','
name|'dst_ref'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
name|'as'
name|'dst'
op|':'
newline|'\n'
indent|'            '
name|'dst_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'dst'
op|','
name|'partition'
op|'='
name|'partition'
op|')'
newline|'\n'
nl|'\n'
name|'_write_partition'
op|'('
name|'session'
op|','
name|'virtual_size'
op|','
name|'dst'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'xenapi_sparse_copy'
op|':'
newline|'\n'
indent|'                '
name|'_sparse_copy'
op|'('
name|'src_path'
op|','
name|'dst_path'
op|','
name|'virtual_size'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'num_blocks'
op|'='
name|'virtual_size'
op|'/'
name|'SECTOR_SIZE'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'dd'"
op|','
nl|'\n'
string|"'if=%s'"
op|'%'
name|'src_path'
op|','
nl|'\n'
string|"'of=%s'"
op|'%'
name|'dst_path'
op|','
nl|'\n'
string|"'count=%d'"
op|'%'
name|'num_blocks'
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_mount_filesystem
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_mount_filesystem'
op|'('
name|'dev_path'
op|','
name|'dir'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""mounts the device specified by dev_path in dir."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'_out'
op|','
name|'err'
op|'='
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mount'"
op|','
nl|'\n'
string|"'-t'"
op|','
string|"'ext2,ext3,ext4,reiserfs'"
op|','
nl|'\n'
name|'dev_path'
op|','
name|'dir'
op|','
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'processutils'
op|'.'
name|'ProcessExecutionError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'err'
op|'='
name|'str'
op|'('
name|'e'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'err'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_mounted_processing
dedent|''
name|'def'
name|'_mounted_processing'
op|'('
name|'device'
op|','
name|'key'
op|','
name|'net'
op|','
name|'metadata'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Callback which runs with the image VDI attached."""'
newline|'\n'
comment|'# NB: Partition 1 hardcoded'
nl|'\n'
name|'dev_path'
op|'='
name|'utils'
op|'.'
name|'make_dev_path'
op|'('
name|'device'
op|','
name|'partition'
op|'='
number|'1'
op|')'
newline|'\n'
name|'with'
name|'utils'
op|'.'
name|'tempdir'
op|'('
op|')'
name|'as'
name|'tmpdir'
op|':'
newline|'\n'
comment|'# Mount only Linux filesystems, to avoid disturbing NTFS images'
nl|'\n'
indent|'        '
name|'err'
op|'='
name|'_mount_filesystem'
op|'('
name|'dev_path'
op|','
name|'tmpdir'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'err'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
comment|'# This try block ensures that the umount occurs'
nl|'\n'
indent|'                '
name|'if'
name|'not'
name|'agent'
op|'.'
name|'find_guest_agent'
op|'('
name|'tmpdir'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'vfs'
op|'='
name|'vfsimpl'
op|'.'
name|'VFSLocalFS'
op|'('
name|'imgfile'
op|'='
name|'None'
op|','
nl|'\n'
name|'imgfmt'
op|'='
name|'None'
op|','
nl|'\n'
name|'imgdir'
op|'='
name|'tmpdir'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'Manipulating interface files directly'"
op|')'
op|')'
newline|'\n'
comment|"# for xenapi, we don't 'inject' admin_password here,"
nl|'\n'
comment|"# it's handled at instance startup time, nor do we"
nl|'\n'
comment|'# support injecting arbitrary files here.'
nl|'\n'
name|'disk'
op|'.'
name|'inject_data_into_fs'
op|'('
name|'vfs'
op|','
nl|'\n'
name|'key'
op|','
name|'net'
op|','
name|'metadata'
op|','
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'                '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'umount'"
op|','
name|'dev_path'
op|','
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'Failed to mount filesystem (expected for '"
nl|'\n'
string|"'non-linux instances): %s'"
op|')'
op|'%'
name|'err'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_prepare_injectables
dedent|''
dedent|''
dedent|''
name|'def'
name|'_prepare_injectables'
op|'('
name|'inst'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""\n    prepares the ssh key and the network configuration file to be\n    injected into the disk image\n    """'
newline|'\n'
comment|'#do the import here - Jinja2 will be loaded only if injection is performed'
nl|'\n'
name|'import'
name|'jinja2'
newline|'\n'
name|'tmpl_path'
op|','
name|'tmpl_file'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'split'
op|'('
name|'CONF'
op|'.'
name|'injected_network_template'
op|')'
newline|'\n'
name|'env'
op|'='
name|'jinja2'
op|'.'
name|'Environment'
op|'('
name|'loader'
op|'='
name|'jinja2'
op|'.'
name|'FileSystemLoader'
op|'('
name|'tmpl_path'
op|')'
op|')'
newline|'\n'
name|'template'
op|'='
name|'env'
op|'.'
name|'get_template'
op|'('
name|'tmpl_file'
op|')'
newline|'\n'
nl|'\n'
name|'metadata'
op|'='
name|'inst'
op|'['
string|"'metadata'"
op|']'
newline|'\n'
name|'key'
op|'='
name|'str'
op|'('
name|'inst'
op|'['
string|"'key_data'"
op|']'
op|')'
newline|'\n'
name|'net'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'network_info'
op|':'
newline|'\n'
indent|'        '
name|'ifc_num'
op|'='
op|'-'
number|'1'
newline|'\n'
name|'interfaces_info'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
indent|'            '
name|'ifc_num'
op|'+='
number|'1'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'not'
name|'vif'
op|'['
string|"'network'"
op|']'
op|'.'
name|'get_meta'
op|'('
string|"'injected'"
op|')'
op|':'
newline|'\n'
comment|'# network is not specified injected'
nl|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
comment|'# vif network is None'
nl|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
comment|'# NOTE(tr3buchet): using all subnets in case dns is stored in a'
nl|'\n'
comment|"#                  subnet that isn't chosen as first v4 or v6"
nl|'\n'
comment|'#                  subnet in the case where there is more than one'
nl|'\n'
comment|'# dns = list of address of each dns entry from each vif subnet'
nl|'\n'
dedent|''
name|'dns'
op|'='
op|'['
name|'ip'
op|'['
string|"'address'"
op|']'
name|'for'
name|'subnet'
name|'in'
name|'vif'
op|'['
string|"'network'"
op|']'
op|'['
string|"'subnets'"
op|']'
nl|'\n'
name|'for'
name|'ip'
name|'in'
name|'subnet'
op|'['
string|"'dns'"
op|']'
op|']'
newline|'\n'
name|'dns'
op|'='
string|"' '"
op|'.'
name|'join'
op|'('
name|'dns'
op|')'
op|'.'
name|'strip'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'interface_info'
op|'='
op|'{'
string|"'name'"
op|':'
string|"'eth%d'"
op|'%'
name|'ifc_num'
op|','
nl|'\n'
string|"'address'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'netmask'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'gateway'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'broadcast'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'dns'"
op|':'
name|'dns'
name|'or'
string|"''"
op|','
nl|'\n'
string|"'address_v6'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'netmask_v6'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'gateway_v6'"
op|':'
string|"''"
op|','
nl|'\n'
string|"'use_ipv6'"
op|':'
name|'CONF'
op|'.'
name|'use_ipv6'
op|'}'
newline|'\n'
nl|'\n'
comment|'# NOTE(tr3buchet): the original code used the old network_info'
nl|'\n'
comment|'#                  which only supported a single ipv4 subnet'
nl|'\n'
comment|'#                  (and optionally, a single ipv6 subnet).'
nl|'\n'
comment|'#                  I modified it to use the new network info model,'
nl|'\n'
comment|'#                  which adds support for multiple v4 or v6'
nl|'\n'
comment|'#                  subnets. I chose to ignore any additional'
nl|'\n'
comment|'#                  subnets, just as the original code ignored'
nl|'\n'
comment|'#                  additional IP information'
nl|'\n'
nl|'\n'
comment|'# populate v4 info if v4 subnet and ip exist'
nl|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# grab the first v4 subnet (or it raises)'
nl|'\n'
indent|'                '
name|'subnet'
op|'='
op|'['
name|'s'
name|'for'
name|'s'
name|'in'
name|'vif'
op|'['
string|"'network'"
op|']'
op|'['
string|"'subnets'"
op|']'
nl|'\n'
name|'if'
name|'s'
op|'['
string|"'version'"
op|']'
op|'=='
number|'4'
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
comment|"# get the subnet's first ip (or it raises)"
nl|'\n'
name|'ip'
op|'='
name|'subnet'
op|'['
string|"'ips'"
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
comment|'# populate interface_info'
nl|'\n'
name|'subnet_netaddr'
op|'='
name|'subnet'
op|'.'
name|'as_netaddr'
op|'('
op|')'
newline|'\n'
name|'interface_info'
op|'['
string|"'address'"
op|']'
op|'='
name|'ip'
op|'['
string|"'address'"
op|']'
newline|'\n'
name|'interface_info'
op|'['
string|"'netmask'"
op|']'
op|'='
name|'subnet_netaddr'
op|'.'
name|'netmask'
newline|'\n'
name|'interface_info'
op|'['
string|"'gateway'"
op|']'
op|'='
name|'subnet'
op|'['
string|"'gateway'"
op|']'
op|'['
string|"'address'"
op|']'
newline|'\n'
name|'interface_info'
op|'['
string|"'broadcast'"
op|']'
op|'='
name|'subnet_netaddr'
op|'.'
name|'broadcast'
newline|'\n'
dedent|''
name|'except'
name|'IndexError'
op|':'
newline|'\n'
comment|"# there isn't a v4 subnet or there are no ips"
nl|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
comment|'# populate v6 info if v6 subnet and ip exist'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
comment|'# grab the first v6 subnet (or it raises)'
nl|'\n'
indent|'                '
name|'subnet'
op|'='
op|'['
name|'s'
name|'for'
name|'s'
name|'in'
name|'vif'
op|'['
string|"'network'"
op|']'
op|'['
string|"'subnets'"
op|']'
nl|'\n'
name|'if'
name|'s'
op|'['
string|"'version'"
op|']'
op|'=='
number|'6'
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
comment|"# get the subnet's first ip (or it raises)"
nl|'\n'
name|'ip'
op|'='
name|'subnet'
op|'['
string|"'ips'"
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
comment|'# populate interface_info'
nl|'\n'
name|'interface_info'
op|'['
string|"'address_v6'"
op|']'
op|'='
name|'ip'
op|'['
string|"'address'"
op|']'
newline|'\n'
name|'interface_info'
op|'['
string|"'netmask_v6'"
op|']'
op|'='
name|'subnet'
op|'.'
name|'as_netaddr'
op|'('
op|')'
op|'.'
name|'netmask'
newline|'\n'
name|'interface_info'
op|'['
string|"'gateway_v6'"
op|']'
op|'='
name|'subnet'
op|'['
string|"'gateway'"
op|']'
op|'['
string|"'address'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'IndexError'
op|':'
newline|'\n'
comment|"# there isn't a v6 subnet or there are no ips"
nl|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
dedent|''
name|'interfaces_info'
op|'.'
name|'append'
op|'('
name|'interface_info'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'interfaces_info'
op|':'
newline|'\n'
indent|'            '
name|'net'
op|'='
name|'template'
op|'.'
name|'render'
op|'('
op|'{'
string|"'interfaces'"
op|':'
name|'interfaces_info'
op|','
nl|'\n'
string|"'use_ipv6'"
op|':'
name|'CONF'
op|'.'
name|'use_ipv6'
op|'}'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'key'
op|','
name|'net'
op|','
name|'metadata'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|ensure_correct_host
dedent|''
name|'def'
name|'ensure_correct_host'
op|'('
name|'session'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Ensure we\'re connected to the host we\'re running on. This is the\n    required configuration for anything that uses vdi_attached_here.\n    """'
newline|'\n'
name|'this_vm_uuid'
op|'='
name|'get_this_vm_uuid'
op|'('
name|'session'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VM.get_by_uuid'"
op|','
name|'this_vm_uuid'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'exc'
op|'.'
name|'details'
op|'['
number|'0'
op|']'
op|'!='
string|"'UUID_INVALID'"
op|':'
newline|'\n'
indent|'            '
name|'raise'
newline|'\n'
dedent|''
name|'raise'
name|'Exception'
op|'('
name|'_'
op|'('
string|"'This domU must be running on the host '"
nl|'\n'
string|"'specified by xenapi_connection_url'"
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|move_disks
dedent|''
dedent|''
name|'def'
name|'move_disks'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'disk_info'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Move and possibly link VHDs via the XAPI plugin."""'
newline|'\n'
name|'imported_vhds'
op|'='
name|'session'
op|'.'
name|'call_plugin_serialized'
op|'('
nl|'\n'
string|"'migration'"
op|','
string|"'move_vhds_into_sr'"
op|','
name|'instance_uuid'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
name|'sr_path'
op|'='
name|'get_sr_path'
op|'('
name|'session'
op|')'
op|','
name|'uuid_stack'
op|'='
name|'_make_uuid_stack'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Now we rescan the SR so we find the VHDs'
nl|'\n'
name|'scan_default_sr'
op|'('
name|'session'
op|')'
newline|'\n'
nl|'\n'
name|'root_uuid'
op|'='
name|'imported_vhds'
op|'['
string|"'root'"
op|']'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'root_vdi_ref'
op|'='
name|'session'
op|'.'
name|'call_xenapi'
op|'('
string|"'VDI.get_by_uuid'"
op|','
name|'root_uuid'
op|')'
newline|'\n'
nl|'\n'
comment|'# Set name-label so we can find if we need to clean up a failed migration'
nl|'\n'
name|'_set_vdi_info'
op|'('
name|'session'
op|','
name|'root_vdi_ref'
op|','
string|"'root'"
op|','
name|'instance'
op|'['
string|"'name'"
op|']'
op|','
string|"'root'"
op|','
nl|'\n'
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'return'
op|'{'
string|"'uuid'"
op|':'
name|'root_uuid'
op|','
string|"'ref'"
op|':'
name|'root_vdi_ref'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|vm_ref_or_raise
dedent|''
name|'def'
name|'vm_ref_or_raise'
op|'('
name|'session'
op|','
name|'instance_name'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'vm_ref'
op|'='
name|'lookup'
op|'('
name|'session'
op|','
name|'instance_name'
op|')'
newline|'\n'
name|'if'
name|'vm_ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|'('
name|'instance_id'
op|'='
name|'instance_name'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'vm_ref'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|handle_ipxe_iso
dedent|''
name|'def'
name|'handle_ipxe_iso'
op|'('
name|'session'
op|','
name|'instance'
op|','
name|'cd_vdi'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""iPXE ISOs are a mechanism to allow the customer to roll their own\n    image.\n\n    To use this feature, a service provider needs to configure the\n    appropriate Nova flags, roll an iPXE ISO, then distribute that image\n    to customers via Glance.\n\n    NOTE: `mkisofs` is not present by default in the Dom0, so the service\n    provider can either add that package manually to Dom0 or include the\n    `mkisofs` binary in the image itself.\n    """'
newline|'\n'
name|'boot_menu_url'
op|'='
name|'CONF'
op|'.'
name|'xenapi_ipxe_boot_menu_url'
newline|'\n'
name|'if'
name|'not'
name|'boot_menu_url'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|"'xenapi_ipxe_boot_menu_url not set, user will have to'"
nl|'\n'
string|"' enter URL manually...'"
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'network_name'
op|'='
name|'CONF'
op|'.'
name|'xenapi_ipxe_network_name'
newline|'\n'
name|'if'
name|'not'
name|'network_name'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|"'xenapi_ipxe_network_name not set, user will have to'"
nl|'\n'
string|"' enter IP manually...'"
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'network'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'vif'
op|'['
string|"'network'"
op|']'
op|'['
string|"'label'"
op|']'
op|'=='
name|'network_name'
op|':'
newline|'\n'
indent|'            '
name|'network'
op|'='
name|'vif'
op|'['
string|"'network'"
op|']'
newline|'\n'
name|'break'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'network'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|'"Unable to find network matching \'%(network_name)s\', user"'
nl|'\n'
string|'" will have to enter IP manually..."'
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'network_name'"
op|':'
name|'network_name'
op|'}'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'sr_path'
op|'='
name|'get_sr_path'
op|'('
name|'session'
op|')'
newline|'\n'
nl|'\n'
comment|'# Unpack IPv4 network info'
nl|'\n'
name|'subnet'
op|'='
op|'['
name|'sn'
name|'for'
name|'sn'
name|'in'
name|'network'
op|'['
string|"'subnets'"
op|']'
nl|'\n'
name|'if'
name|'sn'
op|'['
string|"'version'"
op|']'
op|'=='
number|'4'
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
name|'ip'
op|'='
name|'subnet'
op|'['
string|"'ips'"
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
name|'ip_address'
op|'='
name|'ip'
op|'['
string|"'address'"
op|']'
newline|'\n'
name|'netmask'
op|'='
name|'network_model'
op|'.'
name|'get_netmask'
op|'('
name|'ip'
op|','
name|'subnet'
op|')'
newline|'\n'
name|'gateway'
op|'='
name|'subnet'
op|'['
string|"'gateway'"
op|']'
op|'['
string|"'address'"
op|']'
newline|'\n'
name|'dns'
op|'='
name|'subnet'
op|'['
string|"'dns'"
op|']'
op|'['
number|'0'
op|']'
op|'['
string|"'address'"
op|']'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'session'
op|'.'
name|'call_plugin_serialized'
op|'('
string|'"ipxe"'
op|','
string|'"inject"'
op|','
name|'sr_path'
op|','
nl|'\n'
name|'cd_vdi'
op|'['
string|"'uuid'"
op|']'
op|','
name|'boot_menu_url'
op|','
name|'ip_address'
op|','
name|'netmask'
op|','
nl|'\n'
name|'gateway'
op|','
name|'dns'
op|','
name|'CONF'
op|'.'
name|'xenapi_ipxe_mkisofs_cmd'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'session'
op|'.'
name|'XenAPI'
op|'.'
name|'Failure'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'        '
name|'_type'
op|','
name|'_method'
op|','
name|'error'
op|'='
name|'exc'
op|'.'
name|'details'
op|'['
op|':'
number|'3'
op|']'
newline|'\n'
name|'if'
name|'error'
op|'=='
string|"'CommandNotFound'"
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|'"ISO creation tool \'%s\' does not exist."'
op|')'
op|'%'
nl|'\n'
name|'CONF'
op|'.'
name|'xenapi_ipxe_mkisofs_cmd'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'raise'
newline|'\n'
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
