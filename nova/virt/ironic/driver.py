begin_unit
comment|'# coding=utf-8'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Copyright 2014 Red Hat, Inc.'
nl|'\n'
comment|'# Copyright 2013 Hewlett-Packard Development Company, L.P.'
nl|'\n'
comment|'# All Rights Reserved.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
nl|'\n'
string|'"""\nA driver wrapping the Ironic API, such that Nova may provision\nbare metal resources.\n"""'
newline|'\n'
name|'import'
name|'logging'
name|'as'
name|'py_logging'
newline|'\n'
nl|'\n'
name|'from'
name|'ironicclient'
name|'import'
name|'exc'
name|'as'
name|'ironic_exception'
newline|'\n'
name|'from'
name|'oslo'
op|'.'
name|'config'
name|'import'
name|'cfg'
newline|'\n'
nl|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'arch'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'power_state'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'context'
name|'as'
name|'nova_context'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'exception'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_LW'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'objects'
name|'import'
name|'instance'
name|'as'
name|'instance_obj'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'jsonutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'log'
name|'as'
name|'logging'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'driver'
name|'as'
name|'virt_driver'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'firewall'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'ironic'
name|'import'
name|'client_wrapper'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'ironic'
name|'import'
name|'ironic_states'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|LOG
name|'LOG'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|opts
name|'opts'
op|'='
op|'['
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'api_version'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'1'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Version of Ironic API service endpoint.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'api_endpoint'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'URL for Ironic API endpoint.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'admin_username'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Ironic keystone admin name'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'admin_password'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Ironic keystone admin password.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'admin_auth_token'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Ironic keystone auth token.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'admin_url'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Keystone public API endpoint.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'client_log_level'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Log level override for ironicclient. Set this in '"
nl|'\n'
string|'\'order to override the global "default_log_levels", \''
nl|'\n'
string|'\'"verbose", and "debug" settings.\''
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'admin_tenant_name'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Ironic keystone tenant name.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'api_max_retries'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'60'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
op|'('
string|"'How many retries when a request does conflict.'"
op|')'
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'api_retry_interval'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'2'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
op|'('
string|"'How often to retry in seconds when a request '"
nl|'\n'
string|"'does conflict'"
op|')'
op|')'
op|','
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
DECL|variable|ironic_group
name|'ironic_group'
op|'='
name|'cfg'
op|'.'
name|'OptGroup'
op|'('
name|'name'
op|'='
string|"'ironic'"
op|','
nl|'\n'
DECL|variable|title
name|'title'
op|'='
string|"'Ironic Options'"
op|')'
newline|'\n'
nl|'\n'
DECL|variable|CONF
name|'CONF'
op|'='
name|'cfg'
op|'.'
name|'CONF'
newline|'\n'
name|'CONF'
op|'.'
name|'register_group'
op|'('
name|'ironic_group'
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'register_opts'
op|'('
name|'opts'
op|','
name|'ironic_group'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|_POWER_STATE_MAP
name|'_POWER_STATE_MAP'
op|'='
op|'{'
nl|'\n'
name|'ironic_states'
op|'.'
name|'POWER_ON'
op|':'
name|'power_state'
op|'.'
name|'RUNNING'
op|','
nl|'\n'
name|'ironic_states'
op|'.'
name|'NOSTATE'
op|':'
name|'power_state'
op|'.'
name|'NOSTATE'
op|','
nl|'\n'
name|'ironic_states'
op|'.'
name|'POWER_OFF'
op|':'
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|map_power_state
name|'def'
name|'map_power_state'
op|'('
name|'state'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'_POWER_STATE_MAP'
op|'['
name|'state'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"Power state %s not found."'
op|')'
op|','
name|'state'
op|')'
newline|'\n'
name|'return'
name|'power_state'
op|'.'
name|'NOSTATE'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_validate_instance_and_node
dedent|''
dedent|''
name|'def'
name|'_validate_instance_and_node'
op|'('
name|'icli'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Get the node associated with the instance.\n\n    Check with the Ironic service that this instance is associated with a\n    node, and return the node.\n    """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# TODO(mrda): Bug ID 1365228 icli should be renamed ironicclient'
nl|'\n'
comment|'# throughout'
nl|'\n'
indent|'        '
name|'return'
name|'icli'
op|'.'
name|'call'
op|'('
string|'"node.get_by_instance_uuid"'
op|','
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ironic_exception'
op|'.'
name|'NotFound'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|'('
name|'instance_id'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_nodes_supported_instances
dedent|''
dedent|''
name|'def'
name|'_get_nodes_supported_instances'
op|'('
name|'cpu_arch'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return supported instances for a node."""'
newline|'\n'
name|'if'
name|'not'
name|'cpu_arch'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'['
op|']'
newline|'\n'
dedent|''
name|'return'
op|'['
op|'('
name|'cpu_arch'
op|','
string|"'baremetal'"
op|','
string|"'baremetal'"
op|')'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|IronicDriver
dedent|''
name|'class'
name|'IronicDriver'
op|'('
name|'virt_driver'
op|'.'
name|'ComputeDriver'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Hypervisor driver for Ironic - bare metal provisioning."""'
newline|'\n'
nl|'\n'
DECL|variable|capabilities
name|'capabilities'
op|'='
op|'{'
string|'"has_imagecache"'
op|':'
name|'False'
op|','
nl|'\n'
string|'"supports_recreate"'
op|':'
name|'False'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'virtapi'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'super'
op|'('
name|'IronicDriver'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'virtapi'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'='
name|'firewall'
op|'.'
name|'load_driver'
op|'('
nl|'\n'
name|'default'
op|'='
string|"'nova.virt.firewall.NoopFirewallDriver'"
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(mrda): Bug ID 1365230 Logging configurability needs'
nl|'\n'
comment|'# to be addressed'
nl|'\n'
name|'icli_log_level'
op|'='
name|'CONF'
op|'.'
name|'ironic'
op|'.'
name|'client_log_level'
newline|'\n'
name|'if'
name|'icli_log_level'
op|':'
newline|'\n'
indent|'            '
name|'level'
op|'='
name|'py_logging'
op|'.'
name|'getLevelName'
op|'('
name|'icli_log_level'
op|')'
newline|'\n'
name|'logger'
op|'='
name|'py_logging'
op|'.'
name|'getLogger'
op|'('
string|"'ironicclient'"
op|')'
newline|'\n'
name|'logger'
op|'.'
name|'setLevel'
op|'('
name|'level'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_node_resources_unavailable
dedent|''
dedent|''
name|'def'
name|'_node_resources_unavailable'
op|'('
name|'self'
op|','
name|'node_obj'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Determine whether the node\'s resources are in an acceptable state.\n\n        Determines whether the node\'s resources should be presented\n        to Nova for use based on the current power and maintenance state.\n        Returns True if unacceptable.\n        """'
newline|'\n'
name|'bad_states'
op|'='
op|'['
name|'ironic_states'
op|'.'
name|'ERROR'
op|','
name|'ironic_states'
op|'.'
name|'NOSTATE'
op|']'
newline|'\n'
name|'return'
op|'('
name|'node_obj'
op|'.'
name|'maintenance'
name|'or'
nl|'\n'
name|'node_obj'
op|'.'
name|'power_state'
name|'in'
name|'bad_states'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_node_resource
dedent|''
name|'def'
name|'_node_resource'
op|'('
name|'self'
op|','
name|'node'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Helper method to create resource dict from node stats."""'
newline|'\n'
name|'vcpus'
op|'='
name|'int'
op|'('
name|'node'
op|'.'
name|'properties'
op|'.'
name|'get'
op|'('
string|"'cpus'"
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'memory_mb'
op|'='
name|'int'
op|'('
name|'node'
op|'.'
name|'properties'
op|'.'
name|'get'
op|'('
string|"'memory_mb'"
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'local_gb'
op|'='
name|'int'
op|'('
name|'node'
op|'.'
name|'properties'
op|'.'
name|'get'
op|'('
string|"'local_gb'"
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'cpu_arch'
op|'='
name|'arch'
op|'.'
name|'canonicalize'
op|'('
name|'node'
op|'.'
name|'properties'
op|'.'
name|'get'
op|'('
string|"'cpu_arch'"
op|','
name|'None'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InvalidArchitectureName'
op|':'
newline|'\n'
indent|'            '
name|'cpu_arch'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'cpu_arch'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"cpu_arch not defined for node \'%s\'"'
op|')'
op|','
name|'node'
op|'.'
name|'uuid'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'nodes_extra_specs'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
comment|'# NOTE(deva): In Havana and Icehouse, the flavor was required to link'
nl|'\n'
comment|'# to an arch-specific deploy kernel and ramdisk pair, and so the flavor'
nl|'\n'
comment|"# also had to have extra_specs['cpu_arch'], which was matched against"
nl|'\n'
comment|"# the ironic node.properties['cpu_arch']."
nl|'\n'
comment|'# With Juno, the deploy image(s) may be referenced directly by the'
nl|'\n'
comment|'# node.driver_info, and a flavor no longer needs to contain any of'
nl|'\n'
comment|'# these three extra specs, though the cpu_arch may still be used'
nl|'\n'
comment|'# in a heterogeneous environment, if so desired.'
nl|'\n'
name|'nodes_extra_specs'
op|'['
string|"'cpu_arch'"
op|']'
op|'='
name|'cpu_arch'
newline|'\n'
nl|'\n'
comment|'# NOTE(gilliard): To assist with more precise scheduling, if the'
nl|'\n'
comment|"# node.properties contains a key 'capabilities', we expect the value"
nl|'\n'
comment|'# to be of the form "k1:v1,k2:v2,etc.." which we add directly as'
nl|'\n'
comment|'# key/value pairs into the node_extra_specs to be used by the'
nl|'\n'
comment|'# ComputeCapabilitiesFilter'
nl|'\n'
name|'capabilities'
op|'='
name|'node'
op|'.'
name|'properties'
op|'.'
name|'get'
op|'('
string|"'capabilities'"
op|')'
newline|'\n'
name|'if'
name|'capabilities'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'capability'
name|'in'
name|'str'
op|'('
name|'capabilities'
op|')'
op|'.'
name|'split'
op|'('
string|"','"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'parts'
op|'='
name|'capability'
op|'.'
name|'split'
op|'('
string|"':'"
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'parts'
op|')'
op|'=='
number|'2'
name|'and'
name|'parts'
op|'['
number|'0'
op|']'
name|'and'
name|'parts'
op|'['
number|'1'
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'nodes_extra_specs'
op|'['
name|'parts'
op|'['
number|'0'
op|']'
op|']'
op|'='
name|'parts'
op|'['
number|'1'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Ignoring malformed capability \'%s\'. "'
nl|'\n'
string|'"Format should be \'key:val\'."'
op|')'
op|','
name|'capability'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'vcpus_used'
op|'='
number|'0'
newline|'\n'
name|'memory_mb_used'
op|'='
number|'0'
newline|'\n'
name|'local_gb_used'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'if'
name|'node'
op|'.'
name|'instance_uuid'
op|':'
newline|'\n'
comment|'# Node has an instance, report all resource as unavailable'
nl|'\n'
indent|'            '
name|'vcpus_used'
op|'='
name|'vcpus'
newline|'\n'
name|'memory_mb_used'
op|'='
name|'memory_mb'
newline|'\n'
name|'local_gb_used'
op|'='
name|'local_gb'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_node_resources_unavailable'
op|'('
name|'node'
op|')'
op|':'
newline|'\n'
comment|"# The node's current state is such that it should not present any"
nl|'\n'
comment|'# of its resources to Nova'
nl|'\n'
indent|'            '
name|'vcpus'
op|'='
number|'0'
newline|'\n'
name|'memory_mb'
op|'='
number|'0'
newline|'\n'
name|'local_gb'
op|'='
number|'0'
newline|'\n'
nl|'\n'
dedent|''
name|'dic'
op|'='
op|'{'
nl|'\n'
string|"'node'"
op|':'
name|'str'
op|'('
name|'node'
op|'.'
name|'uuid'
op|')'
op|','
nl|'\n'
string|"'hypervisor_hostname'"
op|':'
name|'str'
op|'('
name|'node'
op|'.'
name|'uuid'
op|')'
op|','
nl|'\n'
string|"'hypervisor_type'"
op|':'
name|'self'
op|'.'
name|'_get_hypervisor_type'
op|'('
op|')'
op|','
nl|'\n'
string|"'hypervisor_version'"
op|':'
name|'self'
op|'.'
name|'_get_hypervisor_version'
op|'('
op|')'
op|','
nl|'\n'
string|"'cpu_info'"
op|':'
string|"'baremetal cpu'"
op|','
nl|'\n'
string|"'vcpus'"
op|':'
name|'vcpus'
op|','
nl|'\n'
string|"'vcpus_used'"
op|':'
name|'vcpus_used'
op|','
nl|'\n'
string|"'local_gb'"
op|':'
name|'local_gb'
op|','
nl|'\n'
string|"'local_gb_used'"
op|':'
name|'local_gb_used'
op|','
nl|'\n'
string|"'disk_total'"
op|':'
name|'local_gb'
op|','
nl|'\n'
string|"'disk_used'"
op|':'
name|'local_gb_used'
op|','
nl|'\n'
string|"'disk_available'"
op|':'
name|'local_gb'
op|'-'
name|'local_gb_used'
op|','
nl|'\n'
string|"'memory_mb'"
op|':'
name|'memory_mb'
op|','
nl|'\n'
string|"'memory_mb_used'"
op|':'
name|'memory_mb_used'
op|','
nl|'\n'
string|"'host_memory_total'"
op|':'
name|'memory_mb'
op|','
nl|'\n'
string|"'host_memory_free'"
op|':'
name|'memory_mb'
op|'-'
name|'memory_mb_used'
op|','
nl|'\n'
string|"'supported_instances'"
op|':'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
nl|'\n'
name|'_get_nodes_supported_instances'
op|'('
name|'cpu_arch'
op|')'
op|')'
op|','
nl|'\n'
string|"'stats'"
op|':'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
name|'nodes_extra_specs'
op|')'
op|','
nl|'\n'
string|"'host'"
op|':'
name|'CONF'
op|'.'
name|'host'
op|','
nl|'\n'
op|'}'
newline|'\n'
name|'dic'
op|'.'
name|'update'
op|'('
name|'nodes_extra_specs'
op|')'
newline|'\n'
name|'return'
name|'dic'
newline|'\n'
nl|'\n'
DECL|member|init_host
dedent|''
name|'def'
name|'init_host'
op|'('
name|'self'
op|','
name|'host'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Initialize anything that is necessary for the driver to function.\n\n        :param host: the hostname of the compute host.\n\n        """'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
DECL|member|_get_hypervisor_type
dedent|''
name|'def'
name|'_get_hypervisor_type'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get hypervisor type."""'
newline|'\n'
name|'return'
string|"'ironic'"
newline|'\n'
nl|'\n'
DECL|member|_get_hypervisor_version
dedent|''
name|'def'
name|'_get_hypervisor_version'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns the version of the Ironic API service endpoint."""'
newline|'\n'
name|'return'
name|'CONF'
op|'.'
name|'ironic'
op|'.'
name|'api_version'
newline|'\n'
nl|'\n'
DECL|member|instance_exists
dedent|''
name|'def'
name|'instance_exists'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Checks the existence of an instance.\n\n        Checks the existence of an instance. This is an override of the\n        base method for efficiency.\n\n        :param instance: The instance object.\n        :returns: True if the instance exists. False if not.\n\n        """'
newline|'\n'
name|'icli'
op|'='
name|'client_wrapper'
op|'.'
name|'IronicClientWrapper'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'_validate_instance_and_node'
op|'('
name|'icli'
op|','
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|list_instances
dedent|''
dedent|''
name|'def'
name|'list_instances'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the names of all the instances provisioned.\n\n        :returns: a list of instance names.\n\n        """'
newline|'\n'
name|'icli'
op|'='
name|'client_wrapper'
op|'.'
name|'IronicClientWrapper'
op|'('
op|')'
newline|'\n'
name|'node_list'
op|'='
name|'icli'
op|'.'
name|'call'
op|'('
string|'"node.list"'
op|','
name|'associated'
op|'='
name|'True'
op|')'
newline|'\n'
name|'context'
op|'='
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
newline|'\n'
name|'return'
op|'['
name|'instance_obj'
op|'.'
name|'Instance'
op|'.'
name|'get_by_uuid'
op|'('
name|'context'
op|','
nl|'\n'
name|'i'
op|'.'
name|'instance_uuid'
op|')'
op|'.'
name|'name'
nl|'\n'
name|'for'
name|'i'
name|'in'
name|'node_list'
op|']'
newline|'\n'
nl|'\n'
DECL|member|list_instance_uuids
dedent|''
name|'def'
name|'list_instance_uuids'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the UUIDs of all the instances provisioned.\n\n        :returns: a list of instance UUIDs.\n\n        """'
newline|'\n'
name|'icli'
op|'='
name|'client_wrapper'
op|'.'
name|'IronicClientWrapper'
op|'('
op|')'
newline|'\n'
name|'node_list'
op|'='
name|'icli'
op|'.'
name|'call'
op|'('
string|'"node.list"'
op|','
name|'associated'
op|'='
name|'True'
op|')'
newline|'\n'
name|'return'
name|'list'
op|'('
name|'n'
op|'.'
name|'instance_uuid'
name|'for'
name|'n'
name|'in'
name|'node_list'
op|')'
newline|'\n'
nl|'\n'
DECL|member|node_is_available
dedent|''
name|'def'
name|'node_is_available'
op|'('
name|'self'
op|','
name|'nodename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Confirms a Nova hypervisor node exists in the Ironic inventory.\n\n        :param nodename: The UUID of the node.\n        :returns: True if the node exists, False if not.\n\n        """'
newline|'\n'
name|'icli'
op|'='
name|'client_wrapper'
op|'.'
name|'IronicClientWrapper'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'icli'
op|'.'
name|'call'
op|'('
string|'"node.get"'
op|','
name|'nodename'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'except'
name|'ironic_exception'
op|'.'
name|'NotFound'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|get_available_nodes
dedent|''
dedent|''
name|'def'
name|'get_available_nodes'
op|'('
name|'self'
op|','
name|'refresh'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns the UUIDs of all nodes in the Ironic inventory.\n\n        :param refresh: Boolean value; If True run update first. Ignored by\n            this driver.\n        :returns: a list of UUIDs\n\n        """'
newline|'\n'
name|'icli'
op|'='
name|'client_wrapper'
op|'.'
name|'IronicClientWrapper'
op|'('
op|')'
newline|'\n'
name|'node_list'
op|'='
name|'icli'
op|'.'
name|'call'
op|'('
string|'"node.list"'
op|')'
newline|'\n'
name|'nodes'
op|'='
op|'['
name|'n'
op|'.'
name|'uuid'
name|'for'
name|'n'
name|'in'
name|'node_list'
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Returning %(num_nodes)s available node(s): %(nodes)s"'
op|','
nl|'\n'
name|'dict'
op|'('
name|'num_nodes'
op|'='
name|'len'
op|'('
name|'nodes'
op|')'
op|','
name|'nodes'
op|'='
name|'nodes'
op|')'
op|')'
newline|'\n'
name|'return'
name|'nodes'
newline|'\n'
nl|'\n'
DECL|member|get_available_resource
dedent|''
name|'def'
name|'get_available_resource'
op|'('
name|'self'
op|','
name|'nodename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve resource information.\n\n        This method is called when nova-compute launches, and\n        as part of a periodic task that records the results in the DB.\n\n        :param nodename: the UUID of the node.\n        :returns: a dictionary describing resources.\n\n        """'
newline|'\n'
name|'icli'
op|'='
name|'client_wrapper'
op|'.'
name|'IronicClientWrapper'
op|'('
op|')'
newline|'\n'
name|'node'
op|'='
name|'icli'
op|'.'
name|'call'
op|'('
string|'"node.get"'
op|','
name|'nodename'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_node_resource'
op|'('
name|'node'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_info
dedent|''
name|'def'
name|'get_info'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the current state and resource usage for this instance.\n\n        If the instance is not found this method returns (a dictionary\n        with) NOSTATE and all resources == 0.\n\n        :param instance: the instance object.\n        :returns: a dictionary containing:\n\n            :state: the running state. One of :mod:`nova.compute.power_state`.\n            :max_mem:  (int) the maximum memory in KBytes allowed.\n            :mem:      (int) the memory in KBytes used by the domain.\n            :num_cpu:  (int) the number of CPUs.\n            :cpu_time: (int) the CPU time used in nanoseconds. Always 0 for\n                             this driver.\n\n        """'
newline|'\n'
name|'icli'
op|'='
name|'client_wrapper'
op|'.'
name|'IronicClientWrapper'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'node'
op|'='
name|'_validate_instance_and_node'
op|'('
name|'icli'
op|','
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'{'
string|"'state'"
op|':'
name|'map_power_state'
op|'('
name|'ironic_states'
op|'.'
name|'NOSTATE'
op|')'
op|','
nl|'\n'
string|"'max_mem'"
op|':'
number|'0'
op|','
nl|'\n'
string|"'mem'"
op|':'
number|'0'
op|','
nl|'\n'
string|"'num_cpu'"
op|':'
number|'0'
op|','
nl|'\n'
string|"'cpu_time'"
op|':'
number|'0'
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
dedent|''
name|'memory_kib'
op|'='
name|'int'
op|'('
name|'node'
op|'.'
name|'properties'
op|'.'
name|'get'
op|'('
string|"'memory_mb'"
op|','
number|'0'
op|')'
op|')'
op|'*'
number|'1024'
newline|'\n'
name|'if'
name|'memory_kib'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Warning, memory usage is 0 for "'
nl|'\n'
string|'"%(instance)s on baremetal node %(node)s."'
op|')'
op|','
nl|'\n'
op|'{'
string|"'instance'"
op|':'
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
string|"'node'"
op|':'
name|'instance'
op|'['
string|"'node'"
op|']'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'num_cpu'
op|'='
name|'node'
op|'.'
name|'properties'
op|'.'
name|'get'
op|'('
string|"'cpus'"
op|','
number|'0'
op|')'
newline|'\n'
name|'if'
name|'num_cpu'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Warning, number of cpus is 0 for "'
nl|'\n'
string|'"%(instance)s on baremetal node %(node)s."'
op|')'
op|','
nl|'\n'
op|'{'
string|"'instance'"
op|':'
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
string|"'node'"
op|':'
name|'instance'
op|'['
string|"'node'"
op|']'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
op|'{'
string|"'state'"
op|':'
name|'map_power_state'
op|'('
name|'node'
op|'.'
name|'power_state'
op|')'
op|','
nl|'\n'
string|"'max_mem'"
op|':'
name|'memory_kib'
op|','
nl|'\n'
string|"'mem'"
op|':'
name|'memory_kib'
op|','
nl|'\n'
string|"'num_cpu'"
op|':'
name|'num_cpu'
op|','
nl|'\n'
string|"'cpu_time'"
op|':'
number|'0'
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|reboot
dedent|''
name|'def'
name|'reboot'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'reboot_type'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'bad_volumes_callback'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Reboot the specified instance.\n\n        :param context: The security context.\n        :param instance: The instance object.\n        :param network_info: Instance network information. Ignored by\n            this driver.\n        :param reboot_type: Either a HARD or SOFT reboot. Ignored by\n            this driver.\n        :param block_device_info: Info pertaining to attached volumes.\n            Ignored by this driver.\n        :param bad_volumes_callback: Function to handle any bad volumes\n            encountered. Ignored by this driver.\n\n        """'
newline|'\n'
name|'icli'
op|'='
name|'client_wrapper'
op|'.'
name|'IronicClientWrapper'
op|'('
op|')'
newline|'\n'
name|'node'
op|'='
name|'_validate_instance_and_node'
op|'('
name|'icli'
op|','
name|'instance'
op|')'
newline|'\n'
name|'icli'
op|'.'
name|'call'
op|'('
string|'"node.set_power_state"'
op|','
name|'node'
op|'.'
name|'uuid'
op|','
string|"'reboot'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|power_off
dedent|''
name|'def'
name|'power_off'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'timeout'
op|'='
number|'0'
op|','
name|'retry_interval'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Power off the specified instance.\n\n        :param instance: The instance object.\n        :param timeout: time to wait for node to shutdown. Ignored by\n            this driver.\n        :param retry_interval: How often to signal node while waiting\n            for it to shutdown. Ignored by this driver.\n        """'
newline|'\n'
name|'icli'
op|'='
name|'client_wrapper'
op|'.'
name|'IronicClientWrapper'
op|'('
op|')'
newline|'\n'
name|'node'
op|'='
name|'_validate_instance_and_node'
op|'('
name|'icli'
op|','
name|'instance'
op|')'
newline|'\n'
name|'icli'
op|'.'
name|'call'
op|'('
string|'"node.set_power_state"'
op|','
name|'node'
op|'.'
name|'uuid'
op|','
string|"'off'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|power_on
dedent|''
name|'def'
name|'power_on'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Power on the specified instance.\n\n        :param context: The security context.\n        :param instance: The instance object.\n        :param network_info: Instance network information. Ignored by\n            this driver.\n        :param block_device_info: Instance block device\n            information. Ignored by this driver.\n\n        """'
newline|'\n'
name|'icli'
op|'='
name|'client_wrapper'
op|'.'
name|'IronicClientWrapper'
op|'('
op|')'
newline|'\n'
name|'node'
op|'='
name|'_validate_instance_and_node'
op|'('
name|'icli'
op|','
name|'instance'
op|')'
newline|'\n'
name|'icli'
op|'.'
name|'call'
op|'('
string|'"node.set_power_state"'
op|','
name|'node'
op|'.'
name|'uuid'
op|','
string|"'on'"
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
