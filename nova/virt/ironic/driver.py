begin_unit
comment|'# coding=utf-8'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Copyright 2014 Red Hat, Inc.'
nl|'\n'
comment|'# Copyright 2013 Hewlett-Packard Development Company, L.P.'
nl|'\n'
comment|'# All Rights Reserved.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
nl|'\n'
string|'"""\nA driver wrapping the Ironic API, such that Nova may provision\nbare metal resources.\n"""'
newline|'\n'
name|'import'
name|'base64'
newline|'\n'
name|'import'
name|'gzip'
newline|'\n'
name|'import'
name|'logging'
name|'as'
name|'py_logging'
newline|'\n'
name|'import'
name|'shutil'
newline|'\n'
name|'import'
name|'tempfile'
newline|'\n'
name|'import'
name|'time'
newline|'\n'
nl|'\n'
name|'from'
name|'oslo_config'
name|'import'
name|'cfg'
newline|'\n'
name|'from'
name|'oslo_log'
name|'import'
name|'log'
name|'as'
name|'logging'
newline|'\n'
name|'from'
name|'oslo_serialization'
name|'import'
name|'jsonutils'
newline|'\n'
name|'from'
name|'oslo_utils'
name|'import'
name|'excutils'
newline|'\n'
name|'from'
name|'oslo_utils'
name|'import'
name|'importutils'
newline|'\n'
name|'import'
name|'six'
newline|'\n'
nl|'\n'
name|'from'
name|'nova'
op|'.'
name|'api'
op|'.'
name|'metadata'
name|'import'
name|'base'
name|'as'
name|'instance_metadata'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'arch'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'hv_type'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'power_state'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'task_states'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'vm_mode'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'context'
name|'as'
name|'nova_context'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'exception'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_LE'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_LI'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_LW'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'objects'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'loopingcall'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'configdrive'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'driver'
name|'as'
name|'virt_driver'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'firewall'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'hardware'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'ironic'
name|'import'
name|'client_wrapper'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'ironic'
name|'import'
name|'ironic_states'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'ironic'
name|'import'
name|'patcher'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|ironic
name|'ironic'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|variable|LOG
name|'LOG'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|opts
name|'opts'
op|'='
op|'['
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'api_version'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'1'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Version of Ironic API service endpoint.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'api_endpoint'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'URL for Ironic API endpoint.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'admin_username'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Ironic keystone admin name'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'admin_password'"
op|','
nl|'\n'
DECL|variable|secret
name|'secret'
op|'='
name|'True'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Ironic keystone admin password.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'admin_auth_token'"
op|','
nl|'\n'
DECL|variable|secret
name|'secret'
op|'='
name|'True'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Ironic keystone auth token.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'admin_url'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Keystone public API endpoint.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'client_log_level'"
op|','
nl|'\n'
DECL|variable|deprecated_for_removal
name|'deprecated_for_removal'
op|'='
name|'True'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Log level override for ironicclient. Set this in '"
nl|'\n'
string|'\'order to override the global "default_log_levels", \''
nl|'\n'
string|'\'"verbose", and "debug" settings. \''
nl|'\n'
string|"'DEPRECATED: use standard logging configuration.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'admin_tenant_name'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Ironic keystone tenant name.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'api_max_retries'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'60'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'How many retries when a request does conflict.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'api_retry_interval'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'2'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'How often to retry in seconds when a request '"
nl|'\n'
string|"'does conflict'"
op|')'
op|','
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
DECL|variable|ironic_group
name|'ironic_group'
op|'='
name|'cfg'
op|'.'
name|'OptGroup'
op|'('
name|'name'
op|'='
string|"'ironic'"
op|','
nl|'\n'
DECL|variable|title
name|'title'
op|'='
string|"'Ironic Options'"
op|')'
newline|'\n'
nl|'\n'
DECL|variable|CONF
name|'CONF'
op|'='
name|'cfg'
op|'.'
name|'CONF'
newline|'\n'
name|'CONF'
op|'.'
name|'register_group'
op|'('
name|'ironic_group'
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'register_opts'
op|'('
name|'opts'
op|','
name|'ironic_group'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|_POWER_STATE_MAP
name|'_POWER_STATE_MAP'
op|'='
op|'{'
nl|'\n'
name|'ironic_states'
op|'.'
name|'POWER_ON'
op|':'
name|'power_state'
op|'.'
name|'RUNNING'
op|','
nl|'\n'
name|'ironic_states'
op|'.'
name|'NOSTATE'
op|':'
name|'power_state'
op|'.'
name|'NOSTATE'
op|','
nl|'\n'
name|'ironic_states'
op|'.'
name|'POWER_OFF'
op|':'
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|map_power_state
name|'def'
name|'map_power_state'
op|'('
name|'state'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'_POWER_STATE_MAP'
op|'['
name|'state'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'KeyError'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"Power state %s not found."'
op|')'
op|','
name|'state'
op|')'
newline|'\n'
name|'return'
name|'power_state'
op|'.'
name|'NOSTATE'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_validate_instance_and_node
dedent|''
dedent|''
name|'def'
name|'_validate_instance_and_node'
op|'('
name|'ironicclient'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Get the node associated with the instance.\n\n    Check with the Ironic service that this instance is associated with a\n    node, and return the node.\n    """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"node.get_by_instance_uuid"'
op|','
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ironic'
op|'.'
name|'exc'
op|'.'
name|'NotFound'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|'('
name|'instance_id'
op|'='
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_get_nodes_supported_instances
dedent|''
dedent|''
name|'def'
name|'_get_nodes_supported_instances'
op|'('
name|'cpu_arch'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return supported instances for a node."""'
newline|'\n'
name|'if'
name|'not'
name|'cpu_arch'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'['
op|']'
newline|'\n'
dedent|''
name|'return'
op|'['
op|'('
name|'cpu_arch'
op|','
nl|'\n'
name|'hv_type'
op|'.'
name|'BAREMETAL'
op|','
nl|'\n'
name|'vm_mode'
op|'.'
name|'HVM'
op|')'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|_log_ironic_polling
dedent|''
name|'def'
name|'_log_ironic_polling'
op|'('
name|'what'
op|','
name|'node'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'power_state'
op|'='
op|'('
name|'None'
name|'if'
name|'node'
op|'.'
name|'power_state'
name|'is'
name|'None'
name|'else'
nl|'\n'
string|'\'"%s"\''
op|'%'
name|'node'
op|'.'
name|'power_state'
op|')'
newline|'\n'
name|'tgt_power_state'
op|'='
op|'('
name|'None'
name|'if'
name|'node'
op|'.'
name|'target_power_state'
name|'is'
name|'None'
name|'else'
nl|'\n'
string|'\'"%s"\''
op|'%'
name|'node'
op|'.'
name|'target_power_state'
op|')'
newline|'\n'
name|'prov_state'
op|'='
op|'('
name|'None'
name|'if'
name|'node'
op|'.'
name|'provision_state'
name|'is'
name|'None'
name|'else'
nl|'\n'
string|'\'"%s"\''
op|'%'
name|'node'
op|'.'
name|'provision_state'
op|')'
newline|'\n'
name|'tgt_prov_state'
op|'='
op|'('
name|'None'
name|'if'
name|'node'
op|'.'
name|'target_provision_state'
name|'is'
name|'None'
name|'else'
nl|'\n'
string|'\'"%s"\''
op|'%'
name|'node'
op|'.'
name|'target_provision_state'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Still waiting for ironic node %(node)s to %(what)s: '"
nl|'\n'
string|"'power_state=%(power_state)s, '"
nl|'\n'
string|"'target_power_state=%(tgt_power_state)s, '"
nl|'\n'
string|"'provision_state=%(prov_state)s, '"
nl|'\n'
string|"'target_provision_state=%(tgt_prov_state)s'"
op|','
nl|'\n'
name|'dict'
op|'('
name|'what'
op|'='
name|'what'
op|','
nl|'\n'
name|'node'
op|'='
name|'node'
op|'.'
name|'uuid'
op|','
nl|'\n'
name|'power_state'
op|'='
name|'power_state'
op|','
nl|'\n'
name|'tgt_power_state'
op|'='
name|'tgt_power_state'
op|','
nl|'\n'
name|'prov_state'
op|'='
name|'prov_state'
op|','
nl|'\n'
name|'tgt_prov_state'
op|'='
name|'tgt_prov_state'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|IronicDriver
dedent|''
name|'class'
name|'IronicDriver'
op|'('
name|'virt_driver'
op|'.'
name|'ComputeDriver'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Hypervisor driver for Ironic - bare metal provisioning."""'
newline|'\n'
nl|'\n'
DECL|variable|capabilities
name|'capabilities'
op|'='
op|'{'
string|'"has_imagecache"'
op|':'
name|'False'
op|','
nl|'\n'
string|'"supports_recreate"'
op|':'
name|'False'
op|','
nl|'\n'
string|'"supports_migrate_to_same_host"'
op|':'
name|'False'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'virtapi'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'super'
op|'('
name|'IronicDriver'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'virtapi'
op|')'
newline|'\n'
name|'global'
name|'ironic'
newline|'\n'
name|'if'
name|'ironic'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'ironic'
op|'='
name|'importutils'
op|'.'
name|'import_module'
op|'('
string|"'ironicclient'"
op|')'
newline|'\n'
comment|'# NOTE(deva): work around a lack of symbols in the current version.'
nl|'\n'
name|'if'
name|'not'
name|'hasattr'
op|'('
name|'ironic'
op|','
string|"'exc'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'ironic'
op|'.'
name|'exc'
op|'='
name|'importutils'
op|'.'
name|'import_module'
op|'('
string|"'ironicclient.exc'"
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'hasattr'
op|'('
name|'ironic'
op|','
string|"'client'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'ironic'
op|'.'
name|'client'
op|'='
name|'importutils'
op|'.'
name|'import_module'
op|'('
nl|'\n'
string|"'ironicclient.client'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'firewall_driver'
op|'='
name|'firewall'
op|'.'
name|'load_driver'
op|'('
nl|'\n'
name|'default'
op|'='
string|"'nova.virt.firewall.NoopFirewallDriver'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'node_cache'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'node_cache_time'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'ironicclient_log_level'
op|'='
name|'CONF'
op|'.'
name|'ironic'
op|'.'
name|'client_log_level'
newline|'\n'
name|'if'
name|'ironicclient_log_level'
op|':'
newline|'\n'
indent|'            '
name|'level'
op|'='
name|'py_logging'
op|'.'
name|'getLevelName'
op|'('
name|'ironicclient_log_level'
op|')'
newline|'\n'
name|'logger'
op|'='
name|'py_logging'
op|'.'
name|'getLogger'
op|'('
string|"'ironicclient'"
op|')'
newline|'\n'
name|'logger'
op|'.'
name|'setLevel'
op|'('
name|'level'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'ironicclient'
op|'='
name|'client_wrapper'
op|'.'
name|'IronicClientWrapper'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_node_resources_unavailable
dedent|''
name|'def'
name|'_node_resources_unavailable'
op|'('
name|'self'
op|','
name|'node_obj'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Determine whether the node\'s resources are in an acceptable state.\n\n        Determines whether the node\'s resources should be presented\n        to Nova for use based on the current power, provision and maintenance\n        state. This is called after _node_resources_used, so any node that\n        is not used and not in AVAILABLE should be considered in a \'bad\' state,\n        and unavailable for scheduling. Returns True if unacceptable.\n        """'
newline|'\n'
name|'bad_power_states'
op|'='
op|'['
nl|'\n'
name|'ironic_states'
op|'.'
name|'ERROR'
op|','
name|'ironic_states'
op|'.'
name|'NOSTATE'
op|']'
newline|'\n'
comment|'# keep NOSTATE around for compatibility'
nl|'\n'
name|'good_provision_states'
op|'='
op|'['
nl|'\n'
name|'ironic_states'
op|'.'
name|'AVAILABLE'
op|','
name|'ironic_states'
op|'.'
name|'NOSTATE'
op|']'
newline|'\n'
name|'return'
op|'('
name|'node_obj'
op|'.'
name|'maintenance'
name|'or'
nl|'\n'
name|'node_obj'
op|'.'
name|'power_state'
name|'in'
name|'bad_power_states'
name|'or'
nl|'\n'
name|'node_obj'
op|'.'
name|'provision_state'
name|'not'
name|'in'
name|'good_provision_states'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_node_resources_used
dedent|''
name|'def'
name|'_node_resources_used'
op|'('
name|'self'
op|','
name|'node_obj'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Determine whether the node\'s resources are currently used.\n\n        Determines whether the node\'s resources should be considered used\n        or not. A node is used when it is either in the process of putting\n        a new instance on the node, has an instance on the node, or is in\n        the process of cleaning up from a deleted instance. Returns True if\n        used.\n        """'
newline|'\n'
name|'used_provision_states'
op|'='
op|'['
nl|'\n'
name|'ironic_states'
op|'.'
name|'CLEANING'
op|','
name|'ironic_states'
op|'.'
name|'DEPLOYING'
op|','
nl|'\n'
name|'ironic_states'
op|'.'
name|'DEPLOYWAIT'
op|','
name|'ironic_states'
op|'.'
name|'DEPLOYDONE'
op|','
nl|'\n'
name|'ironic_states'
op|'.'
name|'ACTIVE'
op|','
name|'ironic_states'
op|'.'
name|'DELETING'
op|','
nl|'\n'
name|'ironic_states'
op|'.'
name|'DELETED'
op|']'
newline|'\n'
name|'return'
op|'('
name|'node_obj'
op|'.'
name|'instance_uuid'
name|'is'
name|'not'
name|'None'
name|'or'
nl|'\n'
name|'node_obj'
op|'.'
name|'provision_state'
name|'in'
name|'used_provision_states'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_node_resource
dedent|''
name|'def'
name|'_node_resource'
op|'('
name|'self'
op|','
name|'node'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Helper method to create resource dict from node stats."""'
newline|'\n'
name|'vcpus'
op|'='
name|'int'
op|'('
name|'node'
op|'.'
name|'properties'
op|'.'
name|'get'
op|'('
string|"'cpus'"
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'memory_mb'
op|'='
name|'int'
op|'('
name|'node'
op|'.'
name|'properties'
op|'.'
name|'get'
op|'('
string|"'memory_mb'"
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'local_gb'
op|'='
name|'int'
op|'('
name|'node'
op|'.'
name|'properties'
op|'.'
name|'get'
op|'('
string|"'local_gb'"
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'raw_cpu_arch'
op|'='
name|'node'
op|'.'
name|'properties'
op|'.'
name|'get'
op|'('
string|"'cpu_arch'"
op|','
name|'None'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'cpu_arch'
op|'='
name|'arch'
op|'.'
name|'canonicalize'
op|'('
name|'raw_cpu_arch'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InvalidArchitectureName'
op|':'
newline|'\n'
indent|'            '
name|'cpu_arch'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'cpu_arch'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"cpu_arch not defined for node \'%s\'"'
op|')'
op|','
name|'node'
op|'.'
name|'uuid'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'nodes_extra_specs'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
comment|'# NOTE(deva): In Havana and Icehouse, the flavor was required to link'
nl|'\n'
comment|'# to an arch-specific deploy kernel and ramdisk pair, and so the flavor'
nl|'\n'
comment|"# also had to have extra_specs['cpu_arch'], which was matched against"
nl|'\n'
comment|"# the ironic node.properties['cpu_arch']."
nl|'\n'
comment|'# With Juno, the deploy image(s) may be referenced directly by the'
nl|'\n'
comment|'# node.driver_info, and a flavor no longer needs to contain any of'
nl|'\n'
comment|'# these three extra specs, though the cpu_arch may still be used'
nl|'\n'
comment|'# in a heterogeneous environment, if so desired.'
nl|'\n'
comment|'# NOTE(dprince): we use the raw cpu_arch here because extra_specs'
nl|'\n'
comment|"# filters aren't canonicalized"
nl|'\n'
name|'nodes_extra_specs'
op|'['
string|"'cpu_arch'"
op|']'
op|'='
name|'raw_cpu_arch'
newline|'\n'
nl|'\n'
comment|'# NOTE(gilliard): To assist with more precise scheduling, if the'
nl|'\n'
comment|"# node.properties contains a key 'capabilities', we expect the value"
nl|'\n'
comment|'# to be of the form "k1:v1,k2:v2,etc.." which we add directly as'
nl|'\n'
comment|'# key/value pairs into the node_extra_specs to be used by the'
nl|'\n'
comment|'# ComputeCapabilitiesFilter'
nl|'\n'
name|'capabilities'
op|'='
name|'node'
op|'.'
name|'properties'
op|'.'
name|'get'
op|'('
string|"'capabilities'"
op|')'
newline|'\n'
name|'if'
name|'capabilities'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'capability'
name|'in'
name|'str'
op|'('
name|'capabilities'
op|')'
op|'.'
name|'split'
op|'('
string|"','"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'parts'
op|'='
name|'capability'
op|'.'
name|'split'
op|'('
string|"':'"
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'parts'
op|')'
op|'=='
number|'2'
name|'and'
name|'parts'
op|'['
number|'0'
op|']'
name|'and'
name|'parts'
op|'['
number|'1'
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'nodes_extra_specs'
op|'['
name|'parts'
op|'['
number|'0'
op|']'
op|']'
op|'='
name|'parts'
op|'['
number|'1'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"Ignoring malformed capability \'%s\'. "'
nl|'\n'
string|'"Format should be \'key:val\'."'
op|')'
op|','
name|'capability'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'vcpus_used'
op|'='
number|'0'
newline|'\n'
name|'memory_mb_used'
op|'='
number|'0'
newline|'\n'
name|'local_gb_used'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_node_resources_used'
op|'('
name|'node'
op|')'
op|':'
newline|'\n'
comment|'# Node is in the process of deploying, is deployed, or is in'
nl|'\n'
comment|'# the process of cleaning up from a deploy. Report all of its'
nl|'\n'
comment|'# resources as in use.'
nl|'\n'
indent|'            '
name|'vcpus_used'
op|'='
name|'vcpus'
newline|'\n'
name|'memory_mb_used'
op|'='
name|'memory_mb'
newline|'\n'
name|'local_gb_used'
op|'='
name|'local_gb'
newline|'\n'
dedent|''
name|'elif'
name|'self'
op|'.'
name|'_node_resources_unavailable'
op|'('
name|'node'
op|')'
op|':'
newline|'\n'
comment|"# The node's current state is such that it should not present any"
nl|'\n'
comment|'# of its resources to Nova'
nl|'\n'
indent|'            '
name|'vcpus'
op|'='
number|'0'
newline|'\n'
name|'memory_mb'
op|'='
number|'0'
newline|'\n'
name|'local_gb'
op|'='
number|'0'
newline|'\n'
nl|'\n'
dedent|''
name|'dic'
op|'='
op|'{'
nl|'\n'
string|"'hypervisor_hostname'"
op|':'
name|'str'
op|'('
name|'node'
op|'.'
name|'uuid'
op|')'
op|','
nl|'\n'
string|"'hypervisor_type'"
op|':'
name|'self'
op|'.'
name|'_get_hypervisor_type'
op|'('
op|')'
op|','
nl|'\n'
string|"'hypervisor_version'"
op|':'
name|'self'
op|'.'
name|'_get_hypervisor_version'
op|'('
op|')'
op|','
nl|'\n'
comment|'# The Ironic driver manages multiple hosts, so there are'
nl|'\n'
comment|'# likely many different CPU models in use. As such it is'
nl|'\n'
comment|'# impossible to provide any meaningful info on the CPU'
nl|'\n'
comment|'# model of the "host"'
nl|'\n'
string|"'cpu_info'"
op|':'
name|'None'
op|','
nl|'\n'
string|"'vcpus'"
op|':'
name|'vcpus'
op|','
nl|'\n'
string|"'vcpus_used'"
op|':'
name|'vcpus_used'
op|','
nl|'\n'
string|"'local_gb'"
op|':'
name|'local_gb'
op|','
nl|'\n'
string|"'local_gb_used'"
op|':'
name|'local_gb_used'
op|','
nl|'\n'
string|"'disk_available_least'"
op|':'
name|'local_gb'
op|'-'
name|'local_gb_used'
op|','
nl|'\n'
string|"'memory_mb'"
op|':'
name|'memory_mb'
op|','
nl|'\n'
string|"'memory_mb_used'"
op|':'
name|'memory_mb_used'
op|','
nl|'\n'
string|"'supported_instances'"
op|':'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
nl|'\n'
name|'_get_nodes_supported_instances'
op|'('
name|'cpu_arch'
op|')'
op|')'
op|','
nl|'\n'
string|"'stats'"
op|':'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
name|'nodes_extra_specs'
op|')'
op|','
nl|'\n'
op|'}'
newline|'\n'
name|'return'
name|'dic'
newline|'\n'
nl|'\n'
DECL|member|_start_firewall
dedent|''
name|'def'
name|'_start_firewall'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'setup_basic_filtering'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'prepare_instance_filter'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'apply_instance_filter'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_stop_firewall
dedent|''
name|'def'
name|'_stop_firewall'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'unfilter_instance'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_add_driver_fields
dedent|''
name|'def'
name|'_add_driver_fields'
op|'('
name|'self'
op|','
name|'node'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'flavor'
op|','
nl|'\n'
name|'preserve_ephemeral'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'patch'
op|'='
name|'patcher'
op|'.'
name|'create'
op|'('
name|'node'
op|')'
op|'.'
name|'get_deploy_patch'
op|'('
name|'instance'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'flavor'
op|','
nl|'\n'
name|'preserve_ephemeral'
op|')'
newline|'\n'
nl|'\n'
comment|'# Associate the node with an instance'
nl|'\n'
name|'patch'
op|'.'
name|'append'
op|'('
op|'{'
string|"'path'"
op|':'
string|"'/instance_uuid'"
op|','
string|"'op'"
op|':'
string|"'add'"
op|','
nl|'\n'
string|"'value'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|'}'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|"'node.update'"
op|','
name|'node'
op|'.'
name|'uuid'
op|','
name|'patch'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ironic'
op|'.'
name|'exc'
op|'.'
name|'BadRequest'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|'"Failed to add deploy parameters on node %(node)s "'
nl|'\n'
string|'"when provisioning the instance %(instance)s"'
op|')'
nl|'\n'
op|'%'
op|'{'
string|"'node'"
op|':'
name|'node'
op|'.'
name|'uuid'
op|','
string|"'instance'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|'}'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'error'
op|'('
name|'msg'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstanceDeployFailure'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_cleanup_deploy
dedent|''
dedent|''
name|'def'
name|'_cleanup_deploy'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'node'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'flavor'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'flavor'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'flavor'
op|'='
name|'instance'
op|'.'
name|'flavor'
newline|'\n'
dedent|''
name|'patch'
op|'='
name|'patcher'
op|'.'
name|'create'
op|'('
name|'node'
op|')'
op|'.'
name|'get_cleanup_patch'
op|'('
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'flavor'
op|')'
newline|'\n'
nl|'\n'
comment|'# Unassociate the node'
nl|'\n'
name|'patch'
op|'.'
name|'append'
op|'('
op|'{'
string|"'op'"
op|':'
string|"'remove'"
op|','
string|"'path'"
op|':'
string|"'/instance_uuid'"
op|'}'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|"'node.update'"
op|','
name|'node'
op|'.'
name|'uuid'
op|','
name|'patch'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ironic'
op|'.'
name|'exc'
op|'.'
name|'BadRequest'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|'"Failed to clean up the parameters on node %(node)s "'
nl|'\n'
string|'"when unprovisioning the instance %(instance)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'node'"
op|':'
name|'node'
op|'.'
name|'uuid'
op|','
string|"'instance'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|'}'
op|')'
newline|'\n'
name|'reason'
op|'='
op|'('
name|'_'
op|'('
string|'"Fail to clean up node %s parameters"'
op|')'
op|'%'
name|'node'
op|'.'
name|'uuid'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstanceTerminationFailure'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_unplug_vifs'
op|'('
name|'node'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_stop_firewall'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_wait_for_active
dedent|''
name|'def'
name|'_wait_for_active'
op|'('
name|'self'
op|','
name|'ironicclient'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Wait for the node to be marked as ACTIVE in Ironic."""'
newline|'\n'
name|'node'
op|'='
name|'_validate_instance_and_node'
op|'('
name|'ironicclient'
op|','
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'node'
op|'.'
name|'provision_state'
op|'=='
name|'ironic_states'
op|'.'
name|'ACTIVE'
op|':'
newline|'\n'
comment|'# job is done'
nl|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Ironic node %(node)s is now ACTIVE"'
op|','
nl|'\n'
name|'dict'
op|'('
name|'node'
op|'='
name|'node'
op|'.'
name|'uuid'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'node'
op|'.'
name|'target_provision_state'
name|'in'
op|'('
name|'ironic_states'
op|'.'
name|'DELETED'
op|','
nl|'\n'
name|'ironic_states'
op|'.'
name|'AVAILABLE'
op|')'
op|':'
newline|'\n'
comment|'# ironic is trying to delete it now'
nl|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|'('
name|'instance_id'
op|'='
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'node'
op|'.'
name|'provision_state'
name|'in'
op|'('
name|'ironic_states'
op|'.'
name|'NOSTATE'
op|','
nl|'\n'
name|'ironic_states'
op|'.'
name|'AVAILABLE'
op|')'
op|':'
newline|'\n'
comment|'# ironic already deleted it'
nl|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|'('
name|'instance_id'
op|'='
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'node'
op|'.'
name|'provision_state'
op|'=='
name|'ironic_states'
op|'.'
name|'DEPLOYFAIL'
op|':'
newline|'\n'
comment|'# ironic failed to deploy'
nl|'\n'
indent|'            '
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|'"Failed to provision instance %(inst)s: %(reason)s"'
op|')'
nl|'\n'
op|'%'
op|'{'
string|"'inst'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|','
string|"'reason'"
op|':'
name|'node'
op|'.'
name|'last_error'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstanceDeployFailure'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'_log_ironic_polling'
op|'('
string|"'become ACTIVE'"
op|','
name|'node'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_wait_for_power_state
dedent|''
name|'def'
name|'_wait_for_power_state'
op|'('
name|'self'
op|','
name|'ironicclient'
op|','
name|'instance'
op|','
name|'message'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Wait for the node to complete a power state change."""'
newline|'\n'
name|'node'
op|'='
name|'_validate_instance_and_node'
op|'('
name|'ironicclient'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'node'
op|'.'
name|'target_power_state'
op|'=='
name|'ironic_states'
op|'.'
name|'NOSTATE'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'_log_ironic_polling'
op|'('
name|'message'
op|','
name|'node'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|init_host
dedent|''
name|'def'
name|'init_host'
op|'('
name|'self'
op|','
name|'host'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Initialize anything that is necessary for the driver to function.\n\n        :param host: the hostname of the compute host.\n\n        """'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
DECL|member|_get_hypervisor_type
dedent|''
name|'def'
name|'_get_hypervisor_type'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get hypervisor type."""'
newline|'\n'
name|'return'
string|"'ironic'"
newline|'\n'
nl|'\n'
DECL|member|_get_hypervisor_version
dedent|''
name|'def'
name|'_get_hypervisor_version'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns the version of the Ironic API service endpoint."""'
newline|'\n'
name|'return'
name|'CONF'
op|'.'
name|'ironic'
op|'.'
name|'api_version'
newline|'\n'
nl|'\n'
DECL|member|instance_exists
dedent|''
name|'def'
name|'instance_exists'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Checks the existence of an instance.\n\n        Checks the existence of an instance. This is an override of the\n        base method for efficiency.\n\n        :param instance: The instance object.\n        :returns: True if the instance exists. False if not.\n\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'_validate_instance_and_node'
op|'('
name|'self'
op|'.'
name|'ironicclient'
op|','
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|list_instances
dedent|''
dedent|''
name|'def'
name|'list_instances'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the names of all the instances provisioned.\n\n        :returns: a list of instance names.\n\n        """'
newline|'\n'
comment|'# NOTE(lucasagomes): limit == 0 is an indicator to continue'
nl|'\n'
comment|"# pagination until there're no more values to be returned."
nl|'\n'
name|'node_list'
op|'='
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"node.list"'
op|','
name|'associated'
op|'='
name|'True'
op|','
nl|'\n'
name|'limit'
op|'='
number|'0'
op|')'
newline|'\n'
name|'context'
op|'='
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
newline|'\n'
name|'return'
op|'['
name|'objects'
op|'.'
name|'Instance'
op|'.'
name|'get_by_uuid'
op|'('
name|'context'
op|','
nl|'\n'
name|'i'
op|'.'
name|'instance_uuid'
op|')'
op|'.'
name|'name'
nl|'\n'
name|'for'
name|'i'
name|'in'
name|'node_list'
op|']'
newline|'\n'
nl|'\n'
DECL|member|list_instance_uuids
dedent|''
name|'def'
name|'list_instance_uuids'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the UUIDs of all the instances provisioned.\n\n        :returns: a list of instance UUIDs.\n\n        """'
newline|'\n'
comment|'# NOTE(lucasagomes): limit == 0 is an indicator to continue'
nl|'\n'
comment|"# pagination until there're no more values to be returned."
nl|'\n'
name|'node_list'
op|'='
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"node.list"'
op|','
name|'associated'
op|'='
name|'True'
op|','
nl|'\n'
name|'limit'
op|'='
number|'0'
op|')'
newline|'\n'
name|'return'
name|'list'
op|'('
name|'n'
op|'.'
name|'instance_uuid'
name|'for'
name|'n'
name|'in'
name|'node_list'
op|')'
newline|'\n'
nl|'\n'
DECL|member|node_is_available
dedent|''
name|'def'
name|'node_is_available'
op|'('
name|'self'
op|','
name|'nodename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Confirms a Nova hypervisor node exists in the Ironic inventory.\n\n        :param nodename: The UUID of the node.\n        :returns: True if the node exists, False if not.\n\n        """'
newline|'\n'
comment|'# NOTE(comstud): We can cheat and use caching here. This method'
nl|'\n'
comment|"# just needs to return True for nodes that exist. It doesn't"
nl|'\n'
comment|"# matter if the data is stale. Sure, it's possible that removing"
nl|'\n'
comment|'# node from Ironic will cause this method to return True until'
nl|'\n'
comment|"# the next call to 'get_available_nodes', but there shouldn't"
nl|'\n'
comment|"# be much harm. There's already somewhat of a race."
nl|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'node_cache'
op|':'
newline|'\n'
comment|'# Empty cache, try to populate it.'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_refresh_cache'
op|'('
op|')'
newline|'\n'
dedent|''
name|'if'
name|'nodename'
name|'in'
name|'self'
op|'.'
name|'node_cache'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
comment|'# NOTE(comstud): Fallback and check Ironic. This case should be'
nl|'\n'
comment|'# rare.'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"node.get"'
op|','
name|'nodename'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'except'
name|'ironic'
op|'.'
name|'exc'
op|'.'
name|'NotFound'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|_refresh_cache
dedent|''
dedent|''
name|'def'
name|'_refresh_cache'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(lucasagomes): limit == 0 is an indicator to continue'
nl|'\n'
comment|"# pagination until there're no more values to be returned."
nl|'\n'
indent|'        '
name|'node_list'
op|'='
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|"'node.list'"
op|','
name|'detail'
op|'='
name|'True'
op|','
name|'limit'
op|'='
number|'0'
op|')'
newline|'\n'
name|'node_cache'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'node'
name|'in'
name|'node_list'
op|':'
newline|'\n'
indent|'            '
name|'node_cache'
op|'['
name|'node'
op|'.'
name|'uuid'
op|']'
op|'='
name|'node'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'node_cache'
op|'='
name|'node_cache'
newline|'\n'
name|'self'
op|'.'
name|'node_cache_time'
op|'='
name|'time'
op|'.'
name|'time'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_available_nodes
dedent|''
name|'def'
name|'get_available_nodes'
op|'('
name|'self'
op|','
name|'refresh'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns the UUIDs of all nodes in the Ironic inventory.\n\n        :param refresh: Boolean value; If True run update first. Ignored by\n                        this driver.\n        :returns: a list of UUIDs\n\n        """'
newline|'\n'
comment|'# NOTE(jroll) we refresh the cache every time this is called'
nl|'\n'
comment|'#             because it needs to happen in the resource tracker'
nl|'\n'
comment|"#             periodic task. This task doesn't pass refresh=True,"
nl|'\n'
comment|'#             unfortunately.'
nl|'\n'
name|'self'
op|'.'
name|'_refresh_cache'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'node_uuids'
op|'='
name|'list'
op|'('
name|'self'
op|'.'
name|'node_cache'
op|'.'
name|'keys'
op|'('
op|')'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Returning %(num_nodes)s available node(s)"'
op|','
nl|'\n'
name|'dict'
op|'('
name|'num_nodes'
op|'='
name|'len'
op|'('
name|'node_uuids'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'node_uuids'
newline|'\n'
nl|'\n'
DECL|member|get_available_resource
dedent|''
name|'def'
name|'get_available_resource'
op|'('
name|'self'
op|','
name|'nodename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve resource information.\n\n        This method is called when nova-compute launches, and\n        as part of a periodic task that records the results in the DB.\n\n        :param nodename: the UUID of the node.\n        :returns: a dictionary describing resources.\n\n        """'
newline|'\n'
comment|'# NOTE(comstud): We can cheat and use caching here. This method is'
nl|'\n'
comment|'# only called from a periodic task and right after the above'
nl|'\n'
comment|'# get_available_nodes() call is called.'
nl|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'node_cache'
op|':'
newline|'\n'
comment|"# Well, it's also called from init_host(), so if we have empty"
nl|'\n'
comment|"# cache, let's try to populate it."
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_refresh_cache'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'cache_age'
op|'='
name|'time'
op|'.'
name|'time'
op|'('
op|')'
op|'-'
name|'self'
op|'.'
name|'node_cache_time'
newline|'\n'
name|'if'
name|'nodename'
name|'in'
name|'self'
op|'.'
name|'node_cache'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Using cache for node %(node)s, age: %(age)s"'
op|','
nl|'\n'
op|'{'
string|"'node'"
op|':'
name|'nodename'
op|','
string|"'age'"
op|':'
name|'cache_age'
op|'}'
op|')'
newline|'\n'
name|'node'
op|'='
name|'self'
op|'.'
name|'node_cache'
op|'['
name|'nodename'
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Node %(node)s not found in cache, age: %(age)s"'
op|','
nl|'\n'
op|'{'
string|"'node'"
op|':'
name|'nodename'
op|','
string|"'age'"
op|':'
name|'cache_age'
op|'}'
op|')'
newline|'\n'
name|'node'
op|'='
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"node.get"'
op|','
name|'nodename'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_node_resource'
op|'('
name|'node'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_info
dedent|''
name|'def'
name|'get_info'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the current state and resource usage for this instance.\n\n        If the instance is not found this method returns (a dictionary\n        with) NOSTATE and all resources == 0.\n\n        :param instance: the instance object.\n        :returns: a InstanceInfo object\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'node'
op|'='
name|'_validate_instance_and_node'
op|'('
name|'self'
op|'.'
name|'ironicclient'
op|','
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'hardware'
op|'.'
name|'InstanceInfo'
op|'('
nl|'\n'
name|'state'
op|'='
name|'map_power_state'
op|'('
name|'ironic_states'
op|'.'
name|'NOSTATE'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'memory_kib'
op|'='
name|'int'
op|'('
name|'node'
op|'.'
name|'properties'
op|'.'
name|'get'
op|'('
string|"'memory_mb'"
op|','
number|'0'
op|')'
op|')'
op|'*'
number|'1024'
newline|'\n'
name|'if'
name|'memory_kib'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"Warning, memory usage is 0 for "'
nl|'\n'
string|'"%(instance)s on baremetal node %(node)s."'
op|')'
op|','
nl|'\n'
op|'{'
string|"'instance'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|','
nl|'\n'
string|"'node'"
op|':'
name|'instance'
op|'.'
name|'node'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'num_cpu'
op|'='
name|'node'
op|'.'
name|'properties'
op|'.'
name|'get'
op|'('
string|"'cpus'"
op|','
number|'0'
op|')'
newline|'\n'
name|'if'
name|'num_cpu'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"Warning, number of cpus is 0 for "'
nl|'\n'
string|'"%(instance)s on baremetal node %(node)s."'
op|')'
op|','
nl|'\n'
op|'{'
string|"'instance'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|','
nl|'\n'
string|"'node'"
op|':'
name|'instance'
op|'.'
name|'node'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'hardware'
op|'.'
name|'InstanceInfo'
op|'('
name|'state'
op|'='
name|'map_power_state'
op|'('
name|'node'
op|'.'
name|'power_state'
op|')'
op|','
nl|'\n'
name|'max_mem_kb'
op|'='
name|'memory_kib'
op|','
nl|'\n'
name|'mem_kb'
op|'='
name|'memory_kib'
op|','
nl|'\n'
name|'num_cpu'
op|'='
name|'num_cpu'
op|')'
newline|'\n'
nl|'\n'
DECL|member|deallocate_networks_on_reschedule
dedent|''
name|'def'
name|'deallocate_networks_on_reschedule'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Does the driver want networks deallocated on reschedule?\n\n        :param instance: the instance object.\n        :returns: Boolean value. If True deallocate networks on reschedule.\n        """'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
nl|'\n'
DECL|member|macs_for_instance
dedent|''
name|'def'
name|'macs_for_instance'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""List the MAC addresses of an instance.\n\n        List of MAC addresses for the node which this instance is\n        associated with.\n\n        :param instance: the instance object.\n        :return: None, or a set of MAC ids (e.g. set([\'12:34:56:78:90:ab\'])).\n            None means \'no constraints\', a set means \'these and only these\n            MAC addresses\'.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'node'
op|'='
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"node.get"'
op|','
name|'instance'
op|'.'
name|'node'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ironic'
op|'.'
name|'exc'
op|'.'
name|'NotFound'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'ports'
op|'='
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"node.list_ports"'
op|','
name|'node'
op|'.'
name|'uuid'
op|')'
newline|'\n'
name|'return'
name|'set'
op|'('
op|'['
name|'p'
op|'.'
name|'address'
name|'for'
name|'p'
name|'in'
name|'ports'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_generate_configdrive
dedent|''
name|'def'
name|'_generate_configdrive'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'node'
op|','
name|'network_info'
op|','
nl|'\n'
name|'extra_md'
op|'='
name|'None'
op|','
name|'files'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Generate a config drive.\n\n        :param instance: The instance object.\n        :param node: The node object.\n        :param network_info: Instance network information.\n        :param extra_md: Optional, extra metadata to be added to the\n                         configdrive.\n        :param files: Optional, a list of paths to files to be added to\n                      the configdrive.\n\n        """'
newline|'\n'
name|'if'
name|'not'
name|'extra_md'
op|':'
newline|'\n'
indent|'            '
name|'extra_md'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
dedent|''
name|'i_meta'
op|'='
name|'instance_metadata'
op|'.'
name|'InstanceMetadata'
op|'('
name|'instance'
op|','
nl|'\n'
name|'content'
op|'='
name|'files'
op|','
name|'extra_md'
op|'='
name|'extra_md'
op|','
name|'network_info'
op|'='
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
name|'with'
name|'tempfile'
op|'.'
name|'NamedTemporaryFile'
op|'('
op|')'
name|'as'
name|'uncompressed'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'configdrive'
op|'.'
name|'ConfigDriveBuilder'
op|'('
name|'instance_md'
op|'='
name|'i_meta'
op|')'
name|'as'
name|'cdb'
op|':'
newline|'\n'
indent|'                    '
name|'cdb'
op|'.'
name|'make_drive'
op|'('
name|'uncompressed'
op|'.'
name|'name'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|'"Creating config drive failed with "'
nl|'\n'
string|'"error: %s"'
op|')'
op|','
name|'e'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'with'
name|'tempfile'
op|'.'
name|'NamedTemporaryFile'
op|'('
op|')'
name|'as'
name|'compressed'
op|':'
newline|'\n'
comment|'# compress config drive'
nl|'\n'
indent|'                '
name|'with'
name|'gzip'
op|'.'
name|'GzipFile'
op|'('
name|'fileobj'
op|'='
name|'compressed'
op|','
name|'mode'
op|'='
string|"'wb'"
op|')'
name|'as'
name|'gzipped'
op|':'
newline|'\n'
indent|'                    '
name|'uncompressed'
op|'.'
name|'seek'
op|'('
number|'0'
op|')'
newline|'\n'
name|'shutil'
op|'.'
name|'copyfileobj'
op|'('
name|'uncompressed'
op|','
name|'gzipped'
op|')'
newline|'\n'
nl|'\n'
comment|'# base64 encode config drive'
nl|'\n'
dedent|''
name|'compressed'
op|'.'
name|'seek'
op|'('
number|'0'
op|')'
newline|'\n'
name|'return'
name|'base64'
op|'.'
name|'b64encode'
op|'('
name|'compressed'
op|'.'
name|'read'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|spawn
dedent|''
dedent|''
dedent|''
name|'def'
name|'spawn'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'injected_files'
op|','
nl|'\n'
name|'admin_password'
op|','
name|'network_info'
op|'='
name|'None'
op|','
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Deploy an instance.\n\n        :param context: The security context.\n        :param instance: The instance object.\n        :param image_meta: Image dict returned by nova.image.glance\n            that defines the image from which to boot this instance.\n        :param injected_files: User files to inject into instance.\n        :param admin_password: Administrator password to set in\n            instance.\n        :param network_info: Instance network information.\n        :param block_device_info: Instance block device\n            information. Ignored by this driver.\n        """'
newline|'\n'
comment|'# The compute manager is meant to know the node uuid, so missing uuid'
nl|'\n'
comment|"# is a significant issue. It may mean we've been passed the wrong data."
nl|'\n'
name|'node_uuid'
op|'='
name|'instance'
op|'.'
name|'get'
op|'('
string|"'node'"
op|')'
newline|'\n'
name|'if'
name|'not'
name|'node_uuid'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ironic'
op|'.'
name|'exc'
op|'.'
name|'BadRequest'
op|'('
nl|'\n'
name|'_'
op|'('
string|'"Ironic node uuid not supplied to "'
nl|'\n'
string|'"driver for instance %s."'
op|')'
op|'%'
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'node'
op|'='
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"node.get"'
op|','
name|'node_uuid'
op|')'
newline|'\n'
name|'flavor'
op|'='
name|'instance'
op|'.'
name|'flavor'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_add_driver_fields'
op|'('
name|'node'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'flavor'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(Shrews): The default ephemeral device needs to be set for'
nl|'\n'
comment|'# services (like cloud-init) that depend on it being returned by the'
nl|'\n'
comment|'# metadata server. Addresses bug https://launchpad.net/bugs/1324286.'
nl|'\n'
name|'if'
name|'flavor'
op|'.'
name|'ephemeral_gb'
op|':'
newline|'\n'
indent|'            '
name|'instance'
op|'.'
name|'default_ephemeral_device'
op|'='
string|"'/dev/sda1'"
newline|'\n'
name|'instance'
op|'.'
name|'save'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# validate we are ready to do the deploy'
nl|'\n'
dedent|''
name|'validate_chk'
op|'='
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"node.validate"'
op|','
name|'node_uuid'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'validate_chk'
op|'.'
name|'deploy'
name|'or'
name|'not'
name|'validate_chk'
op|'.'
name|'power'
op|':'
newline|'\n'
comment|'# something is wrong. undo what we have done'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_cleanup_deploy'
op|'('
name|'context'
op|','
name|'node'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'flavor'
op|'='
name|'flavor'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'ValidationError'
op|'('
name|'_'
op|'('
nl|'\n'
string|'"Ironic node: %(id)s failed to validate."'
nl|'\n'
string|'" (deploy: %(deploy)s, power: %(power)s)"'
op|')'
nl|'\n'
op|'%'
op|'{'
string|"'id'"
op|':'
name|'node'
op|'.'
name|'uuid'
op|','
nl|'\n'
string|"'deploy'"
op|':'
name|'validate_chk'
op|'.'
name|'deploy'
op|','
nl|'\n'
string|"'power'"
op|':'
name|'validate_chk'
op|'.'
name|'power'
op|'}'
op|')'
newline|'\n'
nl|'\n'
comment|'# prepare for the deploy'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_plug_vifs'
op|'('
name|'node'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_start_firewall'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|'"Error preparing deploy for instance "'
nl|'\n'
string|'"%(instance)s on baremetal node %(node)s."'
op|')'
op|','
nl|'\n'
op|'{'
string|"'instance'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|','
nl|'\n'
string|"'node'"
op|':'
name|'node_uuid'
op|'}'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_cleanup_deploy'
op|'('
name|'context'
op|','
name|'node'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'flavor'
op|'='
name|'flavor'
op|')'
newline|'\n'
nl|'\n'
comment|'# Config drive'
nl|'\n'
dedent|''
dedent|''
name|'configdrive_value'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'configdrive'
op|'.'
name|'required_by'
op|'('
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'extra_md'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'if'
name|'admin_password'
op|':'
newline|'\n'
indent|'                '
name|'extra_md'
op|'['
string|"'admin_pass'"
op|']'
op|'='
name|'admin_password'
newline|'\n'
nl|'\n'
dedent|''
name|'configdrive_value'
op|'='
name|'self'
op|'.'
name|'_generate_configdrive'
op|'('
nl|'\n'
name|'instance'
op|','
name|'node'
op|','
name|'network_info'
op|','
name|'extra_md'
op|'='
name|'extra_md'
op|','
nl|'\n'
name|'files'
op|'='
name|'injected_files'
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Config drive for instance %(instance)s on "'
nl|'\n'
string|'"baremetal node %(node)s created."'
op|')'
op|','
nl|'\n'
op|'{'
string|"'instance'"
op|':'
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
string|"'node'"
op|':'
name|'node_uuid'
op|'}'
op|')'
newline|'\n'
nl|'\n'
comment|'# trigger the node deploy'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"node.set_provision_state"'
op|','
name|'node_uuid'
op|','
nl|'\n'
name|'ironic_states'
op|'.'
name|'ACTIVE'
op|','
nl|'\n'
name|'configdrive'
op|'='
name|'configdrive_value'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
op|'('
name|'_LE'
op|'('
string|'"Failed to request Ironic to provision instance "'
nl|'\n'
string|'"%(inst)s: %(reason)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'inst'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|','
nl|'\n'
string|"'reason'"
op|':'
name|'six'
op|'.'
name|'text_type'
op|'('
name|'e'
op|')'
op|'}'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'error'
op|'('
name|'msg'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_cleanup_deploy'
op|'('
name|'context'
op|','
name|'node'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'flavor'
op|'='
name|'flavor'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
name|'self'
op|'.'
name|'_wait_for_active'
op|','
nl|'\n'
name|'self'
op|'.'
name|'ironicclient'
op|','
nl|'\n'
name|'instance'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
name|'CONF'
op|'.'
name|'ironic'
op|'.'
name|'api_retry_interval'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|'"Error deploying instance %(instance)s on "'
nl|'\n'
string|'"baremetal node %(node)s."'
op|')'
op|','
nl|'\n'
op|'{'
string|"'instance'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|','
nl|'\n'
string|"'node'"
op|':'
name|'node_uuid'
op|'}'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'destroy'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_unprovision
dedent|''
dedent|''
dedent|''
name|'def'
name|'_unprovision'
op|'('
name|'self'
op|','
name|'ironicclient'
op|','
name|'instance'
op|','
name|'node'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""This method is called from destroy() to unprovision\n        already provisioned node after required checks.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"node.set_provision_state"'
op|','
name|'node'
op|'.'
name|'uuid'
op|','
string|'"deleted"'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
comment|'# if the node is already in a deprovisioned state, continue'
nl|'\n'
comment|'# This should be fixed in Ironic.'
nl|'\n'
comment|'# TODO(deva): This exception should be added to'
nl|'\n'
comment|'#             python-ironicclient and matched directly,'
nl|'\n'
comment|'#             rather than via __name__.'
nl|'\n'
indent|'            '
name|'if'
name|'getattr'
op|'('
name|'e'
op|','
string|"'__name__'"
op|','
name|'None'
op|')'
op|'!='
string|"'InstanceDeployFailure'"
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
nl|'\n'
comment|'# using a dict because this is modified in the local method'
nl|'\n'
dedent|''
dedent|''
name|'data'
op|'='
op|'{'
string|"'tries'"
op|':'
number|'0'
op|'}'
newline|'\n'
nl|'\n'
DECL|function|_wait_for_provision_state
name|'def'
name|'_wait_for_provision_state'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'node'
op|'='
name|'_validate_instance_and_node'
op|'('
name|'ironicclient'
op|','
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'node'
op|'.'
name|'provision_state'
name|'in'
op|'('
name|'ironic_states'
op|'.'
name|'NOSTATE'
op|','
nl|'\n'
name|'ironic_states'
op|'.'
name|'CLEANING'
op|','
nl|'\n'
name|'ironic_states'
op|'.'
name|'CLEANFAIL'
op|','
nl|'\n'
name|'ironic_states'
op|'.'
name|'AVAILABLE'
op|')'
op|':'
newline|'\n'
comment|'# From a user standpoint, the node is unprovisioned. If a node'
nl|'\n'
comment|'# gets into CLEANFAIL state, it must be fixed in Ironic, but we'
nl|'\n'
comment|'# can consider the instance unprovisioned.'
nl|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Ironic node %(node)s is in state %(state)s, "'
nl|'\n'
string|'"instance is now unprovisioned."'
op|','
nl|'\n'
name|'dict'
op|'('
name|'node'
op|'='
name|'node'
op|'.'
name|'uuid'
op|','
name|'state'
op|'='
name|'node'
op|'.'
name|'provision_state'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'data'
op|'['
string|"'tries'"
op|']'
op|'>='
name|'CONF'
op|'.'
name|'ironic'
op|'.'
name|'api_max_retries'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|'"Error destroying the instance on node %(node)s. "'
nl|'\n'
string|'"Provision state still \'%(state)s\'."'
op|')'
nl|'\n'
op|'%'
op|'{'
string|"'state'"
op|':'
name|'node'
op|'.'
name|'provision_state'
op|','
nl|'\n'
string|"'node'"
op|':'
name|'node'
op|'.'
name|'uuid'
op|'}'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'error'
op|'('
name|'msg'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'data'
op|'['
string|"'tries'"
op|']'
op|'+='
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'_log_ironic_polling'
op|'('
string|"'unprovision'"
op|','
name|'node'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# wait for the state transition to finish'
nl|'\n'
dedent|''
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
name|'_wait_for_provision_state'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
name|'CONF'
op|'.'
name|'ironic'
op|'.'
name|'api_retry_interval'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|destroy
dedent|''
name|'def'
name|'destroy'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'destroy_disks'
op|'='
name|'True'
op|','
name|'migrate_data'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Destroy the specified instance, if it can be found.\n\n        :param context: The security context.\n        :param instance: The instance object.\n        :param network_info: Instance network information.\n        :param block_device_info: Instance block device\n            information. Ignored by this driver.\n        :param destroy_disks: Indicates if disks should be\n            destroyed. Ignored by this driver.\n        :param migrate_data: implementation specific params.\n            Ignored by this driver.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'node'
op|'='
name|'_validate_instance_and_node'
op|'('
name|'self'
op|'.'
name|'ironicclient'
op|','
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"Destroy called on non-existing instance %s."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
comment|'# NOTE(deva): if nova.compute.ComputeManager._delete_instance()'
nl|'\n'
comment|'#             is called on a non-existing instance, the only way'
nl|'\n'
comment|'#             to delete it is to return from this method'
nl|'\n'
comment|'#             without raising any exceptions.'
nl|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'node'
op|'.'
name|'provision_state'
name|'in'
op|'('
name|'ironic_states'
op|'.'
name|'ACTIVE'
op|','
nl|'\n'
name|'ironic_states'
op|'.'
name|'DEPLOYFAIL'
op|','
nl|'\n'
name|'ironic_states'
op|'.'
name|'ERROR'
op|','
nl|'\n'
name|'ironic_states'
op|'.'
name|'DEPLOYWAIT'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_unprovision'
op|'('
name|'self'
op|'.'
name|'ironicclient'
op|','
name|'instance'
op|','
name|'node'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_cleanup_deploy'
op|'('
name|'context'
op|','
name|'node'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|reboot
dedent|''
name|'def'
name|'reboot'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'reboot_type'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'bad_volumes_callback'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Reboot the specified instance.\n\n        NOTE: Ironic does not support soft-off, so this method\n              always performs a hard-reboot.\n        NOTE: Unlike the libvirt driver, this method does not delete\n              and recreate the instance; it preserves local state.\n\n        :param context: The security context.\n        :param instance: The instance object.\n        :param network_info: Instance network information. Ignored by\n            this driver.\n        :param reboot_type: Either a HARD or SOFT reboot. Ignored by\n            this driver.\n        :param block_device_info: Info pertaining to attached volumes.\n            Ignored by this driver.\n        :param bad_volumes_callback: Function to handle any bad volumes\n            encountered. Ignored by this driver.\n\n        """'
newline|'\n'
name|'node'
op|'='
name|'_validate_instance_and_node'
op|'('
name|'self'
op|'.'
name|'ironicclient'
op|','
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"node.set_power_state"'
op|','
name|'node'
op|'.'
name|'uuid'
op|','
string|"'reboot'"
op|')'
newline|'\n'
nl|'\n'
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_wait_for_power_state'
op|','
nl|'\n'
name|'self'
op|'.'
name|'ironicclient'
op|','
name|'instance'
op|','
string|"'reboot'"
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
name|'CONF'
op|'.'
name|'ironic'
op|'.'
name|'api_retry_interval'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|power_off
dedent|''
name|'def'
name|'power_off'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'timeout'
op|'='
number|'0'
op|','
name|'retry_interval'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Power off the specified instance.\n\n        NOTE: Ironic does not support soft-off, so this method ignores\n              timeout and retry_interval parameters.\n        NOTE: Unlike the libvirt driver, this method does not delete\n              and recreate the instance; it preserves local state.\n\n        :param instance: The instance object.\n        :param timeout: time to wait for node to shutdown. Ignored by\n            this driver.\n        :param retry_interval: How often to signal node while waiting\n            for it to shutdown. Ignored by this driver.\n        """'
newline|'\n'
name|'node'
op|'='
name|'_validate_instance_and_node'
op|'('
name|'self'
op|'.'
name|'ironicclient'
op|','
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"node.set_power_state"'
op|','
name|'node'
op|'.'
name|'uuid'
op|','
string|"'off'"
op|')'
newline|'\n'
nl|'\n'
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_wait_for_power_state'
op|','
nl|'\n'
name|'self'
op|'.'
name|'ironicclient'
op|','
name|'instance'
op|','
string|"'power off'"
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
name|'CONF'
op|'.'
name|'ironic'
op|'.'
name|'api_retry_interval'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|power_on
dedent|''
name|'def'
name|'power_on'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Power on the specified instance.\n\n        NOTE: Unlike the libvirt driver, this method does not delete\n              and recreate the instance; it preserves local state.\n\n        :param context: The security context.\n        :param instance: The instance object.\n        :param network_info: Instance network information. Ignored by\n            this driver.\n        :param block_device_info: Instance block device\n            information. Ignored by this driver.\n\n        """'
newline|'\n'
name|'node'
op|'='
name|'_validate_instance_and_node'
op|'('
name|'self'
op|'.'
name|'ironicclient'
op|','
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"node.set_power_state"'
op|','
name|'node'
op|'.'
name|'uuid'
op|','
string|"'on'"
op|')'
newline|'\n'
nl|'\n'
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_wait_for_power_state'
op|','
nl|'\n'
name|'self'
op|'.'
name|'ironicclient'
op|','
name|'instance'
op|','
string|"'power on'"
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
name|'CONF'
op|'.'
name|'ironic'
op|'.'
name|'api_retry_interval'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|refresh_security_group_rules
dedent|''
name|'def'
name|'refresh_security_group_rules'
op|'('
name|'self'
op|','
name|'security_group_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Refresh security group rules from data store.\n\n        Invoked when security group rules are updated.\n\n        :param security_group_id: The security group id.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'refresh_security_group_rules'
op|'('
name|'security_group_id'
op|')'
newline|'\n'
nl|'\n'
DECL|member|refresh_security_group_members
dedent|''
name|'def'
name|'refresh_security_group_members'
op|'('
name|'self'
op|','
name|'security_group_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Refresh security group members from data store.\n\n        Invoked when instances are added/removed to a security group.\n\n        :param security_group_id: The security group id.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'refresh_security_group_members'
op|'('
name|'security_group_id'
op|')'
newline|'\n'
nl|'\n'
DECL|member|refresh_provider_fw_rules
dedent|''
name|'def'
name|'refresh_provider_fw_rules'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Triggers a firewall update based on database changes."""'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'refresh_provider_fw_rules'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|refresh_instance_security_rules
dedent|''
name|'def'
name|'refresh_instance_security_rules'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Refresh security group rules from data store.\n\n        Gets called when an instance gets added to or removed from\n        the security group the instance is a member of or if the\n        group gains or loses a rule.\n\n        :param instance: The instance object.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'refresh_instance_security_rules'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|ensure_filtering_rules_for_instance
dedent|''
name|'def'
name|'ensure_filtering_rules_for_instance'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Set up filtering rules.\n\n        :param instance: The instance object.\n        :param network_info: Instance network information.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'setup_basic_filtering'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'prepare_instance_filter'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|unfilter_instance
dedent|''
name|'def'
name|'unfilter_instance'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Stop filtering instance.\n\n        :param instance: The instance object.\n        :param network_info: Instance network information.\n\n        """'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'unfilter_instance'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_plug_vifs
dedent|''
name|'def'
name|'_plug_vifs'
op|'('
name|'self'
op|','
name|'node'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(PhilDay): Accessing network_info will block if the thread'
nl|'\n'
comment|"# it wraps hasn't finished, so do this ahead of time so that we"
nl|'\n'
comment|"# don't block while holding the logging lock."
nl|'\n'
indent|'        '
name|'network_info_str'
op|'='
name|'str'
op|'('
name|'network_info'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"plug: instance_uuid=%(uuid)s vif=%(network_info)s"'
op|','
nl|'\n'
op|'{'
string|"'uuid'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|','
nl|'\n'
string|"'network_info'"
op|':'
name|'network_info_str'
op|'}'
op|')'
newline|'\n'
comment|'# start by ensuring the ports are clear'
nl|'\n'
name|'self'
op|'.'
name|'_unplug_vifs'
op|'('
name|'node'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
name|'ports'
op|'='
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"node.list_ports"'
op|','
name|'node'
op|'.'
name|'uuid'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'network_info'
op|')'
op|'>'
name|'len'
op|'('
name|'ports'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'VirtualInterfacePlugException'
op|'('
name|'_'
op|'('
nl|'\n'
string|'"Ironic node: %(id)s virtual to physical interface count"'
nl|'\n'
string|'"  missmatch"'
nl|'\n'
string|'" (Vif count: %(vif_count)d, Pif count: %(pif_count)d)"'
op|')'
nl|'\n'
op|'%'
op|'{'
string|"'id'"
op|':'
name|'node'
op|'.'
name|'uuid'
op|','
nl|'\n'
string|"'vif_count'"
op|':'
name|'len'
op|'('
name|'network_info'
op|')'
op|','
nl|'\n'
string|"'pif_count'"
op|':'
name|'len'
op|'('
name|'ports'
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'len'
op|'('
name|'network_info'
op|')'
op|'>'
number|'0'
op|':'
newline|'\n'
comment|'# not needed if no vif are defined'
nl|'\n'
indent|'            '
name|'for'
name|'vif'
op|','
name|'pif'
name|'in'
name|'zip'
op|'('
name|'network_info'
op|','
name|'ports'
op|')'
op|':'
newline|'\n'
comment|'# attach what neutron needs directly to the port'
nl|'\n'
indent|'                '
name|'port_id'
op|'='
name|'six'
op|'.'
name|'text_type'
op|'('
name|'vif'
op|'['
string|"'id'"
op|']'
op|')'
newline|'\n'
name|'patch'
op|'='
op|'['
op|'{'
string|"'op'"
op|':'
string|"'add'"
op|','
nl|'\n'
string|"'path'"
op|':'
string|"'/extra/vif_port_id'"
op|','
nl|'\n'
string|"'value'"
op|':'
name|'port_id'
op|'}'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"port.update"'
op|','
name|'pif'
op|'.'
name|'uuid'
op|','
name|'patch'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_unplug_vifs
dedent|''
dedent|''
dedent|''
name|'def'
name|'_unplug_vifs'
op|'('
name|'self'
op|','
name|'node'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(PhilDay): Accessing network_info will block if the thread'
nl|'\n'
comment|"# it wraps hasn't finished, so do this ahead of time so that we"
nl|'\n'
comment|"# don't block while holding the logging lock."
nl|'\n'
indent|'        '
name|'network_info_str'
op|'='
name|'str'
op|'('
name|'network_info'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"unplug: instance_uuid=%(uuid)s vif=%(network_info)s"'
op|','
nl|'\n'
op|'{'
string|"'uuid'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|','
nl|'\n'
string|"'network_info'"
op|':'
name|'network_info_str'
op|'}'
op|')'
newline|'\n'
name|'if'
name|'network_info'
name|'and'
name|'len'
op|'('
name|'network_info'
op|')'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'ports'
op|'='
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"node.list_ports"'
op|','
name|'node'
op|'.'
name|'uuid'
op|','
nl|'\n'
name|'detail'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
comment|'# not needed if no vif are defined'
nl|'\n'
name|'for'
name|'vif'
op|','
name|'pif'
name|'in'
name|'zip'
op|'('
name|'network_info'
op|','
name|'ports'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
string|"'vif_port_id'"
name|'in'
name|'pif'
op|'.'
name|'extra'
op|':'
newline|'\n'
comment|'# we can not attach a dict directly'
nl|'\n'
indent|'                    '
name|'patch'
op|'='
op|'['
op|'{'
string|"'op'"
op|':'
string|"'remove'"
op|','
string|"'path'"
op|':'
string|"'/extra/vif_port_id'"
op|'}'
op|']'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"port.update"'
op|','
name|'pif'
op|'.'
name|'uuid'
op|','
name|'patch'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ironic'
op|'.'
name|'exc'
op|'.'
name|'BadRequest'
op|':'
newline|'\n'
indent|'                        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|plug_vifs
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'plug_vifs'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Plug VIFs into networks.\n\n        :param instance: The instance object.\n        :param network_info: Instance network information.\n\n        """'
newline|'\n'
name|'node'
op|'='
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"node.get"'
op|','
name|'instance'
op|'.'
name|'node'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_plug_vifs'
op|'('
name|'node'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|unplug_vifs
dedent|''
name|'def'
name|'unplug_vifs'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Unplug VIFs from networks.\n\n        :param instance: The instance object.\n        :param network_info: Instance network information.\n\n        """'
newline|'\n'
name|'node'
op|'='
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"node.get"'
op|','
name|'instance'
op|'.'
name|'node'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_unplug_vifs'
op|'('
name|'node'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|rebuild
dedent|''
name|'def'
name|'rebuild'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'injected_files'
op|','
nl|'\n'
name|'admin_password'
op|','
name|'bdms'
op|','
name|'detach_block_devices'
op|','
nl|'\n'
name|'attach_block_devices'
op|','
name|'network_info'
op|'='
name|'None'
op|','
nl|'\n'
name|'recreate'
op|'='
name|'False'
op|','
name|'block_device_info'
op|'='
name|'None'
op|','
nl|'\n'
name|'preserve_ephemeral'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Rebuild/redeploy an instance.\n\n        This version of rebuild() allows for supporting the option to\n        preserve the ephemeral partition. We cannot call spawn() from\n        here because it will attempt to set the instance_uuid value\n        again, which is not allowed by the Ironic API. It also requires\n        the instance to not have an \'active\' provision state, but we\n        cannot safely change that. Given that, we implement only the\n        portions of spawn() we need within rebuild().\n\n        :param context: The security context.\n        :param instance: The instance object.\n        :param image_meta: Image object returned by nova.image.glance\n            that defines the image from which to boot this instance. Ignored\n            by this driver.\n        :param injected_files: User files to inject into instance. Ignored\n            by this driver.\n        :param admin_password: Administrator password to set in\n            instance. Ignored by this driver.\n        :param bdms: block-device-mappings to use for rebuild. Ignored\n            by this driver.\n        :param detach_block_devices: function to detach block devices. See\n            nova.compute.manager.ComputeManager:_rebuild_default_impl for\n            usage. Ignored by this driver.\n        :param attach_block_devices: function to attach block devices. See\n            nova.compute.manager.ComputeManager:_rebuild_default_impl for\n            usage. Ignored by this driver.\n        :param network_info: Instance network information. Ignored by\n            this driver.\n        :param recreate: Boolean value; if True the instance is\n            recreated on a new hypervisor - all the cleanup of old state is\n            skipped. Ignored by this driver.\n        :param block_device_info: Instance block device\n            information. Ignored by this driver.\n        :param preserve_ephemeral: Boolean value; if True the ephemeral\n            must be preserved on rebuild.\n\n        """'
newline|'\n'
name|'instance'
op|'.'
name|'task_state'
op|'='
name|'task_states'
op|'.'
name|'REBUILD_SPAWNING'
newline|'\n'
name|'instance'
op|'.'
name|'save'
op|'('
name|'expected_task_state'
op|'='
op|'['
name|'task_states'
op|'.'
name|'REBUILDING'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'node_uuid'
op|'='
name|'instance'
op|'.'
name|'node'
newline|'\n'
name|'node'
op|'='
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"node.get"'
op|','
name|'node_uuid'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_add_driver_fields'
op|'('
name|'node'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'instance'
op|'.'
name|'flavor'
op|','
nl|'\n'
name|'preserve_ephemeral'
op|')'
newline|'\n'
nl|'\n'
comment|'# Trigger the node rebuild/redeploy.'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'ironicclient'
op|'.'
name|'call'
op|'('
string|'"node.set_provision_state"'
op|','
nl|'\n'
name|'node_uuid'
op|','
name|'ironic_states'
op|'.'
name|'REBUILD'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'exception'
op|'.'
name|'NovaException'
op|','
comment|'# Retry failed'
nl|'\n'
name|'ironic'
op|'.'
name|'exc'
op|'.'
name|'InternalServerError'
op|','
comment|'# Validations'
nl|'\n'
name|'ironic'
op|'.'
name|'exc'
op|'.'
name|'BadRequest'
op|')'
name|'as'
name|'e'
op|':'
comment|'# Maintenance'
newline|'\n'
indent|'            '
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|'"Failed to request Ironic to rebuild instance "'
nl|'\n'
string|'"%(inst)s: %(reason)s"'
op|')'
op|'%'
op|'{'
string|"'inst'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|','
nl|'\n'
string|"'reason'"
op|':'
name|'six'
op|'.'
name|'text_type'
op|'('
name|'e'
op|')'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstanceDeployFailure'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
comment|'# Although the target provision state is REBUILD, it will actually go'
nl|'\n'
comment|'# to ACTIVE once the redeploy is finished.'
nl|'\n'
dedent|''
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
name|'self'
op|'.'
name|'_wait_for_active'
op|','
nl|'\n'
name|'self'
op|'.'
name|'ironicclient'
op|','
nl|'\n'
name|'instance'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
name|'CONF'
op|'.'
name|'ironic'
op|'.'
name|'api_retry_interval'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
