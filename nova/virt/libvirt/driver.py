begin_unit
comment|'# vim: tabstop=4 shiftwidth=4 softtabstop=4'
nl|'\n'
nl|'\n'
comment|'# Copyright 2010 United States Government as represented by the'
nl|'\n'
comment|'# Administrator of the National Aeronautics and Space Administration.'
nl|'\n'
comment|'# All Rights Reserved.'
nl|'\n'
comment|'# Copyright (c) 2010 Citrix Systems, Inc.'
nl|'\n'
comment|'# Copyright (c) 2011 Piston Cloud Computing, Inc'
nl|'\n'
comment|'# Copyright (c) 2012 University Of Minho'
nl|'\n'
comment|'# (c) Copyright 2013 Hewlett-Packard Development Company, L.P.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
nl|'\n'
string|'"""\nA connection to a hypervisor through libvirt.\n\nSupports KVM, LXC, QEMU, UML, and XEN.\n\n**Related Flags**\n\n:libvirt_type:  Libvirt domain type.  Can be kvm, qemu, uml, xen\n                (default: kvm).\n:libvirt_uri:  Override for the default libvirt URI (depends on libvirt_type).\n:libvirt_disk_prefix:  Override the default disk prefix for the devices\n                       attached to a server.\n:rescue_image_id:  Rescue ami image (None = original image).\n:rescue_kernel_id:  Rescue aki image (None = original image).\n:rescue_ramdisk_id:  Rescue ari image (None = original image).\n:injected_network_template:  Template file for injected network\n:allow_same_net_traffic:  Whether to allow in project network traffic\n\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'errno'
newline|'\n'
name|'import'
name|'eventlet'
newline|'\n'
name|'import'
name|'functools'
newline|'\n'
name|'import'
name|'glob'
newline|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'shutil'
newline|'\n'
name|'import'
name|'socket'
newline|'\n'
name|'import'
name|'sys'
newline|'\n'
name|'import'
name|'tempfile'
newline|'\n'
name|'import'
name|'threading'
newline|'\n'
name|'import'
name|'time'
newline|'\n'
name|'import'
name|'uuid'
newline|'\n'
nl|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'greenio'
newline|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'greenthread'
newline|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'patcher'
newline|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'tpool'
newline|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'util'
name|'as'
name|'eventlet_util'
newline|'\n'
name|'from'
name|'lxml'
name|'import'
name|'etree'
newline|'\n'
name|'from'
name|'oslo'
op|'.'
name|'config'
name|'import'
name|'cfg'
newline|'\n'
nl|'\n'
name|'from'
name|'nova'
op|'.'
name|'api'
op|'.'
name|'metadata'
name|'import'
name|'base'
name|'as'
name|'instance_metadata'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'block_device'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'flavors'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'power_state'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'task_states'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'utils'
name|'as'
name|'compute_utils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'vm_mode'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'context'
name|'as'
name|'nova_context'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'exception'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'image'
name|'import'
name|'glance'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'notifier'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'objects'
name|'import'
name|'instance'
name|'as'
name|'instance_obj'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'excutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'fileutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
op|'.'
name|'gettextutils'
name|'import'
name|'_'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'importutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'jsonutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'log'
name|'as'
name|'logging'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'loopingcall'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'processutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'xmlutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'pci'
name|'import'
name|'pci_manager'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'pci'
name|'import'
name|'pci_utils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'pci'
name|'import'
name|'pci_whitelist'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'utils'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'version'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'configdrive'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'disk'
name|'import'
name|'api'
name|'as'
name|'disk'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'driver'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'event'
name|'as'
name|'virtevent'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'firewall'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'blockinfo'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'config'
name|'as'
name|'vconfig'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'firewall'
name|'as'
name|'libvirt_firewall'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'imagebackend'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'imagecache'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'utils'
name|'as'
name|'libvirt_utils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'netutils'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'volume'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'volume'
name|'import'
name|'encryptors'
newline|'\n'
nl|'\n'
DECL|variable|native_threading
name|'native_threading'
op|'='
name|'patcher'
op|'.'
name|'original'
op|'('
string|'"threading"'
op|')'
newline|'\n'
DECL|variable|native_Queue
name|'native_Queue'
op|'='
name|'patcher'
op|'.'
name|'original'
op|'('
string|'"Queue"'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|libvirt
name|'libvirt'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|variable|LOG
name|'LOG'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|libvirt_opts
name|'libvirt_opts'
op|'='
op|'['
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'rescue_image_id'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Rescue ami image'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'rescue_kernel_id'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Rescue aki image'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'rescue_ramdisk_id'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Rescue ari image'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'libvirt_type'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'kvm'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Libvirt domain type (valid options are: '"
nl|'\n'
string|"'kvm, lxc, qemu, uml, xen)'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'libvirt_uri'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"''"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Override the default libvirt URI '"
nl|'\n'
string|"'(which is dependent on libvirt_type)'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'BoolOpt'
op|'('
string|"'libvirt_inject_password'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
name|'False'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Inject the admin password at boot time, '"
nl|'\n'
string|"'without an agent.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'BoolOpt'
op|'('
string|"'libvirt_inject_key'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
name|'True'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Inject the ssh public key at boot time'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'libvirt_inject_partition'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'1'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'The partition to inject to : '"
nl|'\n'
string|"'-2 => disable, -1 => inspect (libguestfs only), '"
nl|'\n'
string|"'0 => not partitioned, >0 => partition number'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'BoolOpt'
op|'('
string|"'use_usb_tablet'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
name|'True'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Sync virtual and real mouse cursors in Windows VMs'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'live_migration_uri'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|'"qemu+tcp://%s/system"'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Migration target URI '"
nl|'\n'
string|'\'(any included "%s" is replaced with \''
nl|'\n'
string|"'the migration target hostname)'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'live_migration_flag'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Migration flags to be set for live migration'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'block_migration_flag'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '"
nl|'\n'
string|"'VIR_MIGRATE_NON_SHARED_INC'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Migration flags to be set for block migration'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'live_migration_bandwidth'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'0'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Maximum bandwidth to be used during migration, in Mbps'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'snapshot_image_format'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Snapshot image format (valid options are : '"
nl|'\n'
string|"'raw, qcow2, vmdk, vdi). '"
nl|'\n'
string|"'Defaults to same as source image'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'libvirt_vif_driver'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'nova.virt.libvirt.vif.LibvirtGenericVIFDriver'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'The libvirt VIF driver to configure the VIFs.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'ListOpt'
op|'('
string|"'libvirt_volume_drivers'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
op|'['
nl|'\n'
string|"'iscsi=nova.virt.libvirt.volume.LibvirtISCSIVolumeDriver'"
op|','
nl|'\n'
string|"'iser=nova.virt.libvirt.volume.LibvirtISERVolumeDriver'"
op|','
nl|'\n'
string|"'local=nova.virt.libvirt.volume.LibvirtVolumeDriver'"
op|','
nl|'\n'
string|"'fake=nova.virt.libvirt.volume.LibvirtFakeVolumeDriver'"
op|','
nl|'\n'
string|"'rbd=nova.virt.libvirt.volume.LibvirtNetVolumeDriver'"
op|','
nl|'\n'
string|"'sheepdog=nova.virt.libvirt.volume.LibvirtNetVolumeDriver'"
op|','
nl|'\n'
string|"'nfs=nova.virt.libvirt.volume.LibvirtNFSVolumeDriver'"
op|','
nl|'\n'
string|"'aoe=nova.virt.libvirt.volume.LibvirtAOEVolumeDriver'"
op|','
nl|'\n'
string|"'glusterfs='"
nl|'\n'
string|"'nova.virt.libvirt.volume.LibvirtGlusterfsVolumeDriver'"
op|','
nl|'\n'
string|"'fibre_channel=nova.virt.libvirt.volume.'"
nl|'\n'
string|"'LibvirtFibreChannelVolumeDriver'"
op|','
nl|'\n'
string|"'scality='"
nl|'\n'
string|"'nova.virt.libvirt.volume.LibvirtScalityVolumeDriver'"
op|','
nl|'\n'
op|']'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Libvirt handlers for remote volumes.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'libvirt_disk_prefix'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Override the default disk prefix for the devices attached'"
nl|'\n'
string|"' to a server, which is dependent on libvirt_type. '"
nl|'\n'
string|"'(valid options are: sd, xvd, uvd, vd)'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'libvirt_wait_soft_reboot_seconds'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'120'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Number of seconds to wait for instance to shut down after'"
nl|'\n'
string|"' soft reboot request is made. We fall back to hard reboot'"
nl|'\n'
string|"' if instance does not shutdown within this window.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'BoolOpt'
op|'('
string|"'libvirt_nonblocking'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
name|'True'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Use a separated OS thread pool to realize non-blocking'"
nl|'\n'
string|"' libvirt calls'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'libvirt_cpu_mode'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|'\'Set to "host-model" to clone the host CPU feature flags; \''
nl|'\n'
string|'\'to "host-passthrough" to use the host CPU model exactly; \''
nl|'\n'
string|'\'to "custom" to use a named CPU model; \''
nl|'\n'
string|'\'to "none" to not set any CPU model. \''
nl|'\n'
string|'\'If libvirt_type="kvm|qemu", it will default to \''
nl|'\n'
string|'\'"host-model", otherwise it will default to "none"\''
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'libvirt_cpu_model'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Set to a named libvirt CPU model (see names listed '"
nl|'\n'
string|"'in /usr/share/libvirt/cpu_map.xml). Only has effect if '"
nl|'\n'
string|'\'libvirt_cpu_mode="custom" and libvirt_type="kvm|qemu"\''
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'libvirt_snapshots_directory'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'$instances_path/snapshots'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Location where libvirt driver will store snapshots '"
nl|'\n'
string|"'before uploading them to image service'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'xen_hvmloader_path'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'/usr/lib/xen/boot/hvmloader'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Location where the Xen hvmloader is kept'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'ListOpt'
op|'('
string|"'disk_cachemodes'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
op|'['
op|']'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Specific cachemodes to use for different disk types '"
nl|'\n'
string|"'e.g: file=directsync,block=none'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'vcpu_pin_set'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Which pcpus can be used by vcpus of instance '"
nl|'\n'
string|'\'e.g: "4-12,^8,15"\''
op|')'
op|','
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
DECL|variable|CONF
name|'CONF'
op|'='
name|'cfg'
op|'.'
name|'CONF'
newline|'\n'
name|'CONF'
op|'.'
name|'register_opts'
op|'('
name|'libvirt_opts'
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'host'"
op|','
string|"'nova.netconf'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'my_ip'"
op|','
string|"'nova.netconf'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'default_ephemeral_format'"
op|','
string|"'nova.virt.driver'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'use_cow_images'"
op|','
string|"'nova.virt.driver'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'live_migration_retry_count'"
op|','
string|"'nova.compute.manager'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'vncserver_proxyclient_address'"
op|','
string|"'nova.vnc'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'server_proxyclient_address'"
op|','
string|"'nova.spice'"
op|','
name|'group'
op|'='
string|"'spice'"
op|')'
newline|'\n'
nl|'\n'
DECL|variable|DEFAULT_FIREWALL_DRIVER
name|'DEFAULT_FIREWALL_DRIVER'
op|'='
string|'"%s.%s"'
op|'%'
op|'('
nl|'\n'
name|'libvirt_firewall'
op|'.'
name|'__name__'
op|','
nl|'\n'
name|'libvirt_firewall'
op|'.'
name|'IptablesFirewallDriver'
op|'.'
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|MAX_CONSOLE_BYTES
name|'MAX_CONSOLE_BYTES'
op|'='
number|'102400'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|patch_tpool_proxy
name|'def'
name|'patch_tpool_proxy'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""eventlet.tpool.Proxy doesn\'t work with old-style class in __str__()\n    or __repr__() calls. See bug #962840 for details.\n    We perform a monkey patch to replace those two instance methods.\n    """'
newline|'\n'
DECL|function|str_method
name|'def'
name|'str_method'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'str'
op|'('
name|'self'
op|'.'
name|'_obj'
op|')'
newline|'\n'
nl|'\n'
DECL|function|repr_method
dedent|''
name|'def'
name|'repr_method'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'repr'
op|'('
name|'self'
op|'.'
name|'_obj'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'tpool'
op|'.'
name|'Proxy'
op|'.'
name|'__str__'
op|'='
name|'str_method'
newline|'\n'
name|'tpool'
op|'.'
name|'Proxy'
op|'.'
name|'__repr__'
op|'='
name|'repr_method'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
name|'patch_tpool_proxy'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|variable|VIR_DOMAIN_NOSTATE
name|'VIR_DOMAIN_NOSTATE'
op|'='
number|'0'
newline|'\n'
DECL|variable|VIR_DOMAIN_RUNNING
name|'VIR_DOMAIN_RUNNING'
op|'='
number|'1'
newline|'\n'
DECL|variable|VIR_DOMAIN_BLOCKED
name|'VIR_DOMAIN_BLOCKED'
op|'='
number|'2'
newline|'\n'
DECL|variable|VIR_DOMAIN_PAUSED
name|'VIR_DOMAIN_PAUSED'
op|'='
number|'3'
newline|'\n'
DECL|variable|VIR_DOMAIN_SHUTDOWN
name|'VIR_DOMAIN_SHUTDOWN'
op|'='
number|'4'
newline|'\n'
DECL|variable|VIR_DOMAIN_SHUTOFF
name|'VIR_DOMAIN_SHUTOFF'
op|'='
number|'5'
newline|'\n'
DECL|variable|VIR_DOMAIN_CRASHED
name|'VIR_DOMAIN_CRASHED'
op|'='
number|'6'
newline|'\n'
DECL|variable|VIR_DOMAIN_PMSUSPENDED
name|'VIR_DOMAIN_PMSUSPENDED'
op|'='
number|'7'
newline|'\n'
nl|'\n'
DECL|variable|LIBVIRT_POWER_STATE
name|'LIBVIRT_POWER_STATE'
op|'='
op|'{'
nl|'\n'
name|'VIR_DOMAIN_NOSTATE'
op|':'
name|'power_state'
op|'.'
name|'NOSTATE'
op|','
nl|'\n'
name|'VIR_DOMAIN_RUNNING'
op|':'
name|'power_state'
op|'.'
name|'RUNNING'
op|','
nl|'\n'
comment|'# NOTE(maoy): The DOMAIN_BLOCKED state is only valid in Xen.'
nl|'\n'
comment|'# It means that the VM is running and the vCPU is idle. So,'
nl|'\n'
comment|'# we map it to RUNNING'
nl|'\n'
name|'VIR_DOMAIN_BLOCKED'
op|':'
name|'power_state'
op|'.'
name|'RUNNING'
op|','
nl|'\n'
name|'VIR_DOMAIN_PAUSED'
op|':'
name|'power_state'
op|'.'
name|'PAUSED'
op|','
nl|'\n'
comment|'# NOTE(maoy): The libvirt API doc says that DOMAIN_SHUTDOWN'
nl|'\n'
comment|'# means the domain is being shut down. So technically the domain'
nl|'\n'
comment|'# is still running. SHUTOFF is the real powered off state.'
nl|'\n'
comment|'# But we will map both to SHUTDOWN anyway.'
nl|'\n'
comment|'# http://libvirt.org/html/libvirt-libvirt.html'
nl|'\n'
name|'VIR_DOMAIN_SHUTDOWN'
op|':'
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|','
nl|'\n'
name|'VIR_DOMAIN_SHUTOFF'
op|':'
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|','
nl|'\n'
name|'VIR_DOMAIN_CRASHED'
op|':'
name|'power_state'
op|'.'
name|'CRASHED'
op|','
nl|'\n'
name|'VIR_DOMAIN_PMSUSPENDED'
op|':'
name|'power_state'
op|'.'
name|'SUSPENDED'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
DECL|variable|MIN_LIBVIRT_VERSION
name|'MIN_LIBVIRT_VERSION'
op|'='
op|'('
number|'0'
op|','
number|'9'
op|','
number|'6'
op|')'
newline|'\n'
comment|'# When the above version matches/exceeds this version'
nl|'\n'
comment|'# delete it & corresponding code using it'
nl|'\n'
DECL|variable|MIN_LIBVIRT_HOST_CPU_VERSION
name|'MIN_LIBVIRT_HOST_CPU_VERSION'
op|'='
op|'('
number|'0'
op|','
number|'9'
op|','
number|'10'
op|')'
newline|'\n'
DECL|variable|MIN_LIBVIRT_CLOSE_CALLBACK_VERSION
name|'MIN_LIBVIRT_CLOSE_CALLBACK_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'0'
op|','
number|'1'
op|')'
newline|'\n'
DECL|variable|MIN_LIBVIRT_DEVICE_CALLBACK_VERSION
name|'MIN_LIBVIRT_DEVICE_CALLBACK_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'1'
op|','
number|'1'
op|')'
newline|'\n'
comment|'# Live snapshot requirements'
nl|'\n'
DECL|variable|REQ_HYPERVISOR_LIVESNAPSHOT
name|'REQ_HYPERVISOR_LIVESNAPSHOT'
op|'='
string|'"QEMU"'
newline|'\n'
DECL|variable|MIN_LIBVIRT_LIVESNAPSHOT_VERSION
name|'MIN_LIBVIRT_LIVESNAPSHOT_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'0'
op|','
number|'0'
op|')'
newline|'\n'
DECL|variable|MIN_QEMU_LIVESNAPSHOT_VERSION
name|'MIN_QEMU_LIVESNAPSHOT_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'3'
op|','
number|'0'
op|')'
newline|'\n'
comment|'# block size tuning requirements'
nl|'\n'
DECL|variable|MIN_LIBVIRT_BLOCKIO_VERSION
name|'MIN_LIBVIRT_BLOCKIO_VERSION'
op|'='
op|'('
number|'0'
op|','
number|'10'
op|','
number|'2'
op|')'
newline|'\n'
comment|'# BlockJobInfo management requirement'
nl|'\n'
DECL|variable|MIN_LIBVIRT_BLOCKJOBINFO_VERSION
name|'MIN_LIBVIRT_BLOCKJOBINFO_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'1'
op|','
number|'1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|libvirt_error_handler
name|'def'
name|'libvirt_error_handler'
op|'('
name|'context'
op|','
name|'err'
op|')'
op|':'
newline|'\n'
comment|'# Just ignore instead of default outputting to stderr.'
nl|'\n'
indent|'    '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|LibvirtDriver
dedent|''
name|'class'
name|'LibvirtDriver'
op|'('
name|'driver'
op|'.'
name|'ComputeDriver'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|capabilities
indent|'    '
name|'capabilities'
op|'='
op|'{'
nl|'\n'
string|'"has_imagecache"'
op|':'
name|'True'
op|','
nl|'\n'
string|'"supports_recreate"'
op|':'
name|'True'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'virtapi'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'super'
op|'('
name|'LibvirtDriver'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'virtapi'
op|')'
newline|'\n'
nl|'\n'
name|'global'
name|'libvirt'
newline|'\n'
name|'if'
name|'libvirt'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'libvirt'
op|'='
name|'__import__'
op|'('
string|"'libvirt'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_host_state'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_initiator'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_fc_wwnns'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_fc_wwpns'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_wrapped_conn'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_wrapped_conn_lock'
op|'='
name|'threading'
op|'.'
name|'Lock'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_caps'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_vcpu_total'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'read_only'
op|'='
name|'read_only'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'='
name|'firewall'
op|'.'
name|'load_driver'
op|'('
nl|'\n'
name|'DEFAULT_FIREWALL_DRIVER'
op|','
nl|'\n'
name|'self'
op|'.'
name|'virtapi'
op|','
nl|'\n'
name|'get_connection'
op|'='
name|'self'
op|'.'
name|'_get_connection'
op|')'
newline|'\n'
nl|'\n'
name|'vif_class'
op|'='
name|'importutils'
op|'.'
name|'import_class'
op|'('
name|'CONF'
op|'.'
name|'libvirt_vif_driver'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'vif_driver'
op|'='
name|'vif_class'
op|'('
name|'self'
op|'.'
name|'_get_connection'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'volume_drivers'
op|'='
name|'driver'
op|'.'
name|'driver_dict_from_config'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt_volume_drivers'
op|','
name|'self'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'dev_filter'
op|'='
name|'pci_whitelist'
op|'.'
name|'get_pci_devices_filter'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_event_queue'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_disk_cachemode'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'image_cache_manager'
op|'='
name|'imagecache'
op|'.'
name|'ImageCacheManager'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'image_backend'
op|'='
name|'imagebackend'
op|'.'
name|'Backend'
op|'('
name|'CONF'
op|'.'
name|'use_cow_images'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'disk_cachemodes'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'valid_cachemodes'
op|'='
op|'['
string|'"default"'
op|','
nl|'\n'
string|'"none"'
op|','
nl|'\n'
string|'"writethrough"'
op|','
nl|'\n'
string|'"writeback"'
op|','
nl|'\n'
string|'"directsync"'
op|','
nl|'\n'
string|'"unsafe"'
op|','
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'mode_str'
name|'in'
name|'CONF'
op|'.'
name|'disk_cachemodes'
op|':'
newline|'\n'
indent|'            '
name|'disk_type'
op|','
name|'sep'
op|','
name|'cache_mode'
op|'='
name|'mode_str'
op|'.'
name|'partition'
op|'('
string|"'='"
op|')'
newline|'\n'
name|'if'
name|'cache_mode'
name|'not'
name|'in'
name|'self'
op|'.'
name|'valid_cachemodes'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|"'Invalid cachemode %(cache_mode)s specified '"
nl|'\n'
string|"'for disk type %(disk_type)s.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'cache_mode'"
op|':'
name|'cache_mode'
op|','
string|"'disk_type'"
op|':'
name|'disk_type'
op|'}'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'disk_cachemodes'
op|'['
name|'disk_type'
op|']'
op|'='
name|'cache_mode'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_volume_api'
op|'='
name|'volume'
op|'.'
name|'API'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|disk_cachemode
name|'def'
name|'disk_cachemode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_disk_cachemode'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|"# We prefer 'none' for consistent performance, host crash"
nl|'\n'
comment|'# safety & migration correctness by avoiding host page cache.'
nl|'\n'
comment|"# Some filesystems (eg GlusterFS via FUSE) don't support"
nl|'\n'
comment|"# O_DIRECT though. For those we fallback to 'writethrough'"
nl|'\n'
comment|'# which gives host crash safety, and is safe for migration'
nl|'\n'
comment|'# provided the filesystem is cache coherent (cluster filesystems'
nl|'\n'
comment|'# typically are, but things like NFS are not).'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_disk_cachemode'
op|'='
string|'"none"'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_supports_direct_io'
op|'('
name|'CONF'
op|'.'
name|'instances_path'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_disk_cachemode'
op|'='
string|'"writethrough"'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'_disk_cachemode'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|host_state
name|'def'
name|'host_state'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'self'
op|'.'
name|'_host_state'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_host_state'
op|'='
name|'HostState'
op|'('
name|'self'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_host_state'
newline|'\n'
nl|'\n'
DECL|member|set_cache_mode
dedent|''
name|'def'
name|'set_cache_mode'
op|'('
name|'self'
op|','
name|'conf'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Set cache mode on LibvirtConfigGuestDisk object."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'source_type'
op|'='
name|'conf'
op|'.'
name|'source_type'
newline|'\n'
name|'driver_cache'
op|'='
name|'conf'
op|'.'
name|'driver_cache'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'cache_mode'
op|'='
name|'self'
op|'.'
name|'disk_cachemodes'
op|'.'
name|'get'
op|'('
name|'source_type'
op|','
nl|'\n'
name|'driver_cache'
op|')'
newline|'\n'
name|'conf'
op|'.'
name|'driver_cache'
op|'='
name|'cache_mode'
newline|'\n'
nl|'\n'
DECL|member|has_min_version
dedent|''
name|'def'
name|'has_min_version'
op|'('
name|'self'
op|','
name|'lv_ver'
op|'='
name|'None'
op|','
name|'hv_ver'
op|'='
name|'None'
op|','
name|'hv_type'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'lv_ver'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'libvirt_version'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'getLibVersion'
op|'('
op|')'
newline|'\n'
name|'if'
name|'libvirt_version'
op|'<'
name|'utils'
op|'.'
name|'convert_version_to_int'
op|'('
name|'lv_ver'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'hv_ver'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'hypervisor_version'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'getVersion'
op|'('
op|')'
newline|'\n'
name|'if'
name|'hypervisor_version'
op|'<'
name|'utils'
op|'.'
name|'convert_version_to_int'
op|'('
name|'hv_ver'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'hv_type'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'hypervisor_type'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'getType'
op|'('
op|')'
newline|'\n'
name|'if'
name|'hypervisor_type'
op|'!='
name|'hv_type'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|_native_thread
dedent|''
dedent|''
name|'def'
name|'_native_thread'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Receives async events coming in from libvirtd.\n\n        This is a native thread which runs the default\n        libvirt event loop implementation. This processes\n        any incoming async events from libvirtd and queues\n        them for later dispatch. This thread is only\n        permitted to use libvirt python APIs, and the\n        driver.queue_event method. In particular any use\n        of logging is forbidden, since it will confuse\n        eventlet\'s greenthread integration\n        """'
newline|'\n'
nl|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'libvirt'
op|'.'
name|'virEventRunDefaultImpl'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_dispatch_thread
dedent|''
dedent|''
name|'def'
name|'_dispatch_thread'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Dispatches async events coming in from libvirtd.\n\n        This is a green thread which waits for events to\n        arrive from the libvirt event loop thread. This\n        then dispatches the events to the compute manager.\n        """'
newline|'\n'
nl|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_dispatch_events'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_event_lifecycle_callback
name|'def'
name|'_event_lifecycle_callback'
op|'('
name|'conn'
op|','
name|'dom'
op|','
name|'event'
op|','
name|'detail'
op|','
name|'opaque'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Receives lifecycle events from libvirt.\n\n        NB: this method is executing in a native thread, not\n        an eventlet coroutine. It can only invoke other libvirt\n        APIs, or use self.queue_event(). Any use of logging APIs\n        in particular is forbidden.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'='
name|'opaque'
newline|'\n'
nl|'\n'
name|'uuid'
op|'='
name|'dom'
op|'.'
name|'UUIDString'
op|'('
op|')'
newline|'\n'
name|'transition'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'event'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_EVENT_STOPPED'
op|':'
newline|'\n'
indent|'            '
name|'transition'
op|'='
name|'virtevent'
op|'.'
name|'EVENT_LIFECYCLE_STOPPED'
newline|'\n'
dedent|''
name|'elif'
name|'event'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_EVENT_STARTED'
op|':'
newline|'\n'
indent|'            '
name|'transition'
op|'='
name|'virtevent'
op|'.'
name|'EVENT_LIFECYCLE_STARTED'
newline|'\n'
dedent|''
name|'elif'
name|'event'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_EVENT_SUSPENDED'
op|':'
newline|'\n'
indent|'            '
name|'transition'
op|'='
name|'virtevent'
op|'.'
name|'EVENT_LIFECYCLE_PAUSED'
newline|'\n'
dedent|''
name|'elif'
name|'event'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_EVENT_RESUMED'
op|':'
newline|'\n'
indent|'            '
name|'transition'
op|'='
name|'virtevent'
op|'.'
name|'EVENT_LIFECYCLE_RESUMED'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'transition'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_queue_event'
op|'('
name|'virtevent'
op|'.'
name|'LifecycleEvent'
op|'('
name|'uuid'
op|','
name|'transition'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_queue_event
dedent|''
dedent|''
name|'def'
name|'_queue_event'
op|'('
name|'self'
op|','
name|'event'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Puts an event on the queue for dispatch.\n\n        This method is called by the native event thread to\n        put events on the queue for later dispatch by the\n        green thread.\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_event_queue'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Event loop thread is not active, "'
nl|'\n'
string|'"discarding event %s"'
op|')'
op|'%'
name|'event'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
comment|'# Queue the event...'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_event_queue'
op|'.'
name|'put'
op|'('
name|'event'
op|')'
newline|'\n'
nl|'\n'
comment|'# ...then wakeup the green thread to dispatch it'
nl|'\n'
name|'c'
op|'='
string|"' '"
op|'.'
name|'encode'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_notify_send'
op|'.'
name|'write'
op|'('
name|'c'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_notify_send'
op|'.'
name|'flush'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_dispatch_events
dedent|''
name|'def'
name|'_dispatch_events'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Wait for & dispatch events from native thread\n\n        Blocks until native thread indicates some events\n        are ready. Then dispatches all queued events.\n        """'
newline|'\n'
nl|'\n'
comment|'# Wait to be notified that there are some'
nl|'\n'
comment|'# events pending'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'_c'
op|'='
name|'self'
op|'.'
name|'_event_notify_recv'
op|'.'
name|'read'
op|'('
number|'1'
op|')'
newline|'\n'
name|'assert'
name|'_c'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'            '
name|'return'
comment|'# will be raised when pipe is closed'
newline|'\n'
nl|'\n'
comment|'# Process as many events as possible without'
nl|'\n'
comment|'# blocking'
nl|'\n'
dedent|''
name|'while'
name|'not'
name|'self'
op|'.'
name|'_event_queue'
op|'.'
name|'empty'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'event'
op|'='
name|'self'
op|'.'
name|'_event_queue'
op|'.'
name|'get'
op|'('
name|'block'
op|'='
name|'False'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'emit_event'
op|'('
name|'event'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'native_Queue'
op|'.'
name|'Empty'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|_init_events_pipe
dedent|''
dedent|''
dedent|''
name|'def'
name|'_init_events_pipe'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a self-pipe for the native thread to synchronize on.\n\n        This code is taken from the eventlet tpool module, under terms\n        of the Apache License v2.0.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_event_queue'
op|'='
name|'native_Queue'
op|'.'
name|'Queue'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'rpipe'
op|','
name|'wpipe'
op|'='
name|'os'
op|'.'
name|'pipe'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_notify_send'
op|'='
name|'greenio'
op|'.'
name|'GreenPipe'
op|'('
name|'wpipe'
op|','
string|"'wb'"
op|','
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_notify_recv'
op|'='
name|'greenio'
op|'.'
name|'GreenPipe'
op|'('
name|'rpipe'
op|','
string|"'rb'"
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'ImportError'
op|','
name|'NotImplementedError'
op|')'
op|':'
newline|'\n'
comment|'# This is Windows compatibility -- use a socket instead'
nl|'\n'
comment|"#  of a pipe because pipes don't really exist on Windows."
nl|'\n'
indent|'            '
name|'sock'
op|'='
name|'eventlet_util'
op|'.'
name|'__original_socket__'
op|'('
name|'socket'
op|'.'
name|'AF_INET'
op|','
nl|'\n'
name|'socket'
op|'.'
name|'SOCK_STREAM'
op|')'
newline|'\n'
name|'sock'
op|'.'
name|'bind'
op|'('
op|'('
string|"'localhost'"
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'sock'
op|'.'
name|'listen'
op|'('
number|'50'
op|')'
newline|'\n'
name|'csock'
op|'='
name|'eventlet_util'
op|'.'
name|'__original_socket__'
op|'('
name|'socket'
op|'.'
name|'AF_INET'
op|','
nl|'\n'
name|'socket'
op|'.'
name|'SOCK_STREAM'
op|')'
newline|'\n'
name|'csock'
op|'.'
name|'connect'
op|'('
op|'('
string|"'localhost'"
op|','
name|'sock'
op|'.'
name|'getsockname'
op|'('
op|')'
op|'['
number|'1'
op|']'
op|')'
op|')'
newline|'\n'
name|'nsock'
op|','
name|'addr'
op|'='
name|'sock'
op|'.'
name|'accept'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_notify_send'
op|'='
name|'nsock'
op|'.'
name|'makefile'
op|'('
string|"'wb'"
op|','
number|'0'
op|')'
newline|'\n'
name|'gsock'
op|'='
name|'greenio'
op|'.'
name|'GreenSocket'
op|'('
name|'csock'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_notify_recv'
op|'='
name|'gsock'
op|'.'
name|'makefile'
op|'('
string|"'rb'"
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_init_events
dedent|''
dedent|''
name|'def'
name|'_init_events'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Initializes the libvirt events subsystem.\n\n        This requires running a native thread to provide the\n        libvirt event loop integration. This forwards events\n        to a green thread which does the actual dispatching.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_init_events_pipe'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Starting native event thread"'
op|')'
op|')'
newline|'\n'
name|'event_thread'
op|'='
name|'native_threading'
op|'.'
name|'Thread'
op|'('
name|'target'
op|'='
name|'self'
op|'.'
name|'_native_thread'
op|')'
newline|'\n'
name|'event_thread'
op|'.'
name|'setDaemon'
op|'('
name|'True'
op|')'
newline|'\n'
name|'event_thread'
op|'.'
name|'start'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Starting green dispatch thread"'
op|')'
op|')'
newline|'\n'
name|'eventlet'
op|'.'
name|'spawn'
op|'('
name|'self'
op|'.'
name|'_dispatch_thread'
op|')'
newline|'\n'
nl|'\n'
DECL|member|init_host
dedent|''
name|'def'
name|'init_host'
op|'('
name|'self'
op|','
name|'host'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'libvirt'
op|'.'
name|'registerErrorHandler'
op|'('
name|'libvirt_error_handler'
op|','
name|'None'
op|')'
newline|'\n'
name|'libvirt'
op|'.'
name|'virEventRegisterDefaultImpl'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'has_min_version'
op|'('
name|'MIN_LIBVIRT_VERSION'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'major'
op|'='
name|'MIN_LIBVIRT_VERSION'
op|'['
number|'0'
op|']'
newline|'\n'
name|'minor'
op|'='
name|'MIN_LIBVIRT_VERSION'
op|'['
number|'1'
op|']'
newline|'\n'
name|'micro'
op|'='
name|'MIN_LIBVIRT_VERSION'
op|'['
number|'2'
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|"'Nova requires libvirt version '"
nl|'\n'
string|"'%(major)i.%(minor)i.%(micro)i or greater.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'major'"
op|':'
name|'major'
op|','
string|"'minor'"
op|':'
name|'minor'
op|','
string|"'micro'"
op|':'
name|'micro'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_init_events'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_connection
dedent|''
name|'def'
name|'_get_connection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'self'
op|'.'
name|'_wrapped_conn_lock'
op|':'
newline|'\n'
indent|'            '
name|'wrapped_conn'
op|'='
name|'self'
op|'.'
name|'_wrapped_conn'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'wrapped_conn'
name|'or'
name|'not'
name|'self'
op|'.'
name|'_test_connection'
op|'('
name|'wrapped_conn'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Connecting to libvirt: %s'"
op|')'
op|','
name|'self'
op|'.'
name|'uri'
op|'('
op|')'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'CONF'
op|'.'
name|'libvirt_nonblocking'
op|':'
newline|'\n'
indent|'                '
name|'wrapped_conn'
op|'='
name|'self'
op|'.'
name|'_connect'
op|'('
name|'self'
op|'.'
name|'uri'
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'read_only'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'wrapped_conn'
op|'='
name|'tpool'
op|'.'
name|'proxy_call'
op|'('
nl|'\n'
op|'('
name|'libvirt'
op|'.'
name|'virDomain'
op|','
name|'libvirt'
op|'.'
name|'virConnect'
op|')'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_connect'
op|','
name|'self'
op|'.'
name|'uri'
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'read_only'
op|')'
newline|'\n'
dedent|''
name|'with'
name|'self'
op|'.'
name|'_wrapped_conn_lock'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_wrapped_conn'
op|'='
name|'wrapped_conn'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Registering for lifecycle events %s"'
op|')'
op|'%'
nl|'\n'
name|'str'
op|'('
name|'self'
op|')'
op|')'
newline|'\n'
name|'wrapped_conn'
op|'.'
name|'domainEventRegisterAny'
op|'('
nl|'\n'
name|'None'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_EVENT_ID_LIFECYCLE'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_event_lifecycle_callback'
op|','
nl|'\n'
name|'self'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|'"URI %s does not support events"'
op|')'
op|','
nl|'\n'
name|'self'
op|'.'
name|'uri'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'has_min_version'
op|'('
name|'MIN_LIBVIRT_CLOSE_CALLBACK_VERSION'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Registering for connection events: %s"'
op|')'
op|'%'
nl|'\n'
name|'str'
op|'('
name|'self'
op|')'
op|')'
newline|'\n'
name|'wrapped_conn'
op|'.'
name|'registerCloseCallback'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_close_callback'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"URI %s does not support connection events"'
op|')'
op|','
nl|'\n'
name|'self'
op|'.'
name|'uri'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'wrapped_conn'
newline|'\n'
nl|'\n'
DECL|variable|_conn
dedent|''
name|'_conn'
op|'='
name|'property'
op|'('
name|'_get_connection'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_close_callback
name|'def'
name|'_close_callback'
op|'('
name|'self'
op|','
name|'conn'
op|','
name|'reason'
op|','
name|'opaque'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'with'
name|'self'
op|'.'
name|'_wrapped_conn_lock'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'conn'
op|'=='
name|'self'
op|'.'
name|'_wrapped_conn'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"Connection to libvirt lost: %s"'
op|')'
op|'%'
name|'reason'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_wrapped_conn'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_test_connection
name|'def'
name|'_test_connection'
op|'('
name|'conn'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'conn'
op|'.'
name|'getLibVersion'
op|'('
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
name|'e'
op|'.'
name|'get_error_code'
op|'('
op|')'
name|'in'
op|'('
name|'libvirt'
op|'.'
name|'VIR_ERR_SYSTEM_ERROR'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_ERR_INTERNAL_ERROR'
op|')'
name|'and'
nl|'\n'
name|'e'
op|'.'
name|'get_error_domain'
op|'('
op|')'
name|'in'
op|'('
name|'libvirt'
op|'.'
name|'VIR_FROM_REMOTE'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_FROM_RPC'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Connection to libvirt broke'"
op|')'
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|uri
name|'def'
name|'uri'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|"'uml'"
op|':'
newline|'\n'
indent|'            '
name|'uri'
op|'='
name|'CONF'
op|'.'
name|'libvirt_uri'
name|'or'
string|"'uml:///system'"
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|"'xen'"
op|':'
newline|'\n'
indent|'            '
name|'uri'
op|'='
name|'CONF'
op|'.'
name|'libvirt_uri'
name|'or'
string|"'xen:///'"
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|"'lxc'"
op|':'
newline|'\n'
indent|'            '
name|'uri'
op|'='
name|'CONF'
op|'.'
name|'libvirt_uri'
name|'or'
string|"'lxc:///'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'uri'
op|'='
name|'CONF'
op|'.'
name|'libvirt_uri'
name|'or'
string|"'qemu:///system'"
newline|'\n'
dedent|''
name|'return'
name|'uri'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_connect
name|'def'
name|'_connect'
op|'('
name|'uri'
op|','
name|'read_only'
op|')'
op|':'
newline|'\n'
DECL|function|_connect_auth_cb
indent|'        '
name|'def'
name|'_connect_auth_cb'
op|'('
name|'creds'
op|','
name|'opaque'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'len'
op|'('
name|'creds'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'return'
number|'0'
newline|'\n'
dedent|''
name|'LOG'
op|'.'
name|'warning'
op|'('
nl|'\n'
name|'_'
op|'('
string|'"Can not handle authentication request for %d credentials"'
op|')'
nl|'\n'
op|'%'
name|'len'
op|'('
name|'creds'
op|')'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
nl|'\n'
name|'_'
op|'('
string|'"Can not handle authentication request for %d credentials"'
op|')'
nl|'\n'
op|'%'
name|'len'
op|'('
name|'creds'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'auth'
op|'='
op|'['
op|'['
name|'libvirt'
op|'.'
name|'VIR_CRED_AUTHNAME'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_CRED_ECHOPROMPT'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_CRED_REALM'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_CRED_PASSPHRASE'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_CRED_NOECHOPROMPT'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_CRED_EXTERNAL'
op|']'
op|','
nl|'\n'
name|'_connect_auth_cb'
op|','
nl|'\n'
name|'None'
op|']'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'flags'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'read_only'
op|':'
newline|'\n'
indent|'                '
name|'flags'
op|'='
name|'libvirt'
op|'.'
name|'VIR_CONNECT_RO'
newline|'\n'
dedent|''
name|'return'
name|'libvirt'
op|'.'
name|'openAuth'
op|'('
name|'uri'
op|','
name|'auth'
op|','
name|'flags'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_'
op|'('
string|'"Connection to libvirt failed: %s"'
op|')'
op|','
name|'ex'
op|')'
newline|'\n'
name|'payload'
op|'='
name|'dict'
op|'('
name|'ip'
op|'='
name|'LibvirtDriver'
op|'.'
name|'get_host_ip_addr'
op|'('
op|')'
op|','
nl|'\n'
name|'method'
op|'='
string|"'_connect'"
op|','
nl|'\n'
name|'reason'
op|'='
name|'ex'
op|')'
newline|'\n'
name|'notifier'
op|'.'
name|'get_notifier'
op|'('
string|"'compute'"
op|')'
op|'.'
name|'error'
op|'('
nl|'\n'
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
op|','
nl|'\n'
string|"'compute.libvirt.error'"
op|','
name|'payload'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_num_instances
dedent|''
dedent|''
name|'def'
name|'get_num_instances'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Efficient override of base instance_exists method."""'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'numOfDomains'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|instance_exists
dedent|''
name|'def'
name|'instance_exists'
op|'('
name|'self'
op|','
name|'instance_name'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Efficient override of base instance_exists method."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance_name'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'NovaException'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
comment|'# TODO(Shrews): Remove when libvirt Bugzilla bug # 836647 is fixed.'
nl|'\n'
DECL|member|list_instance_ids
dedent|''
dedent|''
name|'def'
name|'list_instance_ids'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'numOfDomains'
op|'('
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'['
op|']'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'listDomainsID'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|list_instances
dedent|''
name|'def'
name|'list_instances'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'names'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'domain_id'
name|'in'
name|'self'
op|'.'
name|'list_instance_ids'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
comment|'# We skip domains with ID 0 (hypervisors).'
nl|'\n'
indent|'                '
name|'if'
name|'domain_id'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'domain'
op|'='
name|'self'
op|'.'
name|'_lookup_by_id'
op|'('
name|'domain_id'
op|')'
newline|'\n'
name|'names'
op|'.'
name|'append'
op|'('
name|'domain'
op|'.'
name|'name'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
comment|'# Ignore deleted instance while listing'
nl|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
comment|'# extend instance list to contain also defined domains'
nl|'\n'
dedent|''
dedent|''
name|'names'
op|'.'
name|'extend'
op|'('
op|'['
name|'vm'
name|'for'
name|'vm'
name|'in'
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'listDefinedDomains'
op|'('
op|')'
nl|'\n'
name|'if'
name|'vm'
name|'not'
name|'in'
name|'names'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'names'
newline|'\n'
nl|'\n'
DECL|member|list_instance_uuids
dedent|''
name|'def'
name|'list_instance_uuids'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'uuids'
op|'='
name|'set'
op|'('
op|')'
newline|'\n'
name|'for'
name|'domain_id'
name|'in'
name|'self'
op|'.'
name|'list_instance_ids'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
comment|'# We skip domains with ID 0 (hypervisors).'
nl|'\n'
indent|'                '
name|'if'
name|'domain_id'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'domain'
op|'='
name|'self'
op|'.'
name|'_lookup_by_id'
op|'('
name|'domain_id'
op|')'
newline|'\n'
name|'uuids'
op|'.'
name|'add'
op|'('
name|'domain'
op|'.'
name|'UUIDString'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
comment|'# Ignore deleted instance while listing'
nl|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
comment|'# extend instance list to contain also defined domains'
nl|'\n'
dedent|''
dedent|''
name|'for'
name|'domain_name'
name|'in'
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'listDefinedDomains'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'uuids'
op|'.'
name|'add'
op|'('
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'domain_name'
op|')'
op|'.'
name|'UUIDString'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
comment|'# Ignore deleted instance while listing'
nl|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'list'
op|'('
name|'uuids'
op|')'
newline|'\n'
nl|'\n'
DECL|member|plug_vifs
dedent|''
name|'def'
name|'plug_vifs'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Plug VIFs into networks."""'
newline|'\n'
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'plug'
op|'('
name|'instance'
op|','
name|'vif'
op|')'
newline|'\n'
nl|'\n'
DECL|member|unplug_vifs
dedent|''
dedent|''
name|'def'
name|'unplug_vifs'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Unplug VIFs from networks."""'
newline|'\n'
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'unplug'
op|'('
name|'instance'
op|','
name|'vif'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_destroy
dedent|''
dedent|''
name|'def'
name|'_destroy'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|"# If the instance is already terminated, we're still happy"
nl|'\n'
comment|'# Otherwise, destroy it'
nl|'\n'
dedent|''
name|'old_domid'
op|'='
op|'-'
number|'1'
newline|'\n'
name|'if'
name|'virt_dom'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'old_domid'
op|'='
name|'virt_dom'
op|'.'
name|'ID'
op|'('
op|')'
newline|'\n'
name|'virt_dom'
op|'.'
name|'destroy'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'is_okay'
op|'='
name|'False'
newline|'\n'
name|'errcode'
op|'='
name|'e'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'errcode'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_OPERATION_INVALID'
op|':'
newline|'\n'
comment|'# If the instance is already shut off, we get this:'
nl|'\n'
comment|'# Code=55 Error=Requested operation is not valid:'
nl|'\n'
comment|'# domain is not running'
nl|'\n'
indent|'                    '
op|'('
name|'state'
op|','
name|'_max_mem'
op|','
name|'_mem'
op|','
name|'_cpus'
op|','
name|'_t'
op|')'
op|'='
name|'virt_dom'
op|'.'
name|'info'
op|'('
op|')'
newline|'\n'
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'state'
op|']'
newline|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|':'
newline|'\n'
indent|'                        '
name|'is_okay'
op|'='
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'errcode'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_OPERATION_TIMEOUT'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|'"Cannot destroy instance, operation time out"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'reason'
op|'='
name|'_'
op|'('
string|'"operation time out"'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstancePowerOffFailure'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'is_okay'
op|':'
newline|'\n'
indent|'                    '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|"'Error from libvirt during destroy. '"
nl|'\n'
string|"'Code=%(errcode)s Error=%(e)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'errcode'"
op|':'
name|'errcode'
op|','
string|"'e'"
op|':'
name|'e'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_wait_for_destroy
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_wait_for_destroy'
op|'('
name|'expected_domid'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Called at an interval until the VM is gone."""'
newline|'\n'
comment|'# NOTE(vish): If the instance disappears during the destroy'
nl|'\n'
comment|'#             we ignore it so the cleanup can still be'
nl|'\n'
comment|'#             attempted because we would prefer destroy to'
nl|'\n'
comment|'#             never fail.'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'dom_info'
op|'='
name|'self'
op|'.'
name|'get_info'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'state'
op|'='
name|'dom_info'
op|'['
string|"'state'"
op|']'
newline|'\n'
name|'new_domid'
op|'='
name|'dom_info'
op|'['
string|"'id'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|'"During wait destroy, instance disappeared."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"Instance destroyed successfully."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(wangpan): If the instance was booted again after destroy,'
nl|'\n'
comment|'#                this may be a endless loop, so check the id of'
nl|'\n'
comment|'#                domain here, if it changed and the instance is'
nl|'\n'
comment|'#                still running, we should destroy it again.'
nl|'\n'
comment|'# see https://bugs.launchpad.net/nova/+bug/1111213 for more details'
nl|'\n'
dedent|''
name|'if'
name|'new_domid'
op|'!='
name|'expected_domid'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"Instance may be started again."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'kwargs'
op|'['
string|"'is_running'"
op|']'
op|'='
name|'True'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'kwargs'
op|'='
op|'{'
string|"'is_running'"
op|':'
name|'False'
op|'}'
newline|'\n'
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
name|'_wait_for_destroy'
op|','
nl|'\n'
name|'old_domid'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
name|'if'
name|'kwargs'
op|'['
string|"'is_running'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"Going to destroy instance again."'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|destroy
dedent|''
dedent|''
name|'def'
name|'destroy'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|'='
name|'None'
op|','
nl|'\n'
name|'destroy_disks'
op|'='
name|'True'
op|','
name|'context'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_cleanup'
op|'('
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|','
nl|'\n'
name|'destroy_disks'
op|','
name|'context'
op|'='
name|'context'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_undefine_domain
dedent|''
name|'def'
name|'_undefine_domain'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'if'
name|'virt_dom'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'virt_dom'
op|'.'
name|'undefineFlags'
op|'('
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_UNDEFINE_MANAGED_SAVE'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Error from libvirt during undefineFlags."'
nl|'\n'
string|'" Retrying with undefine"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'virt_dom'
op|'.'
name|'undefine'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
comment|"# NOTE(vish): Older versions of libvirt don't support"
nl|'\n'
comment|'#             undefine flags, so attempt to do the'
nl|'\n'
comment|'#             right thing.'
nl|'\n'
indent|'                    '
name|'try'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'virt_dom'
op|'.'
name|'hasManagedSaveImage'
op|'('
number|'0'
op|')'
op|':'
newline|'\n'
indent|'                            '
name|'virt_dom'
op|'.'
name|'managedSaveRemove'
op|'('
number|'0'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'                        '
name|'pass'
newline|'\n'
dedent|''
name|'virt_dom'
op|'.'
name|'undefine'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'errcode'
op|'='
name|'e'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|"'Error from libvirt during undefine. '"
nl|'\n'
string|"'Code=%(errcode)s Error=%(e)s'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'errcode'"
op|':'
name|'errcode'
op|','
string|"'e'"
op|':'
name|'e'
op|'}'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_cleanup
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_cleanup'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|','
nl|'\n'
name|'destroy_disks'
op|','
name|'context'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_undefine_domain'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'unplug_vifs'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'retry'
op|'='
name|'True'
newline|'\n'
name|'while'
name|'retry'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'unfilter_instance'
op|'('
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|'='
name|'network_info'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'state'
op|'='
name|'self'
op|'.'
name|'get_info'
op|'('
name|'instance'
op|')'
op|'['
string|"'state'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'                    '
name|'state'
op|'='
name|'power_state'
op|'.'
name|'SHUTDOWN'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'state'
op|'!='
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|'"Instance may be still running, destroy "'
nl|'\n'
string|'"it again."'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'retry'
op|'='
name|'False'
newline|'\n'
name|'errcode'
op|'='
name|'e'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|"'Error from libvirt during unfilter. '"
nl|'\n'
string|"'Code=%(errcode)s Error=%(e)s'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'errcode'"
op|':'
name|'errcode'
op|','
string|"'e'"
op|':'
name|'e'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'reason'
op|'='
string|'"Error unfiltering instance."'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstanceTerminationFailure'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'retry'
op|'='
name|'False'
newline|'\n'
name|'raise'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'retry'
op|'='
name|'False'
newline|'\n'
nl|'\n'
comment|'# FIXME(wangpan): if the instance is booted again here, such as the'
nl|'\n'
comment|'#                 the soft reboot operation boot it here, it will'
nl|'\n'
comment|'#                 become "running deleted", should we check and destroy'
nl|'\n'
comment|'#                 it at the end of this method?'
nl|'\n'
nl|'\n'
comment|'# NOTE(vish): we disconnect from volumes regardless'
nl|'\n'
dedent|''
dedent|''
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'for'
name|'vol'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'            '
name|'connection_info'
op|'='
name|'vol'
op|'['
string|"'connection_info'"
op|']'
newline|'\n'
name|'disk_dev'
op|'='
name|'vol'
op|'['
string|"'mount_device'"
op|']'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
nl|'\n'
name|'if'
op|'('
string|"'data'"
name|'in'
name|'connection_info'
name|'and'
nl|'\n'
string|"'volume_id'"
name|'in'
name|'connection_info'
op|'['
string|"'data'"
op|']'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'volume_id'
op|'='
name|'connection_info'
op|'['
string|"'data'"
op|']'
op|'['
string|"'volume_id'"
op|']'
newline|'\n'
name|'encryption'
op|'='
name|'encryptors'
op|'.'
name|'get_encryption_metadata'
op|'('
name|'context'
op|','
name|'volume_id'
op|','
nl|'\n'
name|'connection_info'
op|')'
newline|'\n'
name|'if'
name|'encryption'
op|':'
newline|'\n'
comment|'# The volume must be detached from the VM before'
nl|'\n'
comment|'# disconnecting it from its encryptor. Otherwise, the'
nl|'\n'
comment|'# encryptor may report that the volume is still in use.'
nl|'\n'
indent|'                    '
name|'encryptor'
op|'='
name|'self'
op|'.'
name|'_get_volume_encryptor'
op|'('
name|'connection_info'
op|','
nl|'\n'
name|'encryption'
op|')'
newline|'\n'
name|'encryptor'
op|'.'
name|'detach_volume'
op|'('
op|'**'
name|'encryption'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'volume_driver_method'
op|'('
string|"'disconnect_volume'"
op|','
nl|'\n'
name|'connection_info'
op|','
nl|'\n'
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'destroy_disks'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_delete_instance_files'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_cleanup_lvm'
op|'('
name|'instance'
op|')'
newline|'\n'
comment|'#NOTE(haomai): destroy volumes if needed'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt_images_type'
op|'=='
string|"'rbd'"
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_cleanup_rbd'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_cleanup_rbd
dedent|''
dedent|''
dedent|''
name|'def'
name|'_cleanup_rbd'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pool'
op|'='
name|'CONF'
op|'.'
name|'libvirt_images_rbd_pool'
newline|'\n'
name|'volumes'
op|'='
name|'libvirt_utils'
op|'.'
name|'list_rbd_volumes'
op|'('
name|'pool'
op|')'
newline|'\n'
name|'pattern'
op|'='
name|'instance'
op|'['
string|"'name'"
op|']'
newline|'\n'
nl|'\n'
DECL|function|belongs_to_instance
name|'def'
name|'belongs_to_instance'
op|'('
name|'disk'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'disk'
op|'.'
name|'startswith'
op|'('
name|'pattern'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'volumes'
op|'='
name|'filter'
op|'('
name|'belongs_to_instance'
op|','
name|'volumes'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'volumes'
op|':'
newline|'\n'
indent|'            '
name|'libvirt_utils'
op|'.'
name|'remove_rbd_volumes'
op|'('
name|'pool'
op|','
op|'*'
name|'volumes'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_cleanup_lvm
dedent|''
dedent|''
name|'def'
name|'_cleanup_lvm'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Delete all LVM disks for given instance object."""'
newline|'\n'
name|'disks'
op|'='
name|'self'
op|'.'
name|'_lvm_disks'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'disks'
op|':'
newline|'\n'
indent|'            '
name|'libvirt_utils'
op|'.'
name|'remove_logical_volumes'
op|'('
op|'*'
name|'disks'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_lvm_disks
dedent|''
dedent|''
name|'def'
name|'_lvm_disks'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns all LVM disks for given instance object."""'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt_images_volume_group'
op|':'
newline|'\n'
indent|'            '
name|'vg'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
string|"'/dev'"
op|','
name|'CONF'
op|'.'
name|'libvirt_images_volume_group'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'vg'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
op|'['
op|']'
newline|'\n'
dedent|''
name|'pattern'
op|'='
string|"'%s_'"
op|'%'
name|'instance'
op|'['
string|"'name'"
op|']'
newline|'\n'
nl|'\n'
DECL|function|belongs_to_instance
name|'def'
name|'belongs_to_instance'
op|'('
name|'disk'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'disk'
op|'.'
name|'startswith'
op|'('
name|'pattern'
op|')'
newline|'\n'
nl|'\n'
DECL|function|fullpath
dedent|''
name|'def'
name|'fullpath'
op|'('
name|'name'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'vg'
op|','
name|'name'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'logical_volumes'
op|'='
name|'libvirt_utils'
op|'.'
name|'list_logical_volumes'
op|'('
name|'vg'
op|')'
newline|'\n'
nl|'\n'
name|'disk_names'
op|'='
name|'filter'
op|'('
name|'belongs_to_instance'
op|','
name|'logical_volumes'
op|')'
newline|'\n'
name|'disks'
op|'='
name|'map'
op|'('
name|'fullpath'
op|','
name|'disk_names'
op|')'
newline|'\n'
name|'return'
name|'disks'
newline|'\n'
dedent|''
name|'return'
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|get_volume_connector
dedent|''
name|'def'
name|'get_volume_connector'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'self'
op|'.'
name|'_initiator'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_initiator'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_iscsi_initiator'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_initiator'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Could not determine iscsi initiator name'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'_fc_wwnns'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_fc_wwnns'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_fc_wwnns'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_fc_wwnns'
name|'or'
name|'len'
op|'('
name|'self'
op|'.'
name|'_fc_wwnns'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Could not determine fibre channel '"
nl|'\n'
string|"'world wide node names'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'_fc_wwpns'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_fc_wwpns'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_fc_wwpns'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_fc_wwpns'
name|'or'
name|'len'
op|'('
name|'self'
op|'.'
name|'_fc_wwpns'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Could not determine fibre channel '"
nl|'\n'
string|"'world wide port names'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'connector'
op|'='
op|'{'
string|"'ip'"
op|':'
name|'CONF'
op|'.'
name|'my_ip'
op|','
nl|'\n'
string|"'host'"
op|':'
name|'CONF'
op|'.'
name|'host'
op|'}'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_initiator'
op|':'
newline|'\n'
indent|'            '
name|'connector'
op|'['
string|"'initiator'"
op|']'
op|'='
name|'self'
op|'.'
name|'_initiator'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_fc_wwnns'
name|'and'
name|'self'
op|'.'
name|'_fc_wwpns'
op|':'
newline|'\n'
indent|'            '
name|'connector'
op|'['
string|'"wwnns"'
op|']'
op|'='
name|'self'
op|'.'
name|'_fc_wwnns'
newline|'\n'
name|'connector'
op|'['
string|'"wwpns"'
op|']'
op|'='
name|'self'
op|'.'
name|'_fc_wwpns'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'connector'
newline|'\n'
nl|'\n'
DECL|member|_cleanup_resize
dedent|''
name|'def'
name|'_cleanup_resize'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'target'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
op|'+'
string|'"_resize"'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'target'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'shutil'
op|'.'
name|'rmtree'
op|'('
name|'target'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'instance'
op|'['
string|"'host'"
op|']'
op|'!='
name|'CONF'
op|'.'
name|'host'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_undefine_domain'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'unplug_vifs'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'unfilter_instance'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|volume_driver_method
dedent|''
dedent|''
name|'def'
name|'volume_driver_method'
op|'('
name|'self'
op|','
name|'method_name'
op|','
name|'connection_info'
op|','
nl|'\n'
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'driver_type'
op|'='
name|'connection_info'
op|'.'
name|'get'
op|'('
string|"'driver_volume_type'"
op|')'
newline|'\n'
name|'if'
name|'driver_type'
name|'not'
name|'in'
name|'self'
op|'.'
name|'volume_drivers'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'VolumeDriverNotFound'
op|'('
name|'driver_type'
op|'='
name|'driver_type'
op|')'
newline|'\n'
dedent|''
name|'driver'
op|'='
name|'self'
op|'.'
name|'volume_drivers'
op|'['
name|'driver_type'
op|']'
newline|'\n'
name|'method'
op|'='
name|'getattr'
op|'('
name|'driver'
op|','
name|'method_name'
op|')'
newline|'\n'
name|'return'
name|'method'
op|'('
name|'connection_info'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_volume_encryptor
dedent|''
name|'def'
name|'_get_volume_encryptor'
op|'('
name|'self'
op|','
name|'connection_info'
op|','
name|'encryption'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'encryptor'
op|'='
name|'encryptors'
op|'.'
name|'get_volume_encryptor'
op|'('
name|'connection_info'
op|','
nl|'\n'
op|'**'
name|'encryption'
op|')'
newline|'\n'
name|'return'
name|'encryptor'
newline|'\n'
nl|'\n'
DECL|member|attach_volume
dedent|''
name|'def'
name|'attach_volume'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'connection_info'
op|','
name|'instance'
op|','
name|'mountpoint'
op|','
nl|'\n'
name|'encryption'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'instance_name'
op|'='
name|'instance'
op|'['
string|"'name'"
op|']'
newline|'\n'
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance_name'
op|')'
newline|'\n'
name|'disk_dev'
op|'='
name|'mountpoint'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'disk_info'
op|'='
op|'{'
nl|'\n'
string|"'dev'"
op|':'
name|'disk_dev'
op|','
nl|'\n'
string|"'bus'"
op|':'
name|'blockinfo'
op|'.'
name|'get_disk_bus_for_disk_dev'
op|'('
name|'CONF'
op|'.'
name|'libvirt_type'
op|','
nl|'\n'
name|'disk_dev'
op|')'
op|','
nl|'\n'
string|"'type'"
op|':'
string|"'disk'"
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
comment|'# Note(cfb): If the volume has a custom block size, check that'
nl|'\n'
comment|'#            that we are using QEMU/KVM and libvirt >= 0.10.2. The'
nl|'\n'
comment|'#            presence of a block size is considered mandatory by'
nl|'\n'
comment|"#            cinder so we fail if we can't honor the request."
nl|'\n'
name|'data'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'if'
op|'('
string|"'data'"
name|'in'
name|'connection_info'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'data'
op|'='
name|'connection_info'
op|'['
string|"'data'"
op|']'
newline|'\n'
dedent|''
name|'if'
op|'('
string|"'logical_block_size'"
name|'in'
name|'data'
name|'or'
string|"'physical_block_size'"
name|'in'
name|'data'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'!='
string|'"kvm"'
name|'and'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'!='
string|'"qemu"'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
name|'_'
op|'('
string|'"Volume sets block size, but the current "'
nl|'\n'
string|'"libvirt hypervisor \'%s\' does not support custom "'
nl|'\n'
string|'"block size"'
op|')'
op|'%'
name|'CONF'
op|'.'
name|'libvirt_type'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InvalidHypervisorType'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'has_min_version'
op|'('
name|'MIN_LIBVIRT_BLOCKIO_VERSION'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'ver'
op|'='
string|'"."'
op|'.'
name|'join'
op|'('
op|'['
name|'str'
op|'('
name|'x'
op|')'
name|'for'
name|'x'
name|'in'
name|'MIN_LIBVIRT_BLOCKIO_VERSION'
op|']'
op|')'
newline|'\n'
name|'msg'
op|'='
name|'_'
op|'('
string|'"Volume sets block size, but libvirt \'%s\' or later is "'
nl|'\n'
string|'"required."'
op|')'
op|'%'
name|'ver'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'conf'
op|'='
name|'self'
op|'.'
name|'volume_driver_method'
op|'('
string|"'connect_volume'"
op|','
nl|'\n'
name|'connection_info'
op|','
nl|'\n'
name|'disk_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'set_cache_mode'
op|'('
name|'conf'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# NOTE(vish): We can always affect config because our'
nl|'\n'
comment|'#             domains are persistent, but we should only'
nl|'\n'
comment|'#             affect live if the domain is running.'
nl|'\n'
indent|'            '
name|'flags'
op|'='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_AFFECT_CONFIG'
newline|'\n'
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'virt_dom'
op|'.'
name|'info'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|']'
newline|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
indent|'                '
name|'flags'
op|'|='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_AFFECT_LIVE'
newline|'\n'
nl|'\n'
comment|'# cache device_path in connection_info -- required by encryptors'
nl|'\n'
dedent|''
name|'if'
string|"'data'"
name|'in'
name|'connection_info'
op|':'
newline|'\n'
indent|'                '
name|'connection_info'
op|'['
string|"'data'"
op|']'
op|'['
string|"'device_path'"
op|']'
op|'='
name|'conf'
op|'.'
name|'source_path'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'encryption'
op|':'
newline|'\n'
indent|'                '
name|'encryptor'
op|'='
name|'self'
op|'.'
name|'_get_volume_encryptor'
op|'('
name|'connection_info'
op|','
nl|'\n'
name|'encryption'
op|')'
newline|'\n'
name|'encryptor'
op|'.'
name|'attach_volume'
op|'('
name|'context'
op|','
op|'**'
name|'encryption'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'virt_dom'
op|'.'
name|'attachDeviceFlags'
op|'('
name|'conf'
op|'.'
name|'to_xml'
op|'('
op|')'
op|','
name|'flags'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'isinstance'
op|'('
name|'ex'
op|','
name|'libvirt'
op|'.'
name|'libvirtError'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'errcode'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'errcode'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_OPERATION_FAILED'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'volume_driver_method'
op|'('
string|"'disconnect_volume'"
op|','
nl|'\n'
name|'connection_info'
op|','
nl|'\n'
name|'disk_dev'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'DeviceIsBusy'
op|'('
name|'device'
op|'='
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'volume_driver_method'
op|'('
string|"'disconnect_volume'"
op|','
nl|'\n'
name|'connection_info'
op|','
nl|'\n'
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_swap_volume
dedent|''
dedent|''
dedent|''
name|'def'
name|'_swap_volume'
op|'('
name|'self'
op|','
name|'domain'
op|','
name|'disk_path'
op|','
name|'new_path'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Swap existing disk with a new block device."""'
newline|'\n'
comment|"# Save a copy of the domain's running XML file"
nl|'\n'
name|'xml'
op|'='
name|'domain'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
nl|'\n'
comment|'# Abort is an idempotent operation, so make sure any block'
nl|'\n'
comment|'# jobs which may have failed are ended.'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'domain'
op|'.'
name|'blockJobAbort'
op|'('
name|'disk_path'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
comment|'# NOTE (rmk): blockRebase cannot be executed on persistent'
nl|'\n'
comment|'#             domains, so we need to temporarily undefine it.'
nl|'\n'
comment|'#             If any part of this block fails, the domain is'
nl|'\n'
comment|'#             re-defined regardless.'
nl|'\n'
indent|'            '
name|'if'
name|'domain'
op|'.'
name|'isPersistent'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'domain'
op|'.'
name|'undefine'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Start copy with VIR_DOMAIN_REBASE_REUSE_EXT flag to'
nl|'\n'
comment|'# allow writing to existing external volume file'
nl|'\n'
dedent|''
name|'domain'
op|'.'
name|'blockRebase'
op|'('
name|'disk_path'
op|','
name|'new_path'
op|','
number|'0'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_BLOCK_REBASE_COPY'
op|'|'
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT'
op|')'
newline|'\n'
nl|'\n'
name|'while'
name|'self'
op|'.'
name|'_wait_for_block_job'
op|'('
name|'domain'
op|','
name|'disk_path'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'time'
op|'.'
name|'sleep'
op|'('
number|'0.5'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'domain'
op|'.'
name|'blockJobAbort'
op|'('
name|'disk_path'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'defineXML'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
DECL|member|swap_volume
dedent|''
dedent|''
name|'def'
name|'swap_volume'
op|'('
name|'self'
op|','
name|'old_connection_info'
op|','
nl|'\n'
name|'new_connection_info'
op|','
name|'instance'
op|','
name|'mountpoint'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'instance_name'
op|'='
name|'instance'
op|'['
string|"'name'"
op|']'
newline|'\n'
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance_name'
op|')'
newline|'\n'
name|'disk_dev'
op|'='
name|'mountpoint'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_disk_xml'
op|'('
name|'virt_dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
op|','
name|'disk_dev'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'xml'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'DiskNotFound'
op|'('
name|'location'
op|'='
name|'disk_dev'
op|')'
newline|'\n'
dedent|''
name|'disk_info'
op|'='
op|'{'
nl|'\n'
string|"'dev'"
op|':'
name|'disk_dev'
op|','
nl|'\n'
string|"'bus'"
op|':'
name|'blockinfo'
op|'.'
name|'get_disk_bus_for_disk_dev'
op|'('
name|'CONF'
op|'.'
name|'libvirt_type'
op|','
nl|'\n'
name|'disk_dev'
op|')'
op|','
nl|'\n'
string|"'type'"
op|':'
string|"'disk'"
op|','
nl|'\n'
op|'}'
newline|'\n'
name|'conf'
op|'='
name|'self'
op|'.'
name|'volume_driver_method'
op|'('
string|"'connect_volume'"
op|','
nl|'\n'
name|'new_connection_info'
op|','
nl|'\n'
name|'disk_info'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'conf'
op|'.'
name|'source_path'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'volume_driver_method'
op|'('
string|"'disconnect_volume'"
op|','
nl|'\n'
name|'new_connection_info'
op|','
nl|'\n'
name|'disk_dev'
op|')'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
name|'_'
op|'('
string|'"Swap only supports host devices"'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_swap_volume'
op|'('
name|'virt_dom'
op|','
name|'disk_dev'
op|','
name|'conf'
op|'.'
name|'source_path'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'volume_driver_method'
op|'('
string|"'disconnect_volume'"
op|','
nl|'\n'
name|'old_connection_info'
op|','
nl|'\n'
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_get_disk_xml
name|'def'
name|'_get_disk_xml'
op|'('
name|'xml'
op|','
name|'device'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns the xml for the disk mounted at device."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'ret'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
string|"'./devices/disk'"
op|')'
newline|'\n'
name|'for'
name|'node'
name|'in'
name|'ret'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'child'
name|'in'
name|'node'
op|'.'
name|'getchildren'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'child'
op|'.'
name|'tag'
op|'=='
string|"'target'"
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'child'
op|'.'
name|'get'
op|'('
string|"'dev'"
op|')'
op|'=='
name|'device'
op|':'
newline|'\n'
indent|'                        '
name|'return'
name|'etree'
op|'.'
name|'tostring'
op|'('
name|'node'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_existing_domain_xml
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_get_existing_domain_xml'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'virt_dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
name|'CONF'
op|'.'
name|'libvirt_type'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'to_xml'
op|'('
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
op|','
nl|'\n'
name|'instance'
op|','
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'xml'
newline|'\n'
nl|'\n'
DECL|member|detach_volume
dedent|''
name|'def'
name|'detach_volume'
op|'('
name|'self'
op|','
name|'connection_info'
op|','
name|'instance'
op|','
name|'mountpoint'
op|','
nl|'\n'
name|'encryption'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'instance_name'
op|'='
name|'instance'
op|'['
string|"'name'"
op|']'
newline|'\n'
name|'disk_dev'
op|'='
name|'mountpoint'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance_name'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_disk_xml'
op|'('
name|'virt_dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
op|','
name|'disk_dev'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'xml'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'DiskNotFound'
op|'('
name|'location'
op|'='
name|'disk_dev'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# NOTE(vish): We can always affect config because our'
nl|'\n'
comment|'#             domains are persistent, but we should only'
nl|'\n'
comment|'#             affect live if the domain is running.'
nl|'\n'
indent|'                '
name|'flags'
op|'='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_AFFECT_CONFIG'
newline|'\n'
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'virt_dom'
op|'.'
name|'info'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|']'
newline|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
indent|'                    '
name|'flags'
op|'|='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_AFFECT_LIVE'
newline|'\n'
dedent|''
name|'virt_dom'
op|'.'
name|'detachDeviceFlags'
op|'('
name|'xml'
op|','
name|'flags'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'encryption'
op|':'
newline|'\n'
comment|'# The volume must be detached from the VM before'
nl|'\n'
comment|'# disconnecting it from its encryptor. Otherwise, the'
nl|'\n'
comment|'# encryptor may report that the volume is still in use.'
nl|'\n'
indent|'                    '
name|'encryptor'
op|'='
name|'self'
op|'.'
name|'_get_volume_encryptor'
op|'('
name|'connection_info'
op|','
nl|'\n'
name|'encryption'
op|')'
newline|'\n'
name|'encryptor'
op|'.'
name|'detach_volume'
op|'('
op|'**'
name|'encryption'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
comment|'# NOTE(vish): This is called to cleanup volumes after live'
nl|'\n'
comment|'#             migration, so we should still disconnect even if'
nl|'\n'
comment|"#             the instance doesn't exist here anymore."
nl|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_DOMAIN'
op|':'
newline|'\n'
comment|'# NOTE(vish):'
nl|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|'"During detach_volume, instance disappeared."'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'volume_driver_method'
op|'('
string|"'disconnect_volume'"
op|','
nl|'\n'
name|'connection_info'
op|','
nl|'\n'
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
DECL|member|attach_interface
dedent|''
name|'def'
name|'attach_interface'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'vif'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'inst_type'
op|'='
name|'self'
op|'.'
name|'virtapi'
op|'.'
name|'instance_type_get'
op|'('
nl|'\n'
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
name|'read_deleted'
op|'='
string|"'yes'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'instance_type_id'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'plug'
op|'('
name|'instance'
op|','
name|'vif'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'setup_basic_filtering'
op|'('
name|'instance'
op|','
op|'['
name|'vif'
op|']'
op|')'
newline|'\n'
name|'cfg'
op|'='
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'get_config'
op|'('
name|'instance'
op|','
name|'vif'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'inst_type'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'flags'
op|'='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_AFFECT_CONFIG'
newline|'\n'
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'virt_dom'
op|'.'
name|'info'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|']'
newline|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
indent|'                '
name|'flags'
op|'|='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_AFFECT_LIVE'
newline|'\n'
dedent|''
name|'virt_dom'
op|'.'
name|'attachDeviceFlags'
op|'('
name|'cfg'
op|'.'
name|'to_xml'
op|'('
op|')'
op|','
name|'flags'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|"'attaching network adapter failed.'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'unplug'
op|'('
name|'instance'
op|','
name|'vif'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InterfaceAttachFailed'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|detach_interface
dedent|''
dedent|''
name|'def'
name|'detach_interface'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'vif'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'inst_type'
op|'='
name|'self'
op|'.'
name|'virtapi'
op|'.'
name|'instance_type_get'
op|'('
nl|'\n'
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
name|'read_deleted'
op|'='
string|"'yes'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'instance_type_id'"
op|']'
op|')'
newline|'\n'
name|'cfg'
op|'='
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'get_config'
op|'('
name|'instance'
op|','
name|'vif'
op|','
name|'None'
op|','
name|'inst_type'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'unplug'
op|'('
name|'instance'
op|','
name|'vif'
op|')'
newline|'\n'
name|'flags'
op|'='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_AFFECT_CONFIG'
newline|'\n'
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'virt_dom'
op|'.'
name|'info'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|']'
newline|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
indent|'                '
name|'flags'
op|'|='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_AFFECT_LIVE'
newline|'\n'
dedent|''
name|'virt_dom'
op|'.'
name|'detachDeviceFlags'
op|'('
name|'cfg'
op|'.'
name|'to_xml'
op|'('
op|')'
op|','
name|'flags'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_DOMAIN'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|'"During detach_interface, "'
nl|'\n'
string|'"instance disappeared."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|"'detaching network adapter failed.'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InterfaceDetachFailed'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|snapshot
dedent|''
dedent|''
dedent|''
name|'def'
name|'snapshot'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'image_href'
op|','
name|'update_task_state'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create snapshot from a running VM instance.\n\n        This command only works with qemu 0.14+\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotRunning'
op|'('
name|'instance_id'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'('
name|'image_service'
op|','
name|'image_id'
op|')'
op|'='
name|'glance'
op|'.'
name|'get_remote_image_service'
op|'('
nl|'\n'
name|'context'
op|','
name|'instance'
op|'['
string|"'image_ref'"
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'base'
op|'='
name|'compute_utils'
op|'.'
name|'get_image_metadata'
op|'('
nl|'\n'
name|'context'
op|','
name|'image_service'
op|','
name|'image_id'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'_image_service'
op|'='
name|'glance'
op|'.'
name|'get_remote_image_service'
op|'('
name|'context'
op|','
name|'image_href'
op|')'
newline|'\n'
name|'snapshot_image_service'
op|','
name|'snapshot_image_id'
op|'='
name|'_image_service'
newline|'\n'
name|'snapshot'
op|'='
name|'snapshot_image_service'
op|'.'
name|'show'
op|'('
name|'context'
op|','
name|'snapshot_image_id'
op|')'
newline|'\n'
nl|'\n'
name|'metadata'
op|'='
op|'{'
string|"'is_public'"
op|':'
name|'False'
op|','
nl|'\n'
string|"'status'"
op|':'
string|"'active'"
op|','
nl|'\n'
string|"'name'"
op|':'
name|'snapshot'
op|'['
string|"'name'"
op|']'
op|','
nl|'\n'
string|"'properties'"
op|':'
op|'{'
nl|'\n'
string|"'kernel_id'"
op|':'
name|'instance'
op|'['
string|"'kernel_id'"
op|']'
op|','
nl|'\n'
string|"'image_location'"
op|':'
string|"'snapshot'"
op|','
nl|'\n'
string|"'image_state'"
op|':'
string|"'available'"
op|','
nl|'\n'
string|"'owner_id'"
op|':'
name|'instance'
op|'['
string|"'project_id'"
op|']'
op|','
nl|'\n'
string|"'ramdisk_id'"
op|':'
name|'instance'
op|'['
string|"'ramdisk_id'"
op|']'
op|','
nl|'\n'
string|"'os_type'"
op|':'
name|'instance'
op|'['
string|"'os_type'"
op|']'
op|','
nl|'\n'
op|'}'
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
name|'disk_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'find_disk'
op|'('
name|'virt_dom'
op|')'
newline|'\n'
name|'source_format'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_disk_type'
op|'('
name|'disk_path'
op|')'
newline|'\n'
nl|'\n'
name|'image_format'
op|'='
name|'CONF'
op|'.'
name|'snapshot_image_format'
name|'or'
name|'source_format'
newline|'\n'
nl|'\n'
comment|'# NOTE(bfilippov): save lvm and rbd as raw'
nl|'\n'
name|'if'
name|'image_format'
op|'=='
string|"'lvm'"
name|'or'
name|'image_format'
op|'=='
string|"'rbd'"
op|':'
newline|'\n'
indent|'            '
name|'image_format'
op|'='
string|"'raw'"
newline|'\n'
nl|'\n'
comment|'# NOTE(vish): glance forces ami disk format to be ami'
nl|'\n'
dedent|''
name|'if'
name|'base'
op|'.'
name|'get'
op|'('
string|"'disk_format'"
op|')'
op|'=='
string|"'ami'"
op|':'
newline|'\n'
indent|'            '
name|'metadata'
op|'['
string|"'disk_format'"
op|']'
op|'='
string|"'ami'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'metadata'
op|'['
string|"'disk_format'"
op|']'
op|'='
name|'image_format'
newline|'\n'
nl|'\n'
dedent|''
name|'metadata'
op|'['
string|"'container_format'"
op|']'
op|'='
name|'base'
op|'.'
name|'get'
op|'('
string|"'container_format'"
op|','
string|"'bare'"
op|')'
newline|'\n'
nl|'\n'
name|'snapshot_name'
op|'='
name|'uuid'
op|'.'
name|'uuid4'
op|'('
op|')'
op|'.'
name|'hex'
newline|'\n'
nl|'\n'
op|'('
name|'state'
op|','
name|'_max_mem'
op|','
name|'_mem'
op|','
name|'_cpus'
op|','
name|'_t'
op|')'
op|'='
name|'virt_dom'
op|'.'
name|'info'
op|'('
op|')'
newline|'\n'
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'state'
op|']'
newline|'\n'
nl|'\n'
comment|'# NOTE(rmk): Live snapshots require QEMU 1.3 and Libvirt 1.0.0.'
nl|'\n'
comment|'#            These restrictions can be relaxed as other configurations'
nl|'\n'
comment|'#            can be validated.'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'has_min_version'
op|'('
name|'MIN_LIBVIRT_LIVESNAPSHOT_VERSION'
op|','
nl|'\n'
name|'MIN_QEMU_LIVESNAPSHOT_VERSION'
op|','
nl|'\n'
name|'REQ_HYPERVISOR_LIVESNAPSHOT'
op|')'
name|'and'
name|'not'
name|'source_format'
op|'=='
string|'"lvm"'
name|'and'
name|'not'
name|'source_format'
op|'=='
string|"'rbd'"
op|':'
newline|'\n'
indent|'            '
name|'live_snapshot'
op|'='
name|'True'
newline|'\n'
comment|'# Abort is an idempotent operation, so make sure any block'
nl|'\n'
comment|'# jobs which may have failed are ended. This operation also'
nl|'\n'
comment|'# confirms the running instance, as opposed to the system as a'
nl|'\n'
comment|'# whole, has a new enough version of the hypervisor (bug 1193146).'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'virt_dom'
op|'.'
name|'blockJobAbort'
op|'('
name|'disk_path'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'                '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_CONFIG_UNSUPPORTED'
op|':'
newline|'\n'
indent|'                    '
name|'live_snapshot'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'pass'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'live_snapshot'
op|'='
name|'False'
newline|'\n'
nl|'\n'
comment|'# NOTE(rmk): We cannot perform live snapshots when a managedSave'
nl|'\n'
comment|'#            file is present, so we will use the cold/legacy method'
nl|'\n'
comment|'#            for instances which are shutdown.'
nl|'\n'
dedent|''
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|':'
newline|'\n'
indent|'            '
name|'live_snapshot'
op|'='
name|'False'
newline|'\n'
nl|'\n'
comment|'# NOTE(dkang): managedSave does not work for LXC'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'!='
string|"'lxc'"
name|'and'
name|'not'
name|'live_snapshot'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
name|'or'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'PAUSED'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_detach_pci_devices'
op|'('
name|'virt_dom'
op|','
nl|'\n'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|')'
op|')'
newline|'\n'
name|'virt_dom'
op|'.'
name|'managedSave'
op|'('
number|'0'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'snapshot_backend'
op|'='
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'snapshot'
op|'('
name|'disk_path'
op|','
nl|'\n'
name|'snapshot_name'
op|','
nl|'\n'
name|'image_type'
op|'='
name|'source_format'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'live_snapshot'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"Beginning live snapshot process"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"Beginning cold snapshot process"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'snapshot_backend'
op|'.'
name|'snapshot_create'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'update_task_state'
op|'('
name|'task_state'
op|'='
name|'task_states'
op|'.'
name|'IMAGE_PENDING_UPLOAD'
op|')'
newline|'\n'
name|'snapshot_directory'
op|'='
name|'CONF'
op|'.'
name|'libvirt_snapshots_directory'
newline|'\n'
name|'fileutils'
op|'.'
name|'ensure_tree'
op|'('
name|'snapshot_directory'
op|')'
newline|'\n'
name|'with'
name|'utils'
op|'.'
name|'tempdir'
op|'('
name|'dir'
op|'='
name|'snapshot_directory'
op|')'
name|'as'
name|'tmpdir'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'out_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'tmpdir'
op|','
name|'snapshot_name'
op|')'
newline|'\n'
name|'if'
name|'live_snapshot'
op|':'
newline|'\n'
comment|'# NOTE (rmk): libvirt needs to be able to write to the'
nl|'\n'
comment|'#             temp directory, which is owned nova.'
nl|'\n'
indent|'                    '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'chmod'"
op|','
string|"'777'"
op|','
name|'tmpdir'
op|','
name|'run_as_root'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_live_snapshot'
op|'('
name|'virt_dom'
op|','
name|'disk_path'
op|','
name|'out_path'
op|','
nl|'\n'
name|'image_format'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'snapshot_backend'
op|'.'
name|'snapshot_extract'
op|'('
name|'out_path'
op|','
name|'image_format'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'not'
name|'live_snapshot'
op|':'
newline|'\n'
indent|'                    '
name|'snapshot_backend'
op|'.'
name|'snapshot_delete'
op|'('
op|')'
newline|'\n'
dedent|''
name|'new_dom'
op|'='
name|'None'
newline|'\n'
comment|'# NOTE(dkang): because previous managedSave is not called'
nl|'\n'
comment|'#              for LXC, _create_domain must not be called.'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'!='
string|"'lxc'"
name|'and'
name|'not'
name|'live_snapshot'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
indent|'                        '
name|'new_dom'
op|'='
name|'self'
op|'.'
name|'_create_domain'
op|'('
name|'domain'
op|'='
name|'virt_dom'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'PAUSED'
op|':'
newline|'\n'
indent|'                        '
name|'new_dom'
op|'='
name|'self'
op|'.'
name|'_create_domain'
op|'('
name|'domain'
op|'='
name|'virt_dom'
op|','
nl|'\n'
name|'launch_flags'
op|'='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_START_PAUSED'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'new_dom'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'_attach_pci_devices'
op|'('
name|'new_dom'
op|','
nl|'\n'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"Snapshot extracted, beginning image upload"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# Upload that image to the image service'
nl|'\n'
nl|'\n'
dedent|''
name|'update_task_state'
op|'('
name|'task_state'
op|'='
name|'task_states'
op|'.'
name|'IMAGE_UPLOADING'
op|','
nl|'\n'
name|'expected_state'
op|'='
name|'task_states'
op|'.'
name|'IMAGE_PENDING_UPLOAD'
op|')'
newline|'\n'
name|'with'
name|'libvirt_utils'
op|'.'
name|'file_open'
op|'('
name|'out_path'
op|')'
name|'as'
name|'image_file'
op|':'
newline|'\n'
indent|'                '
name|'image_service'
op|'.'
name|'update'
op|'('
name|'context'
op|','
nl|'\n'
name|'image_href'
op|','
nl|'\n'
name|'metadata'
op|','
nl|'\n'
name|'image_file'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"Snapshot image upload complete"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_wait_for_block_job
name|'def'
name|'_wait_for_block_job'
op|'('
name|'domain'
op|','
name|'disk_path'
op|','
name|'abort_on_error'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'status'
op|'='
name|'domain'
op|'.'
name|'blockJobInfo'
op|'('
name|'disk_path'
op|','
number|'0'
op|')'
newline|'\n'
name|'if'
name|'status'
op|'=='
op|'-'
number|'1'
name|'and'
name|'abort_on_error'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|"'libvirt error while requesting blockjob info.'"
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'cur'
op|'='
name|'status'
op|'.'
name|'get'
op|'('
string|"'cur'"
op|','
number|'0'
op|')'
newline|'\n'
name|'end'
op|'='
name|'status'
op|'.'
name|'get'
op|'('
string|"'end'"
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'cur'
op|'=='
name|'end'
name|'and'
name|'cur'
op|'!='
number|'0'
name|'and'
name|'end'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
DECL|member|_live_snapshot
dedent|''
dedent|''
name|'def'
name|'_live_snapshot'
op|'('
name|'self'
op|','
name|'domain'
op|','
name|'disk_path'
op|','
name|'out_path'
op|','
name|'image_format'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Snapshot an instance without downtime."""'
newline|'\n'
comment|"# Save a copy of the domain's running XML file"
nl|'\n'
name|'xml'
op|'='
name|'domain'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
nl|'\n'
comment|'# Abort is an idempotent operation, so make sure any block'
nl|'\n'
comment|'# jobs which may have failed are ended.'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'domain'
op|'.'
name|'blockJobAbort'
op|'('
name|'disk_path'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
comment|'# NOTE (rmk): We are using shallow rebases as a workaround to a bug'
nl|'\n'
comment|'#             in QEMU 1.3. In order to do this, we need to create'
nl|'\n'
comment|'#             a destination image with the original backing file'
nl|'\n'
comment|'#             and matching size of the instance root disk.'
nl|'\n'
dedent|''
name|'src_disk_size'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_disk_size'
op|'('
name|'disk_path'
op|')'
newline|'\n'
name|'src_back_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_disk_backing_file'
op|'('
name|'disk_path'
op|','
nl|'\n'
name|'basename'
op|'='
name|'False'
op|')'
newline|'\n'
name|'disk_delta'
op|'='
name|'out_path'
op|'+'
string|"'.delta'"
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'create_cow_image'
op|'('
name|'src_back_path'
op|','
name|'disk_delta'
op|','
nl|'\n'
name|'src_disk_size'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# NOTE (rmk): blockRebase cannot be executed on persistent'
nl|'\n'
comment|'#             domains, so we need to temporarily undefine it.'
nl|'\n'
comment|'#             If any part of this block fails, the domain is'
nl|'\n'
comment|'#             re-defined regardless.'
nl|'\n'
indent|'            '
name|'if'
name|'domain'
op|'.'
name|'isPersistent'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'domain'
op|'.'
name|'undefine'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE (rmk): Establish a temporary mirror of our root disk and'
nl|'\n'
comment|'#             issue an abort once we have a complete copy.'
nl|'\n'
dedent|''
name|'domain'
op|'.'
name|'blockRebase'
op|'('
name|'disk_path'
op|','
name|'disk_delta'
op|','
number|'0'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_BLOCK_REBASE_COPY'
op|'|'
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT'
op|'|'
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_BLOCK_REBASE_SHALLOW'
op|')'
newline|'\n'
nl|'\n'
name|'while'
name|'self'
op|'.'
name|'_wait_for_block_job'
op|'('
name|'domain'
op|','
name|'disk_path'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'time'
op|'.'
name|'sleep'
op|'('
number|'0.5'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'domain'
op|'.'
name|'blockJobAbort'
op|'('
name|'disk_path'
op|','
number|'0'
op|')'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'chown'
op|'('
name|'disk_delta'
op|','
name|'os'
op|'.'
name|'getuid'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'defineXML'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
comment|'# Convert the delta (CoW) image with a backing file to a flat'
nl|'\n'
comment|'# image with no backing file.'
nl|'\n'
dedent|''
name|'libvirt_utils'
op|'.'
name|'extract_snapshot'
op|'('
name|'disk_delta'
op|','
string|"'qcow2'"
op|','
name|'None'
op|','
nl|'\n'
name|'out_path'
op|','
name|'image_format'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_volume_snapshot_update_status
dedent|''
name|'def'
name|'_volume_snapshot_update_status'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'snapshot_id'
op|','
name|'status'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Send a snapshot status update to Cinder.\n\n        This method captures and logs exceptions that occur\n        since callers cannot do anything useful with these exceptions.\n\n        Operations on the Cinder side waiting for this will time out if\n        a failure occurs sending the update.\n\n        :param context: security context\n        :param snapshot_id: id of snapshot being updated\n        :param status: new status value\n\n        """'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_volume_api'
op|'.'
name|'update_snapshot_status'
op|'('
name|'context'
op|','
nl|'\n'
name|'snapshot_id'
op|','
nl|'\n'
name|'status'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|"'Failed to send updated snapshot status '"
nl|'\n'
string|"'to volume service.'"
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_volume_snapshot_create
dedent|''
dedent|''
name|'def'
name|'_volume_snapshot_create'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'domain'
op|','
nl|'\n'
name|'volume_id'
op|','
name|'snapshot_id'
op|','
name|'new_file'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Perform volume snapshot.\n\n           :param domain: VM that volume is attached to\n           :param volume_id: volume UUID to snapshot\n           :param snapshot_id: UUID of snapshot being created\n           :param new_file: relative path to new qcow2 file present on share\n\n        """'
newline|'\n'
nl|'\n'
name|'xml'
op|'='
name|'domain'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
name|'xml_doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
name|'device_info'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuest'
op|'('
op|')'
newline|'\n'
name|'device_info'
op|'.'
name|'parse_dom'
op|'('
name|'xml_doc'
op|')'
newline|'\n'
nl|'\n'
name|'disks_to_snap'
op|'='
op|'['
op|']'
comment|'# to be snapshotted by libvirt'
newline|'\n'
name|'disks_to_skip'
op|'='
op|'['
op|']'
comment|'# local disks not snapshotted'
newline|'\n'
nl|'\n'
name|'for'
name|'disk'
name|'in'
name|'device_info'
op|'.'
name|'devices'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
name|'disk'
op|'.'
name|'root_name'
op|'!='
string|"'disk'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'disk'
op|'.'
name|'target_dev'
name|'is'
name|'None'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'disk'
op|'.'
name|'serial'
name|'is'
name|'None'
name|'or'
name|'disk'
op|'.'
name|'serial'
op|'!='
name|'volume_id'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'disks_to_skip'
op|'.'
name|'append'
op|'('
name|'disk'
op|'.'
name|'source_path'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
comment|'# disk is a Cinder volume with the correct volume_id'
nl|'\n'
nl|'\n'
dedent|''
name|'disk_info'
op|'='
op|'{'
nl|'\n'
string|"'dev'"
op|':'
name|'disk'
op|'.'
name|'target_dev'
op|','
nl|'\n'
string|"'serial'"
op|':'
name|'disk'
op|'.'
name|'serial'
op|','
nl|'\n'
string|"'current_file'"
op|':'
name|'disk'
op|'.'
name|'source_path'
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
comment|'# Determine path for new_file based on current path'
nl|'\n'
name|'current_file'
op|'='
name|'disk_info'
op|'['
string|"'current_file'"
op|']'
newline|'\n'
name|'new_file_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'dirname'
op|'('
name|'current_file'
op|')'
op|','
nl|'\n'
name|'new_file'
op|')'
newline|'\n'
name|'disks_to_snap'
op|'.'
name|'append'
op|'('
op|'('
name|'current_file'
op|','
name|'new_file_path'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'disks_to_snap'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|"'Found no disk to snapshot.'"
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'snapshot'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSnapshot'
op|'('
op|')'
newline|'\n'
name|'disks'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'current_name'
op|','
name|'new_filename'
name|'in'
name|'disks_to_snap'
op|':'
newline|'\n'
indent|'            '
name|'snap_disk'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSnapshotDisk'
op|'('
op|')'
newline|'\n'
name|'snap_disk'
op|'.'
name|'name'
op|'='
name|'current_name'
newline|'\n'
name|'snap_disk'
op|'.'
name|'source_path'
op|'='
name|'new_filename'
newline|'\n'
name|'snap_disk'
op|'.'
name|'source_type'
op|'='
string|"'file'"
newline|'\n'
name|'snap_disk'
op|'.'
name|'snapshot'
op|'='
string|"'external'"
newline|'\n'
name|'snap_disk'
op|'.'
name|'driver_name'
op|'='
string|"'qcow2'"
newline|'\n'
nl|'\n'
name|'snapshot'
op|'.'
name|'add_disk'
op|'('
name|'snap_disk'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'dev'
name|'in'
name|'disks_to_skip'
op|':'
newline|'\n'
indent|'            '
name|'snap_disk'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSnapshotDisk'
op|'('
op|')'
newline|'\n'
name|'snap_disk'
op|'.'
name|'name'
op|'='
name|'dev'
newline|'\n'
name|'snap_disk'
op|'.'
name|'snapshot'
op|'='
string|"'no'"
newline|'\n'
nl|'\n'
name|'snapshot'
op|'.'
name|'add_disk'
op|'('
name|'snap_disk'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'snapshot_xml'
op|'='
name|'snapshot'
op|'.'
name|'to_xml'
op|'('
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"snap xml: %s"'
op|')'
op|'%'
name|'snapshot_xml'
op|')'
newline|'\n'
nl|'\n'
name|'snap_flags'
op|'='
op|'('
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY'
op|'|'
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA'
op|'|'
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT'
op|')'
newline|'\n'
nl|'\n'
name|'QUIESCE'
op|'='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'domain'
op|'.'
name|'snapshotCreateXML'
op|'('
name|'snapshot_xml'
op|','
nl|'\n'
name|'snap_flags'
op|'|'
name|'QUIESCE'
op|')'
newline|'\n'
nl|'\n'
name|'return'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|"'Unable to create quiesced VM snapshot, '"
nl|'\n'
string|"'attempting again with quiescing disabled.'"
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'domain'
op|'.'
name|'snapshotCreateXML'
op|'('
name|'snapshot_xml'
op|','
name|'snap_flags'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|"'Unable to create VM snapshot, '"
nl|'\n'
string|"'failing volume_snapshot operation.'"
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
name|'raise'
newline|'\n'
nl|'\n'
DECL|member|volume_snapshot_create
dedent|''
dedent|''
name|'def'
name|'volume_snapshot_create'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'volume_id'
op|','
nl|'\n'
name|'create_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create snapshots of a Cinder volume via libvirt.\n\n        :param instance: VM instance reference\n        :param volume_id: id of volume being snapshotted\n        :param create_info: dict of information used to create snapshots\n                     - snapshot_id : ID of snapshot\n                     - type : qcow2 / <other>\n                     - new_file : qcow2 file created by Cinder which\n                                  becomes the VM\'s active image after\n                                  the snapshot is complete\n        """'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"volume_snapshot_create: instance: %(instance)s "'
nl|'\n'
string|'"create_info: %(c_info)s"'
op|')'
op|'%'
op|'{'
string|"'instance'"
op|':'
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
string|"'c_info'"
op|':'
name|'create_info'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotRunning'
op|'('
name|'instance_id'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'create_info'
op|'['
string|"'type'"
op|']'
op|'!='
string|"'qcow2'"
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'_'
op|'('
string|"'Unknown type: %s'"
op|')'
op|'%'
nl|'\n'
name|'create_info'
op|'['
string|"'type'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'snapshot_id'
op|'='
name|'create_info'
op|'.'
name|'get'
op|'('
string|"'snapshot_id'"
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'snapshot_id'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'_'
op|'('
string|"'snapshot_id required '"
nl|'\n'
string|"'in create_info'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_volume_snapshot_create'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'virt_dom'
op|','
nl|'\n'
name|'volume_id'
op|','
name|'snapshot_id'
op|','
nl|'\n'
name|'create_info'
op|'['
string|"'new_file'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
name|'_'
op|'('
string|"'Error occurred during volume_snapshot_create, '"
nl|'\n'
string|"'sending error status to Cinder.'"
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'msg'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_volume_snapshot_update_status'
op|'('
nl|'\n'
name|'context'
op|','
name|'snapshot_id'
op|','
string|"'error'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_volume_snapshot_update_status'
op|'('
nl|'\n'
name|'context'
op|','
name|'snapshot_id'
op|','
string|"'creating'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|_volume_snapshot_delete
dedent|''
name|'def'
name|'_volume_snapshot_delete'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'volume_id'
op|','
nl|'\n'
name|'snapshot_id'
op|','
name|'delete_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Note:\n            if file being merged into == active image:\n                do a blockRebase (pull) operation\n            else:\n                do a blockCommit operation\n            Files must be adjacent in snap chain.\n\n        :param instance: instance reference\n        :param volume_id: volume UUID\n        :param snapshot_id: snapshot UUID (unused currently)\n        :param delete_info: {\n            \'type\':              \'qcow2\',\n            \'file_to_merge\':     \'a.img\',\n            \'merge_target_file\': \'b.img\' or None (if merging file_to_merge into\n                                                  active image)\n          }\n\n\n        Libvirt blockjob handling required for this method is broken\n        in versions of libvirt that do not contain:\n        http://libvirt.org/git/?p=libvirt.git;h=0f9e67bfad (1.1.1)\n        (Patch is pending in 1.0.5-maint branch as well, but we cannot detect\n        libvirt 1.0.5.5 vs. 1.0.5.6 here.)\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'has_min_version'
op|'('
name|'MIN_LIBVIRT_BLOCKJOBINFO_VERSION'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'ver'
op|'='
string|"'.'"
op|'.'
name|'join'
op|'('
op|'['
name|'str'
op|'('
name|'x'
op|')'
name|'for'
name|'x'
name|'in'
name|'MIN_LIBVIRT_BLOCKJOBINFO_VERSION'
op|']'
op|')'
newline|'\n'
name|'msg'
op|'='
name|'_'
op|'('
string|'"Libvirt \'%s\' or later is required for online deletion "'
nl|'\n'
string|'"of volume snapshots."'
op|')'
op|'%'
name|'ver'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'volume_snapshot_delete: delete_info: %s'"
op|')'
op|'%'
name|'delete_info'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'delete_info'
op|'['
string|"'type'"
op|']'
op|'!='
string|"'qcow2'"
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|"'Unknown delete_info type %s'"
op|')'
op|'%'
name|'delete_info'
op|'['
string|"'type'"
op|']'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotRunning'
op|'('
name|'instance_id'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'##### Find dev name'
nl|'\n'
dedent|''
name|'my_dev'
op|'='
name|'None'
newline|'\n'
name|'active_disk'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'xml'
op|'='
name|'virt_dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
name|'xml_doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
name|'device_info'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuest'
op|'('
op|')'
newline|'\n'
name|'device_info'
op|'.'
name|'parse_dom'
op|'('
name|'xml_doc'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'disk'
name|'in'
name|'device_info'
op|'.'
name|'devices'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
name|'disk'
op|'.'
name|'root_name'
op|'!='
string|"'disk'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'disk'
op|'.'
name|'target_dev'
name|'is'
name|'None'
name|'or'
name|'disk'
op|'.'
name|'serial'
name|'is'
name|'None'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'disk'
op|'.'
name|'serial'
op|'=='
name|'volume_id'
op|':'
newline|'\n'
indent|'                '
name|'my_dev'
op|'='
name|'disk'
op|'.'
name|'target_dev'
newline|'\n'
name|'active_disk'
op|'='
name|'disk'
op|'.'
name|'source_path'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'my_dev'
name|'is'
name|'None'
name|'or'
name|'active_disk'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|"'Unable to locate disk matching id: %s'"
op|')'
op|'%'
name|'volume_id'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"found dev, it\'s %s, with active disk: %s"'
op|'%'
nl|'\n'
op|'('
name|'my_dev'
op|','
name|'active_disk'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'delete_info'
op|'['
string|"'merge_target_file'"
op|']'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|'# pull via blockRebase()'
nl|'\n'
nl|'\n'
comment|'# Merge the most recent snapshot into the active image'
nl|'\n'
nl|'\n'
indent|'            '
name|'rebase_disk'
op|'='
name|'my_dev'
newline|'\n'
name|'rebase_base'
op|'='
name|'delete_info'
op|'['
string|"'file_to_merge'"
op|']'
newline|'\n'
name|'rebase_bw'
op|'='
number|'0'
newline|'\n'
name|'rebase_flags'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'disk: %(disk)s, base: %(base)s, '"
nl|'\n'
string|"'bw: %(bw)s, flags: %(flags)s'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'disk'"
op|':'
name|'rebase_disk'
op|','
nl|'\n'
string|"'base'"
op|':'
name|'rebase_base'
op|','
nl|'\n'
string|"'bw'"
op|':'
name|'rebase_bw'
op|','
nl|'\n'
string|"'flags'"
op|':'
name|'rebase_flags'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'result'
op|'='
name|'virt_dom'
op|'.'
name|'blockRebase'
op|'('
name|'rebase_disk'
op|','
name|'rebase_base'
op|','
nl|'\n'
name|'rebase_bw'
op|','
name|'rebase_flags'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'result'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'blockRebase started successfully'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'while'
name|'self'
op|'.'
name|'_wait_for_block_job'
op|'('
name|'virt_dom'
op|','
name|'rebase_disk'
op|','
nl|'\n'
name|'abort_on_error'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'waiting for blockRebase job completion'"
op|')'
op|')'
newline|'\n'
name|'time'
op|'.'
name|'sleep'
op|'('
number|'0.5'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# commit with blockCommit()'
nl|'\n'
nl|'\n'
indent|'            '
name|'commit_disk'
op|'='
name|'my_dev'
newline|'\n'
name|'commit_base'
op|'='
name|'delete_info'
op|'['
string|"'merge_target_file'"
op|']'
newline|'\n'
name|'commit_top'
op|'='
name|'delete_info'
op|'['
string|"'file_to_merge'"
op|']'
newline|'\n'
name|'bandwidth'
op|'='
number|'0'
newline|'\n'
name|'flags'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'result'
op|'='
name|'virt_dom'
op|'.'
name|'blockCommit'
op|'('
name|'commit_disk'
op|','
name|'commit_base'
op|','
name|'commit_top'
op|','
nl|'\n'
name|'bandwidth'
op|','
name|'flags'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'result'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'blockCommit started successfully'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'while'
name|'self'
op|'.'
name|'_wait_for_block_job'
op|'('
name|'virt_dom'
op|','
name|'commit_disk'
op|','
nl|'\n'
name|'abort_on_error'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'waiting for blockCommit job completion'"
op|')'
op|')'
newline|'\n'
name|'time'
op|'.'
name|'sleep'
op|'('
number|'0.5'
op|')'
newline|'\n'
nl|'\n'
DECL|member|volume_snapshot_delete
dedent|''
dedent|''
dedent|''
name|'def'
name|'volume_snapshot_delete'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'volume_id'
op|','
name|'snapshot_id'
op|','
nl|'\n'
name|'delete_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_volume_snapshot_delete'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'volume_id'
op|','
nl|'\n'
name|'snapshot_id'
op|','
name|'delete_info'
op|'='
name|'delete_info'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
name|'_'
op|'('
string|"'Error occurred during volume_snapshot_delete, '"
nl|'\n'
string|"'sending error status to Cinder.'"
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'msg'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_volume_snapshot_update_status'
op|'('
nl|'\n'
name|'context'
op|','
name|'snapshot_id'
op|','
string|"'error_deleting'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_volume_snapshot_update_status'
op|'('
name|'context'
op|','
name|'snapshot_id'
op|','
string|"'deleting'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|reboot
dedent|''
name|'def'
name|'reboot'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'reboot_type'
op|'='
string|"'SOFT'"
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'bad_volumes_callback'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Reboot a virtual machine, given an instance reference."""'
newline|'\n'
name|'if'
name|'reboot_type'
op|'=='
string|"'SOFT'"
op|':'
newline|'\n'
comment|'# NOTE(vish): This will attempt to do a graceful shutdown/restart.'
nl|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'soft_reboot_success'
op|'='
name|'self'
op|'.'
name|'_soft_reboot'
op|'('
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Instance soft reboot failed: %s"'
op|')'
op|','
name|'e'
op|')'
newline|'\n'
name|'soft_reboot_success'
op|'='
name|'False'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'soft_reboot_success'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"Instance soft rebooted successfully."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|'"Failed to soft reboot instance. "'
nl|'\n'
string|'"Trying hard reboot."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'_hard_reboot'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_soft_reboot
dedent|''
name|'def'
name|'_soft_reboot'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Attempt to shutdown and restart the instance gracefully.\n\n        We use shutdown and create here so we can return if the guest\n        responded and actually rebooted. Note that this method only\n        succeeds if the guest responds to acpi. Therefore we return\n        success or failure so we can fall back to a hard reboot if\n        necessary.\n\n        :returns: True if the reboot succeeded\n        """'
newline|'\n'
name|'dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|'"name"'
op|']'
op|')'
newline|'\n'
op|'('
name|'state'
op|','
name|'_max_mem'
op|','
name|'_mem'
op|','
name|'_cpus'
op|','
name|'_t'
op|')'
op|'='
name|'dom'
op|'.'
name|'info'
op|'('
op|')'
newline|'\n'
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'state'
op|']'
newline|'\n'
name|'old_domid'
op|'='
name|'dom'
op|'.'
name|'ID'
op|'('
op|')'
newline|'\n'
comment|'# NOTE(vish): This check allows us to reboot an instance that'
nl|'\n'
comment|'#             is already shutdown.'
nl|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
indent|'            '
name|'dom'
op|'.'
name|'shutdown'
op|'('
op|')'
newline|'\n'
comment|'# NOTE(vish): This actually could take slightly longer than the'
nl|'\n'
comment|'#             FLAG defines depending on how long the get_info'
nl|'\n'
comment|'#             call takes to return.'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_prepare_pci_devices_for_use'
op|'('
nl|'\n'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|')'
op|')'
newline|'\n'
name|'for'
name|'x'
name|'in'
name|'xrange'
op|'('
name|'CONF'
op|'.'
name|'libvirt_wait_soft_reboot_seconds'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|'"name"'
op|']'
op|')'
newline|'\n'
op|'('
name|'state'
op|','
name|'_max_mem'
op|','
name|'_mem'
op|','
name|'_cpus'
op|','
name|'_t'
op|')'
op|'='
name|'dom'
op|'.'
name|'info'
op|'('
op|')'
newline|'\n'
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'state'
op|']'
newline|'\n'
name|'new_domid'
op|'='
name|'dom'
op|'.'
name|'ID'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(ivoks): By checking domain IDs, we make sure we are'
nl|'\n'
comment|"#              not recreating domain that's already running."
nl|'\n'
name|'if'
name|'old_domid'
op|'!='
name|'new_domid'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'state'
name|'in'
op|'['
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|','
nl|'\n'
name|'power_state'
op|'.'
name|'CRASHED'
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"Instance shutdown successfully."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_domain'
op|'('
name|'domain'
op|'='
name|'dom'
op|')'
newline|'\n'
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_wait_for_running'
op|','
name|'instance'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"Instance may have been rebooted during soft "'
nl|'\n'
string|'"reboot, so return now."'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'greenthread'
op|'.'
name|'sleep'
op|'('
number|'1'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|_hard_reboot
dedent|''
name|'def'
name|'_hard_reboot'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Reboot a virtual machine, given an instance reference.\n\n        Performs a Libvirt reset (if supported) on the domain.\n\n        If Libvirt reset is unavailable this method actually destroys and\n        re-creates the domain to ensure the reboot happens, as the guest\n        OS cannot ignore this action.\n\n        If xml is set, it uses the passed in xml in place of the xml from the\n        existing domain.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
name|'CONF'
op|'.'
name|'libvirt_type'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
comment|'# NOTE(vish): This could generate the wrong device_format if we are'
nl|'\n'
comment|"#             using the raw backend and the images don't exist yet."
nl|'\n'
comment|"#             The create_images_and_backing below doesn't properly"
nl|'\n'
comment|'#             regenerate raw backend images, however, so when it'
nl|'\n'
comment|'#             does we need to (re)generate the xml after the images'
nl|'\n'
comment|'#             are in place.'
nl|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'to_xml'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|','
nl|'\n'
name|'write_to_disk'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE (rmk): Re-populate any missing backing files.'
nl|'\n'
name|'disk_info_json'
op|'='
name|'self'
op|'.'
name|'get_instance_disk_info'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|','
name|'xml'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'instance_dir'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_images_and_backing'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'instance_dir'
op|','
nl|'\n'
name|'disk_info_json'
op|')'
newline|'\n'
nl|'\n'
comment|'# Initialize all the necessary networking, block devices and'
nl|'\n'
comment|'# start the instance.'
nl|'\n'
name|'self'
op|'.'
name|'_create_domain_and_network'
op|'('
name|'xml'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|','
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'reboot'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_prepare_pci_devices_for_use'
op|'('
nl|'\n'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_wait_for_reboot
name|'def'
name|'_wait_for_reboot'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Called at an interval until the VM is running again."""'
newline|'\n'
name|'state'
op|'='
name|'self'
op|'.'
name|'get_info'
op|'('
name|'instance'
op|')'
op|'['
string|"'state'"
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"Instance rebooted successfully."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
name|'_wait_for_reboot'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|pause
dedent|''
name|'def'
name|'pause'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Pause VM instance."""'
newline|'\n'
name|'dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'dom'
op|'.'
name|'suspend'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|unpause
dedent|''
name|'def'
name|'unpause'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Unpause paused VM instance."""'
newline|'\n'
name|'dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'dom'
op|'.'
name|'resume'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|power_off
dedent|''
name|'def'
name|'power_off'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Power off the specified instance."""'
newline|'\n'
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|power_on
dedent|''
name|'def'
name|'power_on'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Power on the specified instance."""'
newline|'\n'
comment|'# We use _hard_reboot here to ensure that all backing files,'
nl|'\n'
comment|'# network, and block device connections, etc. are established'
nl|'\n'
comment|'# and available before we attempt to start the instance.'
nl|'\n'
name|'self'
op|'.'
name|'_hard_reboot'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|suspend
dedent|''
name|'def'
name|'suspend'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Suspend the specified instance."""'
newline|'\n'
name|'dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_detach_pci_devices'
op|'('
name|'dom'
op|','
nl|'\n'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|')'
op|')'
newline|'\n'
name|'dom'
op|'.'
name|'managedSave'
op|'('
number|'0'
op|')'
newline|'\n'
nl|'\n'
DECL|member|resume
dedent|''
name|'def'
name|'resume'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""resume the specified instance."""'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_existing_domain_xml'
op|'('
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'dom'
op|'='
name|'self'
op|'.'
name|'_create_domain_and_network'
op|'('
name|'xml'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_attach_pci_devices'
op|'('
name|'dom'
op|','
nl|'\n'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|resume_state_on_host_boot
dedent|''
name|'def'
name|'resume_state_on_host_boot'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""resume guest state when a host is booted."""'
newline|'\n'
comment|'# Check if the instance is running already and avoid doing'
nl|'\n'
comment|'# anything if it is.'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'instance_exists'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'domain'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'domain'
op|'.'
name|'info'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|']'
newline|'\n'
nl|'\n'
name|'ignored_states'
op|'='
op|'('
name|'power_state'
op|'.'
name|'RUNNING'
op|','
nl|'\n'
name|'power_state'
op|'.'
name|'SUSPENDED'
op|','
nl|'\n'
name|'power_state'
op|'.'
name|'NOSTATE'
op|','
nl|'\n'
name|'power_state'
op|'.'
name|'PAUSED'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'state'
name|'in'
name|'ignored_states'
op|':'
newline|'\n'
indent|'                '
name|'return'
newline|'\n'
nl|'\n'
comment|'# Instance is not up and could be in an unknown state.'
nl|'\n'
comment|'# Be as absolute as possible about getting it back into'
nl|'\n'
comment|'# a known and running state.'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_hard_reboot'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|rescue
dedent|''
name|'def'
name|'rescue'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'rescue_password'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Loads a VM using rescue images.\n\n        A rescue is normally performed when something goes wrong with the\n        primary images and data needs to be corrected/recovered. Rescuing\n        should not edit or over-ride the original image, only allow for\n        data recovery.\n\n        """'
newline|'\n'
name|'instance_dir'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'unrescue_xml'
op|'='
name|'self'
op|'.'
name|'_get_existing_domain_xml'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'unrescue_xml_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
string|"'unrescue.xml'"
op|')'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'write_to_file'
op|'('
name|'unrescue_xml_path'
op|','
name|'unrescue_xml'
op|')'
newline|'\n'
nl|'\n'
name|'rescue_images'
op|'='
op|'{'
nl|'\n'
string|"'image_id'"
op|':'
name|'CONF'
op|'.'
name|'rescue_image_id'
name|'or'
name|'instance'
op|'['
string|"'image_ref'"
op|']'
op|','
nl|'\n'
string|"'kernel_id'"
op|':'
name|'CONF'
op|'.'
name|'rescue_kernel_id'
name|'or'
name|'instance'
op|'['
string|"'kernel_id'"
op|']'
op|','
nl|'\n'
string|"'ramdisk_id'"
op|':'
name|'CONF'
op|'.'
name|'rescue_ramdisk_id'
name|'or'
name|'instance'
op|'['
string|"'ramdisk_id'"
op|']'
op|','
nl|'\n'
op|'}'
newline|'\n'
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
name|'CONF'
op|'.'
name|'libvirt_type'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'None'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'rescue'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_image'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'disk_info'
op|'['
string|"'mapping'"
op|']'
op|','
nl|'\n'
string|"'.rescue'"
op|','
name|'rescue_images'
op|','
nl|'\n'
name|'network_info'
op|'='
name|'network_info'
op|','
nl|'\n'
name|'admin_pass'
op|'='
name|'rescue_password'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'to_xml'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'image_meta'
op|','
name|'rescue'
op|'='
name|'rescue_images'
op|','
nl|'\n'
name|'write_to_disk'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_domain'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
DECL|member|unrescue
dedent|''
name|'def'
name|'unrescue'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Reboot the VM which is being rescued back into primary images.\n        """'
newline|'\n'
name|'instance_dir'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'unrescue_xml_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
string|"'unrescue.xml'"
op|')'
newline|'\n'
name|'xml'
op|'='
name|'libvirt_utils'
op|'.'
name|'load_file'
op|'('
name|'unrescue_xml_path'
op|')'
newline|'\n'
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_domain'
op|'('
name|'xml'
op|','
name|'virt_dom'
op|')'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'file_delete'
op|'('
name|'unrescue_xml_path'
op|')'
newline|'\n'
name|'rescue_files'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
string|'"*.rescue"'
op|')'
newline|'\n'
name|'for'
name|'rescue_file'
name|'in'
name|'glob'
op|'.'
name|'iglob'
op|'('
name|'rescue_files'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'libvirt_utils'
op|'.'
name|'file_delete'
op|'('
name|'rescue_file'
op|')'
newline|'\n'
nl|'\n'
DECL|member|poll_rebooting_instances
dedent|''
dedent|''
name|'def'
name|'poll_rebooting_instances'
op|'('
name|'self'
op|','
name|'timeout'
op|','
name|'instances'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|_enable_hairpin
dedent|''
name|'def'
name|'_enable_hairpin'
op|'('
name|'self'
op|','
name|'xml'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'interfaces'
op|'='
name|'self'
op|'.'
name|'get_interfaces'
op|'('
name|'xml'
op|')'
newline|'\n'
name|'for'
name|'interface'
name|'in'
name|'interfaces'
op|':'
newline|'\n'
indent|'            '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'tee'"
op|','
nl|'\n'
string|"'/sys/class/net/%s/brport/hairpin_mode'"
op|'%'
name|'interface'
op|','
nl|'\n'
name|'process_input'
op|'='
string|"'1'"
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|','
nl|'\n'
name|'check_exit_code'
op|'='
op|'['
number|'0'
op|','
number|'1'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(ilyaalekseyev): Implementation like in multinics'
nl|'\n'
comment|'# for xenapi(tr3buchet)'
nl|'\n'
DECL|member|spawn
dedent|''
dedent|''
name|'def'
name|'spawn'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'injected_files'
op|','
nl|'\n'
name|'admin_password'
op|','
name|'network_info'
op|'='
name|'None'
op|','
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
name|'CONF'
op|'.'
name|'libvirt_type'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'block_device_info'
op|','
nl|'\n'
name|'image_meta'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_image'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'disk_info'
op|'['
string|"'mapping'"
op|']'
op|','
nl|'\n'
name|'network_info'
op|'='
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|','
nl|'\n'
name|'files'
op|'='
name|'injected_files'
op|','
nl|'\n'
name|'admin_pass'
op|'='
name|'admin_password'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'to_xml'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'disk_info'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|','
nl|'\n'
name|'write_to_disk'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_create_domain_and_network'
op|'('
name|'xml'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|','
name|'context'
op|'='
name|'context'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Instance is running"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_wait_for_boot
name|'def'
name|'_wait_for_boot'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Called at an interval until the VM is running."""'
newline|'\n'
name|'state'
op|'='
name|'self'
op|'.'
name|'get_info'
op|'('
name|'instance'
op|')'
op|'['
string|"'state'"
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"Instance spawned successfully."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
name|'_wait_for_boot'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_flush_libvirt_console
dedent|''
name|'def'
name|'_flush_libvirt_console'
op|'('
name|'self'
op|','
name|'pty'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'out'
op|','
name|'err'
op|'='
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'dd'"
op|','
nl|'\n'
string|"'if=%s'"
op|'%'
name|'pty'
op|','
nl|'\n'
string|"'iflag=nonblock'"
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|','
nl|'\n'
name|'check_exit_code'
op|'='
name|'False'
op|')'
newline|'\n'
name|'return'
name|'out'
newline|'\n'
nl|'\n'
DECL|member|_append_to_file
dedent|''
name|'def'
name|'_append_to_file'
op|'('
name|'self'
op|','
name|'data'
op|','
name|'fpath'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'data: %(data)r, fpath: %(fpath)r'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'data'"
op|':'
name|'data'
op|','
string|"'fpath'"
op|':'
name|'fpath'
op|'}'
op|')'
newline|'\n'
name|'fp'
op|'='
name|'open'
op|'('
name|'fpath'
op|','
string|"'a+'"
op|')'
newline|'\n'
name|'fp'
op|'.'
name|'write'
op|'('
name|'data'
op|')'
newline|'\n'
name|'return'
name|'fpath'
newline|'\n'
nl|'\n'
DECL|member|get_console_output
dedent|''
name|'def'
name|'get_console_output'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'virt_dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
name|'tree'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
name|'console_types'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
comment|"# NOTE(comstud): We want to try 'file' types first, then try 'pty'"
nl|'\n'
comment|"# types.  We can't use Python 2.7 syntax of:"
nl|'\n'
comment|'# tree.find("./devices/console[@type=\'file\']/source")'
nl|'\n'
comment|'# because we need to support 2.6.'
nl|'\n'
name|'console_nodes'
op|'='
name|'tree'
op|'.'
name|'findall'
op|'('
string|"'./devices/console'"
op|')'
newline|'\n'
name|'for'
name|'console_node'
name|'in'
name|'console_nodes'
op|':'
newline|'\n'
indent|'            '
name|'console_type'
op|'='
name|'console_node'
op|'.'
name|'get'
op|'('
string|"'type'"
op|')'
newline|'\n'
name|'console_types'
op|'.'
name|'setdefault'
op|'('
name|'console_type'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'console_types'
op|'['
name|'console_type'
op|']'
op|'.'
name|'append'
op|'('
name|'console_node'
op|')'
newline|'\n'
nl|'\n'
comment|'# If the guest has a console logging to a file prefer to use that'
nl|'\n'
dedent|''
name|'if'
name|'console_types'
op|'.'
name|'get'
op|'('
string|"'file'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'file_console'
name|'in'
name|'console_types'
op|'.'
name|'get'
op|'('
string|"'file'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'source_node'
op|'='
name|'file_console'
op|'.'
name|'find'
op|'('
string|"'./source'"
op|')'
newline|'\n'
name|'if'
name|'source_node'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'path'
op|'='
name|'source_node'
op|'.'
name|'get'
op|'('
string|'"path"'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'path'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'libvirt_utils'
op|'.'
name|'chown'
op|'('
name|'path'
op|','
name|'os'
op|'.'
name|'getuid'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'with'
name|'libvirt_utils'
op|'.'
name|'file_open'
op|'('
name|'path'
op|','
string|"'rb'"
op|')'
name|'as'
name|'fp'
op|':'
newline|'\n'
indent|'                    '
name|'log_data'
op|','
name|'remaining'
op|'='
name|'utils'
op|'.'
name|'last_bytes'
op|'('
name|'fp'
op|','
nl|'\n'
name|'MAX_CONSOLE_BYTES'
op|')'
newline|'\n'
name|'if'
name|'remaining'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                        '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'Truncated console log returned, %d bytes '"
nl|'\n'
string|"'ignored'"
op|')'
op|','
name|'remaining'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'log_data'
newline|'\n'
nl|'\n'
comment|"# Try 'pty' types"
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'console_types'
op|'.'
name|'get'
op|'('
string|"'pty'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'pty_console'
name|'in'
name|'console_types'
op|'.'
name|'get'
op|'('
string|"'pty'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'source_node'
op|'='
name|'pty_console'
op|'.'
name|'find'
op|'('
string|"'./source'"
op|')'
newline|'\n'
name|'if'
name|'source_node'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'pty'
op|'='
name|'source_node'
op|'.'
name|'get'
op|'('
string|'"path"'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'pty'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|'"Guest does not have a console available"'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_chown_console_log_for_instance'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'data'
op|'='
name|'self'
op|'.'
name|'_flush_libvirt_console'
op|'('
name|'pty'
op|')'
newline|'\n'
name|'console_log'
op|'='
name|'self'
op|'.'
name|'_get_console_log_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'fpath'
op|'='
name|'self'
op|'.'
name|'_append_to_file'
op|'('
name|'data'
op|','
name|'console_log'
op|')'
newline|'\n'
nl|'\n'
name|'with'
name|'libvirt_utils'
op|'.'
name|'file_open'
op|'('
name|'fpath'
op|','
string|"'rb'"
op|')'
name|'as'
name|'fp'
op|':'
newline|'\n'
indent|'            '
name|'log_data'
op|','
name|'remaining'
op|'='
name|'utils'
op|'.'
name|'last_bytes'
op|'('
name|'fp'
op|','
name|'MAX_CONSOLE_BYTES'
op|')'
newline|'\n'
name|'if'
name|'remaining'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'Truncated console log returned, %d bytes ignored'"
op|')'
op|','
nl|'\n'
name|'remaining'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'log_data'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|get_host_ip_addr
name|'def'
name|'get_host_ip_addr'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'CONF'
op|'.'
name|'my_ip'
newline|'\n'
nl|'\n'
DECL|member|get_vnc_console
dedent|''
name|'def'
name|'get_vnc_console'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
DECL|function|get_vnc_port_for_instance
indent|'        '
name|'def'
name|'get_vnc_port_for_instance'
op|'('
name|'instance_name'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance_name'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'virt_dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
name|'dom'
op|'='
name|'xmlutils'
op|'.'
name|'safe_minidom_parse_string'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'graphic'
name|'in'
name|'dom'
op|'.'
name|'getElementsByTagName'
op|'('
string|"'graphics'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'graphic'
op|'.'
name|'getAttribute'
op|'('
string|"'type'"
op|')'
op|'=='
string|"'vnc'"
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'graphic'
op|'.'
name|'getAttribute'
op|'('
string|"'port'"
op|')'
newline|'\n'
comment|'# NOTE(rmk): We had VNC consoles enabled but the instance in'
nl|'\n'
comment|'# question is not actually listening for connections.'
nl|'\n'
dedent|''
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'ConsoleTypeUnavailable'
op|'('
name|'console_type'
op|'='
string|"'vnc'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'port'
op|'='
name|'get_vnc_port_for_instance'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'host'
op|'='
name|'CONF'
op|'.'
name|'vncserver_proxyclient_address'
newline|'\n'
nl|'\n'
name|'return'
op|'{'
string|"'host'"
op|':'
name|'host'
op|','
string|"'port'"
op|':'
name|'port'
op|','
string|"'internal_access_path'"
op|':'
name|'None'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|get_spice_console
dedent|''
name|'def'
name|'get_spice_console'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
DECL|function|get_spice_ports_for_instance
indent|'        '
name|'def'
name|'get_spice_ports_for_instance'
op|'('
name|'instance_name'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance_name'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'virt_dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
comment|'# TODO(sleepsonthefloor): use etree instead of minidom'
nl|'\n'
name|'dom'
op|'='
name|'xmlutils'
op|'.'
name|'safe_minidom_parse_string'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'graphic'
name|'in'
name|'dom'
op|'.'
name|'getElementsByTagName'
op|'('
string|"'graphics'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'graphic'
op|'.'
name|'getAttribute'
op|'('
string|"'type'"
op|')'
op|'=='
string|"'spice'"
op|':'
newline|'\n'
indent|'                    '
name|'return'
op|'('
name|'graphic'
op|'.'
name|'getAttribute'
op|'('
string|"'port'"
op|')'
op|','
nl|'\n'
name|'graphic'
op|'.'
name|'getAttribute'
op|'('
string|"'tlsPort'"
op|')'
op|')'
newline|'\n'
comment|'# NOTE(rmk): We had Spice consoles enabled but the instance in'
nl|'\n'
comment|'# question is not actually listening for connections.'
nl|'\n'
dedent|''
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'ConsoleTypeUnavailable'
op|'('
name|'console_type'
op|'='
string|"'spice'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'ports'
op|'='
name|'get_spice_ports_for_instance'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'host'
op|'='
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'server_proxyclient_address'
newline|'\n'
nl|'\n'
name|'return'
op|'{'
string|"'host'"
op|':'
name|'host'
op|','
string|"'port'"
op|':'
name|'ports'
op|'['
number|'0'
op|']'
op|','
nl|'\n'
string|"'tlsPort'"
op|':'
name|'ports'
op|'['
number|'1'
op|']'
op|','
string|"'internal_access_path'"
op|':'
name|'None'
op|'}'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_supports_direct_io
name|'def'
name|'_supports_direct_io'
op|'('
name|'dirpath'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'        '
name|'if'
name|'not'
name|'hasattr'
op|'('
name|'os'
op|','
string|"'O_DIRECT'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"This python runtime does not support direct I/O"'
op|')'
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
name|'testfile'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'dirpath'
op|','
string|'".directio.test"'
op|')'
newline|'\n'
nl|'\n'
name|'hasDirectIO'
op|'='
name|'True'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'='
name|'os'
op|'.'
name|'open'
op|'('
name|'testfile'
op|','
name|'os'
op|'.'
name|'O_CREAT'
op|'|'
name|'os'
op|'.'
name|'O_WRONLY'
op|'|'
name|'os'
op|'.'
name|'O_DIRECT'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'f'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Path \'%(path)s\' supports direct I/O"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'path'"
op|':'
name|'dirpath'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'EINVAL'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Path \'%(path)s\' does not support direct I/O: "'
nl|'\n'
string|'"\'%(ex)s\'"'
op|')'
op|'%'
op|'{'
string|"'path'"
op|':'
name|'dirpath'
op|','
string|"'ex'"
op|':'
name|'str'
op|'('
name|'e'
op|')'
op|'}'
op|')'
newline|'\n'
name|'hasDirectIO'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|'"Error on \'%(path)s\' while checking "'
nl|'\n'
string|'"direct I/O: \'%(ex)s\'"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'path'"
op|':'
name|'dirpath'
op|','
string|"'ex'"
op|':'
name|'str'
op|'('
name|'e'
op|')'
op|'}'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|'"Error on \'%(path)s\' while checking direct I/O: "'
nl|'\n'
string|'"\'%(ex)s\'"'
op|')'
op|'%'
op|'{'
string|"'path'"
op|':'
name|'dirpath'
op|','
string|"'ex'"
op|':'
name|'str'
op|'('
name|'e'
op|')'
op|'}'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'unlink'
op|'('
name|'testfile'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'hasDirectIO'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_create_local
name|'def'
name|'_create_local'
op|'('
name|'target'
op|','
name|'local_size'
op|','
name|'unit'
op|'='
string|"'G'"
op|','
nl|'\n'
name|'fs_format'
op|'='
name|'None'
op|','
name|'label'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a blank image of specified size."""'
newline|'\n'
nl|'\n'
name|'libvirt_utils'
op|'.'
name|'create_image'
op|'('
string|"'raw'"
op|','
name|'target'
op|','
nl|'\n'
string|"'%d%c'"
op|'%'
op|'('
name|'local_size'
op|','
name|'unit'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_create_ephemeral
dedent|''
name|'def'
name|'_create_ephemeral'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'ephemeral_size'
op|','
nl|'\n'
name|'fs_label'
op|','
name|'os_type'
op|','
name|'is_block_dev'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'is_block_dev'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_create_local'
op|'('
name|'target'
op|','
name|'ephemeral_size'
op|')'
newline|'\n'
nl|'\n'
comment|'# Run as root only for block devices.'
nl|'\n'
dedent|''
name|'disk'
op|'.'
name|'mkfs'
op|'('
name|'os_type'
op|','
name|'fs_label'
op|','
name|'target'
op|','
name|'run_as_root'
op|'='
name|'is_block_dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_create_swap
name|'def'
name|'_create_swap'
op|'('
name|'target'
op|','
name|'swap_mb'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a swap file of specified size."""'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'create_image'
op|'('
string|"'raw'"
op|','
name|'target'
op|','
string|"'%dM'"
op|'%'
name|'swap_mb'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'mkfs'
op|'('
string|"'swap'"
op|','
name|'target'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_get_console_log_path
name|'def'
name|'_get_console_log_path'
op|'('
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
op|','
nl|'\n'
string|"'console.log'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|_chown_console_log_for_instance
dedent|''
name|'def'
name|'_chown_console_log_for_instance'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'console_log'
op|'='
name|'self'
op|'.'
name|'_get_console_log_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'console_log'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'libvirt_utils'
op|'.'
name|'chown'
op|'('
name|'console_log'
op|','
name|'os'
op|'.'
name|'getuid'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_create_image
dedent|''
dedent|''
name|'def'
name|'_create_image'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'disk_mapping'
op|','
name|'suffix'
op|'='
string|"''"
op|','
nl|'\n'
name|'disk_images'
op|'='
name|'None'
op|','
name|'network_info'
op|'='
name|'None'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'files'
op|'='
name|'None'
op|','
nl|'\n'
name|'admin_pass'
op|'='
name|'None'
op|','
name|'inject_files'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'suffix'
op|':'
newline|'\n'
indent|'            '
name|'suffix'
op|'='
string|"''"
newline|'\n'
nl|'\n'
dedent|''
name|'booted_from_volume'
op|'='
op|'('
nl|'\n'
op|'('
name|'not'
name|'bool'
op|'('
name|'instance'
op|'.'
name|'get'
op|'('
string|"'image_ref'"
op|')'
op|')'
op|')'
nl|'\n'
name|'or'
string|"'disk'"
name|'not'
name|'in'
name|'disk_mapping'
nl|'\n'
op|')'
newline|'\n'
nl|'\n'
comment|'# syntactic nicety'
nl|'\n'
DECL|function|basepath
name|'def'
name|'basepath'
op|'('
name|'fname'
op|'='
string|"''"
op|','
name|'suffix'
op|'='
name|'suffix'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
op|','
nl|'\n'
name|'fname'
op|'+'
name|'suffix'
op|')'
newline|'\n'
nl|'\n'
DECL|function|image
dedent|''
name|'def'
name|'image'
op|'('
name|'fname'
op|','
name|'image_type'
op|'='
name|'CONF'
op|'.'
name|'libvirt_images_type'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'image'
op|'('
name|'instance'
op|','
nl|'\n'
name|'fname'
op|'+'
name|'suffix'
op|','
name|'image_type'
op|')'
newline|'\n'
nl|'\n'
DECL|function|raw
dedent|''
name|'def'
name|'raw'
op|'('
name|'fname'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'image'
op|'('
name|'fname'
op|','
name|'image_type'
op|'='
string|"'raw'"
op|')'
newline|'\n'
nl|'\n'
comment|'# ensure directories exist and are writable'
nl|'\n'
dedent|''
name|'fileutils'
op|'.'
name|'ensure_tree'
op|'('
name|'basepath'
op|'('
name|'suffix'
op|'='
string|"''"
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'Creating image'"
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(dprince): for rescue console.log may already exist... chown it.'
nl|'\n'
name|'self'
op|'.'
name|'_chown_console_log_for_instance'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(vish): No need add the suffix to console.log'
nl|'\n'
name|'libvirt_utils'
op|'.'
name|'write_to_file'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_get_console_log_path'
op|'('
name|'instance'
op|')'
op|','
string|"''"
op|','
number|'7'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'disk_images'
op|':'
newline|'\n'
indent|'            '
name|'disk_images'
op|'='
op|'{'
string|"'image_id'"
op|':'
name|'instance'
op|'['
string|"'image_ref'"
op|']'
op|','
nl|'\n'
string|"'kernel_id'"
op|':'
name|'instance'
op|'['
string|"'kernel_id'"
op|']'
op|','
nl|'\n'
string|"'ramdisk_id'"
op|':'
name|'instance'
op|'['
string|"'ramdisk_id'"
op|']'
op|'}'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'disk_images'
op|'['
string|"'kernel_id'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'fname'
op|'='
name|'imagecache'
op|'.'
name|'get_cache_fname'
op|'('
name|'disk_images'
op|','
string|"'kernel_id'"
op|')'
newline|'\n'
name|'raw'
op|'('
string|"'kernel'"
op|')'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'libvirt_utils'
op|'.'
name|'fetch_image'
op|','
nl|'\n'
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'filename'
op|'='
name|'fname'
op|','
nl|'\n'
name|'image_id'
op|'='
name|'disk_images'
op|'['
string|"'kernel_id'"
op|']'
op|','
nl|'\n'
name|'user_id'
op|'='
name|'instance'
op|'['
string|"'user_id'"
op|']'
op|','
nl|'\n'
name|'project_id'
op|'='
name|'instance'
op|'['
string|"'project_id'"
op|']'
op|')'
newline|'\n'
name|'if'
name|'disk_images'
op|'['
string|"'ramdisk_id'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'fname'
op|'='
name|'imagecache'
op|'.'
name|'get_cache_fname'
op|'('
name|'disk_images'
op|','
string|"'ramdisk_id'"
op|')'
newline|'\n'
name|'raw'
op|'('
string|"'ramdisk'"
op|')'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'libvirt_utils'
op|'.'
name|'fetch_image'
op|','
nl|'\n'
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'filename'
op|'='
name|'fname'
op|','
nl|'\n'
name|'image_id'
op|'='
name|'disk_images'
op|'['
string|"'ramdisk_id'"
op|']'
op|','
nl|'\n'
name|'user_id'
op|'='
name|'instance'
op|'['
string|"'user_id'"
op|']'
op|','
nl|'\n'
name|'project_id'
op|'='
name|'instance'
op|'['
string|"'project_id'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'inst_type'
op|'='
name|'flavors'
op|'.'
name|'extract_flavor'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(ndipanov): Even if disk_mapping was passed in, which'
nl|'\n'
comment|"# currently happens only on rescue - we still don't want to"
nl|'\n'
comment|'# create a base image.'
nl|'\n'
name|'if'
name|'not'
name|'booted_from_volume'
op|':'
newline|'\n'
indent|'            '
name|'root_fname'
op|'='
name|'imagecache'
op|'.'
name|'get_cache_fname'
op|'('
name|'disk_images'
op|','
string|"'image_id'"
op|')'
newline|'\n'
name|'size'
op|'='
name|'instance'
op|'['
string|"'root_gb'"
op|']'
op|'*'
number|'1024'
op|'*'
number|'1024'
op|'*'
number|'1024'
newline|'\n'
nl|'\n'
name|'if'
name|'size'
op|'=='
number|'0'
name|'or'
name|'suffix'
op|'=='
string|"'.rescue'"
op|':'
newline|'\n'
indent|'                '
name|'size'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'image'
op|'('
string|"'disk'"
op|')'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'libvirt_utils'
op|'.'
name|'fetch_image'
op|','
nl|'\n'
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'filename'
op|'='
name|'root_fname'
op|','
nl|'\n'
name|'size'
op|'='
name|'size'
op|','
nl|'\n'
name|'image_id'
op|'='
name|'disk_images'
op|'['
string|"'image_id'"
op|']'
op|','
nl|'\n'
name|'user_id'
op|'='
name|'instance'
op|'['
string|"'user_id'"
op|']'
op|','
nl|'\n'
name|'project_id'
op|'='
name|'instance'
op|'['
string|"'project_id'"
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Lookup the filesystem type if required'
nl|'\n'
dedent|''
name|'os_type_with_default'
op|'='
name|'instance'
op|'['
string|"'os_type'"
op|']'
newline|'\n'
name|'if'
name|'not'
name|'os_type_with_default'
op|':'
newline|'\n'
indent|'            '
name|'os_type_with_default'
op|'='
string|"'default'"
newline|'\n'
nl|'\n'
dedent|''
name|'ephemeral_gb'
op|'='
name|'instance'
op|'['
string|"'ephemeral_gb'"
op|']'
newline|'\n'
name|'if'
string|"'disk.local'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'            '
name|'disk_image'
op|'='
name|'image'
op|'('
string|"'disk.local'"
op|')'
newline|'\n'
name|'fn'
op|'='
name|'functools'
op|'.'
name|'partial'
op|'('
name|'self'
op|'.'
name|'_create_ephemeral'
op|','
nl|'\n'
name|'fs_label'
op|'='
string|"'ephemeral0'"
op|','
nl|'\n'
name|'os_type'
op|'='
name|'instance'
op|'['
string|'"os_type"'
op|']'
op|','
nl|'\n'
name|'is_block_dev'
op|'='
name|'disk_image'
op|'.'
name|'is_block_dev'
op|')'
newline|'\n'
name|'fname'
op|'='
string|'"ephemeral_%s_%s"'
op|'%'
op|'('
name|'ephemeral_gb'
op|','
name|'os_type_with_default'
op|')'
newline|'\n'
name|'size'
op|'='
name|'ephemeral_gb'
op|'*'
number|'1024'
op|'*'
number|'1024'
op|'*'
number|'1024'
newline|'\n'
name|'disk_image'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'fn'
op|','
nl|'\n'
name|'filename'
op|'='
name|'fname'
op|','
nl|'\n'
name|'size'
op|'='
name|'size'
op|','
nl|'\n'
name|'ephemeral_size'
op|'='
name|'ephemeral_gb'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'idx'
op|','
name|'eph'
name|'in'
name|'enumerate'
op|'('
name|'driver'
op|'.'
name|'block_device_info_get_ephemerals'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'disk_image'
op|'='
name|'image'
op|'('
name|'blockinfo'
op|'.'
name|'get_eph_disk'
op|'('
name|'idx'
op|')'
op|')'
newline|'\n'
name|'fn'
op|'='
name|'functools'
op|'.'
name|'partial'
op|'('
name|'self'
op|'.'
name|'_create_ephemeral'
op|','
nl|'\n'
name|'fs_label'
op|'='
string|"'ephemeral%d'"
op|'%'
name|'idx'
op|','
nl|'\n'
name|'os_type'
op|'='
name|'instance'
op|'['
string|'"os_type"'
op|']'
op|','
nl|'\n'
name|'is_block_dev'
op|'='
name|'disk_image'
op|'.'
name|'is_block_dev'
op|')'
newline|'\n'
name|'size'
op|'='
name|'eph'
op|'['
string|"'size'"
op|']'
op|'*'
number|'1024'
op|'*'
number|'1024'
op|'*'
number|'1024'
newline|'\n'
name|'fname'
op|'='
string|'"ephemeral_%s_%s"'
op|'%'
op|'('
name|'eph'
op|'['
string|"'size'"
op|']'
op|','
name|'os_type_with_default'
op|')'
newline|'\n'
name|'disk_image'
op|'.'
name|'cache'
op|'('
nl|'\n'
name|'fetch_func'
op|'='
name|'fn'
op|','
nl|'\n'
name|'filename'
op|'='
name|'fname'
op|','
nl|'\n'
name|'size'
op|'='
name|'size'
op|','
nl|'\n'
name|'ephemeral_size'
op|'='
name|'eph'
op|'['
string|"'size'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
string|"'disk.swap'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'            '
name|'mapping'
op|'='
name|'disk_mapping'
op|'['
string|"'disk.swap'"
op|']'
newline|'\n'
name|'swap_mb'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'swap'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_swap'
op|'('
name|'block_device_info'
op|')'
newline|'\n'
name|'if'
name|'driver'
op|'.'
name|'swap_is_usable'
op|'('
name|'swap'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'swap_mb'
op|'='
name|'swap'
op|'['
string|"'swap_size'"
op|']'
newline|'\n'
dedent|''
name|'elif'
op|'('
name|'inst_type'
op|'['
string|"'swap'"
op|']'
op|'>'
number|'0'
name|'and'
nl|'\n'
name|'not'
name|'block_device'
op|'.'
name|'volume_in_mapping'
op|'('
nl|'\n'
name|'mapping'
op|'['
string|"'dev'"
op|']'
op|','
name|'block_device_info'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'swap_mb'
op|'='
name|'inst_type'
op|'['
string|"'swap'"
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'swap_mb'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'size'
op|'='
name|'swap_mb'
op|'*'
number|'1024'
op|'*'
number|'1024'
newline|'\n'
name|'image'
op|'('
string|"'disk.swap'"
op|')'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'self'
op|'.'
name|'_create_swap'
op|','
nl|'\n'
name|'filename'
op|'='
string|'"swap_%s"'
op|'%'
name|'swap_mb'
op|','
nl|'\n'
name|'size'
op|'='
name|'size'
op|','
nl|'\n'
name|'swap_mb'
op|'='
name|'swap_mb'
op|')'
newline|'\n'
nl|'\n'
comment|'# Config drive'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'configdrive'
op|'.'
name|'required_by'
op|'('
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'Using config drive'"
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'extra_md'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'if'
name|'admin_pass'
op|':'
newline|'\n'
indent|'                '
name|'extra_md'
op|'['
string|"'admin_pass'"
op|']'
op|'='
name|'admin_pass'
newline|'\n'
nl|'\n'
dedent|''
name|'inst_md'
op|'='
name|'instance_metadata'
op|'.'
name|'InstanceMetadata'
op|'('
name|'instance'
op|','
nl|'\n'
name|'content'
op|'='
name|'files'
op|','
name|'extra_md'
op|'='
name|'extra_md'
op|','
name|'network_info'
op|'='
name|'network_info'
op|')'
newline|'\n'
name|'with'
name|'configdrive'
op|'.'
name|'ConfigDriveBuilder'
op|'('
name|'instance_md'
op|'='
name|'inst_md'
op|')'
name|'as'
name|'cdb'
op|':'
newline|'\n'
indent|'                '
name|'configdrive_path'
op|'='
name|'basepath'
op|'('
name|'fname'
op|'='
string|"'disk.config'"
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'Creating config drive at %(path)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'path'"
op|':'
name|'configdrive_path'
op|'}'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'cdb'
op|'.'
name|'make_drive'
op|'('
name|'configdrive_path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'processutils'
op|'.'
name|'ProcessExecutionError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                    '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|"'Creating config drive failed '"
nl|'\n'
string|"'with error: %s'"
op|')'
op|','
nl|'\n'
name|'e'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# File injection only if needed'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'elif'
name|'inject_files'
name|'and'
name|'CONF'
op|'.'
name|'libvirt_inject_partition'
op|'!='
op|'-'
number|'2'
op|':'
newline|'\n'
indent|'            '
name|'target_partition'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'not'
name|'instance'
op|'['
string|"'kernel_id'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'target_partition'
op|'='
name|'CONF'
op|'.'
name|'libvirt_inject_partition'
newline|'\n'
name|'if'
name|'target_partition'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'target_partition'
op|'='
name|'None'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|"'lxc'"
op|':'
newline|'\n'
indent|'                '
name|'target_partition'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt_inject_key'
name|'and'
name|'instance'
op|'['
string|"'key_data'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'key'
op|'='
name|'str'
op|'('
name|'instance'
op|'['
string|"'key_data'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'key'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'net'
op|'='
name|'netutils'
op|'.'
name|'get_injected_network_template'
op|'('
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
name|'metadata'
op|'='
name|'instance'
op|'.'
name|'get'
op|'('
string|"'metadata'"
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'CONF'
op|'.'
name|'libvirt_inject_password'
op|':'
newline|'\n'
indent|'                '
name|'admin_pass'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'any'
op|'('
op|'('
name|'key'
op|','
name|'net'
op|','
name|'metadata'
op|','
name|'admin_pass'
op|','
name|'files'
op|')'
op|')'
op|':'
newline|'\n'
comment|"# If we're not using config_drive, inject into root fs"
nl|'\n'
indent|'                '
name|'injection_path'
op|'='
name|'image'
op|'('
string|"'disk'"
op|')'
op|'.'
name|'path'
newline|'\n'
name|'img_id'
op|'='
name|'instance'
op|'['
string|"'image_ref'"
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'inj'
op|','
name|'val'
name|'in'
op|'['
op|'('
string|"'key'"
op|','
name|'key'
op|')'
op|','
nl|'\n'
op|'('
string|"'net'"
op|','
name|'net'
op|')'
op|','
nl|'\n'
op|'('
string|"'metadata'"
op|','
name|'metadata'
op|')'
op|','
nl|'\n'
op|'('
string|"'admin_pass'"
op|','
name|'admin_pass'
op|')'
op|','
nl|'\n'
op|'('
string|"'files'"
op|','
name|'files'
op|')'
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'val'
op|':'
newline|'\n'
indent|'                        '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'Injecting %(inj)s into image '"
nl|'\n'
string|"'%(img_id)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'inj'"
op|':'
name|'inj'
op|','
string|"'img_id'"
op|':'
name|'img_id'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'disk'
op|'.'
name|'inject_data'
op|'('
name|'injection_path'
op|','
nl|'\n'
name|'key'
op|','
name|'net'
op|','
name|'metadata'
op|','
name|'admin_pass'
op|','
name|'files'
op|','
nl|'\n'
name|'partition'
op|'='
name|'target_partition'
op|','
nl|'\n'
name|'use_cow'
op|'='
name|'CONF'
op|'.'
name|'use_cow_images'
op|','
nl|'\n'
name|'mandatory'
op|'='
op|'('
string|"'files'"
op|','
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                    '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|"'Error injecting data into image '"
nl|'\n'
string|"'%(img_id)s (%(e)s)'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'img_id'"
op|':'
name|'img_id'
op|','
string|"'e'"
op|':'
name|'e'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|"'uml'"
op|':'
newline|'\n'
indent|'            '
name|'libvirt_utils'
op|'.'
name|'chown'
op|'('
name|'image'
op|'('
string|"'disk'"
op|')'
op|'.'
name|'path'
op|','
string|"'root'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|_prepare_pci_devices_for_use
dedent|''
dedent|''
name|'def'
name|'_prepare_pci_devices_for_use'
op|'('
name|'self'
op|','
name|'pci_devices'
op|')'
op|':'
newline|'\n'
comment|'# kvm , qemu support managed mode'
nl|'\n'
comment|'# In managed mode, the configured device will be automatically'
nl|'\n'
comment|'# detached from the host OS drivers when the guest is started,'
nl|'\n'
comment|'# and then re-attached when the guest shuts down.'
nl|'\n'
indent|'        '
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
name|'not'
name|'in'
op|'('
string|"'xen'"
op|')'
op|':'
newline|'\n'
comment|'# we do manual detach only for xen'
nl|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'dev'
name|'in'
name|'pci_devices'
op|':'
newline|'\n'
indent|'                '
name|'libvirt_dev_addr'
op|'='
name|'dev'
op|'['
string|"'hypervisor_name'"
op|']'
newline|'\n'
name|'libvirt_dev'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'nodeDeviceLookupByName'
op|'('
name|'libvirt_dev_addr'
op|')'
newline|'\n'
comment|"# Note(yjiang5) Spelling for 'dettach' is correct, see"
nl|'\n'
comment|'# http://libvirt.org/html/libvirt-libvirt.html.'
nl|'\n'
name|'libvirt_dev'
op|'.'
name|'dettach'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Note(yjiang5): A reset of one PCI device may impact other'
nl|'\n'
comment|'# devices on the same bus, thus we need two separated loops'
nl|'\n'
comment|'# to detach and then reset it.'
nl|'\n'
dedent|''
name|'for'
name|'dev'
name|'in'
name|'pci_devices'
op|':'
newline|'\n'
indent|'                '
name|'libvirt_dev_addr'
op|'='
name|'dev'
op|'['
string|"'hypervisor_name'"
op|']'
newline|'\n'
name|'libvirt_dev'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'nodeDeviceLookupByName'
op|'('
name|'libvirt_dev_addr'
op|')'
newline|'\n'
name|'libvirt_dev'
op|'.'
name|'reset'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'PciDevicePrepareFailed'
op|'('
name|'id'
op|'='
name|'dev'
op|'['
string|"'id'"
op|']'
op|','
nl|'\n'
name|'instance_uuid'
op|'='
nl|'\n'
name|'dev'
op|'['
string|"'instance_uuid'"
op|']'
op|','
nl|'\n'
name|'reason'
op|'='
name|'str'
op|'('
name|'exc'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_detach_pci_devices
dedent|''
dedent|''
name|'def'
name|'_detach_pci_devices'
op|'('
name|'self'
op|','
name|'dom'
op|','
name|'pci_devs'
op|')'
op|':'
newline|'\n'
nl|'\n'
comment|'# for libvirt version < 1.1.1, this is race condition'
nl|'\n'
comment|'# so forbid detach if not had this version'
nl|'\n'
indent|'        '
name|'if'
name|'not'
name|'self'
op|'.'
name|'has_min_version'
op|'('
name|'MIN_LIBVIRT_DEVICE_CALLBACK_VERSION'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'pci_devs'
op|':'
newline|'\n'
indent|'                '
name|'reason'
op|'='
op|'('
name|'_'
op|'('
string|'"Detaching PCI devices with libvirt < %(ver)s"'
nl|'\n'
string|'" is not permitted"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'ver'"
op|':'
name|'MIN_LIBVIRT_DEVICE_CALLBACK_VERSION'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'PciDeviceDetachFailed'
op|'('
name|'reason'
op|'='
name|'reason'
op|','
nl|'\n'
name|'dev'
op|'='
name|'pci_devs'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'dev'
name|'in'
name|'pci_devs'
op|':'
newline|'\n'
indent|'                '
name|'dom'
op|'.'
name|'detachDeviceFlags'
op|'('
name|'self'
op|'.'
name|'get_guest_pci_device'
op|'('
name|'dev'
op|')'
op|'.'
name|'to_xml'
op|'('
op|')'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_AFFECT_LIVE'
op|')'
newline|'\n'
comment|'# after detachDeviceFlags returned, we should check the dom to'
nl|'\n'
comment|'# ensure the detaching is finished'
nl|'\n'
name|'xml'
op|'='
name|'dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
name|'xml_doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
name|'guest_config'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuest'
op|'('
op|')'
newline|'\n'
name|'guest_config'
op|'.'
name|'parse_dom'
op|'('
name|'xml_doc'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'hdev'
name|'in'
op|'['
name|'d'
name|'for'
name|'d'
name|'in'
name|'guest_config'
op|'.'
name|'devices'
nl|'\n'
name|'if'
name|'d'
op|'.'
name|'type'
op|'=='
string|"'pci'"
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'hdbsf'
op|'='
op|'['
name|'hdev'
op|'.'
name|'domain'
op|','
name|'hdev'
op|'.'
name|'bus'
op|','
name|'hdev'
op|'.'
name|'slot'
op|','
name|'hdev'
op|'.'
name|'function'
op|']'
newline|'\n'
name|'dbsf'
op|'='
name|'pci_utils'
op|'.'
name|'parse_address'
op|'('
name|'dev'
op|'['
string|"'address'"
op|']'
op|')'
newline|'\n'
name|'if'
op|'['
name|'int'
op|'('
name|'x'
op|','
number|'16'
op|')'
name|'for'
name|'x'
name|'in'
name|'hdbsf'
op|']'
op|'=='
op|'['
name|'int'
op|'('
name|'x'
op|','
number|'16'
op|')'
name|'for'
name|'x'
name|'in'
name|'dbsf'
op|']'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
name|'exception'
op|'.'
name|'PciDeviceDetachFailed'
op|'('
name|'reason'
op|'='
nl|'\n'
string|'"timeout"'
op|','
nl|'\n'
name|'dev'
op|'='
name|'dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_DOMAIN'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|'"Instance disappeared while detaching "'
nl|'\n'
string|'"a PCI device from it."'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
nl|'\n'
DECL|member|_attach_pci_devices
dedent|''
dedent|''
dedent|''
name|'def'
name|'_attach_pci_devices'
op|'('
name|'self'
op|','
name|'dom'
op|','
name|'pci_devs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'dev'
name|'in'
name|'pci_devs'
op|':'
newline|'\n'
indent|'                '
name|'dom'
op|'.'
name|'attachDevice'
op|'('
name|'self'
op|'.'
name|'get_guest_pci_device'
op|'('
name|'dev'
op|')'
op|'.'
name|'to_xml'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|"'Attaching PCI devices %(dev)s to %(dom)s failed.'"
op|')'
nl|'\n'
op|'%'
op|'{'
string|"'dev'"
op|':'
name|'pci_devs'
op|','
string|"'dom'"
op|':'
name|'dom'
op|'.'
name|'ID'
op|'('
op|')'
op|'}'
op|')'
newline|'\n'
name|'raise'
newline|'\n'
nl|'\n'
DECL|member|get_host_capabilities
dedent|''
dedent|''
name|'def'
name|'get_host_capabilities'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns an instance of config.LibvirtConfigCaps representing\n           the capabilities of the host.\n        """'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_caps'
op|':'
newline|'\n'
indent|'            '
name|'xmlstr'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'getCapabilities'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_caps'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigCaps'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_caps'
op|'.'
name|'parse_str'
op|'('
name|'xmlstr'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_caps'
newline|'\n'
nl|'\n'
DECL|member|get_host_uuid
dedent|''
name|'def'
name|'get_host_uuid'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns a UUID representing the host."""'
newline|'\n'
name|'caps'
op|'='
name|'self'
op|'.'
name|'get_host_capabilities'
op|'('
op|')'
newline|'\n'
name|'return'
name|'caps'
op|'.'
name|'host'
op|'.'
name|'uuid'
newline|'\n'
nl|'\n'
DECL|member|get_host_cpu_for_guest
dedent|''
name|'def'
name|'get_host_cpu_for_guest'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns an instance of config.LibvirtConfigGuestCPU\n           representing the host\'s CPU model & topology with\n           policy for configuring a guest to match\n        """'
newline|'\n'
nl|'\n'
name|'caps'
op|'='
name|'self'
op|'.'
name|'get_host_capabilities'
op|'('
op|')'
newline|'\n'
name|'hostcpu'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
newline|'\n'
name|'guestcpu'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPU'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'guestcpu'
op|'.'
name|'model'
op|'='
name|'hostcpu'
op|'.'
name|'model'
newline|'\n'
name|'guestcpu'
op|'.'
name|'vendor'
op|'='
name|'hostcpu'
op|'.'
name|'vendor'
newline|'\n'
name|'guestcpu'
op|'.'
name|'arch'
op|'='
name|'hostcpu'
op|'.'
name|'arch'
newline|'\n'
nl|'\n'
name|'guestcpu'
op|'.'
name|'match'
op|'='
string|'"exact"'
newline|'\n'
nl|'\n'
name|'for'
name|'hostfeat'
name|'in'
name|'hostcpu'
op|'.'
name|'features'
op|':'
newline|'\n'
indent|'            '
name|'guestfeat'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPUFeature'
op|'('
name|'hostfeat'
op|'.'
name|'name'
op|')'
newline|'\n'
name|'guestfeat'
op|'.'
name|'policy'
op|'='
string|'"require"'
newline|'\n'
name|'guestcpu'
op|'.'
name|'features'
op|'.'
name|'append'
op|'('
name|'guestfeat'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'guestcpu'
newline|'\n'
nl|'\n'
DECL|member|get_guest_cpu_config
dedent|''
name|'def'
name|'get_guest_cpu_config'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'mode'
op|'='
name|'CONF'
op|'.'
name|'libvirt_cpu_mode'
newline|'\n'
name|'model'
op|'='
name|'CONF'
op|'.'
name|'libvirt_cpu_model'
newline|'\n'
nl|'\n'
name|'if'
name|'mode'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|'"kvm"'
name|'or'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|'"qemu"'
op|':'
newline|'\n'
indent|'                '
name|'mode'
op|'='
string|'"host-model"'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'mode'
op|'='
string|'"none"'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'mode'
op|'=='
string|'"none"'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'!='
string|'"kvm"'
name|'and'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'!='
string|'"qemu"'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|'"Config requested an explicit CPU model, but "'
nl|'\n'
string|'"the current libvirt hypervisor \'%s\' does not "'
nl|'\n'
string|'"support selecting CPU models"'
op|')'
op|'%'
name|'CONF'
op|'.'
name|'libvirt_type'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'mode'
op|'=='
string|'"custom"'
name|'and'
name|'model'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|'"Config requested a custom CPU model, but no "'
nl|'\n'
string|'"model name was provided"'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'msg'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'mode'
op|'!='
string|'"custom"'
name|'and'
name|'model'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|'"A CPU model name should not be set when a "'
nl|'\n'
string|'"host CPU model is requested"'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"CPU mode \'%(mode)s\' model \'%(model)s\' was chosen"'
op|')'
nl|'\n'
op|'%'
op|'{'
string|"'mode'"
op|':'
name|'mode'
op|','
string|"'model'"
op|':'
op|'('
name|'model'
name|'or'
string|'""'
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(berrange): in the future, when MIN_LIBVIRT_VERSION is'
nl|'\n'
comment|'# updated to be at least this new, we can kill off the elif'
nl|'\n'
comment|'# blocks here'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'has_min_version'
op|'('
name|'MIN_LIBVIRT_HOST_CPU_VERSION'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'cpu'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPU'
op|'('
op|')'
newline|'\n'
name|'cpu'
op|'.'
name|'mode'
op|'='
name|'mode'
newline|'\n'
name|'cpu'
op|'.'
name|'model'
op|'='
name|'model'
newline|'\n'
dedent|''
name|'elif'
name|'mode'
op|'=='
string|'"custom"'
op|':'
newline|'\n'
indent|'            '
name|'cpu'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPU'
op|'('
op|')'
newline|'\n'
name|'cpu'
op|'.'
name|'model'
op|'='
name|'model'
newline|'\n'
dedent|''
name|'elif'
name|'mode'
op|'=='
string|'"host-model"'
op|':'
newline|'\n'
indent|'            '
name|'cpu'
op|'='
name|'self'
op|'.'
name|'get_host_cpu_for_guest'
op|'('
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'mode'
op|'=='
string|'"host-passthrough"'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|'"Passthrough of the host CPU was requested but "'
nl|'\n'
string|'"this libvirt version does not support this feature"'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'cpu'
newline|'\n'
nl|'\n'
DECL|member|get_guest_disk_config
dedent|''
name|'def'
name|'get_guest_disk_config'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'name'
op|','
name|'disk_mapping'
op|','
name|'inst_type'
op|','
nl|'\n'
name|'image_type'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'image'
op|'='
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'image'
op|'('
name|'instance'
op|','
nl|'\n'
name|'name'
op|','
nl|'\n'
name|'image_type'
op|')'
newline|'\n'
name|'disk_info'
op|'='
name|'disk_mapping'
op|'['
name|'name'
op|']'
newline|'\n'
name|'return'
name|'image'
op|'.'
name|'libvirt_info'
op|'('
name|'disk_info'
op|'['
string|"'bus'"
op|']'
op|','
nl|'\n'
name|'disk_info'
op|'['
string|"'dev'"
op|']'
op|','
nl|'\n'
name|'disk_info'
op|'['
string|"'type'"
op|']'
op|','
nl|'\n'
name|'self'
op|'.'
name|'disk_cachemode'
op|','
nl|'\n'
name|'inst_type'
op|'['
string|"'extra_specs'"
op|']'
op|','
nl|'\n'
name|'self'
op|'.'
name|'get_hypervisor_version'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_guest_storage_config
dedent|''
name|'def'
name|'get_guest_storage_config'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'disk_info'
op|','
nl|'\n'
name|'rescue'
op|','
name|'block_device_info'
op|','
nl|'\n'
name|'inst_type'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'devices'
op|'='
op|'['
op|']'
newline|'\n'
name|'disk_mapping'
op|'='
name|'disk_info'
op|'['
string|"'mapping'"
op|']'
newline|'\n'
nl|'\n'
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|'"lxc"'
op|':'
newline|'\n'
indent|'            '
name|'fs'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestFilesys'
op|'('
op|')'
newline|'\n'
name|'fs'
op|'.'
name|'source_type'
op|'='
string|'"mount"'
newline|'\n'
name|'fs'
op|'.'
name|'source_dir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
nl|'\n'
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
op|','
string|"'rootfs'"
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'fs'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
nl|'\n'
indent|'            '
name|'if'
name|'rescue'
op|':'
newline|'\n'
indent|'                '
name|'diskrescue'
op|'='
name|'self'
op|'.'
name|'get_guest_disk_config'
op|'('
name|'instance'
op|','
nl|'\n'
string|"'disk.rescue'"
op|','
nl|'\n'
name|'disk_mapping'
op|','
nl|'\n'
name|'inst_type'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'diskrescue'
op|')'
newline|'\n'
nl|'\n'
name|'diskos'
op|'='
name|'self'
op|'.'
name|'get_guest_disk_config'
op|'('
name|'instance'
op|','
nl|'\n'
string|"'disk'"
op|','
nl|'\n'
name|'disk_mapping'
op|','
nl|'\n'
name|'inst_type'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'diskos'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'if'
string|"'disk'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'                    '
name|'diskos'
op|'='
name|'self'
op|'.'
name|'get_guest_disk_config'
op|'('
name|'instance'
op|','
nl|'\n'
string|"'disk'"
op|','
nl|'\n'
name|'disk_mapping'
op|','
nl|'\n'
name|'inst_type'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'diskos'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
string|"'disk.local'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'                    '
name|'disklocal'
op|'='
name|'self'
op|'.'
name|'get_guest_disk_config'
op|'('
name|'instance'
op|','
nl|'\n'
string|"'disk.local'"
op|','
nl|'\n'
name|'disk_mapping'
op|','
nl|'\n'
name|'inst_type'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'disklocal'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'virtapi'
op|'.'
name|'instance_update'
op|'('
nl|'\n'
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
op|','
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
op|'{'
string|"'default_ephemeral_device'"
op|':'
nl|'\n'
name|'block_device'
op|'.'
name|'prepend_dev'
op|'('
name|'disklocal'
op|'.'
name|'target_dev'
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'idx'
op|','
name|'eph'
name|'in'
name|'enumerate'
op|'('
nl|'\n'
name|'driver'
op|'.'
name|'block_device_info_get_ephemerals'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'diskeph'
op|'='
name|'self'
op|'.'
name|'get_guest_disk_config'
op|'('
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'blockinfo'
op|'.'
name|'get_eph_disk'
op|'('
name|'idx'
op|')'
op|','
nl|'\n'
name|'disk_mapping'
op|','
name|'inst_type'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'diskeph'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
string|"'disk.swap'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'                    '
name|'diskswap'
op|'='
name|'self'
op|'.'
name|'get_guest_disk_config'
op|'('
name|'instance'
op|','
nl|'\n'
string|"'disk.swap'"
op|','
nl|'\n'
name|'disk_mapping'
op|','
nl|'\n'
name|'inst_type'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'diskswap'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'virtapi'
op|'.'
name|'instance_update'
op|'('
nl|'\n'
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
op|','
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
op|'{'
string|"'default_swap_device'"
op|':'
name|'block_device'
op|'.'
name|'prepend_dev'
op|'('
nl|'\n'
name|'diskswap'
op|'.'
name|'target_dev'
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'vol'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'                    '
name|'connection_info'
op|'='
name|'vol'
op|'['
string|"'connection_info'"
op|']'
newline|'\n'
name|'vol_dev'
op|'='
name|'block_device'
op|'.'
name|'prepend_dev'
op|'('
name|'vol'
op|'['
string|"'mount_device'"
op|']'
op|')'
newline|'\n'
name|'info'
op|'='
name|'disk_mapping'
op|'['
name|'vol_dev'
op|']'
newline|'\n'
name|'cfg'
op|'='
name|'self'
op|'.'
name|'volume_driver_method'
op|'('
string|"'connect_volume'"
op|','
nl|'\n'
name|'connection_info'
op|','
nl|'\n'
name|'info'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'cfg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
string|"'disk.config'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'                '
name|'diskconfig'
op|'='
name|'self'
op|'.'
name|'get_guest_disk_config'
op|'('
name|'instance'
op|','
nl|'\n'
string|"'disk.config'"
op|','
nl|'\n'
name|'disk_mapping'
op|','
nl|'\n'
name|'inst_type'
op|','
nl|'\n'
string|"'raw'"
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'diskconfig'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'for'
name|'d'
name|'in'
name|'devices'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'set_cache_mode'
op|'('
name|'d'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'devices'
newline|'\n'
nl|'\n'
DECL|member|get_guest_config_sysinfo
dedent|''
name|'def'
name|'get_guest_config_sysinfo'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'sysinfo'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSysinfo'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'sysinfo'
op|'.'
name|'system_manufacturer'
op|'='
name|'version'
op|'.'
name|'vendor_string'
op|'('
op|')'
newline|'\n'
name|'sysinfo'
op|'.'
name|'system_product'
op|'='
name|'version'
op|'.'
name|'product_string'
op|'('
op|')'
newline|'\n'
name|'sysinfo'
op|'.'
name|'system_version'
op|'='
name|'version'
op|'.'
name|'version_string_with_package'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'sysinfo'
op|'.'
name|'system_serial'
op|'='
name|'self'
op|'.'
name|'get_host_uuid'
op|'('
op|')'
newline|'\n'
name|'sysinfo'
op|'.'
name|'system_uuid'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
nl|'\n'
name|'return'
name|'sysinfo'
newline|'\n'
nl|'\n'
DECL|member|get_guest_pci_device
dedent|''
name|'def'
name|'get_guest_pci_device'
op|'('
name|'self'
op|','
name|'pci_device'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'        '
name|'dbsf'
op|'='
name|'pci_utils'
op|'.'
name|'parse_address'
op|'('
name|'pci_device'
op|'['
string|"'address'"
op|']'
op|')'
newline|'\n'
name|'dev'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestHostdevPCI'
op|'('
op|')'
newline|'\n'
name|'dev'
op|'.'
name|'domain'
op|','
name|'dev'
op|'.'
name|'bus'
op|','
name|'dev'
op|'.'
name|'slot'
op|','
name|'dev'
op|'.'
name|'function'
op|'='
name|'dbsf'
newline|'\n'
nl|'\n'
comment|'# only kvm support managed mode'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
name|'in'
op|'('
string|"'xen'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'dev'
op|'.'
name|'managed'
op|'='
string|"'no'"
newline|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
name|'in'
op|'('
string|"'kvm'"
op|','
string|"'qemu'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'dev'
op|'.'
name|'managed'
op|'='
string|"'yes'"
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'dev'
newline|'\n'
nl|'\n'
DECL|member|get_guest_config
dedent|''
name|'def'
name|'get_guest_config'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'disk_info'
op|','
name|'rescue'
op|'='
name|'None'
op|','
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get config data for parameters.\n\n        :param rescue: optional dictionary that should contain the key\n            \'ramdisk_id\' if a ramdisk is needed for the rescue image and\n            \'kernel_id\' if a kernel is needed for the rescue image.\n        """'
newline|'\n'
nl|'\n'
name|'inst_type'
op|'='
name|'self'
op|'.'
name|'virtapi'
op|'.'
name|'instance_type_get'
op|'('
nl|'\n'
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
name|'read_deleted'
op|'='
string|"'yes'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'instance_type_id'"
op|']'
op|')'
newline|'\n'
name|'inst_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'disk_mapping'
op|'='
name|'disk_info'
op|'['
string|"'mapping'"
op|']'
newline|'\n'
nl|'\n'
name|'CONSOLE'
op|'='
string|'"console=tty0 console=ttyS0"'
newline|'\n'
nl|'\n'
name|'guest'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuest'
op|'('
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'virt_type'
op|'='
name|'CONF'
op|'.'
name|'libvirt_type'
newline|'\n'
name|'guest'
op|'.'
name|'name'
op|'='
name|'instance'
op|'['
string|"'name'"
op|']'
newline|'\n'
name|'guest'
op|'.'
name|'uuid'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'guest'
op|'.'
name|'memory'
op|'='
name|'inst_type'
op|'['
string|"'memory_mb'"
op|']'
op|'*'
number|'1024'
newline|'\n'
name|'guest'
op|'.'
name|'vcpus'
op|'='
name|'inst_type'
op|'['
string|"'vcpus'"
op|']'
newline|'\n'
name|'guest'
op|'.'
name|'cpuset'
op|'='
name|'CONF'
op|'.'
name|'vcpu_pin_set'
newline|'\n'
nl|'\n'
name|'quota_items'
op|'='
op|'['
string|"'cpu_shares'"
op|','
string|"'cpu_period'"
op|','
string|"'cpu_quota'"
op|']'
newline|'\n'
name|'for'
name|'key'
op|','
name|'value'
name|'in'
name|'inst_type'
op|'['
string|"'extra_specs'"
op|']'
op|'.'
name|'iteritems'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'scope'
op|'='
name|'key'
op|'.'
name|'split'
op|'('
string|"':'"
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'scope'
op|')'
op|'>'
number|'1'
name|'and'
name|'scope'
op|'['
number|'0'
op|']'
op|'=='
string|"'quota'"
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'scope'
op|'['
number|'1'
op|']'
name|'in'
name|'quota_items'
op|':'
newline|'\n'
indent|'                    '
name|'setattr'
op|'('
name|'guest'
op|','
name|'scope'
op|'['
number|'1'
op|']'
op|','
name|'value'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'guest'
op|'.'
name|'cpu'
op|'='
name|'self'
op|'.'
name|'get_guest_cpu_config'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
string|"'root'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'            '
name|'root_device_name'
op|'='
name|'block_device'
op|'.'
name|'prepend_dev'
op|'('
nl|'\n'
name|'disk_mapping'
op|'['
string|"'root'"
op|']'
op|'['
string|"'dev'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'root_device_name'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'root_device_name'
op|':'
newline|'\n'
comment|'# NOTE(yamahata):'
nl|'\n'
comment|'# for nova.api.ec2.cloud.CloudController.get_metadata()'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'virtapi'
op|'.'
name|'instance_update'
op|'('
nl|'\n'
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
op|','
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
op|'{'
string|"'root_device_name'"
op|':'
name|'root_device_name'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'guest'
op|'.'
name|'os_type'
op|'='
name|'vm_mode'
op|'.'
name|'get_from_instance'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'guest'
op|'.'
name|'os_type'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|'"lxc"'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_type'
op|'='
name|'vm_mode'
op|'.'
name|'EXE'
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|'"uml"'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_type'
op|'='
name|'vm_mode'
op|'.'
name|'UML'
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|'"xen"'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_type'
op|'='
name|'vm_mode'
op|'.'
name|'XEN'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_type'
op|'='
name|'vm_mode'
op|'.'
name|'HVM'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|'"xen"'
name|'and'
name|'guest'
op|'.'
name|'os_type'
op|'=='
name|'vm_mode'
op|'.'
name|'HVM'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'os_loader'
op|'='
name|'CONF'
op|'.'
name|'xen_hvmloader_path'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
name|'in'
op|'('
string|'"kvm"'
op|','
string|'"qemu"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'caps'
op|'='
name|'self'
op|'.'
name|'get_host_capabilities'
op|'('
op|')'
newline|'\n'
name|'if'
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'arch'
name|'in'
op|'('
string|'"i686"'
op|','
string|'"x86_64"'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'sysinfo'
op|'='
name|'self'
op|'.'
name|'get_guest_config_sysinfo'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'os_smbios'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSMBIOS'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|'"lxc"'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'os_type'
op|'='
name|'vm_mode'
op|'.'
name|'EXE'
newline|'\n'
name|'guest'
op|'.'
name|'os_init_path'
op|'='
string|'"/sbin/init"'
newline|'\n'
name|'guest'
op|'.'
name|'os_cmdline'
op|'='
name|'CONSOLE'
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|'"uml"'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'os_type'
op|'='
name|'vm_mode'
op|'.'
name|'UML'
newline|'\n'
name|'guest'
op|'.'
name|'os_kernel'
op|'='
string|'"/usr/bin/linux"'
newline|'\n'
name|'guest'
op|'.'
name|'os_root'
op|'='
name|'root_device_name'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|'"xen"'
name|'and'
name|'guest'
op|'.'
name|'os_type'
op|'=='
name|'vm_mode'
op|'.'
name|'XEN'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_root'
op|'='
name|'root_device_name'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_type'
op|'='
name|'vm_mode'
op|'.'
name|'HVM'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'rescue'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'rescue'
op|'.'
name|'get'
op|'('
string|"'kernel_id'"
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'guest'
op|'.'
name|'os_kernel'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_path'
op|','
string|'"kernel.rescue"'
op|')'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|'"xen"'
op|':'
newline|'\n'
indent|'                        '
name|'guest'
op|'.'
name|'os_cmdline'
op|'='
string|'"ro"'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'guest'
op|'.'
name|'os_cmdline'
op|'='
op|'('
string|'"root=%s %s"'
op|'%'
op|'('
name|'root_device_name'
op|','
nl|'\n'
name|'CONSOLE'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'rescue'
op|'.'
name|'get'
op|'('
string|"'ramdisk_id'"
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'guest'
op|'.'
name|'os_initrd'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_path'
op|','
string|'"ramdisk.rescue"'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'instance'
op|'['
string|"'kernel_id'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_kernel'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_path'
op|','
string|'"kernel"'
op|')'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|'"xen"'
op|':'
newline|'\n'
indent|'                    '
name|'guest'
op|'.'
name|'os_cmdline'
op|'='
string|'"ro"'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'guest'
op|'.'
name|'os_cmdline'
op|'='
op|'('
string|'"root=%s %s"'
op|'%'
op|'('
name|'root_device_name'
op|','
nl|'\n'
name|'CONSOLE'
op|')'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'instance'
op|'['
string|"'ramdisk_id'"
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'guest'
op|'.'
name|'os_initrd'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_path'
op|','
string|'"ramdisk"'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_boot_dev'
op|'='
string|'"hd"'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'!='
string|'"lxc"'
name|'and'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'!='
string|'"uml"'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'acpi'
op|'='
name|'True'
newline|'\n'
name|'guest'
op|'.'
name|'apic'
op|'='
name|'True'
newline|'\n'
nl|'\n'
comment|'# NOTE(mikal): Microsoft Windows expects the clock to be in'
nl|'\n'
comment|'# "localtime". If the clock is set to UTC, then you can use a'
nl|'\n'
comment|'# registry key to let windows know, but Microsoft says this is'
nl|'\n'
comment|'# buggy in http://support.microsoft.com/kb/2687252'
nl|'\n'
dedent|''
name|'clk'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestClock'
op|'('
op|')'
newline|'\n'
name|'if'
name|'instance'
op|'['
string|"'os_type'"
op|']'
op|'=='
string|"'windows'"
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'Configuring timezone for windows instance to '"
nl|'\n'
string|"'localtime'"
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'clk'
op|'.'
name|'offset'
op|'='
string|"'localtime'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'clk'
op|'.'
name|'offset'
op|'='
string|"'utc'"
newline|'\n'
dedent|''
name|'guest'
op|'.'
name|'set_clock'
op|'('
name|'clk'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|'"kvm"'
op|':'
newline|'\n'
comment|'# TODO(berrange) One day this should be per-guest'
nl|'\n'
comment|'# OS type configurable'
nl|'\n'
indent|'            '
name|'tmpit'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestTimer'
op|'('
op|')'
newline|'\n'
name|'tmpit'
op|'.'
name|'name'
op|'='
string|'"pit"'
newline|'\n'
name|'tmpit'
op|'.'
name|'tickpolicy'
op|'='
string|'"delay"'
newline|'\n'
nl|'\n'
name|'tmrtc'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestTimer'
op|'('
op|')'
newline|'\n'
name|'tmrtc'
op|'.'
name|'name'
op|'='
string|'"rtc"'
newline|'\n'
name|'tmrtc'
op|'.'
name|'tickpolicy'
op|'='
string|'"catchup"'
newline|'\n'
nl|'\n'
name|'clk'
op|'.'
name|'add_timer'
op|'('
name|'tmpit'
op|')'
newline|'\n'
name|'clk'
op|'.'
name|'add_timer'
op|'('
name|'tmrtc'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'cfg'
name|'in'
name|'self'
op|'.'
name|'get_guest_storage_config'
op|'('
name|'instance'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'disk_info'
op|','
nl|'\n'
name|'rescue'
op|','
nl|'\n'
name|'block_device_info'
op|','
nl|'\n'
name|'inst_type'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'cfg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
indent|'            '
name|'cfg'
op|'='
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'get_config'
op|'('
name|'instance'
op|','
nl|'\n'
name|'vif'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'inst_type'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'cfg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|'"qemu"'
name|'or'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|'"kvm"'
op|':'
newline|'\n'
comment|"# The QEMU 'pty' driver throws away any data if no"
nl|'\n'
comment|"# client app is connected. Thus we can't get away"
nl|'\n'
comment|'# with a single type=pty console. Instead we have'
nl|'\n'
comment|'# to configure two separate consoles.'
nl|'\n'
indent|'            '
name|'consolelog'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSerial'
op|'('
op|')'
newline|'\n'
name|'consolelog'
op|'.'
name|'type'
op|'='
string|'"file"'
newline|'\n'
name|'consolelog'
op|'.'
name|'source_path'
op|'='
name|'self'
op|'.'
name|'_get_console_log_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'consolelog'
op|')'
newline|'\n'
nl|'\n'
name|'consolepty'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSerial'
op|'('
op|')'
newline|'\n'
name|'consolepty'
op|'.'
name|'type'
op|'='
string|'"pty"'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'consolepty'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'consolepty'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestConsole'
op|'('
op|')'
newline|'\n'
name|'consolepty'
op|'.'
name|'type'
op|'='
string|'"pty"'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'consolepty'
op|')'
newline|'\n'
nl|'\n'
comment|'# We want a tablet if VNC is enabled,'
nl|'\n'
comment|'# or SPICE is enabled and the SPICE agent is disabled'
nl|'\n'
comment|'# NB: this implies that if both SPICE + VNC are enabled'
nl|'\n'
comment|"# at the same time, we'll get the tablet whether the"
nl|'\n'
comment|'# SPICE agent is used or not.'
nl|'\n'
dedent|''
name|'need_usb_tablet'
op|'='
name|'False'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'vnc_enabled'
op|':'
newline|'\n'
indent|'            '
name|'need_usb_tablet'
op|'='
name|'CONF'
op|'.'
name|'use_usb_tablet'
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'enabled'
name|'and'
name|'not'
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'agent_enabled'
op|':'
newline|'\n'
indent|'            '
name|'need_usb_tablet'
op|'='
name|'CONF'
op|'.'
name|'use_usb_tablet'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'need_usb_tablet'
name|'and'
name|'guest'
op|'.'
name|'os_type'
op|'=='
name|'vm_mode'
op|'.'
name|'HVM'
op|':'
newline|'\n'
indent|'            '
name|'tablet'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestInput'
op|'('
op|')'
newline|'\n'
name|'tablet'
op|'.'
name|'type'
op|'='
string|'"tablet"'
newline|'\n'
name|'tablet'
op|'.'
name|'bus'
op|'='
string|'"usb"'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'tablet'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'enabled'
name|'and'
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'agent_enabled'
name|'and'
name|'CONF'
op|'.'
name|'libvirt_type'
name|'not'
name|'in'
op|'('
string|"'lxc'"
op|','
string|"'uml'"
op|','
string|"'xen'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'channel'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestChannel'
op|'('
op|')'
newline|'\n'
name|'channel'
op|'.'
name|'target_name'
op|'='
string|'"com.redhat.spice.0"'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'channel'
op|')'
newline|'\n'
nl|'\n'
comment|'# NB some versions of libvirt support both SPICE and VNC'
nl|'\n'
comment|"# at the same time. We're not trying to second guess which"
nl|'\n'
comment|"# those versions are. We'll just let libvirt report the"
nl|'\n'
comment|'# errors appropriately if the user enables both.'
nl|'\n'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'vnc_enabled'
name|'and'
name|'CONF'
op|'.'
name|'libvirt_type'
name|'not'
name|'in'
op|'('
string|"'lxc'"
op|','
string|"'uml'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'graphics'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestGraphics'
op|'('
op|')'
newline|'\n'
name|'graphics'
op|'.'
name|'type'
op|'='
string|'"vnc"'
newline|'\n'
name|'graphics'
op|'.'
name|'keymap'
op|'='
name|'CONF'
op|'.'
name|'vnc_keymap'
newline|'\n'
name|'graphics'
op|'.'
name|'listen'
op|'='
name|'CONF'
op|'.'
name|'vncserver_listen'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'graphics'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'enabled'
name|'and'
name|'CONF'
op|'.'
name|'libvirt_type'
name|'not'
name|'in'
op|'('
string|"'lxc'"
op|','
string|"'uml'"
op|','
string|"'xen'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'graphics'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestGraphics'
op|'('
op|')'
newline|'\n'
name|'graphics'
op|'.'
name|'type'
op|'='
string|'"spice"'
newline|'\n'
name|'graphics'
op|'.'
name|'keymap'
op|'='
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'keymap'
newline|'\n'
name|'graphics'
op|'.'
name|'listen'
op|'='
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'server_listen'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'graphics'
op|')'
newline|'\n'
nl|'\n'
comment|"# Qemu guest agent only support 'qemu' and 'kvm' hypervisor"
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
name|'in'
op|'('
string|"'qemu'"
op|','
string|"'kvm'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'qga_enabled'
op|'='
name|'False'
newline|'\n'
comment|"# Enable qga only if the 'hw_qemu_guest_agent' property is set"
nl|'\n'
name|'if'
op|'('
name|'image_meta'
name|'is'
name|'not'
name|'None'
name|'and'
name|'image_meta'
op|'.'
name|'get'
op|'('
string|"'properties'"
op|')'
name|'and'
nl|'\n'
name|'image_meta'
op|'['
string|"'properties'"
op|']'
op|'.'
name|'get'
op|'('
string|"'hw_qemu_guest_agent'"
op|')'
nl|'\n'
name|'is'
name|'not'
name|'None'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'hw_qga'
op|'='
name|'image_meta'
op|'['
string|"'properties'"
op|']'
op|'['
string|"'hw_qemu_guest_agent'"
op|']'
newline|'\n'
name|'if'
name|'hw_qga'
op|'.'
name|'lower'
op|'('
op|')'
op|'=='
string|"'yes'"
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Qemu guest agent is enabled through image "'
nl|'\n'
string|'"metadata"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'qga_enabled'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'qga_enabled'
op|':'
newline|'\n'
indent|'                '
name|'qga'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestChannel'
op|'('
op|')'
newline|'\n'
name|'qga'
op|'.'
name|'type'
op|'='
string|'"unix"'
newline|'\n'
name|'qga'
op|'.'
name|'target_name'
op|'='
string|'"org.qemu.guest_agent.0"'
newline|'\n'
name|'qga'
op|'.'
name|'source_path'
op|'='
op|'('
string|'"/var/lib/libvirt/qemu/%s.%s.sock"'
op|'%'
nl|'\n'
op|'('
string|'"org.qemu.guest_agent.0"'
op|','
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'qga'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
name|'in'
op|'('
string|"'xen'"
op|','
string|"'qemu'"
op|','
string|"'kvm'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'pci_dev'
name|'in'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'self'
op|'.'
name|'get_guest_pci_device'
op|'('
name|'pci_dev'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'len'
op|'('
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|')'
op|')'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'PciDeviceUnsupportedHypervisor'
op|'('
nl|'\n'
name|'type'
op|'='
name|'CONF'
op|'.'
name|'libvirt_type'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'guest'
newline|'\n'
nl|'\n'
DECL|member|to_xml
dedent|''
name|'def'
name|'to_xml'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'image_meta'
op|'='
name|'None'
op|','
name|'rescue'
op|'='
name|'None'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'write_to_disk'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
comment|'# We should get image metadata every time for generating xml'
nl|'\n'
indent|'        '
name|'if'
name|'image_meta'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
op|'('
name|'image_service'
op|','
name|'image_id'
op|')'
op|'='
name|'glance'
op|'.'
name|'get_remote_image_service'
op|'('
nl|'\n'
name|'context'
op|','
name|'instance'
op|'['
string|"'image_ref'"
op|']'
op|')'
newline|'\n'
name|'image_meta'
op|'='
name|'compute_utils'
op|'.'
name|'get_image_metadata'
op|'('
nl|'\n'
name|'context'
op|','
name|'image_service'
op|','
name|'image_id'
op|','
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Start to_xml instance=%(instance)s '"
nl|'\n'
string|"'network_info=%(network_info)s '"
nl|'\n'
string|"'disk_info=%(disk_info)s '"
nl|'\n'
string|"'image_meta=%(image_meta)s rescue=%(rescue)s'"
nl|'\n'
string|"'block_device_info=%(block_device_info)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'instance'"
op|':'
name|'instance'
op|','
string|"'network_info'"
op|':'
name|'network_info'
op|','
nl|'\n'
string|"'disk_info'"
op|':'
name|'disk_info'
op|','
string|"'image_meta'"
op|':'
name|'image_meta'
op|','
nl|'\n'
string|"'rescue'"
op|':'
name|'rescue'
op|','
string|"'block_device_info'"
op|':'
name|'block_device_info'
op|'}'
op|')'
newline|'\n'
name|'conf'
op|'='
name|'self'
op|'.'
name|'get_guest_config'
op|'('
name|'instance'
op|','
name|'network_info'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'disk_info'
op|','
name|'rescue'
op|','
name|'block_device_info'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'conf'
op|'.'
name|'to_xml'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'write_to_disk'
op|':'
newline|'\n'
indent|'            '
name|'instance_dir'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'xml_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
string|"'libvirt.xml'"
op|')'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'write_to_file'
op|'('
name|'xml_path'
op|','
name|'xml'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'End to_xml instance=%(instance)s xml=%(xml)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'instance'"
op|':'
name|'instance'
op|','
string|"'xml'"
op|':'
name|'xml'
op|'}'
op|')'
newline|'\n'
name|'return'
name|'xml'
newline|'\n'
nl|'\n'
DECL|member|_lookup_by_id
dedent|''
name|'def'
name|'_lookup_by_id'
op|'('
name|'self'
op|','
name|'instance_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve libvirt domain object given an instance id.\n\n        All libvirt error handling should be handled in this method and\n        relevant nova exceptions should be raised in response.\n\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'lookupByID'
op|'('
name|'instance_id'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_DOMAIN'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|'('
name|'instance_id'
op|'='
name|'instance_id'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|'"Error from libvirt while looking up %(instance_id)s: "'
nl|'\n'
string|'"[Error Code %(error_code)s] %(ex)s"'
op|')'
nl|'\n'
op|'%'
op|'{'
string|"'instance_id'"
op|':'
name|'instance_id'
op|','
nl|'\n'
string|"'error_code'"
op|':'
name|'error_code'
op|','
nl|'\n'
string|"'ex'"
op|':'
name|'ex'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_lookup_by_name
dedent|''
dedent|''
name|'def'
name|'_lookup_by_name'
op|'('
name|'self'
op|','
name|'instance_name'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve libvirt domain object given an instance name.\n\n        All libvirt error handling should be handled in this method and\n        relevant nova exceptions should be raised in response.\n\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'lookupByName'
op|'('
name|'instance_name'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_DOMAIN'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|'('
name|'instance_id'
op|'='
name|'instance_name'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|"'Error from libvirt while looking up %(instance_name)s: '"
nl|'\n'
string|"'[Error Code %(error_code)s] %(ex)s'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'instance_name'"
op|':'
name|'instance_name'
op|','
nl|'\n'
string|"'error_code'"
op|':'
name|'error_code'
op|','
nl|'\n'
string|"'ex'"
op|':'
name|'ex'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_info
dedent|''
dedent|''
name|'def'
name|'get_info'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve information from libvirt for a specific instance name.\n\n        If a libvirt error is encountered during lookup, we might raise a\n        NotFound exception or Error exception depending on how severe the\n        libvirt error is.\n\n        """'
newline|'\n'
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
op|'('
name|'state'
op|','
name|'max_mem'
op|','
name|'mem'
op|','
name|'num_cpu'
op|','
name|'cpu_time'
op|')'
op|'='
name|'virt_dom'
op|'.'
name|'info'
op|'('
op|')'
newline|'\n'
name|'return'
op|'{'
string|"'state'"
op|':'
name|'LIBVIRT_POWER_STATE'
op|'['
name|'state'
op|']'
op|','
nl|'\n'
string|"'max_mem'"
op|':'
name|'max_mem'
op|','
nl|'\n'
string|"'mem'"
op|':'
name|'mem'
op|','
nl|'\n'
string|"'num_cpu'"
op|':'
name|'num_cpu'
op|','
nl|'\n'
string|"'cpu_time'"
op|':'
name|'cpu_time'
op|','
nl|'\n'
string|"'id'"
op|':'
name|'virt_dom'
op|'.'
name|'ID'
op|'('
op|')'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|_create_domain
dedent|''
name|'def'
name|'_create_domain'
op|'('
name|'self'
op|','
name|'xml'
op|'='
name|'None'
op|','
name|'domain'
op|'='
name|'None'
op|','
nl|'\n'
name|'instance'
op|'='
name|'None'
op|','
name|'launch_flags'
op|'='
number|'0'
op|','
name|'power_on'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a domain.\n\n        Either domain or xml must be passed in. If both are passed, then\n        the domain definition is overwritten from the xml.\n        """'
newline|'\n'
name|'inst_path'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'instance'
op|':'
newline|'\n'
indent|'            '
name|'inst_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|"'lxc'"
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'inst_path'
op|':'
newline|'\n'
indent|'                '
name|'inst_path'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'container_dir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_path'
op|','
string|"'rootfs'"
op|')'
newline|'\n'
name|'fileutils'
op|'.'
name|'ensure_tree'
op|'('
name|'container_dir'
op|')'
newline|'\n'
name|'image'
op|'='
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'image'
op|'('
name|'instance'
op|','
string|"'disk'"
op|')'
newline|'\n'
name|'disk'
op|'.'
name|'setup_container'
op|'('
name|'image'
op|'.'
name|'path'
op|','
nl|'\n'
name|'container_dir'
op|'='
name|'container_dir'
op|','
nl|'\n'
name|'use_cow'
op|'='
name|'CONF'
op|'.'
name|'use_cow_images'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'xml'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'domain'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'defineXML'
op|'('
name|'xml'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|'"An error occurred while trying to define a domain"'
nl|'\n'
string|'" with xml: %s"'
op|')'
op|'%'
name|'xml'
op|')'
newline|'\n'
name|'raise'
name|'e'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'power_on'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'domain'
op|'.'
name|'createWithFlags'
op|'('
name|'launch_flags'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|'"An error occurred while trying to launch a "'
nl|'\n'
string|'"defined domain with xml: %s"'
op|')'
op|'%'
nl|'\n'
name|'domain'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_enable_hairpin'
op|'('
name|'domain'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|'"An error occurred while enabling hairpin mode on "'
nl|'\n'
string|'"domain with xml: %s"'
op|')'
op|'%'
name|'domain'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(uni): Now the container is running with its own private mount'
nl|'\n'
comment|'# namespace and so there is no need to keep the container rootfs'
nl|'\n'
comment|'# mounted in the host namespace'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|"'lxc'"
op|':'
newline|'\n'
indent|'            '
name|'state'
op|'='
name|'self'
op|'.'
name|'get_info'
op|'('
name|'instance'
op|')'
op|'['
string|"'state'"
op|']'
newline|'\n'
name|'container_dir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_path'
op|','
string|"'rootfs'"
op|')'
newline|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
indent|'                '
name|'disk'
op|'.'
name|'clean_lxc_namespace'
op|'('
name|'container_dir'
op|'='
name|'container_dir'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'disk'
op|'.'
name|'teardown_container'
op|'('
name|'container_dir'
op|'='
name|'container_dir'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'domain'
newline|'\n'
nl|'\n'
DECL|member|_create_domain_and_network
dedent|''
name|'def'
name|'_create_domain_and_network'
op|'('
name|'self'
op|','
name|'xml'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'power_on'
op|'='
name|'True'
op|','
nl|'\n'
name|'context'
op|'='
name|'None'
op|','
name|'reboot'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'        '
string|'"""Do required network setup and create domain."""'
newline|'\n'
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'vol'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'            '
name|'connection_info'
op|'='
name|'vol'
op|'['
string|"'connection_info'"
op|']'
newline|'\n'
name|'disk_dev'
op|'='
name|'vol'
op|'['
string|"'mount_device'"
op|']'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_info_from_bdm'
op|'('
name|'CONF'
op|'.'
name|'libvirt_type'
op|','
name|'vol'
op|')'
newline|'\n'
name|'conf'
op|'='
name|'self'
op|'.'
name|'volume_driver_method'
op|'('
string|"'connect_volume'"
op|','
nl|'\n'
name|'connection_info'
op|','
nl|'\n'
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
comment|'# cache device_path in connection_info -- required by encryptors'
nl|'\n'
name|'if'
op|'('
name|'not'
name|'reboot'
name|'and'
string|"'data'"
name|'in'
name|'connection_info'
name|'and'
nl|'\n'
string|"'volume_id'"
name|'in'
name|'connection_info'
op|'['
string|"'data'"
op|']'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'connection_info'
op|'['
string|"'data'"
op|']'
op|'['
string|"'device_path'"
op|']'
op|'='
name|'conf'
op|'.'
name|'source_path'
newline|'\n'
name|'self'
op|'.'
name|'virtapi'
op|'.'
name|'block_device_mapping_update'
op|'('
name|'context'
op|','
name|'vol'
op|'.'
name|'id'
op|','
nl|'\n'
op|'{'
string|"'connection_info'"
op|':'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
name|'connection_info'
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'volume_id'
op|'='
name|'connection_info'
op|'['
string|"'data'"
op|']'
op|'['
string|"'volume_id'"
op|']'
newline|'\n'
name|'encryption'
op|'='
name|'encryptors'
op|'.'
name|'get_encryption_metadata'
op|'('
name|'context'
op|','
name|'volume_id'
op|','
nl|'\n'
name|'connection_info'
op|')'
newline|'\n'
name|'if'
name|'encryption'
op|':'
newline|'\n'
indent|'                    '
name|'encryptor'
op|'='
name|'self'
op|'.'
name|'_get_volume_encryptor'
op|'('
name|'connection_info'
op|','
nl|'\n'
name|'encryption'
op|')'
newline|'\n'
name|'encryptor'
op|'.'
name|'attach_volume'
op|'('
name|'context'
op|','
op|'**'
name|'encryption'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'self'
op|'.'
name|'plug_vifs'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'setup_basic_filtering'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'prepare_instance_filter'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'domain'
op|'='
name|'self'
op|'.'
name|'_create_domain'
op|'('
name|'xml'
op|','
name|'instance'
op|'='
name|'instance'
op|','
name|'power_on'
op|'='
name|'power_on'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'apply_instance_filter'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'return'
name|'domain'
newline|'\n'
nl|'\n'
DECL|member|get_all_block_devices
dedent|''
name|'def'
name|'get_all_block_devices'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Return all block devices in use on this node.\n        """'
newline|'\n'
name|'devices'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'dom_id'
name|'in'
name|'self'
op|'.'
name|'list_instance_ids'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'domain'
op|'='
name|'self'
op|'.'
name|'_lookup_by_id'
op|'('
name|'dom_id'
op|')'
newline|'\n'
name|'doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'domain'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"libvirt can\'t find a domain with id: %s"'
op|')'
op|'%'
name|'dom_id'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'ret'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
string|"'./devices/disk'"
op|')'
newline|'\n'
name|'for'
name|'node'
name|'in'
name|'ret'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'node'
op|'.'
name|'get'
op|'('
string|"'type'"
op|')'
op|'!='
string|"'block'"
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'for'
name|'child'
name|'in'
name|'node'
op|'.'
name|'getchildren'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'child'
op|'.'
name|'tag'
op|'=='
string|"'source'"
op|':'
newline|'\n'
indent|'                        '
name|'devices'
op|'.'
name|'append'
op|'('
name|'child'
op|'.'
name|'get'
op|'('
string|"'dev'"
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'return'
name|'devices'
newline|'\n'
nl|'\n'
DECL|member|get_disks
dedent|''
name|'def'
name|'get_disks'
op|'('
name|'self'
op|','
name|'instance_name'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Note that this function takes an instance name.\n\n        Returns a list of all block devices for this domain.\n        """'
newline|'\n'
name|'domain'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance_name'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'domain'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'['
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'filter'
op|'('
name|'bool'
op|','
nl|'\n'
op|'['
name|'target'
op|'.'
name|'get'
op|'('
string|'"dev"'
op|')'
nl|'\n'
name|'for'
name|'target'
name|'in'
name|'doc'
op|'.'
name|'findall'
op|'('
string|"'devices/disk/target'"
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_interfaces
dedent|''
name|'def'
name|'get_interfaces'
op|'('
name|'self'
op|','
name|'xml'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Note that this function takes a domain xml.\n\n        Returns a list of all network interfaces for this instance.\n        """'
newline|'\n'
name|'doc'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'['
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'interfaces'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'ret'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
string|"'./devices/interface'"
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'node'
name|'in'
name|'ret'
op|':'
newline|'\n'
indent|'            '
name|'devdst'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'for'
name|'child'
name|'in'
name|'list'
op|'('
name|'node'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'child'
op|'.'
name|'tag'
op|'=='
string|"'target'"
op|':'
newline|'\n'
indent|'                    '
name|'devdst'
op|'='
name|'child'
op|'.'
name|'attrib'
op|'['
string|"'dev'"
op|']'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'devdst'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'interfaces'
op|'.'
name|'append'
op|'('
name|'devdst'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'interfaces'
newline|'\n'
nl|'\n'
DECL|member|_get_cpuset_ids
dedent|''
name|'def'
name|'_get_cpuset_ids'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Parsing vcpu_pin_set config.\n\n        Returns a list of pcpu ids can be used by instances.\n        """'
newline|'\n'
name|'cpuset_ids'
op|'='
name|'set'
op|'('
op|')'
newline|'\n'
name|'cpuset_reject_ids'
op|'='
name|'set'
op|'('
op|')'
newline|'\n'
name|'for'
name|'rule'
name|'in'
name|'CONF'
op|'.'
name|'vcpu_pin_set'
op|'.'
name|'split'
op|'('
string|"','"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'rule'
op|'='
name|'rule'
op|'.'
name|'strip'
op|'('
op|')'
newline|'\n'
comment|"# Handle multi ','"
nl|'\n'
name|'if'
name|'len'
op|'('
name|'rule'
op|')'
op|'<'
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
comment|'# Note the count limit in the .split() call'
nl|'\n'
dedent|''
name|'range_parts'
op|'='
name|'rule'
op|'.'
name|'split'
op|'('
string|"'-'"
op|','
number|'1'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'range_parts'
op|')'
op|'>'
number|'1'
op|':'
newline|'\n'
comment|'# So, this was a range; start by converting the parts to ints'
nl|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'start'
op|','
name|'end'
op|'='
op|'['
name|'int'
op|'('
name|'p'
op|'.'
name|'strip'
op|'('
op|')'
op|')'
name|'for'
name|'p'
name|'in'
name|'range_parts'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'_'
op|'('
string|'"Invalid range expression %r"'
op|')'
nl|'\n'
op|'%'
name|'rule'
op|')'
newline|'\n'
comment|"# Make sure it's a valid range"
nl|'\n'
dedent|''
name|'if'
name|'start'
op|'>'
name|'end'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'_'
op|'('
string|'"Invalid range expression %r"'
op|')'
nl|'\n'
op|'%'
name|'rule'
op|')'
newline|'\n'
comment|'# Add available pcpu ids to set'
nl|'\n'
dedent|''
name|'cpuset_ids'
op|'|='
name|'set'
op|'('
name|'range'
op|'('
name|'start'
op|','
name|'end'
op|'+'
number|'1'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'rule'
op|'['
number|'0'
op|']'
op|'=='
string|"'^'"
op|':'
newline|'\n'
comment|'# Not a range, the rule is an exclusion rule; convert to int'
nl|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'cpuset_reject_ids'
op|'.'
name|'add'
op|'('
name|'int'
op|'('
name|'rule'
op|'['
number|'1'
op|':'
op|']'
op|'.'
name|'strip'
op|'('
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'_'
op|'('
string|'"Invalid exclusion "'
nl|'\n'
string|'"expression %r"'
op|')'
op|'%'
name|'rule'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# OK, a single PCPU to include; convert to int'
nl|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'cpuset_ids'
op|'.'
name|'add'
op|'('
name|'int'
op|'('
name|'rule'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'_'
op|'('
string|'"Invalid inclusion "'
nl|'\n'
string|'"expression %r"'
op|')'
op|'%'
name|'rule'
op|')'
newline|'\n'
comment|'# Use sets to handle the exclusion rules for us'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'cpuset_ids'
op|'-='
name|'cpuset_reject_ids'
newline|'\n'
name|'if'
name|'not'
name|'cpuset_ids'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'_'
op|'('
string|'"No CPUs available after parsing %r"'
op|')'
op|'%'
nl|'\n'
name|'CONF'
op|'.'
name|'vcpu_pin_set'
op|')'
newline|'\n'
comment|'# This will convert the set to a sorted list for us'
nl|'\n'
dedent|''
name|'return'
name|'sorted'
op|'('
name|'cpuset_ids'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_vcpu_total
dedent|''
name|'def'
name|'get_vcpu_total'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get available vcpu number of physical computer.\n\n        :returns: the number of cpu core instances can be used.\n\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_vcpu_total'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'_vcpu_total'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'total_pcpus'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'getInfo'
op|'('
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|'"Cannot get the number of cpu, because this "'
nl|'\n'
string|'"function is not implemented for this platform. "'
op|')'
op|')'
newline|'\n'
name|'return'
number|'0'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'vcpu_pin_set'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_vcpu_total'
op|'='
name|'total_pcpus'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_vcpu_total'
newline|'\n'
nl|'\n'
dedent|''
name|'available_ids'
op|'='
name|'self'
op|'.'
name|'_get_cpuset_ids'
op|'('
op|')'
newline|'\n'
name|'if'
name|'available_ids'
op|'['
op|'-'
number|'1'
op|']'
op|'>='
name|'total_pcpus'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'_'
op|'('
string|'"Invalid vcpu_pin_set config, "'
nl|'\n'
string|'"out of hypervisor cpu range."'
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_vcpu_total'
op|'='
name|'len'
op|'('
name|'available_ids'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_vcpu_total'
newline|'\n'
nl|'\n'
DECL|member|get_memory_mb_total
dedent|''
name|'def'
name|'get_memory_mb_total'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the total memory size(MB) of physical computer.\n\n        :returns: the total amount of memory(MB).\n\n        """'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'getInfo'
op|'('
op|')'
op|'['
number|'1'
op|']'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|get_local_gb_info
name|'def'
name|'get_local_gb_info'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get local storage info of the compute node in GB.\n\n        :returns: A dict containing:\n             :total: How big the overall usable filesystem is (in gigabytes)\n             :free: How much space is free (in gigabytes)\n             :used: How much space is used (in gigabytes)\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt_images_type'
op|'=='
string|"'lvm'"
op|':'
newline|'\n'
indent|'            '
name|'info'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_volume_group_info'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt_images_volume_group'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'info'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_fs_info'
op|'('
name|'CONF'
op|'.'
name|'instances_path'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
op|'('
name|'k'
op|','
name|'v'
op|')'
name|'in'
name|'info'
op|'.'
name|'iteritems'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'info'
op|'['
name|'k'
op|']'
op|'='
name|'v'
op|'/'
op|'('
number|'1024'
op|'**'
number|'3'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'info'
newline|'\n'
nl|'\n'
DECL|member|get_vcpu_used
dedent|''
name|'def'
name|'get_vcpu_used'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get vcpu usage number of physical computer.\n\n        :returns: The total number of vcpu that currently used.\n\n        """'
newline|'\n'
nl|'\n'
name|'total'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|"'lxc'"
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'total'
op|'+'
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'dom_ids'
op|'='
name|'self'
op|'.'
name|'list_instance_ids'
op|'('
op|')'
newline|'\n'
name|'for'
name|'dom_id'
name|'in'
name|'dom_ids'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_id'
op|'('
name|'dom_id'
op|')'
newline|'\n'
name|'vcpus'
op|'='
name|'dom'
op|'.'
name|'vcpus'
op|'('
op|')'
newline|'\n'
name|'if'
name|'vcpus'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"couldn\'t obtain the vpu count from domain id:"'
nl|'\n'
string|'" %s"'
op|')'
op|'%'
name|'dom_id'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'total'
op|'+='
name|'len'
op|'('
name|'vcpus'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"libvirt can\'t find a domain with id: %s"'
op|')'
op|'%'
name|'dom_id'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
comment|'# NOTE(gtt116): give change to do other task.'
nl|'\n'
dedent|''
name|'greenthread'
op|'.'
name|'sleep'
op|'('
number|'0'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'total'
newline|'\n'
nl|'\n'
DECL|member|get_memory_mb_used
dedent|''
name|'def'
name|'get_memory_mb_used'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the free memory size(MB) of physical computer.\n\n        :returns: the total usage of memory(MB).\n\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'sys'
op|'.'
name|'platform'
op|'.'
name|'upper'
op|'('
op|')'
name|'not'
name|'in'
op|'['
string|"'LINUX2'"
op|','
string|"'LINUX3'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'return'
number|'0'
newline|'\n'
nl|'\n'
dedent|''
name|'m'
op|'='
name|'open'
op|'('
string|"'/proc/meminfo'"
op|')'
op|'.'
name|'read'
op|'('
op|')'
op|'.'
name|'split'
op|'('
op|')'
newline|'\n'
name|'idx1'
op|'='
name|'m'
op|'.'
name|'index'
op|'('
string|"'MemFree:'"
op|')'
newline|'\n'
name|'idx2'
op|'='
name|'m'
op|'.'
name|'index'
op|'('
string|"'Buffers:'"
op|')'
newline|'\n'
name|'idx3'
op|'='
name|'m'
op|'.'
name|'index'
op|'('
string|"'Cached:'"
op|')'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|"'xen'"
op|':'
newline|'\n'
indent|'            '
name|'used'
op|'='
number|'0'
newline|'\n'
name|'for'
name|'domain_id'
name|'in'
name|'self'
op|'.'
name|'list_instance_ids'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'dom_mem'
op|'='
name|'int'
op|'('
name|'self'
op|'.'
name|'_lookup_by_id'
op|'('
name|'domain_id'
op|')'
op|'.'
name|'info'
op|'('
op|')'
op|'['
number|'2'
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"libvirt can\'t find a domain with id: %s"'
op|')'
nl|'\n'
op|'%'
name|'domain_id'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
comment|'# skip dom0'
nl|'\n'
dedent|''
name|'if'
name|'domain_id'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'used'
op|'+='
name|'dom_mem'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# the mem reported by dom0 is be greater of what'
nl|'\n'
comment|'# it is being used'
nl|'\n'
indent|'                    '
name|'used'
op|'+='
op|'('
name|'dom_mem'
op|'-'
nl|'\n'
op|'('
name|'int'
op|'('
name|'m'
op|'['
name|'idx1'
op|'+'
number|'1'
op|']'
op|')'
op|'+'
nl|'\n'
name|'int'
op|'('
name|'m'
op|'['
name|'idx2'
op|'+'
number|'1'
op|']'
op|')'
op|'+'
nl|'\n'
name|'int'
op|'('
name|'m'
op|'['
name|'idx3'
op|'+'
number|'1'
op|']'
op|')'
op|')'
op|')'
newline|'\n'
comment|'# Convert it to MB'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'used'
op|'/'
number|'1024'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'avail'
op|'='
op|'('
name|'int'
op|'('
name|'m'
op|'['
name|'idx1'
op|'+'
number|'1'
op|']'
op|')'
op|'+'
name|'int'
op|'('
name|'m'
op|'['
name|'idx2'
op|'+'
number|'1'
op|']'
op|')'
op|'+'
name|'int'
op|'('
name|'m'
op|'['
name|'idx3'
op|'+'
number|'1'
op|']'
op|')'
op|')'
newline|'\n'
comment|'# Convert it to MB'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'get_memory_mb_total'
op|'('
op|')'
op|'-'
name|'avail'
op|'/'
number|'1024'
newline|'\n'
nl|'\n'
DECL|member|get_hypervisor_type
dedent|''
dedent|''
name|'def'
name|'get_hypervisor_type'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get hypervisor type.\n\n        :returns: hypervisor type (ex. qemu)\n\n        """'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'getType'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_hypervisor_version
dedent|''
name|'def'
name|'get_hypervisor_version'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get hypervisor version.\n\n        :returns: hypervisor version (ex. 12003)\n\n        """'
newline|'\n'
nl|'\n'
comment|'# NOTE(justinsb): getVersion moved between libvirt versions'
nl|'\n'
comment|'# Trying to do be compatible with older versions is a lost cause'
nl|'\n'
comment|'# But ... we can at least give the user a nice message'
nl|'\n'
name|'method'
op|'='
name|'getattr'
op|'('
name|'self'
op|'.'
name|'_conn'
op|','
string|"'getVersion'"
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'method'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'_'
op|'('
string|'"libvirt version is too old"'
nl|'\n'
string|'" (does not support getVersion)"'
op|')'
op|')'
newline|'\n'
comment|'# NOTE(justinsb): If we wanted to get the version, we could:'
nl|'\n'
comment|"# method = getattr(libvirt, 'getVersion', None)"
nl|'\n'
comment|'# NOTE(justinsb): This would then rely on a proper version check'
nl|'\n'
nl|'\n'
dedent|''
name|'return'
name|'method'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_hypervisor_hostname
dedent|''
name|'def'
name|'get_hypervisor_hostname'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns the hostname of the hypervisor."""'
newline|'\n'
name|'hostname'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'getHostname'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
name|'hasattr'
op|'('
name|'self'
op|','
string|"'_hypervisor_hostname'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_hypervisor_hostname'
op|'='
name|'hostname'
newline|'\n'
dedent|''
name|'elif'
name|'hostname'
op|'!='
name|'self'
op|'.'
name|'_hypervisor_hostname'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|"'Hostname has changed from %(old)s '"
nl|'\n'
string|"'to %(new)s. A restart is required to take effect.'"
nl|'\n'
op|')'
op|'%'
op|'{'
string|"'old'"
op|':'
name|'self'
op|'.'
name|'_hypervisor_hostname'
op|','
nl|'\n'
string|"'new'"
op|':'
name|'hostname'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_hypervisor_hostname'
newline|'\n'
nl|'\n'
DECL|member|get_instance_capabilities
dedent|''
name|'def'
name|'get_instance_capabilities'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get hypervisor instance capabilities\n\n        Returns a list of tuples that describe instances the\n        hypervisor is capable of hosting.  Each tuple consists\n        of the triplet (arch, hypervisor_type, vm_mode).\n\n        :returns: List of tuples describing instance capabilities\n        """'
newline|'\n'
name|'caps'
op|'='
name|'self'
op|'.'
name|'get_host_capabilities'
op|'('
op|')'
newline|'\n'
name|'instance_caps'
op|'='
name|'list'
op|'('
op|')'
newline|'\n'
name|'for'
name|'g'
name|'in'
name|'caps'
op|'.'
name|'guests'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'dt'
name|'in'
name|'g'
op|'.'
name|'domtype'
op|':'
newline|'\n'
indent|'                '
name|'instance_cap'
op|'='
op|'('
name|'g'
op|'.'
name|'arch'
op|','
name|'dt'
op|','
name|'g'
op|'.'
name|'ostype'
op|')'
newline|'\n'
name|'instance_caps'
op|'.'
name|'append'
op|'('
name|'instance_cap'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'instance_caps'
newline|'\n'
nl|'\n'
DECL|member|get_cpu_info
dedent|''
name|'def'
name|'get_cpu_info'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get cpuinfo information.\n\n        Obtains cpu feature from virConnect.getCapabilities,\n        and returns as a json string.\n\n        :return: see above description\n\n        """'
newline|'\n'
nl|'\n'
name|'caps'
op|'='
name|'self'
op|'.'
name|'get_host_capabilities'
op|'('
op|')'
newline|'\n'
name|'cpu_info'
op|'='
name|'dict'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'cpu_info'
op|'['
string|"'arch'"
op|']'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'arch'
newline|'\n'
name|'cpu_info'
op|'['
string|"'model'"
op|']'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'model'
newline|'\n'
name|'cpu_info'
op|'['
string|"'vendor'"
op|']'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'vendor'
newline|'\n'
nl|'\n'
name|'topology'
op|'='
name|'dict'
op|'('
op|')'
newline|'\n'
name|'topology'
op|'['
string|"'sockets'"
op|']'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'sockets'
newline|'\n'
name|'topology'
op|'['
string|"'cores'"
op|']'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'cores'
newline|'\n'
name|'topology'
op|'['
string|"'threads'"
op|']'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'threads'
newline|'\n'
name|'cpu_info'
op|'['
string|"'topology'"
op|']'
op|'='
name|'topology'
newline|'\n'
nl|'\n'
name|'features'
op|'='
name|'list'
op|'('
op|')'
newline|'\n'
name|'for'
name|'f'
name|'in'
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'features'
op|':'
newline|'\n'
indent|'            '
name|'features'
op|'.'
name|'append'
op|'('
name|'f'
op|'.'
name|'name'
op|')'
newline|'\n'
dedent|''
name|'cpu_info'
op|'['
string|"'features'"
op|']'
op|'='
name|'features'
newline|'\n'
nl|'\n'
comment|'# TODO(berrange): why do we bother converting the'
nl|'\n'
comment|'# libvirt capabilities XML into a special JSON format ?'
nl|'\n'
comment|'# The data format is different across all the drivers'
nl|'\n'
comment|'# so we could just return the raw capabilities XML'
nl|'\n'
comment|"# which 'compare_cpu' could use directly"
nl|'\n'
comment|'#'
nl|'\n'
comment|'# That said, arch_filter.py now seems to rely on'
nl|'\n'
comment|'# the libvirt drivers format which suggests this'
nl|'\n'
comment|'# data format needs to be standardized across drivers'
nl|'\n'
name|'return'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
name|'cpu_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_pcidev_info
dedent|''
name|'def'
name|'_get_pcidev_info'
op|'('
name|'self'
op|','
name|'devname'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns a dict of PCI device."""'
newline|'\n'
nl|'\n'
DECL|function|_get_device_type
name|'def'
name|'_get_device_type'
op|'('
name|'cfgdev'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Get a PCI device\'s device type.\n\n            An assignable PCI device can be a normal PCI device,\n            a SR-IOV Physical Function (PF), or a SR-IOV Virtual\n            Function (VF). Only normal PCI devices or SR-IOV VFs\n            are assignable, while SR-IOV PFs are always owned by\n            hypervisor.\n\n            Please notice that a PCI device with SR-IOV\n            capability but not enabled is reported as normal PCI device.\n            """'
newline|'\n'
name|'for'
name|'fun_cap'
name|'in'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'fun_capability'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'len'
op|'('
name|'fun_cap'
op|'.'
name|'device_addrs'
op|')'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'fun_cap'
op|'.'
name|'type'
op|'=='
string|"'virt_functions'"
op|':'
newline|'\n'
indent|'                        '
name|'return'
op|'{'
string|"'dev_type'"
op|':'
string|"'type-PF'"
op|'}'
newline|'\n'
dedent|''
name|'if'
name|'fun_cap'
op|'.'
name|'type'
op|'=='
string|"'phys_function'"
op|':'
newline|'\n'
indent|'                        '
name|'return'
op|'{'
string|"'dev_type'"
op|':'
string|"'type-VF'"
op|','
nl|'\n'
string|"'phys_function'"
op|':'
name|'fun_cap'
op|'.'
name|'device_addrs'
op|'}'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
op|'{'
string|"'dev_type'"
op|':'
string|"'type-PCI'"
op|'}'
newline|'\n'
nl|'\n'
dedent|''
name|'virtdev'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'nodeDeviceLookupByName'
op|'('
name|'devname'
op|')'
newline|'\n'
name|'xmlstr'
op|'='
name|'virtdev'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
name|'cfgdev'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigNodeDevice'
op|'('
op|')'
newline|'\n'
name|'cfgdev'
op|'.'
name|'parse_str'
op|'('
name|'xmlstr'
op|')'
newline|'\n'
nl|'\n'
name|'address'
op|'='
string|'"%04x:%02x:%02x.%1x"'
op|'%'
op|'('
nl|'\n'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'domain'
op|','
nl|'\n'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'bus'
op|','
nl|'\n'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'slot'
op|','
nl|'\n'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'function'
op|')'
newline|'\n'
nl|'\n'
name|'device'
op|'='
op|'{'
nl|'\n'
string|'"dev_id"'
op|':'
name|'cfgdev'
op|'.'
name|'name'
op|','
nl|'\n'
string|'"address"'
op|':'
name|'address'
op|','
nl|'\n'
string|'"product_id"'
op|':'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'product_id'
op|'['
number|'2'
op|':'
number|'6'
op|']'
op|','
nl|'\n'
string|'"vendor_id"'
op|':'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'vendor_id'
op|'['
number|'2'
op|':'
number|'6'
op|']'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
comment|'#requirement by DataBase Model'
nl|'\n'
name|'device'
op|'['
string|"'label'"
op|']'
op|'='
string|"'label_%(vendor_id)s_%(product_id)s'"
op|'%'
name|'device'
newline|'\n'
name|'device'
op|'.'
name|'update'
op|'('
name|'_get_device_type'
op|'('
name|'cfgdev'
op|')'
op|')'
newline|'\n'
name|'return'
name|'device'
newline|'\n'
nl|'\n'
DECL|member|_pci_device_assignable
dedent|''
name|'def'
name|'_pci_device_assignable'
op|'('
name|'self'
op|','
name|'device'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'device'
op|'['
string|"'dev_type'"
op|']'
op|'=='
string|"'type-PF'"
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'dev_filter'
op|'.'
name|'device_assignable'
op|'('
name|'device'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_pci_passthrough_devices
dedent|''
name|'def'
name|'get_pci_passthrough_devices'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get host pci devices information.\n\n        Obtains pci devices information from libvirt, and returns\n        as a json string.\n\n        Each device information is a dictionary, with mandatory keys\n        of \'address\', \'vendor_id\', \'product_id\', \'dev_type\', \'dev_id\',\n        \'label\' and other optional device specific information.\n\n        Refer to the objects/pci_device.py for more idea of these keys.\n\n        :returns: a list of the assignable pci devices information\n        """'
newline|'\n'
name|'pci_info'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'dev_names'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'listDevices'
op|'('
string|"'pci'"
op|','
number|'0'
op|')'
name|'or'
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'name'
name|'in'
name|'dev_names'
op|':'
newline|'\n'
indent|'            '
name|'pci_dev'
op|'='
name|'self'
op|'.'
name|'_get_pcidev_info'
op|'('
name|'name'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_pci_device_assignable'
op|'('
name|'pci_dev'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'pci_info'
op|'.'
name|'append'
op|'('
name|'pci_dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
name|'pci_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_all_volume_usage
dedent|''
name|'def'
name|'get_all_volume_usage'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'compute_host_bdms'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return usage info for volumes attached to vms on\n           a given host.\n        """'
newline|'\n'
name|'vol_usage'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'instance_bdms'
name|'in'
name|'compute_host_bdms'
op|':'
newline|'\n'
indent|'            '
name|'instance'
op|'='
name|'instance_bdms'
op|'['
string|"'instance'"
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'bdm'
name|'in'
name|'instance_bdms'
op|'['
string|"'instance_bdms'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'vol_stats'
op|'='
op|'['
op|']'
newline|'\n'
name|'mountpoint'
op|'='
name|'bdm'
op|'['
string|"'device_name'"
op|']'
newline|'\n'
name|'if'
name|'mountpoint'
op|'.'
name|'startswith'
op|'('
string|"'/dev/'"
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'mountpoint'
op|'='
name|'mountpoint'
op|'['
number|'5'
op|':'
op|']'
newline|'\n'
dedent|''
name|'volume_id'
op|'='
name|'bdm'
op|'['
string|"'volume_id'"
op|']'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Trying to get stats for the volume %s"'
op|')'
op|','
nl|'\n'
name|'volume_id'
op|')'
newline|'\n'
name|'vol_stats'
op|'='
name|'self'
op|'.'
name|'block_stats'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|','
name|'mountpoint'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'vol_stats'
op|':'
newline|'\n'
indent|'                    '
name|'stats'
op|'='
name|'dict'
op|'('
name|'volume'
op|'='
name|'volume_id'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|','
nl|'\n'
name|'rd_req'
op|'='
name|'vol_stats'
op|'['
number|'0'
op|']'
op|','
nl|'\n'
name|'rd_bytes'
op|'='
name|'vol_stats'
op|'['
number|'1'
op|']'
op|','
nl|'\n'
name|'wr_req'
op|'='
name|'vol_stats'
op|'['
number|'2'
op|']'
op|','
nl|'\n'
name|'wr_bytes'
op|'='
name|'vol_stats'
op|'['
number|'3'
op|']'
op|','
nl|'\n'
name|'flush_operations'
op|'='
name|'vol_stats'
op|'['
number|'4'
op|']'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
nl|'\n'
name|'_'
op|'('
string|'"Got volume usage stats for the volume=%(volume)s,"'
nl|'\n'
string|'" instance=%(instance)s, rd_req=%(rd_req)d,"'
nl|'\n'
string|'" rd_bytes=%(rd_bytes)d, wr_req=%(wr_req)d,"'
nl|'\n'
string|'" wr_bytes=%(wr_bytes)d"'
op|')'
nl|'\n'
op|'%'
name|'stats'
op|')'
newline|'\n'
name|'vol_usage'
op|'.'
name|'append'
op|'('
name|'stats'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'vol_usage'
newline|'\n'
nl|'\n'
DECL|member|block_stats
dedent|''
name|'def'
name|'block_stats'
op|'('
name|'self'
op|','
name|'instance_name'
op|','
name|'disk'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Note that this function takes an instance name.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'domain'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance_name'
op|')'
newline|'\n'
name|'return'
name|'domain'
op|'.'
name|'blockStats'
op|'('
name|'disk'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'errcode'
op|'='
name|'e'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'Getting block stats failed, device might have '"
nl|'\n'
string|"'been detached. Instance=%(instance_name)s '"
nl|'\n'
string|"'Disk=%(disk)s Code=%(errcode)s Error=%(e)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'instance_name'"
op|':'
name|'instance_name'
op|','
string|"'disk'"
op|':'
name|'disk'
op|','
nl|'\n'
string|"'errcode'"
op|':'
name|'errcode'
op|','
string|"'e'"
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'Could not find domain in libvirt for instance %s. '"
nl|'\n'
string|"'Cannot get block stats for device'"
op|')'
op|','
name|'instance_name'
op|')'
newline|'\n'
nl|'\n'
DECL|member|interface_stats
dedent|''
dedent|''
name|'def'
name|'interface_stats'
op|'('
name|'self'
op|','
name|'instance_name'
op|','
name|'interface'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Note that this function takes an instance name.\n        """'
newline|'\n'
name|'domain'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance_name'
op|')'
newline|'\n'
name|'return'
name|'domain'
op|'.'
name|'interfaceStats'
op|'('
name|'interface'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_console_pool_info
dedent|''
name|'def'
name|'get_console_pool_info'
op|'('
name|'self'
op|','
name|'console_type'
op|')'
op|':'
newline|'\n'
comment|'#TODO(mdragon): console proxy should be implemented for libvirt,'
nl|'\n'
comment|'#               in case someone wants to use it with kvm or'
nl|'\n'
comment|'#               such. For now return fake data.'
nl|'\n'
indent|'        '
name|'return'
op|'{'
string|"'address'"
op|':'
string|"'127.0.0.1'"
op|','
nl|'\n'
string|"'username'"
op|':'
string|"'fakeuser'"
op|','
nl|'\n'
string|"'password'"
op|':'
string|"'fakepassword'"
op|'}'
newline|'\n'
nl|'\n'
DECL|member|refresh_security_group_rules
dedent|''
name|'def'
name|'refresh_security_group_rules'
op|'('
name|'self'
op|','
name|'security_group_id'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'refresh_security_group_rules'
op|'('
name|'security_group_id'
op|')'
newline|'\n'
nl|'\n'
DECL|member|refresh_security_group_members
dedent|''
name|'def'
name|'refresh_security_group_members'
op|'('
name|'self'
op|','
name|'security_group_id'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'refresh_security_group_members'
op|'('
name|'security_group_id'
op|')'
newline|'\n'
nl|'\n'
DECL|member|refresh_instance_security_rules
dedent|''
name|'def'
name|'refresh_instance_security_rules'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'refresh_instance_security_rules'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|refresh_provider_fw_rules
dedent|''
name|'def'
name|'refresh_provider_fw_rules'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'refresh_provider_fw_rules'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_available_resource
dedent|''
name|'def'
name|'get_available_resource'
op|'('
name|'self'
op|','
name|'nodename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve resource information.\n\n        This method is called when nova-compute launches, and\n        as part of a periodic task that records the results in the DB.\n\n        :param nodename: will be put in PCI device\n        :returns: dictionary containing resource info\n        """'
newline|'\n'
nl|'\n'
comment|'# Temporary: convert supported_instances into a string, while keeping'
nl|'\n'
comment|'# the RPC version as JSON. Can be changed when RPC broadcast is removed'
nl|'\n'
name|'stats'
op|'='
name|'self'
op|'.'
name|'host_state'
op|'.'
name|'get_host_stats'
op|'('
name|'refresh'
op|'='
name|'True'
op|')'
newline|'\n'
name|'stats'
op|'['
string|"'supported_instances'"
op|']'
op|'='
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
nl|'\n'
name|'stats'
op|'['
string|"'supported_instances'"
op|']'
op|')'
newline|'\n'
name|'return'
name|'stats'
newline|'\n'
nl|'\n'
DECL|member|check_instance_shared_storage_local
dedent|''
name|'def'
name|'check_instance_shared_storage_local'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'dirpath'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'dirpath'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'fd'
op|','
name|'tmp_file'
op|'='
name|'tempfile'
op|'.'
name|'mkstemp'
op|'('
name|'dir'
op|'='
name|'dirpath'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Creating tmpfile %s to verify with other "'
nl|'\n'
string|'"compute node that the instance is on "'
nl|'\n'
string|'"the same shared storage."'
op|')'
op|'%'
name|'tmp_file'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'fd'
op|')'
newline|'\n'
name|'return'
op|'{'
string|'"filename"'
op|':'
name|'tmp_file'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|check_instance_shared_storage_remote
dedent|''
name|'def'
name|'check_instance_shared_storage_remote'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'data'
op|'['
string|"'filename'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|check_instance_shared_storage_cleanup
dedent|''
name|'def'
name|'check_instance_shared_storage_cleanup'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'fileutils'
op|'.'
name|'delete_if_exists'
op|'('
name|'data'
op|'['
string|'"filename"'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|check_can_live_migrate_destination
dedent|''
name|'def'
name|'check_can_live_migrate_destination'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'src_compute_info'
op|','
name|'dst_compute_info'
op|','
nl|'\n'
name|'block_migration'
op|'='
name|'False'
op|','
nl|'\n'
name|'disk_over_commit'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check if it is possible to execute live migration.\n\n        This runs checks on the destination host, and then calls\n        back to the source host to check the results.\n\n        :param context: security context\n        :param instance: nova.db.sqlalchemy.models.Instance\n        :param block_migration: if true, prepare for block migration\n        :param disk_over_commit: if true, allow disk over commit\n        :returns: a dict containing:\n             :filename: name of the tmpfile under CONF.instances_path\n             :block_migration: whether this is block migration\n             :disk_over_commit: disk-over-commit factor on dest host\n             :disk_available_mb: available disk space on dest host\n        """'
newline|'\n'
name|'disk_available_mb'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'block_migration'
op|':'
newline|'\n'
indent|'            '
name|'disk_available_gb'
op|'='
name|'dst_compute_info'
op|'['
string|"'disk_available_least'"
op|']'
newline|'\n'
name|'disk_available_mb'
op|'='
op|'('
name|'disk_available_gb'
op|'*'
number|'1024'
op|')'
op|'-'
name|'CONF'
op|'.'
name|'reserved_host_disk_mb'
newline|'\n'
nl|'\n'
comment|'# Compare CPU'
nl|'\n'
dedent|''
name|'source_cpu_info'
op|'='
name|'src_compute_info'
op|'['
string|"'cpu_info'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_compare_cpu'
op|'('
name|'source_cpu_info'
op|')'
newline|'\n'
nl|'\n'
comment|'# Create file on storage, to be checked on source host'
nl|'\n'
name|'filename'
op|'='
name|'self'
op|'.'
name|'_create_shared_storage_test_file'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'return'
op|'{'
string|'"filename"'
op|':'
name|'filename'
op|','
nl|'\n'
string|'"block_migration"'
op|':'
name|'block_migration'
op|','
nl|'\n'
string|'"disk_over_commit"'
op|':'
name|'disk_over_commit'
op|','
nl|'\n'
string|'"disk_available_mb"'
op|':'
name|'disk_available_mb'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|check_can_live_migrate_destination_cleanup
dedent|''
name|'def'
name|'check_can_live_migrate_destination_cleanup'
op|'('
name|'self'
op|','
name|'context'
op|','
nl|'\n'
name|'dest_check_data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Do required cleanup on dest host after check_can_live_migrate calls\n\n        :param context: security context\n        """'
newline|'\n'
name|'filename'
op|'='
name|'dest_check_data'
op|'['
string|'"filename"'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_cleanup_shared_storage_test_file'
op|'('
name|'filename'
op|')'
newline|'\n'
nl|'\n'
DECL|member|check_can_live_migrate_source
dedent|''
name|'def'
name|'check_can_live_migrate_source'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'dest_check_data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check if it is possible to execute live migration.\n\n        This checks if the live migration can succeed, based on the\n        results from check_can_live_migrate_destination.\n\n        :param context: security context\n        :param instance: nova.db.sqlalchemy.models.Instance\n        :param dest_check_data: result of check_can_live_migrate_destination\n        :returns: a dict containing migration info\n        """'
newline|'\n'
comment|'# Checking shared storage connectivity'
nl|'\n'
comment|'# if block migration, instances_paths should not be on shared storage.'
nl|'\n'
name|'source'
op|'='
name|'CONF'
op|'.'
name|'host'
newline|'\n'
name|'filename'
op|'='
name|'dest_check_data'
op|'['
string|'"filename"'
op|']'
newline|'\n'
name|'block_migration'
op|'='
name|'dest_check_data'
op|'['
string|'"block_migration"'
op|']'
newline|'\n'
name|'is_volume_backed'
op|'='
name|'dest_check_data'
op|'.'
name|'get'
op|'('
string|"'is_volume_backed'"
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
name|'shared'
op|'='
name|'self'
op|'.'
name|'_check_shared_storage_test_file'
op|'('
name|'filename'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'block_migration'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'shared'
op|':'
newline|'\n'
indent|'                '
name|'reason'
op|'='
name|'_'
op|'('
string|'"Block migration can not be used "'
nl|'\n'
string|'"with shared storage."'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InvalidLocalStorage'
op|'('
name|'reason'
op|'='
name|'reason'
op|','
name|'path'
op|'='
name|'source'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_assert_dest_node_has_enough_disk'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'dest_check_data'
op|'['
string|"'disk_available_mb'"
op|']'
op|','
nl|'\n'
name|'dest_check_data'
op|'['
string|"'disk_over_commit'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'not'
name|'shared'
name|'and'
name|'not'
name|'is_volume_backed'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
name|'_'
op|'('
string|'"Live migration can not be used "'
nl|'\n'
string|'"without shared storage."'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InvalidSharedStorage'
op|'('
name|'reason'
op|'='
name|'reason'
op|','
name|'path'
op|'='
name|'source'
op|')'
newline|'\n'
dedent|''
name|'dest_check_data'
op|'.'
name|'update'
op|'('
op|'{'
string|'"is_shared_storage"'
op|':'
name|'shared'
op|'}'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(mikal): include the instance directory name here because it'
nl|'\n'
comment|"# doesn't yet exist on the destination but we want to force that"
nl|'\n'
comment|'# same name to be used'
nl|'\n'
name|'instance_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|','
nl|'\n'
name|'relative'
op|'='
name|'True'
op|')'
newline|'\n'
name|'dest_check_data'
op|'['
string|"'instance_relative_path'"
op|']'
op|'='
name|'instance_path'
newline|'\n'
nl|'\n'
name|'return'
name|'dest_check_data'
newline|'\n'
nl|'\n'
DECL|member|_assert_dest_node_has_enough_disk
dedent|''
name|'def'
name|'_assert_dest_node_has_enough_disk'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'available_mb'
op|','
name|'disk_over_commit'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Checks if destination has enough disk for block migration."""'
newline|'\n'
comment|'# Libvirt supports qcow2 disk format,which is usually compressed'
nl|'\n'
comment|'# on compute nodes.'
nl|'\n'
comment|'# Real disk image (compressed) may enlarged to "virtual disk size",'
nl|'\n'
comment|'# that is specified as the maximum disk size.'
nl|'\n'
comment|'# (See qemu-img -f path-to-disk)'
nl|'\n'
comment|'# Scheduler recognizes destination host still has enough disk space'
nl|'\n'
comment|'# if real disk size < available disk size'
nl|'\n'
comment|'# if disk_over_commit is True,'
nl|'\n'
comment|'#  otherwise virtual disk size < available disk size.'
nl|'\n'
nl|'\n'
name|'available'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'available_mb'
op|':'
newline|'\n'
indent|'            '
name|'available'
op|'='
name|'available_mb'
op|'*'
op|'('
number|'1024'
op|'**'
number|'2'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'ret'
op|'='
name|'self'
op|'.'
name|'get_instance_disk_info'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'disk_infos'
op|'='
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'ret'
op|')'
newline|'\n'
nl|'\n'
name|'necessary'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'disk_over_commit'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'info'
name|'in'
name|'disk_infos'
op|':'
newline|'\n'
indent|'                '
name|'necessary'
op|'+='
name|'int'
op|'('
name|'info'
op|'['
string|"'disk_size'"
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'info'
name|'in'
name|'disk_infos'
op|':'
newline|'\n'
indent|'                '
name|'necessary'
op|'+='
name|'int'
op|'('
name|'info'
op|'['
string|"'virt_disk_size'"
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Check that available disk > necessary disk'
nl|'\n'
dedent|''
dedent|''
name|'if'
op|'('
name|'available'
op|'-'
name|'necessary'
op|')'
op|'<'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
op|'('
name|'_'
op|'('
string|"'Unable to migrate %(instance_uuid)s: '"
nl|'\n'
string|"'Disk of instance is too large(available'"
nl|'\n'
string|"' on destination host:%(available)s '"
nl|'\n'
string|"'< need:%(necessary)s)'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'instance_uuid'"
op|':'
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
string|"'available'"
op|':'
name|'available'
op|','
nl|'\n'
string|"'necessary'"
op|':'
name|'necessary'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'MigrationPreCheckError'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_compare_cpu
dedent|''
dedent|''
name|'def'
name|'_compare_cpu'
op|'('
name|'self'
op|','
name|'cpu_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Checks the host cpu is compatible to a cpu given by xml.\n        "xml" must be a part of libvirt.openAuth(...).getCapabilities().\n        return values follows by virCPUCompareResult.\n        if 0 > return value, do live migration.\n        \'http://libvirt.org/html/libvirt-libvirt.html#virCPUCompareResult\'\n\n        :param cpu_info: json string that shows cpu feature(see get_cpu_info())\n        :returns:\n            None. if given cpu info is not compatible to this server,\n            raise exception.\n        """'
newline|'\n'
nl|'\n'
comment|'# NOTE(berendt): virConnectCompareCPU not working for Xen'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt_type'
op|'=='
string|"'xen'"
op|':'
newline|'\n'
indent|'            '
name|'return'
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'info'
op|'='
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'cpu_info'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'Instance launched has CPU info:\\n%s'"
op|')'
op|'%'
name|'cpu_info'
op|')'
newline|'\n'
name|'cpu'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigCPU'
op|'('
op|')'
newline|'\n'
name|'cpu'
op|'.'
name|'arch'
op|'='
name|'info'
op|'['
string|"'arch'"
op|']'
newline|'\n'
name|'cpu'
op|'.'
name|'model'
op|'='
name|'info'
op|'['
string|"'model'"
op|']'
newline|'\n'
name|'cpu'
op|'.'
name|'vendor'
op|'='
name|'info'
op|'['
string|"'vendor'"
op|']'
newline|'\n'
name|'cpu'
op|'.'
name|'sockets'
op|'='
name|'info'
op|'['
string|"'topology'"
op|']'
op|'['
string|"'sockets'"
op|']'
newline|'\n'
name|'cpu'
op|'.'
name|'cores'
op|'='
name|'info'
op|'['
string|"'topology'"
op|']'
op|'['
string|"'cores'"
op|']'
newline|'\n'
name|'cpu'
op|'.'
name|'threads'
op|'='
name|'info'
op|'['
string|"'topology'"
op|']'
op|'['
string|"'threads'"
op|']'
newline|'\n'
name|'for'
name|'f'
name|'in'
name|'info'
op|'['
string|"'features'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'cpu'
op|'.'
name|'add_feature'
op|'('
name|'vconfig'
op|'.'
name|'LibvirtConfigCPUFeature'
op|'('
name|'f'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'u'
op|'='
string|'"http://libvirt.org/html/libvirt-libvirt.html#virCPUCompareResult"'
newline|'\n'
name|'m'
op|'='
name|'_'
op|'('
string|'"CPU doesn\'t have compatibility.\\n\\n%(ret)s\\n\\nRefer to %(u)s"'
op|')'
newline|'\n'
comment|'# unknown character exists in xml, then libvirt complains'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'ret'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'compareCPU'
op|'('
name|'cpu'
op|'.'
name|'to_xml'
op|'('
op|')'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'ret'
op|'='
name|'e'
op|'.'
name|'message'
newline|'\n'
name|'LOG'
op|'.'
name|'error'
op|'('
name|'m'
op|','
op|'{'
string|"'ret'"
op|':'
name|'ret'
op|','
string|"'u'"
op|':'
name|'u'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'ret'
op|'<='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'m'
op|','
op|'{'
string|"'ret'"
op|':'
name|'ret'
op|','
string|"'u'"
op|':'
name|'u'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InvalidCPUInfo'
op|'('
name|'reason'
op|'='
name|'m'
op|'%'
op|'{'
string|"'ret'"
op|':'
name|'ret'
op|','
string|"'u'"
op|':'
name|'u'
op|'}'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_create_shared_storage_test_file
dedent|''
dedent|''
name|'def'
name|'_create_shared_storage_test_file'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Makes tmpfile under CONF.instances_path."""'
newline|'\n'
name|'dirpath'
op|'='
name|'CONF'
op|'.'
name|'instances_path'
newline|'\n'
name|'fd'
op|','
name|'tmp_file'
op|'='
name|'tempfile'
op|'.'
name|'mkstemp'
op|'('
name|'dir'
op|'='
name|'dirpath'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Creating tmpfile %s to notify to other "'
nl|'\n'
string|'"compute nodes that they should mount "'
nl|'\n'
string|'"the same storage."'
op|')'
op|'%'
name|'tmp_file'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'fd'
op|')'
newline|'\n'
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'tmp_file'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_check_shared_storage_test_file
dedent|''
name|'def'
name|'_check_shared_storage_test_file'
op|'('
name|'self'
op|','
name|'filename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Confirms existence of the tmpfile under CONF.instances_path.\n\n        Cannot confirm tmpfile return False.\n        """'
newline|'\n'
name|'tmp_file'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'CONF'
op|'.'
name|'instances_path'
op|','
name|'filename'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'tmp_file'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
DECL|member|_cleanup_shared_storage_test_file
dedent|''
dedent|''
name|'def'
name|'_cleanup_shared_storage_test_file'
op|'('
name|'self'
op|','
name|'filename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Removes existence of the tmpfile under CONF.instances_path."""'
newline|'\n'
name|'tmp_file'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'CONF'
op|'.'
name|'instances_path'
op|','
name|'filename'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'remove'
op|'('
name|'tmp_file'
op|')'
newline|'\n'
nl|'\n'
DECL|member|ensure_filtering_rules_for_instance
dedent|''
name|'def'
name|'ensure_filtering_rules_for_instance'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'time_module'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Ensure that an instance\'s filtering rules are enabled.\n\n        When migrating an instance, we need the filtering rules to\n        be configured on the destination host before starting the\n        migration.\n\n        Also, when restarting the compute service, we need to ensure\n        that filtering rules exist for all running services.\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'time_module'
op|':'
newline|'\n'
indent|'            '
name|'time_module'
op|'='
name|'greenthread'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'setup_basic_filtering'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'prepare_instance_filter'
op|'('
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
comment|'# nwfilters may be defined in a separate thread in the case'
nl|'\n'
comment|'# of libvirt non-blocking mode, so we wait for completion'
nl|'\n'
name|'timeout_count'
op|'='
name|'range'
op|'('
name|'CONF'
op|'.'
name|'live_migration_retry_count'
op|')'
newline|'\n'
name|'while'
name|'timeout_count'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'instance_filter_exists'
op|'('
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'break'
newline|'\n'
dedent|''
name|'timeout_count'
op|'.'
name|'pop'
op|'('
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'timeout_count'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
name|'_'
op|'('
string|"'The firewall filter for %s does not exist'"
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|'%'
name|'instance'
op|'['
string|'"name"'
op|']'
op|')'
newline|'\n'
dedent|''
name|'time_module'
op|'.'
name|'sleep'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
DECL|member|filter_defer_apply_on
dedent|''
dedent|''
name|'def'
name|'filter_defer_apply_on'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'filter_defer_apply_on'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|filter_defer_apply_off
dedent|''
name|'def'
name|'filter_defer_apply_off'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'filter_defer_apply_off'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|live_migration
dedent|''
name|'def'
name|'live_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
nl|'\n'
name|'post_method'
op|','
name|'recover_method'
op|','
name|'block_migration'
op|'='
name|'False'
op|','
nl|'\n'
name|'migrate_data'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Spawning live_migration operation for distributing high-load.\n\n        :params context: security context\n        :params instance:\n            nova.db.sqlalchemy.models.Instance object\n            instance object that is migrated.\n        :params dest: destination host\n        :params block_migration: destination host\n        :params post_method:\n            post operation method.\n            expected nova.compute.manager.post_live_migration.\n        :params recover_method:\n            recovery method when any exception occurs.\n            expected nova.compute.manager.recover_live_migration.\n        :params block_migration: if true, do block migration.\n        :params migrate_data: implementation specific params\n\n        """'
newline|'\n'
nl|'\n'
name|'greenthread'
op|'.'
name|'spawn'
op|'('
name|'self'
op|'.'
name|'_live_migration'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
nl|'\n'
name|'post_method'
op|','
name|'recover_method'
op|','
name|'block_migration'
op|','
nl|'\n'
name|'migrate_data'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_live_migration
dedent|''
name|'def'
name|'_live_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
name|'post_method'
op|','
nl|'\n'
name|'recover_method'
op|','
name|'block_migration'
op|'='
name|'False'
op|','
nl|'\n'
name|'migrate_data'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Do live migration.\n\n        :params context: security context\n        :params instance:\n            nova.db.sqlalchemy.models.Instance object\n            instance object that is migrated.\n        :params dest: destination host\n        :params post_method:\n            post operation method.\n            expected nova.compute.manager.post_live_migration.\n        :params recover_method:\n            recovery method when any exception occurs.\n            expected nova.compute.manager.recover_live_migration.\n        :params migrate_data: implementation specific params\n        """'
newline|'\n'
nl|'\n'
comment|'# Do live migration.'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'block_migration'
op|':'
newline|'\n'
indent|'                '
name|'flaglist'
op|'='
name|'CONF'
op|'.'
name|'block_migration_flag'
op|'.'
name|'split'
op|'('
string|"','"
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'flaglist'
op|'='
name|'CONF'
op|'.'
name|'live_migration_flag'
op|'.'
name|'split'
op|'('
string|"','"
op|')'
newline|'\n'
dedent|''
name|'flagvals'
op|'='
op|'['
name|'getattr'
op|'('
name|'libvirt'
op|','
name|'x'
op|'.'
name|'strip'
op|'('
op|')'
op|')'
name|'for'
name|'x'
name|'in'
name|'flaglist'
op|']'
newline|'\n'
name|'logical_sum'
op|'='
name|'reduce'
op|'('
name|'lambda'
name|'x'
op|','
name|'y'
op|':'
name|'x'
op|'|'
name|'y'
op|','
name|'flagvals'
op|')'
newline|'\n'
nl|'\n'
name|'dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|'"name"'
op|']'
op|')'
newline|'\n'
name|'dom'
op|'.'
name|'migrateToURI'
op|'('
name|'CONF'
op|'.'
name|'live_migration_uri'
op|'%'
name|'dest'
op|','
nl|'\n'
name|'logical_sum'
op|','
nl|'\n'
name|'None'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'live_migration_bandwidth'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|'"Live Migration failure: %s"'
op|')'
op|','
name|'e'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'recover_method'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
name|'block_migration'
op|')'
newline|'\n'
nl|'\n'
comment|'# Waiting for completion of live_migration.'
nl|'\n'
dedent|''
dedent|''
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
name|'f'
op|'='
name|'None'
op|')'
newline|'\n'
nl|'\n'
DECL|function|wait_for_live_migration
name|'def'
name|'wait_for_live_migration'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""waiting for live migration completion."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'get_info'
op|'('
name|'instance'
op|')'
op|'['
string|"'state'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'                '
name|'timer'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
name|'post_method'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
name|'block_migration'
op|','
nl|'\n'
name|'migrate_data'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'timer'
op|'.'
name|'f'
op|'='
name|'wait_for_live_migration'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_fetch_instance_kernel_ramdisk
dedent|''
name|'def'
name|'_fetch_instance_kernel_ramdisk'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Download kernel and ramdisk for instance in instance directory."""'
newline|'\n'
name|'instance_dir'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'instance'
op|'['
string|"'kernel_id'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'libvirt_utils'
op|'.'
name|'fetch_image'
op|'('
name|'context'
op|','
nl|'\n'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
string|"'kernel'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'kernel_id'"
op|']'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'user_id'"
op|']'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'project_id'"
op|']'
op|')'
newline|'\n'
name|'if'
name|'instance'
op|'['
string|"'ramdisk_id'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'libvirt_utils'
op|'.'
name|'fetch_image'
op|'('
name|'context'
op|','
nl|'\n'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
nl|'\n'
string|"'ramdisk'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'ramdisk_id'"
op|']'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'user_id'"
op|']'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'project_id'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|pre_live_migration
dedent|''
dedent|''
dedent|''
name|'def'
name|'pre_live_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'block_device_info'
op|','
nl|'\n'
name|'network_info'
op|','
name|'disk_info'
op|','
name|'migrate_data'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Preparation live migration."""'
newline|'\n'
comment|'# Steps for volume backed instance live migration w/o shared storage.'
nl|'\n'
name|'is_shared_storage'
op|'='
name|'True'
newline|'\n'
name|'is_volume_backed'
op|'='
name|'False'
newline|'\n'
name|'is_block_migration'
op|'='
name|'True'
newline|'\n'
name|'instance_relative_path'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'migrate_data'
op|':'
newline|'\n'
indent|'            '
name|'is_shared_storage'
op|'='
name|'migrate_data'
op|'.'
name|'get'
op|'('
string|"'is_shared_storage'"
op|','
name|'True'
op|')'
newline|'\n'
name|'is_volume_backed'
op|'='
name|'migrate_data'
op|'.'
name|'get'
op|'('
string|"'is_volume_backed'"
op|','
name|'False'
op|')'
newline|'\n'
name|'is_block_migration'
op|'='
name|'migrate_data'
op|'.'
name|'get'
op|'('
string|"'block_migration'"
op|','
name|'True'
op|')'
newline|'\n'
name|'instance_relative_path'
op|'='
name|'migrate_data'
op|'.'
name|'get'
op|'('
string|"'instance_relative_path'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'is_shared_storage'
op|':'
newline|'\n'
comment|"# NOTE(mikal): this doesn't use libvirt_utils.get_instance_path"
nl|'\n'
comment|'# because we are ensuring that the same instance directory name'
nl|'\n'
comment|'# is used as was at the source'
nl|'\n'
indent|'            '
name|'if'
name|'instance_relative_path'
op|':'
newline|'\n'
indent|'                '
name|'instance_dir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'CONF'
op|'.'
name|'instances_path'
op|','
nl|'\n'
name|'instance_relative_path'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'instance_dir'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'instance_dir'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'DestinationDiskExists'
op|'('
name|'path'
op|'='
name|'instance_dir'
op|')'
newline|'\n'
dedent|''
name|'os'
op|'.'
name|'mkdir'
op|'('
name|'instance_dir'
op|')'
newline|'\n'
nl|'\n'
comment|'# Ensure images and backing files are present.'
nl|'\n'
name|'self'
op|'.'
name|'_create_images_and_backing'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'instance_dir'
op|','
nl|'\n'
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'is_volume_backed'
name|'and'
name|'not'
op|'('
name|'is_block_migration'
name|'or'
name|'is_shared_storage'
op|')'
op|':'
newline|'\n'
comment|'# Touch the console.log file, required by libvirt.'
nl|'\n'
indent|'            '
name|'console_file'
op|'='
name|'self'
op|'.'
name|'_get_console_log_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'file_open'
op|'('
name|'console_file'
op|','
string|"'a'"
op|')'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# if image has kernel and ramdisk, just download'
nl|'\n'
comment|'# following normal way.'
nl|'\n'
name|'self'
op|'.'
name|'_fetch_instance_kernel_ramdisk'
op|'('
name|'context'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# Establishing connection to volume server.'
nl|'\n'
dedent|''
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'for'
name|'vol'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'            '
name|'connection_info'
op|'='
name|'vol'
op|'['
string|"'connection_info'"
op|']'
newline|'\n'
name|'disk_dev'
op|'='
name|'vol'
op|'['
string|"'mount_device'"
op|']'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_info_from_bdm'
op|'('
name|'CONF'
op|'.'
name|'libvirt_type'
op|','
name|'vol'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'volume_driver_method'
op|'('
string|"'connect_volume'"
op|','
nl|'\n'
name|'connection_info'
op|','
nl|'\n'
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
comment|'# We call plug_vifs before the compute manager calls'
nl|'\n'
comment|'# ensure_filtering_rules_for_instance, to ensure bridge is set up'
nl|'\n'
comment|'# Retry operation is necessary because continuously request comes,'
nl|'\n'
comment|'# concurrent request occurs to iptables, then it complains.'
nl|'\n'
dedent|''
name|'max_retry'
op|'='
name|'CONF'
op|'.'
name|'live_migration_retry_count'
newline|'\n'
name|'for'
name|'cnt'
name|'in'
name|'range'
op|'('
name|'max_retry'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'plug_vifs'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'except'
name|'processutils'
op|'.'
name|'ProcessExecutionError'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'cnt'
op|'=='
name|'max_retry'
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|"'plug_vifs() failed %(cnt)d. Retry up to '"
nl|'\n'
string|"'%(max_retry)d.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'cnt'"
op|':'
name|'cnt'
op|','
nl|'\n'
string|"'max_retry'"
op|':'
name|'max_retry'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'greenthread'
op|'.'
name|'sleep'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_create_images_and_backing
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_create_images_and_backing'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'instance_dir'
op|','
nl|'\n'
name|'disk_info_json'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        :params context: security context\n        :params instance:\n            nova.db.sqlalchemy.models.Instance object\n            instance object that is migrated.\n        :params instance_dir:\n            instance path to use, calculated externally to handle block\n            migrating an instance with an old style instance path\n        :params disk_info_json:\n            json strings specified in get_instance_disk_info\n\n        """'
newline|'\n'
name|'disk_info'
op|'='
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'disk_info_json'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'info'
name|'in'
name|'disk_info'
op|':'
newline|'\n'
indent|'            '
name|'base'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'info'
op|'['
string|"'path'"
op|']'
op|')'
newline|'\n'
comment|'# Get image type and create empty disk image, and'
nl|'\n'
comment|'# create backing file in case of qcow2.'
nl|'\n'
name|'instance_disk'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
name|'base'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'info'
op|'['
string|"'backing_file'"
op|']'
name|'and'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'instance_disk'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'libvirt_utils'
op|'.'
name|'create_image'
op|'('
name|'info'
op|'['
string|"'type'"
op|']'
op|','
name|'instance_disk'
op|','
nl|'\n'
name|'info'
op|'['
string|"'disk_size'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'info'
op|'['
string|"'backing_file'"
op|']'
op|':'
newline|'\n'
comment|'# Creating backing file follows same way as spawning instances.'
nl|'\n'
indent|'                '
name|'cache_name'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'info'
op|'['
string|"'backing_file'"
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'image'
op|'='
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'image'
op|'('
name|'instance'
op|','
nl|'\n'
name|'instance_disk'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt_images_type'
op|')'
newline|'\n'
name|'image'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'libvirt_utils'
op|'.'
name|'fetch_image'
op|','
nl|'\n'
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'filename'
op|'='
name|'cache_name'
op|','
nl|'\n'
name|'image_id'
op|'='
name|'instance'
op|'['
string|"'image_ref'"
op|']'
op|','
nl|'\n'
name|'user_id'
op|'='
name|'instance'
op|'['
string|"'user_id'"
op|']'
op|','
nl|'\n'
name|'project_id'
op|'='
name|'instance'
op|'['
string|"'project_id'"
op|']'
op|','
nl|'\n'
name|'size'
op|'='
name|'info'
op|'['
string|"'virt_disk_size'"
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# if image has kernel and ramdisk, just download'
nl|'\n'
comment|'# following normal way.'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_fetch_instance_kernel_ramdisk'
op|'('
name|'context'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|post_live_migration
dedent|''
name|'def'
name|'post_live_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'block_device_info'
op|')'
op|':'
newline|'\n'
comment|'# Disconnect from volume server'
nl|'\n'
indent|'        '
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'for'
name|'vol'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'            '
name|'connection_info'
op|'='
name|'vol'
op|'['
string|"'connection_info'"
op|']'
newline|'\n'
name|'disk_dev'
op|'='
name|'vol'
op|'['
string|"'mount_device'"
op|']'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'volume_driver_method'
op|'('
string|"'disconnect_volume'"
op|','
nl|'\n'
name|'connection_info'
op|','
nl|'\n'
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
DECL|member|post_live_migration_at_destination
dedent|''
dedent|''
name|'def'
name|'post_live_migration_at_destination'
op|'('
name|'self'
op|','
name|'context'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|','
nl|'\n'
name|'block_migration'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Post operation of live migration at destination host.\n\n        :param context: security context\n        :param instance:\n            nova.db.sqlalchemy.models.Instance object\n            instance object that is migrated.\n        :param network_info: instance network information\n        :param block_migration: if true, post operation of block_migration.\n        """'
newline|'\n'
comment|'# Define migrated instance, otherwise, suspend/destroy does not work.'
nl|'\n'
name|'dom_list'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'listDefinedDomains'
op|'('
op|')'
newline|'\n'
name|'if'
name|'instance'
op|'['
string|'"name"'
op|']'
name|'not'
name|'in'
name|'dom_list'
op|':'
newline|'\n'
comment|'# In case of block migration, destination does not have'
nl|'\n'
comment|'# libvirt.xml'
nl|'\n'
indent|'            '
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
name|'CONF'
op|'.'
name|'libvirt_type'
op|','
nl|'\n'
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'to_xml'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'block_device_info'
op|','
name|'write_to_disk'
op|'='
name|'True'
op|')'
newline|'\n'
comment|'# libvirt.xml should be made by to_xml(), but libvirt'
nl|'\n'
comment|'# does not accept to_xml() result, since uuid is not'
nl|'\n'
comment|'# included in to_xml() result.'
nl|'\n'
name|'dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|'"name"'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'defineXML'
op|'('
name|'dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_instance_disk_info
dedent|''
dedent|''
name|'def'
name|'get_instance_disk_info'
op|'('
name|'self'
op|','
name|'instance_name'
op|','
name|'xml'
op|'='
name|'None'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Preparation block migration.\n\n        :params instance:\n            nova.db.sqlalchemy.models.Instance object\n            instance object that is migrated.\n        :return:\n            json strings with below format::\n\n                "[{\'path\':\'disk\', \'type\':\'raw\',\n                  \'virt_disk_size\':\'10737418240\',\n                  \'backing_file\':\'backing_file\',\n                  \'disk_size\':\'83886080\'},...]"\n\n        """'
newline|'\n'
comment|'# NOTE (rmk): Passing the domain XML into this function is optional.'
nl|'\n'
comment|'#             When it is not passed, we attempt to extract it from'
nl|'\n'
comment|'#             the pre-existing definition.'
nl|'\n'
name|'if'
name|'xml'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance_name'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'virt_dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'                '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|"'Error from libvirt while getting description of '"
nl|'\n'
string|"'%(instance_name)s: [Error Code %(error_code)s] '"
nl|'\n'
string|"'%(ex)s'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'instance_name'"
op|':'
name|'instance_name'
op|','
nl|'\n'
string|"'error_code'"
op|':'
name|'error_code'
op|','
nl|'\n'
string|"'ex'"
op|':'
name|'ex'
op|'}'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'msg'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|'('
name|'instance_id'
op|'='
name|'instance_name'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE (rmk): When block_device_info is provided, we will use it to'
nl|'\n'
comment|'#             filter out devices which are actually volumes.'
nl|'\n'
dedent|''
dedent|''
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
name|'volume_devices'
op|'='
name|'set'
op|'('
op|')'
newline|'\n'
name|'for'
name|'vol'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'            '
name|'disk_dev'
op|'='
name|'vol'
op|'['
string|"'mount_device'"
op|']'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'volume_devices'
op|'.'
name|'add'
op|'('
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'disk_info'
op|'='
op|'['
op|']'
newline|'\n'
name|'doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
name|'disk_nodes'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
string|"'.//devices/disk'"
op|')'
newline|'\n'
name|'path_nodes'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
string|"'.//devices/disk/source'"
op|')'
newline|'\n'
name|'driver_nodes'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
string|"'.//devices/disk/driver'"
op|')'
newline|'\n'
name|'target_nodes'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
string|"'.//devices/disk/target'"
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'cnt'
op|','
name|'path_node'
name|'in'
name|'enumerate'
op|'('
name|'path_nodes'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'disk_type'
op|'='
name|'disk_nodes'
op|'['
name|'cnt'
op|']'
op|'.'
name|'get'
op|'('
string|"'type'"
op|')'
newline|'\n'
name|'path'
op|'='
name|'path_node'
op|'.'
name|'get'
op|'('
string|"'file'"
op|')'
newline|'\n'
name|'target'
op|'='
name|'target_nodes'
op|'['
name|'cnt'
op|']'
op|'.'
name|'attrib'
op|'['
string|"'dev'"
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'disk_type'
op|'!='
string|"'file'"
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'skipping %s since it looks like volume'"
op|')'
op|','
name|'path'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'path'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'skipping disk for %s as it does not have a path'"
op|')'
op|','
nl|'\n'
name|'instance_name'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'target'
name|'in'
name|'volume_devices'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'skipping disk %(path)s (%(target)s) as it is a '"
nl|'\n'
string|"'volume'"
op|')'
op|','
op|'{'
string|"'path'"
op|':'
name|'path'
op|','
string|"'target'"
op|':'
name|'target'
op|'}'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
comment|'# get the real disk size or'
nl|'\n'
comment|'# raise a localized error if image is unavailable'
nl|'\n'
dedent|''
name|'dk_size'
op|'='
name|'int'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'getsize'
op|'('
name|'path'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'disk_type'
op|'='
name|'driver_nodes'
op|'['
name|'cnt'
op|']'
op|'.'
name|'get'
op|'('
string|"'type'"
op|')'
newline|'\n'
name|'if'
name|'disk_type'
op|'=='
string|'"qcow2"'
op|':'
newline|'\n'
indent|'                '
name|'backing_file'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_disk_backing_file'
op|'('
name|'path'
op|')'
newline|'\n'
name|'virt_size'
op|'='
name|'disk'
op|'.'
name|'get_disk_size'
op|'('
name|'path'
op|')'
newline|'\n'
name|'over_commit_size'
op|'='
name|'int'
op|'('
name|'virt_size'
op|')'
op|'-'
name|'dk_size'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'backing_file'
op|'='
string|'""'
newline|'\n'
name|'virt_size'
op|'='
number|'0'
newline|'\n'
name|'over_commit_size'
op|'='
number|'0'
newline|'\n'
nl|'\n'
dedent|''
name|'disk_info'
op|'.'
name|'append'
op|'('
op|'{'
string|"'type'"
op|':'
name|'disk_type'
op|','
nl|'\n'
string|"'path'"
op|':'
name|'path'
op|','
nl|'\n'
string|"'virt_disk_size'"
op|':'
name|'virt_size'
op|','
nl|'\n'
string|"'backing_file'"
op|':'
name|'backing_file'
op|','
nl|'\n'
string|"'disk_size'"
op|':'
name|'dk_size'
op|','
nl|'\n'
string|"'over_committed_disk_size'"
op|':'
name|'over_commit_size'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_disk_over_committed_size_total
dedent|''
name|'def'
name|'get_disk_over_committed_size_total'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return total over committed disk size for all instances."""'
newline|'\n'
comment|'# Disk size that all instance uses : virtual_size - disk_size'
nl|'\n'
name|'instances_name'
op|'='
name|'self'
op|'.'
name|'list_instances'
op|'('
op|')'
newline|'\n'
name|'disk_over_committed_size'
op|'='
number|'0'
newline|'\n'
name|'for'
name|'i_name'
name|'in'
name|'instances_name'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'disk_infos'
op|'='
name|'jsonutils'
op|'.'
name|'loads'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'get_instance_disk_info'
op|'('
name|'i_name'
op|')'
op|')'
newline|'\n'
name|'for'
name|'info'
name|'in'
name|'disk_infos'
op|':'
newline|'\n'
indent|'                    '
name|'disk_over_committed_size'
op|'+='
name|'int'
op|'('
nl|'\n'
name|'info'
op|'['
string|"'over_committed_disk_size'"
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|"'Getting disk size of %(i_name)s: %(e)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'i_name'"
op|':'
name|'i_name'
op|','
string|"'e'"
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
comment|'# Instance was deleted during the check so ignore it'
nl|'\n'
indent|'                '
name|'pass'
newline|'\n'
comment|'# NOTE(gtt116): give change to do other task.'
nl|'\n'
dedent|''
name|'greenthread'
op|'.'
name|'sleep'
op|'('
number|'0'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'disk_over_committed_size'
newline|'\n'
nl|'\n'
DECL|member|unfilter_instance
dedent|''
name|'def'
name|'unfilter_instance'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""See comments of same method in firewall_driver."""'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'unfilter_instance'
op|'('
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|'='
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_host_stats
dedent|''
name|'def'
name|'get_host_stats'
op|'('
name|'self'
op|','
name|'refresh'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the current state of the host.\n\n        If \'refresh\' is True, run update the stats first.\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'host_state'
op|'.'
name|'get_host_stats'
op|'('
name|'refresh'
op|'='
name|'refresh'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_host_uptime
dedent|''
name|'def'
name|'get_host_uptime'
op|'('
name|'self'
op|','
name|'host'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns the result of calling "uptime"."""'
newline|'\n'
comment|'#NOTE(dprince): host seems to be ignored for this call and in'
nl|'\n'
comment|'# other compute drivers as well. Perhaps we should remove it?'
nl|'\n'
name|'out'
op|','
name|'err'
op|'='
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'env'"
op|','
string|"'LANG=C'"
op|','
string|"'uptime'"
op|')'
newline|'\n'
name|'return'
name|'out'
newline|'\n'
nl|'\n'
DECL|member|manage_image_cache
dedent|''
name|'def'
name|'manage_image_cache'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'all_instances'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Manage the local cache of images."""'
newline|'\n'
name|'self'
op|'.'
name|'image_cache_manager'
op|'.'
name|'verify_base_images'
op|'('
name|'context'
op|','
name|'all_instances'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_cleanup_remote_migration
dedent|''
name|'def'
name|'_cleanup_remote_migration'
op|'('
name|'self'
op|','
name|'dest'
op|','
name|'inst_base'
op|','
name|'inst_base_resize'
op|','
nl|'\n'
name|'shared_storage'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Used only for cleanup in case migrate_disk_and_power_off fails."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'inst_base_resize'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'rm'"
op|','
string|"'-rf'"
op|','
name|'inst_base'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'inst_base_resize'
op|','
name|'inst_base'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'shared_storage'
op|':'
newline|'\n'
indent|'                    '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'ssh'"
op|','
name|'dest'
op|','
string|"'rm'"
op|','
string|"'-rf'"
op|','
name|'inst_base'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|_is_storage_shared_with
dedent|''
dedent|''
name|'def'
name|'_is_storage_shared_with'
op|'('
name|'self'
op|','
name|'dest'
op|','
name|'inst_base'
op|')'
op|':'
newline|'\n'
comment|'# NOTE (rmk): There are two methods of determining whether we are'
nl|'\n'
comment|'#             on the same filesystem: the source and dest IP are the'
nl|'\n'
comment|'#             same, or we create a file on the dest system via SSH'
nl|'\n'
comment|'#             and check whether the source system can also see it.'
nl|'\n'
indent|'        '
name|'shared_storage'
op|'='
op|'('
name|'dest'
op|'=='
name|'self'
op|'.'
name|'get_host_ip_addr'
op|'('
op|')'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'shared_storage'
op|':'
newline|'\n'
indent|'            '
name|'tmp_file'
op|'='
name|'uuid'
op|'.'
name|'uuid4'
op|'('
op|')'
op|'.'
name|'hex'
op|'+'
string|"'.tmp'"
newline|'\n'
name|'tmp_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_base'
op|','
name|'tmp_file'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'ssh'"
op|','
name|'dest'
op|','
string|"'touch'"
op|','
name|'tmp_path'
op|')'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'tmp_path'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'shared_storage'
op|'='
name|'True'
newline|'\n'
name|'os'
op|'.'
name|'unlink'
op|'('
name|'tmp_path'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'ssh'"
op|','
name|'dest'
op|','
string|"'rm'"
op|','
name|'tmp_path'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'shared_storage'
newline|'\n'
nl|'\n'
DECL|member|migrate_disk_and_power_off
dedent|''
name|'def'
name|'migrate_disk_and_power_off'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
nl|'\n'
name|'instance_type'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Starting migrate_disk_and_power_off"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'disk_info_text'
op|'='
name|'self'
op|'.'
name|'get_instance_disk_info'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|')'
newline|'\n'
name|'disk_info'
op|'='
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'disk_info_text'
op|')'
newline|'\n'
nl|'\n'
comment|'# copy disks to destination'
nl|'\n'
comment|'# rename instance dir to +_resize at first for using'
nl|'\n'
comment|'# shared storage for instance dir (eg. NFS).'
nl|'\n'
name|'inst_base'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'inst_base_resize'
op|'='
name|'inst_base'
op|'+'
string|'"_resize"'
newline|'\n'
name|'shared_storage'
op|'='
name|'self'
op|'.'
name|'_is_storage_shared_with'
op|'('
name|'dest'
op|','
name|'inst_base'
op|')'
newline|'\n'
nl|'\n'
comment|'# try to create the directory on the remote compute node'
nl|'\n'
comment|'# if this fails we pass the exception up the stack so we can catch'
nl|'\n'
comment|'# failures here earlier'
nl|'\n'
name|'if'
name|'not'
name|'shared_storage'
op|':'
newline|'\n'
indent|'            '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'ssh'"
op|','
name|'dest'
op|','
string|"'mkdir'"
op|','
string|"'-p'"
op|','
name|'inst_base'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'power_off'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'for'
name|'vol'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'            '
name|'connection_info'
op|'='
name|'vol'
op|'['
string|"'connection_info'"
op|']'
newline|'\n'
name|'disk_dev'
op|'='
name|'vol'
op|'['
string|"'mount_device'"
op|']'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'volume_driver_method'
op|'('
string|"'disconnect_volume'"
op|','
nl|'\n'
name|'connection_info'
op|','
nl|'\n'
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'inst_base'
op|','
name|'inst_base_resize'
op|')'
newline|'\n'
comment|'# if we are migrating the instance with shared storage then'
nl|'\n'
comment|'# create the directory.  If it is a remote node the directory'
nl|'\n'
comment|'# has already been created'
nl|'\n'
name|'if'
name|'shared_storage'
op|':'
newline|'\n'
indent|'                '
name|'dest'
op|'='
name|'None'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mkdir'"
op|','
string|"'-p'"
op|','
name|'inst_base'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'info'
name|'in'
name|'disk_info'
op|':'
newline|'\n'
comment|"# assume inst_base == dirname(info['path'])"
nl|'\n'
indent|'                '
name|'img_path'
op|'='
name|'info'
op|'['
string|"'path'"
op|']'
newline|'\n'
name|'fname'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'img_path'
op|')'
newline|'\n'
name|'from_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_base_resize'
op|','
name|'fname'
op|')'
newline|'\n'
name|'if'
name|'info'
op|'['
string|"'type'"
op|']'
op|'=='
string|"'qcow2'"
name|'and'
name|'info'
op|'['
string|"'backing_file'"
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'tmp_path'
op|'='
name|'from_path'
op|'+'
string|'"_rbase"'
newline|'\n'
comment|'# merge backing file'
nl|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'qemu-img'"
op|','
string|"'convert'"
op|','
string|"'-f'"
op|','
string|"'qcow2'"
op|','
nl|'\n'
string|"'-O'"
op|','
string|"'qcow2'"
op|','
name|'from_path'
op|','
name|'tmp_path'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'shared_storage'
op|':'
newline|'\n'
indent|'                        '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'tmp_path'
op|','
name|'img_path'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'libvirt_utils'
op|'.'
name|'copy_image'
op|'('
name|'tmp_path'
op|','
name|'img_path'
op|','
name|'host'
op|'='
name|'dest'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'rm'"
op|','
string|"'-f'"
op|','
name|'tmp_path'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'else'
op|':'
comment|'# raw or qcow2 with no backing file'
newline|'\n'
indent|'                    '
name|'libvirt_utils'
op|'.'
name|'copy_image'
op|'('
name|'from_path'
op|','
name|'img_path'
op|','
name|'host'
op|'='
name|'dest'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_cleanup_remote_migration'
op|'('
name|'dest'
op|','
name|'inst_base'
op|','
nl|'\n'
name|'inst_base_resize'
op|','
nl|'\n'
name|'shared_storage'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'disk_info_text'
newline|'\n'
nl|'\n'
DECL|member|_wait_for_running
dedent|''
name|'def'
name|'_wait_for_running'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'state'
op|'='
name|'self'
op|'.'
name|'get_info'
op|'('
name|'instance'
op|')'
op|'['
string|"'state'"
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"Instance running successfully."'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|finish_migration
dedent|''
dedent|''
name|'def'
name|'finish_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'migration'
op|','
name|'instance'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'network_info'
op|','
name|'image_meta'
op|','
name|'resize_instance'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'power_on'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Starting finish_migration"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# resize disks. only "disk" and "disk.local" are necessary.'
nl|'\n'
name|'disk_info'
op|'='
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'disk_info'
op|')'
newline|'\n'
name|'for'
name|'info'
name|'in'
name|'disk_info'
op|':'
newline|'\n'
indent|'            '
name|'fname'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'info'
op|'['
string|"'path'"
op|']'
op|')'
newline|'\n'
name|'if'
name|'fname'
op|'=='
string|"'disk'"
op|':'
newline|'\n'
indent|'                '
name|'size'
op|'='
name|'instance'
op|'['
string|"'root_gb'"
op|']'
newline|'\n'
dedent|''
name|'elif'
name|'fname'
op|'=='
string|"'disk.local'"
op|':'
newline|'\n'
indent|'                '
name|'size'
op|'='
name|'instance'
op|'['
string|"'ephemeral_gb'"
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'size'
op|'='
number|'0'
newline|'\n'
dedent|''
name|'size'
op|'*='
number|'1024'
op|'*'
number|'1024'
op|'*'
number|'1024'
newline|'\n'
nl|'\n'
comment|'# If we have a non partitioned image that we can extend'
nl|'\n'
comment|"# then ensure we're in 'raw' format so we can extend file system."
nl|'\n'
name|'fmt'
op|'='
name|'info'
op|'['
string|"'type'"
op|']'
newline|'\n'
name|'if'
op|'('
name|'size'
name|'and'
name|'fmt'
op|'=='
string|"'qcow2'"
name|'and'
nl|'\n'
name|'disk'
op|'.'
name|'can_resize_image'
op|'('
name|'info'
op|'['
string|"'path'"
op|']'
op|','
name|'size'
op|')'
name|'and'
nl|'\n'
name|'disk'
op|'.'
name|'is_image_partitionless'
op|'('
name|'info'
op|'['
string|"'path'"
op|']'
op|','
name|'use_cow'
op|'='
name|'True'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'path_raw'
op|'='
name|'info'
op|'['
string|"'path'"
op|']'
op|'+'
string|"'_raw'"
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'qemu-img'"
op|','
string|"'convert'"
op|','
string|"'-f'"
op|','
string|"'qcow2'"
op|','
nl|'\n'
string|"'-O'"
op|','
string|"'raw'"
op|','
name|'info'
op|'['
string|"'path'"
op|']'
op|','
name|'path_raw'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'path_raw'
op|','
name|'info'
op|'['
string|"'path'"
op|']'
op|')'
newline|'\n'
name|'fmt'
op|'='
string|"'raw'"
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'size'
op|':'
newline|'\n'
indent|'                '
name|'use_cow'
op|'='
name|'fmt'
op|'=='
string|"'qcow2'"
newline|'\n'
name|'disk'
op|'.'
name|'extend'
op|'('
name|'info'
op|'['
string|"'path'"
op|']'
op|','
name|'size'
op|','
name|'use_cow'
op|'='
name|'use_cow'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'fmt'
op|'=='
string|"'raw'"
name|'and'
name|'CONF'
op|'.'
name|'use_cow_images'
op|':'
newline|'\n'
comment|'# back to qcow2 (no backing_file though) so that snapshot'
nl|'\n'
comment|'# will be available'
nl|'\n'
indent|'                '
name|'path_qcow'
op|'='
name|'info'
op|'['
string|"'path'"
op|']'
op|'+'
string|"'_qcow'"
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'qemu-img'"
op|','
string|"'convert'"
op|','
string|"'-f'"
op|','
string|"'raw'"
op|','
nl|'\n'
string|"'-O'"
op|','
string|"'qcow2'"
op|','
name|'info'
op|'['
string|"'path'"
op|']'
op|','
name|'path_qcow'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'path_qcow'
op|','
name|'info'
op|'['
string|"'path'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
name|'CONF'
op|'.'
name|'libvirt_type'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'block_device_info'
op|','
nl|'\n'
name|'image_meta'
op|')'
newline|'\n'
comment|'# assume _create_image do nothing if a target file exists.'
nl|'\n'
name|'self'
op|'.'
name|'_create_image'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'disk_mapping'
op|'='
name|'disk_info'
op|'['
string|"'mapping'"
op|']'
op|','
nl|'\n'
name|'network_info'
op|'='
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'inject_files'
op|'='
name|'False'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'to_xml'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|','
nl|'\n'
name|'write_to_disk'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_domain_and_network'
op|'('
name|'xml'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|','
name|'power_on'
op|','
nl|'\n'
name|'context'
op|'='
name|'context'
op|')'
newline|'\n'
name|'if'
name|'power_on'
op|':'
newline|'\n'
indent|'            '
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_wait_for_running'
op|','
nl|'\n'
name|'instance'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_cleanup_failed_migration
dedent|''
dedent|''
name|'def'
name|'_cleanup_failed_migration'
op|'('
name|'self'
op|','
name|'inst_base'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Make sure that a failed migrate doesn\'t prevent us from rolling\n        back in a revert.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'shutil'
op|'.'
name|'rmtree'
op|'('
name|'inst_base'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
nl|'\n'
DECL|member|finish_revert_migration
dedent|''
dedent|''
dedent|''
name|'def'
name|'finish_revert_migration'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'power_on'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Starting finish_revert_migration"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'inst_base'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'inst_base_resize'
op|'='
name|'inst_base'
op|'+'
string|'"_resize"'
newline|'\n'
nl|'\n'
comment|"# NOTE(danms): if we're recovering from a failed migration,"
nl|'\n'
comment|"# make sure we don't have a left-over same-host base directory"
nl|'\n'
comment|"# that would conflict. Also, don't fail on the rename if the"
nl|'\n'
comment|'# failure happened early.'
nl|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'inst_base_resize'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_cleanup_failed_migration'
op|'('
name|'inst_base'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'inst_base_resize'
op|','
name|'inst_base'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
name|'CONF'
op|'.'
name|'libvirt_type'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'to_xml'
op|'('
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
op|','
nl|'\n'
name|'instance'
op|','
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_domain_and_network'
op|'('
name|'xml'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|','
name|'power_on'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'power_on'
op|':'
newline|'\n'
indent|'            '
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_wait_for_running'
op|','
nl|'\n'
name|'instance'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|confirm_migration
dedent|''
dedent|''
name|'def'
name|'confirm_migration'
op|'('
name|'self'
op|','
name|'migration'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Confirms a resize, destroying the source VM."""'
newline|'\n'
name|'self'
op|'.'
name|'_cleanup_resize'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_diagnostics
dedent|''
name|'def'
name|'get_diagnostics'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
DECL|function|get_io_devices
indent|'        '
name|'def'
name|'get_io_devices'
op|'('
name|'xml_doc'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""get the list of io devices from the xml document."""'
newline|'\n'
name|'result'
op|'='
op|'{'
string|'"volumes"'
op|':'
op|'['
op|']'
op|','
string|'"ifaces"'
op|':'
op|'['
op|']'
op|'}'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml_doc'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'result'
newline|'\n'
dedent|''
name|'blocks'
op|'='
op|'['
op|'('
string|"'./devices/disk'"
op|','
string|"'volumes'"
op|')'
op|','
nl|'\n'
op|'('
string|"'./devices/interface'"
op|','
string|"'ifaces'"
op|')'
op|']'
newline|'\n'
name|'for'
name|'block'
op|','
name|'key'
name|'in'
name|'blocks'
op|':'
newline|'\n'
indent|'                '
name|'section'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
name|'block'
op|')'
newline|'\n'
name|'for'
name|'node'
name|'in'
name|'section'
op|':'
newline|'\n'
indent|'                    '
name|'for'
name|'child'
name|'in'
name|'node'
op|'.'
name|'getchildren'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'child'
op|'.'
name|'tag'
op|'=='
string|"'target'"
name|'and'
name|'child'
op|'.'
name|'get'
op|'('
string|"'dev'"
op|')'
op|':'
newline|'\n'
indent|'                            '
name|'result'
op|'['
name|'key'
op|']'
op|'.'
name|'append'
op|'('
name|'child'
op|'.'
name|'get'
op|'('
string|"'dev'"
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
dedent|''
name|'domain'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'output'
op|'='
op|'{'
op|'}'
newline|'\n'
comment|'# get cpu time, might launch an exception if the method'
nl|'\n'
comment|'# is not supported by the underlying hypervisor being'
nl|'\n'
comment|'# used by libvirt'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'cputime'
op|'='
name|'domain'
op|'.'
name|'vcpus'
op|'('
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'len'
op|'('
name|'cputime'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'output'
op|'['
string|'"cpu"'
op|'+'
name|'str'
op|'('
name|'i'
op|')'
op|'+'
string|'"_time"'
op|']'
op|'='
name|'cputime'
op|'['
name|'i'
op|']'
op|'['
number|'2'
op|']'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
comment|'# get io status'
nl|'\n'
dedent|''
name|'xml'
op|'='
name|'domain'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
name|'dom_io'
op|'='
name|'get_io_devices'
op|'('
name|'xml'
op|')'
newline|'\n'
name|'for'
name|'disk'
name|'in'
name|'dom_io'
op|'['
string|'"volumes"'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
comment|'# blockStats might launch an exception if the method'
nl|'\n'
comment|'# is not supported by the underlying hypervisor being'
nl|'\n'
comment|'# used by libvirt'
nl|'\n'
indent|'                '
name|'stats'
op|'='
name|'domain'
op|'.'
name|'blockStats'
op|'('
name|'disk'
op|')'
newline|'\n'
name|'output'
op|'['
name|'disk'
op|'+'
string|'"_read_req"'
op|']'
op|'='
name|'stats'
op|'['
number|'0'
op|']'
newline|'\n'
name|'output'
op|'['
name|'disk'
op|'+'
string|'"_read"'
op|']'
op|'='
name|'stats'
op|'['
number|'1'
op|']'
newline|'\n'
name|'output'
op|'['
name|'disk'
op|'+'
string|'"_write_req"'
op|']'
op|'='
name|'stats'
op|'['
number|'2'
op|']'
newline|'\n'
name|'output'
op|'['
name|'disk'
op|'+'
string|'"_write"'
op|']'
op|'='
name|'stats'
op|'['
number|'3'
op|']'
newline|'\n'
name|'output'
op|'['
name|'disk'
op|'+'
string|'"_errors"'
op|']'
op|'='
name|'stats'
op|'['
number|'4'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'for'
name|'interface'
name|'in'
name|'dom_io'
op|'['
string|'"ifaces"'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
comment|'# interfaceStats might launch an exception if the method'
nl|'\n'
comment|'# is not supported by the underlying hypervisor being'
nl|'\n'
comment|'# used by libvirt'
nl|'\n'
indent|'                '
name|'stats'
op|'='
name|'domain'
op|'.'
name|'interfaceStats'
op|'('
name|'interface'
op|')'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_rx"'
op|']'
op|'='
name|'stats'
op|'['
number|'0'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_rx_packets"'
op|']'
op|'='
name|'stats'
op|'['
number|'1'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_rx_errors"'
op|']'
op|'='
name|'stats'
op|'['
number|'2'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_rx_drop"'
op|']'
op|'='
name|'stats'
op|'['
number|'3'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_tx"'
op|']'
op|'='
name|'stats'
op|'['
number|'4'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_tx_packets"'
op|']'
op|'='
name|'stats'
op|'['
number|'5'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_tx_errors"'
op|']'
op|'='
name|'stats'
op|'['
number|'6'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_tx_drop"'
op|']'
op|'='
name|'stats'
op|'['
number|'7'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'output'
op|'['
string|'"memory"'
op|']'
op|'='
name|'domain'
op|'.'
name|'maxMemory'
op|'('
op|')'
newline|'\n'
comment|'# memoryStats might launch an exception if the method'
nl|'\n'
comment|'# is not supported by the underlying hypervisor being'
nl|'\n'
comment|'# used by libvirt'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'mem'
op|'='
name|'domain'
op|'.'
name|'memoryStats'
op|'('
op|')'
newline|'\n'
name|'for'
name|'key'
name|'in'
name|'mem'
op|'.'
name|'keys'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'output'
op|'['
string|'"memory-"'
op|'+'
name|'key'
op|']'
op|'='
name|'mem'
op|'['
name|'key'
op|']'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|'('
name|'libvirt'
op|'.'
name|'libvirtError'
op|','
name|'AttributeError'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'return'
name|'output'
newline|'\n'
nl|'\n'
DECL|member|instance_on_disk
dedent|''
name|'def'
name|'instance_on_disk'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
comment|'# ensure directories exist and are writable'
nl|'\n'
indent|'        '
name|'instance_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Checking instance files accessibility %s'"
op|')'
op|','
name|'instance_path'
op|')'
newline|'\n'
name|'return'
name|'os'
op|'.'
name|'access'
op|'('
name|'instance_path'
op|','
name|'os'
op|'.'
name|'W_OK'
op|')'
newline|'\n'
nl|'\n'
DECL|member|inject_network_info
dedent|''
name|'def'
name|'inject_network_info'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'nw_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'setup_basic_filtering'
op|'('
name|'instance'
op|','
name|'nw_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_delete_instance_files
dedent|''
name|'def'
name|'_delete_instance_files'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(mikal): a shim to handle this file not using instance objects'
nl|'\n'
comment|'# everywhere. Remove this when that conversion happens.'
nl|'\n'
indent|'        '
name|'context'
op|'='
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
newline|'\n'
name|'inst_obj'
op|'='
name|'instance_obj'
op|'.'
name|'Instance'
op|'.'
name|'get_by_uuid'
op|'('
name|'context'
op|','
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(mikal): this code should be pushed up a layer when this shim is'
nl|'\n'
comment|'# removed.'
nl|'\n'
name|'attempts'
op|'='
name|'int'
op|'('
name|'inst_obj'
op|'.'
name|'system_metadata'
op|'.'
name|'get'
op|'('
string|"'clean_attempts'"
op|','
string|"'0'"
op|')'
op|')'
newline|'\n'
name|'success'
op|'='
name|'self'
op|'.'
name|'delete_instance_files'
op|'('
name|'inst_obj'
op|')'
newline|'\n'
name|'inst_obj'
op|'.'
name|'system_metadata'
op|'['
string|"'clean_attempts'"
op|']'
op|'='
name|'str'
op|'('
name|'attempts'
op|'+'
number|'1'
op|')'
newline|'\n'
name|'if'
name|'success'
op|':'
newline|'\n'
indent|'            '
name|'inst_obj'
op|'.'
name|'cleaned'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'inst_obj'
op|'.'
name|'save'
op|'('
name|'context'
op|')'
newline|'\n'
nl|'\n'
DECL|member|delete_instance_files
dedent|''
name|'def'
name|'delete_instance_files'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'target'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'target'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'Deleting instance files %s'"
op|')'
op|','
name|'target'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'shutil'
op|'.'
name|'rmtree'
op|'('
name|'target'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|"'Failed to cleanup directory %(target)s: '"
nl|'\n'
string|"'%(e)s'"
op|')'
op|','
op|'{'
string|"'target'"
op|':'
name|'target'
op|','
string|"'e'"
op|':'
name|'e'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|"# It is possible that the delete failed, if so don't mark the instance"
nl|'\n'
comment|'# as cleaned.'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'target'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'Deletion of %s failed'"
op|')'
op|','
name|'target'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'Deletion of %s complete'"
op|')'
op|','
name|'target'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|need_legacy_block_device_info
name|'def'
name|'need_legacy_block_device_info'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|default_root_device_name
dedent|''
name|'def'
name|'default_root_device_name'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'root_bdm'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'        '
name|'disk_bus'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_bus_for_device_type'
op|'('
name|'CONF'
op|'.'
name|'libvirt_type'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
string|'"disk"'
op|')'
newline|'\n'
name|'cdrom_bus'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_bus_for_device_type'
op|'('
name|'CONF'
op|'.'
name|'libvirt_type'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
string|'"cdrom"'
op|')'
newline|'\n'
name|'root_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_root_info'
op|'('
name|'CONF'
op|'.'
name|'libvirt_type'
op|','
nl|'\n'
name|'image_meta'
op|','
name|'root_bdm'
op|','
nl|'\n'
name|'disk_bus'
op|','
name|'cdrom_bus'
op|')'
newline|'\n'
name|'return'
name|'block_device'
op|'.'
name|'prepend_dev'
op|'('
name|'root_info'
op|'['
string|"'dev'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|default_device_names_for_instance
dedent|''
name|'def'
name|'default_device_names_for_instance'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'root_device_name'
op|','
nl|'\n'
op|'*'
name|'block_device_lists'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'ephemerals'
op|','
name|'swap'
op|','
name|'block_device_mapping'
op|'='
name|'block_device_lists'
op|'['
op|':'
number|'3'
op|']'
newline|'\n'
nl|'\n'
DECL|function|_update_func
name|'def'
name|'_update_func'
op|'('
name|'bdm'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'bdm_id'
op|'='
name|'bdm'
op|'.'
name|'get'
op|'('
string|"'id'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'virtapi'
op|'.'
name|'block_device_mapping_update'
op|'('
nl|'\n'
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
op|','
nl|'\n'
name|'bdm_id'
op|','
name|'bdm'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'blockinfo'
op|'.'
name|'default_device_names'
op|'('
name|'CONF'
op|'.'
name|'libvirt_type'
op|','
nl|'\n'
name|'instance'
op|','
name|'root_device_name'
op|','
nl|'\n'
name|'_update_func'
op|','
nl|'\n'
name|'ephemerals'
op|','
name|'swap'
op|','
nl|'\n'
name|'block_device_mapping'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|HostState
dedent|''
dedent|''
name|'class'
name|'HostState'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Manages information about the compute node through libvirt."""'
newline|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'driver'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'super'
op|'('
name|'HostState'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_stats'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'driver'
op|'='
name|'driver'
newline|'\n'
name|'self'
op|'.'
name|'update_status'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_host_stats
dedent|''
name|'def'
name|'get_host_stats'
op|'('
name|'self'
op|','
name|'refresh'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the current state of the host.\n\n        If \'refresh\' is True, run update the stats first.\n        """'
newline|'\n'
name|'if'
name|'refresh'
name|'or'
name|'not'
name|'self'
op|'.'
name|'_stats'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'update_status'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_stats'
newline|'\n'
nl|'\n'
DECL|member|update_status
dedent|''
name|'def'
name|'update_status'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve status info from libvirt."""'
newline|'\n'
DECL|function|_get_disk_available_least
name|'def'
name|'_get_disk_available_least'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Return total real disk available least size.\n\n            The size of available disk, when block_migration command given\n            disk_over_commit param is FALSE.\n\n            The size that deducted real instance disk size from the total size\n            of the virtual disk of all instances.\n\n            """'
newline|'\n'
name|'disk_free_gb'
op|'='
name|'disk_info_dict'
op|'['
string|"'free'"
op|']'
newline|'\n'
name|'disk_over_committed'
op|'='
op|'('
name|'self'
op|'.'
name|'driver'
op|'.'
nl|'\n'
name|'get_disk_over_committed_size_total'
op|'('
op|')'
op|')'
newline|'\n'
comment|'# Disk available least size'
nl|'\n'
name|'available_least'
op|'='
name|'disk_free_gb'
op|'*'
op|'('
number|'1024'
op|'**'
number|'3'
op|')'
op|'-'
name|'disk_over_committed'
newline|'\n'
name|'return'
op|'('
name|'available_least'
op|'/'
op|'('
number|'1024'
op|'**'
number|'3'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Updating host stats"'
op|')'
op|')'
newline|'\n'
name|'disk_info_dict'
op|'='
name|'self'
op|'.'
name|'driver'
op|'.'
name|'get_local_gb_info'
op|'('
op|')'
newline|'\n'
name|'data'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
comment|'#NOTE(dprince): calling capabilities before getVersion works around'
nl|'\n'
comment|'# an initialization issue with some versions of Libvirt (1.0.5.5).'
nl|'\n'
comment|'# See: https://bugzilla.redhat.com/show_bug.cgi?id=1000116'
nl|'\n'
comment|'# See: https://bugs.launchpad.net/nova/+bug/1215593'
nl|'\n'
name|'data'
op|'['
string|'"supported_instances"'
op|']'
op|'='
name|'self'
op|'.'
name|'driver'
op|'.'
name|'get_instance_capabilities'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'data'
op|'['
string|'"vcpus"'
op|']'
op|'='
name|'self'
op|'.'
name|'driver'
op|'.'
name|'get_vcpu_total'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|'"memory_mb"'
op|']'
op|'='
name|'self'
op|'.'
name|'driver'
op|'.'
name|'get_memory_mb_total'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|'"local_gb"'
op|']'
op|'='
name|'disk_info_dict'
op|'['
string|"'total'"
op|']'
newline|'\n'
name|'data'
op|'['
string|'"vcpus_used"'
op|']'
op|'='
name|'self'
op|'.'
name|'driver'
op|'.'
name|'get_vcpu_used'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|'"memory_mb_used"'
op|']'
op|'='
name|'self'
op|'.'
name|'driver'
op|'.'
name|'get_memory_mb_used'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|'"local_gb_used"'
op|']'
op|'='
name|'disk_info_dict'
op|'['
string|"'used'"
op|']'
newline|'\n'
name|'data'
op|'['
string|'"hypervisor_type"'
op|']'
op|'='
name|'self'
op|'.'
name|'driver'
op|'.'
name|'get_hypervisor_type'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|'"hypervisor_version"'
op|']'
op|'='
name|'self'
op|'.'
name|'driver'
op|'.'
name|'get_hypervisor_version'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|'"hypervisor_hostname"'
op|']'
op|'='
name|'self'
op|'.'
name|'driver'
op|'.'
name|'get_hypervisor_hostname'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|'"cpu_info"'
op|']'
op|'='
name|'self'
op|'.'
name|'driver'
op|'.'
name|'get_cpu_info'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|"'disk_available_least'"
op|']'
op|'='
name|'_get_disk_available_least'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'data'
op|'['
string|"'pci_passthrough_devices'"
op|']'
op|'='
name|'self'
op|'.'
name|'driver'
op|'.'
name|'get_pci_passthrough_devices'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_stats'
op|'='
name|'data'
newline|'\n'
nl|'\n'
name|'return'
name|'data'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
