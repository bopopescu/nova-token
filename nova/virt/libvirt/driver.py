begin_unit
comment|'# Copyright 2010 United States Government as represented by the'
nl|'\n'
comment|'# Administrator of the National Aeronautics and Space Administration.'
nl|'\n'
comment|'# All Rights Reserved.'
nl|'\n'
comment|'# Copyright (c) 2010 Citrix Systems, Inc.'
nl|'\n'
comment|'# Copyright (c) 2011 Piston Cloud Computing, Inc'
nl|'\n'
comment|'# Copyright (c) 2012 University Of Minho'
nl|'\n'
comment|'# (c) Copyright 2013 Hewlett-Packard Development Company, L.P.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
nl|'\n'
string|'"""\nA connection to a hypervisor through libvirt.\n\nSupports KVM, LXC, QEMU, UML, XEN and Parallels.\n\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'collections'
newline|'\n'
name|'import'
name|'contextlib'
newline|'\n'
name|'import'
name|'errno'
newline|'\n'
name|'import'
name|'functools'
newline|'\n'
name|'import'
name|'glob'
newline|'\n'
name|'import'
name|'itertools'
newline|'\n'
name|'import'
name|'mmap'
newline|'\n'
name|'import'
name|'operator'
newline|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'shutil'
newline|'\n'
name|'import'
name|'tempfile'
newline|'\n'
name|'import'
name|'time'
newline|'\n'
name|'import'
name|'uuid'
newline|'\n'
nl|'\n'
name|'import'
name|'eventlet'
newline|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'greenthread'
newline|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'tpool'
newline|'\n'
name|'from'
name|'lxml'
name|'import'
name|'etree'
newline|'\n'
name|'from'
name|'os_brick'
op|'.'
name|'initiator'
name|'import'
name|'connector'
newline|'\n'
name|'from'
name|'oslo_concurrency'
name|'import'
name|'processutils'
newline|'\n'
name|'from'
name|'oslo_config'
name|'import'
name|'cfg'
newline|'\n'
name|'from'
name|'oslo_log'
name|'import'
name|'log'
name|'as'
name|'logging'
newline|'\n'
name|'from'
name|'oslo_serialization'
name|'import'
name|'jsonutils'
newline|'\n'
name|'from'
name|'oslo_service'
name|'import'
name|'loopingcall'
newline|'\n'
name|'from'
name|'oslo_utils'
name|'import'
name|'excutils'
newline|'\n'
name|'from'
name|'oslo_utils'
name|'import'
name|'fileutils'
newline|'\n'
name|'from'
name|'oslo_utils'
name|'import'
name|'importutils'
newline|'\n'
name|'from'
name|'oslo_utils'
name|'import'
name|'strutils'
newline|'\n'
name|'from'
name|'oslo_utils'
name|'import'
name|'timeutils'
newline|'\n'
name|'from'
name|'oslo_utils'
name|'import'
name|'units'
newline|'\n'
name|'import'
name|'six'
newline|'\n'
name|'from'
name|'six'
op|'.'
name|'moves'
name|'import'
name|'range'
newline|'\n'
nl|'\n'
name|'from'
name|'nova'
op|'.'
name|'api'
op|'.'
name|'metadata'
name|'import'
name|'base'
name|'as'
name|'instance_metadata'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'block_device'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'arch'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'hv_type'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'power_state'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'task_states'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'utils'
name|'as'
name|'compute_utils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'vm_mode'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'console'
name|'import'
name|'serial'
name|'as'
name|'serial_console'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'console'
name|'import'
name|'type'
name|'as'
name|'ctype'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'context'
name|'as'
name|'nova_context'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'exception'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_LE'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_LI'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_LW'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'image'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'network'
name|'import'
name|'model'
name|'as'
name|'network_model'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'objects'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'pci'
name|'import'
name|'manager'
name|'as'
name|'pci_manager'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'pci'
name|'import'
name|'utils'
name|'as'
name|'pci_utils'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'utils'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'version'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'block_device'
name|'as'
name|'driver_block_device'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'configdrive'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'diagnostics'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'disk'
name|'import'
name|'api'
name|'as'
name|'disk'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'disk'
op|'.'
name|'vfs'
name|'import'
name|'guestfs'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'driver'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'firewall'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'hardware'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'image'
name|'import'
name|'model'
name|'as'
name|'imgmodel'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'blockinfo'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'config'
name|'as'
name|'vconfig'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'firewall'
name|'as'
name|'libvirt_firewall'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'guest'
name|'as'
name|'libvirt_guest'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'host'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'imagebackend'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'imagecache'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
op|'.'
name|'storage'
name|'import'
name|'dmcrypt'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
op|'.'
name|'storage'
name|'import'
name|'lvm'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
op|'.'
name|'storage'
name|'import'
name|'rbd_utils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'utils'
name|'as'
name|'libvirt_utils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'vif'
name|'as'
name|'libvirt_vif'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'netutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'watchdog_actions'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'volume'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'volume'
name|'import'
name|'encryptors'
newline|'\n'
nl|'\n'
DECL|variable|libvirt
name|'libvirt'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|variable|LOG
name|'LOG'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|libvirt_opts
name|'libvirt_opts'
op|'='
op|'['
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'rescue_image_id'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Rescue ami image. This will not be used if an image id '"
nl|'\n'
string|"'is provided by the user.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'rescue_kernel_id'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Rescue aki image'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'rescue_ramdisk_id'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Rescue ari image'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'virt_type'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'kvm'"
op|','
nl|'\n'
DECL|variable|choices
name|'choices'
op|'='
op|'('
string|"'kvm'"
op|','
string|"'lxc'"
op|','
string|"'qemu'"
op|','
string|"'uml'"
op|','
string|"'xen'"
op|','
string|"'parallels'"
op|')'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Libvirt domain type'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'connection_uri'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"''"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Override the default libvirt URI '"
nl|'\n'
string|"'(which is dependent on virt_type)'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'BoolOpt'
op|'('
string|"'inject_password'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
name|'False'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Inject the admin password at boot time, '"
nl|'\n'
string|"'without an agent.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'BoolOpt'
op|'('
string|"'inject_key'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
name|'False'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Inject the ssh public key at boot time'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'inject_partition'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
op|'-'
number|'2'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'The partition to inject to : '"
nl|'\n'
string|"'-2 => disable, -1 => inspect (libguestfs only), '"
nl|'\n'
string|"'0 => not partitioned, >0 => partition number'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'BoolOpt'
op|'('
string|"'use_usb_tablet'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
name|'True'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Sync virtual and real mouse cursors in Windows VMs'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'live_migration_uri'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|'"qemu+tcp://%s/system"'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Migration target URI '"
nl|'\n'
string|'\'(any included "%s" is replaced with \''
nl|'\n'
string|"'the migration target hostname)'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'live_migration_flag'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '"
nl|'\n'
string|"'VIR_MIGRATE_LIVE, VIR_MIGRATE_TUNNELLED'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Migration flags to be set for live migration'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'block_migration_flag'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '"
nl|'\n'
string|"'VIR_MIGRATE_LIVE, VIR_MIGRATE_TUNNELLED, '"
nl|'\n'
string|"'VIR_MIGRATE_NON_SHARED_INC'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Migration flags to be set for block migration'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'live_migration_bandwidth'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'0'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Maximum bandwidth to be used during migration, in Mbps'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'snapshot_image_format'"
op|','
nl|'\n'
DECL|variable|choices
name|'choices'
op|'='
op|'('
string|"'raw'"
op|','
string|"'qcow2'"
op|','
string|"'vmdk'"
op|','
string|"'vdi'"
op|')'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Snapshot image format. Defaults to same as source image'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'disk_prefix'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Override the default disk prefix for the devices attached'"
nl|'\n'
string|"' to a server, which is dependent on virt_type. '"
nl|'\n'
string|"'(valid options are: sd, xvd, uvd, vd)'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'wait_soft_reboot_seconds'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'120'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Number of seconds to wait for instance to shut down after'"
nl|'\n'
string|"' soft reboot request is made. We fall back to hard reboot'"
nl|'\n'
string|"' if instance does not shutdown within this window.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'cpu_mode'"
op|','
nl|'\n'
DECL|variable|choices
name|'choices'
op|'='
op|'('
string|"'host-model'"
op|','
string|"'host-passthrough'"
op|','
string|"'custom'"
op|','
string|"'none'"
op|')'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|'\'Set to "host-model" to clone the host CPU feature flags; \''
nl|'\n'
string|'\'to "host-passthrough" to use the host CPU model exactly; \''
nl|'\n'
string|'\'to "custom" to use a named CPU model; \''
nl|'\n'
string|'\'to "none" to not set any CPU model. \''
nl|'\n'
string|'\'If virt_type="kvm|qemu", it will default to \''
nl|'\n'
string|'\'"host-model", otherwise it will default to "none"\''
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'cpu_model'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Set to a named libvirt CPU model (see names listed '"
nl|'\n'
string|"'in /usr/share/libvirt/cpu_map.xml). Only has effect if '"
nl|'\n'
string|'\'cpu_mode="custom" and virt_type="kvm|qemu"\''
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'snapshots_directory'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'$instances_path/snapshots'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Location where libvirt driver will store snapshots '"
nl|'\n'
string|"'before uploading them to image service'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'xen_hvmloader_path'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'/usr/lib/xen/boot/hvmloader'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Location where the Xen hvmloader is kept'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'ListOpt'
op|'('
string|"'disk_cachemodes'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
op|'['
op|']'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Specific cachemodes to use for different disk types '"
nl|'\n'
string|"'e.g: file=directsync,block=none'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'rng_dev_path'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'A path to a device that will be used as source of '"
nl|'\n'
string|"'entropy on the host. Permitted options are: '"
nl|'\n'
string|"'/dev/random or /dev/hwrng'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'ListOpt'
op|'('
string|"'hw_machine_type'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'For qemu or KVM guests, set this option to specify '"
nl|'\n'
string|"'a default machine type per host architecture. '"
nl|'\n'
string|"'You can find a list of supported machine types '"
nl|'\n'
string|"'in your environment by checking the output of '"
nl|'\n'
string|'\'the "virsh capabilities"command. The format of the \''
nl|'\n'
string|"'value for this config option is host-arch=machine-type. '"
nl|'\n'
string|"'For example: x86_64=machinetype1,armv7l=machinetype2'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'sysinfo_serial'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'auto'"
op|','
nl|'\n'
DECL|variable|choices
name|'choices'
op|'='
op|'('
string|"'none'"
op|','
string|"'os'"
op|','
string|"'hardware'"
op|','
string|"'auto'"
op|')'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|'\'The data source used to the populate the host "serial" \''
nl|'\n'
string|"'UUID exposed to guest in the virtual BIOS.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'mem_stats_period_seconds'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'10'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'A number of seconds to memory usage statistics period. '"
nl|'\n'
string|"'Zero or negative value mean to disable memory usage '"
nl|'\n'
string|"'statistics.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'ListOpt'
op|'('
string|"'uid_maps'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
op|'['
op|']'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'List of uid targets and ranges.'"
nl|'\n'
string|"'Syntax is guest-uid:host-uid:count'"
nl|'\n'
string|"'Maximum of 5 allowed.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'ListOpt'
op|'('
string|"'gid_maps'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
op|'['
op|']'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'List of guid targets and ranges.'"
nl|'\n'
string|"'Syntax is guest-gid:host-gid:count'"
nl|'\n'
string|"'Maximum of 5 allowed.'"
op|')'
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
DECL|variable|CONF
name|'CONF'
op|'='
name|'cfg'
op|'.'
name|'CONF'
newline|'\n'
name|'CONF'
op|'.'
name|'register_opts'
op|'('
name|'libvirt_opts'
op|','
string|"'libvirt'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'host'"
op|','
string|"'nova.netconf'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'my_ip'"
op|','
string|"'nova.netconf'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'use_cow_images'"
op|','
string|"'nova.virt.driver'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'enabled'"
op|','
string|"'nova.compute.api'"
op|','
nl|'\n'
DECL|variable|group
name|'group'
op|'='
string|"'ephemeral_storage_encryption'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'cipher'"
op|','
string|"'nova.compute.api'"
op|','
nl|'\n'
DECL|variable|group
name|'group'
op|'='
string|"'ephemeral_storage_encryption'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'key_size'"
op|','
string|"'nova.compute.api'"
op|','
nl|'\n'
DECL|variable|group
name|'group'
op|'='
string|"'ephemeral_storage_encryption'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'live_migration_retry_count'"
op|','
string|"'nova.compute.manager'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'vncserver_proxyclient_address'"
op|','
string|"'nova.vnc'"
op|','
name|'group'
op|'='
string|"'vnc'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'server_proxyclient_address'"
op|','
string|"'nova.spice'"
op|','
name|'group'
op|'='
string|"'spice'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'vcpu_pin_set'"
op|','
string|"'nova.virt.hardware'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'vif_plugging_is_fatal'"
op|','
string|"'nova.virt.driver'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'vif_plugging_timeout'"
op|','
string|"'nova.virt.driver'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'enabled'"
op|','
string|"'nova.console.serial'"
op|','
name|'group'
op|'='
string|"'serial_console'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'proxyclient_address'"
op|','
string|"'nova.console.serial'"
op|','
nl|'\n'
DECL|variable|group
name|'group'
op|'='
string|"'serial_console'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'hw_disk_discard'"
op|','
string|"'nova.virt.libvirt.imagebackend'"
op|','
nl|'\n'
DECL|variable|group
name|'group'
op|'='
string|"'libvirt'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_group'
op|'('
string|"'workarounds'"
op|','
string|"'nova.utils'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'iscsi_use_multipath'"
op|','
string|"'nova.virt.libvirt.volume'"
op|','
nl|'\n'
DECL|variable|group
name|'group'
op|'='
string|"'libvirt'"
op|')'
newline|'\n'
nl|'\n'
DECL|variable|DEFAULT_FIREWALL_DRIVER
name|'DEFAULT_FIREWALL_DRIVER'
op|'='
string|'"%s.%s"'
op|'%'
op|'('
nl|'\n'
name|'libvirt_firewall'
op|'.'
name|'__name__'
op|','
nl|'\n'
name|'libvirt_firewall'
op|'.'
name|'IptablesFirewallDriver'
op|'.'
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|MAX_CONSOLE_BYTES
name|'MAX_CONSOLE_BYTES'
op|'='
number|'100'
op|'*'
name|'units'
op|'.'
name|'Ki'
newline|'\n'
nl|'\n'
comment|'# The libvirt driver will prefix any disable reason codes with this string.'
nl|'\n'
DECL|variable|DISABLE_PREFIX
name|'DISABLE_PREFIX'
op|'='
string|"'AUTO: '"
newline|'\n'
comment|'# Disable reason for the service which was enabled or disabled without reason'
nl|'\n'
DECL|variable|DISABLE_REASON_UNDEFINED
name|'DISABLE_REASON_UNDEFINED'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# Guest config console string'
nl|'\n'
name|'CONSOLE'
op|'='
string|'"console=tty0 console=ttyS0"'
newline|'\n'
nl|'\n'
DECL|variable|GuestNumaConfig
name|'GuestNumaConfig'
op|'='
name|'collections'
op|'.'
name|'namedtuple'
op|'('
nl|'\n'
string|"'GuestNumaConfig'"
op|','
op|'['
string|"'cpuset'"
op|','
string|"'cputune'"
op|','
string|"'numaconfig'"
op|','
string|"'numatune'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|libvirt_volume_drivers
name|'libvirt_volume_drivers'
op|'='
op|'['
nl|'\n'
string|"'iscsi=nova.virt.libvirt.volume.volume.LibvirtISCSIVolumeDriver'"
op|','
nl|'\n'
string|"'iser=nova.virt.libvirt.volume.volume.LibvirtISERVolumeDriver'"
op|','
nl|'\n'
string|"'local=nova.virt.libvirt.volume.volume.LibvirtVolumeDriver'"
op|','
nl|'\n'
string|"'fake=nova.virt.libvirt.volume.volume.LibvirtFakeVolumeDriver'"
op|','
nl|'\n'
string|"'rbd=nova.virt.libvirt.volume.volume.LibvirtNetVolumeDriver'"
op|','
nl|'\n'
string|"'sheepdog=nova.virt.libvirt.volume.volume.LibvirtNetVolumeDriver'"
op|','
nl|'\n'
string|"'nfs=nova.virt.libvirt.volume.volume.LibvirtNFSVolumeDriver'"
op|','
nl|'\n'
string|"'smbfs=nova.virt.libvirt.volume.volume.LibvirtSMBFSVolumeDriver'"
op|','
nl|'\n'
string|"'aoe=nova.virt.libvirt.volume.volume.LibvirtAOEVolumeDriver'"
op|','
nl|'\n'
string|"'glusterfs=nova.virt.libvirt.volume.volume.LibvirtGlusterfsVolumeDriver'"
op|','
nl|'\n'
string|"'fibre_channel='"
nl|'\n'
string|"'nova.virt.libvirt.volume.volume.LibvirtFibreChannelVolumeDriver'"
op|','
nl|'\n'
string|"'scality=nova.virt.libvirt.volume.scality.LibvirtScalityVolumeDriver'"
op|','
nl|'\n'
string|"'gpfs=nova.virt.libvirt.volume.gpfs.LibvirtGPFSVolumeDriver'"
op|','
nl|'\n'
string|"'quobyte=nova.virt.libvirt.volume.quobyte.LibvirtQuobyteVolumeDriver'"
op|','
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|patch_tpool_proxy
name|'def'
name|'patch_tpool_proxy'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""eventlet.tpool.Proxy doesn\'t work with old-style class in __str__()\n    or __repr__() calls. See bug #962840 for details.\n    We perform a monkey patch to replace those two instance methods.\n    """'
newline|'\n'
DECL|function|str_method
name|'def'
name|'str_method'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'str'
op|'('
name|'self'
op|'.'
name|'_obj'
op|')'
newline|'\n'
nl|'\n'
DECL|function|repr_method
dedent|''
name|'def'
name|'repr_method'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'repr'
op|'('
name|'self'
op|'.'
name|'_obj'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'tpool'
op|'.'
name|'Proxy'
op|'.'
name|'__str__'
op|'='
name|'str_method'
newline|'\n'
name|'tpool'
op|'.'
name|'Proxy'
op|'.'
name|'__repr__'
op|'='
name|'repr_method'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
name|'patch_tpool_proxy'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|variable|VIR_DOMAIN_NOSTATE
name|'VIR_DOMAIN_NOSTATE'
op|'='
number|'0'
newline|'\n'
DECL|variable|VIR_DOMAIN_RUNNING
name|'VIR_DOMAIN_RUNNING'
op|'='
number|'1'
newline|'\n'
DECL|variable|VIR_DOMAIN_BLOCKED
name|'VIR_DOMAIN_BLOCKED'
op|'='
number|'2'
newline|'\n'
DECL|variable|VIR_DOMAIN_PAUSED
name|'VIR_DOMAIN_PAUSED'
op|'='
number|'3'
newline|'\n'
DECL|variable|VIR_DOMAIN_SHUTDOWN
name|'VIR_DOMAIN_SHUTDOWN'
op|'='
number|'4'
newline|'\n'
DECL|variable|VIR_DOMAIN_SHUTOFF
name|'VIR_DOMAIN_SHUTOFF'
op|'='
number|'5'
newline|'\n'
DECL|variable|VIR_DOMAIN_CRASHED
name|'VIR_DOMAIN_CRASHED'
op|'='
number|'6'
newline|'\n'
DECL|variable|VIR_DOMAIN_PMSUSPENDED
name|'VIR_DOMAIN_PMSUSPENDED'
op|'='
number|'7'
newline|'\n'
nl|'\n'
DECL|variable|LIBVIRT_POWER_STATE
name|'LIBVIRT_POWER_STATE'
op|'='
op|'{'
nl|'\n'
name|'VIR_DOMAIN_NOSTATE'
op|':'
name|'power_state'
op|'.'
name|'NOSTATE'
op|','
nl|'\n'
name|'VIR_DOMAIN_RUNNING'
op|':'
name|'power_state'
op|'.'
name|'RUNNING'
op|','
nl|'\n'
comment|'# NOTE(maoy): The DOMAIN_BLOCKED state is only valid in Xen.'
nl|'\n'
comment|'# It means that the VM is running and the vCPU is idle. So,'
nl|'\n'
comment|'# we map it to RUNNING'
nl|'\n'
name|'VIR_DOMAIN_BLOCKED'
op|':'
name|'power_state'
op|'.'
name|'RUNNING'
op|','
nl|'\n'
name|'VIR_DOMAIN_PAUSED'
op|':'
name|'power_state'
op|'.'
name|'PAUSED'
op|','
nl|'\n'
comment|'# NOTE(maoy): The libvirt API doc says that DOMAIN_SHUTDOWN'
nl|'\n'
comment|'# means the domain is being shut down. So technically the domain'
nl|'\n'
comment|'# is still running. SHUTOFF is the real powered off state.'
nl|'\n'
comment|'# But we will map both to SHUTDOWN anyway.'
nl|'\n'
comment|'# http://libvirt.org/html/libvirt-libvirt.html'
nl|'\n'
name|'VIR_DOMAIN_SHUTDOWN'
op|':'
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|','
nl|'\n'
name|'VIR_DOMAIN_SHUTOFF'
op|':'
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|','
nl|'\n'
name|'VIR_DOMAIN_CRASHED'
op|':'
name|'power_state'
op|'.'
name|'CRASHED'
op|','
nl|'\n'
name|'VIR_DOMAIN_PMSUSPENDED'
op|':'
name|'power_state'
op|'.'
name|'SUSPENDED'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
DECL|variable|MIN_LIBVIRT_VERSION
name|'MIN_LIBVIRT_VERSION'
op|'='
op|'('
number|'0'
op|','
number|'9'
op|','
number|'11'
op|')'
newline|'\n'
comment|'# When the above version matches/exceeds this version'
nl|'\n'
comment|'# delete it & corresponding code using it'
nl|'\n'
DECL|variable|MIN_LIBVIRT_DEVICE_CALLBACK_VERSION
name|'MIN_LIBVIRT_DEVICE_CALLBACK_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'1'
op|','
number|'1'
op|')'
newline|'\n'
comment|"# TODO(mriedem): Change MIN_LIB_VERSION to this in the 13.0.0 'M' release."
nl|'\n'
DECL|variable|NEXT_MIN_LIBVIRT_VERSION
name|'NEXT_MIN_LIBVIRT_VERSION'
op|'='
op|'('
number|'0'
op|','
number|'10'
op|','
number|'2'
op|')'
newline|'\n'
comment|'# Live snapshot requirements'
nl|'\n'
DECL|variable|MIN_LIBVIRT_LIVESNAPSHOT_VERSION
name|'MIN_LIBVIRT_LIVESNAPSHOT_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'0'
op|','
number|'0'
op|')'
newline|'\n'
DECL|variable|MIN_QEMU_LIVESNAPSHOT_VERSION
name|'MIN_QEMU_LIVESNAPSHOT_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'3'
op|','
number|'0'
op|')'
newline|'\n'
comment|'# block size tuning requirements'
nl|'\n'
DECL|variable|MIN_LIBVIRT_BLOCKIO_VERSION
name|'MIN_LIBVIRT_BLOCKIO_VERSION'
op|'='
op|'('
number|'0'
op|','
number|'10'
op|','
number|'2'
op|')'
newline|'\n'
comment|'# BlockJobInfo management requirement'
nl|'\n'
DECL|variable|MIN_LIBVIRT_BLOCKJOBINFO_VERSION
name|'MIN_LIBVIRT_BLOCKJOBINFO_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'1'
op|','
number|'1'
op|')'
newline|'\n'
comment|'# Relative block commit & rebase (feature is detected,'
nl|'\n'
comment|'# this version is only used for messaging)'
nl|'\n'
DECL|variable|MIN_LIBVIRT_BLOCKJOB_RELATIVE_VERSION
name|'MIN_LIBVIRT_BLOCKJOB_RELATIVE_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'2'
op|','
number|'7'
op|')'
newline|'\n'
comment|'# libvirt discard feature'
nl|'\n'
DECL|variable|MIN_LIBVIRT_DISCARD_VERSION
name|'MIN_LIBVIRT_DISCARD_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'0'
op|','
number|'6'
op|')'
newline|'\n'
DECL|variable|MIN_QEMU_DISCARD_VERSION
name|'MIN_QEMU_DISCARD_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'6'
op|','
number|'0'
op|')'
newline|'\n'
comment|'# While earlier versions could support NUMA reporting and'
nl|'\n'
comment|'# NUMA placement, not until 1.2.7 was there the ability'
nl|'\n'
comment|'# to pin guest nodes to host nodes, so mandate that. Without'
nl|'\n'
comment|'# this the scheduler cannot make guaranteed decisions, as the'
nl|'\n'
comment|'# guest placement may not match what was requested'
nl|'\n'
DECL|variable|MIN_LIBVIRT_NUMA_VERSION
name|'MIN_LIBVIRT_NUMA_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'2'
op|','
number|'7'
op|')'
newline|'\n'
comment|'# Versions of libvirt with known NUMA topology issues'
nl|'\n'
comment|'# See bug #1449028'
nl|'\n'
DECL|variable|BAD_LIBVIRT_NUMA_VERSIONS
name|'BAD_LIBVIRT_NUMA_VERSIONS'
op|'='
op|'['
op|'('
number|'1'
op|','
number|'2'
op|','
number|'9'
op|','
number|'2'
op|')'
op|']'
newline|'\n'
comment|'# While earlier versions could support hugepage backed'
nl|'\n'
comment|'# guests, not until 1.2.8 was there the ability to request'
nl|'\n'
comment|'# a particular huge page size. Without this the scheduler'
nl|'\n'
comment|'# cannot make guaranteed decisions, as the huge page size'
nl|'\n'
comment|'# used by the guest may not match what was requested'
nl|'\n'
DECL|variable|MIN_LIBVIRT_HUGEPAGE_VERSION
name|'MIN_LIBVIRT_HUGEPAGE_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'2'
op|','
number|'8'
op|')'
newline|'\n'
comment|'# Versions of libvirt with broken cpu pinning support. This excludes'
nl|'\n'
comment|'# versions of libvirt with broken NUMA support since pinning needs'
nl|'\n'
comment|'# NUMA'
nl|'\n'
comment|'# See bug #1438226'
nl|'\n'
DECL|variable|BAD_LIBVIRT_CPU_POLICY_VERSIONS
name|'BAD_LIBVIRT_CPU_POLICY_VERSIONS'
op|'='
op|'['
op|'('
number|'1'
op|','
number|'2'
op|','
number|'10'
op|')'
op|']'
newline|'\n'
comment|'# qemu 2.1 introduces support for pinning memory on host'
nl|'\n'
comment|'# NUMA nodes, along with the ability to specify hugepage'
nl|'\n'
comment|'# sizes per guest NUMA node'
nl|'\n'
DECL|variable|MIN_QEMU_NUMA_HUGEPAGE_VERSION
name|'MIN_QEMU_NUMA_HUGEPAGE_VERSION'
op|'='
op|'('
number|'2'
op|','
number|'1'
op|','
number|'0'
op|')'
newline|'\n'
comment|'# fsFreeze/fsThaw requirement'
nl|'\n'
DECL|variable|MIN_LIBVIRT_FSFREEZE_VERSION
name|'MIN_LIBVIRT_FSFREEZE_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'2'
op|','
number|'5'
op|')'
newline|'\n'
nl|'\n'
comment|'# Hyper-V paravirtualized time source'
nl|'\n'
DECL|variable|MIN_LIBVIRT_HYPERV_TIMER_VERSION
name|'MIN_LIBVIRT_HYPERV_TIMER_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'2'
op|','
number|'2'
op|')'
newline|'\n'
DECL|variable|MIN_QEMU_HYPERV_TIMER_VERSION
name|'MIN_QEMU_HYPERV_TIMER_VERSION'
op|'='
op|'('
number|'2'
op|','
number|'0'
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|MIN_LIBVIRT_HYPERV_FEATURE_VERSION
name|'MIN_LIBVIRT_HYPERV_FEATURE_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'0'
op|','
number|'0'
op|')'
newline|'\n'
DECL|variable|MIN_LIBVIRT_HYPERV_FEATURE_EXTRA_VERSION
name|'MIN_LIBVIRT_HYPERV_FEATURE_EXTRA_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'1'
op|','
number|'0'
op|')'
newline|'\n'
DECL|variable|MIN_QEMU_HYPERV_FEATURE_VERSION
name|'MIN_QEMU_HYPERV_FEATURE_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'1'
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
comment|'# parallels driver support'
nl|'\n'
DECL|variable|MIN_LIBVIRT_PARALLELS_VERSION
name|'MIN_LIBVIRT_PARALLELS_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'2'
op|','
number|'12'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|LibvirtDriver
name|'class'
name|'LibvirtDriver'
op|'('
name|'driver'
op|'.'
name|'ComputeDriver'
op|')'
op|':'
newline|'\n'
DECL|variable|capabilities
indent|'    '
name|'capabilities'
op|'='
op|'{'
nl|'\n'
string|'"has_imagecache"'
op|':'
name|'True'
op|','
nl|'\n'
string|'"supports_recreate"'
op|':'
name|'True'
op|','
nl|'\n'
string|'"supports_migrate_to_same_host"'
op|':'
name|'False'
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'virtapi'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'super'
op|'('
name|'LibvirtDriver'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'virtapi'
op|')'
newline|'\n'
nl|'\n'
name|'global'
name|'libvirt'
newline|'\n'
name|'if'
name|'libvirt'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'libvirt'
op|'='
name|'importutils'
op|'.'
name|'import_module'
op|'('
string|"'libvirt'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_host'
op|'='
name|'host'
op|'.'
name|'Host'
op|'('
name|'self'
op|'.'
name|'_uri'
op|'('
op|')'
op|','
name|'read_only'
op|','
nl|'\n'
name|'lifecycle_event_handler'
op|'='
name|'self'
op|'.'
name|'emit_event'
op|','
nl|'\n'
name|'conn_event_handler'
op|'='
name|'self'
op|'.'
name|'_handle_conn_event'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_initiator'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_fc_wwnns'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_fc_wwpns'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_caps'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'='
name|'firewall'
op|'.'
name|'load_driver'
op|'('
nl|'\n'
name|'DEFAULT_FIREWALL_DRIVER'
op|','
nl|'\n'
name|'self'
op|'.'
name|'virtapi'
op|','
nl|'\n'
name|'host'
op|'='
name|'self'
op|'.'
name|'_host'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'vif_driver'
op|'='
name|'libvirt_vif'
op|'.'
name|'LibvirtGenericVIFDriver'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'volume_drivers'
op|'='
name|'driver'
op|'.'
name|'driver_dict_from_config'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_get_volume_drivers'
op|'('
op|')'
op|','
name|'self'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_disk_cachemode'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'image_cache_manager'
op|'='
name|'imagecache'
op|'.'
name|'ImageCacheManager'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'image_backend'
op|'='
name|'imagebackend'
op|'.'
name|'Backend'
op|'('
name|'CONF'
op|'.'
name|'use_cow_images'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'disk_cachemodes'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'valid_cachemodes'
op|'='
op|'['
string|'"default"'
op|','
nl|'\n'
string|'"none"'
op|','
nl|'\n'
string|'"writethrough"'
op|','
nl|'\n'
string|'"writeback"'
op|','
nl|'\n'
string|'"directsync"'
op|','
nl|'\n'
string|'"unsafe"'
op|','
nl|'\n'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_conn_supports_start_paused'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
name|'in'
op|'('
string|"'kvm'"
op|','
nl|'\n'
string|"'qemu'"
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'mode_str'
name|'in'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'disk_cachemodes'
op|':'
newline|'\n'
indent|'            '
name|'disk_type'
op|','
name|'sep'
op|','
name|'cache_mode'
op|'='
name|'mode_str'
op|'.'
name|'partition'
op|'('
string|"'='"
op|')'
newline|'\n'
name|'if'
name|'cache_mode'
name|'not'
name|'in'
name|'self'
op|'.'
name|'valid_cachemodes'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'Invalid cachemode %(cache_mode)s specified '"
nl|'\n'
string|"'for disk type %(disk_type)s.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'cache_mode'"
op|':'
name|'cache_mode'
op|','
string|"'disk_type'"
op|':'
name|'disk_type'
op|'}'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'disk_cachemodes'
op|'['
name|'disk_type'
op|']'
op|'='
name|'cache_mode'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_volume_api'
op|'='
name|'volume'
op|'.'
name|'API'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_image_api'
op|'='
name|'image'
op|'.'
name|'API'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'sysinfo_serial_funcs'
op|'='
op|'{'
nl|'\n'
string|"'none'"
op|':'
name|'lambda'
op|':'
name|'None'
op|','
nl|'\n'
string|"'hardware'"
op|':'
name|'self'
op|'.'
name|'_get_host_sysinfo_serial_hardware'
op|','
nl|'\n'
string|"'os'"
op|':'
name|'self'
op|'.'
name|'_get_host_sysinfo_serial_os'
op|','
nl|'\n'
string|"'auto'"
op|':'
name|'self'
op|'.'
name|'_get_host_sysinfo_serial_auto'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_sysinfo_serial_func'
op|'='
name|'sysinfo_serial_funcs'
op|'.'
name|'get'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'sysinfo_serial'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_sysinfo_serial_func'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
nl|'\n'
name|'_'
op|'('
string|'"Unexpected sysinfo_serial setting \'%(actual)s\'. "'
nl|'\n'
string|'"Permitted values are %(expect)s\'"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'actual'"
op|':'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'sysinfo_serial'
op|','
nl|'\n'
string|"'expect'"
op|':'
string|"', '"
op|'.'
name|'join'
op|'('
string|'"\'%s\'"'
op|'%'
name|'k'
name|'for'
name|'k'
name|'in'
nl|'\n'
name|'sysinfo_serial_funcs'
op|'.'
name|'keys'
op|'('
op|')'
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_volume_drivers
dedent|''
dedent|''
name|'def'
name|'_get_volume_drivers'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'libvirt_volume_drivers'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|disk_cachemode
name|'def'
name|'disk_cachemode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_disk_cachemode'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|"# We prefer 'none' for consistent performance, host crash"
nl|'\n'
comment|'# safety & migration correctness by avoiding host page cache.'
nl|'\n'
comment|"# Some filesystems (eg GlusterFS via FUSE) don't support"
nl|'\n'
comment|"# O_DIRECT though. For those we fallback to 'writethrough'"
nl|'\n'
comment|'# which gives host crash safety, and is safe for migration'
nl|'\n'
comment|'# provided the filesystem is cache coherent (cluster filesystems'
nl|'\n'
comment|'# typically are, but things like NFS are not).'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_disk_cachemode'
op|'='
string|'"none"'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_supports_direct_io'
op|'('
name|'CONF'
op|'.'
name|'instances_path'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_disk_cachemode'
op|'='
string|'"writethrough"'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'_disk_cachemode'
newline|'\n'
nl|'\n'
DECL|member|_set_cache_mode
dedent|''
name|'def'
name|'_set_cache_mode'
op|'('
name|'self'
op|','
name|'conf'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Set cache mode on LibvirtConfigGuestDisk object."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'source_type'
op|'='
name|'conf'
op|'.'
name|'source_type'
newline|'\n'
name|'driver_cache'
op|'='
name|'conf'
op|'.'
name|'driver_cache'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'cache_mode'
op|'='
name|'self'
op|'.'
name|'disk_cachemodes'
op|'.'
name|'get'
op|'('
name|'source_type'
op|','
nl|'\n'
name|'driver_cache'
op|')'
newline|'\n'
name|'conf'
op|'.'
name|'driver_cache'
op|'='
name|'cache_mode'
newline|'\n'
nl|'\n'
DECL|member|_do_quality_warnings
dedent|''
name|'def'
name|'_do_quality_warnings'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Warn about untested driver configurations.\n\n        This will log a warning message about untested driver or host arch\n        configurations to indicate to administrators that the quality is\n        unknown. Currently, only qemu or kvm on intel 32- or 64-bit systems\n        is tested upstream.\n        """'
newline|'\n'
name|'caps'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_capabilities'
op|'('
op|')'
newline|'\n'
name|'hostarch'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'arch'
newline|'\n'
name|'if'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
name|'not'
name|'in'
op|'('
string|"'qemu'"
op|','
string|"'kvm'"
op|')'
name|'or'
nl|'\n'
name|'hostarch'
name|'not'
name|'in'
op|'('
name|'arch'
op|'.'
name|'I686'
op|','
name|'arch'
op|'.'
name|'X86_64'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'The libvirt driver is not tested on '"
nl|'\n'
string|"'%(type)s/%(arch)s by the OpenStack project and '"
nl|'\n'
string|"'thus its quality can not be ensured. For more '"
nl|'\n'
string|"'information, see: https://wiki.openstack.org/wiki/'"
nl|'\n'
string|"'HypervisorSupportMatrix'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'type'"
op|':'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
string|"'arch'"
op|':'
name|'hostarch'
op|'}'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_handle_conn_event
dedent|''
dedent|''
name|'def'
name|'_handle_conn_event'
op|'('
name|'self'
op|','
name|'enabled'
op|','
name|'reason'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Connection event \'%(enabled)d\' reason \'%(reason)s\'"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'enabled'"
op|':'
name|'enabled'
op|','
string|"'reason'"
op|':'
name|'reason'
op|'}'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_set_host_enabled'
op|'('
name|'enabled'
op|','
name|'reason'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_version_to_string
dedent|''
name|'def'
name|'_version_to_string'
op|'('
name|'self'
op|','
name|'version'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|"'.'"
op|'.'
name|'join'
op|'('
op|'['
name|'str'
op|'('
name|'x'
op|')'
name|'for'
name|'x'
name|'in'
name|'version'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|init_host
dedent|''
name|'def'
name|'init_host'
op|'('
name|'self'
op|','
name|'host'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_host'
op|'.'
name|'initialize'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_do_quality_warnings'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'lxc'"
name|'and'
nl|'\n'
name|'not'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'uid_maps'
name|'and'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'gid_maps'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Running libvirt-lxc without user namespaces is "'
nl|'\n'
string|'"dangerous. Containers spawned by Nova will be run "'
nl|'\n'
string|'"as the host\'s root user. It is highly suggested "'
nl|'\n'
string|'"that user namespaces be used in a public or "'
nl|'\n'
string|'"multi-tenant environment."'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|"# Stop libguestfs using KVM unless we're also configured"
nl|'\n'
comment|'# to use this. This solves problem where people need to'
nl|'\n'
comment|'# stop Nova use of KVM because nested-virt is broken'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'!='
string|'"kvm"'
op|':'
newline|'\n'
indent|'            '
name|'guestfs'
op|'.'
name|'force_tcg'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'has_min_version'
op|'('
name|'MIN_LIBVIRT_VERSION'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Nova requires libvirt version %s or greater.'"
op|')'
op|'%'
nl|'\n'
name|'self'
op|'.'
name|'_version_to_string'
op|'('
name|'MIN_LIBVIRT_VERSION'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'parallels'"
name|'and'
nl|'\n'
name|'not'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'has_min_version'
op|'('
name|'MIN_LIBVIRT_PARALLELS_VERSION'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Running Nova with parallels virt_type requires '"
nl|'\n'
string|"'libvirt version %s'"
op|')'
op|'%'
nl|'\n'
name|'self'
op|'.'
name|'_version_to_string'
op|'('
name|'MIN_LIBVIRT_PARALLELS_VERSION'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(mriedem): We plan to move to a minimum required version of'
nl|'\n'
comment|"# libvirt 0.10.2 in the 13.0.0 'M' release so if we're running with"
nl|'\n'
comment|'# less than that now, log a warning.'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'has_min_version'
op|'('
name|'NEXT_MIN_LIBVIRT_VERSION'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|"'Running Nova with a libvirt version less than '"
nl|'\n'
string|"'%(version)s is deprecated. The required minimum '"
nl|'\n'
string|"'version of libvirt will be raised to %(version)s '"
nl|'\n'
string|"'in the 13.0.0 release.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'version'"
op|':'
name|'self'
op|'.'
name|'_version_to_string'
op|'('
nl|'\n'
name|'NEXT_MIN_LIBVIRT_VERSION'
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(sahid): This method is targeted for removal when the tests'
nl|'\n'
comment|'# have been updated to avoid its use'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# All libvirt API calls on the libvirt.Connect object should be'
nl|'\n'
comment|'# encapsulated by methods on the nova.virt.libvirt.host.Host'
nl|'\n'
comment|'# object, rather than directly invoking the libvirt APIs. The goal'
nl|'\n'
comment|'# is to avoid a direct dependency on the libvirt API from the'
nl|'\n'
comment|'# driver.py file.'
nl|'\n'
DECL|member|_get_connection
dedent|''
dedent|''
name|'def'
name|'_get_connection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_connection'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|variable|_conn
dedent|''
name|'_conn'
op|'='
name|'property'
op|'('
name|'_get_connection'
op|')'
newline|'\n'
nl|'\n'
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_uri
name|'def'
name|'_uri'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'uml'"
op|':'
newline|'\n'
indent|'            '
name|'uri'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'connection_uri'
name|'or'
string|"'uml:///system'"
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'xen'"
op|':'
newline|'\n'
indent|'            '
name|'uri'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'connection_uri'
name|'or'
string|"'xen:///'"
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'lxc'"
op|':'
newline|'\n'
indent|'            '
name|'uri'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'connection_uri'
name|'or'
string|"'lxc:///'"
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'parallels'"
op|':'
newline|'\n'
indent|'            '
name|'uri'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'connection_uri'
name|'or'
string|"'parallels:///system'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'uri'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'connection_uri'
name|'or'
string|"'qemu:///system'"
newline|'\n'
dedent|''
name|'return'
name|'uri'
newline|'\n'
nl|'\n'
DECL|member|instance_exists
dedent|''
name|'def'
name|'instance_exists'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Efficient override of base instance_exists method."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'NovaException'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|list_instances
dedent|''
dedent|''
name|'def'
name|'list_instances'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'names'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'dom'
name|'in'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'list_instance_domains'
op|'('
name|'only_running'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'names'
op|'.'
name|'append'
op|'('
name|'dom'
op|'.'
name|'name'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'names'
newline|'\n'
nl|'\n'
DECL|member|list_instance_uuids
dedent|''
name|'def'
name|'list_instance_uuids'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'uuids'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'dom'
name|'in'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'list_instance_domains'
op|'('
name|'only_running'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'uuids'
op|'.'
name|'append'
op|'('
name|'dom'
op|'.'
name|'UUIDString'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'uuids'
newline|'\n'
nl|'\n'
DECL|member|plug_vifs
dedent|''
name|'def'
name|'plug_vifs'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Plug VIFs into networks."""'
newline|'\n'
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'plug'
op|'('
name|'instance'
op|','
name|'vif'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_unplug_vifs
dedent|''
dedent|''
name|'def'
name|'_unplug_vifs'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'ignore_errors'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Unplug VIFs from networks."""'
newline|'\n'
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'unplug'
op|'('
name|'instance'
op|','
name|'vif'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'NovaException'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'not'
name|'ignore_errors'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
newline|'\n'
nl|'\n'
DECL|member|unplug_vifs
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'unplug_vifs'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_unplug_vifs'
op|'('
name|'instance'
op|','
name|'network_info'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_teardown_container
dedent|''
name|'def'
name|'_teardown_container'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'inst_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'container_dir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_path'
op|','
string|"'rootfs'"
op|')'
newline|'\n'
name|'rootfs_dev'
op|'='
name|'instance'
op|'.'
name|'system_metadata'
op|'.'
name|'get'
op|'('
string|"'rootfs_device_name'"
op|')'
newline|'\n'
name|'disk'
op|'.'
name|'teardown_container'
op|'('
name|'container_dir'
op|','
name|'rootfs_dev'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_destroy
dedent|''
name|'def'
name|'_destroy'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'attempt'
op|'='
number|'1'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|"# If the instance is already terminated, we're still happy"
nl|'\n'
comment|'# Otherwise, destroy it'
nl|'\n'
dedent|''
name|'old_domid'
op|'='
op|'-'
number|'1'
newline|'\n'
name|'if'
name|'guest'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'old_domid'
op|'='
name|'guest'
op|'.'
name|'id'
newline|'\n'
name|'guest'
op|'.'
name|'poweroff'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'is_okay'
op|'='
name|'False'
newline|'\n'
name|'errcode'
op|'='
name|'e'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'errcode'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_DOMAIN'
op|':'
newline|'\n'
comment|'# Domain already gone. This can safely be ignored.'
nl|'\n'
indent|'                    '
name|'is_okay'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'elif'
name|'errcode'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_OPERATION_INVALID'
op|':'
newline|'\n'
comment|'# If the instance is already shut off, we get this:'
nl|'\n'
comment|'# Code=55 Error=Requested operation is not valid:'
nl|'\n'
comment|'# domain is not running'
nl|'\n'
nl|'\n'
comment|'# TODO(sahid): At this point we should be a Guest object'
nl|'\n'
indent|'                    '
name|'state'
op|'='
name|'self'
op|'.'
name|'_get_power_state'
op|'('
name|'guest'
op|'.'
name|'_domain'
op|')'
newline|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|':'
newline|'\n'
indent|'                        '
name|'is_okay'
op|'='
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'errcode'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_INTERNAL_ERROR'
op|':'
newline|'\n'
indent|'                    '
name|'errmsg'
op|'='
name|'e'
op|'.'
name|'get_error_message'
op|'('
op|')'
newline|'\n'
name|'if'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'lxc'"
name|'and'
nl|'\n'
name|'errmsg'
op|'=='
string|"'internal error: '"
nl|'\n'
string|"'Some processes refused to die'"
op|')'
op|':'
newline|'\n'
comment|"# Some processes in the container didn't die"
nl|'\n'
comment|'# fast enough for libvirt. The container will'
nl|'\n'
comment|'# eventually die. For now, move on and let'
nl|'\n'
comment|'# the wait_for_destroy logic take over.'
nl|'\n'
indent|'                        '
name|'is_okay'
op|'='
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'errcode'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_OPERATION_TIMEOUT'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Cannot destroy instance, operation time "'
nl|'\n'
string|'"out"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'reason'
op|'='
name|'_'
op|'('
string|'"operation time out"'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstancePowerOffFailure'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'errcode'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_SYSTEM_ERROR'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'e'
op|'.'
name|'get_int1'
op|'('
op|')'
op|'=='
name|'errno'
op|'.'
name|'EBUSY'
op|':'
newline|'\n'
comment|'# NOTE(danpb): When libvirt kills a process it sends it'
nl|'\n'
comment|"# SIGTERM first and waits 10 seconds. If it hasn't gone"
nl|'\n'
comment|'# it sends SIGKILL and waits another 5 seconds. If it'
nl|'\n'
comment|"# still hasn't gone then you get this EBUSY error."
nl|'\n'
comment|'# Usually when a QEMU process fails to go away upon'
nl|'\n'
comment|'# SIGKILL it is because it is stuck in an'
nl|'\n'
comment|'# uninterruptable kernel sleep waiting on I/O from'
nl|'\n'
comment|'# some non-responsive server.'
nl|'\n'
comment|'# Given the CPU load of the gate tests though, it is'
nl|'\n'
comment|'# conceivable that the 15 second timeout is too short,'
nl|'\n'
comment|'# particularly if the VM running tempest has a high'
nl|'\n'
comment|'# steal time from the cloud host. ie 15 wallclock'
nl|'\n'
comment|'# seconds may have passed, but the VM might have only'
nl|'\n'
comment|'# have a few seconds of scheduled run time.'
nl|'\n'
indent|'                        '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'Error from libvirt during destroy. '"
nl|'\n'
string|"'Code=%(errcode)s Error=%(e)s; '"
nl|'\n'
string|"'attempt %(attempt)d of 3'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'errcode'"
op|':'
name|'errcode'
op|','
string|"'e'"
op|':'
name|'e'
op|','
nl|'\n'
string|"'attempt'"
op|':'
name|'attempt'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
name|'as'
name|'ctxt'
op|':'
newline|'\n'
comment|'# Try up to 3 times before giving up.'
nl|'\n'
indent|'                            '
name|'if'
name|'attempt'
op|'<'
number|'3'
op|':'
newline|'\n'
indent|'                                '
name|'ctxt'
op|'.'
name|'reraise'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|','
name|'attempt'
op|'+'
number|'1'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'if'
name|'not'
name|'is_okay'
op|':'
newline|'\n'
indent|'                    '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'Error from libvirt during destroy. '"
nl|'\n'
string|"'Code=%(errcode)s Error=%(e)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'errcode'"
op|':'
name|'errcode'
op|','
string|"'e'"
op|':'
name|'e'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_wait_for_destroy
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_wait_for_destroy'
op|'('
name|'expected_domid'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Called at an interval until the VM is gone."""'
newline|'\n'
comment|'# NOTE(vish): If the instance disappears during the destroy'
nl|'\n'
comment|'#             we ignore it so the cleanup can still be'
nl|'\n'
comment|'#             attempted because we would prefer destroy to'
nl|'\n'
comment|'#             never fail.'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'dom_info'
op|'='
name|'self'
op|'.'
name|'get_info'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'state'
op|'='
name|'dom_info'
op|'.'
name|'state'
newline|'\n'
name|'new_domid'
op|'='
name|'dom_info'
op|'.'
name|'id'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"During wait destroy, instance disappeared."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance destroyed successfully."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(wangpan): If the instance was booted again after destroy,'
nl|'\n'
comment|'#                this may be a endless loop, so check the id of'
nl|'\n'
comment|'#                domain here, if it changed and the instance is'
nl|'\n'
comment|'#                still running, we should destroy it again.'
nl|'\n'
comment|'# see https://bugs.launchpad.net/nova/+bug/1111213 for more details'
nl|'\n'
dedent|''
name|'if'
name|'new_domid'
op|'!='
name|'expected_domid'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance may be started again."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'kwargs'
op|'['
string|"'is_running'"
op|']'
op|'='
name|'True'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'kwargs'
op|'='
op|'{'
string|"'is_running'"
op|':'
name|'False'
op|'}'
newline|'\n'
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
name|'_wait_for_destroy'
op|','
nl|'\n'
name|'old_domid'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
name|'if'
name|'kwargs'
op|'['
string|"'is_running'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Going to destroy instance again."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# NOTE(GuanQiang): teardown container to avoid resource leak'
nl|'\n'
indent|'            '
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'lxc'"
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_teardown_container'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|destroy
dedent|''
dedent|''
dedent|''
name|'def'
name|'destroy'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|'='
name|'None'
op|','
nl|'\n'
name|'destroy_disks'
op|'='
name|'True'
op|','
name|'migrate_data'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'cleanup'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|','
nl|'\n'
name|'destroy_disks'
op|','
name|'migrate_data'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_undefine_domain
dedent|''
name|'def'
name|'_undefine_domain'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'delete_configuration'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'errcode'
op|'='
name|'e'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'Error from libvirt during undefine. '"
nl|'\n'
string|"'Code=%(errcode)s Error=%(e)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'errcode'"
op|':'
name|'errcode'
op|','
string|"'e'"
op|':'
name|'e'
op|'}'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|cleanup
dedent|''
dedent|''
name|'def'
name|'cleanup'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|'='
name|'None'
op|','
nl|'\n'
name|'destroy_disks'
op|'='
name|'True'
op|','
name|'migrate_data'
op|'='
name|'None'
op|','
name|'destroy_vifs'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'destroy_vifs'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_unplug_vifs'
op|'('
name|'instance'
op|','
name|'network_info'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'retry'
op|'='
name|'True'
newline|'\n'
name|'while'
name|'retry'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'unfilter_instance'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'state'
op|'='
name|'self'
op|'.'
name|'get_info'
op|'('
name|'instance'
op|')'
op|'.'
name|'state'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'                    '
name|'state'
op|'='
name|'power_state'
op|'.'
name|'SHUTDOWN'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'state'
op|'!='
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Instance may be still running, destroy "'
nl|'\n'
string|'"it again."'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'retry'
op|'='
name|'False'
newline|'\n'
name|'errcode'
op|'='
name|'e'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Error from libvirt during unfilter. '"
nl|'\n'
string|"'Code=%(errcode)s Error=%(e)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'errcode'"
op|':'
name|'errcode'
op|','
string|"'e'"
op|':'
name|'e'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'reason'
op|'='
string|'"Error unfiltering instance."'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstanceTerminationFailure'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'retry'
op|'='
name|'False'
newline|'\n'
name|'raise'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'retry'
op|'='
name|'False'
newline|'\n'
nl|'\n'
comment|'# FIXME(wangpan): if the instance is booted again here, such as the'
nl|'\n'
comment|'#                 the soft reboot operation boot it here, it will'
nl|'\n'
comment|'#                 become "running deleted", should we check and destroy'
nl|'\n'
comment|'#                 it at the end of this method?'
nl|'\n'
nl|'\n'
comment|'# NOTE(vish): we disconnect from volumes regardless'
nl|'\n'
dedent|''
dedent|''
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'for'
name|'vol'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'            '
name|'connection_info'
op|'='
name|'vol'
op|'['
string|"'connection_info'"
op|']'
newline|'\n'
name|'disk_dev'
op|'='
name|'vol'
op|'['
string|"'mount_device'"
op|']'
newline|'\n'
name|'if'
name|'disk_dev'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'disk_dev'
op|'='
name|'disk_dev'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
string|"'data'"
name|'in'
name|'connection_info'
name|'and'
nl|'\n'
string|"'volume_id'"
name|'in'
name|'connection_info'
op|'['
string|"'data'"
op|']'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'volume_id'
op|'='
name|'connection_info'
op|'['
string|"'data'"
op|']'
op|'['
string|"'volume_id'"
op|']'
newline|'\n'
name|'encryption'
op|'='
name|'encryptors'
op|'.'
name|'get_encryption_metadata'
op|'('
nl|'\n'
name|'context'
op|','
name|'self'
op|'.'
name|'_volume_api'
op|','
name|'volume_id'
op|','
name|'connection_info'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'encryption'
op|':'
newline|'\n'
comment|'# The volume must be detached from the VM before'
nl|'\n'
comment|'# disconnecting it from its encryptor. Otherwise, the'
nl|'\n'
comment|'# encryptor may report that the volume is still in use.'
nl|'\n'
indent|'                    '
name|'encryptor'
op|'='
name|'self'
op|'.'
name|'_get_volume_encryptor'
op|'('
name|'connection_info'
op|','
nl|'\n'
name|'encryption'
op|')'
newline|'\n'
name|'encryptor'
op|'.'
name|'detach_volume'
op|'('
op|'**'
name|'encryption'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_disconnect_volume'
op|'('
name|'connection_info'
op|','
name|'disk_dev'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
name|'as'
name|'ctxt'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'destroy_disks'
op|':'
newline|'\n'
comment|"# Don't block on Volume errors if we're trying to"
nl|'\n'
comment|'# delete the instance as we may be partially created'
nl|'\n'
comment|'# or deleted'
nl|'\n'
indent|'                        '
name|'ctxt'
op|'.'
name|'reraise'
op|'='
name|'False'
newline|'\n'
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Ignoring Volume Error on vol %(vol_id)s "'
nl|'\n'
string|'"during delete %(exc)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'vol_id'"
op|':'
name|'vol'
op|'.'
name|'get'
op|'('
string|"'volume_id'"
op|')'
op|','
string|"'exc'"
op|':'
name|'exc'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'if'
name|'destroy_disks'
op|':'
newline|'\n'
comment|'# NOTE(haomai): destroy volumes if needed'
nl|'\n'
indent|'            '
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_type'
op|'=='
string|"'lvm'"
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_cleanup_lvm'
op|'('
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_type'
op|'=='
string|"'rbd'"
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_cleanup_rbd'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'destroy_disks'
name|'or'
op|'('
nl|'\n'
name|'migrate_data'
name|'and'
name|'migrate_data'
op|'.'
name|'get'
op|'('
string|"'is_shared_block_storage'"
op|','
nl|'\n'
name|'False'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'attempts'
op|'='
name|'int'
op|'('
name|'instance'
op|'.'
name|'system_metadata'
op|'.'
name|'get'
op|'('
string|"'clean_attempts'"
op|','
nl|'\n'
string|"'0'"
op|')'
op|')'
newline|'\n'
name|'success'
op|'='
name|'self'
op|'.'
name|'delete_instance_files'
op|'('
name|'instance'
op|')'
newline|'\n'
comment|'# NOTE(mriedem): This is used in the _run_pending_deletes periodic'
nl|'\n'
comment|'# task in the compute manager. The tight coupling is not great...'
nl|'\n'
name|'instance'
op|'.'
name|'system_metadata'
op|'['
string|"'clean_attempts'"
op|']'
op|'='
name|'str'
op|'('
name|'attempts'
op|'+'
number|'1'
op|')'
newline|'\n'
name|'if'
name|'success'
op|':'
newline|'\n'
indent|'                '
name|'instance'
op|'.'
name|'cleaned'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'instance'
op|'.'
name|'save'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'serial_console'
op|'.'
name|'enabled'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'serials'
op|'='
name|'self'
op|'.'
name|'_get_serial_ports_from_instance'
op|'('
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
comment|'# Serial ports already gone. Nothing to release.'
nl|'\n'
indent|'                '
name|'serials'
op|'='
op|'('
op|')'
newline|'\n'
dedent|''
name|'for'
name|'hostname'
op|','
name|'port'
name|'in'
name|'serials'
op|':'
newline|'\n'
indent|'                '
name|'serial_console'
op|'.'
name|'release_port'
op|'('
name|'host'
op|'='
name|'hostname'
op|','
name|'port'
op|'='
name|'port'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_undefine_domain'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_detach_encrypted_volumes
dedent|''
name|'def'
name|'_detach_encrypted_volumes'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Detaches encrypted volumes attached to instance."""'
newline|'\n'
name|'disks'
op|'='
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'self'
op|'.'
name|'get_instance_disk_info'
op|'('
name|'instance'
op|')'
op|')'
newline|'\n'
name|'encrypted_volumes'
op|'='
name|'filter'
op|'('
name|'dmcrypt'
op|'.'
name|'is_encrypted'
op|','
nl|'\n'
op|'['
name|'disk'
op|'['
string|"'path'"
op|']'
name|'for'
name|'disk'
name|'in'
name|'disks'
op|']'
op|')'
newline|'\n'
name|'for'
name|'path'
name|'in'
name|'encrypted_volumes'
op|':'
newline|'\n'
indent|'            '
name|'dmcrypt'
op|'.'
name|'delete_volume'
op|'('
name|'path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_serial_ports_from_instance
dedent|''
dedent|''
name|'def'
name|'_get_serial_ports_from_instance'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'mode'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns an iterator over serial port(s) configured on instance.\n\n        :param mode: Should be a value in (None, bind, connect)\n        """'
newline|'\n'
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'xml'
op|'='
name|'guest'
op|'.'
name|'get_xml_desc'
op|'('
op|')'
newline|'\n'
name|'tree'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
comment|"# The 'serial' device is the base for x86 platforms. Other platforms"
nl|'\n'
comment|"# (e.g. kvm on system z = arch.S390X) can only use 'console' devices."
nl|'\n'
name|'xpath_mode'
op|'='
string|'"[@mode=\'%s\']"'
op|'%'
name|'mode'
name|'if'
name|'mode'
name|'else'
string|'""'
newline|'\n'
name|'serial_tcp'
op|'='
string|'"./devices/serial[@type=\'tcp\']/source"'
op|'+'
name|'xpath_mode'
newline|'\n'
name|'console_tcp'
op|'='
string|'"./devices/console[@type=\'tcp\']/source"'
op|'+'
name|'xpath_mode'
newline|'\n'
nl|'\n'
name|'tcp_devices'
op|'='
name|'tree'
op|'.'
name|'findall'
op|'('
name|'serial_tcp'
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'tcp_devices'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'tcp_devices'
op|'='
name|'tree'
op|'.'
name|'findall'
op|'('
name|'console_tcp'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'source'
name|'in'
name|'tcp_devices'
op|':'
newline|'\n'
indent|'            '
name|'yield'
op|'('
name|'source'
op|'.'
name|'get'
op|'('
string|'"host"'
op|')'
op|','
name|'int'
op|'('
name|'source'
op|'.'
name|'get'
op|'('
string|'"service"'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_get_rbd_driver
name|'def'
name|'_get_rbd_driver'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'rbd_utils'
op|'.'
name|'RBDDriver'
op|'('
nl|'\n'
name|'pool'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_rbd_pool'
op|','
nl|'\n'
name|'ceph_conf'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_rbd_ceph_conf'
op|','
nl|'\n'
name|'rbd_user'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'rbd_user'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_cleanup_rbd
dedent|''
name|'def'
name|'_cleanup_rbd'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LibvirtDriver'
op|'.'
name|'_get_rbd_driver'
op|'('
op|')'
op|'.'
name|'cleanup_volumes'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_cleanup_lvm
dedent|''
name|'def'
name|'_cleanup_lvm'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Delete all LVM disks for given instance object."""'
newline|'\n'
name|'if'
name|'instance'
op|'.'
name|'get'
op|'('
string|"'ephemeral_key_uuid'"
op|')'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_detach_encrypted_volumes'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'disks'
op|'='
name|'self'
op|'.'
name|'_lvm_disks'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'disks'
op|':'
newline|'\n'
indent|'            '
name|'lvm'
op|'.'
name|'remove_volumes'
op|'('
name|'disks'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_lvm_disks
dedent|''
dedent|''
name|'def'
name|'_lvm_disks'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns all LVM disks for given instance object."""'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_volume_group'
op|':'
newline|'\n'
indent|'            '
name|'vg'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
string|"'/dev'"
op|','
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_volume_group'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'vg'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
op|'['
op|']'
newline|'\n'
dedent|''
name|'pattern'
op|'='
string|"'%s_'"
op|'%'
name|'instance'
op|'.'
name|'uuid'
newline|'\n'
nl|'\n'
DECL|function|belongs_to_instance
name|'def'
name|'belongs_to_instance'
op|'('
name|'disk'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'disk'
op|'.'
name|'startswith'
op|'('
name|'pattern'
op|')'
newline|'\n'
nl|'\n'
DECL|function|fullpath
dedent|''
name|'def'
name|'fullpath'
op|'('
name|'name'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'vg'
op|','
name|'name'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'logical_volumes'
op|'='
name|'lvm'
op|'.'
name|'list_volumes'
op|'('
name|'vg'
op|')'
newline|'\n'
nl|'\n'
name|'disk_names'
op|'='
name|'filter'
op|'('
name|'belongs_to_instance'
op|','
name|'logical_volumes'
op|')'
newline|'\n'
name|'disks'
op|'='
name|'map'
op|'('
name|'fullpath'
op|','
name|'disk_names'
op|')'
newline|'\n'
name|'return'
name|'disks'
newline|'\n'
dedent|''
name|'return'
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|get_volume_connector
dedent|''
name|'def'
name|'get_volume_connector'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'root_helper'
op|'='
name|'utils'
op|'.'
name|'_get_root_helper'
op|'('
op|')'
newline|'\n'
name|'return'
name|'connector'
op|'.'
name|'get_connector_properties'
op|'('
nl|'\n'
name|'root_helper'
op|','
name|'CONF'
op|'.'
name|'my_block_storage_ip'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'iscsi_use_multipath'
op|','
nl|'\n'
name|'enforce_multipath'
op|'='
name|'True'
op|','
nl|'\n'
name|'host'
op|'='
name|'CONF'
op|'.'
name|'host'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_cleanup_resize
dedent|''
name|'def'
name|'_cleanup_resize'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(wangpan): we get the pre-grizzly instance path firstly,'
nl|'\n'
comment|'#                so the backup dir of pre-grizzly instance can'
nl|'\n'
comment|'#                be deleted correctly with grizzly or later nova.'
nl|'\n'
indent|'        '
name|'pre_grizzly_name'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|','
nl|'\n'
name|'forceold'
op|'='
name|'True'
op|')'
newline|'\n'
name|'target'
op|'='
name|'pre_grizzly_name'
op|'+'
string|"'_resize'"
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'target'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'target'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
op|'+'
string|"'_resize'"
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'target'
op|')'
op|':'
newline|'\n'
comment|'# Deletion can fail over NFS, so retry the deletion as required.'
nl|'\n'
comment|'# Set maximum attempt as 5, most test can remove the directory'
nl|'\n'
comment|'# for the second time.'
nl|'\n'
indent|'            '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'rm'"
op|','
string|"'-rf'"
op|','
name|'target'
op|','
name|'delay_on_retry'
op|'='
name|'True'
op|','
nl|'\n'
name|'attempts'
op|'='
number|'5'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'instance'
op|'.'
name|'host'
op|'!='
name|'CONF'
op|'.'
name|'host'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_undefine_domain'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'unplug_vifs'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'unfilter_instance'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_volume_driver
dedent|''
dedent|''
name|'def'
name|'_get_volume_driver'
op|'('
name|'self'
op|','
name|'connection_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'driver_type'
op|'='
name|'connection_info'
op|'.'
name|'get'
op|'('
string|"'driver_volume_type'"
op|')'
newline|'\n'
name|'if'
name|'driver_type'
name|'not'
name|'in'
name|'self'
op|'.'
name|'volume_drivers'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'VolumeDriverNotFound'
op|'('
name|'driver_type'
op|'='
name|'driver_type'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'volume_drivers'
op|'['
name|'driver_type'
op|']'
newline|'\n'
nl|'\n'
DECL|member|_connect_volume
dedent|''
name|'def'
name|'_connect_volume'
op|'('
name|'self'
op|','
name|'connection_info'
op|','
name|'disk_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'driver'
op|'='
name|'self'
op|'.'
name|'_get_volume_driver'
op|'('
name|'connection_info'
op|')'
newline|'\n'
name|'driver'
op|'.'
name|'connect_volume'
op|'('
name|'connection_info'
op|','
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_disconnect_volume
dedent|''
name|'def'
name|'_disconnect_volume'
op|'('
name|'self'
op|','
name|'connection_info'
op|','
name|'disk_dev'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'driver'
op|'='
name|'self'
op|'.'
name|'_get_volume_driver'
op|'('
name|'connection_info'
op|')'
newline|'\n'
name|'driver'
op|'.'
name|'disconnect_volume'
op|'('
name|'connection_info'
op|','
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_volume_config
dedent|''
name|'def'
name|'_get_volume_config'
op|'('
name|'self'
op|','
name|'connection_info'
op|','
name|'disk_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'driver'
op|'='
name|'self'
op|'.'
name|'_get_volume_driver'
op|'('
name|'connection_info'
op|')'
newline|'\n'
name|'return'
name|'driver'
op|'.'
name|'get_config'
op|'('
name|'connection_info'
op|','
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_volume_encryptor
dedent|''
name|'def'
name|'_get_volume_encryptor'
op|'('
name|'self'
op|','
name|'connection_info'
op|','
name|'encryption'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'encryptor'
op|'='
name|'encryptors'
op|'.'
name|'get_volume_encryptor'
op|'('
name|'connection_info'
op|','
nl|'\n'
op|'**'
name|'encryption'
op|')'
newline|'\n'
name|'return'
name|'encryptor'
newline|'\n'
nl|'\n'
DECL|member|attach_volume
dedent|''
name|'def'
name|'attach_volume'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'connection_info'
op|','
name|'instance'
op|','
name|'mountpoint'
op|','
nl|'\n'
name|'disk_bus'
op|'='
name|'None'
op|','
name|'device_type'
op|'='
name|'None'
op|','
name|'encryption'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'image_meta'
op|'='
name|'utils'
op|'.'
name|'get_image_from_system_metadata'
op|'('
nl|'\n'
name|'instance'
op|'.'
name|'system_metadata'
op|')'
newline|'\n'
nl|'\n'
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'disk_dev'
op|'='
name|'mountpoint'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'bdm'
op|'='
op|'{'
nl|'\n'
string|"'device_name'"
op|':'
name|'disk_dev'
op|','
nl|'\n'
string|"'disk_bus'"
op|':'
name|'disk_bus'
op|','
nl|'\n'
string|"'device_type'"
op|':'
name|'device_type'
op|'}'
newline|'\n'
nl|'\n'
comment|'# Note(cfb): If the volume has a custom block size, check that'
nl|'\n'
comment|'#            that we are using QEMU/KVM and libvirt >= 0.10.2. The'
nl|'\n'
comment|'#            presence of a block size is considered mandatory by'
nl|'\n'
comment|"#            cinder so we fail if we can't honor the request."
nl|'\n'
name|'data'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'if'
op|'('
string|"'data'"
name|'in'
name|'connection_info'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'data'
op|'='
name|'connection_info'
op|'['
string|"'data'"
op|']'
newline|'\n'
dedent|''
name|'if'
op|'('
string|"'logical_block_size'"
name|'in'
name|'data'
name|'or'
string|"'physical_block_size'"
name|'in'
name|'data'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'!='
string|'"kvm"'
name|'and'
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'!='
string|'"qemu"'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
name|'_'
op|'('
string|'"Volume sets block size, but the current "'
nl|'\n'
string|'"libvirt hypervisor \'%s\' does not support custom "'
nl|'\n'
string|'"block size"'
op|')'
op|'%'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InvalidHypervisorType'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'has_min_version'
op|'('
name|'MIN_LIBVIRT_BLOCKIO_VERSION'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'ver'
op|'='
string|'"."'
op|'.'
name|'join'
op|'('
op|'['
name|'str'
op|'('
name|'x'
op|')'
name|'for'
name|'x'
name|'in'
name|'MIN_LIBVIRT_BLOCKIO_VERSION'
op|']'
op|')'
newline|'\n'
name|'msg'
op|'='
name|'_'
op|'('
string|'"Volume sets block size, but libvirt \'%s\' or later is "'
nl|'\n'
string|'"required."'
op|')'
op|'%'
name|'ver'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_info_from_bdm'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
nl|'\n'
name|'image_meta'
op|','
name|'bdm'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_connect_volume'
op|'('
name|'connection_info'
op|','
name|'disk_info'
op|')'
newline|'\n'
name|'conf'
op|'='
name|'self'
op|'.'
name|'_get_volume_config'
op|'('
name|'connection_info'
op|','
name|'disk_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_set_cache_mode'
op|'('
name|'conf'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'state'
op|'='
name|'self'
op|'.'
name|'_get_power_state'
op|'('
name|'guest'
op|'.'
name|'_domain'
op|')'
newline|'\n'
name|'live'
op|'='
name|'state'
name|'in'
op|'('
name|'power_state'
op|'.'
name|'RUNNING'
op|','
name|'power_state'
op|'.'
name|'PAUSED'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'encryption'
op|':'
newline|'\n'
indent|'                '
name|'encryptor'
op|'='
name|'self'
op|'.'
name|'_get_volume_encryptor'
op|'('
name|'connection_info'
op|','
nl|'\n'
name|'encryption'
op|')'
newline|'\n'
name|'encryptor'
op|'.'
name|'attach_volume'
op|'('
name|'context'
op|','
op|'**'
name|'encryption'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'guest'
op|'.'
name|'attach_device'
op|'('
name|'conf'
op|','
name|'persistent'
op|'='
name|'True'
op|','
name|'live'
op|'='
name|'live'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Failed to attach volume at mountpoint: %s'"
op|')'
op|','
nl|'\n'
name|'mountpoint'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'ex'
op|','
name|'libvirt'
op|'.'
name|'libvirtError'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'errcode'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'errcode'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_OPERATION_FAILED'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_disconnect_volume'
op|'('
name|'connection_info'
op|','
name|'disk_dev'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'DeviceIsBusy'
op|'('
name|'device'
op|'='
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_disconnect_volume'
op|'('
name|'connection_info'
op|','
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_swap_volume
dedent|''
dedent|''
dedent|''
name|'def'
name|'_swap_volume'
op|'('
name|'self'
op|','
name|'guest'
op|','
name|'disk_path'
op|','
name|'new_path'
op|','
name|'resize_to'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Swap existing disk with a new block device."""'
newline|'\n'
name|'dev'
op|'='
name|'guest'
op|'.'
name|'get_block_device'
op|'('
name|'disk_path'
op|')'
newline|'\n'
nl|'\n'
comment|"# Save a copy of the domain's persistent XML file"
nl|'\n'
name|'xml'
op|'='
name|'guest'
op|'.'
name|'get_xml_desc'
op|'('
name|'dump_inactive'
op|'='
name|'True'
op|','
name|'dump_sensitive'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
comment|'# Abort is an idempotent operation, so make sure any block'
nl|'\n'
comment|'# jobs which may have failed are ended.'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'dev'
op|'.'
name|'abort_job'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
comment|'# NOTE (rmk): blockRebase cannot be executed on persistent'
nl|'\n'
comment|'#             domains, so we need to temporarily undefine it.'
nl|'\n'
comment|'#             If any part of this block fails, the domain is'
nl|'\n'
comment|'#             re-defined regardless.'
nl|'\n'
indent|'            '
name|'if'
name|'guest'
op|'.'
name|'has_persistent_configuration'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'delete_configuration'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Start copy with VIR_DOMAIN_REBASE_REUSE_EXT flag to'
nl|'\n'
comment|'# allow writing to existing external volume file'
nl|'\n'
dedent|''
name|'dev'
op|'.'
name|'rebase'
op|'('
name|'new_path'
op|','
name|'copy'
op|'='
name|'True'
op|','
name|'reuse_ext'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
name|'while'
name|'dev'
op|'.'
name|'wait_for_job'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'time'
op|'.'
name|'sleep'
op|'('
number|'0.5'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'dev'
op|'.'
name|'abort_job'
op|'('
name|'pivot'
op|'='
name|'True'
op|')'
newline|'\n'
name|'if'
name|'resize_to'
op|':'
newline|'\n'
comment|"# NOTE(alex_xu): domain.blockJobAbort isn't sync call. This"
nl|'\n'
comment|'# is bug in libvirt. So we need waiting for the pivot is'
nl|'\n'
comment|'# finished. libvirt bug #1119173'
nl|'\n'
indent|'                '
name|'while'
name|'dev'
op|'.'
name|'wait_for_job'
op|'('
name|'wait_for_job_clean'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'time'
op|'.'
name|'sleep'
op|'('
number|'0.5'
op|')'
newline|'\n'
dedent|''
name|'dev'
op|'.'
name|'resize'
op|'('
name|'resize_to'
op|'*'
name|'units'
op|'.'
name|'Gi'
op|'/'
name|'units'
op|'.'
name|'Ki'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_host'
op|'.'
name|'write_instance_config'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
DECL|member|swap_volume
dedent|''
dedent|''
name|'def'
name|'swap_volume'
op|'('
name|'self'
op|','
name|'old_connection_info'
op|','
nl|'\n'
name|'new_connection_info'
op|','
name|'instance'
op|','
name|'mountpoint'
op|','
name|'resize_to'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'        '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'disk_dev'
op|'='
name|'mountpoint'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'if'
name|'not'
name|'guest'
op|'.'
name|'get_disk'
op|'('
name|'disk_dev'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'DiskNotFound'
op|'('
name|'location'
op|'='
name|'disk_dev'
op|')'
newline|'\n'
dedent|''
name|'disk_info'
op|'='
op|'{'
nl|'\n'
string|"'dev'"
op|':'
name|'disk_dev'
op|','
nl|'\n'
string|"'bus'"
op|':'
name|'blockinfo'
op|'.'
name|'get_disk_bus_for_disk_dev'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
name|'disk_dev'
op|')'
op|','
nl|'\n'
string|"'type'"
op|':'
string|"'disk'"
op|','
nl|'\n'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'_connect_volume'
op|'('
name|'new_connection_info'
op|','
name|'disk_info'
op|')'
newline|'\n'
name|'conf'
op|'='
name|'self'
op|'.'
name|'_get_volume_config'
op|'('
name|'new_connection_info'
op|','
name|'disk_info'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'conf'
op|'.'
name|'source_path'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_disconnect_volume'
op|'('
name|'new_connection_info'
op|','
name|'disk_dev'
op|')'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
name|'_'
op|'('
string|'"Swap only supports host devices"'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# Save updates made in connection_info when connect_volume was called'
nl|'\n'
dedent|''
name|'volume_id'
op|'='
name|'new_connection_info'
op|'.'
name|'get'
op|'('
string|"'serial'"
op|')'
newline|'\n'
name|'bdm'
op|'='
name|'objects'
op|'.'
name|'BlockDeviceMapping'
op|'.'
name|'get_by_volume_id'
op|'('
nl|'\n'
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
op|','
name|'volume_id'
op|')'
newline|'\n'
name|'driver_bdm'
op|'='
name|'driver_block_device'
op|'.'
name|'DriverVolumeBlockDevice'
op|'('
name|'bdm'
op|')'
newline|'\n'
name|'driver_bdm'
op|'['
string|"'connection_info'"
op|']'
op|'='
name|'new_connection_info'
newline|'\n'
name|'driver_bdm'
op|'.'
name|'save'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_swap_volume'
op|'('
name|'guest'
op|','
name|'disk_dev'
op|','
name|'conf'
op|'.'
name|'source_path'
op|','
name|'resize_to'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_disconnect_volume'
op|'('
name|'old_connection_info'
op|','
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_existing_domain_xml
dedent|''
name|'def'
name|'_get_existing_domain_xml'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'guest'
op|'.'
name|'get_xml_desc'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'image_meta'
op|'='
name|'utils'
op|'.'
name|'get_image_from_system_metadata'
op|'('
nl|'\n'
name|'instance'
op|'.'
name|'system_metadata'
op|')'
newline|'\n'
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_guest_xml'
op|'('
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
op|','
nl|'\n'
name|'instance'
op|','
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'xml'
newline|'\n'
nl|'\n'
DECL|member|detach_volume
dedent|''
name|'def'
name|'detach_volume'
op|'('
name|'self'
op|','
name|'connection_info'
op|','
name|'instance'
op|','
name|'mountpoint'
op|','
nl|'\n'
name|'encryption'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'disk_dev'
op|'='
name|'mountpoint'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'conf'
op|'='
name|'guest'
op|'.'
name|'get_disk'
op|'('
name|'disk_dev'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'conf'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'DiskNotFound'
op|'('
name|'location'
op|'='
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'state'
op|'='
name|'self'
op|'.'
name|'_get_power_state'
op|'('
name|'guest'
op|'.'
name|'_domain'
op|')'
newline|'\n'
name|'live'
op|'='
name|'state'
name|'in'
op|'('
name|'power_state'
op|'.'
name|'RUNNING'
op|','
name|'power_state'
op|'.'
name|'PAUSED'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'detach_device'
op|'('
name|'conf'
op|','
name|'persistent'
op|'='
name|'True'
op|','
name|'live'
op|'='
name|'live'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'encryption'
op|':'
newline|'\n'
comment|'# The volume must be detached from the VM before'
nl|'\n'
comment|'# disconnecting it from its encryptor. Otherwise, the'
nl|'\n'
comment|'# encryptor may report that the volume is still in use.'
nl|'\n'
indent|'                '
name|'encryptor'
op|'='
name|'self'
op|'.'
name|'_get_volume_encryptor'
op|'('
name|'connection_info'
op|','
nl|'\n'
name|'encryption'
op|')'
newline|'\n'
name|'encryptor'
op|'.'
name|'detach_volume'
op|'('
op|'**'
name|'encryption'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
comment|'# NOTE(zhaoqin): If the instance does not exist, _lookup_by_name()'
nl|'\n'
comment|'#                will throw InstanceNotFound exception. Need to'
nl|'\n'
comment|'#                disconnect volume under this circumstance.'
nl|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"During detach_volume, instance disappeared."'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
comment|'# NOTE(vish): This is called to cleanup volumes after live'
nl|'\n'
comment|'#             migration, so we should still disconnect even if'
nl|'\n'
comment|"#             the instance doesn't exist here anymore."
nl|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_DOMAIN'
op|':'
newline|'\n'
comment|'# NOTE(vish):'
nl|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"During detach_volume, instance disappeared."'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_disconnect_volume'
op|'('
name|'connection_info'
op|','
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
DECL|member|attach_interface
dedent|''
name|'def'
name|'attach_interface'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'vif'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'plug'
op|'('
name|'instance'
op|','
name|'vif'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'setup_basic_filtering'
op|'('
name|'instance'
op|','
op|'['
name|'vif'
op|']'
op|')'
newline|'\n'
name|'cfg'
op|'='
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'get_config'
op|'('
name|'instance'
op|','
name|'vif'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'instance'
op|'.'
name|'flavor'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'state'
op|'='
name|'self'
op|'.'
name|'_get_power_state'
op|'('
name|'guest'
op|'.'
name|'_domain'
op|')'
newline|'\n'
name|'live'
op|'='
name|'state'
name|'in'
op|'('
name|'power_state'
op|'.'
name|'RUNNING'
op|','
name|'power_state'
op|'.'
name|'PAUSED'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'attach_device'
op|'('
name|'cfg'
op|','
name|'persistent'
op|'='
name|'True'
op|','
name|'live'
op|'='
name|'live'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'attaching network adapter failed.'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|','
name|'exc_info'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'unplug'
op|'('
name|'instance'
op|','
name|'vif'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InterfaceAttachFailed'
op|'('
nl|'\n'
name|'instance_uuid'
op|'='
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
nl|'\n'
DECL|member|detach_interface
dedent|''
dedent|''
name|'def'
name|'detach_interface'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'vif'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'cfg'
op|'='
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'get_config'
op|'('
name|'instance'
op|','
name|'vif'
op|','
name|'None'
op|','
name|'instance'
op|'.'
name|'flavor'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'unplug'
op|'('
name|'instance'
op|','
name|'vif'
op|')'
newline|'\n'
name|'state'
op|'='
name|'self'
op|'.'
name|'_get_power_state'
op|'('
name|'guest'
op|'.'
name|'_domain'
op|')'
newline|'\n'
name|'live'
op|'='
name|'state'
name|'in'
op|'('
name|'power_state'
op|'.'
name|'RUNNING'
op|','
name|'power_state'
op|'.'
name|'PAUSED'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'detach_device'
op|'('
name|'cfg'
op|','
name|'persistent'
op|'='
name|'True'
op|','
name|'live'
op|'='
name|'live'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_DOMAIN'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"During detach_interface, "'
nl|'\n'
string|'"instance disappeared."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'detaching network adapter failed.'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|','
name|'exc_info'
op|'='
name|'True'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InterfaceDetachFailed'
op|'('
nl|'\n'
name|'instance_uuid'
op|'='
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_create_snapshot_metadata
dedent|''
dedent|''
dedent|''
name|'def'
name|'_create_snapshot_metadata'
op|'('
name|'self'
op|','
name|'image_meta'
op|','
name|'instance'
op|','
nl|'\n'
name|'img_fmt'
op|','
name|'snp_name'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'metadata'
op|'='
op|'{'
string|"'is_public'"
op|':'
name|'False'
op|','
nl|'\n'
string|"'status'"
op|':'
string|"'active'"
op|','
nl|'\n'
string|"'name'"
op|':'
name|'snp_name'
op|','
nl|'\n'
string|"'properties'"
op|':'
op|'{'
nl|'\n'
string|"'kernel_id'"
op|':'
name|'instance'
op|'.'
name|'kernel_id'
op|','
nl|'\n'
string|"'image_location'"
op|':'
string|"'snapshot'"
op|','
nl|'\n'
string|"'image_state'"
op|':'
string|"'available'"
op|','
nl|'\n'
string|"'owner_id'"
op|':'
name|'instance'
op|'.'
name|'project_id'
op|','
nl|'\n'
string|"'ramdisk_id'"
op|':'
name|'instance'
op|'.'
name|'ramdisk_id'
op|','
nl|'\n'
op|'}'
nl|'\n'
op|'}'
newline|'\n'
name|'if'
name|'instance'
op|'.'
name|'os_type'
op|':'
newline|'\n'
indent|'            '
name|'metadata'
op|'['
string|"'properties'"
op|']'
op|'['
string|"'os_type'"
op|']'
op|'='
name|'instance'
op|'.'
name|'os_type'
newline|'\n'
nl|'\n'
comment|'# NOTE(vish): glance forces ami disk format to be ami'
nl|'\n'
dedent|''
name|'if'
name|'image_meta'
op|'.'
name|'get'
op|'('
string|"'disk_format'"
op|')'
op|'=='
string|"'ami'"
op|':'
newline|'\n'
indent|'            '
name|'metadata'
op|'['
string|"'disk_format'"
op|']'
op|'='
string|"'ami'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'metadata'
op|'['
string|"'disk_format'"
op|']'
op|'='
name|'img_fmt'
newline|'\n'
nl|'\n'
dedent|''
name|'metadata'
op|'['
string|"'container_format'"
op|']'
op|'='
name|'image_meta'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'container_format'"
op|','
string|"'bare'"
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'metadata'
newline|'\n'
nl|'\n'
DECL|member|snapshot
dedent|''
name|'def'
name|'snapshot'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'image_id'
op|','
name|'update_task_state'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create snapshot from a running VM instance.\n\n        This command only works with qemu 0.14+\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(sahid): We are converting all calls from a'
nl|'\n'
comment|'# virDomain object to use nova.virt.libvirt.Guest.'
nl|'\n'
comment|'# We should be able to remove virt_dom at the end.'
nl|'\n'
name|'virt_dom'
op|'='
name|'guest'
op|'.'
name|'_domain'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotRunning'
op|'('
name|'instance_id'
op|'='
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'image_meta'
op|'='
name|'utils'
op|'.'
name|'get_image_from_system_metadata'
op|'('
nl|'\n'
name|'instance'
op|'.'
name|'system_metadata'
op|')'
newline|'\n'
nl|'\n'
name|'snapshot'
op|'='
name|'self'
op|'.'
name|'_image_api'
op|'.'
name|'get'
op|'('
name|'context'
op|','
name|'image_id'
op|')'
newline|'\n'
nl|'\n'
name|'disk_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'find_disk'
op|'('
name|'virt_dom'
op|')'
newline|'\n'
name|'source_format'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_disk_type'
op|'('
name|'disk_path'
op|')'
newline|'\n'
nl|'\n'
name|'image_format'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'snapshot_image_format'
name|'or'
name|'source_format'
newline|'\n'
nl|'\n'
comment|'# NOTE(bfilippov): save lvm and rbd as raw'
nl|'\n'
name|'if'
name|'image_format'
op|'=='
string|"'lvm'"
name|'or'
name|'image_format'
op|'=='
string|"'rbd'"
op|':'
newline|'\n'
indent|'            '
name|'image_format'
op|'='
string|"'raw'"
newline|'\n'
nl|'\n'
dedent|''
name|'metadata'
op|'='
name|'self'
op|'.'
name|'_create_snapshot_metadata'
op|'('
name|'image_meta'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'image_format'
op|','
nl|'\n'
name|'snapshot'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'snapshot_name'
op|'='
name|'uuid'
op|'.'
name|'uuid4'
op|'('
op|')'
op|'.'
name|'hex'
newline|'\n'
nl|'\n'
name|'state'
op|'='
name|'self'
op|'.'
name|'_get_power_state'
op|'('
name|'virt_dom'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(rmk): Live snapshots require QEMU 1.3 and Libvirt 1.0.0.'
nl|'\n'
comment|'#            These restrictions can be relaxed as other configurations'
nl|'\n'
comment|'#            can be validated.'
nl|'\n'
comment|'# NOTE(dgenin): Instances with LVM encrypted ephemeral storage require'
nl|'\n'
comment|'#               cold snapshots. Currently, checking for encryption is'
nl|'\n'
comment|'#               redundant because LVM supports only cold snapshots.'
nl|'\n'
comment|'#               It is necessary in case this situation changes in the'
nl|'\n'
comment|'#               future.'
nl|'\n'
name|'if'
op|'('
name|'self'
op|'.'
name|'_host'
op|'.'
name|'has_min_version'
op|'('
name|'MIN_LIBVIRT_LIVESNAPSHOT_VERSION'
op|','
nl|'\n'
name|'MIN_QEMU_LIVESNAPSHOT_VERSION'
op|','
nl|'\n'
name|'host'
op|'.'
name|'HV_DRIVER_QEMU'
op|')'
nl|'\n'
name|'and'
name|'source_format'
name|'not'
name|'in'
op|'('
string|"'lvm'"
op|','
string|"'rbd'"
op|')'
nl|'\n'
name|'and'
name|'not'
name|'CONF'
op|'.'
name|'ephemeral_storage_encryption'
op|'.'
name|'enabled'
nl|'\n'
name|'and'
name|'not'
name|'CONF'
op|'.'
name|'workarounds'
op|'.'
name|'disable_libvirt_livesnapshot'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'live_snapshot'
op|'='
name|'True'
newline|'\n'
comment|'# Abort is an idempotent operation, so make sure any block'
nl|'\n'
comment|'# jobs which may have failed are ended. This operation also'
nl|'\n'
comment|'# confirms the running instance, as opposed to the system as a'
nl|'\n'
comment|'# whole, has a new enough version of the hypervisor (bug 1193146).'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'virt_dom'
op|'.'
name|'blockJobAbort'
op|'('
name|'disk_path'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'                '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_CONFIG_UNSUPPORTED'
op|':'
newline|'\n'
indent|'                    '
name|'live_snapshot'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'pass'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'live_snapshot'
op|'='
name|'False'
newline|'\n'
nl|'\n'
comment|'# NOTE(rmk): We cannot perform live snapshots when a managedSave'
nl|'\n'
comment|'#            file is present, so we will use the cold/legacy method'
nl|'\n'
comment|'#            for instances which are shutdown.'
nl|'\n'
dedent|''
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|':'
newline|'\n'
indent|'            '
name|'live_snapshot'
op|'='
name|'False'
newline|'\n'
nl|'\n'
comment|'# NOTE(dkang): managedSave does not work for LXC'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'!='
string|"'lxc'"
name|'and'
name|'not'
name|'live_snapshot'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
name|'or'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'PAUSED'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_detach_pci_devices'
op|'('
name|'guest'
op|','
nl|'\n'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_detach_sriov_ports'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'guest'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'save_memory_state'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'snapshot_backend'
op|'='
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'snapshot'
op|'('
name|'instance'
op|','
nl|'\n'
name|'disk_path'
op|','
nl|'\n'
name|'image_type'
op|'='
name|'source_format'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'live_snapshot'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Beginning live snapshot process"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Beginning cold snapshot process"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'update_task_state'
op|'('
name|'task_state'
op|'='
name|'task_states'
op|'.'
name|'IMAGE_PENDING_UPLOAD'
op|')'
newline|'\n'
name|'snapshot_directory'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'snapshots_directory'
newline|'\n'
name|'fileutils'
op|'.'
name|'ensure_tree'
op|'('
name|'snapshot_directory'
op|')'
newline|'\n'
name|'with'
name|'utils'
op|'.'
name|'tempdir'
op|'('
name|'dir'
op|'='
name|'snapshot_directory'
op|')'
name|'as'
name|'tmpdir'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'out_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'tmpdir'
op|','
name|'snapshot_name'
op|')'
newline|'\n'
name|'if'
name|'live_snapshot'
op|':'
newline|'\n'
comment|'# NOTE(xqueralt): libvirt needs o+x in the temp directory'
nl|'\n'
indent|'                    '
name|'os'
op|'.'
name|'chmod'
op|'('
name|'tmpdir'
op|','
number|'0o701'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_live_snapshot'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'guest'
op|','
name|'disk_path'
op|','
nl|'\n'
name|'out_path'
op|','
name|'image_format'
op|','
name|'image_meta'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'snapshot_backend'
op|'.'
name|'snapshot_extract'
op|'('
name|'out_path'
op|','
name|'image_format'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'='
name|'None'
newline|'\n'
comment|'# NOTE(dkang): because previous managedSave is not called'
nl|'\n'
comment|'#              for LXC, _create_domain must not be called.'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'!='
string|"'lxc'"
name|'and'
name|'not'
name|'live_snapshot'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
indent|'                        '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_create_domain'
op|'('
name|'domain'
op|'='
name|'virt_dom'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'PAUSED'
op|':'
newline|'\n'
indent|'                        '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_create_domain'
op|'('
nl|'\n'
name|'domain'
op|'='
name|'virt_dom'
op|','
name|'pause'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'guest'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'_attach_pci_devices'
op|'('
name|'guest'
op|','
nl|'\n'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_attach_sriov_ports'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'guest'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Snapshot extracted, beginning image upload"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# Upload that image to the image service'
nl|'\n'
nl|'\n'
dedent|''
name|'update_task_state'
op|'('
name|'task_state'
op|'='
name|'task_states'
op|'.'
name|'IMAGE_UPLOADING'
op|','
nl|'\n'
name|'expected_state'
op|'='
name|'task_states'
op|'.'
name|'IMAGE_PENDING_UPLOAD'
op|')'
newline|'\n'
name|'with'
name|'libvirt_utils'
op|'.'
name|'file_open'
op|'('
name|'out_path'
op|')'
name|'as'
name|'image_file'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_image_api'
op|'.'
name|'update'
op|'('
name|'context'
op|','
nl|'\n'
name|'image_id'
op|','
nl|'\n'
name|'metadata'
op|','
nl|'\n'
name|'image_file'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Snapshot image upload complete"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_can_quiesce
dedent|''
dedent|''
dedent|''
name|'def'
name|'_can_quiesce'
op|'('
name|'self'
op|','
name|'image_meta'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
name|'not'
name|'in'
op|'('
string|"'kvm'"
op|','
string|"'qemu'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'('
name|'False'
op|','
name|'_'
op|'('
string|"'Only KVM and QEMU are supported'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'has_min_version'
op|'('
name|'MIN_LIBVIRT_FSFREEZE_VERSION'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'ver'
op|'='
string|'"."'
op|'.'
name|'join'
op|'('
op|'['
name|'str'
op|'('
name|'x'
op|')'
name|'for'
name|'x'
name|'in'
name|'MIN_LIBVIRT_FSFREEZE_VERSION'
op|']'
op|')'
newline|'\n'
name|'return'
op|'('
name|'False'
op|','
name|'_'
op|'('
string|"'Quiescing requires libvirt version %(version)s '"
nl|'\n'
string|"'or greater'"
op|')'
op|'%'
op|'{'
string|"'version'"
op|':'
name|'ver'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'img_meta_prop'
op|'='
name|'image_meta'
op|'.'
name|'get'
op|'('
string|"'properties'"
op|','
op|'{'
op|'}'
op|')'
name|'if'
name|'image_meta'
name|'else'
op|'{'
op|'}'
newline|'\n'
name|'hw_qga'
op|'='
name|'img_meta_prop'
op|'.'
name|'get'
op|'('
string|"'hw_qemu_guest_agent'"
op|','
string|"''"
op|')'
newline|'\n'
name|'if'
name|'not'
name|'strutils'
op|'.'
name|'bool_from_string'
op|'('
name|'hw_qga'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'('
name|'False'
op|','
name|'_'
op|'('
string|"'QEMU guest agent is not enabled'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
op|'('
name|'True'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_set_quiesced
dedent|''
name|'def'
name|'_set_quiesced'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'quiesced'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'supported'
op|','
name|'reason'
op|'='
name|'self'
op|'.'
name|'_can_quiesce'
op|'('
name|'image_meta'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'supported'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'InstanceQuiesceNotSupported'
op|'('
nl|'\n'
name|'instance_id'
op|'='
name|'instance'
op|'.'
name|'uuid'
op|','
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(sahid): We are converting all calls from a'
nl|'\n'
comment|'# virDomain object to use nova.virt.libvirt.Guest.'
nl|'\n'
comment|'# We should be able to remove domain at the end.'
nl|'\n'
name|'domain'
op|'='
name|'guest'
op|'.'
name|'_domain'
newline|'\n'
name|'if'
name|'quiesced'
op|':'
newline|'\n'
indent|'                '
name|'domain'
op|'.'
name|'fsFreeze'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'domain'
op|'.'
name|'fsThaw'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|"'Error from libvirt while quiescing %(instance_name)s: '"
nl|'\n'
string|"'[Error Code %(error_code)s] %(ex)s'"
op|')'
nl|'\n'
op|'%'
op|'{'
string|"'instance_name'"
op|':'
name|'instance'
op|'.'
name|'name'
op|','
nl|'\n'
string|"'error_code'"
op|':'
name|'error_code'
op|','
string|"'ex'"
op|':'
name|'ex'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|quiesce
dedent|''
dedent|''
name|'def'
name|'quiesce'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'image_meta'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Freeze the guest filesystems to prepare for snapshot.\n\n        The qemu-guest-agent must be setup to execute fsfreeze.\n        """'
newline|'\n'
name|'self'
op|'.'
name|'_set_quiesced'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
DECL|member|unquiesce
dedent|''
name|'def'
name|'unquiesce'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'image_meta'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Thaw the guest filesystems after snapshot."""'
newline|'\n'
name|'self'
op|'.'
name|'_set_quiesced'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_live_snapshot
dedent|''
name|'def'
name|'_live_snapshot'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'guest'
op|','
name|'disk_path'
op|','
name|'out_path'
op|','
nl|'\n'
name|'image_format'
op|','
name|'image_meta'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Snapshot an instance without downtime."""'
newline|'\n'
name|'dev'
op|'='
name|'guest'
op|'.'
name|'get_block_device'
op|'('
name|'disk_path'
op|')'
newline|'\n'
nl|'\n'
comment|"# Save a copy of the domain's persistent XML file"
nl|'\n'
name|'xml'
op|'='
name|'guest'
op|'.'
name|'get_xml_desc'
op|'('
name|'dump_inactive'
op|'='
name|'True'
op|','
name|'dump_sensitive'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
comment|'# Abort is an idempotent operation, so make sure any block'
nl|'\n'
comment|'# jobs which may have failed are ended.'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'dev'
op|'.'
name|'abort_job'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
comment|'# NOTE (rmk): We are using shallow rebases as a workaround to a bug'
nl|'\n'
comment|'#             in QEMU 1.3. In order to do this, we need to create'
nl|'\n'
comment|'#             a destination image with the original backing file'
nl|'\n'
comment|'#             and matching size of the instance root disk.'
nl|'\n'
dedent|''
name|'src_disk_size'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_disk_size'
op|'('
name|'disk_path'
op|')'
newline|'\n'
name|'src_back_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_disk_backing_file'
op|'('
name|'disk_path'
op|','
nl|'\n'
name|'basename'
op|'='
name|'False'
op|')'
newline|'\n'
name|'disk_delta'
op|'='
name|'out_path'
op|'+'
string|"'.delta'"
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'create_cow_image'
op|'('
name|'src_back_path'
op|','
name|'disk_delta'
op|','
nl|'\n'
name|'src_disk_size'
op|')'
newline|'\n'
nl|'\n'
name|'img_meta_prop'
op|'='
name|'image_meta'
op|'.'
name|'get'
op|'('
string|"'properties'"
op|','
op|'{'
op|'}'
op|')'
name|'if'
name|'image_meta'
name|'else'
op|'{'
op|'}'
newline|'\n'
name|'require_quiesce'
op|'='
name|'strutils'
op|'.'
name|'bool_from_string'
op|'('
nl|'\n'
name|'img_meta_prop'
op|'.'
name|'get'
op|'('
string|"'os_require_quiesce'"
op|','
string|"''"
op|')'
op|')'
newline|'\n'
name|'if'
name|'require_quiesce'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'quiesce'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'image_meta'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
comment|'# NOTE (rmk): blockRebase cannot be executed on persistent'
nl|'\n'
comment|'#             domains, so we need to temporarily undefine it.'
nl|'\n'
comment|'#             If any part of this block fails, the domain is'
nl|'\n'
comment|'#             re-defined regardless.'
nl|'\n'
indent|'            '
name|'if'
name|'guest'
op|'.'
name|'has_persistent_configuration'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'delete_configuration'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE (rmk): Establish a temporary mirror of our root disk and'
nl|'\n'
comment|'#             issue an abort once we have a complete copy.'
nl|'\n'
dedent|''
name|'dev'
op|'.'
name|'rebase'
op|'('
name|'disk_delta'
op|','
name|'copy'
op|'='
name|'True'
op|','
name|'reuse_ext'
op|'='
name|'True'
op|','
name|'shallow'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
name|'while'
name|'dev'
op|'.'
name|'wait_for_job'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'time'
op|'.'
name|'sleep'
op|'('
number|'0.5'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'dev'
op|'.'
name|'abort_job'
op|'('
op|')'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'chown'
op|'('
name|'disk_delta'
op|','
name|'os'
op|'.'
name|'getuid'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_host'
op|'.'
name|'write_instance_config'
op|'('
name|'xml'
op|')'
newline|'\n'
name|'if'
name|'require_quiesce'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'unquiesce'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'image_meta'
op|')'
newline|'\n'
nl|'\n'
comment|'# Convert the delta (CoW) image with a backing file to a flat'
nl|'\n'
comment|'# image with no backing file.'
nl|'\n'
dedent|''
dedent|''
name|'libvirt_utils'
op|'.'
name|'extract_snapshot'
op|'('
name|'disk_delta'
op|','
string|"'qcow2'"
op|','
nl|'\n'
name|'out_path'
op|','
name|'image_format'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_volume_snapshot_update_status
dedent|''
name|'def'
name|'_volume_snapshot_update_status'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'snapshot_id'
op|','
name|'status'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Send a snapshot status update to Cinder.\n\n        This method captures and logs exceptions that occur\n        since callers cannot do anything useful with these exceptions.\n\n        Operations on the Cinder side waiting for this will time out if\n        a failure occurs sending the update.\n\n        :param context: security context\n        :param snapshot_id: id of snapshot being updated\n        :param status: new status value\n\n        """'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_volume_api'
op|'.'
name|'update_snapshot_status'
op|'('
name|'context'
op|','
nl|'\n'
name|'snapshot_id'
op|','
nl|'\n'
name|'status'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Failed to send updated snapshot status '"
nl|'\n'
string|"'to volume service.'"
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_volume_snapshot_create
dedent|''
dedent|''
name|'def'
name|'_volume_snapshot_create'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'domain'
op|','
nl|'\n'
name|'volume_id'
op|','
name|'new_file'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Perform volume snapshot.\n\n           :param domain: VM that volume is attached to\n           :param volume_id: volume UUID to snapshot\n           :param new_file: relative path to new qcow2 file present on share\n\n        """'
newline|'\n'
nl|'\n'
comment|'# TODO(sahid): An object Guest should be passed instead of'
nl|'\n'
comment|'# a "domain" as virDomain.'
nl|'\n'
name|'guest'
op|'='
name|'libvirt_guest'
op|'.'
name|'Guest'
op|'('
name|'domain'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'guest'
op|'.'
name|'get_xml_desc'
op|'('
op|')'
newline|'\n'
name|'xml_doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
name|'device_info'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuest'
op|'('
op|')'
newline|'\n'
name|'device_info'
op|'.'
name|'parse_dom'
op|'('
name|'xml_doc'
op|')'
newline|'\n'
nl|'\n'
name|'disks_to_snap'
op|'='
op|'['
op|']'
comment|'# to be snapshotted by libvirt'
newline|'\n'
name|'network_disks_to_snap'
op|'='
op|'['
op|']'
comment|'# network disks (netfs, gluster, etc.)'
newline|'\n'
name|'disks_to_skip'
op|'='
op|'['
op|']'
comment|'# local disks not snapshotted'
newline|'\n'
nl|'\n'
name|'for'
name|'guest_disk'
name|'in'
name|'device_info'
op|'.'
name|'devices'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
name|'guest_disk'
op|'.'
name|'root_name'
op|'!='
string|"'disk'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'guest_disk'
op|'.'
name|'target_dev'
name|'is'
name|'None'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'guest_disk'
op|'.'
name|'serial'
name|'is'
name|'None'
name|'or'
name|'guest_disk'
op|'.'
name|'serial'
op|'!='
name|'volume_id'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'disks_to_skip'
op|'.'
name|'append'
op|'('
name|'guest_disk'
op|'.'
name|'target_dev'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
comment|'# disk is a Cinder volume with the correct volume_id'
nl|'\n'
nl|'\n'
dedent|''
name|'disk_info'
op|'='
op|'{'
nl|'\n'
string|"'dev'"
op|':'
name|'guest_disk'
op|'.'
name|'target_dev'
op|','
nl|'\n'
string|"'serial'"
op|':'
name|'guest_disk'
op|'.'
name|'serial'
op|','
nl|'\n'
string|"'current_file'"
op|':'
name|'guest_disk'
op|'.'
name|'source_path'
op|','
nl|'\n'
string|"'source_protocol'"
op|':'
name|'guest_disk'
op|'.'
name|'source_protocol'
op|','
nl|'\n'
string|"'source_name'"
op|':'
name|'guest_disk'
op|'.'
name|'source_name'
op|','
nl|'\n'
string|"'source_hosts'"
op|':'
name|'guest_disk'
op|'.'
name|'source_hosts'
op|','
nl|'\n'
string|"'source_ports'"
op|':'
name|'guest_disk'
op|'.'
name|'source_ports'
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
comment|'# Determine path for new_file based on current path'
nl|'\n'
name|'if'
name|'disk_info'
op|'['
string|"'current_file'"
op|']'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'current_file'
op|'='
name|'disk_info'
op|'['
string|"'current_file'"
op|']'
newline|'\n'
name|'new_file_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'dirname'
op|'('
name|'current_file'
op|')'
op|','
nl|'\n'
name|'new_file'
op|')'
newline|'\n'
name|'disks_to_snap'
op|'.'
name|'append'
op|'('
op|'('
name|'current_file'
op|','
name|'new_file_path'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'disk_info'
op|'['
string|"'source_protocol'"
op|']'
name|'in'
op|'('
string|"'gluster'"
op|','
string|"'netfs'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'network_disks_to_snap'
op|'.'
name|'append'
op|'('
op|'('
name|'disk_info'
op|','
name|'new_file'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'disks_to_snap'
name|'and'
name|'not'
name|'network_disks_to_snap'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|"'Found no disk to snapshot.'"
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'snapshot'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSnapshot'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'current_name'
op|','
name|'new_filename'
name|'in'
name|'disks_to_snap'
op|':'
newline|'\n'
indent|'            '
name|'snap_disk'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSnapshotDisk'
op|'('
op|')'
newline|'\n'
name|'snap_disk'
op|'.'
name|'name'
op|'='
name|'current_name'
newline|'\n'
name|'snap_disk'
op|'.'
name|'source_path'
op|'='
name|'new_filename'
newline|'\n'
name|'snap_disk'
op|'.'
name|'source_type'
op|'='
string|"'file'"
newline|'\n'
name|'snap_disk'
op|'.'
name|'snapshot'
op|'='
string|"'external'"
newline|'\n'
name|'snap_disk'
op|'.'
name|'driver_name'
op|'='
string|"'qcow2'"
newline|'\n'
nl|'\n'
name|'snapshot'
op|'.'
name|'add_disk'
op|'('
name|'snap_disk'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'disk_info'
op|','
name|'new_filename'
name|'in'
name|'network_disks_to_snap'
op|':'
newline|'\n'
indent|'            '
name|'snap_disk'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSnapshotDisk'
op|'('
op|')'
newline|'\n'
name|'snap_disk'
op|'.'
name|'name'
op|'='
name|'disk_info'
op|'['
string|"'dev'"
op|']'
newline|'\n'
name|'snap_disk'
op|'.'
name|'source_type'
op|'='
string|"'network'"
newline|'\n'
name|'snap_disk'
op|'.'
name|'source_protocol'
op|'='
name|'disk_info'
op|'['
string|"'source_protocol'"
op|']'
newline|'\n'
name|'snap_disk'
op|'.'
name|'snapshot'
op|'='
string|"'external'"
newline|'\n'
name|'snap_disk'
op|'.'
name|'source_path'
op|'='
name|'new_filename'
newline|'\n'
name|'old_dir'
op|'='
name|'disk_info'
op|'['
string|"'source_name'"
op|']'
op|'.'
name|'split'
op|'('
string|"'/'"
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'snap_disk'
op|'.'
name|'source_name'
op|'='
string|"'%s/%s'"
op|'%'
op|'('
name|'old_dir'
op|','
name|'new_filename'
op|')'
newline|'\n'
name|'snap_disk'
op|'.'
name|'source_hosts'
op|'='
name|'disk_info'
op|'['
string|"'source_hosts'"
op|']'
newline|'\n'
name|'snap_disk'
op|'.'
name|'source_ports'
op|'='
name|'disk_info'
op|'['
string|"'source_ports'"
op|']'
newline|'\n'
nl|'\n'
name|'snapshot'
op|'.'
name|'add_disk'
op|'('
name|'snap_disk'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'dev'
name|'in'
name|'disks_to_skip'
op|':'
newline|'\n'
indent|'            '
name|'snap_disk'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSnapshotDisk'
op|'('
op|')'
newline|'\n'
name|'snap_disk'
op|'.'
name|'name'
op|'='
name|'dev'
newline|'\n'
name|'snap_disk'
op|'.'
name|'snapshot'
op|'='
string|"'no'"
newline|'\n'
nl|'\n'
name|'snapshot'
op|'.'
name|'add_disk'
op|'('
name|'snap_disk'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'snapshot_xml'
op|'='
name|'snapshot'
op|'.'
name|'to_xml'
op|'('
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"snap xml: %s"'
op|','
name|'snapshot_xml'
op|')'
newline|'\n'
nl|'\n'
name|'snap_flags'
op|'='
op|'('
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY'
op|'|'
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA'
op|'|'
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT'
op|')'
newline|'\n'
nl|'\n'
name|'QUIESCE'
op|'='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'domain'
op|'.'
name|'snapshotCreateXML'
op|'('
name|'snapshot_xml'
op|','
nl|'\n'
name|'snap_flags'
op|'|'
name|'QUIESCE'
op|')'
newline|'\n'
nl|'\n'
name|'return'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Unable to create quiesced VM snapshot, '"
nl|'\n'
string|"'attempting again with quiescing disabled.'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'domain'
op|'.'
name|'snapshotCreateXML'
op|'('
name|'snapshot_xml'
op|','
name|'snap_flags'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Unable to create VM snapshot, '"
nl|'\n'
string|"'failing volume_snapshot operation.'"
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'raise'
newline|'\n'
nl|'\n'
DECL|member|_volume_refresh_connection_info
dedent|''
dedent|''
name|'def'
name|'_volume_refresh_connection_info'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'volume_id'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'bdm'
op|'='
name|'objects'
op|'.'
name|'BlockDeviceMapping'
op|'.'
name|'get_by_volume_id'
op|'('
name|'context'
op|','
nl|'\n'
name|'volume_id'
op|')'
newline|'\n'
nl|'\n'
name|'driver_bdm'
op|'='
name|'driver_block_device'
op|'.'
name|'convert_volume'
op|'('
name|'bdm'
op|')'
newline|'\n'
name|'if'
name|'driver_bdm'
op|':'
newline|'\n'
indent|'            '
name|'driver_bdm'
op|'.'
name|'refresh_connection_info'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_volume_api'
op|','
name|'self'
op|')'
newline|'\n'
nl|'\n'
DECL|member|volume_snapshot_create
dedent|''
dedent|''
name|'def'
name|'volume_snapshot_create'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'volume_id'
op|','
nl|'\n'
name|'create_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create snapshots of a Cinder volume via libvirt.\n\n        :param instance: VM instance object reference\n        :param volume_id: id of volume being snapshotted\n        :param create_info: dict of information used to create snapshots\n                     - snapshot_id : ID of snapshot\n                     - type : qcow2 / <other>\n                     - new_file : qcow2 file created by Cinder which\n                     becomes the VM\'s active image after\n                     the snapshot is complete\n        """'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"volume_snapshot_create: create_info: %(c_info)s"'
op|','
nl|'\n'
op|'{'
string|"'c_info'"
op|':'
name|'create_info'
op|'}'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(sahid): We are converting all calls from a'
nl|'\n'
comment|'# virDomain object to use nova.virt.libvirt.Guest.'
nl|'\n'
comment|'# We should be able to remove virt_dom at the end.'
nl|'\n'
name|'virt_dom'
op|'='
name|'guest'
op|'.'
name|'_domain'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotRunning'
op|'('
name|'instance_id'
op|'='
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'create_info'
op|'['
string|"'type'"
op|']'
op|'!='
string|"'qcow2'"
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'_'
op|'('
string|"'Unknown type: %s'"
op|')'
op|'%'
nl|'\n'
name|'create_info'
op|'['
string|"'type'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'snapshot_id'
op|'='
name|'create_info'
op|'.'
name|'get'
op|'('
string|"'snapshot_id'"
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'snapshot_id'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'_'
op|'('
string|"'snapshot_id required '"
nl|'\n'
string|"'in create_info'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_volume_snapshot_create'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'virt_dom'
op|','
nl|'\n'
name|'volume_id'
op|','
name|'create_info'
op|'['
string|"'new_file'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Error occurred during '"
nl|'\n'
string|"'volume_snapshot_create, '"
nl|'\n'
string|"'sending error status to Cinder.'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_volume_snapshot_update_status'
op|'('
nl|'\n'
name|'context'
op|','
name|'snapshot_id'
op|','
string|"'error'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_volume_snapshot_update_status'
op|'('
nl|'\n'
name|'context'
op|','
name|'snapshot_id'
op|','
string|"'creating'"
op|')'
newline|'\n'
nl|'\n'
DECL|function|_wait_for_snapshot
name|'def'
name|'_wait_for_snapshot'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'snapshot'
op|'='
name|'self'
op|'.'
name|'_volume_api'
op|'.'
name|'get_snapshot'
op|'('
name|'context'
op|','
name|'snapshot_id'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'snapshot'
op|'.'
name|'get'
op|'('
string|"'status'"
op|')'
op|'!='
string|"'creating'"
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_volume_refresh_connection_info'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'volume_id'
op|')'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
name|'_wait_for_snapshot'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_volume_snapshot_delete
dedent|''
name|'def'
name|'_volume_snapshot_delete'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'volume_id'
op|','
nl|'\n'
name|'snapshot_id'
op|','
name|'delete_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Note:\n            if file being merged into == active image:\n                do a blockRebase (pull) operation\n            else:\n                do a blockCommit operation\n            Files must be adjacent in snap chain.\n\n        :param instance: instance object reference\n        :param volume_id: volume UUID\n        :param snapshot_id: snapshot UUID (unused currently)\n        :param delete_info: {\n            \'type\':              \'qcow2\',\n            \'file_to_merge\':     \'a.img\',\n            \'merge_target_file\': \'b.img\' or None (if merging file_to_merge into\n                                                  active image)\n          }\n\n\n        Libvirt blockjob handling required for this method is broken\n        in versions of libvirt that do not contain:\n        http://libvirt.org/git/?p=libvirt.git;h=0f9e67bfad (1.1.1)\n        (Patch is pending in 1.0.5-maint branch as well, but we cannot detect\n        libvirt 1.0.5.5 vs. 1.0.5.6 here.)\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'has_min_version'
op|'('
name|'MIN_LIBVIRT_BLOCKJOBINFO_VERSION'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'ver'
op|'='
string|"'.'"
op|'.'
name|'join'
op|'('
op|'['
name|'str'
op|'('
name|'x'
op|')'
name|'for'
name|'x'
name|'in'
name|'MIN_LIBVIRT_BLOCKJOBINFO_VERSION'
op|']'
op|')'
newline|'\n'
name|'msg'
op|'='
name|'_'
op|'('
string|'"Libvirt \'%s\' or later is required for online deletion "'
nl|'\n'
string|'"of volume snapshots."'
op|')'
op|'%'
name|'ver'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'volume_snapshot_delete: delete_info: %s'"
op|','
name|'delete_info'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'delete_info'
op|'['
string|"'type'"
op|']'
op|'!='
string|"'qcow2'"
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|"'Unknown delete_info type %s'"
op|')'
op|'%'
name|'delete_info'
op|'['
string|"'type'"
op|']'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotRunning'
op|'('
name|'instance_id'
op|'='
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
nl|'\n'
comment|'# Find dev name'
nl|'\n'
dedent|''
name|'my_dev'
op|'='
name|'None'
newline|'\n'
name|'active_disk'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'xml'
op|'='
name|'guest'
op|'.'
name|'get_xml_desc'
op|'('
op|')'
newline|'\n'
name|'xml_doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
name|'device_info'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuest'
op|'('
op|')'
newline|'\n'
name|'device_info'
op|'.'
name|'parse_dom'
op|'('
name|'xml_doc'
op|')'
newline|'\n'
nl|'\n'
name|'active_disk_object'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'for'
name|'guest_disk'
name|'in'
name|'device_info'
op|'.'
name|'devices'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
name|'guest_disk'
op|'.'
name|'root_name'
op|'!='
string|"'disk'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'guest_disk'
op|'.'
name|'target_dev'
name|'is'
name|'None'
name|'or'
name|'guest_disk'
op|'.'
name|'serial'
name|'is'
name|'None'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'guest_disk'
op|'.'
name|'serial'
op|'=='
name|'volume_id'
op|':'
newline|'\n'
indent|'                '
name|'my_dev'
op|'='
name|'guest_disk'
op|'.'
name|'target_dev'
newline|'\n'
nl|'\n'
name|'active_disk'
op|'='
name|'guest_disk'
op|'.'
name|'source_path'
newline|'\n'
name|'active_protocol'
op|'='
name|'guest_disk'
op|'.'
name|'source_protocol'
newline|'\n'
name|'active_disk_object'
op|'='
name|'guest_disk'
newline|'\n'
name|'break'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'my_dev'
name|'is'
name|'None'
name|'or'
op|'('
name|'active_disk'
name|'is'
name|'None'
name|'and'
name|'active_protocol'
name|'is'
name|'None'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|"'Disk with id: %s '"
nl|'\n'
string|"'not found attached to instance.'"
op|')'
op|'%'
name|'volume_id'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Domain XML: %s'"
op|','
name|'xml'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"found device at %s"'
op|','
name|'my_dev'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_get_snap_dev
name|'def'
name|'_get_snap_dev'
op|'('
name|'filename'
op|','
name|'backing_store'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'filename'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
name|'_'
op|'('
string|"'filename cannot be None'"
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
comment|'# libgfapi delete'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"XML: %s"'
op|'%'
name|'xml'
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"active disk object: %s"'
op|'%'
name|'active_disk_object'
op|')'
newline|'\n'
nl|'\n'
comment|'# determine reference within backing store for desired image'
nl|'\n'
name|'filename_to_merge'
op|'='
name|'filename'
newline|'\n'
name|'matched_name'
op|'='
name|'None'
newline|'\n'
name|'b'
op|'='
name|'backing_store'
newline|'\n'
name|'index'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'current_filename'
op|'='
name|'active_disk_object'
op|'.'
name|'source_name'
op|'.'
name|'split'
op|'('
string|"'/'"
op|')'
op|'['
number|'1'
op|']'
newline|'\n'
name|'if'
name|'current_filename'
op|'=='
name|'filename_to_merge'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'my_dev'
op|'+'
string|"'[0]'"
newline|'\n'
nl|'\n'
dedent|''
name|'while'
name|'b'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'source_filename'
op|'='
name|'b'
op|'.'
name|'source_name'
op|'.'
name|'split'
op|'('
string|"'/'"
op|')'
op|'['
number|'1'
op|']'
newline|'\n'
name|'if'
name|'source_filename'
op|'=='
name|'filename_to_merge'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'found match: %s'"
op|'%'
name|'b'
op|'.'
name|'source_name'
op|')'
newline|'\n'
name|'matched_name'
op|'='
name|'b'
op|'.'
name|'source_name'
newline|'\n'
name|'index'
op|'='
name|'b'
op|'.'
name|'index'
newline|'\n'
name|'break'
newline|'\n'
nl|'\n'
dedent|''
name|'b'
op|'='
name|'b'
op|'.'
name|'backing_store'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'matched_name'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
name|'_'
op|'('
string|"'no match found for %s'"
op|')'
op|'%'
op|'('
name|'filename_to_merge'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'index of match (%s) is %s'"
op|'%'
op|'('
name|'b'
op|'.'
name|'source_name'
op|','
name|'index'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'my_snap_dev'
op|'='
string|"'%s[%s]'"
op|'%'
op|'('
name|'my_dev'
op|','
name|'index'
op|')'
newline|'\n'
name|'return'
name|'my_snap_dev'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'delete_info'
op|'['
string|"'merge_target_file'"
op|']'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|'# pull via blockRebase()'
nl|'\n'
nl|'\n'
comment|'# Merge the most recent snapshot into the active image'
nl|'\n'
nl|'\n'
indent|'            '
name|'rebase_disk'
op|'='
name|'my_dev'
newline|'\n'
name|'rebase_base'
op|'='
name|'delete_info'
op|'['
string|"'file_to_merge'"
op|']'
comment|'# often None'
newline|'\n'
name|'if'
name|'active_protocol'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'rebase_base'
op|'='
name|'_get_snap_dev'
op|'('
name|'delete_info'
op|'['
string|"'file_to_merge'"
op|']'
op|','
nl|'\n'
name|'active_disk_object'
op|'.'
name|'backing_store'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(deepakcs): libvirt added support for _RELATIVE in v1.2.7,'
nl|'\n'
comment|'# and when available this flag _must_ be used to ensure backing'
nl|'\n'
comment|'# paths are maintained relative by qemu.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# If _RELATIVE flag not found, continue with old behaviour'
nl|'\n'
comment|'# (relative backing path seems to work for this case)'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_BLOCK_REBASE_RELATIVE'
newline|'\n'
name|'relative'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Relative blockrebase support was not detected. "'
nl|'\n'
string|'"Continuing with old behaviour."'
op|')'
op|')'
newline|'\n'
name|'relative'
op|'='
name|'False'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
nl|'\n'
string|"'disk: %(disk)s, base: %(base)s, '"
nl|'\n'
string|"'bw: %(bw)s, relative: %(relative)s'"
op|','
nl|'\n'
op|'{'
string|"'disk'"
op|':'
name|'rebase_disk'
op|','
nl|'\n'
string|"'base'"
op|':'
name|'rebase_base'
op|','
nl|'\n'
string|"'bw'"
op|':'
name|'libvirt_guest'
op|'.'
name|'BlockDevice'
op|'.'
name|'REBASE_DEFAULT_BANDWIDTH'
op|','
nl|'\n'
string|"'relative'"
op|':'
name|'str'
op|'('
name|'relative'
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'dev'
op|'='
name|'guest'
op|'.'
name|'get_block_device'
op|'('
name|'rebase_disk'
op|')'
newline|'\n'
name|'result'
op|'='
name|'dev'
op|'.'
name|'rebase'
op|'('
name|'rebase_base'
op|','
name|'relative'
op|'='
name|'relative'
op|')'
newline|'\n'
name|'if'
name|'result'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'blockRebase started successfully'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'while'
name|'dev'
op|'.'
name|'wait_for_job'
op|'('
name|'abort_on_error'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'waiting for blockRebase job completion'"
op|')'
newline|'\n'
name|'time'
op|'.'
name|'sleep'
op|'('
number|'0.5'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# commit with blockCommit()'
nl|'\n'
indent|'            '
name|'my_snap_base'
op|'='
name|'None'
newline|'\n'
name|'my_snap_top'
op|'='
name|'None'
newline|'\n'
name|'commit_disk'
op|'='
name|'my_dev'
newline|'\n'
nl|'\n'
comment|'# NOTE(deepakcs): libvirt added support for _RELATIVE in v1.2.7,'
nl|'\n'
comment|'# and when available this flag _must_ be used to ensure backing'
nl|'\n'
comment|'# paths are maintained relative by qemu.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# If _RELATIVE flag not found, raise exception as relative backing'
nl|'\n'
comment|'# path may not be maintained and Cinder flow is broken if allowed'
nl|'\n'
comment|'# to continue.'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_BLOCK_COMMIT_RELATIVE'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'                '
name|'ver'
op|'='
string|"'.'"
op|'.'
name|'join'
op|'('
nl|'\n'
op|'['
name|'str'
op|'('
name|'x'
op|')'
name|'for'
name|'x'
name|'in'
nl|'\n'
name|'MIN_LIBVIRT_BLOCKJOB_RELATIVE_VERSION'
op|']'
op|')'
newline|'\n'
name|'msg'
op|'='
name|'_'
op|'('
string|'"Relative blockcommit support was not detected. "'
nl|'\n'
string|'"Libvirt \'%s\' or later is required for online "'
nl|'\n'
string|'"deletion of file/network storage-backed volume "'
nl|'\n'
string|'"snapshots."'
op|')'
op|'%'
name|'ver'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'active_protocol'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'my_snap_base'
op|'='
name|'_get_snap_dev'
op|'('
name|'delete_info'
op|'['
string|"'merge_target_file'"
op|']'
op|','
nl|'\n'
name|'active_disk_object'
op|'.'
name|'backing_store'
op|')'
newline|'\n'
name|'my_snap_top'
op|'='
name|'_get_snap_dev'
op|'('
name|'delete_info'
op|'['
string|"'file_to_merge'"
op|']'
op|','
nl|'\n'
name|'active_disk_object'
op|'.'
name|'backing_store'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'commit_base'
op|'='
name|'my_snap_base'
name|'or'
name|'delete_info'
op|'['
string|"'merge_target_file'"
op|']'
newline|'\n'
name|'commit_top'
op|'='
name|'my_snap_top'
name|'or'
name|'delete_info'
op|'['
string|"'file_to_merge'"
op|']'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'will call blockCommit with commit_disk=%(commit_disk)s '"
nl|'\n'
string|"'commit_base=%(commit_base)s '"
nl|'\n'
string|"'commit_top=%(commit_top)s '"
nl|'\n'
op|'%'
op|'{'
string|"'commit_disk'"
op|':'
name|'commit_disk'
op|','
nl|'\n'
string|"'commit_base'"
op|':'
name|'commit_base'
op|','
nl|'\n'
string|"'commit_top'"
op|':'
name|'commit_top'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'dev'
op|'='
name|'guest'
op|'.'
name|'get_block_device'
op|'('
name|'commit_disk'
op|')'
newline|'\n'
name|'result'
op|'='
name|'dev'
op|'.'
name|'commit'
op|'('
name|'commit_base'
op|','
name|'commit_top'
op|','
name|'relative'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'result'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'blockCommit started successfully'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'while'
name|'dev'
op|'.'
name|'wait_for_job'
op|'('
name|'abort_on_error'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'waiting for blockCommit job completion'"
op|')'
newline|'\n'
name|'time'
op|'.'
name|'sleep'
op|'('
number|'0.5'
op|')'
newline|'\n'
nl|'\n'
DECL|member|volume_snapshot_delete
dedent|''
dedent|''
dedent|''
name|'def'
name|'volume_snapshot_delete'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'volume_id'
op|','
name|'snapshot_id'
op|','
nl|'\n'
name|'delete_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_volume_snapshot_delete'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'volume_id'
op|','
nl|'\n'
name|'snapshot_id'
op|','
name|'delete_info'
op|'='
name|'delete_info'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Error occurred during '"
nl|'\n'
string|"'volume_snapshot_delete, '"
nl|'\n'
string|"'sending error status to Cinder.'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_volume_snapshot_update_status'
op|'('
nl|'\n'
name|'context'
op|','
name|'snapshot_id'
op|','
string|"'error_deleting'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_volume_snapshot_update_status'
op|'('
name|'context'
op|','
name|'snapshot_id'
op|','
string|"'deleting'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_volume_refresh_connection_info'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'volume_id'
op|')'
newline|'\n'
nl|'\n'
DECL|member|reboot
dedent|''
name|'def'
name|'reboot'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'reboot_type'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'bad_volumes_callback'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Reboot a virtual machine, given an instance reference."""'
newline|'\n'
name|'if'
name|'reboot_type'
op|'=='
string|"'SOFT'"
op|':'
newline|'\n'
comment|'# NOTE(vish): This will attempt to do a graceful shutdown/restart.'
nl|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'soft_reboot_success'
op|'='
name|'self'
op|'.'
name|'_soft_reboot'
op|'('
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Instance soft reboot failed: %s"'
op|','
name|'e'
op|')'
newline|'\n'
name|'soft_reboot_success'
op|'='
name|'False'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'soft_reboot_success'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance soft rebooted successfully."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Failed to soft reboot instance. "'
nl|'\n'
string|'"Trying hard reboot."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'_hard_reboot'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_soft_reboot
dedent|''
name|'def'
name|'_soft_reboot'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Attempt to shutdown and restart the instance gracefully.\n\n        We use shutdown and create here so we can return if the guest\n        responded and actually rebooted. Note that this method only\n        succeeds if the guest responds to acpi. Therefore we return\n        success or failure so we can fall back to a hard reboot if\n        necessary.\n\n        :returns: True if the reboot succeeded\n        """'
newline|'\n'
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(sahid): We are converting all calls from a'
nl|'\n'
comment|'# virDomain object to use nova.virt.libvirt.Guest.'
nl|'\n'
comment|'# We should be able to remove dom at the end.'
nl|'\n'
name|'dom'
op|'='
name|'guest'
op|'.'
name|'_domain'
newline|'\n'
name|'state'
op|'='
name|'self'
op|'.'
name|'_get_power_state'
op|'('
name|'dom'
op|')'
newline|'\n'
name|'old_domid'
op|'='
name|'dom'
op|'.'
name|'ID'
op|'('
op|')'
newline|'\n'
comment|'# NOTE(vish): This check allows us to reboot an instance that'
nl|'\n'
comment|'#             is already shutdown.'
nl|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
indent|'            '
name|'dom'
op|'.'
name|'shutdown'
op|'('
op|')'
newline|'\n'
comment|'# NOTE(vish): This actually could take slightly longer than the'
nl|'\n'
comment|'#             FLAG defines depending on how long the get_info'
nl|'\n'
comment|'#             call takes to return.'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_prepare_pci_devices_for_use'
op|'('
nl|'\n'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|','
string|"'all'"
op|')'
op|')'
newline|'\n'
name|'for'
name|'x'
name|'in'
name|'xrange'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'wait_soft_reboot_seconds'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(sahid): We are converting all calls from a'
nl|'\n'
comment|'# virDomain object to use nova.virt.libvirt.Guest.'
nl|'\n'
comment|'# We should be able to remove dom at the end.'
nl|'\n'
name|'dom'
op|'='
name|'guest'
op|'.'
name|'_domain'
newline|'\n'
name|'state'
op|'='
name|'self'
op|'.'
name|'_get_power_state'
op|'('
name|'dom'
op|')'
newline|'\n'
name|'new_domid'
op|'='
name|'dom'
op|'.'
name|'ID'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(ivoks): By checking domain IDs, we make sure we are'
nl|'\n'
comment|"#              not recreating domain that's already running."
nl|'\n'
name|'if'
name|'old_domid'
op|'!='
name|'new_domid'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'state'
name|'in'
op|'['
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|','
nl|'\n'
name|'power_state'
op|'.'
name|'CRASHED'
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance shutdown successfully."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_domain'
op|'('
name|'domain'
op|'='
name|'dom'
op|')'
newline|'\n'
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_wait_for_running'
op|','
name|'instance'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance may have been rebooted during soft "'
nl|'\n'
string|'"reboot, so return now."'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'greenthread'
op|'.'
name|'sleep'
op|'('
number|'1'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|_hard_reboot
dedent|''
name|'def'
name|'_hard_reboot'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Reboot a virtual machine, given an instance reference.\n\n        Performs a Libvirt reset (if supported) on the domain.\n\n        If Libvirt reset is unavailable this method actually destroys and\n        re-creates the domain to ensure the reboot happens, as the guest\n        OS cannot ignore this action.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# Convert the system metadata to image metadata'
nl|'\n'
name|'image_meta'
op|'='
name|'utils'
op|'.'
name|'get_image_from_system_metadata'
op|'('
nl|'\n'
name|'instance'
op|'.'
name|'system_metadata'
op|')'
newline|'\n'
nl|'\n'
name|'instance_dir'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'fileutils'
op|'.'
name|'ensure_tree'
op|'('
name|'instance_dir'
op|')'
newline|'\n'
nl|'\n'
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
comment|'# NOTE(vish): This could generate the wrong device_format if we are'
nl|'\n'
comment|"#             using the raw backend and the images don't exist yet."
nl|'\n'
comment|"#             The create_images_and_backing below doesn't properly"
nl|'\n'
comment|'#             regenerate raw backend images, however, so when it'
nl|'\n'
comment|'#             does we need to (re)generate the xml after the images'
nl|'\n'
comment|'#             are in place.'
nl|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_guest_xml'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|','
nl|'\n'
name|'write_to_disk'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE (rmk): Re-populate any missing backing files.'
nl|'\n'
name|'disk_info'
op|'='
name|'self'
op|'.'
name|'_get_instance_disk_info'
op|'('
name|'instance'
op|'.'
name|'name'
op|','
name|'xml'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'context'
op|'.'
name|'auth_token'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_create_images_and_backing'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'instance_dir'
op|','
nl|'\n'
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
comment|'# Initialize all the necessary networking, block devices and'
nl|'\n'
comment|'# start the instance.'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_create_domain_and_network'
op|'('
name|'context'
op|','
name|'xml'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'disk_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|','
nl|'\n'
name|'reboot'
op|'='
name|'True'
op|','
nl|'\n'
name|'vifs_already_plugged'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_prepare_pci_devices_for_use'
op|'('
nl|'\n'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|','
string|"'all'"
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_wait_for_reboot
name|'def'
name|'_wait_for_reboot'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Called at an interval until the VM is running again."""'
newline|'\n'
name|'state'
op|'='
name|'self'
op|'.'
name|'get_info'
op|'('
name|'instance'
op|')'
op|'.'
name|'state'
newline|'\n'
nl|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance rebooted successfully."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
name|'_wait_for_reboot'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|pause
dedent|''
name|'def'
name|'pause'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Pause VM instance."""'
newline|'\n'
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(sahid): We are converting all calls from a'
nl|'\n'
comment|'# virDomain object to use nova.virt.libvirt.Guest.'
nl|'\n'
comment|'# We should be able to remove dom at the end.'
nl|'\n'
name|'dom'
op|'='
name|'guest'
op|'.'
name|'_domain'
newline|'\n'
name|'dom'
op|'.'
name|'suspend'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|unpause
dedent|''
name|'def'
name|'unpause'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Unpause paused VM instance."""'
newline|'\n'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
op|'.'
name|'resume'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_clean_shutdown
dedent|''
name|'def'
name|'_clean_shutdown'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'timeout'
op|','
name|'retry_interval'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Attempt to shutdown the instance gracefully.\n\n        :param instance: The instance to be shutdown\n        :param timeout: How long to wait in seconds for the instance to\n                        shutdown\n        :param retry_interval: How often in seconds to signal the instance\n                               to shutdown while waiting\n\n        :returns: True if the shutdown succeeded\n        """'
newline|'\n'
nl|'\n'
comment|'# List of states that represent a shutdown instance'
nl|'\n'
name|'SHUTDOWN_STATES'
op|'='
op|'['
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|','
nl|'\n'
name|'power_state'
op|'.'
name|'CRASHED'
op|']'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(sahid): We are converting all calls from a'
nl|'\n'
comment|'# virDomain object to use nova.virt.libvirt.Guest.'
nl|'\n'
comment|'# We should be able to remove dom at the end.'
nl|'\n'
name|'dom'
op|'='
name|'guest'
op|'.'
name|'_domain'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
comment|"# If the instance has gone then we don't need to"
nl|'\n'
comment|'# wait for it to shutdown'
nl|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'state'
op|'='
name|'self'
op|'.'
name|'_get_power_state'
op|'('
name|'dom'
op|')'
newline|'\n'
name|'if'
name|'state'
name|'in'
name|'SHUTDOWN_STATES'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance already shutdown."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Shutting down instance from state %s"'
op|','
name|'state'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'dom'
op|'.'
name|'shutdown'
op|'('
op|')'
newline|'\n'
name|'retry_countdown'
op|'='
name|'retry_interval'
newline|'\n'
nl|'\n'
name|'for'
name|'sec'
name|'in'
name|'six'
op|'.'
name|'moves'
op|'.'
name|'range'
op|'('
name|'timeout'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'            '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(sahid): We are converting all calls from a'
nl|'\n'
comment|'# virDomain object to use nova.virt.libvirt.Guest.'
nl|'\n'
comment|'# We should be able to remove dom at the end.'
nl|'\n'
name|'dom'
op|'='
name|'guest'
op|'.'
name|'_domain'
newline|'\n'
nl|'\n'
name|'state'
op|'='
name|'self'
op|'.'
name|'_get_power_state'
op|'('
name|'dom'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'state'
name|'in'
name|'SHUTDOWN_STATES'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance shutdown successfully after %d "'
nl|'\n'
string|'"seconds."'
op|')'
op|','
name|'sec'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
nl|'\n'
comment|"# Note(PhilD): We can't assume that the Guest was able to process"
nl|'\n'
comment|'#              any previous shutdown signal (for example it may'
nl|'\n'
comment|'#              have still been startingup, so within the overall'
nl|'\n'
comment|'#              timeout we re-trigger the shutdown every'
nl|'\n'
comment|'#              retry_interval'
nl|'\n'
dedent|''
name|'if'
name|'retry_countdown'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'retry_countdown'
op|'='
name|'retry_interval'
newline|'\n'
comment|'# Instance could shutdown at any time, in which case we'
nl|'\n'
comment|'# will get an exception when we call shutdown'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Instance in state %s after %d seconds - "'
nl|'\n'
string|'"resending shutdown"'
op|','
name|'state'
op|','
name|'sec'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'dom'
op|'.'
name|'shutdown'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
comment|'# Assume this is because its now shutdown, so loop'
nl|'\n'
comment|'# one more time to clean up.'
nl|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Ignoring libvirt exception from shutdown "'
nl|'\n'
string|'"request."'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'retry_countdown'
op|'-='
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'time'
op|'.'
name|'sleep'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance failed to shutdown in %d seconds."'
op|')'
op|','
nl|'\n'
name|'timeout'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|power_off
dedent|''
name|'def'
name|'power_off'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'timeout'
op|'='
number|'0'
op|','
name|'retry_interval'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Power off the specified instance."""'
newline|'\n'
name|'if'
name|'timeout'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_clean_shutdown'
op|'('
name|'instance'
op|','
name|'timeout'
op|','
name|'retry_interval'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|power_on
dedent|''
name|'def'
name|'power_on'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Power on the specified instance."""'
newline|'\n'
comment|'# We use _hard_reboot here to ensure that all backing files,'
nl|'\n'
comment|'# network, and block device connections, etc. are established'
nl|'\n'
comment|'# and available before we attempt to start the instance.'
nl|'\n'
name|'self'
op|'.'
name|'_hard_reboot'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|suspend
dedent|''
name|'def'
name|'suspend'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Suspend the specified instance."""'
newline|'\n'
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_detach_pci_devices'
op|'('
name|'guest'
op|','
nl|'\n'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_detach_sriov_ports'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'guest'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'save_memory_state'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|resume
dedent|''
name|'def'
name|'resume'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""resume the specified instance."""'
newline|'\n'
name|'image_meta'
op|'='
name|'utils'
op|'.'
name|'get_image_from_system_metadata'
op|'('
nl|'\n'
name|'instance'
op|'.'
name|'system_metadata'
op|')'
newline|'\n'
nl|'\n'
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_existing_domain_xml'
op|'('
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'guest'
op|'='
name|'self'
op|'.'
name|'_create_domain_and_network'
op|'('
name|'context'
op|','
name|'xml'
op|','
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|','
nl|'\n'
name|'vifs_already_plugged'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_attach_pci_devices'
op|'('
name|'guest'
op|','
nl|'\n'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_attach_sriov_ports'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'guest'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|resume_state_on_host_boot
dedent|''
name|'def'
name|'resume_state_on_host_boot'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""resume guest state when a host is booted."""'
newline|'\n'
comment|'# Check if the instance is running already and avoid doing'
nl|'\n'
comment|'# anything if it is.'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(sahid): We are converting all calls from a'
nl|'\n'
comment|'# virDomain object to use nova.virt.libvirt.Guest.'
nl|'\n'
comment|'# We should be able to remove domain at the end.'
nl|'\n'
name|'domain'
op|'='
name|'guest'
op|'.'
name|'_domain'
newline|'\n'
nl|'\n'
name|'state'
op|'='
name|'self'
op|'.'
name|'_get_power_state'
op|'('
name|'domain'
op|')'
newline|'\n'
nl|'\n'
name|'ignored_states'
op|'='
op|'('
name|'power_state'
op|'.'
name|'RUNNING'
op|','
nl|'\n'
name|'power_state'
op|'.'
name|'SUSPENDED'
op|','
nl|'\n'
name|'power_state'
op|'.'
name|'NOSTATE'
op|','
nl|'\n'
name|'power_state'
op|'.'
name|'PAUSED'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'state'
name|'in'
name|'ignored_states'
op|':'
newline|'\n'
indent|'                '
name|'return'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'exception'
op|'.'
name|'NovaException'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
comment|'# Instance is not up and could be in an unknown state.'
nl|'\n'
comment|'# Be as absolute as possible about getting it back into'
nl|'\n'
comment|'# a known and running state.'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_hard_reboot'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|rescue
dedent|''
name|'def'
name|'rescue'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'rescue_password'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Loads a VM using rescue images.\n\n        A rescue is normally performed when something goes wrong with the\n        primary images and data needs to be corrected/recovered. Rescuing\n        should not edit or over-ride the original image, only allow for\n        data recovery.\n\n        """'
newline|'\n'
name|'instance_dir'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'unrescue_xml'
op|'='
name|'self'
op|'.'
name|'_get_existing_domain_xml'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'unrescue_xml_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
string|"'unrescue.xml'"
op|')'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'write_to_file'
op|'('
name|'unrescue_xml_path'
op|','
name|'unrescue_xml'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'image_meta'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'rescue_image_id'
op|'='
name|'image_meta'
op|'.'
name|'get'
op|'('
string|"'id'"
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'rescue_image_id'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'rescue_images'
op|'='
op|'{'
nl|'\n'
string|"'image_id'"
op|':'
op|'('
name|'rescue_image_id'
name|'or'
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'rescue_image_id'
name|'or'
name|'instance'
op|'.'
name|'image_ref'
op|')'
op|','
nl|'\n'
string|"'kernel_id'"
op|':'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'rescue_kernel_id'
name|'or'
nl|'\n'
name|'instance'
op|'.'
name|'kernel_id'
op|')'
op|','
nl|'\n'
string|"'ramdisk_id'"
op|':'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'rescue_ramdisk_id'
name|'or'
nl|'\n'
name|'instance'
op|'.'
name|'ramdisk_id'
op|')'
op|','
nl|'\n'
op|'}'
newline|'\n'
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'rescue'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_image'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'disk_info'
op|'['
string|"'mapping'"
op|']'
op|','
nl|'\n'
name|'suffix'
op|'='
string|"'.rescue'"
op|','
name|'disk_images'
op|'='
name|'rescue_images'
op|','
nl|'\n'
name|'network_info'
op|'='
name|'network_info'
op|','
nl|'\n'
name|'admin_pass'
op|'='
name|'rescue_password'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_guest_xml'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'image_meta'
op|','
name|'rescue'
op|'='
name|'rescue_images'
op|','
nl|'\n'
name|'write_to_disk'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_domain'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
DECL|member|unrescue
dedent|''
name|'def'
name|'unrescue'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Reboot the VM which is being rescued back into primary images.\n        """'
newline|'\n'
name|'instance_dir'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'unrescue_xml_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
string|"'unrescue.xml'"
op|')'
newline|'\n'
name|'xml'
op|'='
name|'libvirt_utils'
op|'.'
name|'load_file'
op|'('
name|'unrescue_xml_path'
op|')'
newline|'\n'
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(sahid): We are converting all calls from a'
nl|'\n'
comment|'# virDomain object to use nova.virt.libvirt.Guest.'
nl|'\n'
comment|'# We should be able to remove virt_dom at the end.'
nl|'\n'
name|'virt_dom'
op|'='
name|'guest'
op|'.'
name|'_domain'
newline|'\n'
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_domain'
op|'('
name|'xml'
op|','
name|'virt_dom'
op|')'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'file_delete'
op|'('
name|'unrescue_xml_path'
op|')'
newline|'\n'
name|'rescue_files'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
string|'"*.rescue"'
op|')'
newline|'\n'
name|'for'
name|'rescue_file'
name|'in'
name|'glob'
op|'.'
name|'iglob'
op|'('
name|'rescue_files'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'libvirt_utils'
op|'.'
name|'file_delete'
op|'('
name|'rescue_file'
op|')'
newline|'\n'
comment|'# cleanup rescue volume'
nl|'\n'
dedent|''
name|'lvm'
op|'.'
name|'remove_volumes'
op|'('
op|'['
name|'lvmdisk'
name|'for'
name|'lvmdisk'
name|'in'
name|'self'
op|'.'
name|'_lvm_disks'
op|'('
name|'instance'
op|')'
nl|'\n'
name|'if'
name|'lvmdisk'
op|'.'
name|'endswith'
op|'('
string|"'.rescue'"
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|poll_rebooting_instances
dedent|''
name|'def'
name|'poll_rebooting_instances'
op|'('
name|'self'
op|','
name|'timeout'
op|','
name|'instances'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
comment|'# NOTE(ilyaalekseyev): Implementation like in multinics'
nl|'\n'
comment|'# for xenapi(tr3buchet)'
nl|'\n'
DECL|member|spawn
dedent|''
name|'def'
name|'spawn'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'injected_files'
op|','
nl|'\n'
name|'admin_password'
op|','
name|'network_info'
op|'='
name|'None'
op|','
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_image'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'disk_info'
op|'['
string|"'mapping'"
op|']'
op|','
nl|'\n'
name|'network_info'
op|'='
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|','
nl|'\n'
name|'files'
op|'='
name|'injected_files'
op|','
nl|'\n'
name|'admin_pass'
op|'='
name|'admin_password'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_guest_xml'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'disk_info'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|','
nl|'\n'
name|'write_to_disk'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_domain_and_network'
op|'('
name|'context'
op|','
name|'xml'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'disk_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Instance is running"'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_wait_for_boot
name|'def'
name|'_wait_for_boot'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Called at an interval until the VM is running."""'
newline|'\n'
name|'state'
op|'='
name|'self'
op|'.'
name|'get_info'
op|'('
name|'instance'
op|')'
op|'.'
name|'state'
newline|'\n'
nl|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance spawned successfully."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
name|'_wait_for_boot'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_flush_libvirt_console
dedent|''
name|'def'
name|'_flush_libvirt_console'
op|'('
name|'self'
op|','
name|'pty'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'out'
op|','
name|'err'
op|'='
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'dd'"
op|','
nl|'\n'
string|"'if=%s'"
op|'%'
name|'pty'
op|','
nl|'\n'
string|"'iflag=nonblock'"
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|','
nl|'\n'
name|'check_exit_code'
op|'='
name|'False'
op|')'
newline|'\n'
name|'return'
name|'out'
newline|'\n'
nl|'\n'
DECL|member|_append_to_file
dedent|''
name|'def'
name|'_append_to_file'
op|'('
name|'self'
op|','
name|'data'
op|','
name|'fpath'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'data: %(data)r, fpath: %(fpath)r'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'data'"
op|':'
name|'data'
op|','
string|"'fpath'"
op|':'
name|'fpath'
op|'}'
op|')'
newline|'\n'
name|'with'
name|'open'
op|'('
name|'fpath'
op|','
string|"'a+'"
op|')'
name|'as'
name|'fp'
op|':'
newline|'\n'
indent|'            '
name|'fp'
op|'.'
name|'write'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'fpath'
newline|'\n'
nl|'\n'
DECL|member|get_console_output
dedent|''
name|'def'
name|'get_console_output'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'xml'
op|'='
name|'guest'
op|'.'
name|'get_xml_desc'
op|'('
op|')'
newline|'\n'
name|'tree'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
name|'console_types'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
comment|"# NOTE(comstud): We want to try 'file' types first, then try 'pty'"
nl|'\n'
comment|"# types.  We can't use Python 2.7 syntax of:"
nl|'\n'
comment|'# tree.find("./devices/console[@type=\'file\']/source")'
nl|'\n'
comment|'# because we need to support 2.6.'
nl|'\n'
name|'console_nodes'
op|'='
name|'tree'
op|'.'
name|'findall'
op|'('
string|"'./devices/console'"
op|')'
newline|'\n'
name|'for'
name|'console_node'
name|'in'
name|'console_nodes'
op|':'
newline|'\n'
indent|'            '
name|'console_type'
op|'='
name|'console_node'
op|'.'
name|'get'
op|'('
string|"'type'"
op|')'
newline|'\n'
name|'console_types'
op|'.'
name|'setdefault'
op|'('
name|'console_type'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'console_types'
op|'['
name|'console_type'
op|']'
op|'.'
name|'append'
op|'('
name|'console_node'
op|')'
newline|'\n'
nl|'\n'
comment|'# If the guest has a console logging to a file prefer to use that'
nl|'\n'
dedent|''
name|'if'
name|'console_types'
op|'.'
name|'get'
op|'('
string|"'file'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'file_console'
name|'in'
name|'console_types'
op|'.'
name|'get'
op|'('
string|"'file'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'source_node'
op|'='
name|'file_console'
op|'.'
name|'find'
op|'('
string|"'./source'"
op|')'
newline|'\n'
name|'if'
name|'source_node'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'path'
op|'='
name|'source_node'
op|'.'
name|'get'
op|'('
string|'"path"'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'path'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'path'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Instance is configured with a file console, '"
nl|'\n'
string|"'but the backing file is not (yet?) present'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
string|'""'
newline|'\n'
nl|'\n'
dedent|''
name|'libvirt_utils'
op|'.'
name|'chown'
op|'('
name|'path'
op|','
name|'os'
op|'.'
name|'getuid'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'with'
name|'libvirt_utils'
op|'.'
name|'file_open'
op|'('
name|'path'
op|','
string|"'rb'"
op|')'
name|'as'
name|'fp'
op|':'
newline|'\n'
indent|'                    '
name|'log_data'
op|','
name|'remaining'
op|'='
name|'utils'
op|'.'
name|'last_bytes'
op|'('
name|'fp'
op|','
nl|'\n'
name|'MAX_CONSOLE_BYTES'
op|')'
newline|'\n'
name|'if'
name|'remaining'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                        '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Truncated console log returned, '"
nl|'\n'
string|"'%d bytes ignored'"
op|')'
op|','
name|'remaining'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'log_data'
newline|'\n'
nl|'\n'
comment|"# Try 'pty' types"
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'console_types'
op|'.'
name|'get'
op|'('
string|"'pty'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'pty_console'
name|'in'
name|'console_types'
op|'.'
name|'get'
op|'('
string|"'pty'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'source_node'
op|'='
name|'pty_console'
op|'.'
name|'find'
op|'('
string|"'./source'"
op|')'
newline|'\n'
name|'if'
name|'source_node'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'pty'
op|'='
name|'source_node'
op|'.'
name|'get'
op|'('
string|'"path"'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'pty'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|'"Guest does not have a console available"'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_chown_console_log_for_instance'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'data'
op|'='
name|'self'
op|'.'
name|'_flush_libvirt_console'
op|'('
name|'pty'
op|')'
newline|'\n'
name|'console_log'
op|'='
name|'self'
op|'.'
name|'_get_console_log_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'fpath'
op|'='
name|'self'
op|'.'
name|'_append_to_file'
op|'('
name|'data'
op|','
name|'console_log'
op|')'
newline|'\n'
nl|'\n'
name|'with'
name|'libvirt_utils'
op|'.'
name|'file_open'
op|'('
name|'fpath'
op|','
string|"'rb'"
op|')'
name|'as'
name|'fp'
op|':'
newline|'\n'
indent|'            '
name|'log_data'
op|','
name|'remaining'
op|'='
name|'utils'
op|'.'
name|'last_bytes'
op|'('
name|'fp'
op|','
name|'MAX_CONSOLE_BYTES'
op|')'
newline|'\n'
name|'if'
name|'remaining'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Truncated console log returned, '"
nl|'\n'
string|"'%d bytes ignored'"
op|')'
op|','
nl|'\n'
name|'remaining'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'log_data'
newline|'\n'
nl|'\n'
DECL|member|get_host_ip_addr
dedent|''
dedent|''
name|'def'
name|'get_host_ip_addr'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'ips'
op|'='
name|'compute_utils'
op|'.'
name|'get_machine_ips'
op|'('
op|')'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'my_ip'
name|'not'
name|'in'
name|'ips'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'my_ip address (%(my_ip)s) was not found on '"
nl|'\n'
string|"'any of the interfaces: %(ifaces)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'my_ip'"
op|':'
name|'CONF'
op|'.'
name|'my_ip'
op|','
string|"'ifaces'"
op|':'
string|'", "'
op|'.'
name|'join'
op|'('
name|'ips'
op|')'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'CONF'
op|'.'
name|'my_ip'
newline|'\n'
nl|'\n'
DECL|member|get_vnc_console
dedent|''
name|'def'
name|'get_vnc_console'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
DECL|function|get_vnc_port_for_instance
indent|'        '
name|'def'
name|'get_vnc_port_for_instance'
op|'('
name|'instance_name'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'xml'
op|'='
name|'guest'
op|'.'
name|'get_xml_desc'
op|'('
op|')'
newline|'\n'
name|'xml_dom'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
name|'graphic'
op|'='
name|'xml_dom'
op|'.'
name|'find'
op|'('
string|'"./devices/graphics[@type=\'vnc\']"'
op|')'
newline|'\n'
name|'if'
name|'graphic'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'graphic'
op|'.'
name|'get'
op|'('
string|"'port'"
op|')'
newline|'\n'
comment|'# NOTE(rmk): We had VNC consoles enabled but the instance in'
nl|'\n'
comment|'# question is not actually listening for connections.'
nl|'\n'
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'ConsoleTypeUnavailable'
op|'('
name|'console_type'
op|'='
string|"'vnc'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'port'
op|'='
name|'get_vnc_port_for_instance'
op|'('
name|'instance'
op|'.'
name|'name'
op|')'
newline|'\n'
name|'host'
op|'='
name|'CONF'
op|'.'
name|'vnc'
op|'.'
name|'vncserver_proxyclient_address'
newline|'\n'
nl|'\n'
name|'return'
name|'ctype'
op|'.'
name|'ConsoleVNC'
op|'('
name|'host'
op|'='
name|'host'
op|','
name|'port'
op|'='
name|'port'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_spice_console
dedent|''
name|'def'
name|'get_spice_console'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
DECL|function|get_spice_ports_for_instance
indent|'        '
name|'def'
name|'get_spice_ports_for_instance'
op|'('
name|'instance_name'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'xml'
op|'='
name|'guest'
op|'.'
name|'get_xml_desc'
op|'('
op|')'
newline|'\n'
name|'xml_dom'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
name|'graphic'
op|'='
name|'xml_dom'
op|'.'
name|'find'
op|'('
string|'"./devices/graphics[@type=\'spice\']"'
op|')'
newline|'\n'
name|'if'
name|'graphic'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'return'
op|'('
name|'graphic'
op|'.'
name|'get'
op|'('
string|"'port'"
op|')'
op|','
name|'graphic'
op|'.'
name|'get'
op|'('
string|"'tlsPort'"
op|')'
op|')'
newline|'\n'
comment|'# NOTE(rmk): We had Spice consoles enabled but the instance in'
nl|'\n'
comment|'# question is not actually listening for connections.'
nl|'\n'
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'ConsoleTypeUnavailable'
op|'('
name|'console_type'
op|'='
string|"'spice'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'ports'
op|'='
name|'get_spice_ports_for_instance'
op|'('
name|'instance'
op|'.'
name|'name'
op|')'
newline|'\n'
name|'host'
op|'='
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'server_proxyclient_address'
newline|'\n'
nl|'\n'
name|'return'
name|'ctype'
op|'.'
name|'ConsoleSpice'
op|'('
name|'host'
op|'='
name|'host'
op|','
name|'port'
op|'='
name|'ports'
op|'['
number|'0'
op|']'
op|','
name|'tlsPort'
op|'='
name|'ports'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_serial_console
dedent|''
name|'def'
name|'get_serial_console'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'hostname'
op|','
name|'port'
name|'in'
name|'self'
op|'.'
name|'_get_serial_ports_from_instance'
op|'('
nl|'\n'
name|'instance'
op|','
name|'mode'
op|'='
string|"'bind'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'ctype'
op|'.'
name|'ConsoleSerial'
op|'('
name|'host'
op|'='
name|'hostname'
op|','
name|'port'
op|'='
name|'port'
op|')'
newline|'\n'
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'ConsoleTypeUnavailable'
op|'('
name|'console_type'
op|'='
string|"'serial'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_supports_direct_io
name|'def'
name|'_supports_direct_io'
op|'('
name|'dirpath'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'        '
name|'if'
name|'not'
name|'hasattr'
op|'('
name|'os'
op|','
string|"'O_DIRECT'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"This python runtime does not support direct I/O"'
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
name|'testfile'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'dirpath'
op|','
string|'".directio.test"'
op|')'
newline|'\n'
nl|'\n'
name|'hasDirectIO'
op|'='
name|'True'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'='
name|'os'
op|'.'
name|'open'
op|'('
name|'testfile'
op|','
name|'os'
op|'.'
name|'O_CREAT'
op|'|'
name|'os'
op|'.'
name|'O_WRONLY'
op|'|'
name|'os'
op|'.'
name|'O_DIRECT'
op|')'
newline|'\n'
comment|'# Check is the write allowed with 512 byte alignment'
nl|'\n'
name|'align_size'
op|'='
number|'512'
newline|'\n'
name|'m'
op|'='
name|'mmap'
op|'.'
name|'mmap'
op|'('
op|'-'
number|'1'
op|','
name|'align_size'
op|')'
newline|'\n'
name|'m'
op|'.'
name|'write'
op|'('
string|'r"x"'
op|'*'
name|'align_size'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'write'
op|'('
name|'f'
op|','
name|'m'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'f'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Path \'%(path)s\' supports direct I/O"'
op|','
nl|'\n'
op|'{'
string|"'path'"
op|':'
name|'dirpath'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'EINVAL'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Path \'%(path)s\' does not support direct I/O: "'
nl|'\n'
string|'"\'%(ex)s\'"'
op|','
op|'{'
string|"'path'"
op|':'
name|'dirpath'
op|','
string|"'ex'"
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
name|'hasDirectIO'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|'"Error on \'%(path)s\' while checking "'
nl|'\n'
string|'"direct I/O: \'%(ex)s\'"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'path'"
op|':'
name|'dirpath'
op|','
string|"'ex'"
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|'"Error on \'%(path)s\' while checking direct I/O: "'
nl|'\n'
string|'"\'%(ex)s\'"'
op|')'
op|','
op|'{'
string|"'path'"
op|':'
name|'dirpath'
op|','
string|"'ex'"
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'unlink'
op|'('
name|'testfile'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'hasDirectIO'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_create_local
name|'def'
name|'_create_local'
op|'('
name|'target'
op|','
name|'local_size'
op|','
name|'unit'
op|'='
string|"'G'"
op|','
nl|'\n'
name|'fs_format'
op|'='
name|'None'
op|','
name|'label'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a blank image of specified size."""'
newline|'\n'
nl|'\n'
name|'libvirt_utils'
op|'.'
name|'create_image'
op|'('
string|"'raw'"
op|','
name|'target'
op|','
nl|'\n'
string|"'%d%c'"
op|'%'
op|'('
name|'local_size'
op|','
name|'unit'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_create_ephemeral
dedent|''
name|'def'
name|'_create_ephemeral'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'ephemeral_size'
op|','
nl|'\n'
name|'fs_label'
op|','
name|'os_type'
op|','
name|'is_block_dev'
op|'='
name|'False'
op|','
nl|'\n'
name|'max_size'
op|'='
name|'None'
op|','
name|'context'
op|'='
name|'None'
op|','
name|'specified_fs'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'is_block_dev'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_create_local'
op|'('
name|'target'
op|','
name|'ephemeral_size'
op|')'
newline|'\n'
nl|'\n'
comment|'# Run as root only for block devices.'
nl|'\n'
dedent|''
name|'disk'
op|'.'
name|'mkfs'
op|'('
name|'os_type'
op|','
name|'fs_label'
op|','
name|'target'
op|','
name|'run_as_root'
op|'='
name|'is_block_dev'
op|','
nl|'\n'
name|'specified_fs'
op|'='
name|'specified_fs'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_create_swap
name|'def'
name|'_create_swap'
op|'('
name|'target'
op|','
name|'swap_mb'
op|','
name|'max_size'
op|'='
name|'None'
op|','
name|'context'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a swap file of specified size."""'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'create_image'
op|'('
string|"'raw'"
op|','
name|'target'
op|','
string|"'%dM'"
op|'%'
name|'swap_mb'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'mkfs'
op|'('
string|"'swap'"
op|','
name|'target'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_get_console_log_path
name|'def'
name|'_get_console_log_path'
op|'('
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
op|','
nl|'\n'
string|"'console.log'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_get_disk_config_path
name|'def'
name|'_get_disk_config_path'
op|'('
name|'instance'
op|','
name|'suffix'
op|'='
string|"''"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
op|','
nl|'\n'
string|"'disk.config'"
op|'+'
name|'suffix'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_chown_console_log_for_instance
dedent|''
name|'def'
name|'_chown_console_log_for_instance'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'console_log'
op|'='
name|'self'
op|'.'
name|'_get_console_log_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'console_log'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'libvirt_utils'
op|'.'
name|'chown'
op|'('
name|'console_log'
op|','
name|'os'
op|'.'
name|'getuid'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_chown_disk_config_for_instance
dedent|''
dedent|''
name|'def'
name|'_chown_disk_config_for_instance'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'disk_config'
op|'='
name|'self'
op|'.'
name|'_get_disk_config_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'disk_config'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'libvirt_utils'
op|'.'
name|'chown'
op|'('
name|'disk_config'
op|','
name|'os'
op|'.'
name|'getuid'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_is_booted_from_volume
name|'def'
name|'_is_booted_from_volume'
op|'('
name|'instance'
op|','
name|'disk_mapping'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Determines whether the VM is booting from volume\n\n        Determines whether the disk mapping indicates that the VM\n        is booting from a volume.\n        """'
newline|'\n'
name|'return'
op|'('
op|'('
name|'not'
name|'bool'
op|'('
name|'instance'
op|'.'
name|'get'
op|'('
string|"'image_ref'"
op|')'
op|')'
op|')'
nl|'\n'
name|'or'
string|"'disk'"
name|'not'
name|'in'
name|'disk_mapping'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_inject_data
dedent|''
name|'def'
name|'_inject_data'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'admin_pass'
op|','
name|'files'
op|','
name|'suffix'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Injects data in a disk image\n\n        Helper used for injecting data in a disk image file system.\n\n        Keyword arguments:\n          instance -- a dict that refers instance specifications\n          network_info -- a dict that refers network speficications\n          admin_pass -- a string used to set an admin password\n          files -- a list of files needs to be injected\n          suffix -- a string used as an image name suffix\n        """'
newline|'\n'
comment|'# Handles the partition need to be used.'
nl|'\n'
name|'target_partition'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'not'
name|'instance'
op|'.'
name|'kernel_id'
op|':'
newline|'\n'
indent|'            '
name|'target_partition'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'inject_partition'
newline|'\n'
name|'if'
name|'target_partition'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'target_partition'
op|'='
name|'None'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'lxc'"
op|':'
newline|'\n'
indent|'            '
name|'target_partition'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# Handles the key injection.'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'inject_key'
name|'and'
name|'instance'
op|'.'
name|'get'
op|'('
string|"'key_data'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'key'
op|'='
name|'str'
op|'('
name|'instance'
op|'.'
name|'key_data'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'key'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# Handles the admin password injection.'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'inject_password'
op|':'
newline|'\n'
indent|'            '
name|'admin_pass'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# Handles the network injection.'
nl|'\n'
dedent|''
name|'net'
op|'='
name|'netutils'
op|'.'
name|'get_injected_network_template'
op|'('
nl|'\n'
name|'network_info'
op|','
name|'libvirt_virt_type'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|')'
newline|'\n'
nl|'\n'
comment|'# Handles the metadata injection'
nl|'\n'
name|'metadata'
op|'='
name|'instance'
op|'.'
name|'get'
op|'('
string|"'metadata'"
op|')'
newline|'\n'
nl|'\n'
name|'image_type'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_type'
newline|'\n'
name|'if'
name|'any'
op|'('
op|'('
name|'key'
op|','
name|'net'
op|','
name|'metadata'
op|','
name|'admin_pass'
op|','
name|'files'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'injection_image'
op|'='
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'image'
op|'('
nl|'\n'
name|'instance'
op|','
nl|'\n'
string|"'disk'"
op|'+'
name|'suffix'
op|','
nl|'\n'
name|'image_type'
op|')'
newline|'\n'
name|'img_id'
op|'='
name|'instance'
op|'.'
name|'image_ref'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'injection_image'
op|'.'
name|'check_image_exists'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'Image %s not found on disk storage. '"
nl|'\n'
string|"'Continue without injecting data'"
op|')'
op|','
nl|'\n'
name|'injection_image'
op|'.'
name|'path'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'disk'
op|'.'
name|'inject_data'
op|'('
name|'injection_image'
op|'.'
name|'get_model'
op|'('
name|'self'
op|'.'
name|'_conn'
op|')'
op|','
nl|'\n'
name|'key'
op|','
name|'net'
op|','
name|'metadata'
op|','
name|'admin_pass'
op|','
name|'files'
op|','
nl|'\n'
name|'partition'
op|'='
name|'target_partition'
op|','
nl|'\n'
name|'mandatory'
op|'='
op|'('
string|"'files'"
op|','
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'Error injecting data into image '"
nl|'\n'
string|"'%(img_id)s (%(e)s)'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'img_id'"
op|':'
name|'img_id'
op|','
string|"'e'"
op|':'
name|'e'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_create_image
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_create_image'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'disk_mapping'
op|','
name|'suffix'
op|'='
string|"''"
op|','
nl|'\n'
name|'disk_images'
op|'='
name|'None'
op|','
name|'network_info'
op|'='
name|'None'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'files'
op|'='
name|'None'
op|','
nl|'\n'
name|'admin_pass'
op|'='
name|'None'
op|','
name|'inject_files'
op|'='
name|'True'
op|','
nl|'\n'
name|'fallback_from_host'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'booted_from_volume'
op|'='
name|'self'
op|'.'
name|'_is_booted_from_volume'
op|'('
nl|'\n'
name|'instance'
op|','
name|'disk_mapping'
op|')'
newline|'\n'
nl|'\n'
DECL|function|image
name|'def'
name|'image'
op|'('
name|'fname'
op|','
name|'image_type'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_type'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'image'
op|'('
name|'instance'
op|','
nl|'\n'
name|'fname'
op|'+'
name|'suffix'
op|','
name|'image_type'
op|')'
newline|'\n'
nl|'\n'
DECL|function|raw
dedent|''
name|'def'
name|'raw'
op|'('
name|'fname'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'image'
op|'('
name|'fname'
op|','
name|'image_type'
op|'='
string|"'raw'"
op|')'
newline|'\n'
nl|'\n'
comment|'# ensure directories exist and are writable'
nl|'\n'
dedent|''
name|'fileutils'
op|'.'
name|'ensure_tree'
op|'('
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Creating image'"
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(dprince): for rescue console.log may already exist... chown it.'
nl|'\n'
name|'self'
op|'.'
name|'_chown_console_log_for_instance'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(yaguang): For evacuate disk.config already exist in shared'
nl|'\n'
comment|'# storage, chown it.'
nl|'\n'
name|'self'
op|'.'
name|'_chown_disk_config_for_instance'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(vish): No need add the suffix to console.log'
nl|'\n'
name|'libvirt_utils'
op|'.'
name|'write_to_file'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_get_console_log_path'
op|'('
name|'instance'
op|')'
op|','
string|"''"
op|','
number|'7'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'disk_images'
op|':'
newline|'\n'
indent|'            '
name|'disk_images'
op|'='
op|'{'
string|"'image_id'"
op|':'
name|'instance'
op|'.'
name|'image_ref'
op|','
nl|'\n'
string|"'kernel_id'"
op|':'
name|'instance'
op|'.'
name|'kernel_id'
op|','
nl|'\n'
string|"'ramdisk_id'"
op|':'
name|'instance'
op|'.'
name|'ramdisk_id'
op|'}'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'disk_images'
op|'['
string|"'kernel_id'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'fname'
op|'='
name|'imagecache'
op|'.'
name|'get_cache_fname'
op|'('
name|'disk_images'
op|','
string|"'kernel_id'"
op|')'
newline|'\n'
name|'raw'
op|'('
string|"'kernel'"
op|')'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'libvirt_utils'
op|'.'
name|'fetch_image'
op|','
nl|'\n'
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'filename'
op|'='
name|'fname'
op|','
nl|'\n'
name|'image_id'
op|'='
name|'disk_images'
op|'['
string|"'kernel_id'"
op|']'
op|','
nl|'\n'
name|'user_id'
op|'='
name|'instance'
op|'.'
name|'user_id'
op|','
nl|'\n'
name|'project_id'
op|'='
name|'instance'
op|'.'
name|'project_id'
op|')'
newline|'\n'
name|'if'
name|'disk_images'
op|'['
string|"'ramdisk_id'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'fname'
op|'='
name|'imagecache'
op|'.'
name|'get_cache_fname'
op|'('
name|'disk_images'
op|','
string|"'ramdisk_id'"
op|')'
newline|'\n'
name|'raw'
op|'('
string|"'ramdisk'"
op|')'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'libvirt_utils'
op|'.'
name|'fetch_image'
op|','
nl|'\n'
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'filename'
op|'='
name|'fname'
op|','
nl|'\n'
name|'image_id'
op|'='
name|'disk_images'
op|'['
string|"'ramdisk_id'"
op|']'
op|','
nl|'\n'
name|'user_id'
op|'='
name|'instance'
op|'.'
name|'user_id'
op|','
nl|'\n'
name|'project_id'
op|'='
name|'instance'
op|'.'
name|'project_id'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'inst_type'
op|'='
name|'instance'
op|'.'
name|'get_flavor'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(ndipanov): Even if disk_mapping was passed in, which'
nl|'\n'
comment|"# currently happens only on rescue - we still don't want to"
nl|'\n'
comment|'# create a base image.'
nl|'\n'
name|'if'
name|'not'
name|'booted_from_volume'
op|':'
newline|'\n'
indent|'            '
name|'root_fname'
op|'='
name|'imagecache'
op|'.'
name|'get_cache_fname'
op|'('
name|'disk_images'
op|','
string|"'image_id'"
op|')'
newline|'\n'
name|'size'
op|'='
name|'instance'
op|'.'
name|'root_gb'
op|'*'
name|'units'
op|'.'
name|'Gi'
newline|'\n'
nl|'\n'
name|'if'
name|'size'
op|'=='
number|'0'
name|'or'
name|'suffix'
op|'=='
string|"'.rescue'"
op|':'
newline|'\n'
indent|'                '
name|'size'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'backend'
op|'='
name|'image'
op|'('
string|"'disk'"
op|')'
newline|'\n'
name|'if'
name|'backend'
op|'.'
name|'SUPPORTS_CLONE'
op|':'
newline|'\n'
DECL|function|clone_fallback_to_fetch
indent|'                '
name|'def'
name|'clone_fallback_to_fetch'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'try'
op|':'
newline|'\n'
indent|'                        '
name|'backend'
op|'.'
name|'clone'
op|'('
name|'context'
op|','
name|'disk_images'
op|'['
string|"'image_id'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'ImageUnacceptable'
op|':'
newline|'\n'
indent|'                        '
name|'libvirt_utils'
op|'.'
name|'fetch_image'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'fetch_func'
op|'='
name|'clone_fallback_to_fetch'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'fetch_func'
op|'='
name|'libvirt_utils'
op|'.'
name|'fetch_image'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_try_fetch_image_cache'
op|'('
name|'backend'
op|','
name|'fetch_func'
op|','
name|'context'
op|','
nl|'\n'
name|'root_fname'
op|','
name|'disk_images'
op|'['
string|"'image_id'"
op|']'
op|','
nl|'\n'
name|'instance'
op|','
name|'size'
op|','
name|'fallback_from_host'
op|')'
newline|'\n'
nl|'\n'
comment|'# Lookup the filesystem type if required'
nl|'\n'
dedent|''
name|'os_type_with_default'
op|'='
name|'disk'
op|'.'
name|'get_fs_type_for_os_type'
op|'('
name|'instance'
op|'.'
name|'os_type'
op|')'
newline|'\n'
comment|'# Generate a file extension based on the file system'
nl|'\n'
comment|'# type and the mkfs commands configured if any'
nl|'\n'
name|'file_extension'
op|'='
name|'disk'
op|'.'
name|'get_file_extension_for_os_type'
op|'('
nl|'\n'
name|'os_type_with_default'
op|')'
newline|'\n'
nl|'\n'
name|'ephemeral_gb'
op|'='
name|'instance'
op|'.'
name|'ephemeral_gb'
newline|'\n'
name|'if'
string|"'disk.local'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'            '
name|'disk_image'
op|'='
name|'image'
op|'('
string|"'disk.local'"
op|')'
newline|'\n'
name|'fn'
op|'='
name|'functools'
op|'.'
name|'partial'
op|'('
name|'self'
op|'.'
name|'_create_ephemeral'
op|','
nl|'\n'
name|'fs_label'
op|'='
string|"'ephemeral0'"
op|','
nl|'\n'
name|'os_type'
op|'='
name|'instance'
op|'.'
name|'os_type'
op|','
nl|'\n'
name|'is_block_dev'
op|'='
name|'disk_image'
op|'.'
name|'is_block_dev'
op|')'
newline|'\n'
name|'fname'
op|'='
string|'"ephemeral_%s_%s"'
op|'%'
op|'('
name|'ephemeral_gb'
op|','
name|'file_extension'
op|')'
newline|'\n'
name|'size'
op|'='
name|'ephemeral_gb'
op|'*'
name|'units'
op|'.'
name|'Gi'
newline|'\n'
name|'disk_image'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'fn'
op|','
nl|'\n'
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'filename'
op|'='
name|'fname'
op|','
nl|'\n'
name|'size'
op|'='
name|'size'
op|','
nl|'\n'
name|'ephemeral_size'
op|'='
name|'ephemeral_gb'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'idx'
op|','
name|'eph'
name|'in'
name|'enumerate'
op|'('
name|'driver'
op|'.'
name|'block_device_info_get_ephemerals'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'disk_image'
op|'='
name|'image'
op|'('
name|'blockinfo'
op|'.'
name|'get_eph_disk'
op|'('
name|'idx'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'specified_fs'
op|'='
name|'eph'
op|'.'
name|'get'
op|'('
string|"'guest_format'"
op|')'
newline|'\n'
name|'if'
name|'specified_fs'
name|'and'
name|'not'
name|'self'
op|'.'
name|'is_supported_fs_format'
op|'('
name|'specified_fs'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
name|'_'
op|'('
string|'"%s format is not supported"'
op|')'
op|'%'
name|'specified_fs'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InvalidBDMFormat'
op|'('
name|'details'
op|'='
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'fn'
op|'='
name|'functools'
op|'.'
name|'partial'
op|'('
name|'self'
op|'.'
name|'_create_ephemeral'
op|','
nl|'\n'
name|'fs_label'
op|'='
string|"'ephemeral%d'"
op|'%'
name|'idx'
op|','
nl|'\n'
name|'os_type'
op|'='
name|'instance'
op|'.'
name|'os_type'
op|','
nl|'\n'
name|'is_block_dev'
op|'='
name|'disk_image'
op|'.'
name|'is_block_dev'
op|')'
newline|'\n'
name|'size'
op|'='
name|'eph'
op|'['
string|"'size'"
op|']'
op|'*'
name|'units'
op|'.'
name|'Gi'
newline|'\n'
name|'fname'
op|'='
string|'"ephemeral_%s_%s"'
op|'%'
op|'('
name|'eph'
op|'['
string|"'size'"
op|']'
op|','
name|'file_extension'
op|')'
newline|'\n'
name|'disk_image'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'fn'
op|','
nl|'\n'
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'filename'
op|'='
name|'fname'
op|','
nl|'\n'
name|'size'
op|'='
name|'size'
op|','
nl|'\n'
name|'ephemeral_size'
op|'='
name|'eph'
op|'['
string|"'size'"
op|']'
op|','
nl|'\n'
name|'specified_fs'
op|'='
name|'specified_fs'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
string|"'disk.swap'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'            '
name|'mapping'
op|'='
name|'disk_mapping'
op|'['
string|"'disk.swap'"
op|']'
newline|'\n'
name|'swap_mb'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'swap'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_swap'
op|'('
name|'block_device_info'
op|')'
newline|'\n'
name|'if'
name|'driver'
op|'.'
name|'swap_is_usable'
op|'('
name|'swap'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'swap_mb'
op|'='
name|'swap'
op|'['
string|"'swap_size'"
op|']'
newline|'\n'
dedent|''
name|'elif'
op|'('
name|'inst_type'
op|'['
string|"'swap'"
op|']'
op|'>'
number|'0'
name|'and'
nl|'\n'
name|'not'
name|'block_device'
op|'.'
name|'volume_in_mapping'
op|'('
nl|'\n'
name|'mapping'
op|'['
string|"'dev'"
op|']'
op|','
name|'block_device_info'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'swap_mb'
op|'='
name|'inst_type'
op|'['
string|"'swap'"
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'swap_mb'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'size'
op|'='
name|'swap_mb'
op|'*'
name|'units'
op|'.'
name|'Mi'
newline|'\n'
name|'image'
op|'('
string|"'disk.swap'"
op|')'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'self'
op|'.'
name|'_create_swap'
op|','
nl|'\n'
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'filename'
op|'='
string|'"swap_%s"'
op|'%'
name|'swap_mb'
op|','
nl|'\n'
name|'size'
op|'='
name|'size'
op|','
nl|'\n'
name|'swap_mb'
op|'='
name|'swap_mb'
op|')'
newline|'\n'
nl|'\n'
comment|'# Config drive'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'configdrive'
op|'.'
name|'required_by'
op|'('
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Using config drive'"
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'extra_md'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'if'
name|'admin_pass'
op|':'
newline|'\n'
indent|'                '
name|'extra_md'
op|'['
string|"'admin_pass'"
op|']'
op|'='
name|'admin_pass'
newline|'\n'
nl|'\n'
dedent|''
name|'inst_md'
op|'='
name|'instance_metadata'
op|'.'
name|'InstanceMetadata'
op|'('
name|'instance'
op|','
nl|'\n'
name|'content'
op|'='
name|'files'
op|','
name|'extra_md'
op|'='
name|'extra_md'
op|','
name|'network_info'
op|'='
name|'network_info'
op|')'
newline|'\n'
name|'with'
name|'configdrive'
op|'.'
name|'ConfigDriveBuilder'
op|'('
name|'instance_md'
op|'='
name|'inst_md'
op|')'
name|'as'
name|'cdb'
op|':'
newline|'\n'
indent|'                '
name|'configdrive_path'
op|'='
name|'self'
op|'.'
name|'_get_disk_config_path'
op|'('
name|'instance'
op|','
name|'suffix'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Creating config drive at %(path)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'path'"
op|':'
name|'configdrive_path'
op|'}'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'cdb'
op|'.'
name|'make_drive'
op|'('
name|'configdrive_path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'processutils'
op|'.'
name|'ProcessExecutionError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                    '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'Creating config drive failed '"
nl|'\n'
string|"'with error: %s'"
op|')'
op|','
nl|'\n'
name|'e'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# File injection only if needed'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'elif'
name|'inject_files'
name|'and'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'inject_partition'
op|'!='
op|'-'
number|'2'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'booted_from_volume'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'File injection into a boot from volume '"
nl|'\n'
string|"'instance is not supported'"
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_inject_data'
op|'('
nl|'\n'
name|'instance'
op|','
name|'network_info'
op|','
name|'admin_pass'
op|','
name|'files'
op|','
name|'suffix'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'uml'"
op|':'
newline|'\n'
indent|'            '
name|'libvirt_utils'
op|'.'
name|'chown'
op|'('
name|'image'
op|'('
string|"'disk'"
op|')'
op|'.'
name|'path'
op|','
string|"'root'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|_prepare_pci_devices_for_use
dedent|''
dedent|''
name|'def'
name|'_prepare_pci_devices_for_use'
op|'('
name|'self'
op|','
name|'pci_devices'
op|')'
op|':'
newline|'\n'
comment|'# kvm , qemu support managed mode'
nl|'\n'
comment|'# In managed mode, the configured device will be automatically'
nl|'\n'
comment|'# detached from the host OS drivers when the guest is started,'
nl|'\n'
comment|'# and then re-attached when the guest shuts down.'
nl|'\n'
indent|'        '
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'!='
string|"'xen'"
op|':'
newline|'\n'
comment|'# we do manual detach only for xen'
nl|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'dev'
name|'in'
name|'pci_devices'
op|':'
newline|'\n'
indent|'                '
name|'libvirt_dev_addr'
op|'='
name|'dev'
op|'['
string|"'hypervisor_name'"
op|']'
newline|'\n'
name|'libvirt_dev'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'device_lookup_by_name'
op|'('
name|'libvirt_dev_addr'
op|')'
newline|'\n'
comment|"# Note(yjiang5) Spelling for 'dettach' is correct, see"
nl|'\n'
comment|'# http://libvirt.org/html/libvirt-libvirt.html.'
nl|'\n'
name|'libvirt_dev'
op|'.'
name|'dettach'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Note(yjiang5): A reset of one PCI device may impact other'
nl|'\n'
comment|'# devices on the same bus, thus we need two separated loops'
nl|'\n'
comment|'# to detach and then reset it.'
nl|'\n'
dedent|''
name|'for'
name|'dev'
name|'in'
name|'pci_devices'
op|':'
newline|'\n'
indent|'                '
name|'libvirt_dev_addr'
op|'='
name|'dev'
op|'['
string|"'hypervisor_name'"
op|']'
newline|'\n'
name|'libvirt_dev'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'device_lookup_by_name'
op|'('
name|'libvirt_dev_addr'
op|')'
newline|'\n'
name|'libvirt_dev'
op|'.'
name|'reset'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'PciDevicePrepareFailed'
op|'('
name|'id'
op|'='
name|'dev'
op|'['
string|"'id'"
op|']'
op|','
nl|'\n'
name|'instance_uuid'
op|'='
nl|'\n'
name|'dev'
op|'['
string|"'instance_uuid'"
op|']'
op|','
nl|'\n'
name|'reason'
op|'='
name|'six'
op|'.'
name|'text_type'
op|'('
name|'exc'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_detach_pci_devices
dedent|''
dedent|''
name|'def'
name|'_detach_pci_devices'
op|'('
name|'self'
op|','
name|'guest'
op|','
name|'pci_devs'
op|')'
op|':'
newline|'\n'
nl|'\n'
comment|'# for libvirt version < 1.1.1, this is race condition'
nl|'\n'
comment|'# so forbid detach if not had this version'
nl|'\n'
indent|'        '
name|'if'
name|'not'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'has_min_version'
op|'('
name|'MIN_LIBVIRT_DEVICE_CALLBACK_VERSION'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'pci_devs'
op|':'
newline|'\n'
indent|'                '
name|'reason'
op|'='
op|'('
name|'_'
op|'('
string|'"Detaching PCI devices with libvirt < %(ver)s"'
nl|'\n'
string|'" is not permitted"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'ver'"
op|':'
name|'MIN_LIBVIRT_DEVICE_CALLBACK_VERSION'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'PciDeviceDetachFailed'
op|'('
name|'reason'
op|'='
name|'reason'
op|','
nl|'\n'
name|'dev'
op|'='
name|'pci_devs'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'dev'
name|'in'
name|'pci_devs'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'detach_device'
op|'('
name|'self'
op|'.'
name|'_get_guest_pci_device'
op|'('
name|'dev'
op|')'
op|','
name|'live'
op|'='
name|'True'
op|')'
newline|'\n'
comment|'# after detachDeviceFlags returned, we should check the dom to'
nl|'\n'
comment|'# ensure the detaching is finished'
nl|'\n'
name|'xml'
op|'='
name|'guest'
op|'.'
name|'get_xml_desc'
op|'('
op|')'
newline|'\n'
name|'xml_doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
name|'guest_config'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuest'
op|'('
op|')'
newline|'\n'
name|'guest_config'
op|'.'
name|'parse_dom'
op|'('
name|'xml_doc'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'hdev'
name|'in'
op|'['
name|'d'
name|'for'
name|'d'
name|'in'
name|'guest_config'
op|'.'
name|'devices'
nl|'\n'
name|'if'
name|'isinstance'
op|'('
name|'d'
op|','
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestHostdevPCI'
op|')'
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'hdbsf'
op|'='
op|'['
name|'hdev'
op|'.'
name|'domain'
op|','
name|'hdev'
op|'.'
name|'bus'
op|','
name|'hdev'
op|'.'
name|'slot'
op|','
name|'hdev'
op|'.'
name|'function'
op|']'
newline|'\n'
name|'dbsf'
op|'='
name|'pci_utils'
op|'.'
name|'parse_address'
op|'('
name|'dev'
op|'['
string|"'address'"
op|']'
op|')'
newline|'\n'
name|'if'
op|'['
name|'int'
op|'('
name|'x'
op|','
number|'16'
op|')'
name|'for'
name|'x'
name|'in'
name|'hdbsf'
op|']'
op|'=='
op|'['
name|'int'
op|'('
name|'x'
op|','
number|'16'
op|')'
name|'for'
name|'x'
name|'in'
name|'dbsf'
op|']'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
name|'exception'
op|'.'
name|'PciDeviceDetachFailed'
op|'('
name|'reason'
op|'='
nl|'\n'
string|'"timeout"'
op|','
nl|'\n'
name|'dev'
op|'='
name|'dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_DOMAIN'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Instance disappeared while detaching "'
nl|'\n'
string|'"a PCI device from it."'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
nl|'\n'
DECL|member|_attach_pci_devices
dedent|''
dedent|''
dedent|''
name|'def'
name|'_attach_pci_devices'
op|'('
name|'self'
op|','
name|'guest'
op|','
name|'pci_devs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'dev'
name|'in'
name|'pci_devs'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'attach_device'
op|'('
name|'self'
op|'.'
name|'_get_guest_pci_device'
op|'('
name|'dev'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'Attaching PCI devices %(dev)s to %(dom)s failed.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'dev'"
op|':'
name|'pci_devs'
op|','
string|"'dom'"
op|':'
name|'guest'
op|'.'
name|'id'
op|'}'
op|')'
newline|'\n'
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_has_sriov_port
name|'def'
name|'_has_sriov_port'
op|'('
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'vif'
op|'['
string|"'vnic_type'"
op|']'
op|'=='
name|'network_model'
op|'.'
name|'VNIC_TYPE_DIRECT'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|_attach_sriov_ports
dedent|''
name|'def'
name|'_attach_sriov_ports'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'guest'
op|','
name|'network_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'network_info'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'network_info'
op|'='
name|'instance'
op|'.'
name|'info_cache'
op|'.'
name|'network_info'
newline|'\n'
dedent|''
name|'if'
name|'network_info'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_has_sriov_port'
op|'('
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'image_meta'
op|'='
name|'utils'
op|'.'
name|'get_image_from_system_metadata'
op|'('
nl|'\n'
name|'instance'
op|'.'
name|'system_metadata'
op|')'
newline|'\n'
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'vif'
op|'['
string|"'vnic_type'"
op|']'
op|'=='
name|'network_model'
op|'.'
name|'VNIC_TYPE_DIRECT'
op|':'
newline|'\n'
indent|'                    '
name|'cfg'
op|'='
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'get_config'
op|'('
name|'instance'
op|','
nl|'\n'
name|'vif'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'instance'
op|'.'
name|'flavor'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Attaching SR-IOV port %(port)s to %(dom)s'"
op|','
nl|'\n'
op|'{'
string|"'port'"
op|':'
name|'vif'
op|','
string|"'dom'"
op|':'
name|'guest'
op|'.'
name|'id'
op|'}'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'attach_device'
op|'('
name|'cfg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_detach_sriov_ports
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_detach_sriov_ports'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'guest'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'network_info'
op|'='
name|'instance'
op|'.'
name|'info_cache'
op|'.'
name|'network_info'
newline|'\n'
name|'if'
name|'network_info'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_has_sriov_port'
op|'('
name|'network_info'
op|')'
op|':'
newline|'\n'
comment|'# for libvirt version < 1.1.1, this is race condition'
nl|'\n'
comment|"# so forbid detach if it's an older version"
nl|'\n'
indent|'            '
name|'if'
name|'not'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'has_min_version'
op|'('
nl|'\n'
name|'MIN_LIBVIRT_DEVICE_CALLBACK_VERSION'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'reason'
op|'='
op|'('
name|'_'
op|'('
string|'"Detaching SR-IOV ports with"'
nl|'\n'
string|'" libvirt < %(ver)s is not permitted"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'ver'"
op|':'
name|'MIN_LIBVIRT_DEVICE_CALLBACK_VERSION'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'PciDeviceDetachFailed'
op|'('
name|'reason'
op|'='
name|'reason'
op|','
nl|'\n'
name|'dev'
op|'='
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'image_meta'
op|'='
name|'utils'
op|'.'
name|'get_image_from_system_metadata'
op|'('
nl|'\n'
name|'instance'
op|'.'
name|'system_metadata'
op|')'
newline|'\n'
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'vif'
op|'['
string|"'vnic_type'"
op|']'
op|'=='
name|'network_model'
op|'.'
name|'VNIC_TYPE_DIRECT'
op|':'
newline|'\n'
indent|'                    '
name|'cfg'
op|'='
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'get_config'
op|'('
name|'instance'
op|','
nl|'\n'
name|'vif'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'instance'
op|'.'
name|'flavor'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'detach_device'
op|'('
name|'cfg'
op|','
name|'live'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_set_host_enabled
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_set_host_enabled'
op|'('
name|'self'
op|','
name|'enabled'
op|','
nl|'\n'
name|'disable_reason'
op|'='
name|'DISABLE_REASON_UNDEFINED'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Enables / Disables the compute service on this host.\n\n           This doesn\'t override non-automatic disablement with an automatic\n           setting; thereby permitting operators to keep otherwise\n           healthy hosts out of rotation.\n        """'
newline|'\n'
nl|'\n'
name|'status_name'
op|'='
op|'{'
name|'True'
op|':'
string|"'disabled'"
op|','
nl|'\n'
name|'False'
op|':'
string|"'enabled'"
op|'}'
newline|'\n'
nl|'\n'
name|'disable_service'
op|'='
name|'not'
name|'enabled'
newline|'\n'
nl|'\n'
name|'ctx'
op|'='
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'service'
op|'='
name|'objects'
op|'.'
name|'Service'
op|'.'
name|'get_by_compute_host'
op|'('
name|'ctx'
op|','
name|'CONF'
op|'.'
name|'host'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'service'
op|'.'
name|'disabled'
op|'!='
name|'disable_service'
op|':'
newline|'\n'
comment|'# Note(jang): this is a quick fix to stop operator-'
nl|'\n'
comment|'# disabled compute hosts from re-enabling themselves'
nl|'\n'
comment|'# automatically. We prefix any automatic reason code'
nl|'\n'
comment|'# with a fixed string. We only re-enable a host'
nl|'\n'
comment|'# automatically if we find that string in place.'
nl|'\n'
comment|'# This should probably be replaced with a separate flag.'
nl|'\n'
indent|'                '
name|'if'
name|'not'
name|'service'
op|'.'
name|'disabled'
name|'or'
op|'('
nl|'\n'
name|'service'
op|'.'
name|'disabled_reason'
name|'and'
nl|'\n'
name|'service'
op|'.'
name|'disabled_reason'
op|'.'
name|'startswith'
op|'('
name|'DISABLE_PREFIX'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'service'
op|'.'
name|'disabled'
op|'='
name|'disable_service'
newline|'\n'
name|'service'
op|'.'
name|'disabled_reason'
op|'='
op|'('
nl|'\n'
name|'DISABLE_PREFIX'
op|'+'
name|'disable_reason'
nl|'\n'
name|'if'
name|'disable_service'
name|'else'
name|'DISABLE_REASON_UNDEFINED'
op|')'
newline|'\n'
name|'service'
op|'.'
name|'save'
op|'('
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Updating compute service status to %s'"
op|','
nl|'\n'
name|'status_name'
op|'['
name|'disable_service'
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Not overriding manual compute service '"
nl|'\n'
string|"'status with: %s'"
op|','
nl|'\n'
name|'status_name'
op|'['
name|'disable_service'
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
name|'exception'
op|'.'
name|'ComputeHostNotFound'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'\'Cannot update service status on host "%s" \''
nl|'\n'
string|"'since it is not registered.'"
op|')'
op|','
name|'CONF'
op|'.'
name|'host'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'\'Cannot update service status on host "%s" \''
nl|'\n'
string|"'due to an unexpected exception.'"
op|')'
op|','
name|'CONF'
op|'.'
name|'host'
op|','
nl|'\n'
name|'exc_info'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_cpu_model_config
dedent|''
dedent|''
name|'def'
name|'_get_guest_cpu_model_config'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'mode'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'cpu_mode'
newline|'\n'
name|'model'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'cpu_model'
newline|'\n'
nl|'\n'
name|'if'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|'"kvm"'
name|'or'
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|'"qemu"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'mode'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'mode'
op|'='
string|'"host-model"'
newline|'\n'
dedent|''
name|'if'
name|'mode'
op|'=='
string|'"none"'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPU'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'mode'
name|'is'
name|'None'
name|'or'
name|'mode'
op|'=='
string|'"none"'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
op|'('
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'!='
string|'"kvm"'
name|'and'
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'!='
string|'"qemu"'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|'"Config requested an explicit CPU model, but "'
nl|'\n'
string|'"the current libvirt hypervisor \'%s\' does not "'
nl|'\n'
string|'"support selecting CPU models"'
op|')'
op|'%'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'mode'
op|'=='
string|'"custom"'
name|'and'
name|'model'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|'"Config requested a custom CPU model, but no "'
nl|'\n'
string|'"model name was provided"'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'msg'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'mode'
op|'!='
string|'"custom"'
name|'and'
name|'model'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|'"A CPU model name should not be set when a "'
nl|'\n'
string|'"host CPU model is requested"'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"CPU mode \'%(mode)s\' model \'%(model)s\' was chosen"'
op|','
nl|'\n'
op|'{'
string|"'mode'"
op|':'
name|'mode'
op|','
string|"'model'"
op|':'
op|'('
name|'model'
name|'or'
string|'""'
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'cpu'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPU'
op|'('
op|')'
newline|'\n'
name|'cpu'
op|'.'
name|'mode'
op|'='
name|'mode'
newline|'\n'
name|'cpu'
op|'.'
name|'model'
op|'='
name|'model'
newline|'\n'
nl|'\n'
name|'return'
name|'cpu'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_cpu_config
dedent|''
name|'def'
name|'_get_guest_cpu_config'
op|'('
name|'self'
op|','
name|'flavor'
op|','
name|'image'
op|','
nl|'\n'
name|'guest_cpu_numa_config'
op|','
name|'instance_numa_topology'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'cpu'
op|'='
name|'self'
op|'.'
name|'_get_guest_cpu_model_config'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'cpu'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'topology'
op|'='
name|'hardware'
op|'.'
name|'get_best_cpu_topology'
op|'('
nl|'\n'
name|'flavor'
op|','
name|'image'
op|','
name|'numa_topology'
op|'='
name|'instance_numa_topology'
op|')'
newline|'\n'
nl|'\n'
name|'cpu'
op|'.'
name|'sockets'
op|'='
name|'topology'
op|'.'
name|'sockets'
newline|'\n'
name|'cpu'
op|'.'
name|'cores'
op|'='
name|'topology'
op|'.'
name|'cores'
newline|'\n'
name|'cpu'
op|'.'
name|'threads'
op|'='
name|'topology'
op|'.'
name|'threads'
newline|'\n'
name|'cpu'
op|'.'
name|'numa'
op|'='
name|'guest_cpu_numa_config'
newline|'\n'
nl|'\n'
name|'return'
name|'cpu'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_disk_config
dedent|''
name|'def'
name|'_get_guest_disk_config'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'name'
op|','
name|'disk_mapping'
op|','
name|'inst_type'
op|','
nl|'\n'
name|'image_type'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'hw_disk_discard'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'has_min_version'
op|'('
name|'MIN_LIBVIRT_DISCARD_VERSION'
op|','
nl|'\n'
name|'MIN_QEMU_DISCARD_VERSION'
op|','
nl|'\n'
name|'host'
op|'.'
name|'HV_DRIVER_QEMU'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|"'Volume sets discard option, but libvirt %(libvirt)s'"
nl|'\n'
string|"' or later is required, qemu %(qemu)s'"
nl|'\n'
string|"' or later is required.'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'libvirt'"
op|':'
name|'MIN_LIBVIRT_DISCARD_VERSION'
op|','
nl|'\n'
string|"'qemu'"
op|':'
name|'MIN_QEMU_DISCARD_VERSION'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'image'
op|'='
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'image'
op|'('
name|'instance'
op|','
nl|'\n'
name|'name'
op|','
nl|'\n'
name|'image_type'
op|')'
newline|'\n'
name|'disk_info'
op|'='
name|'disk_mapping'
op|'['
name|'name'
op|']'
newline|'\n'
name|'return'
name|'image'
op|'.'
name|'libvirt_info'
op|'('
name|'disk_info'
op|'['
string|"'bus'"
op|']'
op|','
nl|'\n'
name|'disk_info'
op|'['
string|"'dev'"
op|']'
op|','
nl|'\n'
name|'disk_info'
op|'['
string|"'type'"
op|']'
op|','
nl|'\n'
name|'self'
op|'.'
name|'disk_cachemode'
op|','
nl|'\n'
name|'inst_type'
op|'['
string|"'extra_specs'"
op|']'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_version'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_fs_config
dedent|''
name|'def'
name|'_get_guest_fs_config'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'name'
op|','
name|'image_type'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'image'
op|'='
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'image'
op|'('
name|'instance'
op|','
nl|'\n'
name|'name'
op|','
nl|'\n'
name|'image_type'
op|')'
newline|'\n'
name|'return'
name|'image'
op|'.'
name|'libvirt_fs_info'
op|'('
string|'"/"'
op|','
string|'"ploop"'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_storage_config
dedent|''
name|'def'
name|'_get_guest_storage_config'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'disk_info'
op|','
nl|'\n'
name|'rescue'
op|','
name|'block_device_info'
op|','
nl|'\n'
name|'inst_type'
op|','
name|'os_type'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'devices'
op|'='
op|'['
op|']'
newline|'\n'
name|'disk_mapping'
op|'='
name|'disk_info'
op|'['
string|"'mapping'"
op|']'
newline|'\n'
nl|'\n'
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'mount_rootfs'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|'"lxc"'
newline|'\n'
name|'if'
name|'mount_rootfs'
op|':'
newline|'\n'
indent|'            '
name|'fs'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestFilesys'
op|'('
op|')'
newline|'\n'
name|'fs'
op|'.'
name|'source_type'
op|'='
string|'"mount"'
newline|'\n'
name|'fs'
op|'.'
name|'source_dir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
nl|'\n'
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
op|','
string|"'rootfs'"
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'fs'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'os_type'
op|'=='
name|'vm_mode'
op|'.'
name|'EXE'
name|'and'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|'"parallels"'
op|':'
newline|'\n'
indent|'            '
name|'fs'
op|'='
name|'self'
op|'.'
name|'_get_guest_fs_config'
op|'('
name|'instance'
op|','
string|'"disk"'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'fs'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
nl|'\n'
indent|'            '
name|'if'
name|'rescue'
op|':'
newline|'\n'
indent|'                '
name|'diskrescue'
op|'='
name|'self'
op|'.'
name|'_get_guest_disk_config'
op|'('
name|'instance'
op|','
nl|'\n'
string|"'disk.rescue'"
op|','
nl|'\n'
name|'disk_mapping'
op|','
nl|'\n'
name|'inst_type'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'diskrescue'
op|')'
newline|'\n'
nl|'\n'
name|'diskos'
op|'='
name|'self'
op|'.'
name|'_get_guest_disk_config'
op|'('
name|'instance'
op|','
nl|'\n'
string|"'disk'"
op|','
nl|'\n'
name|'disk_mapping'
op|','
nl|'\n'
name|'inst_type'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'diskos'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'if'
string|"'disk'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'                    '
name|'diskos'
op|'='
name|'self'
op|'.'
name|'_get_guest_disk_config'
op|'('
name|'instance'
op|','
nl|'\n'
string|"'disk'"
op|','
nl|'\n'
name|'disk_mapping'
op|','
nl|'\n'
name|'inst_type'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'diskos'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
string|"'disk.local'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'                    '
name|'disklocal'
op|'='
name|'self'
op|'.'
name|'_get_guest_disk_config'
op|'('
name|'instance'
op|','
nl|'\n'
string|"'disk.local'"
op|','
nl|'\n'
name|'disk_mapping'
op|','
nl|'\n'
name|'inst_type'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'disklocal'
op|')'
newline|'\n'
name|'instance'
op|'.'
name|'default_ephemeral_device'
op|'='
op|'('
nl|'\n'
name|'block_device'
op|'.'
name|'prepend_dev'
op|'('
name|'disklocal'
op|'.'
name|'target_dev'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'idx'
op|','
name|'eph'
name|'in'
name|'enumerate'
op|'('
nl|'\n'
name|'driver'
op|'.'
name|'block_device_info_get_ephemerals'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'diskeph'
op|'='
name|'self'
op|'.'
name|'_get_guest_disk_config'
op|'('
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'blockinfo'
op|'.'
name|'get_eph_disk'
op|'('
name|'idx'
op|')'
op|','
nl|'\n'
name|'disk_mapping'
op|','
name|'inst_type'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'diskeph'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
string|"'disk.swap'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'                    '
name|'diskswap'
op|'='
name|'self'
op|'.'
name|'_get_guest_disk_config'
op|'('
name|'instance'
op|','
nl|'\n'
string|"'disk.swap'"
op|','
nl|'\n'
name|'disk_mapping'
op|','
nl|'\n'
name|'inst_type'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'diskswap'
op|')'
newline|'\n'
name|'instance'
op|'.'
name|'default_swap_device'
op|'='
op|'('
nl|'\n'
name|'block_device'
op|'.'
name|'prepend_dev'
op|'('
name|'diskswap'
op|'.'
name|'target_dev'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
string|"'disk.config'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'                '
name|'diskconfig'
op|'='
name|'self'
op|'.'
name|'_get_guest_disk_config'
op|'('
name|'instance'
op|','
nl|'\n'
string|"'disk.config'"
op|','
nl|'\n'
name|'disk_mapping'
op|','
nl|'\n'
name|'inst_type'
op|','
nl|'\n'
string|"'raw'"
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'diskconfig'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'for'
name|'vol'
name|'in'
name|'block_device'
op|'.'
name|'get_bdms_to_connect'
op|'('
name|'block_device_mapping'
op|','
nl|'\n'
name|'mount_rootfs'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'connection_info'
op|'='
name|'vol'
op|'['
string|"'connection_info'"
op|']'
newline|'\n'
name|'vol_dev'
op|'='
name|'block_device'
op|'.'
name|'prepend_dev'
op|'('
name|'vol'
op|'['
string|"'mount_device'"
op|']'
op|')'
newline|'\n'
name|'info'
op|'='
name|'disk_mapping'
op|'['
name|'vol_dev'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_connect_volume'
op|'('
name|'connection_info'
op|','
name|'info'
op|')'
newline|'\n'
name|'cfg'
op|'='
name|'self'
op|'.'
name|'_get_volume_config'
op|'('
name|'connection_info'
op|','
name|'info'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'cfg'
op|')'
newline|'\n'
name|'vol'
op|'['
string|"'connection_info'"
op|']'
op|'='
name|'connection_info'
newline|'\n'
name|'vol'
op|'.'
name|'save'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'d'
name|'in'
name|'devices'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_set_cache_mode'
op|'('
name|'d'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'image_meta'
name|'and'
nl|'\n'
name|'image_meta'
op|'.'
name|'get'
op|'('
string|"'properties'"
op|','
op|'{'
op|'}'
op|')'
op|'.'
name|'get'
op|'('
string|"'hw_scsi_model'"
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'hw_scsi_model'
op|'='
name|'image_meta'
op|'['
string|"'properties'"
op|']'
op|'['
string|"'hw_scsi_model'"
op|']'
newline|'\n'
name|'scsi_controller'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestController'
op|'('
op|')'
newline|'\n'
name|'scsi_controller'
op|'.'
name|'type'
op|'='
string|"'scsi'"
newline|'\n'
name|'scsi_controller'
op|'.'
name|'model'
op|'='
name|'hw_scsi_model'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'scsi_controller'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'devices'
newline|'\n'
nl|'\n'
DECL|member|_get_host_sysinfo_serial_hardware
dedent|''
name|'def'
name|'_get_host_sysinfo_serial_hardware'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get a UUID from the host hardware\n\n        Get a UUID for the host hardware reported by libvirt.\n        This is typically from the SMBIOS data, unless it has\n        been overridden in /etc/libvirt/libvirtd.conf\n        """'
newline|'\n'
name|'caps'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_capabilities'
op|'('
op|')'
newline|'\n'
name|'return'
name|'caps'
op|'.'
name|'host'
op|'.'
name|'uuid'
newline|'\n'
nl|'\n'
DECL|member|_get_host_sysinfo_serial_os
dedent|''
name|'def'
name|'_get_host_sysinfo_serial_os'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get a UUID from the host operating system\n\n        Get a UUID for the host operating system. Modern Linux\n        distros based on systemd provide a /etc/machine-id\n        file containing a UUID. This is also provided inside\n        systemd based containers and can be provided by other\n        init systems too, since it is just a plain text file.\n        """'
newline|'\n'
name|'with'
name|'open'
op|'('
string|'"/etc/machine-id"'
op|')'
name|'as'
name|'f'
op|':'
newline|'\n'
comment|"# We want to have '-' in the right place"
nl|'\n'
comment|'# so we parse & reformat the value'
nl|'\n'
indent|'            '
name|'return'
name|'str'
op|'('
name|'uuid'
op|'.'
name|'UUID'
op|'('
name|'f'
op|'.'
name|'read'
op|'('
op|')'
op|'.'
name|'split'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_host_sysinfo_serial_auto
dedent|''
dedent|''
name|'def'
name|'_get_host_sysinfo_serial_auto'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
string|'"/etc/machine-id"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'_get_host_sysinfo_serial_os'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'_get_host_sysinfo_serial_hardware'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_config_sysinfo
dedent|''
dedent|''
name|'def'
name|'_get_guest_config_sysinfo'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'sysinfo'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSysinfo'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'sysinfo'
op|'.'
name|'system_manufacturer'
op|'='
name|'version'
op|'.'
name|'vendor_string'
op|'('
op|')'
newline|'\n'
name|'sysinfo'
op|'.'
name|'system_product'
op|'='
name|'version'
op|'.'
name|'product_string'
op|'('
op|')'
newline|'\n'
name|'sysinfo'
op|'.'
name|'system_version'
op|'='
name|'version'
op|'.'
name|'version_string_with_package'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'sysinfo'
op|'.'
name|'system_serial'
op|'='
name|'self'
op|'.'
name|'_sysinfo_serial_func'
op|'('
op|')'
newline|'\n'
name|'sysinfo'
op|'.'
name|'system_uuid'
op|'='
name|'instance'
op|'.'
name|'uuid'
newline|'\n'
nl|'\n'
name|'sysinfo'
op|'.'
name|'system_family'
op|'='
string|'"Virtual Machine"'
newline|'\n'
nl|'\n'
name|'return'
name|'sysinfo'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_pci_device
dedent|''
name|'def'
name|'_get_guest_pci_device'
op|'('
name|'self'
op|','
name|'pci_device'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'        '
name|'dbsf'
op|'='
name|'pci_utils'
op|'.'
name|'parse_address'
op|'('
name|'pci_device'
op|'['
string|"'address'"
op|']'
op|')'
newline|'\n'
name|'dev'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestHostdevPCI'
op|'('
op|')'
newline|'\n'
name|'dev'
op|'.'
name|'domain'
op|','
name|'dev'
op|'.'
name|'bus'
op|','
name|'dev'
op|'.'
name|'slot'
op|','
name|'dev'
op|'.'
name|'function'
op|'='
name|'dbsf'
newline|'\n'
nl|'\n'
comment|'# only kvm support managed mode'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
name|'in'
op|'('
string|"'xen'"
op|','
string|"'parallels'"
op|','
op|')'
op|':'
newline|'\n'
indent|'            '
name|'dev'
op|'.'
name|'managed'
op|'='
string|"'no'"
newline|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
name|'in'
op|'('
string|"'kvm'"
op|','
string|"'qemu'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'dev'
op|'.'
name|'managed'
op|'='
string|"'yes'"
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'dev'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_config_meta
dedent|''
name|'def'
name|'_get_guest_config_meta'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get metadata config for guest."""'
newline|'\n'
nl|'\n'
name|'meta'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestMetaNovaInstance'
op|'('
op|')'
newline|'\n'
name|'meta'
op|'.'
name|'package'
op|'='
name|'version'
op|'.'
name|'version_string_with_package'
op|'('
op|')'
newline|'\n'
name|'meta'
op|'.'
name|'name'
op|'='
name|'instance'
op|'.'
name|'display_name'
newline|'\n'
name|'meta'
op|'.'
name|'creationTime'
op|'='
name|'time'
op|'.'
name|'time'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'instance'
op|'.'
name|'image_ref'
name|'not'
name|'in'
op|'('
string|'""'
op|','
name|'None'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'meta'
op|'.'
name|'roottype'
op|'='
string|'"image"'
newline|'\n'
name|'meta'
op|'.'
name|'rootid'
op|'='
name|'instance'
op|'.'
name|'image_ref'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'context'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'ometa'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestMetaNovaOwner'
op|'('
op|')'
newline|'\n'
name|'ometa'
op|'.'
name|'userid'
op|'='
name|'context'
op|'.'
name|'user_id'
newline|'\n'
name|'ometa'
op|'.'
name|'username'
op|'='
name|'context'
op|'.'
name|'user_name'
newline|'\n'
name|'ometa'
op|'.'
name|'projectid'
op|'='
name|'context'
op|'.'
name|'project_id'
newline|'\n'
name|'ometa'
op|'.'
name|'projectname'
op|'='
name|'context'
op|'.'
name|'project_name'
newline|'\n'
name|'meta'
op|'.'
name|'owner'
op|'='
name|'ometa'
newline|'\n'
nl|'\n'
dedent|''
name|'fmeta'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestMetaNovaFlavor'
op|'('
op|')'
newline|'\n'
name|'flavor'
op|'='
name|'instance'
op|'.'
name|'flavor'
newline|'\n'
name|'fmeta'
op|'.'
name|'name'
op|'='
name|'flavor'
op|'.'
name|'name'
newline|'\n'
name|'fmeta'
op|'.'
name|'memory'
op|'='
name|'flavor'
op|'.'
name|'memory_mb'
newline|'\n'
name|'fmeta'
op|'.'
name|'vcpus'
op|'='
name|'flavor'
op|'.'
name|'vcpus'
newline|'\n'
name|'fmeta'
op|'.'
name|'ephemeral'
op|'='
name|'flavor'
op|'.'
name|'ephemeral_gb'
newline|'\n'
name|'fmeta'
op|'.'
name|'disk'
op|'='
name|'flavor'
op|'.'
name|'root_gb'
newline|'\n'
name|'fmeta'
op|'.'
name|'swap'
op|'='
name|'flavor'
op|'.'
name|'swap'
newline|'\n'
nl|'\n'
name|'meta'
op|'.'
name|'flavor'
op|'='
name|'fmeta'
newline|'\n'
nl|'\n'
name|'return'
name|'meta'
newline|'\n'
nl|'\n'
DECL|member|_machine_type_mappings
dedent|''
name|'def'
name|'_machine_type_mappings'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'mappings'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'mapping'
name|'in'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'hw_machine_type'
op|':'
newline|'\n'
indent|'            '
name|'host_arch'
op|','
name|'_'
op|','
name|'machine_type'
op|'='
name|'mapping'
op|'.'
name|'partition'
op|'('
string|"'='"
op|')'
newline|'\n'
name|'mappings'
op|'['
name|'host_arch'
op|']'
op|'='
name|'machine_type'
newline|'\n'
dedent|''
name|'return'
name|'mappings'
newline|'\n'
nl|'\n'
DECL|member|_get_machine_type
dedent|''
name|'def'
name|'_get_machine_type'
op|'('
name|'self'
op|','
name|'image_meta'
op|','
name|'caps'
op|')'
op|':'
newline|'\n'
comment|'# The underlying machine type can be set as an image attribute,'
nl|'\n'
comment|'# or otherwise based on some architecture specific defaults'
nl|'\n'
nl|'\n'
indent|'        '
name|'mach_type'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'if'
op|'('
name|'image_meta'
name|'is'
name|'not'
name|'None'
name|'and'
name|'image_meta'
op|'.'
name|'get'
op|'('
string|"'properties'"
op|')'
name|'and'
nl|'\n'
name|'image_meta'
op|'['
string|"'properties'"
op|']'
op|'.'
name|'get'
op|'('
string|"'hw_machine_type'"
op|')'
nl|'\n'
name|'is'
name|'not'
name|'None'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'mach_type'
op|'='
name|'image_meta'
op|'['
string|"'properties'"
op|']'
op|'['
string|"'hw_machine_type'"
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# For ARM systems we will default to vexpress-a15 for armv7'
nl|'\n'
comment|'# and virt for aarch64'
nl|'\n'
indent|'            '
name|'if'
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'arch'
op|'=='
name|'arch'
op|'.'
name|'ARMV7'
op|':'
newline|'\n'
indent|'                '
name|'mach_type'
op|'='
string|'"vexpress-a15"'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'arch'
op|'=='
name|'arch'
op|'.'
name|'AARCH64'
op|':'
newline|'\n'
indent|'                '
name|'mach_type'
op|'='
string|'"virt"'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'arch'
name|'in'
op|'('
name|'arch'
op|'.'
name|'S390'
op|','
name|'arch'
op|'.'
name|'S390X'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'mach_type'
op|'='
string|"'s390-ccw-virtio'"
newline|'\n'
nl|'\n'
comment|'# If set in the config, use that as the default.'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'hw_machine_type'
op|':'
newline|'\n'
indent|'                '
name|'mappings'
op|'='
name|'self'
op|'.'
name|'_machine_type_mappings'
op|'('
op|')'
newline|'\n'
name|'mach_type'
op|'='
name|'mappings'
op|'.'
name|'get'
op|'('
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'arch'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'mach_type'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_create_idmaps
name|'def'
name|'_create_idmaps'
op|'('
name|'klass'
op|','
name|'map_strings'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'idmaps'
op|'='
op|'['
op|']'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'map_strings'
op|')'
op|'>'
number|'5'
op|':'
newline|'\n'
indent|'            '
name|'map_strings'
op|'='
name|'map_strings'
op|'['
number|'0'
op|':'
number|'5'
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Too many id maps, only included first five."'
op|')'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'map_string'
name|'in'
name|'map_strings'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'idmap'
op|'='
name|'klass'
op|'('
op|')'
newline|'\n'
name|'values'
op|'='
op|'['
name|'int'
op|'('
name|'i'
op|')'
name|'for'
name|'i'
name|'in'
name|'map_string'
op|'.'
name|'split'
op|'('
string|'":"'
op|')'
op|']'
newline|'\n'
name|'idmap'
op|'.'
name|'start'
op|'='
name|'values'
op|'['
number|'0'
op|']'
newline|'\n'
name|'idmap'
op|'.'
name|'target'
op|'='
name|'values'
op|'['
number|'1'
op|']'
newline|'\n'
name|'idmap'
op|'.'
name|'count'
op|'='
name|'values'
op|'['
number|'2'
op|']'
newline|'\n'
name|'idmaps'
op|'.'
name|'append'
op|'('
name|'idmap'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'ValueError'
op|','
name|'IndexError'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Invalid value for id mapping %s"'
op|')'
op|','
name|'map_string'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'idmaps'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_idmaps
dedent|''
name|'def'
name|'_get_guest_idmaps'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'id_maps'
op|'='
op|'['
op|']'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'lxc'"
name|'and'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'uid_maps'
op|':'
newline|'\n'
indent|'            '
name|'uid_maps'
op|'='
name|'self'
op|'.'
name|'_create_idmaps'
op|'('
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestUIDMap'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'uid_maps'
op|')'
newline|'\n'
name|'id_maps'
op|'.'
name|'extend'
op|'('
name|'uid_maps'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'lxc'"
name|'and'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'gid_maps'
op|':'
newline|'\n'
indent|'            '
name|'gid_maps'
op|'='
name|'self'
op|'.'
name|'_create_idmaps'
op|'('
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestGIDMap'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'gid_maps'
op|')'
newline|'\n'
name|'id_maps'
op|'.'
name|'extend'
op|'('
name|'gid_maps'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'id_maps'
newline|'\n'
nl|'\n'
DECL|member|_update_guest_cputune
dedent|''
name|'def'
name|'_update_guest_cputune'
op|'('
name|'self'
op|','
name|'guest'
op|','
name|'flavor'
op|','
name|'virt_type'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'virt_type'
name|'in'
op|'('
string|"'lxc'"
op|','
string|"'kvm'"
op|','
string|"'qemu'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'guest'
op|'.'
name|'cputune'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'cputune'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPUTune'
op|'('
op|')'
newline|'\n'
comment|'# Setting the default cpu.shares value to be a value'
nl|'\n'
comment|'# dependent on the number of vcpus'
nl|'\n'
dedent|''
name|'guest'
op|'.'
name|'cputune'
op|'.'
name|'shares'
op|'='
number|'1024'
op|'*'
name|'guest'
op|'.'
name|'vcpus'
newline|'\n'
nl|'\n'
name|'cputuning'
op|'='
op|'['
string|"'shares'"
op|','
string|"'period'"
op|','
string|"'quota'"
op|']'
newline|'\n'
name|'for'
name|'name'
name|'in'
name|'cputuning'
op|':'
newline|'\n'
indent|'                '
name|'key'
op|'='
string|'"quota:cpu_"'
op|'+'
name|'name'
newline|'\n'
name|'if'
name|'key'
name|'in'
name|'flavor'
op|'.'
name|'extra_specs'
op|':'
newline|'\n'
indent|'                    '
name|'setattr'
op|'('
name|'guest'
op|'.'
name|'cputune'
op|','
name|'name'
op|','
nl|'\n'
name|'int'
op|'('
name|'flavor'
op|'.'
name|'extra_specs'
op|'['
name|'key'
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_cpu_numa_config_from_instance
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_get_cpu_numa_config_from_instance'
op|'('
name|'self'
op|','
name|'instance_numa_topology'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'instance_numa_topology'
op|':'
newline|'\n'
indent|'            '
name|'guest_cpu_numa'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPUNUMA'
op|'('
op|')'
newline|'\n'
name|'for'
name|'instance_cell'
name|'in'
name|'instance_numa_topology'
op|'.'
name|'cells'
op|':'
newline|'\n'
indent|'                '
name|'guest_cell'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPUNUMACell'
op|'('
op|')'
newline|'\n'
name|'guest_cell'
op|'.'
name|'id'
op|'='
name|'instance_cell'
op|'.'
name|'id'
newline|'\n'
name|'guest_cell'
op|'.'
name|'cpus'
op|'='
name|'instance_cell'
op|'.'
name|'cpuset'
newline|'\n'
name|'guest_cell'
op|'.'
name|'memory'
op|'='
name|'instance_cell'
op|'.'
name|'memory'
op|'*'
name|'units'
op|'.'
name|'Ki'
newline|'\n'
name|'guest_cpu_numa'
op|'.'
name|'cells'
op|'.'
name|'append'
op|'('
name|'guest_cell'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'guest_cpu_numa'
newline|'\n'
nl|'\n'
DECL|member|_has_cpu_policy_support
dedent|''
dedent|''
name|'def'
name|'_has_cpu_policy_support'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'ver'
name|'in'
name|'BAD_LIBVIRT_CPU_POLICY_VERSIONS'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'has_version'
op|'('
name|'ver'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'ver_'
op|'='
name|'self'
op|'.'
name|'_version_to_string'
op|'('
name|'ver'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'CPUPinningNotSupported'
op|'('
name|'reason'
op|'='
name|'_'
op|'('
nl|'\n'
string|"'Invalid libvirt version %(version)s'"
op|')'
op|'%'
op|'{'
string|"'version'"
op|':'
name|'ver_'
op|'}'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'True'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_numa_config
dedent|''
name|'def'
name|'_get_guest_numa_config'
op|'('
name|'self'
op|','
name|'instance_numa_topology'
op|','
name|'flavor'
op|','
name|'pci_devs'
op|','
nl|'\n'
name|'allowed_cpus'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns the config objects for the guest NUMA specs.\n\n        Determines the CPUs that the guest can be pinned to if the guest\n        specifies a cell topology and the host supports it. Constructs the\n        libvirt XML config object representing the NUMA topology selected\n        for the guest. Returns a tuple of:\n\n            (cpu_set, guest_cpu_tune, guest_cpu_numa, guest_numa_tune)\n\n        With the following caveats:\n\n            a) If there is no specified guest NUMA topology, then\n               all tuple elements except cpu_set shall be None. cpu_set\n               will be populated with the chosen CPUs that the guest\n               allowed CPUs fit within, which could be the supplied\n               allowed_cpus value if the host doesn\'t support NUMA\n               topologies.\n\n            b) If there is a specified guest NUMA topology, then\n               cpu_set will be None and guest_cpu_numa will be the\n               LibvirtConfigGuestCPUNUMA object representing the guest\'s\n               NUMA topology. If the host supports NUMA, then guest_cpu_tune\n               will contain a LibvirtConfigGuestCPUTune object representing\n               the optimized chosen cells that match the host capabilities\n               with the instance\'s requested topology. If the host does\n               not support NUMA, then guest_cpu_tune and guest_numa_tune\n               will be None.\n        """'
newline|'\n'
nl|'\n'
name|'if'
op|'('
name|'not'
name|'self'
op|'.'
name|'_has_numa_support'
op|'('
op|')'
name|'and'
nl|'\n'
name|'instance_numa_topology'
name|'is'
name|'not'
name|'None'
op|')'
op|':'
newline|'\n'
comment|'# We should not get here, since we should have avoided'
nl|'\n'
comment|'# reporting NUMA topology from _get_host_numa_topology'
nl|'\n'
comment|'# in the first place. Just in case of a scheduler'
nl|'\n'
comment|'# mess up though, raise an exception'
nl|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'NUMATopologyUnsupported'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'topology'
op|'='
name|'self'
op|'.'
name|'_get_host_numa_topology'
op|'('
op|')'
newline|'\n'
comment|'# We have instance NUMA so translate it to the config class'
nl|'\n'
name|'guest_cpu_numa_config'
op|'='
name|'self'
op|'.'
name|'_get_cpu_numa_config_from_instance'
op|'('
nl|'\n'
name|'instance_numa_topology'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'guest_cpu_numa_config'
op|':'
newline|'\n'
comment|'# No NUMA topology defined for instance - let the host kernel deal'
nl|'\n'
comment|'# with the NUMA effects.'
nl|'\n'
comment|'# TODO(ndipanov): Attempt to spread the instance'
nl|'\n'
comment|'# across NUMA nodes and expose the topology to the'
nl|'\n'
comment|'# instance as an optimisation'
nl|'\n'
indent|'            '
name|'return'
name|'GuestNumaConfig'
op|'('
name|'allowed_cpus'
op|','
name|'None'
op|','
name|'None'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'topology'
op|':'
newline|'\n'
comment|'# Now get the CpuTune configuration from the numa_topology'
nl|'\n'
indent|'                '
name|'guest_cpu_tune'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPUTune'
op|'('
op|')'
newline|'\n'
name|'guest_numa_tune'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestNUMATune'
op|'('
op|')'
newline|'\n'
name|'allpcpus'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'numa_mem'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestNUMATuneMemory'
op|'('
op|')'
newline|'\n'
name|'numa_memnodes'
op|'='
op|'['
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestNUMATuneMemNode'
op|'('
op|')'
nl|'\n'
name|'for'
name|'_'
name|'in'
name|'guest_cpu_numa_config'
op|'.'
name|'cells'
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'host_cell'
name|'in'
name|'topology'
op|'.'
name|'cells'
op|':'
newline|'\n'
indent|'                    '
name|'for'
name|'guest_node_id'
op|','
name|'guest_config_cell'
name|'in'
name|'enumerate'
op|'('
nl|'\n'
name|'guest_cpu_numa_config'
op|'.'
name|'cells'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'guest_config_cell'
op|'.'
name|'id'
op|'=='
name|'host_cell'
op|'.'
name|'id'
op|':'
newline|'\n'
indent|'                            '
name|'node'
op|'='
name|'numa_memnodes'
op|'['
name|'guest_node_id'
op|']'
newline|'\n'
name|'node'
op|'.'
name|'cellid'
op|'='
name|'guest_config_cell'
op|'.'
name|'id'
newline|'\n'
name|'node'
op|'.'
name|'nodeset'
op|'='
op|'['
name|'host_cell'
op|'.'
name|'id'
op|']'
newline|'\n'
name|'node'
op|'.'
name|'mode'
op|'='
string|'"strict"'
newline|'\n'
nl|'\n'
name|'numa_mem'
op|'.'
name|'nodeset'
op|'.'
name|'append'
op|'('
name|'host_cell'
op|'.'
name|'id'
op|')'
newline|'\n'
nl|'\n'
name|'object_numa_cell'
op|'='
op|'('
nl|'\n'
name|'instance_numa_topology'
op|'.'
name|'cells'
op|'['
name|'guest_node_id'
op|']'
nl|'\n'
op|')'
newline|'\n'
name|'for'
name|'cpu'
name|'in'
name|'guest_config_cell'
op|'.'
name|'cpus'
op|':'
newline|'\n'
indent|'                                '
name|'pin_cpuset'
op|'='
op|'('
nl|'\n'
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPUTuneVCPUPin'
op|'('
op|')'
op|')'
newline|'\n'
name|'pin_cpuset'
op|'.'
name|'id'
op|'='
name|'cpu'
newline|'\n'
comment|'# If there is pinning information in the cell'
nl|'\n'
comment|'# we pin to individual CPUs, otherwise we float'
nl|'\n'
comment|'# over the whole host NUMA node'
nl|'\n'
nl|'\n'
name|'if'
op|'('
name|'object_numa_cell'
op|'.'
name|'cpu_pinning'
name|'and'
nl|'\n'
name|'self'
op|'.'
name|'_has_cpu_policy_support'
op|'('
op|')'
op|')'
op|':'
newline|'\n'
indent|'                                    '
name|'pcpu'
op|'='
name|'object_numa_cell'
op|'.'
name|'cpu_pinning'
op|'['
name|'cpu'
op|']'
newline|'\n'
name|'pin_cpuset'
op|'.'
name|'cpuset'
op|'='
name|'set'
op|'('
op|'['
name|'pcpu'
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                                    '
name|'pin_cpuset'
op|'.'
name|'cpuset'
op|'='
name|'host_cell'
op|'.'
name|'cpuset'
newline|'\n'
dedent|''
name|'allpcpus'
op|'.'
name|'extend'
op|'('
name|'pin_cpuset'
op|'.'
name|'cpuset'
op|')'
newline|'\n'
name|'guest_cpu_tune'
op|'.'
name|'vcpupin'
op|'.'
name|'append'
op|'('
name|'pin_cpuset'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(berrange) When the guest has >1 NUMA node, it will'
nl|'\n'
comment|'# span multiple host NUMA nodes. By pinning emulator threads'
nl|'\n'
comment|'# to the union of all nodes, we guarantee there will be'
nl|'\n'
comment|'# cross-node memory access by the emulator threads when'
nl|'\n'
comment|'# responding to guest I/O operations. The only way to avoid'
nl|'\n'
comment|'# this would be to pin emulator threads to a single node and'
nl|'\n'
comment|'# tell the guest OS to only do I/O from one of its virtual'
nl|'\n'
comment|'# NUMA nodes. This is not even remotely practical.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# The long term solution is to make use of a new QEMU feature'
nl|'\n'
comment|'# called "I/O Threads" which will let us configure an explicit'
nl|'\n'
comment|'# I/O thread for each guest vCPU or guest NUMA node. It is'
nl|'\n'
comment|'# still TBD how to make use of this feature though, especially'
nl|'\n'
comment|'# how to associate IO threads with guest devices to eliminiate'
nl|'\n'
comment|'# cross NUMA node traffic. This is an area of investigation'
nl|'\n'
comment|'# for QEMU community devs.'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'emulatorpin'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPUTuneEmulatorPin'
op|'('
op|')'
newline|'\n'
name|'emulatorpin'
op|'.'
name|'cpuset'
op|'='
name|'set'
op|'('
name|'allpcpus'
op|')'
newline|'\n'
name|'guest_cpu_tune'
op|'.'
name|'emulatorpin'
op|'='
name|'emulatorpin'
newline|'\n'
comment|'# Sort the vcpupin list per vCPU id for human-friendlier XML'
nl|'\n'
name|'guest_cpu_tune'
op|'.'
name|'vcpupin'
op|'.'
name|'sort'
op|'('
name|'key'
op|'='
name|'operator'
op|'.'
name|'attrgetter'
op|'('
string|'"id"'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'guest_numa_tune'
op|'.'
name|'memory'
op|'='
name|'numa_mem'
newline|'\n'
name|'guest_numa_tune'
op|'.'
name|'memnodes'
op|'='
name|'numa_memnodes'
newline|'\n'
nl|'\n'
comment|'# normalize cell.id'
nl|'\n'
name|'for'
name|'i'
op|','
op|'('
name|'cell'
op|','
name|'memnode'
op|')'
name|'in'
name|'enumerate'
op|'('
nl|'\n'
name|'zip'
op|'('
name|'guest_cpu_numa_config'
op|'.'
name|'cells'
op|','
nl|'\n'
name|'guest_numa_tune'
op|'.'
name|'memnodes'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'cell'
op|'.'
name|'id'
op|'='
name|'i'
newline|'\n'
name|'memnode'
op|'.'
name|'cellid'
op|'='
name|'i'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'GuestNumaConfig'
op|'('
name|'None'
op|','
name|'guest_cpu_tune'
op|','
nl|'\n'
name|'guest_cpu_numa_config'
op|','
nl|'\n'
name|'guest_numa_tune'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'GuestNumaConfig'
op|'('
name|'allowed_cpus'
op|','
name|'None'
op|','
nl|'\n'
name|'guest_cpu_numa_config'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_os_type
dedent|''
dedent|''
dedent|''
name|'def'
name|'_get_guest_os_type'
op|'('
name|'self'
op|','
name|'virt_type'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns the guest OS type based on virt type."""'
newline|'\n'
name|'if'
name|'virt_type'
op|'=='
string|'"lxc"'
op|':'
newline|'\n'
indent|'            '
name|'ret'
op|'='
name|'vm_mode'
op|'.'
name|'EXE'
newline|'\n'
dedent|''
name|'elif'
name|'virt_type'
op|'=='
string|'"uml"'
op|':'
newline|'\n'
indent|'            '
name|'ret'
op|'='
name|'vm_mode'
op|'.'
name|'UML'
newline|'\n'
dedent|''
name|'elif'
name|'virt_type'
op|'=='
string|'"xen"'
op|':'
newline|'\n'
indent|'            '
name|'ret'
op|'='
name|'vm_mode'
op|'.'
name|'XEN'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'ret'
op|'='
name|'vm_mode'
op|'.'
name|'HVM'
newline|'\n'
dedent|''
name|'return'
name|'ret'
newline|'\n'
nl|'\n'
DECL|member|_set_guest_for_rescue
dedent|''
name|'def'
name|'_set_guest_for_rescue'
op|'('
name|'self'
op|','
name|'rescue'
op|','
name|'guest'
op|','
name|'inst_path'
op|','
name|'virt_type'
op|','
nl|'\n'
name|'root_device_name'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'rescue'
op|'.'
name|'get'
op|'('
string|"'kernel_id'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'os_kernel'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_path'
op|','
string|'"kernel.rescue"'
op|')'
newline|'\n'
name|'if'
name|'virt_type'
op|'=='
string|'"xen"'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_cmdline'
op|'='
string|'"ro root=%s"'
op|'%'
name|'root_device_name'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_cmdline'
op|'='
op|'('
string|'"root=%s %s"'
op|'%'
op|'('
name|'root_device_name'
op|','
name|'CONSOLE'
op|')'
op|')'
newline|'\n'
name|'if'
name|'virt_type'
op|'=='
string|'"qemu"'
op|':'
newline|'\n'
indent|'                    '
name|'guest'
op|'.'
name|'os_cmdline'
op|'+='
string|'" no_timer_check"'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'rescue'
op|'.'
name|'get'
op|'('
string|"'ramdisk_id'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'os_initrd'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_path'
op|','
string|'"ramdisk.rescue"'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_set_guest_for_inst_kernel
dedent|''
dedent|''
name|'def'
name|'_set_guest_for_inst_kernel'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'guest'
op|','
name|'inst_path'
op|','
name|'virt_type'
op|','
nl|'\n'
name|'root_device_name'
op|','
name|'image_meta'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'guest'
op|'.'
name|'os_kernel'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_path'
op|','
string|'"kernel"'
op|')'
newline|'\n'
name|'if'
name|'virt_type'
op|'=='
string|'"xen"'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'os_cmdline'
op|'='
string|'"ro root=%s"'
op|'%'
name|'root_device_name'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'os_cmdline'
op|'='
op|'('
string|'"root=%s %s"'
op|'%'
op|'('
name|'root_device_name'
op|','
name|'CONSOLE'
op|')'
op|')'
newline|'\n'
name|'if'
name|'virt_type'
op|'=='
string|'"qemu"'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_cmdline'
op|'+='
string|'" no_timer_check"'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'instance'
op|'.'
name|'ramdisk_id'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'os_initrd'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_path'
op|','
string|'"ramdisk"'
op|')'
newline|'\n'
comment|'# we only support os_command_line with images with an explicit'
nl|'\n'
comment|"# kernel set and don't want to break nova if there's an"
nl|'\n'
comment|'# os_command_line property without a specified kernel_id param'
nl|'\n'
dedent|''
name|'if'
name|'image_meta'
op|':'
newline|'\n'
indent|'            '
name|'img_props'
op|'='
name|'image_meta'
op|'.'
name|'get'
op|'('
string|"'properties'"
op|','
op|'{'
op|'}'
op|')'
newline|'\n'
name|'if'
name|'img_props'
op|'.'
name|'get'
op|'('
string|"'os_command_line'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_cmdline'
op|'='
name|'img_props'
op|'.'
name|'get'
op|'('
string|"'os_command_line'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|_set_clock
dedent|''
dedent|''
dedent|''
name|'def'
name|'_set_clock'
op|'('
name|'self'
op|','
name|'guest'
op|','
name|'os_type'
op|','
name|'image_meta'
op|','
name|'virt_type'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(mikal): Microsoft Windows expects the clock to be in'
nl|'\n'
comment|'# "localtime". If the clock is set to UTC, then you can use a'
nl|'\n'
comment|'# registry key to let windows know, but Microsoft says this is'
nl|'\n'
comment|'# buggy in http://support.microsoft.com/kb/2687252'
nl|'\n'
indent|'        '
name|'clk'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestClock'
op|'('
op|')'
newline|'\n'
name|'if'
name|'os_type'
op|'=='
string|"'windows'"
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Configuring timezone for windows instance to '"
nl|'\n'
string|"'localtime'"
op|')'
op|')'
newline|'\n'
name|'clk'
op|'.'
name|'offset'
op|'='
string|"'localtime'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'clk'
op|'.'
name|'offset'
op|'='
string|"'utc'"
newline|'\n'
dedent|''
name|'guest'
op|'.'
name|'set_clock'
op|'('
name|'clk'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'virt_type'
op|'=='
string|'"kvm"'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_set_kvm_timers'
op|'('
name|'clk'
op|','
name|'os_type'
op|','
name|'image_meta'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_set_kvm_timers
dedent|''
dedent|''
name|'def'
name|'_set_kvm_timers'
op|'('
name|'self'
op|','
name|'clk'
op|','
name|'os_type'
op|','
name|'image_meta'
op|')'
op|':'
newline|'\n'
comment|'# TODO(berrange) One day this should be per-guest'
nl|'\n'
comment|'# OS type configurable'
nl|'\n'
indent|'        '
name|'tmpit'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestTimer'
op|'('
op|')'
newline|'\n'
name|'tmpit'
op|'.'
name|'name'
op|'='
string|'"pit"'
newline|'\n'
name|'tmpit'
op|'.'
name|'tickpolicy'
op|'='
string|'"delay"'
newline|'\n'
nl|'\n'
name|'tmrtc'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestTimer'
op|'('
op|')'
newline|'\n'
name|'tmrtc'
op|'.'
name|'name'
op|'='
string|'"rtc"'
newline|'\n'
name|'tmrtc'
op|'.'
name|'tickpolicy'
op|'='
string|'"catchup"'
newline|'\n'
nl|'\n'
name|'clk'
op|'.'
name|'add_timer'
op|'('
name|'tmpit'
op|')'
newline|'\n'
name|'clk'
op|'.'
name|'add_timer'
op|'('
name|'tmrtc'
op|')'
newline|'\n'
nl|'\n'
name|'guestarch'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_arch'
op|'('
name|'image_meta'
op|')'
newline|'\n'
name|'if'
name|'guestarch'
name|'in'
op|'('
name|'arch'
op|'.'
name|'I686'
op|','
name|'arch'
op|'.'
name|'X86_64'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(rfolco): HPET is a hardware timer for x86 arch.'
nl|'\n'
comment|'# qemu -no-hpet is not supported on non-x86 targets.'
nl|'\n'
indent|'            '
name|'tmhpet'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestTimer'
op|'('
op|')'
newline|'\n'
name|'tmhpet'
op|'.'
name|'name'
op|'='
string|'"hpet"'
newline|'\n'
name|'tmhpet'
op|'.'
name|'present'
op|'='
name|'False'
newline|'\n'
name|'clk'
op|'.'
name|'add_timer'
op|'('
name|'tmhpet'
op|')'
newline|'\n'
nl|'\n'
comment|'# With new enough QEMU we can provide Windows guests'
nl|'\n'
comment|'# with the paravirtualized hyperv timer source. This'
nl|'\n'
comment|'# is the windows equiv of kvm-clock, allowing Windows'
nl|'\n'
comment|'# guests to accurately keep time.'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'os_type'
op|'=='
string|"'windows'"
name|'and'
nl|'\n'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'has_min_version'
op|'('
name|'MIN_LIBVIRT_HYPERV_TIMER_VERSION'
op|','
nl|'\n'
name|'MIN_QEMU_HYPERV_TIMER_VERSION'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'tmhyperv'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestTimer'
op|'('
op|')'
newline|'\n'
name|'tmhyperv'
op|'.'
name|'name'
op|'='
string|'"hypervclock"'
newline|'\n'
name|'tmhyperv'
op|'.'
name|'present'
op|'='
name|'True'
newline|'\n'
name|'clk'
op|'.'
name|'add_timer'
op|'('
name|'tmhyperv'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_set_features
dedent|''
dedent|''
name|'def'
name|'_set_features'
op|'('
name|'self'
op|','
name|'guest'
op|','
name|'os_type'
op|','
name|'caps'
op|','
name|'virt_type'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'virt_type'
op|'=='
string|'"xen"'
op|':'
newline|'\n'
comment|'# PAE only makes sense in X86'
nl|'\n'
indent|'            '
name|'if'
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'arch'
name|'in'
op|'('
name|'arch'
op|'.'
name|'I686'
op|','
name|'arch'
op|'.'
name|'X86_64'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'features'
op|'.'
name|'append'
op|'('
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestFeaturePAE'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
op|'('
name|'virt_type'
name|'not'
name|'in'
op|'('
string|'"lxc"'
op|','
string|'"uml"'
op|','
string|'"parallels"'
op|','
string|'"xen"'
op|')'
name|'or'
nl|'\n'
op|'('
name|'virt_type'
op|'=='
string|'"xen"'
name|'and'
name|'guest'
op|'.'
name|'os_type'
op|'=='
name|'vm_mode'
op|'.'
name|'HVM'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'features'
op|'.'
name|'append'
op|'('
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestFeatureACPI'
op|'('
op|')'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'features'
op|'.'
name|'append'
op|'('
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestFeatureAPIC'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'virt_type'
name|'in'
op|'('
string|'"qemu"'
op|','
string|'"kvm"'
op|')'
name|'and'
nl|'\n'
name|'os_type'
op|'=='
string|"'windows'"
name|'and'
nl|'\n'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'has_min_version'
op|'('
name|'MIN_LIBVIRT_HYPERV_FEATURE_VERSION'
op|','
nl|'\n'
name|'MIN_QEMU_HYPERV_FEATURE_VERSION'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'hv'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestFeatureHyperV'
op|'('
op|')'
newline|'\n'
name|'hv'
op|'.'
name|'relaxed'
op|'='
name|'True'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'has_min_version'
op|'('
nl|'\n'
name|'MIN_LIBVIRT_HYPERV_FEATURE_EXTRA_VERSION'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'hv'
op|'.'
name|'spinlocks'
op|'='
name|'True'
newline|'\n'
comment|'# Increase spinlock retries - value recommended by'
nl|'\n'
comment|'# KVM maintainers who certify Windows guests'
nl|'\n'
comment|'# with Microsoft'
nl|'\n'
name|'hv'
op|'.'
name|'spinlock_retries'
op|'='
number|'8191'
newline|'\n'
name|'hv'
op|'.'
name|'vapic'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'guest'
op|'.'
name|'features'
op|'.'
name|'append'
op|'('
name|'hv'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_create_serial_console_devices
dedent|''
dedent|''
name|'def'
name|'_create_serial_console_devices'
op|'('
name|'self'
op|','
name|'guest'
op|','
name|'instance'
op|','
name|'flavor'
op|','
nl|'\n'
name|'image_meta'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'guest_arch'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_arch'
op|'('
name|'image_meta'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'serial_console'
op|'.'
name|'enabled'
op|':'
newline|'\n'
indent|'            '
name|'num_ports'
op|'='
name|'hardware'
op|'.'
name|'get_number_of_serial_ports'
op|'('
nl|'\n'
name|'flavor'
op|','
name|'image_meta'
op|')'
newline|'\n'
name|'for'
name|'port'
name|'in'
name|'six'
op|'.'
name|'moves'
op|'.'
name|'range'
op|'('
name|'num_ports'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'guest_arch'
name|'in'
op|'('
name|'arch'
op|'.'
name|'S390'
op|','
name|'arch'
op|'.'
name|'S390X'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'console'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestConsole'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'console'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSerial'
op|'('
op|')'
newline|'\n'
dedent|''
name|'console'
op|'.'
name|'port'
op|'='
name|'port'
newline|'\n'
name|'console'
op|'.'
name|'type'
op|'='
string|'"tcp"'
newline|'\n'
name|'console'
op|'.'
name|'listen_host'
op|'='
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'serial_console'
op|'.'
name|'proxyclient_address'
op|')'
newline|'\n'
name|'console'
op|'.'
name|'listen_port'
op|'='
op|'('
nl|'\n'
name|'serial_console'
op|'.'
name|'acquire_port'
op|'('
nl|'\n'
name|'console'
op|'.'
name|'listen_host'
op|')'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'console'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|"# The QEMU 'pty' driver throws away any data if no"
nl|'\n'
comment|"# client app is connected. Thus we can't get away"
nl|'\n'
comment|'# with a single type=pty console. Instead we have'
nl|'\n'
comment|'# to configure two separate consoles.'
nl|'\n'
indent|'            '
name|'if'
name|'guest_arch'
name|'in'
op|'('
name|'arch'
op|'.'
name|'S390'
op|','
name|'arch'
op|'.'
name|'S390X'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'consolelog'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestConsole'
op|'('
op|')'
newline|'\n'
name|'consolelog'
op|'.'
name|'target_type'
op|'='
string|'"sclplm"'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'consolelog'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSerial'
op|'('
op|')'
newline|'\n'
dedent|''
name|'consolelog'
op|'.'
name|'type'
op|'='
string|'"file"'
newline|'\n'
name|'consolelog'
op|'.'
name|'source_path'
op|'='
name|'self'
op|'.'
name|'_get_console_log_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'consolelog'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_add_video_driver
dedent|''
dedent|''
name|'def'
name|'_add_video_driver'
op|'('
name|'self'
op|','
name|'guest'
op|','
name|'image_meta'
op|','
name|'img_meta_prop'
op|','
name|'flavor'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'VALID_VIDEO_DEVICES'
op|'='
op|'('
string|'"vga"'
op|','
string|'"cirrus"'
op|','
string|'"vmvga"'
op|','
string|'"xen"'
op|','
string|'"qxl"'
op|')'
newline|'\n'
name|'video'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestVideo'
op|'('
op|')'
newline|'\n'
comment|'# NOTE(ldbragst): The following logic sets the video.type'
nl|'\n'
comment|'# depending on supported defaults given the architecture,'
nl|'\n'
comment|'# virtualization type, and features. The video.type attribute can'
nl|'\n'
comment|"# be overridden by the user with image_meta['properties'], which"
nl|'\n'
comment|'# is carried out in the next if statement below this one.'
nl|'\n'
name|'guestarch'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_arch'
op|'('
name|'image_meta'
op|')'
newline|'\n'
name|'if'
name|'guest'
op|'.'
name|'os_type'
op|'=='
name|'vm_mode'
op|'.'
name|'XEN'
op|':'
newline|'\n'
indent|'            '
name|'video'
op|'.'
name|'type'
op|'='
string|"'xen'"
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'parallels'"
op|':'
newline|'\n'
indent|'            '
name|'video'
op|'.'
name|'type'
op|'='
string|"'vga'"
newline|'\n'
dedent|''
name|'elif'
name|'guestarch'
name|'in'
op|'('
name|'arch'
op|'.'
name|'PPC'
op|','
name|'arch'
op|'.'
name|'PPC64'
op|')'
op|':'
newline|'\n'
comment|"# NOTE(ldbragst): PowerKVM doesn't support 'cirrus' be default"
nl|'\n'
comment|"# so use 'vga' instead when running on Power hardware."
nl|'\n'
indent|'            '
name|'video'
op|'.'
name|'type'
op|'='
string|"'vga'"
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'enabled'
op|':'
newline|'\n'
indent|'            '
name|'video'
op|'.'
name|'type'
op|'='
string|"'qxl'"
newline|'\n'
dedent|''
name|'if'
name|'img_meta_prop'
op|'.'
name|'get'
op|'('
string|"'hw_video_model'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'video'
op|'.'
name|'type'
op|'='
name|'img_meta_prop'
op|'.'
name|'get'
op|'('
string|"'hw_video_model'"
op|')'
newline|'\n'
name|'if'
op|'('
name|'video'
op|'.'
name|'type'
name|'not'
name|'in'
name|'VALID_VIDEO_DEVICES'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'InvalidVideoMode'
op|'('
name|'model'
op|'='
name|'video'
op|'.'
name|'type'
op|')'
newline|'\n'
nl|'\n'
comment|"# Set video memory, only if the flavor's limit is set"
nl|'\n'
dedent|''
dedent|''
name|'video_ram'
op|'='
name|'int'
op|'('
name|'img_meta_prop'
op|'.'
name|'get'
op|'('
string|"'hw_video_ram'"
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'max_vram'
op|'='
name|'int'
op|'('
name|'flavor'
op|'.'
name|'extra_specs'
op|'.'
name|'get'
op|'('
string|"'hw_video:ram_max_mb'"
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'if'
name|'video_ram'
op|'>'
name|'max_vram'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'RequestedVRamTooHigh'
op|'('
name|'req_vram'
op|'='
name|'video_ram'
op|','
nl|'\n'
name|'max_vram'
op|'='
name|'max_vram'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'max_vram'
name|'and'
name|'video_ram'
op|':'
newline|'\n'
indent|'            '
name|'video'
op|'.'
name|'vram'
op|'='
name|'video_ram'
op|'*'
name|'units'
op|'.'
name|'Mi'
op|'/'
name|'units'
op|'.'
name|'Ki'
newline|'\n'
dedent|''
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'video'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_add_qga_device
dedent|''
name|'def'
name|'_add_qga_device'
op|'('
name|'self'
op|','
name|'guest'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'qga'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestChannel'
op|'('
op|')'
newline|'\n'
name|'qga'
op|'.'
name|'type'
op|'='
string|'"unix"'
newline|'\n'
name|'qga'
op|'.'
name|'target_name'
op|'='
string|'"org.qemu.guest_agent.0"'
newline|'\n'
name|'qga'
op|'.'
name|'source_path'
op|'='
op|'('
string|'"/var/lib/libvirt/qemu/%s.%s.sock"'
op|'%'
nl|'\n'
op|'('
string|'"org.qemu.guest_agent.0"'
op|','
name|'instance'
op|'.'
name|'name'
op|')'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'qga'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_add_rng_device
dedent|''
name|'def'
name|'_add_rng_device'
op|'('
name|'self'
op|','
name|'guest'
op|','
name|'flavor'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'rng_device'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestRng'
op|'('
op|')'
newline|'\n'
name|'rate_bytes'
op|'='
name|'flavor'
op|'.'
name|'extra_specs'
op|'.'
name|'get'
op|'('
string|"'hw_rng:rate_bytes'"
op|','
number|'0'
op|')'
newline|'\n'
name|'period'
op|'='
name|'flavor'
op|'.'
name|'extra_specs'
op|'.'
name|'get'
op|'('
string|"'hw_rng:rate_period'"
op|','
number|'0'
op|')'
newline|'\n'
name|'if'
name|'rate_bytes'
op|':'
newline|'\n'
indent|'            '
name|'rng_device'
op|'.'
name|'rate_bytes'
op|'='
name|'int'
op|'('
name|'rate_bytes'
op|')'
newline|'\n'
name|'rng_device'
op|'.'
name|'rate_period'
op|'='
name|'int'
op|'('
name|'period'
op|')'
newline|'\n'
dedent|''
name|'rng_path'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'rng_dev_path'
newline|'\n'
name|'if'
op|'('
name|'rng_path'
name|'and'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'rng_path'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'RngDeviceNotExist'
op|'('
name|'path'
op|'='
name|'rng_path'
op|')'
newline|'\n'
dedent|''
name|'rng_device'
op|'.'
name|'backend'
op|'='
name|'rng_path'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'rng_device'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_set_qemu_guest_agent
dedent|''
name|'def'
name|'_set_qemu_guest_agent'
op|'('
name|'self'
op|','
name|'guest'
op|','
name|'flavor'
op|','
name|'instance'
op|','
name|'img_meta_prop'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'qga_enabled'
op|'='
name|'False'
newline|'\n'
comment|"# Enable qga only if the 'hw_qemu_guest_agent' is equal to yes"
nl|'\n'
name|'hw_qga'
op|'='
name|'img_meta_prop'
op|'.'
name|'get'
op|'('
string|"'hw_qemu_guest_agent'"
op|','
string|"''"
op|')'
newline|'\n'
name|'if'
name|'strutils'
op|'.'
name|'bool_from_string'
op|'('
name|'hw_qga'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Qemu guest agent is enabled through image "'
nl|'\n'
string|'"metadata"'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'qga_enabled'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'if'
name|'qga_enabled'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_add_qga_device'
op|'('
name|'guest'
op|','
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'rng_is_virtio'
op|'='
name|'img_meta_prop'
op|'.'
name|'get'
op|'('
string|"'hw_rng_model'"
op|')'
op|'=='
string|"'virtio'"
newline|'\n'
name|'rng_allowed_str'
op|'='
name|'flavor'
op|'.'
name|'extra_specs'
op|'.'
name|'get'
op|'('
string|"'hw_rng:allowed'"
op|','
string|"''"
op|')'
newline|'\n'
name|'rng_allowed'
op|'='
name|'strutils'
op|'.'
name|'bool_from_string'
op|'('
name|'rng_allowed_str'
op|')'
newline|'\n'
name|'if'
name|'rng_is_virtio'
name|'and'
name|'rng_allowed'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_add_rng_device'
op|'('
name|'guest'
op|','
name|'flavor'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_memory_backing_config
dedent|''
dedent|''
name|'def'
name|'_get_guest_memory_backing_config'
op|'('
name|'self'
op|','
name|'inst_topology'
op|','
name|'numatune'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'wantsmempages'
op|'='
name|'False'
newline|'\n'
name|'if'
name|'inst_topology'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'cell'
name|'in'
name|'inst_topology'
op|'.'
name|'cells'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'cell'
op|'.'
name|'pagesize'
op|':'
newline|'\n'
indent|'                    '
name|'wantsmempages'
op|'='
name|'True'
newline|'\n'
name|'break'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'not'
name|'wantsmempages'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'_has_hugepage_support'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# We should not get here, since we should have avoided'
nl|'\n'
comment|'# reporting NUMA topology from _get_host_numa_topology'
nl|'\n'
comment|'# in the first place. Just in case of a scheduler'
nl|'\n'
comment|'# mess up though, raise an exception'
nl|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'MemoryPagesUnsupported'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'host_topology'
op|'='
name|'self'
op|'.'
name|'_get_host_numa_topology'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'host_topology'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|'# As above, we should not get here but just in case...'
nl|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'MemoryPagesUnsupported'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Currently libvirt does not support the smallest'
nl|'\n'
comment|'# pagesize set as a backend memory.'
nl|'\n'
comment|'# https://bugzilla.redhat.com/show_bug.cgi?id=1173507'
nl|'\n'
dedent|''
name|'avail_pagesize'
op|'='
op|'['
name|'page'
op|'.'
name|'size_kb'
nl|'\n'
name|'for'
name|'page'
name|'in'
name|'host_topology'
op|'.'
name|'cells'
op|'['
number|'0'
op|']'
op|'.'
name|'mempages'
op|']'
newline|'\n'
name|'avail_pagesize'
op|'.'
name|'sort'
op|'('
op|')'
newline|'\n'
name|'smallest'
op|'='
name|'avail_pagesize'
op|'['
number|'0'
op|']'
newline|'\n'
nl|'\n'
name|'pages'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'guest_cellid'
op|','
name|'inst_cell'
name|'in'
name|'enumerate'
op|'('
name|'inst_topology'
op|'.'
name|'cells'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'inst_cell'
op|'.'
name|'pagesize'
name|'and'
name|'inst_cell'
op|'.'
name|'pagesize'
op|'>'
name|'smallest'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'memnode'
name|'in'
name|'numatune'
op|'.'
name|'memnodes'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'guest_cellid'
op|'=='
name|'memnode'
op|'.'
name|'cellid'
op|':'
newline|'\n'
indent|'                        '
name|'page'
op|'='
op|'('
nl|'\n'
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestMemoryBackingPage'
op|'('
op|')'
op|')'
newline|'\n'
name|'page'
op|'.'
name|'nodeset'
op|'='
op|'['
name|'guest_cellid'
op|']'
newline|'\n'
name|'page'
op|'.'
name|'size_kb'
op|'='
name|'inst_cell'
op|'.'
name|'pagesize'
newline|'\n'
name|'pages'
op|'.'
name|'append'
op|'('
name|'page'
op|')'
newline|'\n'
name|'break'
comment|'# Quit early...'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'if'
name|'pages'
op|':'
newline|'\n'
indent|'            '
name|'membacking'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestMemoryBacking'
op|'('
op|')'
newline|'\n'
name|'membacking'
op|'.'
name|'hugepages'
op|'='
name|'pages'
newline|'\n'
name|'return'
name|'membacking'
newline|'\n'
nl|'\n'
DECL|member|_get_flavor
dedent|''
dedent|''
name|'def'
name|'_get_flavor'
op|'('
name|'self'
op|','
name|'ctxt'
op|','
name|'instance'
op|','
name|'flavor'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'flavor'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'flavor'
newline|'\n'
dedent|''
name|'return'
name|'instance'
op|'.'
name|'flavor'
newline|'\n'
nl|'\n'
DECL|member|_configure_guest_by_virt_type
dedent|''
name|'def'
name|'_configure_guest_by_virt_type'
op|'('
name|'self'
op|','
name|'guest'
op|','
name|'virt_type'
op|','
name|'caps'
op|','
name|'instance'
op|','
nl|'\n'
name|'image_meta'
op|','
name|'flavor'
op|','
name|'root_device_name'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'virt_type'
op|'=='
string|'"xen"'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'guest'
op|'.'
name|'os_type'
op|'=='
name|'vm_mode'
op|'.'
name|'HVM'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_loader'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'xen_hvmloader_path'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'virt_type'
name|'in'
op|'('
string|'"kvm"'
op|','
string|'"qemu"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'arch'
name|'in'
op|'('
name|'arch'
op|'.'
name|'I686'
op|','
name|'arch'
op|'.'
name|'X86_64'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'sysinfo'
op|'='
name|'self'
op|'.'
name|'_get_guest_config_sysinfo'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'os_smbios'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSMBIOS'
op|'('
op|')'
newline|'\n'
dedent|''
name|'guest'
op|'.'
name|'os_mach_type'
op|'='
name|'self'
op|'.'
name|'_get_machine_type'
op|'('
name|'image_meta'
op|','
name|'caps'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'os_bootmenu'
op|'='
name|'strutils'
op|'.'
name|'bool_from_string'
op|'('
nl|'\n'
name|'flavor'
op|'.'
name|'extra_specs'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'hw:boot_menu'"
op|','
name|'image_meta'
op|'.'
name|'get'
op|'('
string|"'properties'"
op|','
op|'{'
op|'}'
op|')'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'hw_boot_menu'"
op|','
string|"'no'"
op|')'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'virt_type'
op|'=='
string|'"lxc"'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'os_init_path'
op|'='
string|'"/sbin/init"'
newline|'\n'
name|'guest'
op|'.'
name|'os_cmdline'
op|'='
name|'CONSOLE'
newline|'\n'
dedent|''
name|'elif'
name|'virt_type'
op|'=='
string|'"uml"'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'os_kernel'
op|'='
string|'"/usr/bin/linux"'
newline|'\n'
name|'guest'
op|'.'
name|'os_root'
op|'='
name|'root_device_name'
newline|'\n'
dedent|''
name|'elif'
name|'virt_type'
op|'=='
string|'"parallels"'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'guest'
op|'.'
name|'os_type'
op|'=='
name|'vm_mode'
op|'.'
name|'EXE'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_init_path'
op|'='
string|'"/sbin/init"'
newline|'\n'
nl|'\n'
DECL|member|_conf_non_lxc_uml
dedent|''
dedent|''
dedent|''
name|'def'
name|'_conf_non_lxc_uml'
op|'('
name|'self'
op|','
name|'virt_type'
op|','
name|'guest'
op|','
name|'root_device_name'
op|','
name|'rescue'
op|','
nl|'\n'
name|'instance'
op|','
name|'inst_path'
op|','
name|'image_meta'
op|','
name|'disk_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'rescue'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_set_guest_for_rescue'
op|'('
name|'rescue'
op|','
name|'guest'
op|','
name|'inst_path'
op|','
name|'virt_type'
op|','
nl|'\n'
name|'root_device_name'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'instance'
op|'.'
name|'kernel_id'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_set_guest_for_inst_kernel'
op|'('
name|'instance'
op|','
name|'guest'
op|','
name|'inst_path'
op|','
nl|'\n'
name|'virt_type'
op|','
name|'root_device_name'
op|','
nl|'\n'
name|'image_meta'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'os_boot_dev'
op|'='
name|'blockinfo'
op|'.'
name|'get_boot_order'
op|'('
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_create_consoles
dedent|''
dedent|''
name|'def'
name|'_create_consoles'
op|'('
name|'self'
op|','
name|'virt_type'
op|','
name|'guest'
op|','
name|'instance'
op|','
name|'flavor'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'caps'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'virt_type'
name|'in'
op|'('
string|'"qemu"'
op|','
string|'"kvm"'
op|')'
op|':'
newline|'\n'
comment|'# Create the serial console char devices'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_create_serial_console_devices'
op|'('
name|'guest'
op|','
name|'instance'
op|','
name|'flavor'
op|','
nl|'\n'
name|'image_meta'
op|')'
newline|'\n'
name|'if'
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'arch'
name|'in'
op|'('
name|'arch'
op|'.'
name|'S390'
op|','
name|'arch'
op|'.'
name|'S390X'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'consolepty'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestConsole'
op|'('
op|')'
newline|'\n'
name|'consolepty'
op|'.'
name|'target_type'
op|'='
string|'"sclp"'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'consolepty'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSerial'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'consolepty'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestConsole'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'consolepty'
newline|'\n'
nl|'\n'
DECL|member|_cpu_config_to_vcpu_model
dedent|''
name|'def'
name|'_cpu_config_to_vcpu_model'
op|'('
name|'self'
op|','
name|'cpu_config'
op|','
name|'vcpu_model'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Update VirtCPUModel object according to libvirt CPU config.\n\n        :param:cpu_config: vconfig.LibvirtConfigGuestCPU presenting the\n                           instance\'s virtual cpu configuration.\n        :param:vcpu_model: VirtCPUModel object. A new object will be created\n                           if None.\n\n        :return: Updated VirtCPUModel object, or None if cpu_config is None\n\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'cpu_config'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'vcpu_model'
op|':'
newline|'\n'
indent|'            '
name|'vcpu_model'
op|'='
name|'objects'
op|'.'
name|'VirtCPUModel'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'vcpu_model'
op|'.'
name|'arch'
op|'='
name|'cpu_config'
op|'.'
name|'arch'
newline|'\n'
name|'vcpu_model'
op|'.'
name|'vendor'
op|'='
name|'cpu_config'
op|'.'
name|'vendor'
newline|'\n'
name|'vcpu_model'
op|'.'
name|'model'
op|'='
name|'cpu_config'
op|'.'
name|'model'
newline|'\n'
name|'vcpu_model'
op|'.'
name|'mode'
op|'='
name|'cpu_config'
op|'.'
name|'mode'
newline|'\n'
name|'vcpu_model'
op|'.'
name|'match'
op|'='
name|'cpu_config'
op|'.'
name|'match'
newline|'\n'
nl|'\n'
name|'if'
name|'cpu_config'
op|'.'
name|'sockets'
op|':'
newline|'\n'
indent|'            '
name|'vcpu_model'
op|'.'
name|'topology'
op|'='
name|'objects'
op|'.'
name|'VirtCPUTopology'
op|'('
nl|'\n'
name|'sockets'
op|'='
name|'cpu_config'
op|'.'
name|'sockets'
op|','
nl|'\n'
name|'cores'
op|'='
name|'cpu_config'
op|'.'
name|'cores'
op|','
nl|'\n'
name|'threads'
op|'='
name|'cpu_config'
op|'.'
name|'threads'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'vcpu_model'
op|'.'
name|'topology'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'features'
op|'='
op|'['
name|'objects'
op|'.'
name|'VirtCPUFeature'
op|'('
nl|'\n'
name|'name'
op|'='
name|'f'
op|'.'
name|'name'
op|','
nl|'\n'
name|'policy'
op|'='
name|'f'
op|'.'
name|'policy'
op|')'
name|'for'
name|'f'
name|'in'
name|'cpu_config'
op|'.'
name|'features'
op|']'
newline|'\n'
name|'vcpu_model'
op|'.'
name|'features'
op|'='
name|'features'
newline|'\n'
nl|'\n'
name|'return'
name|'vcpu_model'
newline|'\n'
nl|'\n'
DECL|member|_vcpu_model_to_cpu_config
dedent|''
name|'def'
name|'_vcpu_model_to_cpu_config'
op|'('
name|'self'
op|','
name|'vcpu_model'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create libvirt CPU config according to VirtCPUModel object.\n\n        :param:vcpu_model: VirtCPUModel object.\n\n        :return: vconfig.LibvirtConfigGuestCPU.\n\n        """'
newline|'\n'
nl|'\n'
name|'cpu_config'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPU'
op|'('
op|')'
newline|'\n'
name|'cpu_config'
op|'.'
name|'arch'
op|'='
name|'vcpu_model'
op|'.'
name|'arch'
newline|'\n'
name|'cpu_config'
op|'.'
name|'model'
op|'='
name|'vcpu_model'
op|'.'
name|'model'
newline|'\n'
name|'cpu_config'
op|'.'
name|'mode'
op|'='
name|'vcpu_model'
op|'.'
name|'mode'
newline|'\n'
name|'cpu_config'
op|'.'
name|'match'
op|'='
name|'vcpu_model'
op|'.'
name|'match'
newline|'\n'
name|'cpu_config'
op|'.'
name|'vendor'
op|'='
name|'vcpu_model'
op|'.'
name|'vendor'
newline|'\n'
name|'if'
name|'vcpu_model'
op|'.'
name|'topology'
op|':'
newline|'\n'
indent|'            '
name|'cpu_config'
op|'.'
name|'sockets'
op|'='
name|'vcpu_model'
op|'.'
name|'topology'
op|'.'
name|'sockets'
newline|'\n'
name|'cpu_config'
op|'.'
name|'cores'
op|'='
name|'vcpu_model'
op|'.'
name|'topology'
op|'.'
name|'cores'
newline|'\n'
name|'cpu_config'
op|'.'
name|'threads'
op|'='
name|'vcpu_model'
op|'.'
name|'topology'
op|'.'
name|'threads'
newline|'\n'
dedent|''
name|'if'
name|'vcpu_model'
op|'.'
name|'features'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'f'
name|'in'
name|'vcpu_model'
op|'.'
name|'features'
op|':'
newline|'\n'
indent|'                '
name|'xf'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPUFeature'
op|'('
op|')'
newline|'\n'
name|'xf'
op|'.'
name|'name'
op|'='
name|'f'
op|'.'
name|'name'
newline|'\n'
name|'xf'
op|'.'
name|'policy'
op|'='
name|'f'
op|'.'
name|'policy'
newline|'\n'
name|'cpu_config'
op|'.'
name|'features'
op|'.'
name|'add'
op|'('
name|'xf'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'cpu_config'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_config
dedent|''
name|'def'
name|'_get_guest_config'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'disk_info'
op|','
name|'rescue'
op|'='
name|'None'
op|','
name|'block_device_info'
op|'='
name|'None'
op|','
nl|'\n'
name|'context'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get config data for parameters.\n\n        :param rescue: optional dictionary that should contain the key\n            \'ramdisk_id\' if a ramdisk is needed for the rescue image and\n            \'kernel_id\' if a kernel is needed for the rescue image.\n        """'
newline|'\n'
name|'flavor'
op|'='
name|'instance'
op|'.'
name|'flavor'
newline|'\n'
name|'inst_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'disk_mapping'
op|'='
name|'disk_info'
op|'['
string|"'mapping'"
op|']'
newline|'\n'
name|'img_meta_prop'
op|'='
name|'image_meta'
op|'.'
name|'get'
op|'('
string|"'properties'"
op|','
op|'{'
op|'}'
op|')'
name|'if'
name|'image_meta'
name|'else'
op|'{'
op|'}'
newline|'\n'
nl|'\n'
name|'virt_type'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
newline|'\n'
name|'guest'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuest'
op|'('
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'virt_type'
op|'='
name|'virt_type'
newline|'\n'
name|'guest'
op|'.'
name|'name'
op|'='
name|'instance'
op|'.'
name|'name'
newline|'\n'
name|'guest'
op|'.'
name|'uuid'
op|'='
name|'instance'
op|'.'
name|'uuid'
newline|'\n'
comment|'# We are using default unit for memory: KiB'
nl|'\n'
name|'guest'
op|'.'
name|'memory'
op|'='
name|'flavor'
op|'.'
name|'memory_mb'
op|'*'
name|'units'
op|'.'
name|'Ki'
newline|'\n'
name|'guest'
op|'.'
name|'vcpus'
op|'='
name|'flavor'
op|'.'
name|'vcpus'
newline|'\n'
name|'allowed_cpus'
op|'='
name|'hardware'
op|'.'
name|'get_vcpu_pin_set'
op|'('
op|')'
newline|'\n'
name|'pci_devs'
op|'='
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|','
string|"'all'"
op|')'
newline|'\n'
nl|'\n'
name|'guest_numa_config'
op|'='
name|'self'
op|'.'
name|'_get_guest_numa_config'
op|'('
nl|'\n'
name|'instance'
op|'.'
name|'numa_topology'
op|','
name|'flavor'
op|','
name|'pci_devs'
op|','
name|'allowed_cpus'
op|')'
newline|'\n'
nl|'\n'
name|'guest'
op|'.'
name|'cpuset'
op|'='
name|'guest_numa_config'
op|'.'
name|'cpuset'
newline|'\n'
name|'guest'
op|'.'
name|'cputune'
op|'='
name|'guest_numa_config'
op|'.'
name|'cputune'
newline|'\n'
name|'guest'
op|'.'
name|'numatune'
op|'='
name|'guest_numa_config'
op|'.'
name|'numatune'
newline|'\n'
nl|'\n'
name|'guest'
op|'.'
name|'membacking'
op|'='
name|'self'
op|'.'
name|'_get_guest_memory_backing_config'
op|'('
nl|'\n'
name|'instance'
op|'.'
name|'numa_topology'
op|','
name|'guest_numa_config'
op|'.'
name|'numatune'
op|')'
newline|'\n'
nl|'\n'
name|'guest'
op|'.'
name|'metadata'
op|'.'
name|'append'
op|'('
name|'self'
op|'.'
name|'_get_guest_config_meta'
op|'('
name|'context'
op|','
nl|'\n'
name|'instance'
op|')'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'idmaps'
op|'='
name|'self'
op|'.'
name|'_get_guest_idmaps'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_update_guest_cputune'
op|'('
name|'guest'
op|','
name|'flavor'
op|','
name|'virt_type'
op|')'
newline|'\n'
nl|'\n'
name|'guest'
op|'.'
name|'cpu'
op|'='
name|'self'
op|'.'
name|'_get_guest_cpu_config'
op|'('
nl|'\n'
name|'flavor'
op|','
name|'image_meta'
op|','
name|'guest_numa_config'
op|'.'
name|'numaconfig'
op|','
nl|'\n'
name|'instance'
op|'.'
name|'numa_topology'
op|')'
newline|'\n'
nl|'\n'
comment|"# Notes(yjiang5): we always sync the instance's vcpu model with"
nl|'\n'
comment|'# the corresponding config file.'
nl|'\n'
name|'instance'
op|'.'
name|'vcpu_model'
op|'='
name|'self'
op|'.'
name|'_cpu_config_to_vcpu_model'
op|'('
nl|'\n'
name|'guest'
op|'.'
name|'cpu'
op|','
name|'instance'
op|'.'
name|'vcpu_model'
op|')'
newline|'\n'
nl|'\n'
name|'if'
string|"'root'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'            '
name|'root_device_name'
op|'='
name|'block_device'
op|'.'
name|'prepend_dev'
op|'('
nl|'\n'
name|'disk_mapping'
op|'['
string|"'root'"
op|']'
op|'['
string|"'dev'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'root_device_name'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'root_device_name'
op|':'
newline|'\n'
comment|'# NOTE(yamahata):'
nl|'\n'
comment|'# for nova.api.ec2.cloud.CloudController.get_metadata()'
nl|'\n'
indent|'            '
name|'instance'
op|'.'
name|'root_device_name'
op|'='
name|'root_device_name'
newline|'\n'
nl|'\n'
dedent|''
name|'guest'
op|'.'
name|'os_type'
op|'='
op|'('
name|'vm_mode'
op|'.'
name|'get_from_instance'
op|'('
name|'instance'
op|')'
name|'or'
nl|'\n'
name|'self'
op|'.'
name|'_get_guest_os_type'
op|'('
name|'virt_type'
op|')'
op|')'
newline|'\n'
name|'caps'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_capabilities'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_configure_guest_by_virt_type'
op|'('
name|'guest'
op|','
name|'virt_type'
op|','
name|'caps'
op|','
name|'instance'
op|','
nl|'\n'
name|'image_meta'
op|','
name|'flavor'
op|','
nl|'\n'
name|'root_device_name'
op|')'
newline|'\n'
name|'if'
name|'virt_type'
name|'not'
name|'in'
op|'('
string|"'lxc'"
op|','
string|"'uml'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_conf_non_lxc_uml'
op|'('
name|'virt_type'
op|','
name|'guest'
op|','
name|'root_device_name'
op|','
name|'rescue'
op|','
nl|'\n'
name|'instance'
op|','
name|'inst_path'
op|','
name|'image_meta'
op|','
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_set_features'
op|'('
name|'guest'
op|','
name|'instance'
op|'.'
name|'os_type'
op|','
name|'caps'
op|','
name|'virt_type'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_set_clock'
op|'('
name|'guest'
op|','
name|'instance'
op|'.'
name|'os_type'
op|','
name|'image_meta'
op|','
name|'virt_type'
op|')'
newline|'\n'
nl|'\n'
name|'storage_configs'
op|'='
name|'self'
op|'.'
name|'_get_guest_storage_config'
op|'('
nl|'\n'
name|'instance'
op|','
name|'image_meta'
op|','
name|'disk_info'
op|','
name|'rescue'
op|','
name|'block_device_info'
op|','
nl|'\n'
name|'flavor'
op|','
name|'guest'
op|'.'
name|'os_type'
op|')'
newline|'\n'
name|'for'
name|'config'
name|'in'
name|'storage_configs'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'config'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
indent|'            '
name|'config'
op|'='
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'get_config'
op|'('
nl|'\n'
name|'instance'
op|','
name|'vif'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'flavor'
op|','
name|'virt_type'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'config'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'consolepty'
op|'='
name|'self'
op|'.'
name|'_create_consoles'
op|'('
name|'virt_type'
op|','
name|'guest'
op|','
name|'instance'
op|','
name|'flavor'
op|','
nl|'\n'
name|'image_meta'
op|','
name|'caps'
op|')'
newline|'\n'
name|'if'
name|'virt_type'
op|'!='
string|"'parallels'"
op|':'
newline|'\n'
indent|'            '
name|'consolepty'
op|'.'
name|'type'
op|'='
string|'"pty"'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'consolepty'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'tablet'
op|'='
name|'self'
op|'.'
name|'_get_guest_usb_tablet'
op|'('
name|'guest'
op|'.'
name|'os_type'
op|')'
newline|'\n'
name|'if'
name|'tablet'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'tablet'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'enabled'
name|'and'
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'agent_enabled'
name|'and'
nl|'\n'
name|'virt_type'
name|'not'
name|'in'
op|'('
string|"'lxc'"
op|','
string|"'uml'"
op|','
string|"'xen'"
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'channel'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestChannel'
op|'('
op|')'
newline|'\n'
name|'channel'
op|'.'
name|'target_name'
op|'='
string|'"com.redhat.spice.0"'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'channel'
op|')'
newline|'\n'
nl|'\n'
comment|'# NB some versions of libvirt support both SPICE and VNC'
nl|'\n'
comment|"# at the same time. We're not trying to second guess which"
nl|'\n'
comment|"# those versions are. We'll just let libvirt report the"
nl|'\n'
comment|'# errors appropriately if the user enables both.'
nl|'\n'
dedent|''
name|'add_video_driver'
op|'='
name|'False'
newline|'\n'
name|'if'
op|'('
op|'('
name|'CONF'
op|'.'
name|'vnc'
op|'.'
name|'enabled'
name|'and'
nl|'\n'
name|'virt_type'
name|'not'
name|'in'
op|'('
string|"'lxc'"
op|','
string|"'uml'"
op|')'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'graphics'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestGraphics'
op|'('
op|')'
newline|'\n'
name|'graphics'
op|'.'
name|'type'
op|'='
string|'"vnc"'
newline|'\n'
name|'graphics'
op|'.'
name|'keymap'
op|'='
name|'CONF'
op|'.'
name|'vnc'
op|'.'
name|'keymap'
newline|'\n'
name|'graphics'
op|'.'
name|'listen'
op|'='
name|'CONF'
op|'.'
name|'vnc'
op|'.'
name|'vncserver_listen'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'graphics'
op|')'
newline|'\n'
name|'add_video_driver'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'enabled'
name|'and'
nl|'\n'
name|'virt_type'
name|'not'
name|'in'
op|'('
string|"'lxc'"
op|','
string|"'uml'"
op|','
string|"'xen'"
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'graphics'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestGraphics'
op|'('
op|')'
newline|'\n'
name|'graphics'
op|'.'
name|'type'
op|'='
string|'"spice"'
newline|'\n'
name|'graphics'
op|'.'
name|'keymap'
op|'='
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'keymap'
newline|'\n'
name|'graphics'
op|'.'
name|'listen'
op|'='
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'server_listen'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'graphics'
op|')'
newline|'\n'
name|'add_video_driver'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'add_video_driver'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_add_video_driver'
op|'('
name|'guest'
op|','
name|'image_meta'
op|','
name|'img_meta_prop'
op|','
name|'flavor'
op|')'
newline|'\n'
nl|'\n'
comment|"# Qemu guest agent only support 'qemu' and 'kvm' hypervisor"
nl|'\n'
dedent|''
name|'if'
name|'virt_type'
name|'in'
op|'('
string|"'qemu'"
op|','
string|"'kvm'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_set_qemu_guest_agent'
op|'('
name|'guest'
op|','
name|'flavor'
op|','
name|'instance'
op|','
name|'img_meta_prop'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'virt_type'
name|'in'
op|'('
string|"'xen'"
op|','
string|"'qemu'"
op|','
string|"'kvm'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'pci_dev'
name|'in'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'self'
op|'.'
name|'_get_guest_pci_device'
op|'('
name|'pci_dev'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'len'
op|'('
name|'pci_devs'
op|')'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'PciDeviceUnsupportedHypervisor'
op|'('
nl|'\n'
name|'type'
op|'='
name|'virt_type'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
string|"'hw_watchdog_action'"
name|'in'
name|'flavor'
op|'.'
name|'extra_specs'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'\'Old property name "hw_watchdog_action" is now \''
nl|'\n'
string|"'deprecated and will be removed in the next release. '"
nl|'\n'
string|"'Use updated property name '"
nl|'\n'
string|'\'"hw:watchdog_action" instead\''
op|')'
op|')'
newline|'\n'
comment|"# TODO(pkholkin): accepting old property name 'hw_watchdog_action'"
nl|'\n'
comment|'#                should be removed in the next release'
nl|'\n'
dedent|''
name|'watchdog_action'
op|'='
op|'('
name|'flavor'
op|'.'
name|'extra_specs'
op|'.'
name|'get'
op|'('
string|"'hw_watchdog_action'"
op|')'
name|'or'
nl|'\n'
name|'flavor'
op|'.'
name|'extra_specs'
op|'.'
name|'get'
op|'('
string|"'hw:watchdog_action'"
op|')'
nl|'\n'
name|'or'
string|"'disabled'"
op|')'
newline|'\n'
name|'if'
op|'('
name|'image_meta'
name|'is'
name|'not'
name|'None'
name|'and'
nl|'\n'
name|'image_meta'
op|'.'
name|'get'
op|'('
string|"'properties'"
op|','
op|'{'
op|'}'
op|')'
op|'.'
name|'get'
op|'('
string|"'hw_watchdog_action'"
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'watchdog_action'
op|'='
name|'image_meta'
op|'['
string|"'properties'"
op|']'
op|'['
string|"'hw_watchdog_action'"
op|']'
newline|'\n'
nl|'\n'
comment|'# NB(sross): currently only actually supported by KVM/QEmu'
nl|'\n'
dedent|''
name|'if'
name|'watchdog_action'
op|'!='
string|"'disabled'"
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'watchdog_actions'
op|'.'
name|'is_valid_watchdog_action'
op|'('
name|'watchdog_action'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'bark'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestWatchdog'
op|'('
op|')'
newline|'\n'
name|'bark'
op|'.'
name|'action'
op|'='
name|'watchdog_action'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'bark'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'InvalidWatchdogAction'
op|'('
name|'action'
op|'='
name|'watchdog_action'
op|')'
newline|'\n'
nl|'\n'
comment|"# Memory balloon device only support 'qemu/kvm' and 'xen' hypervisor"
nl|'\n'
dedent|''
dedent|''
name|'if'
op|'('
name|'virt_type'
name|'in'
op|'('
string|"'xen'"
op|','
string|"'qemu'"
op|','
string|"'kvm'"
op|')'
name|'and'
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'mem_stats_period_seconds'
op|'>'
number|'0'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'balloon'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigMemoryBalloon'
op|'('
op|')'
newline|'\n'
name|'if'
name|'virt_type'
name|'in'
op|'('
string|"'qemu'"
op|','
string|"'kvm'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'balloon'
op|'.'
name|'model'
op|'='
string|"'virtio'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'balloon'
op|'.'
name|'model'
op|'='
string|"'xen'"
newline|'\n'
dedent|''
name|'balloon'
op|'.'
name|'period'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'mem_stats_period_seconds'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'balloon'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'guest'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_usb_tablet
dedent|''
name|'def'
name|'_get_guest_usb_tablet'
op|'('
name|'self'
op|','
name|'os_type'
op|')'
op|':'
newline|'\n'
comment|'# We want a tablet if VNC is enabled, or SPICE is enabled and'
nl|'\n'
comment|'# the SPICE agent is disabled. If the SPICE agent is enabled'
nl|'\n'
comment|'# it provides a paravirt mouse which drastically reduces'
nl|'\n'
comment|'# overhead (by eliminating USB polling).'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# NB: this implies that if both SPICE + VNC are enabled'
nl|'\n'
comment|"# at the same time, we'll get the tablet whether the"
nl|'\n'
comment|'# SPICE agent is used or not.'
nl|'\n'
indent|'        '
name|'need_usb_tablet'
op|'='
name|'False'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'vnc'
op|'.'
name|'enabled'
op|':'
newline|'\n'
indent|'            '
name|'need_usb_tablet'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'use_usb_tablet'
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'enabled'
name|'and'
name|'not'
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'agent_enabled'
op|':'
newline|'\n'
indent|'            '
name|'need_usb_tablet'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'use_usb_tablet'
newline|'\n'
nl|'\n'
dedent|''
name|'tablet'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'need_usb_tablet'
name|'and'
name|'os_type'
op|'=='
name|'vm_mode'
op|'.'
name|'HVM'
op|':'
newline|'\n'
indent|'            '
name|'tablet'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestInput'
op|'('
op|')'
newline|'\n'
name|'tablet'
op|'.'
name|'type'
op|'='
string|'"tablet"'
newline|'\n'
name|'tablet'
op|'.'
name|'bus'
op|'='
string|'"usb"'
newline|'\n'
dedent|''
name|'return'
name|'tablet'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_xml
dedent|''
name|'def'
name|'_get_guest_xml'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'image_meta'
op|','
name|'rescue'
op|'='
name|'None'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'write_to_disk'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(danms): Stringifying a NetworkInfo will take a lock. Do'
nl|'\n'
comment|"# this ahead of time so that we don't acquire it while also"
nl|'\n'
comment|'# holding the logging lock.'
nl|'\n'
indent|'        '
name|'network_info_str'
op|'='
name|'str'
op|'('
name|'network_info'
op|')'
newline|'\n'
name|'msg'
op|'='
op|'('
string|"'Start _get_guest_xml '"
nl|'\n'
string|"'network_info=%(network_info)s '"
nl|'\n'
string|"'disk_info=%(disk_info)s '"
nl|'\n'
string|"'image_meta=%(image_meta)s rescue=%(rescue)s '"
nl|'\n'
string|"'block_device_info=%(block_device_info)s'"
op|'%'
nl|'\n'
op|'{'
string|"'network_info'"
op|':'
name|'network_info_str'
op|','
string|"'disk_info'"
op|':'
name|'disk_info'
op|','
nl|'\n'
string|"'image_meta'"
op|':'
name|'image_meta'
op|','
string|"'rescue'"
op|':'
name|'rescue'
op|','
nl|'\n'
string|"'block_device_info'"
op|':'
name|'block_device_info'
op|'}'
op|')'
newline|'\n'
comment|'# NOTE(mriedem): block_device_info can contain auth_password so we'
nl|'\n'
comment|'# need to sanitize the password in the message.'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'strutils'
op|'.'
name|'mask_password'
op|'('
name|'msg'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'conf'
op|'='
name|'self'
op|'.'
name|'_get_guest_config'
op|'('
name|'instance'
op|','
name|'network_info'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'disk_info'
op|','
name|'rescue'
op|','
name|'block_device_info'
op|','
nl|'\n'
name|'context'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'conf'
op|'.'
name|'to_xml'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'write_to_disk'
op|':'
newline|'\n'
indent|'            '
name|'instance_dir'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'xml_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
string|"'libvirt.xml'"
op|')'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'write_to_file'
op|'('
name|'xml_path'
op|','
name|'xml'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'End _get_guest_xml xml=%(xml)s'"
op|','
nl|'\n'
op|'{'
string|"'xml'"
op|':'
name|'xml'
op|'}'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'xml'
newline|'\n'
nl|'\n'
DECL|member|get_info
dedent|''
name|'def'
name|'get_info'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve information from libvirt for a specific instance name.\n\n        If a libvirt error is encountered during lookup, we might raise a\n        NotFound exception or Error exception depending on how severe the\n        libvirt error is.\n\n        """'
newline|'\n'
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(sahid): We are converting all calls from a'
nl|'\n'
comment|'# virDomain object to use nova.virt.libvirt.Guest.'
nl|'\n'
comment|'# We should be able to remove virt_dom at the end.'
nl|'\n'
name|'virt_dom'
op|'='
name|'guest'
op|'.'
name|'_domain'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'dom_info'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_domain_info'
op|'('
name|'virt_dom'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_DOMAIN'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|'('
name|'instance_id'
op|'='
name|'instance'
op|'.'
name|'name'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|"'Error from libvirt while getting domain info for '"
nl|'\n'
string|"'%(instance_name)s: [Error Code %(error_code)s] %(ex)s'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'instance_name'"
op|':'
name|'instance'
op|'.'
name|'name'
op|','
nl|'\n'
string|"'error_code'"
op|':'
name|'error_code'
op|','
nl|'\n'
string|"'ex'"
op|':'
name|'ex'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'hardware'
op|'.'
name|'InstanceInfo'
op|'('
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'dom_info'
op|'['
number|'0'
op|']'
op|']'
op|','
nl|'\n'
name|'max_mem_kb'
op|'='
name|'dom_info'
op|'['
number|'1'
op|']'
op|','
nl|'\n'
name|'mem_kb'
op|'='
name|'dom_info'
op|'['
number|'2'
op|']'
op|','
nl|'\n'
name|'num_cpu'
op|'='
name|'dom_info'
op|'['
number|'3'
op|']'
op|','
nl|'\n'
name|'cpu_time_ns'
op|'='
name|'dom_info'
op|'['
number|'4'
op|']'
op|','
nl|'\n'
name|'id'
op|'='
name|'virt_dom'
op|'.'
name|'ID'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_create_domain_setup_lxc
dedent|''
name|'def'
name|'_create_domain_setup_lxc'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'block_device_info'
op|','
name|'disk_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'inst_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'disk_info'
op|'='
name|'disk_info'
name|'or'
op|'{'
op|'}'
newline|'\n'
name|'disk_mapping'
op|'='
name|'disk_info'
op|'.'
name|'get'
op|'('
string|"'mapping'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_is_booted_from_volume'
op|'('
name|'instance'
op|','
name|'disk_mapping'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'root_disk'
op|'='
name|'block_device'
op|'.'
name|'get_root_bdm'
op|'('
name|'block_device_mapping'
op|')'
newline|'\n'
name|'disk_path'
op|'='
name|'root_disk'
op|'['
string|"'connection_info'"
op|']'
op|'['
string|"'data'"
op|']'
op|'['
string|"'device_path'"
op|']'
newline|'\n'
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_info_from_bdm'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
name|'image_meta'
op|','
name|'root_disk'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_connect_volume'
op|'('
name|'root_disk'
op|'['
string|"'connection_info'"
op|']'
op|','
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
comment|'# Get the system metadata from the instance'
nl|'\n'
name|'use_cow'
op|'='
name|'instance'
op|'.'
name|'system_metadata'
op|'['
string|"'image_disk_format'"
op|']'
op|'=='
string|"'qcow2'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'image'
op|'='
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'image'
op|'('
name|'instance'
op|','
string|"'disk'"
op|')'
newline|'\n'
name|'disk_path'
op|'='
name|'image'
op|'.'
name|'path'
newline|'\n'
name|'use_cow'
op|'='
name|'CONF'
op|'.'
name|'use_cow_images'
newline|'\n'
nl|'\n'
dedent|''
name|'container_dir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_path'
op|','
string|"'rootfs'"
op|')'
newline|'\n'
name|'fileutils'
op|'.'
name|'ensure_tree'
op|'('
name|'container_dir'
op|')'
newline|'\n'
name|'fmt'
op|'='
name|'imgmodel'
op|'.'
name|'FORMAT_RAW'
newline|'\n'
name|'if'
name|'use_cow'
op|':'
newline|'\n'
indent|'            '
name|'fmt'
op|'='
name|'imgmodel'
op|'.'
name|'FORMAT_QCOW2'
newline|'\n'
dedent|''
name|'image'
op|'='
name|'imgmodel'
op|'.'
name|'LocalFileImage'
op|'('
name|'disk_path'
op|','
name|'fmt'
op|')'
newline|'\n'
name|'rootfs_dev'
op|'='
name|'disk'
op|'.'
name|'setup_container'
op|'('
name|'image'
op|','
nl|'\n'
name|'container_dir'
op|'='
name|'container_dir'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# Save rootfs device to disconnect it when deleting the instance'
nl|'\n'
indent|'            '
name|'if'
name|'rootfs_dev'
op|':'
newline|'\n'
indent|'                '
name|'instance'
op|'.'
name|'system_metadata'
op|'['
string|"'rootfs_device_name'"
op|']'
op|'='
name|'rootfs_dev'
newline|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'uid_maps'
name|'or'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'gid_maps'
op|':'
newline|'\n'
indent|'                '
name|'id_maps'
op|'='
name|'self'
op|'.'
name|'_get_guest_idmaps'
op|'('
op|')'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'chown_for_id_maps'
op|'('
name|'container_dir'
op|','
name|'id_maps'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_create_domain_cleanup_lxc'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_create_domain_cleanup_lxc
dedent|''
dedent|''
dedent|''
name|'def'
name|'_create_domain_cleanup_lxc'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'inst_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'container_dir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_path'
op|','
string|"'rootfs'"
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'state'
op|'='
name|'self'
op|'.'
name|'get_info'
op|'('
name|'instance'
op|')'
op|'.'
name|'state'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
comment|'# The domain may not be present if the instance failed to start'
nl|'\n'
indent|'            '
name|'state'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
comment|'# NOTE(uni): Now the container is running with its own private'
nl|'\n'
comment|'# mount namespace and so there is no need to keep the container'
nl|'\n'
comment|'# rootfs mounted in the host namespace'
nl|'\n'
indent|'            '
name|'disk'
op|'.'
name|'clean_lxc_namespace'
op|'('
name|'container_dir'
op|'='
name|'container_dir'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'disk'
op|'.'
name|'teardown_container'
op|'('
name|'container_dir'
op|'='
name|'container_dir'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'contextlib'
op|'.'
name|'contextmanager'
newline|'\n'
DECL|member|_lxc_disk_handler
name|'def'
name|'_lxc_disk_handler'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'block_device_info'
op|','
name|'disk_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Context manager to handle the pre and post instance boot,\n           LXC specific disk operations.\n\n           An image or a volume path will be prepared and setup to be\n           used by the container, prior to starting it.\n           The disk will be disconnected and unmounted if a container has\n           failed to start.\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'!='
string|"'lxc'"
op|':'
newline|'\n'
indent|'            '
name|'yield'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_create_domain_setup_lxc'
op|'('
name|'instance'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'block_device_info'
op|','
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'yield'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_create_domain_cleanup_lxc'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(sahid): Consider renaming this to _create_guest.'
nl|'\n'
DECL|member|_create_domain
dedent|''
dedent|''
name|'def'
name|'_create_domain'
op|'('
name|'self'
op|','
name|'xml'
op|'='
name|'None'
op|','
name|'domain'
op|'='
name|'None'
op|','
nl|'\n'
name|'power_on'
op|'='
name|'True'
op|','
name|'pause'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a domain.\n\n        Either domain or xml must be passed in. If both are passed, then\n        the domain definition is overwritten from the xml.\n\n        :returns guest.Guest: Guest just created\n        """'
newline|'\n'
name|'if'
name|'xml'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'='
name|'libvirt_guest'
op|'.'
name|'Guest'
op|'.'
name|'create'
op|'('
name|'xml'
op|','
name|'self'
op|'.'
name|'_host'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'='
name|'libvirt_guest'
op|'.'
name|'Guest'
op|'('
name|'domain'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'power_on'
name|'or'
name|'pause'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'launch'
op|'('
name|'pause'
op|'='
name|'pause'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'utils'
op|'.'
name|'is_neutron'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'enable_hairpin'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'guest'
newline|'\n'
nl|'\n'
DECL|member|_neutron_failed_callback
dedent|''
name|'def'
name|'_neutron_failed_callback'
op|'('
name|'self'
op|','
name|'event_name'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'Neutron Reported failure on event '"
nl|'\n'
string|"'%(event)s for instance %(uuid)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'event'"
op|':'
name|'event_name'
op|','
string|"'uuid'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|'}'
op|')'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'vif_plugging_is_fatal'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'VirtualInterfaceCreateException'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_neutron_events
dedent|''
dedent|''
name|'def'
name|'_get_neutron_events'
op|'('
name|'self'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(danms): We need to collect any VIFs that are currently'
nl|'\n'
comment|'# down that we expect a down->up event for. Anything that is'
nl|'\n'
comment|'# already up will not undergo that transition, and for'
nl|'\n'
comment|"# anything that might be stale (cache-wise) assume it's"
nl|'\n'
comment|"# already up so we don't block on it."
nl|'\n'
indent|'        '
name|'return'
op|'['
op|'('
string|"'network-vif-plugged'"
op|','
name|'vif'
op|'['
string|"'id'"
op|']'
op|')'
nl|'\n'
name|'for'
name|'vif'
name|'in'
name|'network_info'
name|'if'
name|'vif'
op|'.'
name|'get'
op|'('
string|"'active'"
op|','
name|'True'
op|')'
name|'is'
name|'False'
op|']'
newline|'\n'
nl|'\n'
DECL|member|_create_domain_and_network
dedent|''
name|'def'
name|'_create_domain_and_network'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'xml'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'disk_info'
op|','
name|'block_device_info'
op|'='
name|'None'
op|','
nl|'\n'
name|'power_on'
op|'='
name|'True'
op|','
name|'reboot'
op|'='
name|'False'
op|','
nl|'\n'
name|'vifs_already_plugged'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'        '
string|'"""Do required network setup and create domain."""'
newline|'\n'
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'image_meta'
op|'='
name|'utils'
op|'.'
name|'get_image_from_system_metadata'
op|'('
nl|'\n'
name|'instance'
op|'.'
name|'system_metadata'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'vol'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'            '
name|'connection_info'
op|'='
name|'vol'
op|'['
string|"'connection_info'"
op|']'
newline|'\n'
nl|'\n'
name|'if'
op|'('
name|'not'
name|'reboot'
name|'and'
string|"'data'"
name|'in'
name|'connection_info'
name|'and'
nl|'\n'
string|"'volume_id'"
name|'in'
name|'connection_info'
op|'['
string|"'data'"
op|']'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'volume_id'
op|'='
name|'connection_info'
op|'['
string|"'data'"
op|']'
op|'['
string|"'volume_id'"
op|']'
newline|'\n'
name|'encryption'
op|'='
name|'encryptors'
op|'.'
name|'get_encryption_metadata'
op|'('
nl|'\n'
name|'context'
op|','
name|'self'
op|'.'
name|'_volume_api'
op|','
name|'volume_id'
op|','
name|'connection_info'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'encryption'
op|':'
newline|'\n'
indent|'                    '
name|'encryptor'
op|'='
name|'self'
op|'.'
name|'_get_volume_encryptor'
op|'('
name|'connection_info'
op|','
nl|'\n'
name|'encryption'
op|')'
newline|'\n'
name|'encryptor'
op|'.'
name|'attach_volume'
op|'('
name|'context'
op|','
op|'**'
name|'encryption'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'timeout'
op|'='
name|'CONF'
op|'.'
name|'vif_plugging_timeout'
newline|'\n'
name|'if'
op|'('
name|'self'
op|'.'
name|'_conn_supports_start_paused'
name|'and'
nl|'\n'
name|'utils'
op|'.'
name|'is_neutron'
op|'('
op|')'
name|'and'
name|'not'
nl|'\n'
name|'vifs_already_plugged'
name|'and'
name|'power_on'
name|'and'
name|'timeout'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'='
name|'self'
op|'.'
name|'_get_neutron_events'
op|'('
name|'network_info'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'pause'
op|'='
name|'bool'
op|'('
name|'events'
op|')'
newline|'\n'
name|'guest'
op|'='
name|'None'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'self'
op|'.'
name|'virtapi'
op|'.'
name|'wait_for_instance_event'
op|'('
nl|'\n'
name|'instance'
op|','
name|'events'
op|','
name|'deadline'
op|'='
name|'timeout'
op|','
nl|'\n'
name|'error_callback'
op|'='
name|'self'
op|'.'
name|'_neutron_failed_callback'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'plug_vifs'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'setup_basic_filtering'
op|'('
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'prepare_instance_filter'
op|'('
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|')'
newline|'\n'
name|'with'
name|'self'
op|'.'
name|'_lxc_disk_handler'
op|'('
name|'instance'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'block_device_info'
op|','
name|'disk_info'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_create_domain'
op|'('
nl|'\n'
name|'xml'
op|','
name|'pause'
op|'='
name|'pause'
op|','
name|'power_on'
op|'='
name|'power_on'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'apply_instance_filter'
op|'('
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'exception'
op|'.'
name|'VirtualInterfaceCreateException'
op|':'
newline|'\n'
comment|"# Neutron reported failure and we didn't swallow it, so"
nl|'\n'
comment|'# bail here'
nl|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'guest'
op|':'
newline|'\n'
indent|'                    '
name|'guest'
op|'.'
name|'poweroff'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'cleanup'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|'='
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'eventlet'
op|'.'
name|'timeout'
op|'.'
name|'Timeout'
op|':'
newline|'\n'
comment|'# We never heard from Neutron'
nl|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'Timeout waiting for vif plugging callback for '"
nl|'\n'
string|"'instance %(uuid)s'"
op|')'
op|','
op|'{'
string|"'uuid'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|'}'
op|')'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'vif_plugging_is_fatal'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'guest'
op|':'
newline|'\n'
indent|'                    '
name|'guest'
op|'.'
name|'poweroff'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'cleanup'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|'='
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'VirtualInterfaceCreateException'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Resume only if domain has been paused'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'pause'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'resume'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'guest'
newline|'\n'
nl|'\n'
DECL|member|_get_all_block_devices
dedent|''
name|'def'
name|'_get_all_block_devices'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return all block devices in use on this node."""'
newline|'\n'
name|'devices'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'dom'
name|'in'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'list_instance_domains'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
comment|'# TODO(sahid): list_instance_domain should'
nl|'\n'
comment|'# be renamed as list_guest and so returning'
nl|'\n'
comment|'# Guest objects.'
nl|'\n'
indent|'                '
name|'guest'
op|'='
name|'libvirt_guest'
op|'.'
name|'Guest'
op|'('
name|'dom'
op|')'
newline|'\n'
name|'doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'guest'
op|'.'
name|'get_xml_desc'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"couldn\'t obtain the XML from domain:"'
nl|'\n'
string|'" %(uuid)s, exception: %(ex)s"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|'"uuid"'
op|':'
name|'guest'
op|'.'
name|'id'
op|','
string|'"ex"'
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'sources'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
string|'"./devices/disk[@type=\'block\']/source"'
op|')'
newline|'\n'
name|'for'
name|'source'
name|'in'
name|'sources'
op|':'
newline|'\n'
indent|'                '
name|'devices'
op|'.'
name|'append'
op|'('
name|'source'
op|'.'
name|'get'
op|'('
string|"'dev'"
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'devices'
newline|'\n'
nl|'\n'
DECL|member|_get_interfaces
dedent|''
name|'def'
name|'_get_interfaces'
op|'('
name|'self'
op|','
name|'xml'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Note that this function takes a domain xml.\n\n        Returns a list of all network interfaces for this instance.\n        """'
newline|'\n'
name|'doc'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'['
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'interfaces'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'nodes'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
string|"'./devices/interface/target'"
op|')'
newline|'\n'
name|'for'
name|'target'
name|'in'
name|'nodes'
op|':'
newline|'\n'
indent|'            '
name|'interfaces'
op|'.'
name|'append'
op|'('
name|'target'
op|'.'
name|'get'
op|'('
string|"'dev'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'interfaces'
newline|'\n'
nl|'\n'
DECL|member|_get_vcpu_total
dedent|''
name|'def'
name|'_get_vcpu_total'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get available vcpu number of physical computer.\n\n        :returns: the number of cpu core instances can be used.\n\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'total_pcpus'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_cpu_count'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Cannot get the number of cpu, because this "'
nl|'\n'
string|'"function is not implemented for this platform. "'
op|')'
op|')'
newline|'\n'
name|'return'
number|'0'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'vcpu_pin_set'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'total_pcpus'
newline|'\n'
nl|'\n'
dedent|''
name|'available_ids'
op|'='
name|'hardware'
op|'.'
name|'get_vcpu_pin_set'
op|'('
op|')'
newline|'\n'
comment|'# We get the list of online CPUs on the host and see if the requested'
nl|'\n'
comment|'# set falls under these. If not, we retain the old behavior.'
nl|'\n'
name|'online_pcpus'
op|'='
name|'None'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'online_pcpus'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_online_cpus'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Couldn\'t retrieve the online CPUs due to a Libvirt "'
nl|'\n'
string|'"error: %(error)s with error code: %(error_code)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'error'"
op|':'
name|'ex'
op|','
string|"'error_code'"
op|':'
name|'error_code'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'online_pcpus'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
op|'('
name|'available_ids'
op|'<='
name|'online_pcpus'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|'"Invalid vcpu_pin_set config, one or more of the "'
nl|'\n'
string|'"specified cpuset is not online. Online cpuset(s): "'
nl|'\n'
string|'"%(online)s, requested cpuset(s): %(req)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'online'"
op|':'
name|'sorted'
op|'('
name|'online_pcpus'
op|')'
op|','
nl|'\n'
string|"'req'"
op|':'
name|'sorted'
op|'('
name|'available_ids'
op|')'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'msg'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'sorted'
op|'('
name|'available_ids'
op|')'
op|'['
op|'-'
number|'1'
op|']'
op|'>='
name|'total_pcpus'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'_'
op|'('
string|'"Invalid vcpu_pin_set config, "'
nl|'\n'
string|'"out of hypervisor cpu range."'
op|')'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'len'
op|'('
name|'available_ids'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_get_local_gb_info
name|'def'
name|'_get_local_gb_info'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get local storage info of the compute node in GB.\n\n        :returns: A dict containing:\n             :total: How big the overall usable filesystem is (in gigabytes)\n             :free: How much space is free (in gigabytes)\n             :used: How much space is used (in gigabytes)\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_type'
op|'=='
string|"'lvm'"
op|':'
newline|'\n'
indent|'            '
name|'info'
op|'='
name|'lvm'
op|'.'
name|'get_volume_group_info'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_volume_group'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_type'
op|'=='
string|"'rbd'"
op|':'
newline|'\n'
indent|'            '
name|'info'
op|'='
name|'LibvirtDriver'
op|'.'
name|'_get_rbd_driver'
op|'('
op|')'
op|'.'
name|'get_pool_info'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'info'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_fs_info'
op|'('
name|'CONF'
op|'.'
name|'instances_path'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
op|'('
name|'k'
op|','
name|'v'
op|')'
name|'in'
name|'six'
op|'.'
name|'iteritems'
op|'('
name|'info'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'info'
op|'['
name|'k'
op|']'
op|'='
name|'v'
op|'/'
name|'units'
op|'.'
name|'Gi'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'info'
newline|'\n'
nl|'\n'
DECL|member|_get_vcpu_used
dedent|''
name|'def'
name|'_get_vcpu_used'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get vcpu usage number of physical computer.\n\n        :returns: The total number of vcpu(s) that are currently being used.\n\n        """'
newline|'\n'
nl|'\n'
name|'total'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'lxc'"
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'total'
op|'+'
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'dom'
name|'in'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'list_instance_domains'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
comment|'# TODO(sahid): list_instance_domains should'
nl|'\n'
comment|'# return Guest objects.'
nl|'\n'
indent|'                '
name|'vcpus'
op|'='
name|'libvirt_guest'
op|'.'
name|'Guest'
op|'('
name|'dom'
op|')'
op|'.'
name|'get_vcpus_info'
op|'('
op|')'
newline|'\n'
name|'if'
name|'vcpus'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'total'
op|'+='
name|'len'
op|'('
name|'list'
op|'('
name|'vcpus'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"couldn\'t obtain the vpu count from domain id:"'
nl|'\n'
string|'" %(uuid)s, exception: %(ex)s"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|'"uuid"'
op|':'
name|'dom'
op|'.'
name|'UUIDString'
op|'('
op|')'
op|','
string|'"ex"'
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
comment|'# NOTE(gtt116): give other tasks a chance.'
nl|'\n'
dedent|''
name|'greenthread'
op|'.'
name|'sleep'
op|'('
number|'0'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'total'
newline|'\n'
nl|'\n'
DECL|member|_get_instance_capabilities
dedent|''
name|'def'
name|'_get_instance_capabilities'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get hypervisor instance capabilities\n\n        Returns a list of tuples that describe instances the\n        hypervisor is capable of hosting.  Each tuple consists\n        of the triplet (arch, hypervisor_type, vm_mode).\n\n        :returns: List of tuples describing instance capabilities\n        """'
newline|'\n'
name|'caps'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_capabilities'
op|'('
op|')'
newline|'\n'
name|'instance_caps'
op|'='
name|'list'
op|'('
op|')'
newline|'\n'
name|'for'
name|'g'
name|'in'
name|'caps'
op|'.'
name|'guests'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'dt'
name|'in'
name|'g'
op|'.'
name|'domtype'
op|':'
newline|'\n'
indent|'                '
name|'instance_cap'
op|'='
op|'('
nl|'\n'
name|'arch'
op|'.'
name|'canonicalize'
op|'('
name|'g'
op|'.'
name|'arch'
op|')'
op|','
nl|'\n'
name|'hv_type'
op|'.'
name|'canonicalize'
op|'('
name|'dt'
op|')'
op|','
nl|'\n'
name|'vm_mode'
op|'.'
name|'canonicalize'
op|'('
name|'g'
op|'.'
name|'ostype'
op|')'
op|')'
newline|'\n'
name|'instance_caps'
op|'.'
name|'append'
op|'('
name|'instance_cap'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'instance_caps'
newline|'\n'
nl|'\n'
DECL|member|_get_cpu_info
dedent|''
name|'def'
name|'_get_cpu_info'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get cpuinfo information.\n\n        Obtains cpu feature from virConnect.getCapabilities.\n\n        :return: see above description\n\n        """'
newline|'\n'
nl|'\n'
name|'caps'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_capabilities'
op|'('
op|')'
newline|'\n'
name|'cpu_info'
op|'='
name|'dict'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'cpu_info'
op|'['
string|"'arch'"
op|']'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'arch'
newline|'\n'
name|'cpu_info'
op|'['
string|"'model'"
op|']'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'model'
newline|'\n'
name|'cpu_info'
op|'['
string|"'vendor'"
op|']'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'vendor'
newline|'\n'
nl|'\n'
name|'topology'
op|'='
name|'dict'
op|'('
op|')'
newline|'\n'
name|'topology'
op|'['
string|"'sockets'"
op|']'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'sockets'
newline|'\n'
name|'topology'
op|'['
string|"'cores'"
op|']'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'cores'
newline|'\n'
name|'topology'
op|'['
string|"'threads'"
op|']'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'threads'
newline|'\n'
name|'cpu_info'
op|'['
string|"'topology'"
op|']'
op|'='
name|'topology'
newline|'\n'
nl|'\n'
name|'features'
op|'='
name|'set'
op|'('
op|')'
newline|'\n'
name|'for'
name|'f'
name|'in'
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'features'
op|':'
newline|'\n'
indent|'            '
name|'features'
op|'.'
name|'add'
op|'('
name|'f'
op|'.'
name|'name'
op|')'
newline|'\n'
dedent|''
name|'cpu_info'
op|'['
string|"'features'"
op|']'
op|'='
name|'features'
newline|'\n'
name|'return'
name|'cpu_info'
newline|'\n'
nl|'\n'
DECL|member|_get_pcidev_info
dedent|''
name|'def'
name|'_get_pcidev_info'
op|'('
name|'self'
op|','
name|'devname'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns a dict of PCI device."""'
newline|'\n'
nl|'\n'
DECL|function|_get_device_type
name|'def'
name|'_get_device_type'
op|'('
name|'cfgdev'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Get a PCI device\'s device type.\n\n            An assignable PCI device can be a normal PCI device,\n            a SR-IOV Physical Function (PF), or a SR-IOV Virtual\n            Function (VF). Only normal PCI devices or SR-IOV VFs\n            are assignable, while SR-IOV PFs are always owned by\n            hypervisor.\n\n            Please notice that a PCI device with SR-IOV\n            capability but not enabled is reported as normal PCI device.\n            """'
newline|'\n'
name|'for'
name|'fun_cap'
name|'in'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'fun_capability'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'len'
op|'('
name|'fun_cap'
op|'.'
name|'device_addrs'
op|')'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'fun_cap'
op|'.'
name|'type'
op|'=='
string|"'virt_functions'"
op|':'
newline|'\n'
indent|'                        '
name|'return'
op|'{'
string|"'dev_type'"
op|':'
string|"'type-PF'"
op|'}'
newline|'\n'
dedent|''
name|'if'
name|'fun_cap'
op|'.'
name|'type'
op|'=='
string|"'phys_function'"
op|':'
newline|'\n'
indent|'                        '
name|'phys_address'
op|'='
string|'"%04x:%02x:%02x.%01x"'
op|'%'
op|'('
nl|'\n'
name|'fun_cap'
op|'.'
name|'device_addrs'
op|'['
number|'0'
op|']'
op|'['
number|'0'
op|']'
op|','
nl|'\n'
name|'fun_cap'
op|'.'
name|'device_addrs'
op|'['
number|'0'
op|']'
op|'['
number|'1'
op|']'
op|','
nl|'\n'
name|'fun_cap'
op|'.'
name|'device_addrs'
op|'['
number|'0'
op|']'
op|'['
number|'2'
op|']'
op|','
nl|'\n'
name|'fun_cap'
op|'.'
name|'device_addrs'
op|'['
number|'0'
op|']'
op|'['
number|'3'
op|']'
op|')'
newline|'\n'
name|'return'
op|'{'
string|"'dev_type'"
op|':'
string|"'type-VF'"
op|','
nl|'\n'
string|"'phys_function'"
op|':'
name|'phys_address'
op|'}'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
op|'{'
string|"'dev_type'"
op|':'
string|"'type-PCI'"
op|'}'
newline|'\n'
nl|'\n'
dedent|''
name|'virtdev'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'device_lookup_by_name'
op|'('
name|'devname'
op|')'
newline|'\n'
name|'xmlstr'
op|'='
name|'virtdev'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
name|'cfgdev'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigNodeDevice'
op|'('
op|')'
newline|'\n'
name|'cfgdev'
op|'.'
name|'parse_str'
op|'('
name|'xmlstr'
op|')'
newline|'\n'
nl|'\n'
name|'address'
op|'='
string|'"%04x:%02x:%02x.%1x"'
op|'%'
op|'('
nl|'\n'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'domain'
op|','
nl|'\n'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'bus'
op|','
nl|'\n'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'slot'
op|','
nl|'\n'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'function'
op|')'
newline|'\n'
nl|'\n'
name|'device'
op|'='
op|'{'
nl|'\n'
string|'"dev_id"'
op|':'
name|'cfgdev'
op|'.'
name|'name'
op|','
nl|'\n'
string|'"address"'
op|':'
name|'address'
op|','
nl|'\n'
string|'"product_id"'
op|':'
string|'"%04x"'
op|'%'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'product_id'
op|','
nl|'\n'
string|'"vendor_id"'
op|':'
string|'"%04x"'
op|'%'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'vendor_id'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
name|'device'
op|'['
string|'"numa_node"'
op|']'
op|'='
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'numa_node'
newline|'\n'
nl|'\n'
comment|'# requirement by DataBase Model'
nl|'\n'
name|'device'
op|'['
string|"'label'"
op|']'
op|'='
string|"'label_%(vendor_id)s_%(product_id)s'"
op|'%'
name|'device'
newline|'\n'
name|'device'
op|'.'
name|'update'
op|'('
name|'_get_device_type'
op|'('
name|'cfgdev'
op|')'
op|')'
newline|'\n'
name|'return'
name|'device'
newline|'\n'
nl|'\n'
DECL|member|_get_pci_passthrough_devices
dedent|''
name|'def'
name|'_get_pci_passthrough_devices'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get host PCI devices information.\n\n        Obtains pci devices information from libvirt, and returns\n        as a JSON string.\n\n        Each device information is a dictionary, with mandatory keys\n        of \'address\', \'vendor_id\', \'product_id\', \'dev_type\', \'dev_id\',\n        \'label\' and other optional device specific information.\n\n        Refer to the objects/pci_device.py for more idea of these keys.\n\n        :returns: a JSON string containaing a list of the assignable PCI\n                  devices information\n        """'
newline|'\n'
comment|"# Bail early if we know we can't support `listDevices` to avoid"
nl|'\n'
comment|'# repeated warnings within a periodic task'
nl|'\n'
name|'if'
name|'not'
name|'getattr'
op|'('
name|'self'
op|','
string|"'_list_devices_supported'"
op|','
name|'True'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'dev_names'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'list_pci_devices'
op|'('
op|')'
name|'or'
op|'['
op|']'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_SUPPORT'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_list_devices_supported'
op|'='
name|'False'
newline|'\n'
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"URI %(uri)s does not support "'
nl|'\n'
string|'"listDevices: %(error)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'uri'"
op|':'
name|'self'
op|'.'
name|'_uri'
op|'('
op|')'
op|','
string|"'error'"
op|':'
name|'ex'
op|'}'
op|')'
newline|'\n'
name|'return'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
op|'['
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'pci_info'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'name'
name|'in'
name|'dev_names'
op|':'
newline|'\n'
indent|'            '
name|'pci_info'
op|'.'
name|'append'
op|'('
name|'self'
op|'.'
name|'_get_pcidev_info'
op|'('
name|'name'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
name|'pci_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_has_numa_support
dedent|''
name|'def'
name|'_has_numa_support'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# This means that the host can support LibvirtConfigGuestNUMATune'
nl|'\n'
comment|'# and the nodeset field in LibvirtConfigGuestMemoryBackingPage'
nl|'\n'
indent|'        '
name|'supported_archs'
op|'='
op|'['
name|'arch'
op|'.'
name|'I686'
op|','
name|'arch'
op|'.'
name|'X86_64'
op|']'
newline|'\n'
name|'caps'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_capabilities'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'ver'
name|'in'
name|'BAD_LIBVIRT_NUMA_VERSIONS'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'has_version'
op|'('
name|'ver'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
op|'('
op|'('
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'arch'
name|'in'
name|'supported_archs'
op|')'
name|'and'
nl|'\n'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'has_min_version'
op|'('
name|'MIN_LIBVIRT_NUMA_VERSION'
op|','
nl|'\n'
name|'MIN_QEMU_NUMA_HUGEPAGE_VERSION'
op|','
nl|'\n'
name|'host'
op|'.'
name|'HV_DRIVER_QEMU'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_has_hugepage_support
dedent|''
name|'def'
name|'_has_hugepage_support'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# This means that the host can support multiple values for the size'
nl|'\n'
comment|'# field in LibvirtConfigGuestMemoryBackingPage'
nl|'\n'
indent|'        '
name|'supported_archs'
op|'='
op|'['
name|'arch'
op|'.'
name|'I686'
op|','
name|'arch'
op|'.'
name|'X86_64'
op|']'
newline|'\n'
name|'caps'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_capabilities'
op|'('
op|')'
newline|'\n'
name|'return'
op|'('
op|'('
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'arch'
name|'in'
name|'supported_archs'
op|')'
name|'and'
nl|'\n'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'has_min_version'
op|'('
name|'MIN_LIBVIRT_HUGEPAGE_VERSION'
op|','
nl|'\n'
name|'MIN_QEMU_NUMA_HUGEPAGE_VERSION'
op|','
nl|'\n'
name|'host'
op|'.'
name|'HV_DRIVER_QEMU'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_host_numa_topology
dedent|''
name|'def'
name|'_get_host_numa_topology'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'self'
op|'.'
name|'_has_numa_support'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'caps'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_capabilities'
op|'('
op|')'
newline|'\n'
name|'topology'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'topology'
newline|'\n'
nl|'\n'
name|'if'
name|'topology'
name|'is'
name|'None'
name|'or'
name|'not'
name|'topology'
op|'.'
name|'cells'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'cells'
op|'='
op|'['
op|']'
newline|'\n'
name|'allowed_cpus'
op|'='
name|'hardware'
op|'.'
name|'get_vcpu_pin_set'
op|'('
op|')'
newline|'\n'
name|'online_cpus'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_online_cpus'
op|'('
op|')'
newline|'\n'
name|'if'
name|'allowed_cpus'
op|':'
newline|'\n'
indent|'            '
name|'allowed_cpus'
op|'&='
name|'online_cpus'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'allowed_cpus'
op|'='
name|'online_cpus'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'cell'
name|'in'
name|'topology'
op|'.'
name|'cells'
op|':'
newline|'\n'
indent|'            '
name|'cpuset'
op|'='
name|'set'
op|'('
name|'cpu'
op|'.'
name|'id'
name|'for'
name|'cpu'
name|'in'
name|'cell'
op|'.'
name|'cpus'
op|')'
newline|'\n'
name|'siblings'
op|'='
name|'sorted'
op|'('
name|'map'
op|'('
name|'set'
op|','
nl|'\n'
name|'set'
op|'('
name|'tuple'
op|'('
name|'cpu'
op|'.'
name|'siblings'
op|')'
nl|'\n'
name|'if'
name|'cpu'
op|'.'
name|'siblings'
name|'else'
op|'('
op|')'
nl|'\n'
name|'for'
name|'cpu'
name|'in'
name|'cell'
op|'.'
name|'cpus'
op|')'
nl|'\n'
op|')'
op|')'
newline|'\n'
name|'cpuset'
op|'&='
name|'allowed_cpus'
newline|'\n'
name|'siblings'
op|'='
op|'['
name|'sib'
op|'&'
name|'allowed_cpus'
name|'for'
name|'sib'
name|'in'
name|'siblings'
op|']'
newline|'\n'
comment|'# Filter out singles and empty sibling sets that may be left'
nl|'\n'
name|'siblings'
op|'='
op|'['
name|'sib'
name|'for'
name|'sib'
name|'in'
name|'siblings'
name|'if'
name|'len'
op|'('
name|'sib'
op|')'
op|'>'
number|'1'
op|']'
newline|'\n'
nl|'\n'
name|'mempages'
op|'='
op|'['
op|']'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_has_hugepage_support'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'mempages'
op|'='
op|'['
nl|'\n'
name|'objects'
op|'.'
name|'NUMAPagesTopology'
op|'('
nl|'\n'
name|'size_kb'
op|'='
name|'pages'
op|'.'
name|'size'
op|','
nl|'\n'
name|'total'
op|'='
name|'pages'
op|'.'
name|'total'
op|','
nl|'\n'
name|'used'
op|'='
number|'0'
op|')'
nl|'\n'
name|'for'
name|'pages'
name|'in'
name|'cell'
op|'.'
name|'mempages'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'cell'
op|'='
name|'objects'
op|'.'
name|'NUMACell'
op|'('
name|'id'
op|'='
name|'cell'
op|'.'
name|'id'
op|','
name|'cpuset'
op|'='
name|'cpuset'
op|','
nl|'\n'
name|'memory'
op|'='
name|'cell'
op|'.'
name|'memory'
op|'/'
name|'units'
op|'.'
name|'Ki'
op|','
nl|'\n'
name|'cpu_usage'
op|'='
number|'0'
op|','
name|'memory_usage'
op|'='
number|'0'
op|','
nl|'\n'
name|'siblings'
op|'='
name|'siblings'
op|','
nl|'\n'
name|'pinned_cpus'
op|'='
name|'set'
op|'('
op|'['
op|']'
op|')'
op|','
nl|'\n'
name|'mempages'
op|'='
name|'mempages'
op|')'
newline|'\n'
name|'cells'
op|'.'
name|'append'
op|'('
name|'cell'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'objects'
op|'.'
name|'NUMATopology'
op|'('
name|'cells'
op|'='
name|'cells'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_all_volume_usage
dedent|''
name|'def'
name|'get_all_volume_usage'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'compute_host_bdms'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return usage info for volumes attached to vms on\n           a given host.\n        """'
newline|'\n'
name|'vol_usage'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'instance_bdms'
name|'in'
name|'compute_host_bdms'
op|':'
newline|'\n'
indent|'            '
name|'instance'
op|'='
name|'instance_bdms'
op|'['
string|"'instance'"
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'bdm'
name|'in'
name|'instance_bdms'
op|'['
string|"'instance_bdms'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'mountpoint'
op|'='
name|'bdm'
op|'['
string|"'device_name'"
op|']'
newline|'\n'
name|'if'
name|'mountpoint'
op|'.'
name|'startswith'
op|'('
string|"'/dev/'"
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'mountpoint'
op|'='
name|'mountpoint'
op|'['
number|'5'
op|':'
op|']'
newline|'\n'
dedent|''
name|'volume_id'
op|'='
name|'bdm'
op|'['
string|"'volume_id'"
op|']'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Trying to get stats for the volume %s"'
op|','
nl|'\n'
name|'volume_id'
op|')'
newline|'\n'
name|'vol_stats'
op|'='
name|'self'
op|'.'
name|'block_stats'
op|'('
name|'instance'
op|','
name|'mountpoint'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'vol_stats'
op|':'
newline|'\n'
indent|'                    '
name|'stats'
op|'='
name|'dict'
op|'('
name|'volume'
op|'='
name|'volume_id'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|','
nl|'\n'
name|'rd_req'
op|'='
name|'vol_stats'
op|'['
number|'0'
op|']'
op|','
nl|'\n'
name|'rd_bytes'
op|'='
name|'vol_stats'
op|'['
number|'1'
op|']'
op|','
nl|'\n'
name|'wr_req'
op|'='
name|'vol_stats'
op|'['
number|'2'
op|']'
op|','
nl|'\n'
name|'wr_bytes'
op|'='
name|'vol_stats'
op|'['
number|'3'
op|']'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
nl|'\n'
string|'"Got volume usage stats for the volume=%(volume)s,"'
nl|'\n'
string|'" rd_req=%(rd_req)d, rd_bytes=%(rd_bytes)d, "'
nl|'\n'
string|'"wr_req=%(wr_req)d, wr_bytes=%(wr_bytes)d"'
op|','
nl|'\n'
name|'stats'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'vol_usage'
op|'.'
name|'append'
op|'('
name|'stats'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'vol_usage'
newline|'\n'
nl|'\n'
DECL|member|block_stats
dedent|''
name|'def'
name|'block_stats'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'disk_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Note that this function takes an instance name."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(sahid): We are converting all calls from a'
nl|'\n'
comment|'# virDomain object to use nova.virt.libvirt.Guest.'
nl|'\n'
comment|'# We should be able to remove domain at the end.'
nl|'\n'
name|'domain'
op|'='
name|'guest'
op|'.'
name|'_domain'
newline|'\n'
name|'return'
name|'domain'
op|'.'
name|'blockStats'
op|'('
name|'disk_id'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'errcode'
op|'='
name|'e'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Getting block stats failed, device might have '"
nl|'\n'
string|"'been detached. Instance=%(instance_name)s '"
nl|'\n'
string|"'Disk=%(disk)s Code=%(errcode)s Error=%(e)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'instance_name'"
op|':'
name|'instance'
op|'.'
name|'name'
op|','
string|"'disk'"
op|':'
name|'disk_id'
op|','
nl|'\n'
string|"'errcode'"
op|':'
name|'errcode'
op|','
string|"'e'"
op|':'
name|'e'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Could not find domain in libvirt for instance %s. '"
nl|'\n'
string|"'Cannot get block stats for device'"
op|')'
op|','
name|'instance'
op|'.'
name|'name'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_console_pool_info
dedent|''
dedent|''
name|'def'
name|'get_console_pool_info'
op|'('
name|'self'
op|','
name|'console_type'
op|')'
op|':'
newline|'\n'
comment|'# TODO(mdragon): console proxy should be implemented for libvirt,'
nl|'\n'
comment|'#                in case someone wants to use it with kvm or'
nl|'\n'
comment|'#                such. For now return fake data.'
nl|'\n'
indent|'        '
name|'return'
op|'{'
string|"'address'"
op|':'
string|"'127.0.0.1'"
op|','
nl|'\n'
string|"'username'"
op|':'
string|"'fakeuser'"
op|','
nl|'\n'
string|"'password'"
op|':'
string|"'fakepassword'"
op|'}'
newline|'\n'
nl|'\n'
DECL|member|refresh_security_group_rules
dedent|''
name|'def'
name|'refresh_security_group_rules'
op|'('
name|'self'
op|','
name|'security_group_id'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'refresh_security_group_rules'
op|'('
name|'security_group_id'
op|')'
newline|'\n'
nl|'\n'
DECL|member|refresh_security_group_members
dedent|''
name|'def'
name|'refresh_security_group_members'
op|'('
name|'self'
op|','
name|'security_group_id'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'refresh_security_group_members'
op|'('
name|'security_group_id'
op|')'
newline|'\n'
nl|'\n'
DECL|member|refresh_instance_security_rules
dedent|''
name|'def'
name|'refresh_instance_security_rules'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'refresh_instance_security_rules'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|refresh_provider_fw_rules
dedent|''
name|'def'
name|'refresh_provider_fw_rules'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'refresh_provider_fw_rules'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_available_resource
dedent|''
name|'def'
name|'get_available_resource'
op|'('
name|'self'
op|','
name|'nodename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve resource information.\n\n        This method is called when nova-compute launches, and\n        as part of a periodic task that records the results in the DB.\n\n        :param nodename: will be put in PCI device\n        :returns: dictionary containing resource info\n        """'
newline|'\n'
nl|'\n'
name|'disk_info_dict'
op|'='
name|'self'
op|'.'
name|'_get_local_gb_info'
op|'('
op|')'
newline|'\n'
name|'data'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
comment|'# NOTE(dprince): calling capabilities before getVersion works around'
nl|'\n'
comment|'# an initialization issue with some versions of Libvirt (1.0.5.5).'
nl|'\n'
comment|'# See: https://bugzilla.redhat.com/show_bug.cgi?id=1000116'
nl|'\n'
comment|'# See: https://bugs.launchpad.net/nova/+bug/1215593'
nl|'\n'
nl|'\n'
comment|'# Temporary convert supported_instances into a string, while keeping'
nl|'\n'
comment|'# the RPC version as JSON. Can be changed when RPC broadcast is removed'
nl|'\n'
name|'data'
op|'['
string|'"supported_instances"'
op|']'
op|'='
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_get_instance_capabilities'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'data'
op|'['
string|'"vcpus"'
op|']'
op|'='
name|'self'
op|'.'
name|'_get_vcpu_total'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|'"memory_mb"'
op|']'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_memory_mb_total'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|'"local_gb"'
op|']'
op|'='
name|'disk_info_dict'
op|'['
string|"'total'"
op|']'
newline|'\n'
name|'data'
op|'['
string|'"vcpus_used"'
op|']'
op|'='
name|'self'
op|'.'
name|'_get_vcpu_used'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|'"memory_mb_used"'
op|']'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_memory_mb_used'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|'"local_gb_used"'
op|']'
op|'='
name|'disk_info_dict'
op|'['
string|"'used'"
op|']'
newline|'\n'
name|'data'
op|'['
string|'"hypervisor_type"'
op|']'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_driver_type'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|'"hypervisor_version"'
op|']'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_version'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|'"hypervisor_hostname"'
op|']'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_hostname'
op|'('
op|')'
newline|'\n'
comment|'# TODO(berrange): why do we bother converting the'
nl|'\n'
comment|'# libvirt capabilities XML into a special JSON format ?'
nl|'\n'
comment|'# The data format is different across all the drivers'
nl|'\n'
comment|'# so we could just return the raw capabilities XML'
nl|'\n'
comment|"# which 'compare_cpu' could use directly"
nl|'\n'
comment|'#'
nl|'\n'
comment|'# That said, arch_filter.py now seems to rely on'
nl|'\n'
comment|'# the libvirt drivers format which suggests this'
nl|'\n'
comment|'# data format needs to be standardized across drivers'
nl|'\n'
name|'data'
op|'['
string|'"cpu_info"'
op|']'
op|'='
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
name|'self'
op|'.'
name|'_get_cpu_info'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'disk_free_gb'
op|'='
name|'disk_info_dict'
op|'['
string|"'free'"
op|']'
newline|'\n'
name|'disk_over_committed'
op|'='
name|'self'
op|'.'
name|'_get_disk_over_committed_size_total'
op|'('
op|')'
newline|'\n'
name|'available_least'
op|'='
name|'disk_free_gb'
op|'*'
name|'units'
op|'.'
name|'Gi'
op|'-'
name|'disk_over_committed'
newline|'\n'
name|'data'
op|'['
string|"'disk_available_least'"
op|']'
op|'='
name|'available_least'
op|'/'
name|'units'
op|'.'
name|'Gi'
newline|'\n'
nl|'\n'
name|'data'
op|'['
string|"'pci_passthrough_devices'"
op|']'
op|'='
name|'self'
op|'.'
name|'_get_pci_passthrough_devices'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'numa_topology'
op|'='
name|'self'
op|'.'
name|'_get_host_numa_topology'
op|'('
op|')'
newline|'\n'
name|'if'
name|'numa_topology'
op|':'
newline|'\n'
indent|'            '
name|'data'
op|'['
string|"'numa_topology'"
op|']'
op|'='
name|'numa_topology'
op|'.'
name|'_to_json'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'data'
op|'['
string|"'numa_topology'"
op|']'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'data'
newline|'\n'
nl|'\n'
DECL|member|check_instance_shared_storage_local
dedent|''
name|'def'
name|'check_instance_shared_storage_local'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check if instance files located on shared storage.\n\n        This runs check on the destination host, and then calls\n        back to the source host to check the results.\n\n        :param context: security context\n        :param instance: nova.objects.instance.Instance object\n        :returns\n            :tempfile: A dict containing the tempfile info on the destination\n                       host\n            :None: 1. If the instance path is not existing.\n                   2. If the image backend is shared block storage type.\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'backend'
op|'('
op|')'
op|'.'
name|'is_shared_block_storage'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'dirpath'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'dirpath'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'fd'
op|','
name|'tmp_file'
op|'='
name|'tempfile'
op|'.'
name|'mkstemp'
op|'('
name|'dir'
op|'='
name|'dirpath'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Creating tmpfile %s to verify with other "'
nl|'\n'
string|'"compute node that the instance is on "'
nl|'\n'
string|'"the same shared storage."'
op|','
nl|'\n'
name|'tmp_file'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'fd'
op|')'
newline|'\n'
name|'return'
op|'{'
string|'"filename"'
op|':'
name|'tmp_file'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|check_instance_shared_storage_remote
dedent|''
name|'def'
name|'check_instance_shared_storage_remote'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'data'
op|'['
string|"'filename'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|check_instance_shared_storage_cleanup
dedent|''
name|'def'
name|'check_instance_shared_storage_cleanup'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'fileutils'
op|'.'
name|'delete_if_exists'
op|'('
name|'data'
op|'['
string|'"filename"'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|check_can_live_migrate_destination
dedent|''
name|'def'
name|'check_can_live_migrate_destination'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'src_compute_info'
op|','
name|'dst_compute_info'
op|','
nl|'\n'
name|'block_migration'
op|'='
name|'False'
op|','
nl|'\n'
name|'disk_over_commit'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check if it is possible to execute live migration.\n\n        This runs checks on the destination host, and then calls\n        back to the source host to check the results.\n\n        :param context: security context\n        :param instance: nova.db.sqlalchemy.models.Instance\n        :param block_migration: if true, prepare for block migration\n        :param disk_over_commit: if true, allow disk over commit\n        :returns: a dict containing:\n             :filename: name of the tmpfile under CONF.instances_path\n             :block_migration: whether this is block migration\n             :disk_over_commit: disk-over-commit factor on dest host\n             :disk_available_mb: available disk space on dest host\n        """'
newline|'\n'
name|'disk_available_mb'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'block_migration'
op|':'
newline|'\n'
indent|'            '
name|'disk_available_gb'
op|'='
name|'dst_compute_info'
op|'['
string|"'disk_available_least'"
op|']'
newline|'\n'
name|'disk_available_mb'
op|'='
op|'('
name|'disk_available_gb'
op|'*'
name|'units'
op|'.'
name|'Ki'
op|')'
op|'-'
name|'CONF'
op|'.'
name|'reserved_host_disk_mb'
newline|'\n'
nl|'\n'
comment|'# Compare CPU'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'instance'
op|'.'
name|'vcpu_model'
name|'or'
name|'not'
name|'instance'
op|'.'
name|'vcpu_model'
op|'.'
name|'model'
op|':'
newline|'\n'
indent|'            '
name|'source_cpu_info'
op|'='
name|'src_compute_info'
op|'['
string|"'cpu_info'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_compare_cpu'
op|'('
name|'None'
op|','
name|'source_cpu_info'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_compare_cpu'
op|'('
name|'instance'
op|'.'
name|'vcpu_model'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
comment|'# Create file on storage, to be checked on source host'
nl|'\n'
dedent|''
name|'filename'
op|'='
name|'self'
op|'.'
name|'_create_shared_storage_test_file'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'return'
op|'{'
string|'"filename"'
op|':'
name|'filename'
op|','
nl|'\n'
string|'"image_type"'
op|':'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_type'
op|','
nl|'\n'
string|'"block_migration"'
op|':'
name|'block_migration'
op|','
nl|'\n'
string|'"disk_over_commit"'
op|':'
name|'disk_over_commit'
op|','
nl|'\n'
string|'"disk_available_mb"'
op|':'
name|'disk_available_mb'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|check_can_live_migrate_destination_cleanup
dedent|''
name|'def'
name|'check_can_live_migrate_destination_cleanup'
op|'('
name|'self'
op|','
name|'context'
op|','
nl|'\n'
name|'dest_check_data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Do required cleanup on dest host after check_can_live_migrate calls\n\n        :param context: security context\n        """'
newline|'\n'
name|'filename'
op|'='
name|'dest_check_data'
op|'['
string|'"filename"'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_cleanup_shared_storage_test_file'
op|'('
name|'filename'
op|')'
newline|'\n'
nl|'\n'
DECL|member|check_can_live_migrate_source
dedent|''
name|'def'
name|'check_can_live_migrate_source'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'dest_check_data'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check if it is possible to execute live migration.\n\n        This checks if the live migration can succeed, based on the\n        results from check_can_live_migrate_destination.\n\n        :param context: security context\n        :param instance: nova.db.sqlalchemy.models.Instance\n        :param dest_check_data: result of check_can_live_migrate_destination\n        :param block_device_info: result of _get_instance_block_device_info\n        :returns: a dict containing migration info\n        """'
newline|'\n'
comment|'# Checking shared storage connectivity'
nl|'\n'
comment|'# if block migration, instances_paths should not be on shared storage.'
nl|'\n'
name|'source'
op|'='
name|'CONF'
op|'.'
name|'host'
newline|'\n'
nl|'\n'
name|'dest_check_data'
op|'.'
name|'update'
op|'('
op|'{'
string|"'is_shared_instance_path'"
op|':'
nl|'\n'
name|'self'
op|'.'
name|'_check_shared_storage_test_file'
op|'('
nl|'\n'
name|'dest_check_data'
op|'['
string|"'filename'"
op|']'
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'dest_check_data'
op|'.'
name|'update'
op|'('
op|'{'
string|"'is_shared_block_storage'"
op|':'
nl|'\n'
name|'self'
op|'.'
name|'_is_shared_block_storage'
op|'('
name|'instance'
op|','
name|'dest_check_data'
op|','
nl|'\n'
name|'block_device_info'
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'dest_check_data'
op|'['
string|"'block_migration'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
name|'dest_check_data'
op|'['
string|"'is_shared_block_storage'"
op|']'
name|'or'
nl|'\n'
name|'dest_check_data'
op|'['
string|"'is_shared_instance_path'"
op|']'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'reason'
op|'='
name|'_'
op|'('
string|'"Block migration can not be used "'
nl|'\n'
string|'"with shared storage."'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InvalidLocalStorage'
op|'('
name|'reason'
op|'='
name|'reason'
op|','
name|'path'
op|'='
name|'source'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_assert_dest_node_has_enough_disk'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'dest_check_data'
op|'['
string|"'disk_available_mb'"
op|']'
op|','
nl|'\n'
name|'dest_check_data'
op|'['
string|"'disk_over_commit'"
op|']'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'not'
op|'('
name|'dest_check_data'
op|'['
string|"'is_shared_block_storage'"
op|']'
name|'or'
nl|'\n'
name|'dest_check_data'
op|'['
string|"'is_shared_instance_path'"
op|']'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
name|'_'
op|'('
string|'"Live migration can not be used "'
nl|'\n'
string|'"without shared storage."'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InvalidSharedStorage'
op|'('
name|'reason'
op|'='
name|'reason'
op|','
name|'path'
op|'='
name|'source'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(mikal): include the instance directory name here because it'
nl|'\n'
comment|"# doesn't yet exist on the destination but we want to force that"
nl|'\n'
comment|'# same name to be used'
nl|'\n'
dedent|''
name|'instance_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|','
nl|'\n'
name|'relative'
op|'='
name|'True'
op|')'
newline|'\n'
name|'dest_check_data'
op|'['
string|"'instance_relative_path'"
op|']'
op|'='
name|'instance_path'
newline|'\n'
nl|'\n'
comment|"# NOTE(danms): Emulate this old flag in case we're talking to"
nl|'\n'
comment|'# an older client (<= Juno). We can remove this when we bump the'
nl|'\n'
comment|'# compute RPC API to 4.0.'
nl|'\n'
name|'dest_check_data'
op|'['
string|"'is_shared_storage'"
op|']'
op|'='
op|'('
nl|'\n'
name|'dest_check_data'
op|'['
string|"'is_shared_instance_path'"
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'dest_check_data'
newline|'\n'
nl|'\n'
DECL|member|_is_shared_block_storage
dedent|''
name|'def'
name|'_is_shared_block_storage'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'dest_check_data'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check if all block storage of an instance can be shared\n        between source and destination of a live migration.\n\n        Returns true if the instance is volume backed and has no local disks,\n        or if the image backend is the same on source and destination and the\n        backend shares block storage between compute nodes.\n\n        :param instance: nova.objects.instance.Instance object\n        :param dest_check_data: dict with boolean fields image_type,\n                                is_shared_instance_path, and is_volume_backed\n        """'
newline|'\n'
name|'if'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_type'
op|'=='
name|'dest_check_data'
op|'.'
name|'get'
op|'('
string|"'image_type'"
op|')'
name|'and'
nl|'\n'
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'backend'
op|'('
op|')'
op|'.'
name|'is_shared_block_storage'
op|'('
op|')'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(dgenin): currently true only for RBD image backend'
nl|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'dest_check_data'
op|'.'
name|'get'
op|'('
string|"'is_shared_instance_path'"
op|')'
name|'and'
nl|'\n'
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'backend'
op|'('
op|')'
op|'.'
name|'is_file_in_instance_path'
op|'('
op|')'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(angdraug): file based image backends (Raw, Qcow2)'
nl|'\n'
comment|'# place block device files under the instance path'
nl|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'dest_check_data'
op|'.'
name|'get'
op|'('
string|"'is_volume_backed'"
op|')'
name|'and'
nl|'\n'
name|'not'
name|'bool'
op|'('
name|'jsonutils'
op|'.'
name|'loads'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'get_instance_disk_info'
op|'('
name|'instance'
op|','
nl|'\n'
name|'block_device_info'
op|')'
op|')'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|_assert_dest_node_has_enough_disk
dedent|''
name|'def'
name|'_assert_dest_node_has_enough_disk'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'available_mb'
op|','
name|'disk_over_commit'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Checks if destination has enough disk for block migration."""'
newline|'\n'
comment|'# Libvirt supports qcow2 disk format,which is usually compressed'
nl|'\n'
comment|'# on compute nodes.'
nl|'\n'
comment|'# Real disk image (compressed) may enlarged to "virtual disk size",'
nl|'\n'
comment|'# that is specified as the maximum disk size.'
nl|'\n'
comment|'# (See qemu-img -f path-to-disk)'
nl|'\n'
comment|'# Scheduler recognizes destination host still has enough disk space'
nl|'\n'
comment|'# if real disk size < available disk size'
nl|'\n'
comment|'# if disk_over_commit is True,'
nl|'\n'
comment|'#  otherwise virtual disk size < available disk size.'
nl|'\n'
nl|'\n'
name|'available'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'available_mb'
op|':'
newline|'\n'
indent|'            '
name|'available'
op|'='
name|'available_mb'
op|'*'
name|'units'
op|'.'
name|'Mi'
newline|'\n'
nl|'\n'
dedent|''
name|'ret'
op|'='
name|'self'
op|'.'
name|'get_instance_disk_info'
op|'('
name|'instance'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|')'
newline|'\n'
name|'disk_infos'
op|'='
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'ret'
op|')'
newline|'\n'
nl|'\n'
name|'necessary'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'disk_over_commit'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'info'
name|'in'
name|'disk_infos'
op|':'
newline|'\n'
indent|'                '
name|'necessary'
op|'+='
name|'int'
op|'('
name|'info'
op|'['
string|"'disk_size'"
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'info'
name|'in'
name|'disk_infos'
op|':'
newline|'\n'
indent|'                '
name|'necessary'
op|'+='
name|'int'
op|'('
name|'info'
op|'['
string|"'virt_disk_size'"
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Check that available disk > necessary disk'
nl|'\n'
dedent|''
dedent|''
name|'if'
op|'('
name|'available'
op|'-'
name|'necessary'
op|')'
op|'<'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
op|'('
name|'_'
op|'('
string|"'Unable to migrate %(instance_uuid)s: '"
nl|'\n'
string|"'Disk of instance is too large(available'"
nl|'\n'
string|"' on destination host:%(available)s '"
nl|'\n'
string|"'< need:%(necessary)s)'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'instance_uuid'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|','
nl|'\n'
string|"'available'"
op|':'
name|'available'
op|','
nl|'\n'
string|"'necessary'"
op|':'
name|'necessary'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'MigrationPreCheckError'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_compare_cpu
dedent|''
dedent|''
name|'def'
name|'_compare_cpu'
op|'('
name|'self'
op|','
name|'guest_cpu'
op|','
name|'host_cpu_str'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check the host is compatible with the requested CPU\n\n        :param guest_cpu: nova.objects.VirtCPUModel or None\n        :param host_cpu_str: JSON from _get_cpu_info() method\n\n        If the \'guest_cpu\' parameter is not None, this will be\n        validated for migration compatibility with the host.\n        Otherwise the \'host_cpu_str\' JSON string will be used for\n        validation.\n\n        :returns:\n            None. if given cpu info is not compatible to this server,\n            raise exception.\n        """'
newline|'\n'
nl|'\n'
comment|'# NOTE(berendt): virConnectCompareCPU not working for Xen'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
name|'not'
name|'in'
op|'['
string|"'qemu'"
op|','
string|"'kvm'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'guest_cpu'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'info'
op|'='
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'host_cpu_str'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Instance launched has CPU info: %s'"
op|')'
op|','
name|'host_cpu_str'
op|')'
newline|'\n'
name|'cpu'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigCPU'
op|'('
op|')'
newline|'\n'
name|'cpu'
op|'.'
name|'arch'
op|'='
name|'info'
op|'['
string|"'arch'"
op|']'
newline|'\n'
name|'cpu'
op|'.'
name|'model'
op|'='
name|'info'
op|'['
string|"'model'"
op|']'
newline|'\n'
name|'cpu'
op|'.'
name|'vendor'
op|'='
name|'info'
op|'['
string|"'vendor'"
op|']'
newline|'\n'
name|'cpu'
op|'.'
name|'sockets'
op|'='
name|'info'
op|'['
string|"'topology'"
op|']'
op|'['
string|"'sockets'"
op|']'
newline|'\n'
name|'cpu'
op|'.'
name|'cores'
op|'='
name|'info'
op|'['
string|"'topology'"
op|']'
op|'['
string|"'cores'"
op|']'
newline|'\n'
name|'cpu'
op|'.'
name|'threads'
op|'='
name|'info'
op|'['
string|"'topology'"
op|']'
op|'['
string|"'threads'"
op|']'
newline|'\n'
name|'for'
name|'f'
name|'in'
name|'info'
op|'['
string|"'features'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'cpu'
op|'.'
name|'add_feature'
op|'('
name|'vconfig'
op|'.'
name|'LibvirtConfigCPUFeature'
op|'('
name|'f'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'cpu'
op|'='
name|'self'
op|'.'
name|'_vcpu_model_to_cpu_config'
op|'('
name|'guest_cpu'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'u'
op|'='
string|'"http://libvirt.org/html/libvirt-libvirt.html#virCPUCompareResult"'
newline|'\n'
name|'m'
op|'='
name|'_'
op|'('
string|'"CPU doesn\'t have compatibility.\\n\\n%(ret)s\\n\\nRefer to %(u)s"'
op|')'
newline|'\n'
comment|'# unknown character exists in xml, then libvirt complains'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'ret'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'compare_cpu'
op|'('
name|'cpu'
op|'.'
name|'to_xml'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'e'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_SUPPORT'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"URI %(uri)s does not support cpu comparison. "'
nl|'\n'
string|'"It will be proceeded though. Error: %(error)s"'
op|','
nl|'\n'
op|'{'
string|"'uri'"
op|':'
name|'self'
op|'.'
name|'_uri'
op|'('
op|')'
op|','
string|"'error'"
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'m'
op|','
op|'{'
string|"'ret'"
op|':'
name|'e'
op|','
string|"'u'"
op|':'
name|'u'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'MigrationPreCheckError'
op|'('
nl|'\n'
name|'reason'
op|'='
name|'m'
op|'%'
op|'{'
string|"'ret'"
op|':'
name|'e'
op|','
string|"'u'"
op|':'
name|'u'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'ret'
op|'<='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'m'
op|','
op|'{'
string|"'ret'"
op|':'
name|'ret'
op|','
string|"'u'"
op|':'
name|'u'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InvalidCPUInfo'
op|'('
name|'reason'
op|'='
name|'m'
op|'%'
op|'{'
string|"'ret'"
op|':'
name|'ret'
op|','
string|"'u'"
op|':'
name|'u'
op|'}'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_create_shared_storage_test_file
dedent|''
dedent|''
name|'def'
name|'_create_shared_storage_test_file'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Makes tmpfile under CONF.instances_path."""'
newline|'\n'
name|'dirpath'
op|'='
name|'CONF'
op|'.'
name|'instances_path'
newline|'\n'
name|'fd'
op|','
name|'tmp_file'
op|'='
name|'tempfile'
op|'.'
name|'mkstemp'
op|'('
name|'dir'
op|'='
name|'dirpath'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Creating tmpfile %s to notify to other "'
nl|'\n'
string|'"compute nodes that they should mount "'
nl|'\n'
string|'"the same storage."'
op|','
name|'tmp_file'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'fd'
op|')'
newline|'\n'
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'tmp_file'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_check_shared_storage_test_file
dedent|''
name|'def'
name|'_check_shared_storage_test_file'
op|'('
name|'self'
op|','
name|'filename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Confirms existence of the tmpfile under CONF.instances_path.\n\n        Cannot confirm tmpfile return False.\n        """'
newline|'\n'
name|'tmp_file'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'CONF'
op|'.'
name|'instances_path'
op|','
name|'filename'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'tmp_file'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
DECL|member|_cleanup_shared_storage_test_file
dedent|''
dedent|''
name|'def'
name|'_cleanup_shared_storage_test_file'
op|'('
name|'self'
op|','
name|'filename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Removes existence of the tmpfile under CONF.instances_path."""'
newline|'\n'
name|'tmp_file'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'CONF'
op|'.'
name|'instances_path'
op|','
name|'filename'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'remove'
op|'('
name|'tmp_file'
op|')'
newline|'\n'
nl|'\n'
DECL|member|ensure_filtering_rules_for_instance
dedent|''
name|'def'
name|'ensure_filtering_rules_for_instance'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Ensure that an instance\'s filtering rules are enabled.\n\n        When migrating an instance, we need the filtering rules to\n        be configured on the destination host before starting the\n        migration.\n\n        Also, when restarting the compute service, we need to ensure\n        that filtering rules exist for all running services.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'setup_basic_filtering'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'prepare_instance_filter'
op|'('
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
comment|'# nwfilters may be defined in a separate thread in the case'
nl|'\n'
comment|'# of libvirt non-blocking mode, so we wait for completion'
nl|'\n'
name|'timeout_count'
op|'='
name|'list'
op|'('
name|'range'
op|'('
name|'CONF'
op|'.'
name|'live_migration_retry_count'
op|')'
op|')'
newline|'\n'
name|'while'
name|'timeout_count'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'instance_filter_exists'
op|'('
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'break'
newline|'\n'
dedent|''
name|'timeout_count'
op|'.'
name|'pop'
op|'('
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'timeout_count'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
name|'_'
op|'('
string|"'The firewall filter for %s does not exist'"
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|'%'
name|'instance'
op|'.'
name|'name'
op|')'
newline|'\n'
dedent|''
name|'greenthread'
op|'.'
name|'sleep'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
DECL|member|filter_defer_apply_on
dedent|''
dedent|''
name|'def'
name|'filter_defer_apply_on'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'filter_defer_apply_on'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|filter_defer_apply_off
dedent|''
name|'def'
name|'filter_defer_apply_off'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'filter_defer_apply_off'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|live_migration
dedent|''
name|'def'
name|'live_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
nl|'\n'
name|'post_method'
op|','
name|'recover_method'
op|','
name|'block_migration'
op|'='
name|'False'
op|','
nl|'\n'
name|'migrate_data'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Spawning live_migration operation for distributing high-load.\n\n        :param context: security context\n        :param instance:\n            nova.db.sqlalchemy.models.Instance object\n            instance object that is migrated.\n        :param dest: destination host\n        :param post_method:\n            post operation method.\n            expected nova.compute.manager._post_live_migration.\n        :param recover_method:\n            recovery method when any exception occurs.\n            expected nova.compute.manager._rollback_live_migration.\n        :param block_migration: if true, do block migration.\n        :param migrate_data: implementation specific params\n\n        """'
newline|'\n'
nl|'\n'
comment|"# 'dest' will be substituted into 'migration_uri' so ensure"
nl|'\n'
comment|"# it does't contain any characters that could be used to"
nl|'\n'
comment|'# exploit the URI accepted by libivrt'
nl|'\n'
name|'if'
name|'not'
name|'libvirt_utils'
op|'.'
name|'is_valid_hostname'
op|'('
name|'dest'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'InvalidHostname'
op|'('
name|'hostname'
op|'='
name|'dest'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'utils'
op|'.'
name|'spawn'
op|'('
name|'self'
op|'.'
name|'_live_migration'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
nl|'\n'
name|'post_method'
op|','
name|'recover_method'
op|','
name|'block_migration'
op|','
nl|'\n'
name|'migrate_data'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_update_xml
dedent|''
name|'def'
name|'_update_xml'
op|'('
name|'self'
op|','
name|'xml_str'
op|','
name|'volume'
op|','
name|'listen_addrs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'xml_doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml_str'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'volume'
op|':'
newline|'\n'
indent|'            '
name|'xml_doc'
op|'='
name|'self'
op|'.'
name|'_update_volume_xml'
op|'('
name|'xml_doc'
op|','
name|'volume'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'listen_addrs'
op|':'
newline|'\n'
indent|'            '
name|'xml_doc'
op|'='
name|'self'
op|'.'
name|'_update_graphics_xml'
op|'('
name|'xml_doc'
op|','
name|'listen_addrs'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_check_graphics_addresses_can_live_migrate'
op|'('
name|'listen_addrs'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'etree'
op|'.'
name|'tostring'
op|'('
name|'xml_doc'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_update_graphics_xml
dedent|''
name|'def'
name|'_update_graphics_xml'
op|'('
name|'self'
op|','
name|'xml_doc'
op|','
name|'listen_addrs'
op|')'
op|':'
newline|'\n'
nl|'\n'
comment|'# change over listen addresses'
nl|'\n'
indent|'        '
name|'for'
name|'dev'
name|'in'
name|'xml_doc'
op|'.'
name|'findall'
op|'('
string|"'./devices/graphics'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'gr_type'
op|'='
name|'dev'
op|'.'
name|'get'
op|'('
string|"'type'"
op|')'
newline|'\n'
name|'listen_tag'
op|'='
name|'dev'
op|'.'
name|'find'
op|'('
string|"'listen'"
op|')'
newline|'\n'
name|'if'
name|'gr_type'
name|'in'
op|'('
string|"'vnc'"
op|','
string|"'spice'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'listen_tag'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'listen_tag'
op|'.'
name|'set'
op|'('
string|"'address'"
op|','
name|'listen_addrs'
op|'['
name|'gr_type'
op|']'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'dev'
op|'.'
name|'get'
op|'('
string|"'listen'"
op|')'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'dev'
op|'.'
name|'set'
op|'('
string|"'listen'"
op|','
name|'listen_addrs'
op|'['
name|'gr_type'
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'xml_doc'
newline|'\n'
nl|'\n'
DECL|member|_update_volume_xml
dedent|''
name|'def'
name|'_update_volume_xml'
op|'('
name|'self'
op|','
name|'xml_doc'
op|','
name|'volume'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Update XML using device information of destination host."""'
newline|'\n'
nl|'\n'
comment|'# Update volume xml'
nl|'\n'
name|'parser'
op|'='
name|'etree'
op|'.'
name|'XMLParser'
op|'('
name|'remove_blank_text'
op|'='
name|'True'
op|')'
newline|'\n'
name|'disk_nodes'
op|'='
name|'xml_doc'
op|'.'
name|'findall'
op|'('
string|"'./devices/disk'"
op|')'
newline|'\n'
name|'for'
name|'pos'
op|','
name|'disk_dev'
name|'in'
name|'enumerate'
op|'('
name|'disk_nodes'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'serial_source'
op|'='
name|'disk_dev'
op|'.'
name|'findtext'
op|'('
string|"'serial'"
op|')'
newline|'\n'
name|'if'
name|'serial_source'
name|'is'
name|'None'
name|'or'
name|'volume'
op|'.'
name|'get'
op|'('
name|'serial_source'
op|')'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
string|"'connection_info'"
name|'not'
name|'in'
name|'volume'
op|'['
name|'serial_source'
op|']'
name|'or'
nl|'\n'
string|"'disk_info'"
name|'not'
name|'in'
name|'volume'
op|'['
name|'serial_source'
op|']'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'conf'
op|'='
name|'self'
op|'.'
name|'_get_volume_config'
op|'('
nl|'\n'
name|'volume'
op|'['
name|'serial_source'
op|']'
op|'['
string|"'connection_info'"
op|']'
op|','
nl|'\n'
name|'volume'
op|'['
name|'serial_source'
op|']'
op|'['
string|"'disk_info'"
op|']'
op|')'
newline|'\n'
name|'xml_doc2'
op|'='
name|'etree'
op|'.'
name|'XML'
op|'('
name|'conf'
op|'.'
name|'to_xml'
op|'('
op|')'
op|','
name|'parser'
op|')'
newline|'\n'
name|'serial_dest'
op|'='
name|'xml_doc2'
op|'.'
name|'findtext'
op|'('
string|"'serial'"
op|')'
newline|'\n'
nl|'\n'
comment|'# Compare source serial and destination serial number.'
nl|'\n'
comment|'# If these serial numbers match, continue the process.'
nl|'\n'
name|'if'
op|'('
name|'serial_dest'
name|'and'
op|'('
name|'serial_source'
op|'=='
name|'serial_dest'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Find same serial number: pos=%(pos)s, "'
nl|'\n'
string|'"serial=%(num)s"'
op|','
nl|'\n'
op|'{'
string|"'pos'"
op|':'
name|'pos'
op|','
string|"'num'"
op|':'
name|'serial_source'
op|'}'
op|')'
newline|'\n'
name|'for'
name|'cnt'
op|','
name|'item_src'
name|'in'
name|'enumerate'
op|'('
name|'disk_dev'
op|')'
op|':'
newline|'\n'
comment|'# If source and destination have same item, update'
nl|'\n'
comment|'# the item using destination value.'
nl|'\n'
indent|'                    '
name|'for'
name|'item_dst'
name|'in'
name|'xml_doc2'
op|'.'
name|'findall'
op|'('
name|'item_src'
op|'.'
name|'tag'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'disk_dev'
op|'.'
name|'remove'
op|'('
name|'item_src'
op|')'
newline|'\n'
name|'item_dst'
op|'.'
name|'tail'
op|'='
name|'None'
newline|'\n'
name|'disk_dev'
op|'.'
name|'insert'
op|'('
name|'cnt'
op|','
name|'item_dst'
op|')'
newline|'\n'
nl|'\n'
comment|'# If destination has additional items, thses items should be'
nl|'\n'
comment|'# added here.'
nl|'\n'
dedent|''
dedent|''
name|'for'
name|'item_dst'
name|'in'
name|'list'
op|'('
name|'xml_doc2'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'item_dst'
op|'.'
name|'tail'
op|'='
name|'None'
newline|'\n'
name|'disk_dev'
op|'.'
name|'insert'
op|'('
name|'cnt'
op|','
name|'item_dst'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'xml_doc'
newline|'\n'
nl|'\n'
DECL|member|_check_graphics_addresses_can_live_migrate
dedent|''
name|'def'
name|'_check_graphics_addresses_can_live_migrate'
op|'('
name|'self'
op|','
name|'listen_addrs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOCAL_ADDRS'
op|'='
op|'('
string|"'0.0.0.0'"
op|','
string|"'127.0.0.1'"
op|','
string|"'::'"
op|','
string|"'::1'"
op|')'
newline|'\n'
nl|'\n'
name|'local_vnc'
op|'='
name|'CONF'
op|'.'
name|'vnc'
op|'.'
name|'vncserver_listen'
name|'in'
name|'LOCAL_ADDRS'
newline|'\n'
name|'local_spice'
op|'='
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'server_listen'
name|'in'
name|'LOCAL_ADDRS'
newline|'\n'
nl|'\n'
name|'if'
op|'('
op|'('
name|'CONF'
op|'.'
name|'vnc'
op|'.'
name|'enabled'
name|'and'
name|'not'
name|'local_vnc'
op|')'
name|'or'
nl|'\n'
op|'('
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'enabled'
name|'and'
name|'not'
name|'local_spice'
op|')'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|"'Your libvirt version does not support the'"
nl|'\n'
string|"' VIR_DOMAIN_XML_MIGRATABLE flag or your'"
nl|'\n'
string|"' destination node does not support'"
nl|'\n'
string|"' retrieving listen addresses.  In order'"
nl|'\n'
string|"' for live migration to work properly, you'"
nl|'\n'
string|"' must configure the graphics (VNC and/or'"
nl|'\n'
string|"' SPICE) listen addresses to be either'"
nl|'\n'
string|"' the catch-all address (0.0.0.0 or ::) or'"
nl|'\n'
string|"' the local address (127.0.0.1 or ::1).'"
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'MigrationError'
op|'('
name|'reason'
op|'='
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'listen_addrs'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'dest_local_vnc'
op|'='
name|'listen_addrs'
op|'['
string|"'vnc'"
op|']'
name|'in'
name|'LOCAL_ADDRS'
newline|'\n'
name|'dest_local_spice'
op|'='
name|'listen_addrs'
op|'['
string|"'spice'"
op|']'
name|'in'
name|'LOCAL_ADDRS'
newline|'\n'
nl|'\n'
name|'if'
op|'('
op|'('
name|'CONF'
op|'.'
name|'vnc'
op|'.'
name|'enabled'
name|'and'
name|'not'
name|'dest_local_vnc'
op|')'
name|'or'
nl|'\n'
op|'('
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'enabled'
name|'and'
name|'not'
name|'dest_local_spice'
op|')'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'Your libvirt version does not support the'"
nl|'\n'
string|"' VIR_DOMAIN_XML_MIGRATABLE flag, and the '"
nl|'\n'
string|"' graphics (VNC and/or SPICE) listen'"
nl|'\n'
string|"' addresses on the destination node do not'"
nl|'\n'
string|"' match the addresses on the source node.'"
nl|'\n'
string|"' Since the source node has listen'"
nl|'\n'
string|"' addresses set to either the catch-all'"
nl|'\n'
string|"' address (0.0.0.0 or ::) or the local'"
nl|'\n'
string|"' address (127.0.0.1 or ::1), the live'"
nl|'\n'
string|"' migration will succeed, but the VM will'"
nl|'\n'
string|"' continue to listen on the current'"
nl|'\n'
string|"' addresses.'"
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_live_migration_operation
dedent|''
dedent|''
dedent|''
name|'def'
name|'_live_migration_operation'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
nl|'\n'
name|'block_migration'
op|','
name|'migrate_data'
op|','
name|'dom'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Invoke the live migration operation\n\n        :param context: security context\n        :param instance:\n            nova.db.sqlalchemy.models.Instance object\n            instance object that is migrated.\n        :param dest: destination host\n        :param block_migration: if true, do block migration.\n        :param migrate_data: implementation specific params\n        :param dom: the libvirt domain object\n\n        This method is intended to be run in a background thread and will\n        block that thread until the migration is finished or failed.\n        """'
newline|'\n'
comment|'# TODO(sahid): Should pass a guest to this method.'
nl|'\n'
name|'guest'
op|'='
name|'libvirt_guest'
op|'.'
name|'Guest'
op|'('
name|'dom'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'block_migration'
op|':'
newline|'\n'
indent|'                '
name|'flaglist'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'block_migration_flag'
op|'.'
name|'split'
op|'('
string|"','"
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'flaglist'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'live_migration_flag'
op|'.'
name|'split'
op|'('
string|"','"
op|')'
newline|'\n'
dedent|''
name|'flagvals'
op|'='
op|'['
name|'getattr'
op|'('
name|'libvirt'
op|','
name|'x'
op|'.'
name|'strip'
op|'('
op|')'
op|')'
name|'for'
name|'x'
name|'in'
name|'flaglist'
op|']'
newline|'\n'
name|'logical_sum'
op|'='
name|'reduce'
op|'('
name|'lambda'
name|'x'
op|','
name|'y'
op|':'
name|'x'
op|'|'
name|'y'
op|','
name|'flagvals'
op|')'
newline|'\n'
nl|'\n'
name|'pre_live_migrate_data'
op|'='
op|'('
name|'migrate_data'
name|'or'
op|'{'
op|'}'
op|')'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'pre_live_migration_result'"
op|','
op|'{'
op|'}'
op|')'
newline|'\n'
name|'listen_addrs'
op|'='
name|'pre_live_migrate_data'
op|'.'
name|'get'
op|'('
string|"'graphics_listen_addrs'"
op|')'
newline|'\n'
name|'volume'
op|'='
name|'pre_live_migrate_data'
op|'.'
name|'get'
op|'('
string|"'volume'"
op|')'
newline|'\n'
nl|'\n'
name|'migratable_flag'
op|'='
name|'getattr'
op|'('
name|'libvirt'
op|','
string|"'VIR_DOMAIN_XML_MIGRATABLE'"
op|','
nl|'\n'
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'if'
op|'('
name|'migratable_flag'
name|'is'
name|'None'
name|'or'
nl|'\n'
op|'('
name|'listen_addrs'
name|'is'
name|'None'
name|'and'
name|'not'
name|'volume'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_check_graphics_addresses_can_live_migrate'
op|'('
name|'listen_addrs'
op|')'
newline|'\n'
name|'dom'
op|'.'
name|'migrateToURI'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'live_migration_uri'
op|'%'
name|'dest'
op|','
nl|'\n'
name|'logical_sum'
op|','
nl|'\n'
name|'None'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'live_migration_bandwidth'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'old_xml_str'
op|'='
name|'guest'
op|'.'
name|'get_xml_desc'
op|'('
name|'dump_migratable'
op|'='
name|'True'
op|')'
newline|'\n'
name|'new_xml_str'
op|'='
name|'self'
op|'.'
name|'_update_xml'
op|'('
name|'old_xml_str'
op|','
nl|'\n'
name|'volume'
op|','
nl|'\n'
name|'listen_addrs'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'dom'
op|'.'
name|'migrateToURI2'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'live_migration_uri'
op|'%'
name|'dest'
op|','
nl|'\n'
name|'None'
op|','
nl|'\n'
name|'new_xml_str'
op|','
nl|'\n'
name|'logical_sum'
op|','
nl|'\n'
name|'None'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'live_migration_bandwidth'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
comment|'# NOTE(mriedem): There is a bug in older versions of'
nl|'\n'
comment|'# libvirt where the VIR_DOMAIN_XML_MIGRATABLE flag causes'
nl|'\n'
comment|'# virDomainDefCheckABIStability to not compare the source'
nl|'\n'
comment|"# and target domain xml's correctly for the CPU model."
nl|'\n'
comment|'# We try to handle that error here and attempt the legacy'
nl|'\n'
comment|'# migrateToURI path, which could fail if the console'
nl|'\n'
comment|'# addresses are not correct, but in that case we have the'
nl|'\n'
comment|'# _check_graphics_addresses_can_live_migrate check in place'
nl|'\n'
comment|'# to catch it.'
nl|'\n'
comment|'# TODO(mriedem): Remove this workaround when'
nl|'\n'
comment|'# Red Hat BZ #1141838 is closed.'
nl|'\n'
indent|'                    '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_CONFIG_UNSUPPORTED'
op|':'
newline|'\n'
indent|'                        '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'An error occurred trying to live '"
nl|'\n'
string|"'migrate. Falling back to legacy live '"
nl|'\n'
string|"'migrate flow. Error: %s'"
op|')'
op|','
name|'ex'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_check_graphics_addresses_can_live_migrate'
op|'('
nl|'\n'
name|'listen_addrs'
op|')'
newline|'\n'
name|'dom'
op|'.'
name|'migrateToURI'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'live_migration_uri'
op|'%'
name|'dest'
op|','
nl|'\n'
name|'logical_sum'
op|','
nl|'\n'
name|'None'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'live_migration_bandwidth'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|'"Live Migration failure: %s"'
op|')'
op|','
name|'e'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|"# If 'migrateToURI' fails we don't know what state the"
nl|'\n'
comment|'# VM instances on each host are in. Possibilities include'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#  1. src==running, dst==none'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     Migration failed & rolled back, or never started'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#  2. src==running, dst==paused'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     Migration started but is still ongoing'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#  3. src==paused,  dst==paused'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     Migration data transfer completed, but switchover'
nl|'\n'
comment|'#     is still ongoing, or failed'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#  4. src==paused,  dst==running'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     Migration data transfer completed, switchover'
nl|'\n'
comment|'#     happened but cleanup on source failed'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#  5. src==none,    dst==running'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#     Migration fully succeeded.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# Libvirt will aim to complete any migration operation'
nl|'\n'
comment|'# or roll it back. So even if the migrateToURI call has'
nl|'\n'
comment|'# returned an error, if the migration was not finished'
nl|'\n'
comment|'# libvirt should clean up.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# So we take the error raise here with a pinch of salt'
nl|'\n'
comment|'# and rely on the domain job info status to figure out'
nl|'\n'
comment|'# what really happened to the VM, which is a much more'
nl|'\n'
comment|'# reliable indicator.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# In particular we need to try very hard to ensure that'
nl|'\n'
comment|'# Nova does not "forget" about the guest. ie leaving it'
nl|'\n'
comment|'# running on a different host to the one recorded in'
nl|'\n'
comment|'# the database, as that would be a serious resource leak'
nl|'\n'
nl|'\n'
dedent|''
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Migration operation thread has finished"'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_live_migration_monitor
dedent|''
name|'def'
name|'_live_migration_monitor'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
name|'post_method'
op|','
nl|'\n'
name|'recover_method'
op|','
name|'block_migration'
op|','
nl|'\n'
name|'migrate_data'
op|','
name|'dom'
op|','
name|'finish_event'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'n'
op|'='
number|'0'
newline|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'info'
op|'='
name|'host'
op|'.'
name|'DomainJobInfo'
op|'.'
name|'for_domain'
op|'('
name|'dom'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'info'
op|'.'
name|'type'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_JOB_NONE'
op|':'
newline|'\n'
comment|'# Annoyingly this could indicate many possible'
nl|'\n'
comment|'# states, so we must fix the mess:'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#   1. Migration has not yet begun'
nl|'\n'
comment|'#   2. Migration has stopped due to failure'
nl|'\n'
comment|'#   3. Migration has stopped due to completion'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# We can detect option 1 by seeing if thread is still'
nl|'\n'
comment|'# running. We can distinguish 2 vs 3 by seeing if the'
nl|'\n'
comment|'# VM still exists & running on the current host'
nl|'\n'
comment|'#'
nl|'\n'
indent|'                '
name|'if'
name|'not'
name|'finish_event'
op|'.'
name|'ready'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Operation thread is still running"'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
comment|'# Leave type untouched'
nl|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'try'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'dom'
op|'.'
name|'isActive'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"VM running on src, migration failed"'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'info'
op|'.'
name|'type'
op|'='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_JOB_FAILED'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"VM is shutoff, migration finished"'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'info'
op|'.'
name|'type'
op|'='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_JOB_COMPLETED'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'                        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Error checking domain status %(ex)s"'
op|','
nl|'\n'
name|'ex'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_DOMAIN'
op|':'
newline|'\n'
indent|'                            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"VM is missing, migration finished"'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'info'
op|'.'
name|'type'
op|'='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_JOB_COMPLETED'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Error %(ex)s, migration failed"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'info'
op|'.'
name|'type'
op|'='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_JOB_FAILED'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'info'
op|'.'
name|'type'
op|'!='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_JOB_NONE'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Fixed incorrect job type to be %d"'
op|','
nl|'\n'
name|'info'
op|'.'
name|'type'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'info'
op|'.'
name|'type'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_JOB_NONE'
op|':'
newline|'\n'
comment|'# Migration is not yet started'
nl|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Migration not running yet"'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'info'
op|'.'
name|'type'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_JOB_UNBOUNDED'
op|':'
newline|'\n'
comment|"# We loop every 500ms, so don't log on every"
nl|'\n'
comment|'# iteration to avoid spamming logs for long'
nl|'\n'
comment|'# running migrations. Just once every 5 secs'
nl|'\n'
comment|'# is sufficient for developers to debug problems.'
nl|'\n'
comment|'# We log once every 30 seconds at info to help'
nl|'\n'
comment|'# admins see slow running migration operations'
nl|'\n'
comment|'# when debug logs are off.'
nl|'\n'
indent|'                '
name|'if'
op|'('
name|'n'
op|'%'
number|'10'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
comment|'# Ignoring memory_processed, as due to repeated'
nl|'\n'
comment|'# dirtying of data, this can be way larger than'
nl|'\n'
comment|"# memory_total. Best to just look at what's"
nl|'\n'
comment|"# remaining to copy and ignore what's done already"
nl|'\n'
comment|'#'
nl|'\n'
comment|'# TODO(berrange) perhaps we could include disk'
nl|'\n'
comment|'# transfer stats in the progress too, but it'
nl|'\n'
comment|'# might make memory info more obscure as large'
nl|'\n'
comment|'# disk sizes might dwarf memory size'
nl|'\n'
indent|'                    '
name|'remaining'
op|'='
number|'100'
newline|'\n'
name|'if'
name|'info'
op|'.'
name|'memory_total'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'                        '
name|'remaining'
op|'='
name|'round'
op|'('
name|'info'
op|'.'
name|'memory_remaining'
op|'*'
nl|'\n'
number|'100'
op|'/'
name|'info'
op|'.'
name|'memory_total'
op|')'
newline|'\n'
dedent|''
name|'instance'
op|'.'
name|'progress'
op|'='
number|'100'
op|'-'
name|'remaining'
newline|'\n'
name|'instance'
op|'.'
name|'save'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'lg'
op|'='
name|'LOG'
op|'.'
name|'debug'
newline|'\n'
name|'if'
op|'('
name|'n'
op|'%'
number|'60'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                        '
name|'lg'
op|'='
name|'LOG'
op|'.'
name|'info'
newline|'\n'
nl|'\n'
dedent|''
name|'lg'
op|'('
name|'_LI'
op|'('
string|'"Migration running for %(secs)d secs, "'
nl|'\n'
string|'"memory %(remaining)d%% remaining; "'
nl|'\n'
string|'"(bytes processed=%(processed_memory)d, "'
nl|'\n'
string|'"remaining=%(remaining_memory)d, "'
nl|'\n'
string|'"total=%(total_memory)d)"'
op|')'
op|','
nl|'\n'
op|'{'
string|'"secs"'
op|':'
name|'n'
op|'/'
number|'2'
op|','
string|'"remaining"'
op|':'
name|'remaining'
op|','
nl|'\n'
string|'"processed_memory"'
op|':'
name|'info'
op|'.'
name|'memory_processed'
op|','
nl|'\n'
string|'"remaining_memory"'
op|':'
name|'info'
op|'.'
name|'memory_remaining'
op|','
nl|'\n'
string|'"total_memory"'
op|':'
name|'info'
op|'.'
name|'memory_total'
op|'}'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# Migration is still running'
nl|'\n'
comment|'#'
nl|'\n'
comment|"# This is where we'd wire up calls to change live"
nl|'\n'
comment|'# migration status. eg change max downtime, cancel'
nl|'\n'
comment|'# the operation, change max bandwidth'
nl|'\n'
dedent|''
name|'n'
op|'='
name|'n'
op|'+'
number|'1'
newline|'\n'
dedent|''
name|'elif'
name|'info'
op|'.'
name|'type'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_JOB_COMPLETED'
op|':'
newline|'\n'
comment|'# Migration is all done'
nl|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Migration operation has completed"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'post_method'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
name|'block_migration'
op|','
nl|'\n'
name|'migrate_data'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'elif'
name|'info'
op|'.'
name|'type'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_JOB_FAILED'
op|':'
newline|'\n'
comment|'# Migration did not succeed'
nl|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|'"Migration operation has aborted"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'recover_method'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
name|'block_migration'
op|','
nl|'\n'
name|'migrate_data'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'elif'
name|'info'
op|'.'
name|'type'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_JOB_CANCELLED'
op|':'
newline|'\n'
comment|'# Migration was stopped by admin'
nl|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Migration operation was cancelled"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'recover_method'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
name|'block_migration'
op|','
nl|'\n'
name|'migrate_data'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Unexpected migration job type: %d"'
op|')'
op|','
nl|'\n'
name|'info'
op|'.'
name|'type'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'time'
op|'.'
name|'sleep'
op|'('
number|'0.5'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_live_migration
dedent|''
dedent|''
name|'def'
name|'_live_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
name|'post_method'
op|','
nl|'\n'
name|'recover_method'
op|','
name|'block_migration'
op|','
nl|'\n'
name|'migrate_data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Do live migration.\n\n        :param context: security context\n        :param instance:\n            nova.db.sqlalchemy.models.Instance object\n            instance object that is migrated.\n        :param dest: destination host\n        :param post_method:\n            post operation method.\n            expected nova.compute.manager._post_live_migration.\n        :param recover_method:\n            recovery method when any exception occurs.\n            expected nova.compute.manager._rollback_live_migration.\n        :param block_migration: if true, do block migration.\n        :param migrate_data: implementation specific params\n\n        This fires off a new thread to run the blocking migration\n        operation, and then this thread monitors the progress of\n        migration and controls its operation\n        """'
newline|'\n'
nl|'\n'
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(sahid): We are converting all calls from a'
nl|'\n'
comment|'# virDomain object to use nova.virt.libvirt.Guest.'
nl|'\n'
comment|'# We should be able to remove dom at the end.'
nl|'\n'
name|'dom'
op|'='
name|'guest'
op|'.'
name|'_domain'
newline|'\n'
nl|'\n'
name|'opthread'
op|'='
name|'utils'
op|'.'
name|'spawn'
op|'('
name|'self'
op|'.'
name|'_live_migration_operation'
op|','
nl|'\n'
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
nl|'\n'
name|'block_migration'
op|','
nl|'\n'
name|'migrate_data'
op|','
name|'dom'
op|')'
newline|'\n'
nl|'\n'
name|'finish_event'
op|'='
name|'eventlet'
op|'.'
name|'event'
op|'.'
name|'Event'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|thread_finished
name|'def'
name|'thread_finished'
op|'('
name|'thread'
op|','
name|'event'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Migration operation thread notification"'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'event'
op|'.'
name|'send'
op|'('
op|')'
newline|'\n'
dedent|''
name|'opthread'
op|'.'
name|'link'
op|'('
name|'thread_finished'
op|','
name|'finish_event'
op|')'
newline|'\n'
nl|'\n'
comment|'# Let eventlet schedule the new thread right away'
nl|'\n'
name|'time'
op|'.'
name|'sleep'
op|'('
number|'0'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Starting monitoring of live migration"'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_live_migration_monitor'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
nl|'\n'
name|'post_method'
op|','
name|'recover_method'
op|','
nl|'\n'
name|'block_migration'
op|','
name|'migrate_data'
op|','
nl|'\n'
name|'dom'
op|','
name|'finish_event'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Error monitoring migration: %(ex)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|'"ex"'
op|':'
name|'ex'
op|'}'
op|','
name|'instance'
op|'='
name|'instance'
op|','
name|'exc_info'
op|'='
name|'True'
op|')'
newline|'\n'
name|'raise'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Live migration monitoring is all done"'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_try_fetch_image
dedent|''
dedent|''
name|'def'
name|'_try_fetch_image'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'path'
op|','
name|'image_id'
op|','
name|'instance'
op|','
nl|'\n'
name|'fallback_from_host'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'libvirt_utils'
op|'.'
name|'fetch_image'
op|'('
name|'context'
op|','
name|'path'
op|','
nl|'\n'
name|'image_id'
op|','
nl|'\n'
name|'instance'
op|'.'
name|'user_id'
op|','
nl|'\n'
name|'instance'
op|'.'
name|'project_id'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'ImageNotFound'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'fallback_from_host'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Image %(image_id)s doesn\'t exist anymore on "'
nl|'\n'
string|'"image service, attempting to copy image "'
nl|'\n'
string|'"from %(host)s"'
op|','
nl|'\n'
op|'{'
string|"'image_id'"
op|':'
name|'image_id'
op|','
string|"'host'"
op|':'
name|'fallback_from_host'
op|'}'
op|')'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'copy_image'
op|'('
name|'src'
op|'='
name|'path'
op|','
name|'dest'
op|'='
name|'path'
op|','
nl|'\n'
name|'host'
op|'='
name|'fallback_from_host'
op|','
nl|'\n'
name|'receive'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_fetch_instance_kernel_ramdisk
dedent|''
dedent|''
name|'def'
name|'_fetch_instance_kernel_ramdisk'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'fallback_from_host'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Download kernel and ramdisk for instance in instance directory."""'
newline|'\n'
name|'instance_dir'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'instance'
op|'.'
name|'kernel_id'
op|':'
newline|'\n'
indent|'            '
name|'kernel_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
string|"'kernel'"
op|')'
newline|'\n'
comment|"# NOTE(dsanders): only fetch image if it's not available at"
nl|'\n'
comment|'# kernel_path. This also avoids ImageNotFound exception if'
nl|'\n'
comment|'# the image has been deleted from glance'
nl|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'kernel_path'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_try_fetch_image'
op|'('
name|'context'
op|','
nl|'\n'
name|'kernel_path'
op|','
nl|'\n'
name|'instance'
op|'.'
name|'kernel_id'
op|','
nl|'\n'
name|'instance'
op|','
name|'fallback_from_host'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'instance'
op|'.'
name|'ramdisk_id'
op|':'
newline|'\n'
indent|'                '
name|'ramdisk_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
string|"'ramdisk'"
op|')'
newline|'\n'
comment|"# NOTE(dsanders): only fetch image if it's not available at"
nl|'\n'
comment|'# ramdisk_path. This also avoids ImageNotFound exception if'
nl|'\n'
comment|'# the image has been deleted from glance'
nl|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'ramdisk_path'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_try_fetch_image'
op|'('
name|'context'
op|','
nl|'\n'
name|'ramdisk_path'
op|','
nl|'\n'
name|'instance'
op|'.'
name|'ramdisk_id'
op|','
nl|'\n'
name|'instance'
op|','
name|'fallback_from_host'
op|')'
newline|'\n'
nl|'\n'
DECL|member|rollback_live_migration_at_destination
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'rollback_live_migration_at_destination'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|','
nl|'\n'
name|'destroy_disks'
op|'='
name|'True'
op|','
nl|'\n'
name|'migrate_data'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Clean up destination node after a failed live migration."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'destroy'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|','
nl|'\n'
name|'destroy_disks'
op|','
name|'migrate_data'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
comment|'# NOTE(gcb): Failed block live migration may leave instance'
nl|'\n'
comment|'# directory at destination node, ensure it is always deleted.'
nl|'\n'
indent|'            '
name|'is_shared_instance_path'
op|'='
name|'True'
newline|'\n'
name|'if'
name|'migrate_data'
op|':'
newline|'\n'
indent|'                '
name|'is_shared_instance_path'
op|'='
name|'migrate_data'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'is_shared_instance_path'"
op|','
name|'True'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'not'
name|'is_shared_instance_path'
op|':'
newline|'\n'
indent|'                '
name|'instance_dir'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path_at_destination'
op|'('
nl|'\n'
name|'instance'
op|','
name|'migrate_data'
op|')'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'instance_dir'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'shutil'
op|'.'
name|'rmtree'
op|'('
name|'instance_dir'
op|')'
newline|'\n'
nl|'\n'
DECL|member|pre_live_migration
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'pre_live_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'block_device_info'
op|','
nl|'\n'
name|'network_info'
op|','
name|'disk_info'
op|','
name|'migrate_data'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Preparation live migration."""'
newline|'\n'
name|'if'
name|'disk_info'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'disk_info'
op|'='
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
comment|'# Steps for volume backed instance live migration w/o shared storage.'
nl|'\n'
dedent|''
name|'is_shared_block_storage'
op|'='
name|'True'
newline|'\n'
name|'is_shared_instance_path'
op|'='
name|'True'
newline|'\n'
name|'is_block_migration'
op|'='
name|'True'
newline|'\n'
name|'if'
name|'migrate_data'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'migrate_data in pre_live_migration: %s'"
op|','
name|'migrate_data'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'is_shared_block_storage'
op|'='
name|'migrate_data'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'is_shared_block_storage'"
op|','
name|'True'
op|')'
newline|'\n'
name|'is_shared_instance_path'
op|'='
name|'migrate_data'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'is_shared_instance_path'"
op|','
name|'True'
op|')'
newline|'\n'
name|'is_block_migration'
op|'='
name|'migrate_data'
op|'.'
name|'get'
op|'('
string|"'block_migration'"
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'image_meta'
op|'='
name|'utils'
op|'.'
name|'get_image_from_system_metadata'
op|'('
nl|'\n'
name|'instance'
op|'.'
name|'system_metadata'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
op|'('
name|'is_shared_instance_path'
name|'and'
name|'is_shared_block_storage'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(dims): Using config drive with iso format does not work'
nl|'\n'
comment|'# because of a bug in libvirt with read only devices. However'
nl|'\n'
comment|'# one can use vfat as config_drive_format which works fine.'
nl|'\n'
comment|'# Please see bug/1246201 for details on the libvirt bug.'
nl|'\n'
indent|'            '
name|'if'
name|'CONF'
op|'.'
name|'config_drive_format'
op|'!='
string|"'vfat'"
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'configdrive'
op|'.'
name|'required_by'
op|'('
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'exception'
op|'.'
name|'NoLiveMigrationForConfigDriveInLibVirt'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'not'
name|'is_shared_instance_path'
op|':'
newline|'\n'
indent|'            '
name|'instance_dir'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path_at_destination'
op|'('
nl|'\n'
name|'instance'
op|','
name|'migrate_data'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'instance_dir'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'DestinationDiskExists'
op|'('
name|'path'
op|'='
name|'instance_dir'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Creating instance directory: %s'"
op|','
name|'instance_dir'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'mkdir'
op|'('
name|'instance_dir'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'is_shared_block_storage'
op|':'
newline|'\n'
comment|'# Ensure images and backing files are present.'
nl|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Checking to make sure images and backing files are '"
nl|'\n'
string|"'present before live migration.'"
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_images_and_backing'
op|'('
nl|'\n'
name|'context'
op|','
name|'instance'
op|','
name|'instance_dir'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'fallback_from_host'
op|'='
name|'instance'
op|'.'
name|'host'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
op|'('
name|'is_block_migration'
name|'or'
name|'is_shared_instance_path'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(angdraug): when block storage is shared between source and'
nl|'\n'
comment|"# destination and instance path isn't (e.g. volume backed or rbd"
nl|'\n'
comment|'# backed instance), instance path on destination has to be prepared'
nl|'\n'
nl|'\n'
comment|'# Touch the console.log file, required by libvirt.'
nl|'\n'
indent|'            '
name|'console_file'
op|'='
name|'self'
op|'.'
name|'_get_console_log_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Touch instance console log: %s'"
op|','
name|'console_file'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'file_open'
op|'('
name|'console_file'
op|','
string|"'a'"
op|')'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# if image has kernel and ramdisk, just download'
nl|'\n'
comment|'# following normal way.'
nl|'\n'
name|'self'
op|'.'
name|'_fetch_instance_kernel_ramdisk'
op|'('
name|'context'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# Establishing connection to volume server.'
nl|'\n'
dedent|''
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'block_device_mapping'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Connecting volumes before live migration.'"
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'vol'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'            '
name|'connection_info'
op|'='
name|'vol'
op|'['
string|"'connection_info'"
op|']'
newline|'\n'
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_info_from_bdm'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
name|'image_meta'
op|','
name|'vol'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_connect_volume'
op|'('
name|'connection_info'
op|','
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'is_block_migration'
name|'and'
name|'len'
op|'('
name|'block_device_mapping'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(stpierre): if this instance has mapped volumes,'
nl|'\n'
comment|"# we can't do a block migration, since that will"
nl|'\n'
comment|'# result in volumes being copied from themselves to'
nl|'\n'
comment|'# themselves, which is a recipe for disaster.'
nl|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'error'
op|'('
nl|'\n'
name|'_LE'
op|'('
string|"'Cannot block migrate instance %s with mapped volumes'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|"'Cannot block migrate instance %s with mapped volumes'"
op|')'
op|'%'
nl|'\n'
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'MigrationError'
op|'('
name|'reason'
op|'='
name|'msg'
op|')'
newline|'\n'
nl|'\n'
comment|'# We call plug_vifs before the compute manager calls'
nl|'\n'
comment|'# ensure_filtering_rules_for_instance, to ensure bridge is set up'
nl|'\n'
comment|'# Retry operation is necessary because continuously request comes,'
nl|'\n'
comment|'# concurrent request occurs to iptables, then it complains.'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Plugging VIFs before live migration.'"
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'max_retry'
op|'='
name|'CONF'
op|'.'
name|'live_migration_retry_count'
newline|'\n'
name|'for'
name|'cnt'
name|'in'
name|'range'
op|'('
name|'max_retry'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'plug_vifs'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'except'
name|'processutils'
op|'.'
name|'ProcessExecutionError'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'cnt'
op|'=='
name|'max_retry'
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'plug_vifs() failed %(cnt)d. Retry up to '"
nl|'\n'
string|"'%(max_retry)d.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'cnt'"
op|':'
name|'cnt'
op|','
nl|'\n'
string|"'max_retry'"
op|':'
name|'max_retry'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'greenthread'
op|'.'
name|'sleep'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
comment|'# Store vncserver_listen and latest disk device info'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'res_data'
op|'='
op|'{'
string|"'graphics_listen_addrs'"
op|':'
op|'{'
op|'}'
op|','
string|"'volume'"
op|':'
op|'{'
op|'}'
op|'}'
newline|'\n'
name|'res_data'
op|'['
string|"'graphics_listen_addrs'"
op|']'
op|'['
string|"'vnc'"
op|']'
op|'='
name|'CONF'
op|'.'
name|'vnc'
op|'.'
name|'vncserver_listen'
newline|'\n'
name|'res_data'
op|'['
string|"'graphics_listen_addrs'"
op|']'
op|'['
string|"'spice'"
op|']'
op|'='
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'server_listen'
newline|'\n'
name|'for'
name|'vol'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'            '
name|'connection_info'
op|'='
name|'vol'
op|'['
string|"'connection_info'"
op|']'
newline|'\n'
name|'if'
name|'connection_info'
op|'.'
name|'get'
op|'('
string|"'serial'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'serial'
op|'='
name|'connection_info'
op|'['
string|"'serial'"
op|']'
newline|'\n'
name|'res_data'
op|'['
string|"'volume'"
op|']'
op|'['
name|'serial'
op|']'
op|'='
op|'{'
string|"'connection_info'"
op|':'
op|'{'
op|'}'
op|','
nl|'\n'
string|"'disk_info'"
op|':'
op|'{'
op|'}'
op|'}'
newline|'\n'
name|'res_data'
op|'['
string|"'volume'"
op|']'
op|'['
name|'serial'
op|']'
op|'['
string|"'connection_info'"
op|']'
op|'='
name|'connection_info'
newline|'\n'
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_info_from_bdm'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
name|'image_meta'
op|','
name|'vol'
op|')'
newline|'\n'
name|'res_data'
op|'['
string|"'volume'"
op|']'
op|'['
name|'serial'
op|']'
op|'['
string|"'disk_info'"
op|']'
op|'='
name|'disk_info'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'res_data'
newline|'\n'
nl|'\n'
DECL|member|_try_fetch_image_cache
dedent|''
name|'def'
name|'_try_fetch_image_cache'
op|'('
name|'self'
op|','
name|'image'
op|','
name|'fetch_func'
op|','
name|'context'
op|','
name|'filename'
op|','
nl|'\n'
name|'image_id'
op|','
name|'instance'
op|','
name|'size'
op|','
nl|'\n'
name|'fallback_from_host'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'image'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'fetch_func'
op|','
nl|'\n'
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'filename'
op|'='
name|'filename'
op|','
nl|'\n'
name|'image_id'
op|'='
name|'image_id'
op|','
nl|'\n'
name|'user_id'
op|'='
name|'instance'
op|'.'
name|'user_id'
op|','
nl|'\n'
name|'project_id'
op|'='
name|'instance'
op|'.'
name|'project_id'
op|','
nl|'\n'
name|'size'
op|'='
name|'size'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'ImageNotFound'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'fallback_from_host'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Image %(image_id)s doesn\'t exist anymore "'
nl|'\n'
string|'"on image service, attempting to copy "'
nl|'\n'
string|'"image from %(host)s"'
op|','
nl|'\n'
op|'{'
string|"'image_id'"
op|':'
name|'image_id'
op|','
string|"'host'"
op|':'
name|'fallback_from_host'
op|'}'
op|')'
newline|'\n'
nl|'\n'
DECL|function|copy_from_host
name|'def'
name|'copy_from_host'
op|'('
name|'target'
op|','
name|'max_size'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'libvirt_utils'
op|'.'
name|'copy_image'
op|'('
name|'src'
op|'='
name|'target'
op|','
nl|'\n'
name|'dest'
op|'='
name|'target'
op|','
nl|'\n'
name|'host'
op|'='
name|'fallback_from_host'
op|','
nl|'\n'
name|'receive'
op|'='
name|'True'
op|')'
newline|'\n'
dedent|''
name|'image'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'copy_from_host'
op|','
nl|'\n'
name|'filename'
op|'='
name|'filename'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_create_images_and_backing
dedent|''
dedent|''
name|'def'
name|'_create_images_and_backing'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'instance_dir'
op|','
nl|'\n'
name|'disk_info'
op|','
name|'fallback_from_host'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""":param context: security context\n           :param instance:\n               nova.db.sqlalchemy.models.Instance object\n               instance object that is migrated.\n           :param instance_dir:\n               instance path to use, calculated externally to handle block\n               migrating an instance with an old style instance path\n           :param disk_info:\n               disk info specified in _get_instance_disk_info\n           :param fallback_from_host:\n               host where we can retrieve images if the glance images are\n               not available.\n\n        """'
newline|'\n'
name|'if'
name|'not'
name|'disk_info'
op|':'
newline|'\n'
indent|'            '
name|'disk_info'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'info'
name|'in'
name|'disk_info'
op|':'
newline|'\n'
indent|'            '
name|'base'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'info'
op|'['
string|"'path'"
op|']'
op|')'
newline|'\n'
comment|'# Get image type and create empty disk image, and'
nl|'\n'
comment|'# create backing file in case of qcow2.'
nl|'\n'
name|'instance_disk'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
name|'base'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'info'
op|'['
string|"'backing_file'"
op|']'
name|'and'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'instance_disk'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'libvirt_utils'
op|'.'
name|'create_image'
op|'('
name|'info'
op|'['
string|"'type'"
op|']'
op|','
name|'instance_disk'
op|','
nl|'\n'
name|'info'
op|'['
string|"'virt_disk_size'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'info'
op|'['
string|"'backing_file'"
op|']'
op|':'
newline|'\n'
comment|'# Creating backing file follows same way as spawning instances.'
nl|'\n'
indent|'                '
name|'cache_name'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'info'
op|'['
string|"'backing_file'"
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'image'
op|'='
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'image'
op|'('
name|'instance'
op|','
nl|'\n'
name|'instance_disk'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_type'
op|')'
newline|'\n'
name|'if'
name|'cache_name'
op|'.'
name|'startswith'
op|'('
string|"'ephemeral'"
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'image'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'self'
op|'.'
name|'_create_ephemeral'
op|','
nl|'\n'
name|'fs_label'
op|'='
name|'cache_name'
op|','
nl|'\n'
name|'os_type'
op|'='
name|'instance'
op|'.'
name|'os_type'
op|','
nl|'\n'
name|'filename'
op|'='
name|'cache_name'
op|','
nl|'\n'
name|'size'
op|'='
name|'info'
op|'['
string|"'virt_disk_size'"
op|']'
op|','
nl|'\n'
name|'ephemeral_size'
op|'='
name|'instance'
op|'.'
name|'ephemeral_gb'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'cache_name'
op|'.'
name|'startswith'
op|'('
string|"'swap'"
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'inst_type'
op|'='
name|'instance'
op|'.'
name|'get_flavor'
op|'('
op|')'
newline|'\n'
name|'swap_mb'
op|'='
name|'inst_type'
op|'.'
name|'swap'
newline|'\n'
name|'image'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'self'
op|'.'
name|'_create_swap'
op|','
nl|'\n'
name|'filename'
op|'='
string|'"swap_%s"'
op|'%'
name|'swap_mb'
op|','
nl|'\n'
name|'size'
op|'='
name|'swap_mb'
op|'*'
name|'units'
op|'.'
name|'Mi'
op|','
nl|'\n'
name|'swap_mb'
op|'='
name|'swap_mb'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_try_fetch_image_cache'
op|'('
name|'image'
op|','
nl|'\n'
name|'libvirt_utils'
op|'.'
name|'fetch_image'
op|','
nl|'\n'
name|'context'
op|','
name|'cache_name'
op|','
nl|'\n'
name|'instance'
op|'.'
name|'image_ref'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'info'
op|'['
string|"'virt_disk_size'"
op|']'
op|','
nl|'\n'
name|'fallback_from_host'
op|')'
newline|'\n'
nl|'\n'
comment|'# if image has kernel and ramdisk, just download'
nl|'\n'
comment|'# following normal way.'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'self'
op|'.'
name|'_fetch_instance_kernel_ramdisk'
op|'('
nl|'\n'
name|'context'
op|','
name|'instance'
op|','
name|'fallback_from_host'
op|'='
name|'fallback_from_host'
op|')'
newline|'\n'
nl|'\n'
DECL|member|post_live_migration
dedent|''
name|'def'
name|'post_live_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'block_device_info'
op|','
nl|'\n'
name|'migrate_data'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
comment|'# Disconnect from volume server'
nl|'\n'
indent|'        '
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'for'
name|'vol'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'            '
name|'connection_info'
op|'='
name|'vol'
op|'['
string|"'connection_info'"
op|']'
newline|'\n'
name|'disk_dev'
op|'='
name|'vol'
op|'['
string|"'mount_device'"
op|']'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_disconnect_volume'
op|'('
name|'connection_info'
op|','
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
DECL|member|post_live_migration_at_source
dedent|''
dedent|''
name|'def'
name|'post_live_migration_at_source'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Unplug VIFs from networks at source.\n\n        :param context: security context\n        :param instance: instance object reference\n        :param network_info: instance network information\n        """'
newline|'\n'
name|'self'
op|'.'
name|'unplug_vifs'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|post_live_migration_at_destination
dedent|''
name|'def'
name|'post_live_migration_at_destination'
op|'('
name|'self'
op|','
name|'context'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|','
nl|'\n'
name|'block_migration'
op|'='
name|'False'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Post operation of live migration at destination host.\n\n        :param context: security context\n        :param instance:\n            nova.db.sqlalchemy.models.Instance object\n            instance object that is migrated.\n        :param network_info: instance network information\n        :param block_migration: if true, post operation of block_migration.\n        """'
newline|'\n'
comment|'# Define migrated instance, otherwise, suspend/destroy does not work.'
nl|'\n'
name|'image_meta'
op|'='
name|'utils'
op|'.'
name|'get_image_from_system_metadata'
op|'('
nl|'\n'
name|'instance'
op|'.'
name|'system_metadata'
op|')'
newline|'\n'
comment|'# In case of block migration, destination does not have'
nl|'\n'
comment|'# libvirt.xml'
nl|'\n'
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
name|'instance'
op|','
nl|'\n'
name|'image_meta'
op|','
name|'block_device_info'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_guest_xml'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|','
nl|'\n'
name|'write_to_disk'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'write_instance_config'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_instance_disk_info
dedent|''
name|'def'
name|'_get_instance_disk_info'
op|'('
name|'self'
op|','
name|'instance_name'
op|','
name|'xml'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
name|'volume_devices'
op|'='
name|'set'
op|'('
op|')'
newline|'\n'
name|'for'
name|'vol'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'            '
name|'disk_dev'
op|'='
name|'vol'
op|'['
string|"'mount_device'"
op|']'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'volume_devices'
op|'.'
name|'add'
op|'('
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'disk_info'
op|'='
op|'['
op|']'
newline|'\n'
name|'doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
name|'disk_nodes'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
string|"'.//devices/disk'"
op|')'
newline|'\n'
name|'path_nodes'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
string|"'.//devices/disk/source'"
op|')'
newline|'\n'
name|'driver_nodes'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
string|"'.//devices/disk/driver'"
op|')'
newline|'\n'
name|'target_nodes'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
string|"'.//devices/disk/target'"
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'cnt'
op|','
name|'path_node'
name|'in'
name|'enumerate'
op|'('
name|'path_nodes'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'disk_type'
op|'='
name|'disk_nodes'
op|'['
name|'cnt'
op|']'
op|'.'
name|'get'
op|'('
string|"'type'"
op|')'
newline|'\n'
name|'path'
op|'='
name|'path_node'
op|'.'
name|'get'
op|'('
string|"'file'"
op|')'
name|'or'
name|'path_node'
op|'.'
name|'get'
op|'('
string|"'dev'"
op|')'
newline|'\n'
name|'target'
op|'='
name|'target_nodes'
op|'['
name|'cnt'
op|']'
op|'.'
name|'attrib'
op|'['
string|"'dev'"
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'path'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'skipping disk for %s as it does not have a path'"
op|','
nl|'\n'
name|'instance_name'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'disk_type'
name|'not'
name|'in'
op|'['
string|"'file'"
op|','
string|"'block'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'skipping disk because it looks like a volume'"
op|','
name|'path'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'target'
name|'in'
name|'volume_devices'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'skipping disk %(path)s (%(target)s) as it is a '"
nl|'\n'
string|"'volume'"
op|','
op|'{'
string|"'path'"
op|':'
name|'path'
op|','
string|"'target'"
op|':'
name|'target'
op|'}'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
comment|'# get the real disk size or'
nl|'\n'
comment|'# raise a localized error if image is unavailable'
nl|'\n'
dedent|''
name|'if'
name|'disk_type'
op|'=='
string|"'file'"
op|':'
newline|'\n'
indent|'                '
name|'dk_size'
op|'='
name|'int'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'getsize'
op|'('
name|'path'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'disk_type'
op|'=='
string|"'block'"
name|'and'
name|'block_device_info'
op|':'
newline|'\n'
indent|'                '
name|'dk_size'
op|'='
name|'lvm'
op|'.'
name|'get_volume_size'
op|'('
name|'path'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'skipping disk %(path)s (%(target)s) - unable to '"
nl|'\n'
string|"'determine if volume'"
op|','
nl|'\n'
op|'{'
string|"'path'"
op|':'
name|'path'
op|','
string|"'target'"
op|':'
name|'target'
op|'}'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'disk_type'
op|'='
name|'driver_nodes'
op|'['
name|'cnt'
op|']'
op|'.'
name|'get'
op|'('
string|"'type'"
op|')'
newline|'\n'
name|'if'
name|'disk_type'
op|'=='
string|'"qcow2"'
op|':'
newline|'\n'
indent|'                '
name|'backing_file'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_disk_backing_file'
op|'('
name|'path'
op|')'
newline|'\n'
name|'virt_size'
op|'='
name|'disk'
op|'.'
name|'get_disk_size'
op|'('
name|'path'
op|')'
newline|'\n'
name|'over_commit_size'
op|'='
name|'int'
op|'('
name|'virt_size'
op|')'
op|'-'
name|'dk_size'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'backing_file'
op|'='
string|'""'
newline|'\n'
name|'virt_size'
op|'='
name|'dk_size'
newline|'\n'
name|'over_commit_size'
op|'='
number|'0'
newline|'\n'
nl|'\n'
dedent|''
name|'disk_info'
op|'.'
name|'append'
op|'('
op|'{'
string|"'type'"
op|':'
name|'disk_type'
op|','
nl|'\n'
string|"'path'"
op|':'
name|'path'
op|','
nl|'\n'
string|"'virt_disk_size'"
op|':'
name|'virt_size'
op|','
nl|'\n'
string|"'backing_file'"
op|':'
name|'backing_file'
op|','
nl|'\n'
string|"'disk_size'"
op|':'
name|'dk_size'
op|','
nl|'\n'
string|"'over_committed_disk_size'"
op|':'
name|'over_commit_size'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'disk_info'
newline|'\n'
nl|'\n'
DECL|member|get_instance_disk_info
dedent|''
name|'def'
name|'get_instance_disk_info'
op|'('
name|'self'
op|','
name|'instance'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'guest'
op|'.'
name|'get_xml_desc'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'Error from libvirt while getting description of '"
nl|'\n'
string|"'%(instance_name)s: [Error Code %(error_code)s] '"
nl|'\n'
string|"'%(ex)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'instance_name'"
op|':'
name|'instance'
op|'.'
name|'name'
op|','
nl|'\n'
string|"'error_code'"
op|':'
name|'error_code'
op|','
nl|'\n'
string|"'ex'"
op|':'
name|'ex'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|'('
name|'instance_id'
op|'='
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_get_instance_disk_info'
op|'('
name|'instance'
op|'.'
name|'name'
op|','
name|'xml'
op|','
nl|'\n'
name|'block_device_info'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_disk_over_committed_size_total
dedent|''
name|'def'
name|'_get_disk_over_committed_size_total'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return total over committed disk size for all instances."""'
newline|'\n'
comment|'# Disk size that all instance uses : virtual_size - disk_size'
nl|'\n'
name|'disk_over_committed_size'
op|'='
number|'0'
newline|'\n'
name|'for'
name|'dom'
name|'in'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'list_instance_domains'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
comment|'# TODO(sahid): list_instance_domain should'
nl|'\n'
comment|'# be renamed as list_guest and so returning'
nl|'\n'
comment|'# Guest objects.'
nl|'\n'
indent|'                '
name|'guest'
op|'='
name|'libvirt_guest'
op|'.'
name|'Guest'
op|'('
name|'dom'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'guest'
op|'.'
name|'get_xml_desc'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'disk_infos'
op|'='
name|'self'
op|'.'
name|'_get_instance_disk_info'
op|'('
name|'guest'
op|'.'
name|'name'
op|','
name|'xml'
op|')'
newline|'\n'
name|'for'
name|'info'
name|'in'
name|'disk_infos'
op|':'
newline|'\n'
indent|'                    '
name|'disk_over_committed_size'
op|'+='
name|'int'
op|'('
nl|'\n'
name|'info'
op|'['
string|"'over_committed_disk_size'"
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'                '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
nl|'\n'
string|"'Error from libvirt while getting description of '"
nl|'\n'
string|"'%(instance_name)s: [Error Code %(error_code)s] %(ex)s'"
nl|'\n'
op|')'
op|'%'
op|'{'
string|"'instance_name'"
op|':'
name|'guest'
op|'.'
name|'name'
op|','
nl|'\n'
string|"'error_code'"
op|':'
name|'error_code'
op|','
nl|'\n'
string|"'ex'"
op|':'
name|'ex'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'Periodic task is updating the host stat, '"
nl|'\n'
string|"'it is trying to get disk %(i_name)s, '"
nl|'\n'
string|"'but disk file was removed by concurrent '"
nl|'\n'
string|"'operations such as resize.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'i_name'"
op|':'
name|'guest'
op|'.'
name|'name'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'e'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'EACCES'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'Periodic task is updating the host stat, '"
nl|'\n'
string|"'it is trying to get disk %(i_name)s, '"
nl|'\n'
string|"'but access is denied. It is most likely '"
nl|'\n'
string|"'due to a VM that exists on the compute '"
nl|'\n'
string|"'node but is not managed by Nova.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'i_name'"
op|':'
name|'guest'
op|'.'
name|'name'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'exception'
op|'.'
name|'VolumeBDMPathNotFound'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'Periodic task is updating the host stats, '"
nl|'\n'
string|"'it is trying to get disk info for %(i_name)s, '"
nl|'\n'
string|"'but the backing volume block device was removed '"
nl|'\n'
string|"'by concurrent operations such as resize. '"
nl|'\n'
string|"'Error: %(error)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'i_name'"
op|':'
name|'guest'
op|'.'
name|'name'
op|','
nl|'\n'
string|"'error'"
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
comment|'# NOTE(gtt116): give other tasks a chance.'
nl|'\n'
dedent|''
name|'greenthread'
op|'.'
name|'sleep'
op|'('
number|'0'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'disk_over_committed_size'
newline|'\n'
nl|'\n'
DECL|member|unfilter_instance
dedent|''
name|'def'
name|'unfilter_instance'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""See comments of same method in firewall_driver."""'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'unfilter_instance'
op|'('
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|'='
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_available_nodes
dedent|''
name|'def'
name|'get_available_nodes'
op|'('
name|'self'
op|','
name|'refresh'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'['
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_hostname'
op|'('
op|')'
op|']'
newline|'\n'
nl|'\n'
DECL|member|get_host_cpu_stats
dedent|''
name|'def'
name|'get_host_cpu_stats'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the current CPU state of the host."""'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_cpu_stats'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_host_uptime
dedent|''
name|'def'
name|'get_host_uptime'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns the result of calling "uptime"."""'
newline|'\n'
name|'out'
op|','
name|'err'
op|'='
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'env'"
op|','
string|"'LANG=C'"
op|','
string|"'uptime'"
op|')'
newline|'\n'
name|'return'
name|'out'
newline|'\n'
nl|'\n'
DECL|member|manage_image_cache
dedent|''
name|'def'
name|'manage_image_cache'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'all_instances'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Manage the local cache of images."""'
newline|'\n'
name|'self'
op|'.'
name|'image_cache_manager'
op|'.'
name|'update'
op|'('
name|'context'
op|','
name|'all_instances'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_cleanup_remote_migration
dedent|''
name|'def'
name|'_cleanup_remote_migration'
op|'('
name|'self'
op|','
name|'dest'
op|','
name|'inst_base'
op|','
name|'inst_base_resize'
op|','
nl|'\n'
name|'shared_storage'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Used only for cleanup in case migrate_disk_and_power_off fails."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'inst_base_resize'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'rm'"
op|','
string|"'-rf'"
op|','
name|'inst_base'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'inst_base_resize'
op|','
name|'inst_base'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'shared_storage'
op|':'
newline|'\n'
indent|'                    '
name|'utils'
op|'.'
name|'ssh_execute'
op|'('
name|'dest'
op|','
string|"'rm'"
op|','
string|"'-rf'"
op|','
name|'inst_base'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|_is_storage_shared_with
dedent|''
dedent|''
name|'def'
name|'_is_storage_shared_with'
op|'('
name|'self'
op|','
name|'dest'
op|','
name|'inst_base'
op|')'
op|':'
newline|'\n'
comment|'# NOTE (rmk): There are two methods of determining whether we are'
nl|'\n'
comment|'#             on the same filesystem: the source and dest IP are the'
nl|'\n'
comment|'#             same, or we create a file on the dest system via SSH'
nl|'\n'
comment|'#             and check whether the source system can also see it.'
nl|'\n'
indent|'        '
name|'shared_storage'
op|'='
op|'('
name|'dest'
op|'=='
name|'self'
op|'.'
name|'get_host_ip_addr'
op|'('
op|')'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'shared_storage'
op|':'
newline|'\n'
indent|'            '
name|'tmp_file'
op|'='
name|'uuid'
op|'.'
name|'uuid4'
op|'('
op|')'
op|'.'
name|'hex'
op|'+'
string|"'.tmp'"
newline|'\n'
name|'tmp_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_base'
op|','
name|'tmp_file'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'utils'
op|'.'
name|'ssh_execute'
op|'('
name|'dest'
op|','
string|"'touch'"
op|','
name|'tmp_path'
op|')'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'tmp_path'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'shared_storage'
op|'='
name|'True'
newline|'\n'
name|'os'
op|'.'
name|'unlink'
op|'('
name|'tmp_path'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'utils'
op|'.'
name|'ssh_execute'
op|'('
name|'dest'
op|','
string|"'rm'"
op|','
name|'tmp_path'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'shared_storage'
newline|'\n'
nl|'\n'
DECL|member|migrate_disk_and_power_off
dedent|''
name|'def'
name|'migrate_disk_and_power_off'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
nl|'\n'
name|'flavor'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
nl|'\n'
name|'timeout'
op|'='
number|'0'
op|','
name|'retry_interval'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Starting migrate_disk_and_power_off"'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'ephemerals'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_ephemerals'
op|'('
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
comment|'# get_bdm_ephemeral_disk_size() will return 0 if the new'
nl|'\n'
comment|"# instance's requested block device mapping contain no"
nl|'\n'
comment|'# ephemeral devices. However, we still want to check if'
nl|'\n'
comment|"# the original instance's ephemeral_gb property was set and"
nl|'\n'
comment|'# ensure that the new requested flavor ephemeral size is greater'
nl|'\n'
name|'eph_size'
op|'='
op|'('
name|'block_device'
op|'.'
name|'get_bdm_ephemeral_disk_size'
op|'('
name|'ephemerals'
op|')'
name|'or'
nl|'\n'
name|'instance'
op|'.'
name|'ephemeral_gb'
op|')'
newline|'\n'
nl|'\n'
comment|'# Checks if the migration needs a disk resize down.'
nl|'\n'
name|'root_down'
op|'='
name|'flavor'
op|'.'
name|'root_gb'
op|'<'
name|'instance'
op|'.'
name|'root_gb'
newline|'\n'
name|'ephemeral_down'
op|'='
name|'flavor'
op|'.'
name|'ephemeral_gb'
op|'<'
name|'eph_size'
newline|'\n'
name|'disk_info_text'
op|'='
name|'self'
op|'.'
name|'get_instance_disk_info'
op|'('
nl|'\n'
name|'instance'
op|','
name|'block_device_info'
op|'='
name|'block_device_info'
op|')'
newline|'\n'
name|'booted_from_volume'
op|'='
name|'self'
op|'.'
name|'_is_booted_from_volume'
op|'('
name|'instance'
op|','
nl|'\n'
name|'disk_info_text'
op|')'
newline|'\n'
name|'if'
op|'('
name|'root_down'
name|'and'
name|'not'
name|'booted_from_volume'
op|')'
name|'or'
name|'ephemeral_down'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
name|'_'
op|'('
string|'"Unable to resize disk down."'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstanceFaultRollback'
op|'('
nl|'\n'
name|'exception'
op|'.'
name|'ResizeError'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'disk_info'
op|'='
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'disk_info_text'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(dgenin): Migration is not implemented for LVM backed instances.'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_type'
op|'=='
string|"'lvm'"
name|'and'
name|'not'
name|'booted_from_volume'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
name|'_'
op|'('
string|'"Migration is not supported for LVM backed instances"'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstanceFaultRollback'
op|'('
nl|'\n'
name|'exception'
op|'.'
name|'MigrationPreCheckError'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|'# copy disks to destination'
nl|'\n'
comment|'# rename instance dir to +_resize at first for using'
nl|'\n'
comment|'# shared storage for instance dir (eg. NFS).'
nl|'\n'
dedent|''
name|'inst_base'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'inst_base_resize'
op|'='
name|'inst_base'
op|'+'
string|'"_resize"'
newline|'\n'
name|'shared_storage'
op|'='
name|'self'
op|'.'
name|'_is_storage_shared_with'
op|'('
name|'dest'
op|','
name|'inst_base'
op|')'
newline|'\n'
nl|'\n'
comment|'# try to create the directory on the remote compute node'
nl|'\n'
comment|'# if this fails we pass the exception up the stack so we can catch'
nl|'\n'
comment|'# failures here earlier'
nl|'\n'
name|'if'
name|'not'
name|'shared_storage'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'utils'
op|'.'
name|'ssh_execute'
op|'('
name|'dest'
op|','
string|"'mkdir'"
op|','
string|"'-p'"
op|','
name|'inst_base'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'processutils'
op|'.'
name|'ProcessExecutionError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'reason'
op|'='
name|'_'
op|'('
string|'"not able to execute ssh command: %s"'
op|')'
op|'%'
name|'e'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstanceFaultRollback'
op|'('
nl|'\n'
name|'exception'
op|'.'
name|'ResizeError'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'power_off'
op|'('
name|'instance'
op|','
name|'timeout'
op|','
name|'retry_interval'
op|')'
newline|'\n'
nl|'\n'
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'for'
name|'vol'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'            '
name|'connection_info'
op|'='
name|'vol'
op|'['
string|"'connection_info'"
op|']'
newline|'\n'
name|'disk_dev'
op|'='
name|'vol'
op|'['
string|"'mount_device'"
op|']'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_disconnect_volume'
op|'('
name|'connection_info'
op|','
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'inst_base'
op|','
name|'inst_base_resize'
op|')'
newline|'\n'
comment|'# if we are migrating the instance with shared storage then'
nl|'\n'
comment|'# create the directory.  If it is a remote node the directory'
nl|'\n'
comment|'# has already been created'
nl|'\n'
name|'if'
name|'shared_storage'
op|':'
newline|'\n'
indent|'                '
name|'dest'
op|'='
name|'None'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mkdir'"
op|','
string|"'-p'"
op|','
name|'inst_base'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'active_flavor'
op|'='
name|'instance'
op|'.'
name|'get_flavor'
op|'('
op|')'
newline|'\n'
name|'for'
name|'info'
name|'in'
name|'disk_info'
op|':'
newline|'\n'
comment|"# assume inst_base == dirname(info['path'])"
nl|'\n'
indent|'                '
name|'img_path'
op|'='
name|'info'
op|'['
string|"'path'"
op|']'
newline|'\n'
name|'fname'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'img_path'
op|')'
newline|'\n'
name|'from_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_base_resize'
op|','
name|'fname'
op|')'
newline|'\n'
nl|'\n'
name|'if'
op|'('
name|'fname'
op|'=='
string|"'disk.swap'"
name|'and'
nl|'\n'
name|'active_flavor'
op|'.'
name|'get'
op|'('
string|"'swap'"
op|','
number|'0'
op|')'
op|'!='
name|'flavor'
op|'.'
name|'get'
op|'('
string|"'swap'"
op|','
number|'0'
op|')'
op|')'
op|':'
newline|'\n'
comment|'# To properly resize the swap partition, it must be'
nl|'\n'
comment|'# re-created with the proper size.  This is acceptable'
nl|'\n'
comment|'# because when an OS is shut down, the contents of the'
nl|'\n'
comment|"# swap space are just garbage, the OS doesn't bother about"
nl|'\n'
comment|'# what is in it.'
nl|'\n'
nl|'\n'
comment|'# We will not copy over the swap disk here, and rely on'
nl|'\n'
comment|'# finish_migration/_create_image to re-create it for us.'
nl|'\n'
indent|'                    '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'info'
op|'['
string|"'type'"
op|']'
op|'=='
string|"'qcow2'"
name|'and'
name|'info'
op|'['
string|"'backing_file'"
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'tmp_path'
op|'='
name|'from_path'
op|'+'
string|'"_rbase"'
newline|'\n'
comment|'# merge backing file'
nl|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'qemu-img'"
op|','
string|"'convert'"
op|','
string|"'-f'"
op|','
string|"'qcow2'"
op|','
nl|'\n'
string|"'-O'"
op|','
string|"'qcow2'"
op|','
name|'from_path'
op|','
name|'tmp_path'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'shared_storage'
op|':'
newline|'\n'
indent|'                        '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'tmp_path'
op|','
name|'img_path'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'libvirt_utils'
op|'.'
name|'copy_image'
op|'('
name|'tmp_path'
op|','
name|'img_path'
op|','
name|'host'
op|'='
name|'dest'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'rm'"
op|','
string|"'-f'"
op|','
name|'tmp_path'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'else'
op|':'
comment|'# raw or qcow2 with no backing file'
newline|'\n'
indent|'                    '
name|'libvirt_utils'
op|'.'
name|'copy_image'
op|'('
name|'from_path'
op|','
name|'img_path'
op|','
name|'host'
op|'='
name|'dest'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_cleanup_remote_migration'
op|'('
name|'dest'
op|','
name|'inst_base'
op|','
nl|'\n'
name|'inst_base_resize'
op|','
nl|'\n'
name|'shared_storage'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'disk_info_text'
newline|'\n'
nl|'\n'
DECL|member|_wait_for_running
dedent|''
name|'def'
name|'_wait_for_running'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'state'
op|'='
name|'self'
op|'.'
name|'get_info'
op|'('
name|'instance'
op|')'
op|'.'
name|'state'
newline|'\n'
nl|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance running successfully."'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_disk_size_from_instance
name|'def'
name|'_disk_size_from_instance'
op|'('
name|'instance'
op|','
name|'info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Determines the disk size from instance properties\n\n        Returns the disk size by using the disk name to determine whether it\n        is a root or an ephemeral disk, then by checking properties of the\n        instance returns the size converted to bytes.\n\n        Returns 0 if the disk name not match (disk, disk.local).\n        """'
newline|'\n'
name|'fname'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'info'
op|'['
string|"'path'"
op|']'
op|')'
newline|'\n'
name|'if'
name|'fname'
op|'=='
string|"'disk'"
op|':'
newline|'\n'
indent|'            '
name|'size'
op|'='
name|'instance'
op|'.'
name|'root_gb'
newline|'\n'
dedent|''
name|'elif'
name|'fname'
op|'=='
string|"'disk.local'"
op|':'
newline|'\n'
indent|'            '
name|'size'
op|'='
name|'instance'
op|'.'
name|'ephemeral_gb'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'size'
op|'='
number|'0'
newline|'\n'
dedent|''
name|'return'
name|'size'
op|'*'
name|'units'
op|'.'
name|'Gi'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_disk_raw_to_qcow2
name|'def'
name|'_disk_raw_to_qcow2'
op|'('
name|'path'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Converts a raw disk to qcow2."""'
newline|'\n'
name|'path_qcow'
op|'='
name|'path'
op|'+'
string|"'_qcow'"
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'qemu-img'"
op|','
string|"'convert'"
op|','
string|"'-f'"
op|','
string|"'raw'"
op|','
nl|'\n'
string|"'-O'"
op|','
string|"'qcow2'"
op|','
name|'path'
op|','
name|'path_qcow'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'path_qcow'
op|','
name|'path'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_disk_qcow2_to_raw
name|'def'
name|'_disk_qcow2_to_raw'
op|'('
name|'path'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Converts a qcow2 disk to raw."""'
newline|'\n'
name|'path_raw'
op|'='
name|'path'
op|'+'
string|"'_raw'"
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'qemu-img'"
op|','
string|"'convert'"
op|','
string|"'-f'"
op|','
string|"'qcow2'"
op|','
nl|'\n'
string|"'-O'"
op|','
string|"'raw'"
op|','
name|'path'
op|','
name|'path_raw'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'path_raw'
op|','
name|'path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_disk_resize
dedent|''
name|'def'
name|'_disk_resize'
op|'('
name|'self'
op|','
name|'image'
op|','
name|'size'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Attempts to resize a disk to size\n\n        :param image: an instance of nova.virt.image.model.Image\n\n        Attempts to resize a disk by checking the capabilities and\n        preparing the format, then calling disk.api.extend.\n\n        Note: Currently only support disk extend.\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'image'
op|','
name|'imgmodel'
op|'.'
name|'LocalFileImage'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Skipping resize of non-local image"'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
comment|'# If we have a non partitioned image that we can extend'
nl|'\n'
comment|"# then ensure we're in 'raw' format so we can extend file system."
nl|'\n'
dedent|''
name|'converted'
op|'='
name|'False'
newline|'\n'
name|'if'
op|'('
name|'size'
name|'and'
nl|'\n'
name|'image'
op|'.'
name|'format'
op|'=='
name|'imgmodel'
op|'.'
name|'FORMAT_QCOW2'
name|'and'
nl|'\n'
name|'disk'
op|'.'
name|'can_resize_image'
op|'('
name|'image'
op|'.'
name|'path'
op|','
name|'size'
op|')'
name|'and'
nl|'\n'
name|'disk'
op|'.'
name|'is_image_extendable'
op|'('
name|'image'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_disk_qcow2_to_raw'
op|'('
name|'image'
op|'.'
name|'path'
op|')'
newline|'\n'
name|'converted'
op|'='
name|'True'
newline|'\n'
name|'image'
op|'='
name|'imgmodel'
op|'.'
name|'LocalFileImage'
op|'('
name|'image'
op|'.'
name|'path'
op|','
nl|'\n'
name|'imgmodel'
op|'.'
name|'FORMAT_RAW'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'size'
op|':'
newline|'\n'
indent|'            '
name|'disk'
op|'.'
name|'extend'
op|'('
name|'image'
op|','
name|'size'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'converted'
op|':'
newline|'\n'
comment|'# back to qcow2 (no backing_file though) so that snapshot'
nl|'\n'
comment|'# will be available'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_disk_raw_to_qcow2'
op|'('
name|'image'
op|'.'
name|'path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|finish_migration
dedent|''
dedent|''
name|'def'
name|'finish_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'migration'
op|','
name|'instance'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'network_info'
op|','
name|'image_meta'
op|','
name|'resize_instance'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'power_on'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Starting finish_migration"'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# resize disks. only "disk" and "disk.local" are necessary.'
nl|'\n'
name|'disk_info'
op|'='
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'disk_info'
op|')'
newline|'\n'
name|'for'
name|'info'
name|'in'
name|'disk_info'
op|':'
newline|'\n'
indent|'            '
name|'size'
op|'='
name|'self'
op|'.'
name|'_disk_size_from_instance'
op|'('
name|'instance'
op|','
name|'info'
op|')'
newline|'\n'
name|'if'
name|'resize_instance'
op|':'
newline|'\n'
indent|'                '
name|'image'
op|'='
name|'imgmodel'
op|'.'
name|'LocalFileImage'
op|'('
name|'info'
op|'['
string|"'path'"
op|']'
op|','
nl|'\n'
name|'info'
op|'['
string|"'type'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_disk_resize'
op|'('
name|'image'
op|','
name|'size'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'info'
op|'['
string|"'type'"
op|']'
op|'=='
string|"'raw'"
name|'and'
name|'CONF'
op|'.'
name|'use_cow_images'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_disk_raw_to_qcow2'
op|'('
name|'info'
op|'['
string|"'path'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
comment|'# assume _create_image do nothing if a target file exists.'
nl|'\n'
name|'self'
op|'.'
name|'_create_image'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'disk_info'
op|'['
string|"'mapping'"
op|']'
op|','
nl|'\n'
name|'network_info'
op|'='
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'inject_files'
op|'='
name|'False'
op|','
nl|'\n'
name|'fallback_from_host'
op|'='
name|'migration'
op|'.'
name|'source_compute'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_guest_xml'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|','
nl|'\n'
name|'write_to_disk'
op|'='
name|'True'
op|')'
newline|'\n'
comment|'# NOTE(mriedem): vifs_already_plugged=True here, regardless of whether'
nl|'\n'
comment|"# or not we've migrated to another host, because we unplug VIFs locally"
nl|'\n'
comment|'# and the status change in the port might go undetected by the neutron'
nl|'\n'
comment|'# L2 agent (or neutron server) so neutron may not know that the VIF was'
nl|'\n'
comment|'# unplugged in the first place and never send an event.'
nl|'\n'
name|'self'
op|'.'
name|'_create_domain_and_network'
op|'('
name|'context'
op|','
name|'xml'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'disk_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|','
nl|'\n'
name|'power_on'
op|'='
name|'power_on'
op|','
nl|'\n'
name|'vifs_already_plugged'
op|'='
name|'True'
op|')'
newline|'\n'
name|'if'
name|'power_on'
op|':'
newline|'\n'
indent|'            '
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_wait_for_running'
op|','
nl|'\n'
name|'instance'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_cleanup_failed_migration
dedent|''
dedent|''
name|'def'
name|'_cleanup_failed_migration'
op|'('
name|'self'
op|','
name|'inst_base'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Make sure that a failed migrate doesn\'t prevent us from rolling\n        back in a revert.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'shutil'
op|'.'
name|'rmtree'
op|'('
name|'inst_base'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
nl|'\n'
DECL|member|finish_revert_migration
dedent|''
dedent|''
dedent|''
name|'def'
name|'finish_revert_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'power_on'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Starting finish_revert_migration"'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'inst_base'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'inst_base_resize'
op|'='
name|'inst_base'
op|'+'
string|'"_resize"'
newline|'\n'
nl|'\n'
comment|"# NOTE(danms): if we're recovering from a failed migration,"
nl|'\n'
comment|"# make sure we don't have a left-over same-host base directory"
nl|'\n'
comment|"# that would conflict. Also, don't fail on the rename if the"
nl|'\n'
comment|'# failure happened early.'
nl|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'inst_base_resize'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_cleanup_failed_migration'
op|'('
name|'inst_base'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'inst_base_resize'
op|','
name|'inst_base'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'image_meta'
op|'='
name|'utils'
op|'.'
name|'get_image_from_system_metadata'
op|'('
nl|'\n'
name|'instance'
op|'.'
name|'system_metadata'
op|')'
newline|'\n'
nl|'\n'
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_guest_xml'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_domain_and_network'
op|'('
name|'context'
op|','
name|'xml'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'disk_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|','
nl|'\n'
name|'power_on'
op|'='
name|'power_on'
op|','
nl|'\n'
name|'vifs_already_plugged'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'power_on'
op|':'
newline|'\n'
indent|'            '
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_wait_for_running'
op|','
nl|'\n'
name|'instance'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"finish_revert_migration finished successfully."'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|confirm_migration
dedent|''
name|'def'
name|'confirm_migration'
op|'('
name|'self'
op|','
name|'migration'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Confirms a resize, destroying the source VM."""'
newline|'\n'
name|'self'
op|'.'
name|'_cleanup_resize'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_get_io_devices
name|'def'
name|'_get_io_devices'
op|'('
name|'xml_doc'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""get the list of io devices from the xml document."""'
newline|'\n'
name|'result'
op|'='
op|'{'
string|'"volumes"'
op|':'
op|'['
op|']'
op|','
string|'"ifaces"'
op|':'
op|'['
op|']'
op|'}'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml_doc'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'result'
newline|'\n'
dedent|''
name|'blocks'
op|'='
op|'['
op|'('
string|"'./devices/disk'"
op|','
string|"'volumes'"
op|')'
op|','
nl|'\n'
op|'('
string|"'./devices/interface'"
op|','
string|"'ifaces'"
op|')'
op|']'
newline|'\n'
name|'for'
name|'block'
op|','
name|'key'
name|'in'
name|'blocks'
op|':'
newline|'\n'
indent|'            '
name|'section'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
name|'block'
op|')'
newline|'\n'
name|'for'
name|'node'
name|'in'
name|'section'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'child'
name|'in'
name|'node'
op|'.'
name|'getchildren'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'child'
op|'.'
name|'tag'
op|'=='
string|"'target'"
name|'and'
name|'child'
op|'.'
name|'get'
op|'('
string|"'dev'"
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'result'
op|'['
name|'key'
op|']'
op|'.'
name|'append'
op|'('
name|'child'
op|'.'
name|'get'
op|'('
string|"'dev'"
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
DECL|member|get_diagnostics
dedent|''
name|'def'
name|'get_diagnostics'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(sahid): We are converting all calls from a'
nl|'\n'
comment|'# virDomain object to use nova.virt.libvirt.Guest.'
nl|'\n'
comment|'# We should be able to remove domain at the end.'
nl|'\n'
name|'domain'
op|'='
name|'guest'
op|'.'
name|'_domain'
newline|'\n'
name|'output'
op|'='
op|'{'
op|'}'
newline|'\n'
comment|'# get cpu time, might launch an exception if the method'
nl|'\n'
comment|'# is not supported by the underlying hypervisor being'
nl|'\n'
comment|'# used by libvirt'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'vcpu'
name|'in'
name|'guest'
op|'.'
name|'get_vcpus_info'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'output'
op|'['
string|'"cpu"'
op|'+'
name|'str'
op|'('
name|'vcpu'
op|'.'
name|'id'
op|')'
op|'+'
string|'"_time"'
op|']'
op|'='
name|'vcpu'
op|'.'
name|'time'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
comment|'# get io status'
nl|'\n'
dedent|''
name|'xml'
op|'='
name|'guest'
op|'.'
name|'get_xml_desc'
op|'('
op|')'
newline|'\n'
name|'dom_io'
op|'='
name|'LibvirtDriver'
op|'.'
name|'_get_io_devices'
op|'('
name|'xml'
op|')'
newline|'\n'
name|'for'
name|'guest_disk'
name|'in'
name|'dom_io'
op|'['
string|'"volumes"'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
comment|'# blockStats might launch an exception if the method'
nl|'\n'
comment|'# is not supported by the underlying hypervisor being'
nl|'\n'
comment|'# used by libvirt'
nl|'\n'
indent|'                '
name|'stats'
op|'='
name|'domain'
op|'.'
name|'blockStats'
op|'('
name|'guest_disk'
op|')'
newline|'\n'
name|'output'
op|'['
name|'guest_disk'
op|'+'
string|'"_read_req"'
op|']'
op|'='
name|'stats'
op|'['
number|'0'
op|']'
newline|'\n'
name|'output'
op|'['
name|'guest_disk'
op|'+'
string|'"_read"'
op|']'
op|'='
name|'stats'
op|'['
number|'1'
op|']'
newline|'\n'
name|'output'
op|'['
name|'guest_disk'
op|'+'
string|'"_write_req"'
op|']'
op|'='
name|'stats'
op|'['
number|'2'
op|']'
newline|'\n'
name|'output'
op|'['
name|'guest_disk'
op|'+'
string|'"_write"'
op|']'
op|'='
name|'stats'
op|'['
number|'3'
op|']'
newline|'\n'
name|'output'
op|'['
name|'guest_disk'
op|'+'
string|'"_errors"'
op|']'
op|'='
name|'stats'
op|'['
number|'4'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'for'
name|'interface'
name|'in'
name|'dom_io'
op|'['
string|'"ifaces"'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
comment|'# interfaceStats might launch an exception if the method'
nl|'\n'
comment|'# is not supported by the underlying hypervisor being'
nl|'\n'
comment|'# used by libvirt'
nl|'\n'
indent|'                '
name|'stats'
op|'='
name|'domain'
op|'.'
name|'interfaceStats'
op|'('
name|'interface'
op|')'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_rx"'
op|']'
op|'='
name|'stats'
op|'['
number|'0'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_rx_packets"'
op|']'
op|'='
name|'stats'
op|'['
number|'1'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_rx_errors"'
op|']'
op|'='
name|'stats'
op|'['
number|'2'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_rx_drop"'
op|']'
op|'='
name|'stats'
op|'['
number|'3'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_tx"'
op|']'
op|'='
name|'stats'
op|'['
number|'4'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_tx_packets"'
op|']'
op|'='
name|'stats'
op|'['
number|'5'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_tx_errors"'
op|']'
op|'='
name|'stats'
op|'['
number|'6'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_tx_drop"'
op|']'
op|'='
name|'stats'
op|'['
number|'7'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'output'
op|'['
string|'"memory"'
op|']'
op|'='
name|'domain'
op|'.'
name|'maxMemory'
op|'('
op|')'
newline|'\n'
comment|'# memoryStats might launch an exception if the method'
nl|'\n'
comment|'# is not supported by the underlying hypervisor being'
nl|'\n'
comment|'# used by libvirt'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'mem'
op|'='
name|'domain'
op|'.'
name|'memoryStats'
op|'('
op|')'
newline|'\n'
name|'for'
name|'key'
name|'in'
name|'mem'
op|'.'
name|'keys'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'output'
op|'['
string|'"memory-"'
op|'+'
name|'key'
op|']'
op|'='
name|'mem'
op|'['
name|'key'
op|']'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|'('
name|'libvirt'
op|'.'
name|'libvirtError'
op|','
name|'AttributeError'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'return'
name|'output'
newline|'\n'
nl|'\n'
DECL|member|get_instance_diagnostics
dedent|''
name|'def'
name|'get_instance_diagnostics'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'guest'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_guest'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# TODO(sahid): We are converting all calls from a'
nl|'\n'
comment|'# virDomain object to use nova.virt.libvirt.Guest.'
nl|'\n'
comment|'# We should be able to remove domain at the end.'
nl|'\n'
name|'domain'
op|'='
name|'guest'
op|'.'
name|'_domain'
newline|'\n'
nl|'\n'
name|'xml'
op|'='
name|'guest'
op|'.'
name|'get_xml_desc'
op|'('
op|')'
newline|'\n'
name|'xml_doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
op|'('
name|'state'
op|','
name|'max_mem'
op|','
name|'mem'
op|','
name|'num_cpu'
op|','
name|'cpu_time'
op|')'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_domain_info'
op|'('
name|'domain'
op|')'
newline|'\n'
name|'config_drive'
op|'='
name|'configdrive'
op|'.'
name|'required_by'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'launched_at'
op|'='
name|'timeutils'
op|'.'
name|'normalize_time'
op|'('
name|'instance'
op|'.'
name|'launched_at'
op|')'
newline|'\n'
name|'uptime'
op|'='
name|'timeutils'
op|'.'
name|'delta_seconds'
op|'('
name|'launched_at'
op|','
nl|'\n'
name|'timeutils'
op|'.'
name|'utcnow'
op|'('
op|')'
op|')'
newline|'\n'
name|'diags'
op|'='
name|'diagnostics'
op|'.'
name|'Diagnostics'
op|'('
name|'state'
op|'='
name|'power_state'
op|'.'
name|'STATE_MAP'
op|'['
name|'state'
op|']'
op|','
nl|'\n'
name|'driver'
op|'='
string|"'libvirt'"
op|','
nl|'\n'
name|'config_drive'
op|'='
name|'config_drive'
op|','
nl|'\n'
name|'hypervisor_os'
op|'='
string|"'linux'"
op|','
nl|'\n'
name|'uptime'
op|'='
name|'uptime'
op|')'
newline|'\n'
name|'diags'
op|'.'
name|'memory_details'
op|'.'
name|'maximum'
op|'='
name|'max_mem'
op|'/'
name|'units'
op|'.'
name|'Mi'
newline|'\n'
name|'diags'
op|'.'
name|'memory_details'
op|'.'
name|'used'
op|'='
name|'mem'
op|'/'
name|'units'
op|'.'
name|'Mi'
newline|'\n'
nl|'\n'
comment|'# get cpu time, might launch an exception if the method'
nl|'\n'
comment|'# is not supported by the underlying hypervisor being'
nl|'\n'
comment|'# used by libvirt'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'vcpu'
name|'in'
name|'guest'
op|'.'
name|'get_vcpus_info'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'diags'
op|'.'
name|'add_cpu'
op|'('
name|'time'
op|'='
name|'vcpu'
op|'.'
name|'time'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
comment|'# get io status'
nl|'\n'
dedent|''
name|'dom_io'
op|'='
name|'LibvirtDriver'
op|'.'
name|'_get_io_devices'
op|'('
name|'xml'
op|')'
newline|'\n'
name|'for'
name|'guest_disk'
name|'in'
name|'dom_io'
op|'['
string|'"volumes"'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
comment|'# blockStats might launch an exception if the method'
nl|'\n'
comment|'# is not supported by the underlying hypervisor being'
nl|'\n'
comment|'# used by libvirt'
nl|'\n'
indent|'                '
name|'stats'
op|'='
name|'domain'
op|'.'
name|'blockStats'
op|'('
name|'guest_disk'
op|')'
newline|'\n'
name|'diags'
op|'.'
name|'add_disk'
op|'('
name|'read_bytes'
op|'='
name|'stats'
op|'['
number|'1'
op|']'
op|','
nl|'\n'
name|'read_requests'
op|'='
name|'stats'
op|'['
number|'0'
op|']'
op|','
nl|'\n'
name|'write_bytes'
op|'='
name|'stats'
op|'['
number|'3'
op|']'
op|','
nl|'\n'
name|'write_requests'
op|'='
name|'stats'
op|'['
number|'2'
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'for'
name|'interface'
name|'in'
name|'dom_io'
op|'['
string|'"ifaces"'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
comment|'# interfaceStats might launch an exception if the method'
nl|'\n'
comment|'# is not supported by the underlying hypervisor being'
nl|'\n'
comment|'# used by libvirt'
nl|'\n'
indent|'                '
name|'stats'
op|'='
name|'domain'
op|'.'
name|'interfaceStats'
op|'('
name|'interface'
op|')'
newline|'\n'
name|'diags'
op|'.'
name|'add_nic'
op|'('
name|'rx_octets'
op|'='
name|'stats'
op|'['
number|'0'
op|']'
op|','
nl|'\n'
name|'rx_errors'
op|'='
name|'stats'
op|'['
number|'2'
op|']'
op|','
nl|'\n'
name|'rx_drop'
op|'='
name|'stats'
op|'['
number|'3'
op|']'
op|','
nl|'\n'
name|'rx_packets'
op|'='
name|'stats'
op|'['
number|'1'
op|']'
op|','
nl|'\n'
name|'tx_octets'
op|'='
name|'stats'
op|'['
number|'4'
op|']'
op|','
nl|'\n'
name|'tx_errors'
op|'='
name|'stats'
op|'['
number|'6'
op|']'
op|','
nl|'\n'
name|'tx_drop'
op|'='
name|'stats'
op|'['
number|'7'
op|']'
op|','
nl|'\n'
name|'tx_packets'
op|'='
name|'stats'
op|'['
number|'5'
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
comment|'# Update mac addresses of interface if stats have been reported'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'diags'
op|'.'
name|'nic_details'
op|':'
newline|'\n'
indent|'            '
name|'nodes'
op|'='
name|'xml_doc'
op|'.'
name|'findall'
op|'('
string|"'./devices/interface/mac'"
op|')'
newline|'\n'
name|'for'
name|'index'
op|','
name|'node'
name|'in'
name|'enumerate'
op|'('
name|'nodes'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'diags'
op|'.'
name|'nic_details'
op|'['
name|'index'
op|']'
op|'.'
name|'mac_address'
op|'='
name|'node'
op|'.'
name|'get'
op|'('
string|"'address'"
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'diags'
newline|'\n'
nl|'\n'
DECL|member|instance_on_disk
dedent|''
name|'def'
name|'instance_on_disk'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
comment|'# ensure directories exist and are writable'
nl|'\n'
indent|'        '
name|'instance_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Checking instance files accessibility %s'"
op|','
name|'instance_path'
op|')'
newline|'\n'
name|'shared_instance_path'
op|'='
name|'os'
op|'.'
name|'access'
op|'('
name|'instance_path'
op|','
name|'os'
op|'.'
name|'W_OK'
op|')'
newline|'\n'
comment|'# NOTE(flwang): For shared block storage scenario, the file system is'
nl|'\n'
comment|'# not really shared by the two hosts, but the volume of evacuated'
nl|'\n'
comment|'# instance is reachable.'
nl|'\n'
name|'shared_block_storage'
op|'='
op|'('
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'backend'
op|'('
op|')'
op|'.'
nl|'\n'
name|'is_shared_block_storage'
op|'('
op|')'
op|')'
newline|'\n'
name|'return'
name|'shared_instance_path'
name|'or'
name|'shared_block_storage'
newline|'\n'
nl|'\n'
DECL|member|inject_network_info
dedent|''
name|'def'
name|'inject_network_info'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'nw_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'setup_basic_filtering'
op|'('
name|'instance'
op|','
name|'nw_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|delete_instance_files
dedent|''
name|'def'
name|'delete_instance_files'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'target'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
comment|'# A resize may be in progress'
nl|'\n'
name|'target_resize'
op|'='
name|'target'
op|'+'
string|"'_resize'"
newline|'\n'
comment|'# Other threads may attempt to rename the path, so renaming the path'
nl|'\n'
comment|"# to target + '_del' (because it is atomic) and iterating through"
nl|'\n'
comment|'# twice in the unlikely event that a concurrent rename occurs between'
nl|'\n'
comment|'# the two rename attempts in this method. In general this method'
nl|'\n'
comment|'# should be fairly thread-safe without these additional checks, since'
nl|'\n'
comment|'# other operations involving renames are not permitted when the task'
nl|'\n'
comment|'# state is not None and the task state should be set to something'
nl|'\n'
comment|'# other than None by the time this method is invoked.'
nl|'\n'
name|'target_del'
op|'='
name|'target'
op|'+'
string|"'_del'"
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'six'
op|'.'
name|'moves'
op|'.'
name|'range'
op|'('
number|'2'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'target'
op|','
name|'target_del'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'target_resize'
op|','
name|'target_del'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
comment|'# Either the target or target_resize path may still exist if all'
nl|'\n'
comment|'# rename attempts failed.'
nl|'\n'
dedent|''
dedent|''
name|'remaining_path'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'p'
name|'in'
op|'('
name|'target'
op|','
name|'target_resize'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'p'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'remaining_path'
op|'='
name|'p'
newline|'\n'
name|'break'
newline|'\n'
nl|'\n'
comment|'# A previous delete attempt may have been interrupted, so target_del'
nl|'\n'
comment|'# may exist even if all rename attempts during the present method'
nl|'\n'
comment|'# invocation failed due to the absence of both target and'
nl|'\n'
comment|'# target_resize.'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'remaining_path'
name|'and'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'target_del'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Deleting instance files %s'"
op|')'
op|','
name|'target_del'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'remaining_path'
op|'='
name|'target_del'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'shutil'
op|'.'
name|'rmtree'
op|'('
name|'target_del'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'Failed to cleanup directory %(target)s: '"
nl|'\n'
string|"'%(e)s'"
op|')'
op|','
op|'{'
string|"'target'"
op|':'
name|'target_del'
op|','
string|"'e'"
op|':'
name|'e'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|"# It is possible that the delete failed, if so don't mark the instance"
nl|'\n'
comment|'# as cleaned.'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'remaining_path'
name|'and'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'remaining_path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Deletion of %s failed'"
op|')'
op|','
name|'remaining_path'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Deletion of %s complete'"
op|')'
op|','
name|'target_del'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|need_legacy_block_device_info
name|'def'
name|'need_legacy_block_device_info'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|default_root_device_name
dedent|''
name|'def'
name|'default_root_device_name'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'root_bdm'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'        '
name|'disk_bus'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_bus_for_device_type'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
name|'image_meta'
op|','
string|'"disk"'
op|')'
newline|'\n'
name|'cdrom_bus'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_bus_for_device_type'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
name|'image_meta'
op|','
string|'"cdrom"'
op|')'
newline|'\n'
name|'root_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_root_info'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
name|'image_meta'
op|','
name|'root_bdm'
op|','
name|'disk_bus'
op|','
nl|'\n'
name|'cdrom_bus'
op|')'
newline|'\n'
name|'return'
name|'block_device'
op|'.'
name|'prepend_dev'
op|'('
name|'root_info'
op|'['
string|"'dev'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|default_device_names_for_instance
dedent|''
name|'def'
name|'default_device_names_for_instance'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'root_device_name'
op|','
nl|'\n'
op|'*'
name|'block_device_lists'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'image_meta'
op|'='
name|'utils'
op|'.'
name|'get_image_from_system_metadata'
op|'('
nl|'\n'
name|'instance'
op|'.'
name|'system_metadata'
op|')'
newline|'\n'
nl|'\n'
name|'block_device_mapping'
op|'='
name|'list'
op|'('
name|'itertools'
op|'.'
name|'chain'
op|'('
op|'*'
name|'block_device_lists'
op|')'
op|')'
newline|'\n'
comment|'# NOTE(ndipanov): Null out the device names so that blockinfo code'
nl|'\n'
comment|'#                 will assign them'
nl|'\n'
name|'for'
name|'bdm'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'bdm'
op|'.'
name|'device_name'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Ignoring supplied device name: %(device_name)s. "'
nl|'\n'
string|'"Libvirt can\'t honour user-supplied dev names"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'device_name'"
op|':'
name|'bdm'
op|'.'
name|'device_name'
op|'}'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'bdm'
op|'.'
name|'device_name'
op|'='
name|'None'
newline|'\n'
dedent|''
dedent|''
name|'block_device_info'
op|'='
name|'driver'
op|'.'
name|'get_block_device_info'
op|'('
name|'instance'
op|','
nl|'\n'
name|'block_device_mapping'
op|')'
newline|'\n'
nl|'\n'
name|'blockinfo'
op|'.'
name|'default_device_names'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
nl|'\n'
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'block_device_info'
op|','
nl|'\n'
name|'image_meta'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_device_name_for_instance
dedent|''
name|'def'
name|'get_device_name_for_instance'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'bdms'
op|','
name|'block_device_obj'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'image_meta'
op|'='
name|'utils'
op|'.'
name|'get_image_from_system_metadata'
op|'('
nl|'\n'
name|'instance'
op|'.'
name|'system_metadata'
op|')'
newline|'\n'
name|'block_device_info'
op|'='
name|'driver'
op|'.'
name|'get_block_device_info'
op|'('
name|'instance'
op|','
name|'bdms'
op|')'
newline|'\n'
name|'instance_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
name|'instance'
op|','
nl|'\n'
name|'image_meta'
op|','
name|'block_device_info'
op|'='
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
name|'suggested_dev_name'
op|'='
name|'block_device_obj'
op|'.'
name|'device_name'
newline|'\n'
name|'if'
name|'suggested_dev_name'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'Ignoring supplied device name: %(suggested_dev)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'suggested_dev'"
op|':'
name|'suggested_dev_name'
op|'}'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(ndipanov): get_info_from_bdm will generate the new device name'
nl|'\n'
comment|"#                 only when it's actually not set on the bd object"
nl|'\n'
dedent|''
name|'block_device_obj'
op|'.'
name|'device_name'
op|'='
name|'None'
newline|'\n'
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_info_from_bdm'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
name|'image_meta'
op|','
name|'block_device_obj'
op|','
nl|'\n'
name|'mapping'
op|'='
name|'instance_info'
op|'['
string|"'mapping'"
op|']'
op|')'
newline|'\n'
name|'return'
name|'block_device'
op|'.'
name|'prepend_dev'
op|'('
name|'disk_info'
op|'['
string|"'dev'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|is_supported_fs_format
dedent|''
name|'def'
name|'is_supported_fs_format'
op|'('
name|'self'
op|','
name|'fs_type'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'fs_type'
name|'in'
op|'['
name|'disk'
op|'.'
name|'FS_FORMAT_EXT2'
op|','
name|'disk'
op|'.'
name|'FS_FORMAT_EXT3'
op|','
nl|'\n'
name|'disk'
op|'.'
name|'FS_FORMAT_EXT4'
op|','
name|'disk'
op|'.'
name|'FS_FORMAT_XFS'
op|']'
newline|'\n'
nl|'\n'
DECL|member|_get_power_state
dedent|''
name|'def'
name|'_get_power_state'
op|'('
name|'self'
op|','
name|'virt_dom'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'dom_info'
op|'='
name|'self'
op|'.'
name|'_host'
op|'.'
name|'get_domain_info'
op|'('
name|'virt_dom'
op|')'
newline|'\n'
name|'return'
name|'LIBVIRT_POWER_STATE'
op|'['
name|'dom_info'
op|'['
number|'0'
op|']'
op|']'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
