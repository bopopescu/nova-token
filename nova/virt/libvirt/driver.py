begin_unit
comment|'# Copyright 2010 United States Government as represented by the'
nl|'\n'
comment|'# Administrator of the National Aeronautics and Space Administration.'
nl|'\n'
comment|'# All Rights Reserved.'
nl|'\n'
comment|'# Copyright (c) 2010 Citrix Systems, Inc.'
nl|'\n'
comment|'# Copyright (c) 2011 Piston Cloud Computing, Inc'
nl|'\n'
comment|'# Copyright (c) 2012 University Of Minho'
nl|'\n'
comment|'# (c) Copyright 2013 Hewlett-Packard Development Company, L.P.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
nl|'\n'
string|'"""\nA connection to a hypervisor through libvirt.\n\nSupports KVM, LXC, QEMU, UML, and XEN.\n\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'contextlib'
newline|'\n'
name|'import'
name|'errno'
newline|'\n'
name|'import'
name|'functools'
newline|'\n'
name|'import'
name|'glob'
newline|'\n'
name|'import'
name|'mmap'
newline|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'random'
newline|'\n'
name|'import'
name|'shutil'
newline|'\n'
name|'import'
name|'socket'
newline|'\n'
name|'import'
name|'sys'
newline|'\n'
name|'import'
name|'tempfile'
newline|'\n'
name|'import'
name|'threading'
newline|'\n'
name|'import'
name|'time'
newline|'\n'
name|'import'
name|'uuid'
newline|'\n'
name|'from'
name|'xml'
op|'.'
name|'dom'
name|'import'
name|'minidom'
newline|'\n'
nl|'\n'
name|'import'
name|'eventlet'
newline|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'greenio'
newline|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'greenthread'
newline|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'patcher'
newline|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'tpool'
newline|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'util'
name|'as'
name|'eventlet_util'
newline|'\n'
name|'from'
name|'lxml'
name|'import'
name|'etree'
newline|'\n'
name|'from'
name|'oslo'
op|'.'
name|'config'
name|'import'
name|'cfg'
newline|'\n'
name|'from'
name|'oslo'
op|'.'
name|'serialization'
name|'import'
name|'jsonutils'
newline|'\n'
name|'from'
name|'oslo'
op|'.'
name|'utils'
name|'import'
name|'excutils'
newline|'\n'
name|'from'
name|'oslo'
op|'.'
name|'utils'
name|'import'
name|'importutils'
newline|'\n'
name|'from'
name|'oslo'
op|'.'
name|'utils'
name|'import'
name|'strutils'
newline|'\n'
name|'from'
name|'oslo'
op|'.'
name|'utils'
name|'import'
name|'timeutils'
newline|'\n'
name|'from'
name|'oslo'
op|'.'
name|'utils'
name|'import'
name|'units'
newline|'\n'
name|'import'
name|'six'
newline|'\n'
nl|'\n'
name|'from'
name|'nova'
op|'.'
name|'api'
op|'.'
name|'metadata'
name|'import'
name|'base'
name|'as'
name|'instance_metadata'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'block_device'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'arch'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'flavors'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'hvtype'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'power_state'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'task_states'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'utils'
name|'as'
name|'compute_utils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'vm_mode'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'console'
name|'import'
name|'serial'
name|'as'
name|'serial_console'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'console'
name|'import'
name|'type'
name|'as'
name|'ctype'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'context'
name|'as'
name|'nova_context'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'exception'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_LE'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_LI'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_LW'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'image'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'network'
name|'import'
name|'model'
name|'as'
name|'network_model'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'objects'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'fileutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'log'
name|'as'
name|'logging'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'loopingcall'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'processutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'pci'
name|'import'
name|'pci_manager'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'pci'
name|'import'
name|'pci_utils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'pci'
name|'import'
name|'pci_whitelist'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'rpc'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'utils'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'version'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'block_device'
name|'as'
name|'driver_block_device'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'configdrive'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'diagnostics'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'disk'
name|'import'
name|'api'
name|'as'
name|'disk'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'disk'
op|'.'
name|'vfs'
name|'import'
name|'guestfs'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'driver'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'event'
name|'as'
name|'virtevent'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'firewall'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'hardware'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'blockinfo'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'config'
name|'as'
name|'vconfig'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'dmcrypt'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'firewall'
name|'as'
name|'libvirt_firewall'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'imagebackend'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'imagecache'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'lvm'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'rbd_utils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'utils'
name|'as'
name|'libvirt_utils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'vif'
name|'as'
name|'libvirt_vif'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'netutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'watchdog_actions'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'volume'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'volume'
name|'import'
name|'encryptors'
newline|'\n'
nl|'\n'
DECL|variable|native_threading
name|'native_threading'
op|'='
name|'patcher'
op|'.'
name|'original'
op|'('
string|'"threading"'
op|')'
newline|'\n'
DECL|variable|native_Queue
name|'native_Queue'
op|'='
name|'patcher'
op|'.'
name|'original'
op|'('
string|'"Queue"'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|libvirt
name|'libvirt'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|variable|LOG
name|'LOG'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|libvirt_opts
name|'libvirt_opts'
op|'='
op|'['
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'rescue_image_id'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Rescue ami image. This will not be used if an image id '"
nl|'\n'
string|"'is provided by the user.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'rescue_kernel_id'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Rescue aki image'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'rescue_ramdisk_id'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Rescue ari image'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'virt_type'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'kvm'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Libvirt domain type (valid options are: '"
nl|'\n'
string|"'kvm, lxc, qemu, uml, xen)'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'connection_uri'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"''"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Override the default libvirt URI '"
nl|'\n'
string|"'(which is dependent on virt_type)'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'BoolOpt'
op|'('
string|"'inject_password'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
name|'False'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Inject the admin password at boot time, '"
nl|'\n'
string|"'without an agent.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'BoolOpt'
op|'('
string|"'inject_key'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
name|'False'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Inject the ssh public key at boot time'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'inject_partition'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
op|'-'
number|'2'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'The partition to inject to : '"
nl|'\n'
string|"'-2 => disable, -1 => inspect (libguestfs only), '"
nl|'\n'
string|"'0 => not partitioned, >0 => partition number'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'BoolOpt'
op|'('
string|"'use_usb_tablet'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
name|'True'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Sync virtual and real mouse cursors in Windows VMs'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'live_migration_uri'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|'"qemu+tcp://%s/system"'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Migration target URI '"
nl|'\n'
string|'\'(any included "%s" is replaced with \''
nl|'\n'
string|"'the migration target hostname)'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'live_migration_flag'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '"
nl|'\n'
string|"'VIR_MIGRATE_LIVE, VIR_MIGRATE_TUNNELLED'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Migration flags to be set for live migration'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'block_migration_flag'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '"
nl|'\n'
string|"'VIR_MIGRATE_LIVE, VIR_MIGRATE_TUNNELLED, '"
nl|'\n'
string|"'VIR_MIGRATE_NON_SHARED_INC'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Migration flags to be set for block migration'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'live_migration_bandwidth'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'0'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Maximum bandwidth to be used during migration, in Mbps'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'snapshot_image_format'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Snapshot image format (valid options are : '"
nl|'\n'
string|"'raw, qcow2, vmdk, vdi). '"
nl|'\n'
string|"'Defaults to same as source image'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'ListOpt'
op|'('
string|"'volume_drivers'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
op|'['
nl|'\n'
string|"'iscsi=nova.virt.libvirt.volume.LibvirtISCSIVolumeDriver'"
op|','
nl|'\n'
string|"'iser=nova.virt.libvirt.volume.LibvirtISERVolumeDriver'"
op|','
nl|'\n'
string|"'local=nova.virt.libvirt.volume.LibvirtVolumeDriver'"
op|','
nl|'\n'
string|"'fake=nova.virt.libvirt.volume.LibvirtFakeVolumeDriver'"
op|','
nl|'\n'
string|"'rbd=nova.virt.libvirt.volume.LibvirtNetVolumeDriver'"
op|','
nl|'\n'
string|"'sheepdog=nova.virt.libvirt.volume.LibvirtNetVolumeDriver'"
op|','
nl|'\n'
string|"'nfs=nova.virt.libvirt.volume.LibvirtNFSVolumeDriver'"
op|','
nl|'\n'
string|"'aoe=nova.virt.libvirt.volume.LibvirtAOEVolumeDriver'"
op|','
nl|'\n'
string|"'glusterfs='"
nl|'\n'
string|"'nova.virt.libvirt.volume.LibvirtGlusterfsVolumeDriver'"
op|','
nl|'\n'
string|"'fibre_channel=nova.virt.libvirt.volume.'"
nl|'\n'
string|"'LibvirtFibreChannelVolumeDriver'"
op|','
nl|'\n'
string|"'scality='"
nl|'\n'
string|"'nova.virt.libvirt.volume.LibvirtScalityVolumeDriver'"
op|','
nl|'\n'
op|']'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'DEPRECATED. Libvirt handlers for remote volumes. '"
nl|'\n'
string|"'This option is deprecated and will be removed in the '"
nl|'\n'
string|"'Kilo release.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'disk_prefix'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Override the default disk prefix for the devices attached'"
nl|'\n'
string|"' to a server, which is dependent on virt_type. '"
nl|'\n'
string|"'(valid options are: sd, xvd, uvd, vd)'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'wait_soft_reboot_seconds'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'120'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Number of seconds to wait for instance to shut down after'"
nl|'\n'
string|"' soft reboot request is made. We fall back to hard reboot'"
nl|'\n'
string|"' if instance does not shutdown within this window.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'cpu_mode'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|'\'Set to "host-model" to clone the host CPU feature flags; \''
nl|'\n'
string|'\'to "host-passthrough" to use the host CPU model exactly; \''
nl|'\n'
string|'\'to "custom" to use a named CPU model; \''
nl|'\n'
string|'\'to "none" to not set any CPU model. \''
nl|'\n'
string|'\'If virt_type="kvm|qemu", it will default to \''
nl|'\n'
string|'\'"host-model", otherwise it will default to "none"\''
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'cpu_model'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Set to a named libvirt CPU model (see names listed '"
nl|'\n'
string|"'in /usr/share/libvirt/cpu_map.xml). Only has effect if '"
nl|'\n'
string|'\'cpu_mode="custom" and virt_type="kvm|qemu"\''
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'snapshots_directory'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'$instances_path/snapshots'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Location where libvirt driver will store snapshots '"
nl|'\n'
string|"'before uploading them to image service'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'xen_hvmloader_path'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'/usr/lib/xen/boot/hvmloader'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Location where the Xen hvmloader is kept'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'ListOpt'
op|'('
string|"'disk_cachemodes'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
op|'['
op|']'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Specific cachemodes to use for different disk types '"
nl|'\n'
string|"'e.g: file=directsync,block=none'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'rng_dev_path'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'A path to a device that will be used as source of '"
nl|'\n'
string|"'entropy on the host. Permitted options are: '"
nl|'\n'
string|"'/dev/random or /dev/hwrng'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'ListOpt'
op|'('
string|"'hw_machine_type'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'For qemu or KVM guests, set this option to specify '"
nl|'\n'
string|"'a default machine type per host architecture. '"
nl|'\n'
string|"'You can find a list of supported machine types '"
nl|'\n'
string|"'in your environment by checking the output of '"
nl|'\n'
string|'\'the "virsh capabilities"command. The format of the \''
nl|'\n'
string|"'value for this config option is host-arch=machine-type. '"
nl|'\n'
string|"'For example: x86_64=machinetype1,armv7l=machinetype2'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'sysinfo_serial'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'auto'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|'\'The data source used to the populate the host "serial" \''
nl|'\n'
string|"'UUID exposed to guest in the virtual BIOS. Permitted '"
nl|'\n'
string|'\'options are "hardware", "os", "none" or "auto" \''
nl|'\n'
string|"'(default).'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'mem_stats_period_seconds'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'10'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'A number of seconds to memory usage statistics period. '"
nl|'\n'
string|"'Zero or negative value mean to disable memory usage '"
nl|'\n'
string|"'statistics.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'ListOpt'
op|'('
string|"'uid_maps'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
op|'['
op|']'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'List of uid targets and ranges.'"
nl|'\n'
string|"'Syntax is guest-uid:host-uid:count'"
nl|'\n'
string|"'Maximum of 5 allowed.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'ListOpt'
op|'('
string|"'gid_maps'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
op|'['
op|']'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'List of guid targets and ranges.'"
nl|'\n'
string|"'Syntax is guest-gid:host-gid:count'"
nl|'\n'
string|"'Maximum of 5 allowed.'"
op|')'
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
DECL|variable|CONF
name|'CONF'
op|'='
name|'cfg'
op|'.'
name|'CONF'
newline|'\n'
name|'CONF'
op|'.'
name|'register_opts'
op|'('
name|'libvirt_opts'
op|','
string|"'libvirt'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'host'"
op|','
string|"'nova.netconf'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'my_ip'"
op|','
string|"'nova.netconf'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'default_ephemeral_format'"
op|','
string|"'nova.virt.driver'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'use_cow_images'"
op|','
string|"'nova.virt.driver'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'enabled'"
op|','
string|"'nova.compute.api'"
op|','
nl|'\n'
DECL|variable|group
name|'group'
op|'='
string|"'ephemeral_storage_encryption'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'cipher'"
op|','
string|"'nova.compute.api'"
op|','
nl|'\n'
DECL|variable|group
name|'group'
op|'='
string|"'ephemeral_storage_encryption'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'key_size'"
op|','
string|"'nova.compute.api'"
op|','
nl|'\n'
DECL|variable|group
name|'group'
op|'='
string|"'ephemeral_storage_encryption'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'live_migration_retry_count'"
op|','
string|"'nova.compute.manager'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'vncserver_proxyclient_address'"
op|','
string|"'nova.vnc'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'server_proxyclient_address'"
op|','
string|"'nova.spice'"
op|','
name|'group'
op|'='
string|"'spice'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'vcpu_pin_set'"
op|','
string|"'nova.virt.hardware'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'vif_plugging_is_fatal'"
op|','
string|"'nova.virt.driver'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'vif_plugging_timeout'"
op|','
string|"'nova.virt.driver'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'enabled'"
op|','
string|"'nova.console.serial'"
op|','
name|'group'
op|'='
string|"'serial_console'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'proxyclient_address'"
op|','
string|"'nova.console.serial'"
op|','
nl|'\n'
DECL|variable|group
name|'group'
op|'='
string|"'serial_console'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'hw_disk_discard'"
op|','
string|"'nova.virt.libvirt.imagebackend'"
op|','
nl|'\n'
DECL|variable|group
name|'group'
op|'='
string|"'libvirt'"
op|')'
newline|'\n'
nl|'\n'
DECL|variable|DEFAULT_FIREWALL_DRIVER
name|'DEFAULT_FIREWALL_DRIVER'
op|'='
string|'"%s.%s"'
op|'%'
op|'('
nl|'\n'
name|'libvirt_firewall'
op|'.'
name|'__name__'
op|','
nl|'\n'
name|'libvirt_firewall'
op|'.'
name|'IptablesFirewallDriver'
op|'.'
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|MAX_CONSOLE_BYTES
name|'MAX_CONSOLE_BYTES'
op|'='
number|'100'
op|'*'
name|'units'
op|'.'
name|'Ki'
newline|'\n'
nl|'\n'
comment|'# The libvirt driver will prefix any disable reason codes with this string.'
nl|'\n'
DECL|variable|DISABLE_PREFIX
name|'DISABLE_PREFIX'
op|'='
string|"'AUTO: '"
newline|'\n'
comment|'# Disable reason for the service which was enabled or disabled without reason'
nl|'\n'
DECL|variable|DISABLE_REASON_UNDEFINED
name|'DISABLE_REASON_UNDEFINED'
op|'='
string|"'None'"
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|patch_tpool_proxy
name|'def'
name|'patch_tpool_proxy'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""eventlet.tpool.Proxy doesn\'t work with old-style class in __str__()\n    or __repr__() calls. See bug #962840 for details.\n    We perform a monkey patch to replace those two instance methods.\n    """'
newline|'\n'
DECL|function|str_method
name|'def'
name|'str_method'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'str'
op|'('
name|'self'
op|'.'
name|'_obj'
op|')'
newline|'\n'
nl|'\n'
DECL|function|repr_method
dedent|''
name|'def'
name|'repr_method'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'repr'
op|'('
name|'self'
op|'.'
name|'_obj'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'tpool'
op|'.'
name|'Proxy'
op|'.'
name|'__str__'
op|'='
name|'str_method'
newline|'\n'
name|'tpool'
op|'.'
name|'Proxy'
op|'.'
name|'__repr__'
op|'='
name|'repr_method'
newline|'\n'
nl|'\n'
nl|'\n'
dedent|''
name|'patch_tpool_proxy'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|variable|VIR_DOMAIN_NOSTATE
name|'VIR_DOMAIN_NOSTATE'
op|'='
number|'0'
newline|'\n'
DECL|variable|VIR_DOMAIN_RUNNING
name|'VIR_DOMAIN_RUNNING'
op|'='
number|'1'
newline|'\n'
DECL|variable|VIR_DOMAIN_BLOCKED
name|'VIR_DOMAIN_BLOCKED'
op|'='
number|'2'
newline|'\n'
DECL|variable|VIR_DOMAIN_PAUSED
name|'VIR_DOMAIN_PAUSED'
op|'='
number|'3'
newline|'\n'
DECL|variable|VIR_DOMAIN_SHUTDOWN
name|'VIR_DOMAIN_SHUTDOWN'
op|'='
number|'4'
newline|'\n'
DECL|variable|VIR_DOMAIN_SHUTOFF
name|'VIR_DOMAIN_SHUTOFF'
op|'='
number|'5'
newline|'\n'
DECL|variable|VIR_DOMAIN_CRASHED
name|'VIR_DOMAIN_CRASHED'
op|'='
number|'6'
newline|'\n'
DECL|variable|VIR_DOMAIN_PMSUSPENDED
name|'VIR_DOMAIN_PMSUSPENDED'
op|'='
number|'7'
newline|'\n'
nl|'\n'
DECL|variable|LIBVIRT_POWER_STATE
name|'LIBVIRT_POWER_STATE'
op|'='
op|'{'
nl|'\n'
name|'VIR_DOMAIN_NOSTATE'
op|':'
name|'power_state'
op|'.'
name|'NOSTATE'
op|','
nl|'\n'
name|'VIR_DOMAIN_RUNNING'
op|':'
name|'power_state'
op|'.'
name|'RUNNING'
op|','
nl|'\n'
comment|'# NOTE(maoy): The DOMAIN_BLOCKED state is only valid in Xen.'
nl|'\n'
comment|'# It means that the VM is running and the vCPU is idle. So,'
nl|'\n'
comment|'# we map it to RUNNING'
nl|'\n'
name|'VIR_DOMAIN_BLOCKED'
op|':'
name|'power_state'
op|'.'
name|'RUNNING'
op|','
nl|'\n'
name|'VIR_DOMAIN_PAUSED'
op|':'
name|'power_state'
op|'.'
name|'PAUSED'
op|','
nl|'\n'
comment|'# NOTE(maoy): The libvirt API doc says that DOMAIN_SHUTDOWN'
nl|'\n'
comment|'# means the domain is being shut down. So technically the domain'
nl|'\n'
comment|'# is still running. SHUTOFF is the real powered off state.'
nl|'\n'
comment|'# But we will map both to SHUTDOWN anyway.'
nl|'\n'
comment|'# http://libvirt.org/html/libvirt-libvirt.html'
nl|'\n'
name|'VIR_DOMAIN_SHUTDOWN'
op|':'
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|','
nl|'\n'
name|'VIR_DOMAIN_SHUTOFF'
op|':'
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|','
nl|'\n'
name|'VIR_DOMAIN_CRASHED'
op|':'
name|'power_state'
op|'.'
name|'CRASHED'
op|','
nl|'\n'
name|'VIR_DOMAIN_PMSUSPENDED'
op|':'
name|'power_state'
op|'.'
name|'SUSPENDED'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
DECL|variable|MIN_LIBVIRT_VERSION
name|'MIN_LIBVIRT_VERSION'
op|'='
op|'('
number|'0'
op|','
number|'9'
op|','
number|'11'
op|')'
newline|'\n'
comment|'# When the above version matches/exceeds this version'
nl|'\n'
comment|'# delete it & corresponding code using it'
nl|'\n'
DECL|variable|MIN_LIBVIRT_DEVICE_CALLBACK_VERSION
name|'MIN_LIBVIRT_DEVICE_CALLBACK_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'1'
op|','
number|'1'
op|')'
newline|'\n'
comment|'# Live snapshot requirements'
nl|'\n'
DECL|variable|REQ_HYPERVISOR_LIVESNAPSHOT
name|'REQ_HYPERVISOR_LIVESNAPSHOT'
op|'='
string|'"QEMU"'
newline|'\n'
comment|'# TODO(sdague): this should be 1.0.0, but hacked to set 1.3.0 until'
nl|'\n'
comment|'# https://bugs.launchpad.net/nova/+bug/1334398'
nl|'\n'
comment|'# can be diagnosed & resolved'
nl|'\n'
DECL|variable|MIN_LIBVIRT_LIVESNAPSHOT_VERSION
name|'MIN_LIBVIRT_LIVESNAPSHOT_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'3'
op|','
number|'0'
op|')'
newline|'\n'
DECL|variable|MIN_QEMU_LIVESNAPSHOT_VERSION
name|'MIN_QEMU_LIVESNAPSHOT_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'3'
op|','
number|'0'
op|')'
newline|'\n'
comment|'# block size tuning requirements'
nl|'\n'
DECL|variable|MIN_LIBVIRT_BLOCKIO_VERSION
name|'MIN_LIBVIRT_BLOCKIO_VERSION'
op|'='
op|'('
number|'0'
op|','
number|'10'
op|','
number|'2'
op|')'
newline|'\n'
comment|'# BlockJobInfo management requirement'
nl|'\n'
DECL|variable|MIN_LIBVIRT_BLOCKJOBINFO_VERSION
name|'MIN_LIBVIRT_BLOCKJOBINFO_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'1'
op|','
number|'1'
op|')'
newline|'\n'
comment|'# Relative block commit (feature is detected,'
nl|'\n'
comment|'# this version is only used for messaging)'
nl|'\n'
DECL|variable|MIN_LIBVIRT_BLOCKCOMMIT_RELATIVE_VERSION
name|'MIN_LIBVIRT_BLOCKCOMMIT_RELATIVE_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'2'
op|','
number|'7'
op|')'
newline|'\n'
comment|'# libvirt discard feature'
nl|'\n'
DECL|variable|MIN_LIBVIRT_DISCARD_VERSION
name|'MIN_LIBVIRT_DISCARD_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'0'
op|','
number|'6'
op|')'
newline|'\n'
DECL|variable|MIN_QEMU_DISCARD_VERSION
name|'MIN_QEMU_DISCARD_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'6'
op|','
number|'0'
op|')'
newline|'\n'
DECL|variable|REQ_HYPERVISOR_DISCARD
name|'REQ_HYPERVISOR_DISCARD'
op|'='
string|'"QEMU"'
newline|'\n'
comment|'# libvirt numa topology support'
nl|'\n'
DECL|variable|MIN_LIBVIRT_NUMA_TOPOLOGY_VERSION
name|'MIN_LIBVIRT_NUMA_TOPOLOGY_VERSION'
op|'='
op|'('
number|'1'
op|','
number|'0'
op|','
number|'4'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|libvirt_error_handler
name|'def'
name|'libvirt_error_handler'
op|'('
name|'context'
op|','
name|'err'
op|')'
op|':'
newline|'\n'
comment|'# Just ignore instead of default outputting to stderr.'
nl|'\n'
indent|'    '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|LibvirtDriver
dedent|''
name|'class'
name|'LibvirtDriver'
op|'('
name|'driver'
op|'.'
name|'ComputeDriver'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|variable|capabilities
indent|'    '
name|'capabilities'
op|'='
op|'{'
nl|'\n'
string|'"has_imagecache"'
op|':'
name|'True'
op|','
nl|'\n'
string|'"supports_recreate"'
op|':'
name|'True'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'virtapi'
op|','
name|'read_only'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'super'
op|'('
name|'LibvirtDriver'
op|','
name|'self'
op|')'
op|'.'
name|'__init__'
op|'('
name|'virtapi'
op|')'
newline|'\n'
nl|'\n'
name|'global'
name|'libvirt'
newline|'\n'
name|'if'
name|'libvirt'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'libvirt'
op|'='
name|'importutils'
op|'.'
name|'import_module'
op|'('
string|"'libvirt'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_skip_list_all_domains'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_initiator'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_fc_wwnns'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_fc_wwpns'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_wrapped_conn'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_wrapped_conn_lock'
op|'='
name|'threading'
op|'.'
name|'Lock'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_caps'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_vcpu_total'
op|'='
number|'0'
newline|'\n'
name|'self'
op|'.'
name|'read_only'
op|'='
name|'read_only'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'='
name|'firewall'
op|'.'
name|'load_driver'
op|'('
nl|'\n'
name|'DEFAULT_FIREWALL_DRIVER'
op|','
nl|'\n'
name|'self'
op|'.'
name|'virtapi'
op|','
nl|'\n'
name|'get_connection'
op|'='
name|'self'
op|'.'
name|'_get_connection'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'vif_driver'
op|'='
name|'libvirt_vif'
op|'.'
name|'LibvirtGenericVIFDriver'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_get_connection'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'volume_drivers'
op|'='
name|'driver'
op|'.'
name|'driver_dict_from_config'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'volume_drivers'
op|','
name|'self'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'dev_filter'
op|'='
name|'pci_whitelist'
op|'.'
name|'get_pci_devices_filter'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_event_queue'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_disk_cachemode'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'image_cache_manager'
op|'='
name|'imagecache'
op|'.'
name|'ImageCacheManager'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'image_backend'
op|'='
name|'imagebackend'
op|'.'
name|'Backend'
op|'('
name|'CONF'
op|'.'
name|'use_cow_images'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'disk_cachemodes'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'valid_cachemodes'
op|'='
op|'['
string|'"default"'
op|','
nl|'\n'
string|'"none"'
op|','
nl|'\n'
string|'"writethrough"'
op|','
nl|'\n'
string|'"writeback"'
op|','
nl|'\n'
string|'"directsync"'
op|','
nl|'\n'
string|'"unsafe"'
op|','
nl|'\n'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_conn_supports_start_paused'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
name|'in'
op|'('
string|"'kvm'"
op|','
nl|'\n'
string|"'qemu'"
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'mode_str'
name|'in'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'disk_cachemodes'
op|':'
newline|'\n'
indent|'            '
name|'disk_type'
op|','
name|'sep'
op|','
name|'cache_mode'
op|'='
name|'mode_str'
op|'.'
name|'partition'
op|'('
string|"'='"
op|')'
newline|'\n'
name|'if'
name|'cache_mode'
name|'not'
name|'in'
name|'self'
op|'.'
name|'valid_cachemodes'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'Invalid cachemode %(cache_mode)s specified '"
nl|'\n'
string|"'for disk type %(disk_type)s.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'cache_mode'"
op|':'
name|'cache_mode'
op|','
string|"'disk_type'"
op|':'
name|'disk_type'
op|'}'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'disk_cachemodes'
op|'['
name|'disk_type'
op|']'
op|'='
name|'cache_mode'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_volume_api'
op|'='
name|'volume'
op|'.'
name|'API'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_image_api'
op|'='
name|'image'
op|'.'
name|'API'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'sysinfo_serial_funcs'
op|'='
op|'{'
nl|'\n'
string|"'none'"
op|':'
name|'lambda'
op|':'
name|'None'
op|','
nl|'\n'
string|"'hardware'"
op|':'
name|'self'
op|'.'
name|'_get_host_sysinfo_serial_hardware'
op|','
nl|'\n'
string|"'os'"
op|':'
name|'self'
op|'.'
name|'_get_host_sysinfo_serial_os'
op|','
nl|'\n'
string|"'auto'"
op|':'
name|'self'
op|'.'
name|'_get_host_sysinfo_serial_auto'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_sysinfo_serial_func'
op|'='
name|'sysinfo_serial_funcs'
op|'.'
name|'get'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'sysinfo_serial'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_sysinfo_serial_func'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
nl|'\n'
name|'_'
op|'('
string|'"Unexpected sysinfo_serial setting \'%(actual)s\'. "'
nl|'\n'
string|'"Permitted values are %(expect)s\'"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'actual'"
op|':'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'sysinfo_serial'
op|','
nl|'\n'
string|"'expect'"
op|':'
string|"', '"
op|'.'
name|'join'
op|'('
string|'"\'%s\'"'
op|'%'
name|'k'
name|'for'
name|'k'
name|'in'
nl|'\n'
name|'sysinfo_serial_funcs'
op|'.'
name|'keys'
op|'('
op|')'
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|disk_cachemode
name|'def'
name|'disk_cachemode'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_disk_cachemode'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|"# We prefer 'none' for consistent performance, host crash"
nl|'\n'
comment|'# safety & migration correctness by avoiding host page cache.'
nl|'\n'
comment|"# Some filesystems (eg GlusterFS via FUSE) don't support"
nl|'\n'
comment|"# O_DIRECT though. For those we fallback to 'writethrough'"
nl|'\n'
comment|'# which gives host crash safety, and is safe for migration'
nl|'\n'
comment|'# provided the filesystem is cache coherent (cluster filesystems'
nl|'\n'
comment|'# typically are, but things like NFS are not).'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_disk_cachemode'
op|'='
string|'"none"'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_supports_direct_io'
op|'('
name|'CONF'
op|'.'
name|'instances_path'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_disk_cachemode'
op|'='
string|'"writethrough"'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'_disk_cachemode'
newline|'\n'
nl|'\n'
DECL|member|_set_cache_mode
dedent|''
name|'def'
name|'_set_cache_mode'
op|'('
name|'self'
op|','
name|'conf'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Set cache mode on LibvirtConfigGuestDisk object."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'source_type'
op|'='
name|'conf'
op|'.'
name|'source_type'
newline|'\n'
name|'driver_cache'
op|'='
name|'conf'
op|'.'
name|'driver_cache'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'cache_mode'
op|'='
name|'self'
op|'.'
name|'disk_cachemodes'
op|'.'
name|'get'
op|'('
name|'source_type'
op|','
nl|'\n'
name|'driver_cache'
op|')'
newline|'\n'
name|'conf'
op|'.'
name|'driver_cache'
op|'='
name|'cache_mode'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_conn_has_min_version
name|'def'
name|'_conn_has_min_version'
op|'('
name|'conn'
op|','
name|'lv_ver'
op|'='
name|'None'
op|','
name|'hv_ver'
op|'='
name|'None'
op|','
name|'hv_type'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'lv_ver'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'libvirt_version'
op|'='
name|'conn'
op|'.'
name|'getLibVersion'
op|'('
op|')'
newline|'\n'
name|'if'
name|'libvirt_version'
op|'<'
name|'utils'
op|'.'
name|'convert_version_to_int'
op|'('
name|'lv_ver'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'hv_ver'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'hypervisor_version'
op|'='
name|'conn'
op|'.'
name|'getVersion'
op|'('
op|')'
newline|'\n'
name|'if'
name|'hypervisor_version'
op|'<'
name|'utils'
op|'.'
name|'convert_version_to_int'
op|'('
name|'hv_ver'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'hv_type'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'hypervisor_type'
op|'='
name|'conn'
op|'.'
name|'getType'
op|'('
op|')'
newline|'\n'
name|'if'
name|'hypervisor_type'
op|'!='
name|'hv_type'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|_has_min_version
dedent|''
dedent|''
name|'def'
name|'_has_min_version'
op|'('
name|'self'
op|','
name|'lv_ver'
op|'='
name|'None'
op|','
name|'hv_ver'
op|'='
name|'None'
op|','
name|'hv_type'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'self'
op|'.'
name|'_conn_has_min_version'
op|'('
name|'self'
op|'.'
name|'_conn'
op|','
name|'lv_ver'
op|','
name|'hv_ver'
op|','
name|'hv_type'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_native_thread
dedent|''
name|'def'
name|'_native_thread'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Receives async events coming in from libvirtd.\n\n        This is a native thread which runs the default\n        libvirt event loop implementation. This processes\n        any incoming async events from libvirtd and queues\n        them for later dispatch. This thread is only\n        permitted to use libvirt python APIs, and the\n        driver.queue_event method. In particular any use\n        of logging is forbidden, since it will confuse\n        eventlet\'s greenthread integration\n        """'
newline|'\n'
nl|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'libvirt'
op|'.'
name|'virEventRunDefaultImpl'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_dispatch_thread
dedent|''
dedent|''
name|'def'
name|'_dispatch_thread'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Dispatches async events coming in from libvirtd.\n\n        This is a green thread which waits for events to\n        arrive from the libvirt event loop thread. This\n        then dispatches the events to the compute manager.\n        """'
newline|'\n'
nl|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_dispatch_events'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_event_lifecycle_callback
name|'def'
name|'_event_lifecycle_callback'
op|'('
name|'conn'
op|','
name|'dom'
op|','
name|'event'
op|','
name|'detail'
op|','
name|'opaque'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Receives lifecycle events from libvirt.\n\n        NB: this method is executing in a native thread, not\n        an eventlet coroutine. It can only invoke other libvirt\n        APIs, or use self.queue_event(). Any use of logging APIs\n        in particular is forbidden.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'='
name|'opaque'
newline|'\n'
nl|'\n'
name|'uuid'
op|'='
name|'dom'
op|'.'
name|'UUIDString'
op|'('
op|')'
newline|'\n'
name|'transition'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'event'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_EVENT_STOPPED'
op|':'
newline|'\n'
indent|'            '
name|'transition'
op|'='
name|'virtevent'
op|'.'
name|'EVENT_LIFECYCLE_STOPPED'
newline|'\n'
dedent|''
name|'elif'
name|'event'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_EVENT_STARTED'
op|':'
newline|'\n'
indent|'            '
name|'transition'
op|'='
name|'virtevent'
op|'.'
name|'EVENT_LIFECYCLE_STARTED'
newline|'\n'
dedent|''
name|'elif'
name|'event'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_EVENT_SUSPENDED'
op|':'
newline|'\n'
indent|'            '
name|'transition'
op|'='
name|'virtevent'
op|'.'
name|'EVENT_LIFECYCLE_PAUSED'
newline|'\n'
dedent|''
name|'elif'
name|'event'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_EVENT_RESUMED'
op|':'
newline|'\n'
indent|'            '
name|'transition'
op|'='
name|'virtevent'
op|'.'
name|'EVENT_LIFECYCLE_RESUMED'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'transition'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_queue_event'
op|'('
name|'virtevent'
op|'.'
name|'LifecycleEvent'
op|'('
name|'uuid'
op|','
name|'transition'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_queue_event
dedent|''
dedent|''
name|'def'
name|'_queue_event'
op|'('
name|'self'
op|','
name|'event'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Puts an event on the queue for dispatch.\n\n        This method is called by the native event thread to\n        put events on the queue for later dispatch by the\n        green thread. Any use of logging APIs is forbidden.\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_event_queue'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
comment|'# Queue the event...'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_event_queue'
op|'.'
name|'put'
op|'('
name|'event'
op|')'
newline|'\n'
nl|'\n'
comment|'# ...then wakeup the green thread to dispatch it'
nl|'\n'
name|'c'
op|'='
string|"' '"
op|'.'
name|'encode'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_notify_send'
op|'.'
name|'write'
op|'('
name|'c'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_notify_send'
op|'.'
name|'flush'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_dispatch_events
dedent|''
name|'def'
name|'_dispatch_events'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Wait for & dispatch events from native thread\n\n        Blocks until native thread indicates some events\n        are ready. Then dispatches all queued events.\n        """'
newline|'\n'
nl|'\n'
comment|'# Wait to be notified that there are some'
nl|'\n'
comment|'# events pending'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'_c'
op|'='
name|'self'
op|'.'
name|'_event_notify_recv'
op|'.'
name|'read'
op|'('
number|'1'
op|')'
newline|'\n'
name|'assert'
name|'_c'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'            '
name|'return'
comment|'# will be raised when pipe is closed'
newline|'\n'
nl|'\n'
comment|'# Process as many events as possible without'
nl|'\n'
comment|'# blocking'
nl|'\n'
dedent|''
name|'last_close_event'
op|'='
name|'None'
newline|'\n'
name|'while'
name|'not'
name|'self'
op|'.'
name|'_event_queue'
op|'.'
name|'empty'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'event'
op|'='
name|'self'
op|'.'
name|'_event_queue'
op|'.'
name|'get'
op|'('
name|'block'
op|'='
name|'False'
op|')'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'event'
op|','
name|'virtevent'
op|'.'
name|'LifecycleEvent'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'emit_event'
op|'('
name|'event'
op|')'
newline|'\n'
dedent|''
name|'elif'
string|"'conn'"
name|'in'
name|'event'
name|'and'
string|"'reason'"
name|'in'
name|'event'
op|':'
newline|'\n'
indent|'                    '
name|'last_close_event'
op|'='
name|'event'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'native_Queue'
op|'.'
name|'Empty'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'last_close_event'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'conn'
op|'='
name|'last_close_event'
op|'['
string|"'conn'"
op|']'
newline|'\n'
comment|'# get_new_connection may already have disabled the host,'
nl|'\n'
comment|'# in which case _wrapped_conn is None.'
nl|'\n'
name|'with'
name|'self'
op|'.'
name|'_wrapped_conn_lock'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'conn'
op|'=='
name|'self'
op|'.'
name|'_wrapped_conn'
op|':'
newline|'\n'
indent|'                '
name|'reason'
op|'='
name|'last_close_event'
op|'['
string|"'reason'"
op|']'
newline|'\n'
name|'_error'
op|'='
name|'_'
op|'('
string|'"Connection to libvirt lost: %s"'
op|')'
op|'%'
name|'reason'
newline|'\n'
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_error'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_wrapped_conn'
op|'='
name|'None'
newline|'\n'
comment|'# Disable compute service to avoid'
nl|'\n'
comment|'# new instances of being scheduled on this host.'
nl|'\n'
name|'self'
op|'.'
name|'_set_host_enabled'
op|'('
name|'False'
op|','
name|'disable_reason'
op|'='
name|'_error'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_init_events_pipe
dedent|''
dedent|''
dedent|''
name|'def'
name|'_init_events_pipe'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a self-pipe for the native thread to synchronize on.\n\n        This code is taken from the eventlet tpool module, under terms\n        of the Apache License v2.0.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_event_queue'
op|'='
name|'native_Queue'
op|'.'
name|'Queue'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'rpipe'
op|','
name|'wpipe'
op|'='
name|'os'
op|'.'
name|'pipe'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_notify_send'
op|'='
name|'greenio'
op|'.'
name|'GreenPipe'
op|'('
name|'wpipe'
op|','
string|"'wb'"
op|','
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_notify_recv'
op|'='
name|'greenio'
op|'.'
name|'GreenPipe'
op|'('
name|'rpipe'
op|','
string|"'rb'"
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'ImportError'
op|','
name|'NotImplementedError'
op|')'
op|':'
newline|'\n'
comment|'# This is Windows compatibility -- use a socket instead'
nl|'\n'
comment|"#  of a pipe because pipes don't really exist on Windows."
nl|'\n'
indent|'            '
name|'sock'
op|'='
name|'eventlet_util'
op|'.'
name|'__original_socket__'
op|'('
name|'socket'
op|'.'
name|'AF_INET'
op|','
nl|'\n'
name|'socket'
op|'.'
name|'SOCK_STREAM'
op|')'
newline|'\n'
name|'sock'
op|'.'
name|'bind'
op|'('
op|'('
string|"'localhost'"
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'sock'
op|'.'
name|'listen'
op|'('
number|'50'
op|')'
newline|'\n'
name|'csock'
op|'='
name|'eventlet_util'
op|'.'
name|'__original_socket__'
op|'('
name|'socket'
op|'.'
name|'AF_INET'
op|','
nl|'\n'
name|'socket'
op|'.'
name|'SOCK_STREAM'
op|')'
newline|'\n'
name|'csock'
op|'.'
name|'connect'
op|'('
op|'('
string|"'localhost'"
op|','
name|'sock'
op|'.'
name|'getsockname'
op|'('
op|')'
op|'['
number|'1'
op|']'
op|')'
op|')'
newline|'\n'
name|'nsock'
op|','
name|'addr'
op|'='
name|'sock'
op|'.'
name|'accept'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_notify_send'
op|'='
name|'nsock'
op|'.'
name|'makefile'
op|'('
string|"'wb'"
op|','
number|'0'
op|')'
newline|'\n'
name|'gsock'
op|'='
name|'greenio'
op|'.'
name|'GreenSocket'
op|'('
name|'csock'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_notify_recv'
op|'='
name|'gsock'
op|'.'
name|'makefile'
op|'('
string|"'rb'"
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_init_events
dedent|''
dedent|''
name|'def'
name|'_init_events'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Initializes the libvirt events subsystem.\n\n        This requires running a native thread to provide the\n        libvirt event loop integration. This forwards events\n        to a green thread which does the actual dispatching.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_init_events_pipe'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Starting native event thread"'
op|')'
newline|'\n'
name|'event_thread'
op|'='
name|'native_threading'
op|'.'
name|'Thread'
op|'('
name|'target'
op|'='
name|'self'
op|'.'
name|'_native_thread'
op|')'
newline|'\n'
name|'event_thread'
op|'.'
name|'setDaemon'
op|'('
name|'True'
op|')'
newline|'\n'
name|'event_thread'
op|'.'
name|'start'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Starting green dispatch thread"'
op|')'
newline|'\n'
name|'eventlet'
op|'.'
name|'spawn'
op|'('
name|'self'
op|'.'
name|'_dispatch_thread'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_do_quality_warnings
dedent|''
name|'def'
name|'_do_quality_warnings'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Warn about untested driver configurations.\n\n        This will log a warning message about untested driver or host arch\n        configurations to indicate to administrators that the quality is\n        unknown. Currently, only qemu or kvm on intel 32- or 64-bit systems\n        is tested upstream.\n        """'
newline|'\n'
name|'caps'
op|'='
name|'self'
op|'.'
name|'_get_host_capabilities'
op|'('
op|')'
newline|'\n'
name|'hostarch'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'arch'
newline|'\n'
name|'if'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
name|'not'
name|'in'
op|'('
string|"'qemu'"
op|','
string|"'kvm'"
op|')'
name|'or'
nl|'\n'
name|'hostarch'
name|'not'
name|'in'
op|'('
name|'arch'
op|'.'
name|'I686'
op|','
name|'arch'
op|'.'
name|'X86_64'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'The libvirt driver is not tested on '"
nl|'\n'
string|"'%(type)s/%(arch)s by the OpenStack project and '"
nl|'\n'
string|"'thus its quality can not be ensured. For more '"
nl|'\n'
string|"'information, see: https://wiki.openstack.org/wiki/'"
nl|'\n'
string|"'HypervisorSupportMatrix'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'type'"
op|':'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
string|"'arch'"
op|':'
name|'hostarch'
op|'}'
op|')'
newline|'\n'
nl|'\n'
DECL|member|init_host
dedent|''
dedent|''
name|'def'
name|'init_host'
op|'('
name|'self'
op|','
name|'host'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(dkliban): Error handler needs to be registered before libvirt'
nl|'\n'
comment|'#                connection is used for the first time.  Otherwise, the'
nl|'\n'
comment|'#                handler does not get registered.'
nl|'\n'
indent|'        '
name|'libvirt'
op|'.'
name|'registerErrorHandler'
op|'('
name|'libvirt_error_handler'
op|','
name|'None'
op|')'
newline|'\n'
name|'libvirt'
op|'.'
name|'virEventRegisterDefaultImpl'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_do_quality_warnings'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'lxc'"
name|'and'
nl|'\n'
name|'not'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'uid_maps'
name|'and'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'gid_maps'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Running libvirt-lxc without user namespaces is "'
nl|'\n'
string|'"dangerous. Containers spawned by Nova will be run "'
nl|'\n'
string|'"as the host\'s root user. It is highly suggested "'
nl|'\n'
string|'"that user namespaces be used in a public or "'
nl|'\n'
string|'"multi-tenant environment."'
op|')'
op|')'
newline|'\n'
nl|'\n'
comment|"# Stop libguestfs using KVM unless we're also configured"
nl|'\n'
comment|'# to use this. This solves problem where people need to'
nl|'\n'
comment|'# stop Nova use of KVM because nested-virt is broken'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'!='
string|'"kvm"'
op|':'
newline|'\n'
indent|'            '
name|'guestfs'
op|'.'
name|'force_tcg'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'_has_min_version'
op|'('
name|'MIN_LIBVIRT_VERSION'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'major'
op|'='
name|'MIN_LIBVIRT_VERSION'
op|'['
number|'0'
op|']'
newline|'\n'
name|'minor'
op|'='
name|'MIN_LIBVIRT_VERSION'
op|'['
number|'1'
op|']'
newline|'\n'
name|'micro'
op|'='
name|'MIN_LIBVIRT_VERSION'
op|'['
number|'2'
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'Nova requires libvirt version '"
nl|'\n'
string|"'%(major)i.%(minor)i.%(micro)i or greater.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'major'"
op|':'
name|'major'
op|','
string|"'minor'"
op|':'
name|'minor'
op|','
string|"'micro'"
op|':'
name|'micro'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_init_events'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_new_connection
dedent|''
name|'def'
name|'_get_new_connection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# call with _wrapped_conn_lock held'
nl|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Connecting to libvirt: %s'"
op|','
name|'self'
op|'.'
name|'uri'
op|'('
op|')'
op|')'
newline|'\n'
name|'wrapped_conn'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'wrapped_conn'
op|'='
name|'self'
op|'.'
name|'_connect'
op|'('
name|'self'
op|'.'
name|'uri'
op|'('
op|')'
op|','
name|'self'
op|'.'
name|'read_only'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
comment|'# Enabling the compute service, in case it was disabled'
nl|'\n'
comment|'# since the connection was successful.'
nl|'\n'
indent|'            '
name|'disable_reason'
op|'='
name|'DISABLE_REASON_UNDEFINED'
newline|'\n'
name|'if'
name|'not'
name|'wrapped_conn'
op|':'
newline|'\n'
indent|'                '
name|'disable_reason'
op|'='
string|"'Failed to connect to libvirt'"
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_set_host_enabled'
op|'('
name|'bool'
op|'('
name|'wrapped_conn'
op|')'
op|','
name|'disable_reason'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_wrapped_conn'
op|'='
name|'wrapped_conn'
newline|'\n'
name|'self'
op|'.'
name|'_skip_list_all_domains'
op|'='
name|'False'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Registering for lifecycle events %s"'
op|','
name|'self'
op|')'
newline|'\n'
name|'wrapped_conn'
op|'.'
name|'domainEventRegisterAny'
op|'('
nl|'\n'
name|'None'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_EVENT_ID_LIFECYCLE'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_event_lifecycle_callback'
op|','
nl|'\n'
name|'self'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"URI %(uri)s does not support events: %(error)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'uri'"
op|':'
name|'self'
op|'.'
name|'uri'
op|'('
op|')'
op|','
string|"'error'"
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Registering for connection events: %s"'
op|','
name|'str'
op|'('
name|'self'
op|')'
op|')'
newline|'\n'
name|'wrapped_conn'
op|'.'
name|'registerCloseCallback'
op|'('
name|'self'
op|'.'
name|'_close_callback'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'TypeError'
op|','
name|'AttributeError'
op|')'
name|'as'
name|'e'
op|':'
newline|'\n'
comment|'# NOTE: The registerCloseCallback of python-libvirt 1.0.1+'
nl|'\n'
comment|'# is defined with 3 arguments, and the above registerClose-'
nl|'\n'
comment|'# Callback succeeds. However, the one of python-libvirt 1.0.0'
nl|'\n'
comment|'# is defined with 4 arguments and TypeError happens here.'
nl|'\n'
comment|'# Then python-libvirt 0.9 does not define a method register-'
nl|'\n'
comment|'# CloseCallback.'
nl|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"The version of python-libvirt does not support "'
nl|'\n'
string|'"registerCloseCallback or is too old: %s"'
op|','
name|'e'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"URI %(uri)s does not support connection"'
nl|'\n'
string|'" events: %(error)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'uri'"
op|':'
name|'self'
op|'.'
name|'uri'
op|'('
op|')'
op|','
string|"'error'"
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'wrapped_conn'
newline|'\n'
nl|'\n'
DECL|member|_get_connection
dedent|''
name|'def'
name|'_get_connection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# multiple concurrent connections are protected by _wrapped_conn_lock'
nl|'\n'
indent|'        '
name|'with'
name|'self'
op|'.'
name|'_wrapped_conn_lock'
op|':'
newline|'\n'
indent|'            '
name|'wrapped_conn'
op|'='
name|'self'
op|'.'
name|'_wrapped_conn'
newline|'\n'
name|'if'
name|'not'
name|'wrapped_conn'
name|'or'
name|'not'
name|'self'
op|'.'
name|'_test_connection'
op|'('
name|'wrapped_conn'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'wrapped_conn'
op|'='
name|'self'
op|'.'
name|'_get_new_connection'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'wrapped_conn'
newline|'\n'
nl|'\n'
DECL|variable|_conn
dedent|''
name|'_conn'
op|'='
name|'property'
op|'('
name|'_get_connection'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_close_callback
name|'def'
name|'_close_callback'
op|'('
name|'self'
op|','
name|'conn'
op|','
name|'reason'
op|','
name|'opaque'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'close_info'
op|'='
op|'{'
string|"'conn'"
op|':'
name|'conn'
op|','
string|"'reason'"
op|':'
name|'reason'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'_queue_event'
op|'('
name|'close_info'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_test_connection
name|'def'
name|'_test_connection'
op|'('
name|'conn'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'conn'
op|'.'
name|'getLibVersion'
op|'('
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
name|'e'
op|'.'
name|'get_error_code'
op|'('
op|')'
name|'in'
op|'('
name|'libvirt'
op|'.'
name|'VIR_ERR_SYSTEM_ERROR'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_ERR_INTERNAL_ERROR'
op|')'
name|'and'
nl|'\n'
name|'e'
op|'.'
name|'get_error_domain'
op|'('
op|')'
name|'in'
op|'('
name|'libvirt'
op|'.'
name|'VIR_FROM_REMOTE'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_FROM_RPC'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Connection to libvirt broke'"
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|uri
name|'def'
name|'uri'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'uml'"
op|':'
newline|'\n'
indent|'            '
name|'uri'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'connection_uri'
name|'or'
string|"'uml:///system'"
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'xen'"
op|':'
newline|'\n'
indent|'            '
name|'uri'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'connection_uri'
name|'or'
string|"'xen:///'"
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'lxc'"
op|':'
newline|'\n'
indent|'            '
name|'uri'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'connection_uri'
name|'or'
string|"'lxc:///'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'uri'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'connection_uri'
name|'or'
string|"'qemu:///system'"
newline|'\n'
dedent|''
name|'return'
name|'uri'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_connect_auth_cb
name|'def'
name|'_connect_auth_cb'
op|'('
name|'creds'
op|','
name|'opaque'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'len'
op|'('
name|'creds'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'return'
number|'0'
newline|'\n'
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
nl|'\n'
name|'_'
op|'('
string|'"Can not handle authentication request for %d credentials"'
op|')'
nl|'\n'
op|'%'
name|'len'
op|'('
name|'creds'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_connect
name|'def'
name|'_connect'
op|'('
name|'uri'
op|','
name|'read_only'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'auth'
op|'='
op|'['
op|'['
name|'libvirt'
op|'.'
name|'VIR_CRED_AUTHNAME'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_CRED_ECHOPROMPT'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_CRED_REALM'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_CRED_PASSPHRASE'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_CRED_NOECHOPROMPT'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_CRED_EXTERNAL'
op|']'
op|','
nl|'\n'
name|'LibvirtDriver'
op|'.'
name|'_connect_auth_cb'
op|','
nl|'\n'
name|'None'
op|']'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'flags'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'read_only'
op|':'
newline|'\n'
indent|'                '
name|'flags'
op|'='
name|'libvirt'
op|'.'
name|'VIR_CONNECT_RO'
newline|'\n'
comment|'# tpool.proxy_call creates a native thread. Due to limitations'
nl|'\n'
comment|'# with eventlet locking we cannot use the logging API inside'
nl|'\n'
comment|'# the called function.'
nl|'\n'
dedent|''
name|'return'
name|'tpool'
op|'.'
name|'proxy_call'
op|'('
nl|'\n'
op|'('
name|'libvirt'
op|'.'
name|'virDomain'
op|','
name|'libvirt'
op|'.'
name|'virConnect'
op|')'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'openAuth'
op|','
name|'uri'
op|','
name|'auth'
op|','
name|'flags'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|'"Connection to libvirt failed: %s"'
op|')'
op|','
name|'ex'
op|')'
newline|'\n'
name|'payload'
op|'='
name|'dict'
op|'('
name|'ip'
op|'='
name|'LibvirtDriver'
op|'.'
name|'get_host_ip_addr'
op|'('
op|')'
op|','
nl|'\n'
name|'method'
op|'='
string|"'_connect'"
op|','
nl|'\n'
name|'reason'
op|'='
name|'ex'
op|')'
newline|'\n'
name|'rpc'
op|'.'
name|'get_notifier'
op|'('
string|"'compute'"
op|')'
op|'.'
name|'error'
op|'('
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
op|','
nl|'\n'
string|"'compute.libvirt.error'"
op|','
nl|'\n'
name|'payload'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'HypervisorUnavailable'
op|'('
name|'host'
op|'='
name|'CONF'
op|'.'
name|'host'
op|')'
newline|'\n'
nl|'\n'
DECL|member|instance_exists
dedent|''
dedent|''
name|'def'
name|'instance_exists'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Efficient override of base instance_exists method."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'.'
name|'name'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'NovaException'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|_list_instance_domains_fast
dedent|''
dedent|''
name|'def'
name|'_list_instance_domains_fast'
op|'('
name|'self'
op|','
name|'only_running'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
comment|'# The modern (>= 0.9.13) fast way - 1 single API call for all domains'
nl|'\n'
indent|'        '
name|'flags'
op|'='
name|'libvirt'
op|'.'
name|'VIR_CONNECT_LIST_DOMAINS_ACTIVE'
newline|'\n'
name|'if'
name|'not'
name|'only_running'
op|':'
newline|'\n'
indent|'            '
name|'flags'
op|'='
name|'flags'
op|'|'
name|'libvirt'
op|'.'
name|'VIR_CONNECT_LIST_DOMAINS_INACTIVE'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'listAllDomains'
op|'('
name|'flags'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_list_instance_domains_slow
dedent|''
name|'def'
name|'_list_instance_domains_slow'
op|'('
name|'self'
op|','
name|'only_running'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
comment|'# The legacy (< 0.9.13) slow way - O(n) API call for n domains'
nl|'\n'
indent|'        '
name|'uuids'
op|'='
op|'['
op|']'
newline|'\n'
name|'doms'
op|'='
op|'['
op|']'
newline|'\n'
comment|'# Redundant numOfDomains check is for libvirt bz #836647'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'numOfDomains'
op|'('
op|')'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'id'
name|'in'
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'listDomainsID'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_id'
op|'('
name|'id'
op|')'
newline|'\n'
name|'doms'
op|'.'
name|'append'
op|'('
name|'dom'
op|')'
newline|'\n'
name|'uuids'
op|'.'
name|'append'
op|'('
name|'dom'
op|'.'
name|'UUIDString'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'only_running'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'doms'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'name'
name|'in'
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'listDefinedDomains'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'name'
op|')'
newline|'\n'
name|'if'
name|'dom'
op|'.'
name|'UUIDString'
op|'('
op|')'
name|'not'
name|'in'
name|'uuids'
op|':'
newline|'\n'
indent|'                    '
name|'doms'
op|'.'
name|'append'
op|'('
name|'dom'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'doms'
newline|'\n'
nl|'\n'
DECL|member|_list_instance_domains
dedent|''
name|'def'
name|'_list_instance_domains'
op|'('
name|'self'
op|','
name|'only_running'
op|'='
name|'True'
op|','
name|'only_guests'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get a list of libvirt.Domain objects for nova instances\n\n        :param only_running: True to only return running instances\n        :param only_guests: True to filter out any host domain (eg Dom-0)\n\n        Query libvirt to a get a list of all libvirt.Domain objects\n        that correspond to nova instances. If the only_running parameter\n        is true this list will only include active domains, otherwise\n        inactive domains will be included too. If the only_guests parameter\n        is true the list will have any "host" domain (aka Xen Domain-0)\n        filtered out.\n\n        :returns: list of libvirt.Domain objects\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_skip_list_all_domains'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'alldoms'
op|'='
name|'self'
op|'.'
name|'_list_instance_domains_fast'
op|'('
name|'only_running'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'libvirt'
op|'.'
name|'libvirtError'
op|','
name|'AttributeError'
op|')'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Unable to use bulk domain list APIs, "'
nl|'\n'
string|'"falling back to slow code path: %(ex)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'ex'"
op|':'
name|'ex'
op|'}'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_skip_list_all_domains'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'self'
op|'.'
name|'_skip_list_all_domains'
op|':'
newline|'\n'
comment|"# Old libvirt, or a libvirt driver which doesn't"
nl|'\n'
comment|'# implement the new API'
nl|'\n'
indent|'            '
name|'alldoms'
op|'='
name|'self'
op|'.'
name|'_list_instance_domains_slow'
op|'('
name|'only_running'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'doms'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'dom'
name|'in'
name|'alldoms'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'only_guests'
name|'and'
name|'dom'
op|'.'
name|'ID'
op|'('
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'doms'
op|'.'
name|'append'
op|'('
name|'dom'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'doms'
newline|'\n'
nl|'\n'
DECL|member|list_instances
dedent|''
name|'def'
name|'list_instances'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'names'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'dom'
name|'in'
name|'self'
op|'.'
name|'_list_instance_domains'
op|'('
name|'only_running'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'names'
op|'.'
name|'append'
op|'('
name|'dom'
op|'.'
name|'name'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'names'
newline|'\n'
nl|'\n'
DECL|member|list_instance_uuids
dedent|''
name|'def'
name|'list_instance_uuids'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'uuids'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'dom'
name|'in'
name|'self'
op|'.'
name|'_list_instance_domains'
op|'('
name|'only_running'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'uuids'
op|'.'
name|'append'
op|'('
name|'dom'
op|'.'
name|'UUIDString'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'uuids'
newline|'\n'
nl|'\n'
DECL|member|plug_vifs
dedent|''
name|'def'
name|'plug_vifs'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Plug VIFs into networks."""'
newline|'\n'
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'plug'
op|'('
name|'instance'
op|','
name|'vif'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_unplug_vifs
dedent|''
dedent|''
name|'def'
name|'_unplug_vifs'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'ignore_errors'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Unplug VIFs from networks."""'
newline|'\n'
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'unplug'
op|'('
name|'instance'
op|','
name|'vif'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'NovaException'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'not'
name|'ignore_errors'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
newline|'\n'
nl|'\n'
DECL|member|unplug_vifs
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'unplug_vifs'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_unplug_vifs'
op|'('
name|'instance'
op|','
name|'network_info'
op|','
name|'False'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_teardown_container
dedent|''
name|'def'
name|'_teardown_container'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'inst_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'container_dir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_path'
op|','
string|"'rootfs'"
op|')'
newline|'\n'
name|'rootfs_dev'
op|'='
name|'instance'
op|'.'
name|'system_metadata'
op|'.'
name|'get'
op|'('
string|"'rootfs_device_name'"
op|')'
newline|'\n'
name|'disk'
op|'.'
name|'teardown_container'
op|'('
name|'container_dir'
op|','
name|'rootfs_dev'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_destroy
dedent|''
name|'def'
name|'_destroy'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|"# If the instance is already terminated, we're still happy"
nl|'\n'
comment|'# Otherwise, destroy it'
nl|'\n'
dedent|''
name|'old_domid'
op|'='
op|'-'
number|'1'
newline|'\n'
name|'if'
name|'virt_dom'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'old_domid'
op|'='
name|'virt_dom'
op|'.'
name|'ID'
op|'('
op|')'
newline|'\n'
name|'virt_dom'
op|'.'
name|'destroy'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(GuanQiang): teardown container to avoid resource leak'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'lxc'"
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_teardown_container'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'is_okay'
op|'='
name|'False'
newline|'\n'
name|'errcode'
op|'='
name|'e'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'errcode'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_DOMAIN'
op|':'
newline|'\n'
comment|'# Domain already gone. This can safely be ignored.'
nl|'\n'
indent|'                    '
name|'is_okay'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'elif'
name|'errcode'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_OPERATION_INVALID'
op|':'
newline|'\n'
comment|'# If the instance is already shut off, we get this:'
nl|'\n'
comment|'# Code=55 Error=Requested operation is not valid:'
nl|'\n'
comment|'# domain is not running'
nl|'\n'
indent|'                    '
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'virt_dom'
op|'.'
name|'info'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|']'
newline|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|':'
newline|'\n'
indent|'                        '
name|'is_okay'
op|'='
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'errcode'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_OPERATION_TIMEOUT'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Cannot destroy instance, operation time "'
nl|'\n'
string|'"out"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'reason'
op|'='
name|'_'
op|'('
string|'"operation time out"'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstancePowerOffFailure'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'is_okay'
op|':'
newline|'\n'
indent|'                    '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'Error from libvirt during destroy. '"
nl|'\n'
string|"'Code=%(errcode)s Error=%(e)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'errcode'"
op|':'
name|'errcode'
op|','
string|"'e'"
op|':'
name|'e'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_wait_for_destroy
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_wait_for_destroy'
op|'('
name|'expected_domid'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Called at an interval until the VM is gone."""'
newline|'\n'
comment|'# NOTE(vish): If the instance disappears during the destroy'
nl|'\n'
comment|'#             we ignore it so the cleanup can still be'
nl|'\n'
comment|'#             attempted because we would prefer destroy to'
nl|'\n'
comment|'#             never fail.'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'dom_info'
op|'='
name|'self'
op|'.'
name|'get_info'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'state'
op|'='
name|'dom_info'
op|'['
string|"'state'"
op|']'
newline|'\n'
name|'new_domid'
op|'='
name|'dom_info'
op|'['
string|"'id'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_LW'
op|'('
string|'"During wait destroy, instance disappeared."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance destroyed successfully."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(wangpan): If the instance was booted again after destroy,'
nl|'\n'
comment|'#                this may be a endless loop, so check the id of'
nl|'\n'
comment|'#                domain here, if it changed and the instance is'
nl|'\n'
comment|'#                still running, we should destroy it again.'
nl|'\n'
comment|'# see https://bugs.launchpad.net/nova/+bug/1111213 for more details'
nl|'\n'
dedent|''
name|'if'
name|'new_domid'
op|'!='
name|'expected_domid'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance may be started again."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'kwargs'
op|'['
string|"'is_running'"
op|']'
op|'='
name|'True'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'kwargs'
op|'='
op|'{'
string|"'is_running'"
op|':'
name|'False'
op|'}'
newline|'\n'
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
name|'_wait_for_destroy'
op|','
nl|'\n'
name|'old_domid'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
name|'if'
name|'kwargs'
op|'['
string|"'is_running'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Going to destroy instance again."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|destroy
dedent|''
dedent|''
name|'def'
name|'destroy'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|'='
name|'None'
op|','
nl|'\n'
name|'destroy_disks'
op|'='
name|'True'
op|','
name|'migrate_data'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'cleanup'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|','
nl|'\n'
name|'destroy_disks'
op|','
name|'migrate_data'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_undefine_domain
dedent|''
name|'def'
name|'_undefine_domain'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'None'
newline|'\n'
dedent|''
name|'if'
name|'virt_dom'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'virt_dom'
op|'.'
name|'undefineFlags'
op|'('
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_UNDEFINE_MANAGED_SAVE'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Error from libvirt during undefineFlags."'
nl|'\n'
string|'" Retrying with undefine"'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'virt_dom'
op|'.'
name|'undefine'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
comment|"# NOTE(vish): Older versions of libvirt don't support"
nl|'\n'
comment|'#             undefine flags, so attempt to do the'
nl|'\n'
comment|'#             right thing.'
nl|'\n'
indent|'                    '
name|'try'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'virt_dom'
op|'.'
name|'hasManagedSaveImage'
op|'('
number|'0'
op|')'
op|':'
newline|'\n'
indent|'                            '
name|'virt_dom'
op|'.'
name|'managedSaveRemove'
op|'('
number|'0'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'                        '
name|'pass'
newline|'\n'
dedent|''
name|'virt_dom'
op|'.'
name|'undefine'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'errcode'
op|'='
name|'e'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'Error from libvirt during undefine. '"
nl|'\n'
string|"'Code=%(errcode)s Error=%(e)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'errcode'"
op|':'
name|'errcode'
op|','
string|"'e'"
op|':'
name|'e'
op|'}'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|cleanup
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'cleanup'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|'='
name|'None'
op|','
nl|'\n'
name|'destroy_disks'
op|'='
name|'True'
op|','
name|'migrate_data'
op|'='
name|'None'
op|','
name|'destroy_vifs'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'destroy_vifs'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_unplug_vifs'
op|'('
name|'instance'
op|','
name|'network_info'
op|','
name|'True'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'retry'
op|'='
name|'True'
newline|'\n'
name|'while'
name|'retry'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'unfilter_instance'
op|'('
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|'='
name|'network_info'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'state'
op|'='
name|'self'
op|'.'
name|'get_info'
op|'('
name|'instance'
op|')'
op|'['
string|"'state'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'                    '
name|'state'
op|'='
name|'power_state'
op|'.'
name|'SHUTDOWN'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'state'
op|'!='
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Instance may be still running, destroy "'
nl|'\n'
string|'"it again."'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'retry'
op|'='
name|'False'
newline|'\n'
name|'errcode'
op|'='
name|'e'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Error from libvirt during unfilter. '"
nl|'\n'
string|"'Code=%(errcode)s Error=%(e)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'errcode'"
op|':'
name|'errcode'
op|','
string|"'e'"
op|':'
name|'e'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'reason'
op|'='
string|'"Error unfiltering instance."'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstanceTerminationFailure'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'retry'
op|'='
name|'False'
newline|'\n'
name|'raise'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'retry'
op|'='
name|'False'
newline|'\n'
nl|'\n'
comment|'# FIXME(wangpan): if the instance is booted again here, such as the'
nl|'\n'
comment|'#                 the soft reboot operation boot it here, it will'
nl|'\n'
comment|'#                 become "running deleted", should we check and destroy'
nl|'\n'
comment|'#                 it at the end of this method?'
nl|'\n'
nl|'\n'
comment|'# NOTE(vish): we disconnect from volumes regardless'
nl|'\n'
dedent|''
dedent|''
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'for'
name|'vol'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'            '
name|'connection_info'
op|'='
name|'vol'
op|'['
string|"'connection_info'"
op|']'
newline|'\n'
name|'disk_dev'
op|'='
name|'vol'
op|'['
string|"'mount_device'"
op|']'
newline|'\n'
name|'if'
name|'disk_dev'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'disk_dev'
op|'='
name|'disk_dev'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
string|"'data'"
name|'in'
name|'connection_info'
name|'and'
nl|'\n'
string|"'volume_id'"
name|'in'
name|'connection_info'
op|'['
string|"'data'"
op|']'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'volume_id'
op|'='
name|'connection_info'
op|'['
string|"'data'"
op|']'
op|'['
string|"'volume_id'"
op|']'
newline|'\n'
name|'encryption'
op|'='
name|'encryptors'
op|'.'
name|'get_encryption_metadata'
op|'('
nl|'\n'
name|'context'
op|','
name|'self'
op|'.'
name|'_volume_api'
op|','
name|'volume_id'
op|','
name|'connection_info'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'encryption'
op|':'
newline|'\n'
comment|'# The volume must be detached from the VM before'
nl|'\n'
comment|'# disconnecting it from its encryptor. Otherwise, the'
nl|'\n'
comment|'# encryptor may report that the volume is still in use.'
nl|'\n'
indent|'                    '
name|'encryptor'
op|'='
name|'self'
op|'.'
name|'_get_volume_encryptor'
op|'('
name|'connection_info'
op|','
nl|'\n'
name|'encryption'
op|')'
newline|'\n'
name|'encryptor'
op|'.'
name|'detach_volume'
op|'('
op|'**'
name|'encryption'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_disconnect_volume'
op|'('
name|'connection_info'
op|','
name|'disk_dev'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
name|'as'
name|'ctxt'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'destroy_disks'
op|':'
newline|'\n'
comment|"# Don't block on Volume errors if we're trying to"
nl|'\n'
comment|'# delete the instance as we may be partially created'
nl|'\n'
comment|'# or deleted'
nl|'\n'
indent|'                        '
name|'ctxt'
op|'.'
name|'reraise'
op|'='
name|'False'
newline|'\n'
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Ignoring Volume Error on vol %(vol_id)s "'
nl|'\n'
string|'"during delete %(exc)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'vol_id'"
op|':'
name|'vol'
op|'.'
name|'get'
op|'('
string|"'volume_id'"
op|')'
op|','
string|"'exc'"
op|':'
name|'exc'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'if'
name|'destroy_disks'
op|':'
newline|'\n'
comment|'# NOTE(haomai): destroy volumes if needed'
nl|'\n'
indent|'            '
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_type'
op|'=='
string|"'lvm'"
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_cleanup_lvm'
op|'('
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_type'
op|'=='
string|"'rbd'"
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_cleanup_rbd'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'destroy_disks'
name|'or'
op|'('
nl|'\n'
name|'migrate_data'
name|'and'
name|'migrate_data'
op|'.'
name|'get'
op|'('
string|"'is_shared_block_storage'"
op|','
nl|'\n'
name|'False'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_delete_instance_files'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'serial_console'
op|'.'
name|'enabled'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'host'
op|','
name|'port'
name|'in'
name|'self'
op|'.'
name|'_get_serial_ports_from_instance'
op|'('
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'serial_console'
op|'.'
name|'release_port'
op|'('
name|'host'
op|'='
name|'host'
op|','
name|'port'
op|'='
name|'port'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_undefine_domain'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_detach_encrypted_volumes
dedent|''
name|'def'
name|'_detach_encrypted_volumes'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Detaches encrypted volumes attached to instance."""'
newline|'\n'
name|'disks'
op|'='
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'self'
op|'.'
name|'get_instance_disk_info'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
op|')'
newline|'\n'
name|'encrypted_volumes'
op|'='
name|'filter'
op|'('
name|'dmcrypt'
op|'.'
name|'is_encrypted'
op|','
nl|'\n'
op|'['
name|'disk'
op|'['
string|"'path'"
op|']'
name|'for'
name|'disk'
name|'in'
name|'disks'
op|']'
op|')'
newline|'\n'
name|'for'
name|'path'
name|'in'
name|'encrypted_volumes'
op|':'
newline|'\n'
indent|'            '
name|'dmcrypt'
op|'.'
name|'delete_volume'
op|'('
name|'path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_serial_ports_from_instance
dedent|''
dedent|''
name|'def'
name|'_get_serial_ports_from_instance'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'mode'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns an iterator over serial port(s) configured on instance.\n\n        :param mode: Should be a value in (None, bind, connect)\n        """'
newline|'\n'
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'virt_dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
name|'tree'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
name|'for'
name|'serial'
name|'in'
name|'tree'
op|'.'
name|'findall'
op|'('
string|'"./devices/serial"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'serial'
op|'.'
name|'get'
op|'('
string|'"type"'
op|')'
op|'=='
string|'"tcp"'
op|':'
newline|'\n'
indent|'                '
name|'source'
op|'='
name|'serial'
op|'.'
name|'find'
op|'('
string|'"./source"'
op|')'
newline|'\n'
name|'if'
name|'source'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'mode'
name|'and'
name|'source'
op|'.'
name|'get'
op|'('
string|'"mode"'
op|')'
op|'!='
name|'mode'
op|':'
newline|'\n'
indent|'                        '
name|'continue'
newline|'\n'
dedent|''
name|'yield'
op|'('
name|'source'
op|'.'
name|'get'
op|'('
string|'"host"'
op|')'
op|','
name|'int'
op|'('
name|'source'
op|'.'
name|'get'
op|'('
string|'"service"'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_get_rbd_driver
name|'def'
name|'_get_rbd_driver'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'rbd_utils'
op|'.'
name|'RBDDriver'
op|'('
nl|'\n'
name|'pool'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_rbd_pool'
op|','
nl|'\n'
name|'ceph_conf'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_rbd_ceph_conf'
op|','
nl|'\n'
name|'rbd_user'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'rbd_user'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_cleanup_rbd
dedent|''
name|'def'
name|'_cleanup_rbd'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LibvirtDriver'
op|'.'
name|'_get_rbd_driver'
op|'('
op|')'
op|'.'
name|'cleanup_volumes'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_cleanup_lvm
dedent|''
name|'def'
name|'_cleanup_lvm'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Delete all LVM disks for given instance object."""'
newline|'\n'
name|'if'
name|'instance'
op|'.'
name|'get'
op|'('
string|"'ephemeral_key_uuid'"
op|')'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_detach_encrypted_volumes'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'disks'
op|'='
name|'self'
op|'.'
name|'_lvm_disks'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'disks'
op|':'
newline|'\n'
indent|'            '
name|'lvm'
op|'.'
name|'remove_volumes'
op|'('
name|'disks'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_lvm_disks
dedent|''
dedent|''
name|'def'
name|'_lvm_disks'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns all LVM disks for given instance object."""'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_volume_group'
op|':'
newline|'\n'
indent|'            '
name|'vg'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
string|"'/dev'"
op|','
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_volume_group'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'vg'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
op|'['
op|']'
newline|'\n'
dedent|''
name|'pattern'
op|'='
string|"'%s_'"
op|'%'
name|'instance'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
nl|'\n'
DECL|function|belongs_to_instance
name|'def'
name|'belongs_to_instance'
op|'('
name|'disk'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'disk'
op|'.'
name|'startswith'
op|'('
name|'pattern'
op|')'
newline|'\n'
nl|'\n'
DECL|function|fullpath
dedent|''
name|'def'
name|'fullpath'
op|'('
name|'name'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'vg'
op|','
name|'name'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'logical_volumes'
op|'='
name|'lvm'
op|'.'
name|'list_volumes'
op|'('
name|'vg'
op|')'
newline|'\n'
nl|'\n'
name|'disk_names'
op|'='
name|'filter'
op|'('
name|'belongs_to_instance'
op|','
name|'logical_volumes'
op|')'
newline|'\n'
name|'disks'
op|'='
name|'map'
op|'('
name|'fullpath'
op|','
name|'disk_names'
op|')'
newline|'\n'
name|'return'
name|'disks'
newline|'\n'
dedent|''
name|'return'
op|'['
op|']'
newline|'\n'
nl|'\n'
DECL|member|get_volume_connector
dedent|''
name|'def'
name|'get_volume_connector'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'self'
op|'.'
name|'_initiator'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_initiator'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_iscsi_initiator'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_initiator'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Could not determine iscsi initiator name'"
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'_fc_wwnns'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_fc_wwnns'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_fc_wwnns'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_fc_wwnns'
name|'or'
name|'len'
op|'('
name|'self'
op|'.'
name|'_fc_wwnns'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Could not determine fibre channel '"
nl|'\n'
string|"'world wide node names'"
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'_fc_wwpns'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_fc_wwpns'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_fc_wwpns'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_fc_wwpns'
name|'or'
name|'len'
op|'('
name|'self'
op|'.'
name|'_fc_wwpns'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Could not determine fibre channel '"
nl|'\n'
string|"'world wide port names'"
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'connector'
op|'='
op|'{'
string|"'ip'"
op|':'
name|'CONF'
op|'.'
name|'my_ip'
op|','
nl|'\n'
string|"'host'"
op|':'
name|'CONF'
op|'.'
name|'host'
op|'}'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_initiator'
op|':'
newline|'\n'
indent|'            '
name|'connector'
op|'['
string|"'initiator'"
op|']'
op|'='
name|'self'
op|'.'
name|'_initiator'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_fc_wwnns'
name|'and'
name|'self'
op|'.'
name|'_fc_wwpns'
op|':'
newline|'\n'
indent|'            '
name|'connector'
op|'['
string|'"wwnns"'
op|']'
op|'='
name|'self'
op|'.'
name|'_fc_wwnns'
newline|'\n'
name|'connector'
op|'['
string|'"wwpns"'
op|']'
op|'='
name|'self'
op|'.'
name|'_fc_wwpns'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'connector'
newline|'\n'
nl|'\n'
DECL|member|_cleanup_resize
dedent|''
name|'def'
name|'_cleanup_resize'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(wangpan): we get the pre-grizzly instance path firstly,'
nl|'\n'
comment|'#                so the backup dir of pre-grizzly instance can'
nl|'\n'
comment|'#                be deleted correctly with grizzly or later nova.'
nl|'\n'
indent|'        '
name|'pre_grizzly_name'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|','
nl|'\n'
name|'forceold'
op|'='
name|'True'
op|')'
newline|'\n'
name|'target'
op|'='
name|'pre_grizzly_name'
op|'+'
string|"'_resize'"
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'target'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'target'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
op|'+'
string|"'_resize'"
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'target'
op|')'
op|':'
newline|'\n'
comment|'# Deletion can fail over NFS, so retry the deletion as required.'
nl|'\n'
comment|'# Set maximum attempt as 5, most test can remove the directory'
nl|'\n'
comment|'# for the second time.'
nl|'\n'
indent|'            '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'rm'"
op|','
string|"'-rf'"
op|','
name|'target'
op|','
name|'delay_on_retry'
op|'='
name|'True'
op|','
nl|'\n'
name|'attempts'
op|'='
number|'5'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'instance'
op|'['
string|"'host'"
op|']'
op|'!='
name|'CONF'
op|'.'
name|'host'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_undefine_domain'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'unplug_vifs'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'unfilter_instance'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_connect_volume
dedent|''
dedent|''
name|'def'
name|'_connect_volume'
op|'('
name|'self'
op|','
name|'connection_info'
op|','
name|'disk_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'driver_type'
op|'='
name|'connection_info'
op|'.'
name|'get'
op|'('
string|"'driver_volume_type'"
op|')'
newline|'\n'
name|'if'
name|'driver_type'
name|'not'
name|'in'
name|'self'
op|'.'
name|'volume_drivers'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'VolumeDriverNotFound'
op|'('
name|'driver_type'
op|'='
name|'driver_type'
op|')'
newline|'\n'
dedent|''
name|'driver'
op|'='
name|'self'
op|'.'
name|'volume_drivers'
op|'['
name|'driver_type'
op|']'
newline|'\n'
name|'return'
name|'driver'
op|'.'
name|'connect_volume'
op|'('
name|'connection_info'
op|','
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_disconnect_volume
dedent|''
name|'def'
name|'_disconnect_volume'
op|'('
name|'self'
op|','
name|'connection_info'
op|','
name|'disk_dev'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'driver_type'
op|'='
name|'connection_info'
op|'.'
name|'get'
op|'('
string|"'driver_volume_type'"
op|')'
newline|'\n'
name|'if'
name|'driver_type'
name|'not'
name|'in'
name|'self'
op|'.'
name|'volume_drivers'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'VolumeDriverNotFound'
op|'('
name|'driver_type'
op|'='
name|'driver_type'
op|')'
newline|'\n'
dedent|''
name|'driver'
op|'='
name|'self'
op|'.'
name|'volume_drivers'
op|'['
name|'driver_type'
op|']'
newline|'\n'
name|'return'
name|'driver'
op|'.'
name|'disconnect_volume'
op|'('
name|'connection_info'
op|','
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_volume_config
dedent|''
name|'def'
name|'_get_volume_config'
op|'('
name|'self'
op|','
name|'connection_info'
op|','
name|'disk_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'driver_type'
op|'='
name|'connection_info'
op|'.'
name|'get'
op|'('
string|"'driver_volume_type'"
op|')'
newline|'\n'
name|'if'
name|'driver_type'
name|'not'
name|'in'
name|'self'
op|'.'
name|'volume_drivers'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'VolumeDriverNotFound'
op|'('
name|'driver_type'
op|'='
name|'driver_type'
op|')'
newline|'\n'
dedent|''
name|'driver'
op|'='
name|'self'
op|'.'
name|'volume_drivers'
op|'['
name|'driver_type'
op|']'
newline|'\n'
name|'return'
name|'driver'
op|'.'
name|'get_config'
op|'('
name|'connection_info'
op|','
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_volume_encryptor
dedent|''
name|'def'
name|'_get_volume_encryptor'
op|'('
name|'self'
op|','
name|'connection_info'
op|','
name|'encryption'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'encryptor'
op|'='
name|'encryptors'
op|'.'
name|'get_volume_encryptor'
op|'('
name|'connection_info'
op|','
nl|'\n'
op|'**'
name|'encryption'
op|')'
newline|'\n'
name|'return'
name|'encryptor'
newline|'\n'
nl|'\n'
DECL|member|attach_volume
dedent|''
name|'def'
name|'attach_volume'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'connection_info'
op|','
name|'instance'
op|','
name|'mountpoint'
op|','
nl|'\n'
name|'disk_bus'
op|'='
name|'None'
op|','
name|'device_type'
op|'='
name|'None'
op|','
name|'encryption'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'instance_name'
op|'='
name|'instance'
op|'['
string|"'name'"
op|']'
newline|'\n'
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance_name'
op|')'
newline|'\n'
name|'disk_dev'
op|'='
name|'mountpoint'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'bdm'
op|'='
op|'{'
nl|'\n'
string|"'device_name'"
op|':'
name|'disk_dev'
op|','
nl|'\n'
string|"'disk_bus'"
op|':'
name|'disk_bus'
op|','
nl|'\n'
string|"'device_type'"
op|':'
name|'device_type'
op|'}'
newline|'\n'
nl|'\n'
comment|'# Note(cfb): If the volume has a custom block size, check that'
nl|'\n'
comment|'#            that we are using QEMU/KVM and libvirt >= 0.10.2. The'
nl|'\n'
comment|'#            presence of a block size is considered mandatory by'
nl|'\n'
comment|"#            cinder so we fail if we can't honor the request."
nl|'\n'
name|'data'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'if'
op|'('
string|"'data'"
name|'in'
name|'connection_info'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'data'
op|'='
name|'connection_info'
op|'['
string|"'data'"
op|']'
newline|'\n'
dedent|''
name|'if'
op|'('
string|"'logical_block_size'"
name|'in'
name|'data'
name|'or'
string|"'physical_block_size'"
name|'in'
name|'data'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'!='
string|'"kvm"'
name|'and'
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'!='
string|'"qemu"'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
name|'_'
op|'('
string|'"Volume sets block size, but the current "'
nl|'\n'
string|'"libvirt hypervisor \'%s\' does not support custom "'
nl|'\n'
string|'"block size"'
op|')'
op|'%'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InvalidHypervisorType'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'self'
op|'.'
name|'_has_min_version'
op|'('
name|'MIN_LIBVIRT_BLOCKIO_VERSION'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'ver'
op|'='
string|'"."'
op|'.'
name|'join'
op|'('
op|'['
name|'str'
op|'('
name|'x'
op|')'
name|'for'
name|'x'
name|'in'
name|'MIN_LIBVIRT_BLOCKIO_VERSION'
op|']'
op|')'
newline|'\n'
name|'msg'
op|'='
name|'_'
op|'('
string|'"Volume sets block size, but libvirt \'%s\' or later is "'
nl|'\n'
string|'"required."'
op|')'
op|'%'
name|'ver'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_info_from_bdm'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
name|'bdm'
op|')'
newline|'\n'
name|'conf'
op|'='
name|'self'
op|'.'
name|'_connect_volume'
op|'('
name|'connection_info'
op|','
name|'disk_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_set_cache_mode'
op|'('
name|'conf'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# NOTE(vish): We can always affect config because our'
nl|'\n'
comment|'#             domains are persistent, but we should only'
nl|'\n'
comment|'#             affect live if the domain is running.'
nl|'\n'
indent|'            '
name|'flags'
op|'='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_AFFECT_CONFIG'
newline|'\n'
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'virt_dom'
op|'.'
name|'info'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|']'
newline|'\n'
name|'if'
name|'state'
name|'in'
op|'('
name|'power_state'
op|'.'
name|'RUNNING'
op|','
name|'power_state'
op|'.'
name|'PAUSED'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'flags'
op|'|='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_AFFECT_LIVE'
newline|'\n'
nl|'\n'
comment|'# cache device_path in connection_info -- required by encryptors'
nl|'\n'
dedent|''
name|'if'
string|"'data'"
name|'in'
name|'connection_info'
op|':'
newline|'\n'
indent|'                '
name|'connection_info'
op|'['
string|"'data'"
op|']'
op|'['
string|"'device_path'"
op|']'
op|'='
name|'conf'
op|'.'
name|'source_path'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'encryption'
op|':'
newline|'\n'
indent|'                '
name|'encryptor'
op|'='
name|'self'
op|'.'
name|'_get_volume_encryptor'
op|'('
name|'connection_info'
op|','
nl|'\n'
name|'encryption'
op|')'
newline|'\n'
name|'encryptor'
op|'.'
name|'attach_volume'
op|'('
name|'context'
op|','
op|'**'
name|'encryption'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'virt_dom'
op|'.'
name|'attachDeviceFlags'
op|'('
name|'conf'
op|'.'
name|'to_xml'
op|'('
op|')'
op|','
name|'flags'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_'
op|'('
string|"'Failed to attach volume at mountpoint: %s'"
op|')'
op|','
nl|'\n'
name|'mountpoint'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'ex'
op|','
name|'libvirt'
op|'.'
name|'libvirtError'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'errcode'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'errcode'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_OPERATION_FAILED'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_disconnect_volume'
op|'('
name|'connection_info'
op|','
name|'disk_dev'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'DeviceIsBusy'
op|'('
name|'device'
op|'='
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_disconnect_volume'
op|'('
name|'connection_info'
op|','
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_swap_volume
dedent|''
dedent|''
dedent|''
name|'def'
name|'_swap_volume'
op|'('
name|'self'
op|','
name|'domain'
op|','
name|'disk_path'
op|','
name|'new_path'
op|','
name|'resize_to'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Swap existing disk with a new block device."""'
newline|'\n'
comment|"# Save a copy of the domain's persistent XML file"
nl|'\n'
name|'xml'
op|'='
name|'domain'
op|'.'
name|'XMLDesc'
op|'('
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_XML_INACTIVE'
op|'|'
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_XML_SECURE'
op|')'
newline|'\n'
nl|'\n'
comment|'# Abort is an idempotent operation, so make sure any block'
nl|'\n'
comment|'# jobs which may have failed are ended.'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'domain'
op|'.'
name|'blockJobAbort'
op|'('
name|'disk_path'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
comment|'# NOTE (rmk): blockRebase cannot be executed on persistent'
nl|'\n'
comment|'#             domains, so we need to temporarily undefine it.'
nl|'\n'
comment|'#             If any part of this block fails, the domain is'
nl|'\n'
comment|'#             re-defined regardless.'
nl|'\n'
indent|'            '
name|'if'
name|'domain'
op|'.'
name|'isPersistent'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'domain'
op|'.'
name|'undefine'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Start copy with VIR_DOMAIN_REBASE_REUSE_EXT flag to'
nl|'\n'
comment|'# allow writing to existing external volume file'
nl|'\n'
dedent|''
name|'domain'
op|'.'
name|'blockRebase'
op|'('
name|'disk_path'
op|','
name|'new_path'
op|','
number|'0'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_BLOCK_REBASE_COPY'
op|'|'
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT'
op|')'
newline|'\n'
nl|'\n'
name|'while'
name|'self'
op|'.'
name|'_wait_for_block_job'
op|'('
name|'domain'
op|','
name|'disk_path'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'time'
op|'.'
name|'sleep'
op|'('
number|'0.5'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'domain'
op|'.'
name|'blockJobAbort'
op|'('
name|'disk_path'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_BLOCK_JOB_ABORT_PIVOT'
op|')'
newline|'\n'
name|'if'
name|'resize_to'
op|':'
newline|'\n'
comment|"# NOTE(alex_xu): domain.blockJobAbort isn't sync call. This"
nl|'\n'
comment|'# is bug in libvirt. So we need waiting for the pivot is'
nl|'\n'
comment|'# finished. libvirt bug #1119173'
nl|'\n'
indent|'                '
name|'while'
name|'self'
op|'.'
name|'_wait_for_block_job'
op|'('
name|'domain'
op|','
name|'disk_path'
op|','
nl|'\n'
name|'wait_for_job_clean'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'time'
op|'.'
name|'sleep'
op|'('
number|'0.5'
op|')'
newline|'\n'
dedent|''
name|'domain'
op|'.'
name|'blockResize'
op|'('
name|'disk_path'
op|','
name|'resize_to'
op|'*'
name|'units'
op|'.'
name|'Gi'
op|'/'
name|'units'
op|'.'
name|'Ki'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'defineXML'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
DECL|member|swap_volume
dedent|''
dedent|''
name|'def'
name|'swap_volume'
op|'('
name|'self'
op|','
name|'old_connection_info'
op|','
nl|'\n'
name|'new_connection_info'
op|','
name|'instance'
op|','
name|'mountpoint'
op|','
name|'resize_to'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'instance_name'
op|'='
name|'instance'
op|'['
string|"'name'"
op|']'
newline|'\n'
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance_name'
op|')'
newline|'\n'
name|'disk_dev'
op|'='
name|'mountpoint'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_disk_xml'
op|'('
name|'virt_dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
op|','
name|'disk_dev'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'xml'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'DiskNotFound'
op|'('
name|'location'
op|'='
name|'disk_dev'
op|')'
newline|'\n'
dedent|''
name|'disk_info'
op|'='
op|'{'
nl|'\n'
string|"'dev'"
op|':'
name|'disk_dev'
op|','
nl|'\n'
string|"'bus'"
op|':'
name|'blockinfo'
op|'.'
name|'get_disk_bus_for_disk_dev'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
name|'disk_dev'
op|')'
op|','
nl|'\n'
string|"'type'"
op|':'
string|"'disk'"
op|','
nl|'\n'
op|'}'
newline|'\n'
name|'conf'
op|'='
name|'self'
op|'.'
name|'_connect_volume'
op|'('
name|'new_connection_info'
op|','
name|'disk_info'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'conf'
op|'.'
name|'source_path'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_disconnect_volume'
op|'('
name|'new_connection_info'
op|','
name|'disk_dev'
op|')'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
name|'_'
op|'('
string|'"Swap only supports host devices"'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_swap_volume'
op|'('
name|'virt_dom'
op|','
name|'disk_dev'
op|','
name|'conf'
op|'.'
name|'source_path'
op|','
name|'resize_to'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_disconnect_volume'
op|'('
name|'old_connection_info'
op|','
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_get_disk_xml
name|'def'
name|'_get_disk_xml'
op|'('
name|'xml'
op|','
name|'device'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns the xml for the disk mounted at device."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
dedent|''
name|'ret'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
string|"'./devices/disk'"
op|')'
newline|'\n'
name|'for'
name|'node'
name|'in'
name|'ret'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'child'
name|'in'
name|'node'
op|'.'
name|'getchildren'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'child'
op|'.'
name|'tag'
op|'=='
string|"'target'"
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'child'
op|'.'
name|'get'
op|'('
string|"'dev'"
op|')'
op|'=='
name|'device'
op|':'
newline|'\n'
indent|'                        '
name|'return'
name|'etree'
op|'.'
name|'tostring'
op|'('
name|'node'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_existing_domain_xml
dedent|''
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_get_existing_domain_xml'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'virt_dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_guest_xml'
op|'('
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
op|','
nl|'\n'
name|'instance'
op|','
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'xml'
newline|'\n'
nl|'\n'
DECL|member|detach_volume
dedent|''
name|'def'
name|'detach_volume'
op|'('
name|'self'
op|','
name|'connection_info'
op|','
name|'instance'
op|','
name|'mountpoint'
op|','
nl|'\n'
name|'encryption'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'instance_name'
op|'='
name|'instance'
op|'['
string|"'name'"
op|']'
newline|'\n'
name|'disk_dev'
op|'='
name|'mountpoint'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance_name'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_disk_xml'
op|'('
name|'virt_dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
op|','
name|'disk_dev'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'xml'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'DiskNotFound'
op|'('
name|'location'
op|'='
name|'disk_dev'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# NOTE(vish): We can always affect config because our'
nl|'\n'
comment|'#             domains are persistent, but we should only'
nl|'\n'
comment|'#             affect live if the domain is running.'
nl|'\n'
indent|'                '
name|'flags'
op|'='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_AFFECT_CONFIG'
newline|'\n'
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'virt_dom'
op|'.'
name|'info'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|']'
newline|'\n'
name|'if'
name|'state'
name|'in'
op|'('
name|'power_state'
op|'.'
name|'RUNNING'
op|','
name|'power_state'
op|'.'
name|'PAUSED'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'flags'
op|'|='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_AFFECT_LIVE'
newline|'\n'
dedent|''
name|'virt_dom'
op|'.'
name|'detachDeviceFlags'
op|'('
name|'xml'
op|','
name|'flags'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'encryption'
op|':'
newline|'\n'
comment|'# The volume must be detached from the VM before'
nl|'\n'
comment|'# disconnecting it from its encryptor. Otherwise, the'
nl|'\n'
comment|'# encryptor may report that the volume is still in use.'
nl|'\n'
indent|'                    '
name|'encryptor'
op|'='
name|'self'
op|'.'
name|'_get_volume_encryptor'
op|'('
name|'connection_info'
op|','
nl|'\n'
name|'encryption'
op|')'
newline|'\n'
name|'encryptor'
op|'.'
name|'detach_volume'
op|'('
op|'**'
name|'encryption'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
comment|'# NOTE(zhaoqin): If the instance does not exist, _lookup_by_name()'
nl|'\n'
comment|'#                will throw InstanceNotFound exception. Need to'
nl|'\n'
comment|'#                disconnect volume under this circumstance.'
nl|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"During detach_volume, instance disappeared."'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
comment|'# NOTE(vish): This is called to cleanup volumes after live'
nl|'\n'
comment|'#             migration, so we should still disconnect even if'
nl|'\n'
comment|"#             the instance doesn't exist here anymore."
nl|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_DOMAIN'
op|':'
newline|'\n'
comment|'# NOTE(vish):'
nl|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"During detach_volume, instance disappeared."'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_disconnect_volume'
op|'('
name|'connection_info'
op|','
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
DECL|member|attach_interface
dedent|''
name|'def'
name|'attach_interface'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'vif'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'flavor'
op|'='
name|'objects'
op|'.'
name|'Flavor'
op|'.'
name|'get_by_id'
op|'('
nl|'\n'
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
name|'read_deleted'
op|'='
string|"'yes'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'instance_type_id'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'plug'
op|'('
name|'instance'
op|','
name|'vif'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'setup_basic_filtering'
op|'('
name|'instance'
op|','
op|'['
name|'vif'
op|']'
op|')'
newline|'\n'
name|'cfg'
op|'='
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'get_config'
op|'('
name|'instance'
op|','
name|'vif'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'flavor'
op|','
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'flags'
op|'='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_AFFECT_CONFIG'
newline|'\n'
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'virt_dom'
op|'.'
name|'info'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|']'
newline|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
name|'or'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'PAUSED'
op|':'
newline|'\n'
indent|'                '
name|'flags'
op|'|='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_AFFECT_LIVE'
newline|'\n'
dedent|''
name|'virt_dom'
op|'.'
name|'attachDeviceFlags'
op|'('
name|'cfg'
op|'.'
name|'to_xml'
op|'('
op|')'
op|','
name|'flags'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'attaching network adapter failed.'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'unplug'
op|'('
name|'instance'
op|','
name|'vif'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InterfaceAttachFailed'
op|'('
nl|'\n'
name|'instance_uuid'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|detach_interface
dedent|''
dedent|''
name|'def'
name|'detach_interface'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'vif'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'flavor'
op|'='
name|'objects'
op|'.'
name|'Flavor'
op|'.'
name|'get_by_id'
op|'('
nl|'\n'
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
name|'read_deleted'
op|'='
string|"'yes'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'instance_type_id'"
op|']'
op|')'
newline|'\n'
name|'cfg'
op|'='
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'get_config'
op|'('
name|'instance'
op|','
name|'vif'
op|','
name|'None'
op|','
name|'flavor'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'unplug'
op|'('
name|'instance'
op|','
name|'vif'
op|')'
newline|'\n'
name|'flags'
op|'='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_AFFECT_CONFIG'
newline|'\n'
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'virt_dom'
op|'.'
name|'info'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|']'
newline|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
name|'or'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'PAUSED'
op|':'
newline|'\n'
indent|'                '
name|'flags'
op|'|='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_AFFECT_LIVE'
newline|'\n'
dedent|''
name|'virt_dom'
op|'.'
name|'detachDeviceFlags'
op|'('
name|'cfg'
op|'.'
name|'to_xml'
op|'('
op|')'
op|','
name|'flags'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_DOMAIN'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"During detach_interface, "'
nl|'\n'
string|'"instance disappeared."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'detaching network adapter failed.'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|','
name|'exc_info'
op|'='
name|'True'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InterfaceDetachFailed'
op|'('
nl|'\n'
name|'instance_uuid'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_create_snapshot_metadata
dedent|''
dedent|''
dedent|''
name|'def'
name|'_create_snapshot_metadata'
op|'('
name|'self'
op|','
name|'base'
op|','
name|'instance'
op|','
name|'img_fmt'
op|','
name|'snp_name'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'metadata'
op|'='
op|'{'
string|"'is_public'"
op|':'
name|'False'
op|','
nl|'\n'
string|"'status'"
op|':'
string|"'active'"
op|','
nl|'\n'
string|"'name'"
op|':'
name|'snp_name'
op|','
nl|'\n'
string|"'properties'"
op|':'
op|'{'
nl|'\n'
string|"'kernel_id'"
op|':'
name|'instance'
op|'['
string|"'kernel_id'"
op|']'
op|','
nl|'\n'
string|"'image_location'"
op|':'
string|"'snapshot'"
op|','
nl|'\n'
string|"'image_state'"
op|':'
string|"'available'"
op|','
nl|'\n'
string|"'owner_id'"
op|':'
name|'instance'
op|'['
string|"'project_id'"
op|']'
op|','
nl|'\n'
string|"'ramdisk_id'"
op|':'
name|'instance'
op|'['
string|"'ramdisk_id'"
op|']'
op|','
nl|'\n'
op|'}'
nl|'\n'
op|'}'
newline|'\n'
name|'if'
name|'instance'
op|'['
string|"'os_type'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'metadata'
op|'['
string|"'properties'"
op|']'
op|'['
string|"'os_type'"
op|']'
op|'='
name|'instance'
op|'['
string|"'os_type'"
op|']'
newline|'\n'
nl|'\n'
comment|'# NOTE(vish): glance forces ami disk format to be ami'
nl|'\n'
dedent|''
name|'if'
name|'base'
op|'.'
name|'get'
op|'('
string|"'disk_format'"
op|')'
op|'=='
string|"'ami'"
op|':'
newline|'\n'
indent|'            '
name|'metadata'
op|'['
string|"'disk_format'"
op|']'
op|'='
string|"'ami'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'metadata'
op|'['
string|"'disk_format'"
op|']'
op|'='
name|'img_fmt'
newline|'\n'
nl|'\n'
dedent|''
name|'metadata'
op|'['
string|"'container_format'"
op|']'
op|'='
name|'base'
op|'.'
name|'get'
op|'('
string|"'container_format'"
op|','
string|"'bare'"
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'metadata'
newline|'\n'
nl|'\n'
DECL|member|snapshot
dedent|''
name|'def'
name|'snapshot'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'image_id'
op|','
name|'update_task_state'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create snapshot from a running VM instance.\n\n        This command only works with qemu 0.14+\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotRunning'
op|'('
name|'instance_id'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'base_image_ref'
op|'='
name|'instance'
op|'['
string|"'image_ref'"
op|']'
newline|'\n'
nl|'\n'
name|'base'
op|'='
name|'compute_utils'
op|'.'
name|'get_image_metadata'
op|'('
nl|'\n'
name|'context'
op|','
name|'self'
op|'.'
name|'_image_api'
op|','
name|'base_image_ref'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'snapshot'
op|'='
name|'self'
op|'.'
name|'_image_api'
op|'.'
name|'get'
op|'('
name|'context'
op|','
name|'image_id'
op|')'
newline|'\n'
nl|'\n'
name|'disk_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'find_disk'
op|'('
name|'virt_dom'
op|')'
newline|'\n'
name|'source_format'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_disk_type'
op|'('
name|'disk_path'
op|')'
newline|'\n'
nl|'\n'
name|'image_format'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'snapshot_image_format'
name|'or'
name|'source_format'
newline|'\n'
nl|'\n'
comment|'# NOTE(bfilippov): save lvm and rbd as raw'
nl|'\n'
name|'if'
name|'image_format'
op|'=='
string|"'lvm'"
name|'or'
name|'image_format'
op|'=='
string|"'rbd'"
op|':'
newline|'\n'
indent|'            '
name|'image_format'
op|'='
string|"'raw'"
newline|'\n'
nl|'\n'
dedent|''
name|'metadata'
op|'='
name|'self'
op|'.'
name|'_create_snapshot_metadata'
op|'('
name|'base'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'image_format'
op|','
nl|'\n'
name|'snapshot'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'snapshot_name'
op|'='
name|'uuid'
op|'.'
name|'uuid4'
op|'('
op|')'
op|'.'
name|'hex'
newline|'\n'
nl|'\n'
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'virt_dom'
op|'.'
name|'info'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|']'
newline|'\n'
nl|'\n'
comment|'# NOTE(rmk): Live snapshots require QEMU 1.3 and Libvirt 1.0.0.'
nl|'\n'
comment|'#            These restrictions can be relaxed as other configurations'
nl|'\n'
comment|'#            can be validated.'
nl|'\n'
comment|'# NOTE(dgenin): Instances with LVM encrypted ephemeral storage require'
nl|'\n'
comment|'#               cold snapshots. Currently, checking for encryption is'
nl|'\n'
comment|'#               redundant because LVM supports only cold snapshots.'
nl|'\n'
comment|'#               It is necessary in case this situation changes in the'
nl|'\n'
comment|'#               future.'
nl|'\n'
name|'if'
op|'('
name|'self'
op|'.'
name|'_has_min_version'
op|'('
name|'MIN_LIBVIRT_LIVESNAPSHOT_VERSION'
op|','
nl|'\n'
name|'MIN_QEMU_LIVESNAPSHOT_VERSION'
op|','
nl|'\n'
name|'REQ_HYPERVISOR_LIVESNAPSHOT'
op|')'
nl|'\n'
name|'and'
name|'source_format'
name|'not'
name|'in'
op|'('
string|"'lvm'"
op|','
string|"'rbd'"
op|')'
nl|'\n'
name|'and'
name|'not'
name|'CONF'
op|'.'
name|'ephemeral_storage_encryption'
op|'.'
name|'enabled'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'live_snapshot'
op|'='
name|'True'
newline|'\n'
comment|'# Abort is an idempotent operation, so make sure any block'
nl|'\n'
comment|'# jobs which may have failed are ended. This operation also'
nl|'\n'
comment|'# confirms the running instance, as opposed to the system as a'
nl|'\n'
comment|'# whole, has a new enough version of the hypervisor (bug 1193146).'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'virt_dom'
op|'.'
name|'blockJobAbort'
op|'('
name|'disk_path'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'                '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_CONFIG_UNSUPPORTED'
op|':'
newline|'\n'
indent|'                    '
name|'live_snapshot'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'pass'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'live_snapshot'
op|'='
name|'False'
newline|'\n'
nl|'\n'
comment|'# NOTE(rmk): We cannot perform live snapshots when a managedSave'
nl|'\n'
comment|'#            file is present, so we will use the cold/legacy method'
nl|'\n'
comment|'#            for instances which are shutdown.'
nl|'\n'
dedent|''
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|':'
newline|'\n'
indent|'            '
name|'live_snapshot'
op|'='
name|'False'
newline|'\n'
nl|'\n'
comment|'# NOTE(dkang): managedSave does not work for LXC'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'!='
string|"'lxc'"
name|'and'
name|'not'
name|'live_snapshot'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
name|'or'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'PAUSED'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_detach_pci_devices'
op|'('
name|'virt_dom'
op|','
nl|'\n'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_detach_sriov_ports'
op|'('
name|'instance'
op|','
name|'virt_dom'
op|')'
newline|'\n'
name|'virt_dom'
op|'.'
name|'managedSave'
op|'('
number|'0'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'snapshot_backend'
op|'='
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'snapshot'
op|'('
name|'instance'
op|','
nl|'\n'
name|'disk_path'
op|','
nl|'\n'
name|'image_type'
op|'='
name|'source_format'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'live_snapshot'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Beginning live snapshot process"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Beginning cold snapshot process"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'update_task_state'
op|'('
name|'task_state'
op|'='
name|'task_states'
op|'.'
name|'IMAGE_PENDING_UPLOAD'
op|')'
newline|'\n'
name|'snapshot_directory'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'snapshots_directory'
newline|'\n'
name|'fileutils'
op|'.'
name|'ensure_tree'
op|'('
name|'snapshot_directory'
op|')'
newline|'\n'
name|'with'
name|'utils'
op|'.'
name|'tempdir'
op|'('
name|'dir'
op|'='
name|'snapshot_directory'
op|')'
name|'as'
name|'tmpdir'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'out_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'tmpdir'
op|','
name|'snapshot_name'
op|')'
newline|'\n'
name|'if'
name|'live_snapshot'
op|':'
newline|'\n'
comment|'# NOTE(xqueralt): libvirt needs o+x in the temp directory'
nl|'\n'
indent|'                    '
name|'os'
op|'.'
name|'chmod'
op|'('
name|'tmpdir'
op|','
number|'0o701'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_live_snapshot'
op|'('
name|'virt_dom'
op|','
name|'disk_path'
op|','
name|'out_path'
op|','
nl|'\n'
name|'image_format'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'snapshot_backend'
op|'.'
name|'snapshot_extract'
op|'('
name|'out_path'
op|','
name|'image_format'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'                '
name|'new_dom'
op|'='
name|'None'
newline|'\n'
comment|'# NOTE(dkang): because previous managedSave is not called'
nl|'\n'
comment|'#              for LXC, _create_domain must not be called.'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'!='
string|"'lxc'"
name|'and'
name|'not'
name|'live_snapshot'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
indent|'                        '
name|'new_dom'
op|'='
name|'self'
op|'.'
name|'_create_domain'
op|'('
name|'domain'
op|'='
name|'virt_dom'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'PAUSED'
op|':'
newline|'\n'
indent|'                        '
name|'new_dom'
op|'='
name|'self'
op|'.'
name|'_create_domain'
op|'('
name|'domain'
op|'='
name|'virt_dom'
op|','
nl|'\n'
name|'launch_flags'
op|'='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_START_PAUSED'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'new_dom'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'_attach_pci_devices'
op|'('
name|'new_dom'
op|','
nl|'\n'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_attach_sriov_ports'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'new_dom'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Snapshot extracted, beginning image upload"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# Upload that image to the image service'
nl|'\n'
nl|'\n'
dedent|''
name|'update_task_state'
op|'('
name|'task_state'
op|'='
name|'task_states'
op|'.'
name|'IMAGE_UPLOADING'
op|','
nl|'\n'
name|'expected_state'
op|'='
name|'task_states'
op|'.'
name|'IMAGE_PENDING_UPLOAD'
op|')'
newline|'\n'
name|'with'
name|'libvirt_utils'
op|'.'
name|'file_open'
op|'('
name|'out_path'
op|')'
name|'as'
name|'image_file'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_image_api'
op|'.'
name|'update'
op|'('
name|'context'
op|','
nl|'\n'
name|'image_id'
op|','
nl|'\n'
name|'metadata'
op|','
nl|'\n'
name|'image_file'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Snapshot image upload complete"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_wait_for_block_job
name|'def'
name|'_wait_for_block_job'
op|'('
name|'domain'
op|','
name|'disk_path'
op|','
name|'abort_on_error'
op|'='
name|'False'
op|','
nl|'\n'
name|'wait_for_job_clean'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Wait for libvirt block job to complete.\n\n        Libvirt may return either cur==end or an empty dict when\n        the job is complete, depending on whether the job has been\n        cleaned up by libvirt yet, or not.\n\n        :returns: True if still in progress\n                  False if completed\n        """'
newline|'\n'
nl|'\n'
name|'status'
op|'='
name|'domain'
op|'.'
name|'blockJobInfo'
op|'('
name|'disk_path'
op|','
number|'0'
op|')'
newline|'\n'
name|'if'
name|'status'
op|'=='
op|'-'
number|'1'
name|'and'
name|'abort_on_error'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|"'libvirt error while requesting blockjob info.'"
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'cur'
op|'='
name|'status'
op|'.'
name|'get'
op|'('
string|"'cur'"
op|','
number|'0'
op|')'
newline|'\n'
name|'end'
op|'='
name|'status'
op|'.'
name|'get'
op|'('
string|"'end'"
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'wait_for_job_clean'
op|':'
newline|'\n'
indent|'            '
name|'job_ended'
op|'='
name|'not'
name|'status'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'job_ended'
op|'='
name|'cur'
op|'=='
name|'end'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'not'
name|'job_ended'
newline|'\n'
nl|'\n'
DECL|member|_live_snapshot
dedent|''
name|'def'
name|'_live_snapshot'
op|'('
name|'self'
op|','
name|'domain'
op|','
name|'disk_path'
op|','
name|'out_path'
op|','
name|'image_format'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Snapshot an instance without downtime."""'
newline|'\n'
comment|"# Save a copy of the domain's persistent XML file"
nl|'\n'
name|'xml'
op|'='
name|'domain'
op|'.'
name|'XMLDesc'
op|'('
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_XML_INACTIVE'
op|'|'
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_XML_SECURE'
op|')'
newline|'\n'
nl|'\n'
comment|'# Abort is an idempotent operation, so make sure any block'
nl|'\n'
comment|'# jobs which may have failed are ended.'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'domain'
op|'.'
name|'blockJobAbort'
op|'('
name|'disk_path'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
comment|'# NOTE (rmk): We are using shallow rebases as a workaround to a bug'
nl|'\n'
comment|'#             in QEMU 1.3. In order to do this, we need to create'
nl|'\n'
comment|'#             a destination image with the original backing file'
nl|'\n'
comment|'#             and matching size of the instance root disk.'
nl|'\n'
dedent|''
name|'src_disk_size'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_disk_size'
op|'('
name|'disk_path'
op|')'
newline|'\n'
name|'src_back_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_disk_backing_file'
op|'('
name|'disk_path'
op|','
nl|'\n'
name|'basename'
op|'='
name|'False'
op|')'
newline|'\n'
name|'disk_delta'
op|'='
name|'out_path'
op|'+'
string|"'.delta'"
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'create_cow_image'
op|'('
name|'src_back_path'
op|','
name|'disk_delta'
op|','
nl|'\n'
name|'src_disk_size'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# NOTE (rmk): blockRebase cannot be executed on persistent'
nl|'\n'
comment|'#             domains, so we need to temporarily undefine it.'
nl|'\n'
comment|'#             If any part of this block fails, the domain is'
nl|'\n'
comment|'#             re-defined regardless.'
nl|'\n'
indent|'            '
name|'if'
name|'domain'
op|'.'
name|'isPersistent'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'domain'
op|'.'
name|'undefine'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE (rmk): Establish a temporary mirror of our root disk and'
nl|'\n'
comment|'#             issue an abort once we have a complete copy.'
nl|'\n'
dedent|''
name|'domain'
op|'.'
name|'blockRebase'
op|'('
name|'disk_path'
op|','
name|'disk_delta'
op|','
number|'0'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_BLOCK_REBASE_COPY'
op|'|'
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT'
op|'|'
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_BLOCK_REBASE_SHALLOW'
op|')'
newline|'\n'
nl|'\n'
name|'while'
name|'self'
op|'.'
name|'_wait_for_block_job'
op|'('
name|'domain'
op|','
name|'disk_path'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'time'
op|'.'
name|'sleep'
op|'('
number|'0.5'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'domain'
op|'.'
name|'blockJobAbort'
op|'('
name|'disk_path'
op|','
number|'0'
op|')'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'chown'
op|'('
name|'disk_delta'
op|','
name|'os'
op|'.'
name|'getuid'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'defineXML'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
comment|'# Convert the delta (CoW) image with a backing file to a flat'
nl|'\n'
comment|'# image with no backing file.'
nl|'\n'
dedent|''
name|'libvirt_utils'
op|'.'
name|'extract_snapshot'
op|'('
name|'disk_delta'
op|','
string|"'qcow2'"
op|','
nl|'\n'
name|'out_path'
op|','
name|'image_format'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_volume_snapshot_update_status
dedent|''
name|'def'
name|'_volume_snapshot_update_status'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'snapshot_id'
op|','
name|'status'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Send a snapshot status update to Cinder.\n\n        This method captures and logs exceptions that occur\n        since callers cannot do anything useful with these exceptions.\n\n        Operations on the Cinder side waiting for this will time out if\n        a failure occurs sending the update.\n\n        :param context: security context\n        :param snapshot_id: id of snapshot being updated\n        :param status: new status value\n\n        """'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_volume_api'
op|'.'
name|'update_snapshot_status'
op|'('
name|'context'
op|','
nl|'\n'
name|'snapshot_id'
op|','
nl|'\n'
name|'status'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Failed to send updated snapshot status '"
nl|'\n'
string|"'to volume service.'"
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_volume_snapshot_create
dedent|''
dedent|''
name|'def'
name|'_volume_snapshot_create'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'domain'
op|','
nl|'\n'
name|'volume_id'
op|','
name|'new_file'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Perform volume snapshot.\n\n           :param domain: VM that volume is attached to\n           :param volume_id: volume UUID to snapshot\n           :param new_file: relative path to new qcow2 file present on share\n\n        """'
newline|'\n'
nl|'\n'
name|'xml'
op|'='
name|'domain'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
name|'xml_doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
name|'device_info'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuest'
op|'('
op|')'
newline|'\n'
name|'device_info'
op|'.'
name|'parse_dom'
op|'('
name|'xml_doc'
op|')'
newline|'\n'
nl|'\n'
name|'disks_to_snap'
op|'='
op|'['
op|']'
comment|'# to be snapshotted by libvirt'
newline|'\n'
name|'network_disks_to_snap'
op|'='
op|'['
op|']'
comment|'# network disks (netfs, gluster, etc.)'
newline|'\n'
name|'disks_to_skip'
op|'='
op|'['
op|']'
comment|'# local disks not snapshotted'
newline|'\n'
nl|'\n'
name|'for'
name|'guest_disk'
name|'in'
name|'device_info'
op|'.'
name|'devices'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
name|'guest_disk'
op|'.'
name|'root_name'
op|'!='
string|"'disk'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'guest_disk'
op|'.'
name|'target_dev'
name|'is'
name|'None'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'guest_disk'
op|'.'
name|'serial'
name|'is'
name|'None'
name|'or'
name|'guest_disk'
op|'.'
name|'serial'
op|'!='
name|'volume_id'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'disks_to_skip'
op|'.'
name|'append'
op|'('
name|'guest_disk'
op|'.'
name|'target_dev'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
comment|'# disk is a Cinder volume with the correct volume_id'
nl|'\n'
nl|'\n'
dedent|''
name|'disk_info'
op|'='
op|'{'
nl|'\n'
string|"'dev'"
op|':'
name|'guest_disk'
op|'.'
name|'target_dev'
op|','
nl|'\n'
string|"'serial'"
op|':'
name|'guest_disk'
op|'.'
name|'serial'
op|','
nl|'\n'
string|"'current_file'"
op|':'
name|'guest_disk'
op|'.'
name|'source_path'
op|','
nl|'\n'
string|"'source_protocol'"
op|':'
name|'guest_disk'
op|'.'
name|'source_protocol'
op|','
nl|'\n'
string|"'source_name'"
op|':'
name|'guest_disk'
op|'.'
name|'source_name'
op|','
nl|'\n'
string|"'source_hosts'"
op|':'
name|'guest_disk'
op|'.'
name|'source_hosts'
op|','
nl|'\n'
string|"'source_ports'"
op|':'
name|'guest_disk'
op|'.'
name|'source_ports'
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
comment|'# Determine path for new_file based on current path'
nl|'\n'
name|'if'
name|'disk_info'
op|'['
string|"'current_file'"
op|']'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'current_file'
op|'='
name|'disk_info'
op|'['
string|"'current_file'"
op|']'
newline|'\n'
name|'new_file_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'dirname'
op|'('
name|'current_file'
op|')'
op|','
nl|'\n'
name|'new_file'
op|')'
newline|'\n'
name|'disks_to_snap'
op|'.'
name|'append'
op|'('
op|'('
name|'current_file'
op|','
name|'new_file_path'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'disk_info'
op|'['
string|"'source_protocol'"
op|']'
name|'in'
op|'('
string|"'gluster'"
op|','
string|"'netfs'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'network_disks_to_snap'
op|'.'
name|'append'
op|'('
op|'('
name|'disk_info'
op|','
name|'new_file'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'disks_to_snap'
name|'and'
name|'not'
name|'network_disks_to_snap'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|"'Found no disk to snapshot.'"
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'snapshot'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSnapshot'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'current_name'
op|','
name|'new_filename'
name|'in'
name|'disks_to_snap'
op|':'
newline|'\n'
indent|'            '
name|'snap_disk'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSnapshotDisk'
op|'('
op|')'
newline|'\n'
name|'snap_disk'
op|'.'
name|'name'
op|'='
name|'current_name'
newline|'\n'
name|'snap_disk'
op|'.'
name|'source_path'
op|'='
name|'new_filename'
newline|'\n'
name|'snap_disk'
op|'.'
name|'source_type'
op|'='
string|"'file'"
newline|'\n'
name|'snap_disk'
op|'.'
name|'snapshot'
op|'='
string|"'external'"
newline|'\n'
name|'snap_disk'
op|'.'
name|'driver_name'
op|'='
string|"'qcow2'"
newline|'\n'
nl|'\n'
name|'snapshot'
op|'.'
name|'add_disk'
op|'('
name|'snap_disk'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'disk_info'
op|','
name|'new_filename'
name|'in'
name|'network_disks_to_snap'
op|':'
newline|'\n'
indent|'            '
name|'snap_disk'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSnapshotDisk'
op|'('
op|')'
newline|'\n'
name|'snap_disk'
op|'.'
name|'name'
op|'='
name|'disk_info'
op|'['
string|"'dev'"
op|']'
newline|'\n'
name|'snap_disk'
op|'.'
name|'source_type'
op|'='
string|"'network'"
newline|'\n'
name|'snap_disk'
op|'.'
name|'source_protocol'
op|'='
name|'disk_info'
op|'['
string|"'source_protocol'"
op|']'
newline|'\n'
name|'snap_disk'
op|'.'
name|'snapshot'
op|'='
string|"'external'"
newline|'\n'
name|'snap_disk'
op|'.'
name|'source_path'
op|'='
name|'new_filename'
newline|'\n'
name|'old_dir'
op|'='
name|'disk_info'
op|'['
string|"'source_name'"
op|']'
op|'.'
name|'split'
op|'('
string|"'/'"
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'snap_disk'
op|'.'
name|'source_name'
op|'='
string|"'%s/%s'"
op|'%'
op|'('
name|'old_dir'
op|','
name|'new_filename'
op|')'
newline|'\n'
name|'snap_disk'
op|'.'
name|'source_hosts'
op|'='
name|'disk_info'
op|'['
string|"'source_hosts'"
op|']'
newline|'\n'
name|'snap_disk'
op|'.'
name|'source_ports'
op|'='
name|'disk_info'
op|'['
string|"'source_ports'"
op|']'
newline|'\n'
nl|'\n'
name|'snapshot'
op|'.'
name|'add_disk'
op|'('
name|'snap_disk'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'dev'
name|'in'
name|'disks_to_skip'
op|':'
newline|'\n'
indent|'            '
name|'snap_disk'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSnapshotDisk'
op|'('
op|')'
newline|'\n'
name|'snap_disk'
op|'.'
name|'name'
op|'='
name|'dev'
newline|'\n'
name|'snap_disk'
op|'.'
name|'snapshot'
op|'='
string|"'no'"
newline|'\n'
nl|'\n'
name|'snapshot'
op|'.'
name|'add_disk'
op|'('
name|'snap_disk'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'snapshot_xml'
op|'='
name|'snapshot'
op|'.'
name|'to_xml'
op|'('
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"snap xml: %s"'
op|','
name|'snapshot_xml'
op|')'
newline|'\n'
nl|'\n'
name|'snap_flags'
op|'='
op|'('
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY'
op|'|'
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA'
op|'|'
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT'
op|')'
newline|'\n'
nl|'\n'
name|'QUIESCE'
op|'='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'domain'
op|'.'
name|'snapshotCreateXML'
op|'('
name|'snapshot_xml'
op|','
nl|'\n'
name|'snap_flags'
op|'|'
name|'QUIESCE'
op|')'
newline|'\n'
nl|'\n'
name|'return'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Unable to create quiesced VM snapshot, '"
nl|'\n'
string|"'attempting again with quiescing disabled.'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'domain'
op|'.'
name|'snapshotCreateXML'
op|'('
name|'snapshot_xml'
op|','
name|'snap_flags'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Unable to create VM snapshot, '"
nl|'\n'
string|"'failing volume_snapshot operation.'"
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'raise'
newline|'\n'
nl|'\n'
DECL|member|_volume_refresh_connection_info
dedent|''
dedent|''
name|'def'
name|'_volume_refresh_connection_info'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'volume_id'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'bdm'
op|'='
name|'objects'
op|'.'
name|'BlockDeviceMapping'
op|'.'
name|'get_by_volume_id'
op|'('
name|'context'
op|','
nl|'\n'
name|'volume_id'
op|')'
newline|'\n'
name|'driver_bdm'
op|'='
name|'driver_block_device'
op|'.'
name|'DriverVolumeBlockDevice'
op|'('
name|'bdm'
op|')'
newline|'\n'
name|'driver_bdm'
op|'.'
name|'refresh_connection_info'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_volume_api'
op|','
name|'self'
op|')'
newline|'\n'
nl|'\n'
DECL|member|volume_snapshot_create
dedent|''
name|'def'
name|'volume_snapshot_create'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'volume_id'
op|','
nl|'\n'
name|'create_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create snapshots of a Cinder volume via libvirt.\n\n        :param instance: VM instance object reference\n        :param volume_id: id of volume being snapshotted\n        :param create_info: dict of information used to create snapshots\n                     - snapshot_id : ID of snapshot\n                     - type : qcow2 / <other>\n                     - new_file : qcow2 file created by Cinder which\n                     becomes the VM\'s active image after\n                     the snapshot is complete\n        """'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"volume_snapshot_create: create_info: %(c_info)s"'
op|','
nl|'\n'
op|'{'
string|"'c_info'"
op|':'
name|'create_info'
op|'}'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'.'
name|'name'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotRunning'
op|'('
name|'instance_id'
op|'='
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'create_info'
op|'['
string|"'type'"
op|']'
op|'!='
string|"'qcow2'"
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'_'
op|'('
string|"'Unknown type: %s'"
op|')'
op|'%'
nl|'\n'
name|'create_info'
op|'['
string|"'type'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'snapshot_id'
op|'='
name|'create_info'
op|'.'
name|'get'
op|'('
string|"'snapshot_id'"
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'snapshot_id'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'_'
op|'('
string|"'snapshot_id required '"
nl|'\n'
string|"'in create_info'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_volume_snapshot_create'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'virt_dom'
op|','
nl|'\n'
name|'volume_id'
op|','
name|'create_info'
op|'['
string|"'new_file'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Error occurred during '"
nl|'\n'
string|"'volume_snapshot_create, '"
nl|'\n'
string|"'sending error status to Cinder.'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_volume_snapshot_update_status'
op|'('
nl|'\n'
name|'context'
op|','
name|'snapshot_id'
op|','
string|"'error'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_volume_snapshot_update_status'
op|'('
nl|'\n'
name|'context'
op|','
name|'snapshot_id'
op|','
string|"'creating'"
op|')'
newline|'\n'
nl|'\n'
DECL|function|_wait_for_snapshot
name|'def'
name|'_wait_for_snapshot'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'snapshot'
op|'='
name|'self'
op|'.'
name|'_volume_api'
op|'.'
name|'get_snapshot'
op|'('
name|'context'
op|','
name|'snapshot_id'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'snapshot'
op|'.'
name|'get'
op|'('
string|"'status'"
op|')'
op|'!='
string|"'creating'"
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_volume_refresh_connection_info'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'volume_id'
op|')'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
name|'_wait_for_snapshot'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_volume_snapshot_delete
dedent|''
name|'def'
name|'_volume_snapshot_delete'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'volume_id'
op|','
nl|'\n'
name|'snapshot_id'
op|','
name|'delete_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Note:\n            if file being merged into == active image:\n                do a blockRebase (pull) operation\n            else:\n                do a blockCommit operation\n            Files must be adjacent in snap chain.\n\n        :param instance: instance object reference\n        :param volume_id: volume UUID\n        :param snapshot_id: snapshot UUID (unused currently)\n        :param delete_info: {\n            \'type\':              \'qcow2\',\n            \'file_to_merge\':     \'a.img\',\n            \'merge_target_file\': \'b.img\' or None (if merging file_to_merge into\n                                                  active image)\n          }\n\n\n        Libvirt blockjob handling required for this method is broken\n        in versions of libvirt that do not contain:\n        http://libvirt.org/git/?p=libvirt.git;h=0f9e67bfad (1.1.1)\n        (Patch is pending in 1.0.5-maint branch as well, but we cannot detect\n        libvirt 1.0.5.5 vs. 1.0.5.6 here.)\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_has_min_version'
op|'('
name|'MIN_LIBVIRT_BLOCKJOBINFO_VERSION'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'ver'
op|'='
string|"'.'"
op|'.'
name|'join'
op|'('
op|'['
name|'str'
op|'('
name|'x'
op|')'
name|'for'
name|'x'
name|'in'
name|'MIN_LIBVIRT_BLOCKJOBINFO_VERSION'
op|']'
op|')'
newline|'\n'
name|'msg'
op|'='
name|'_'
op|'('
string|'"Libvirt \'%s\' or later is required for online deletion "'
nl|'\n'
string|'"of volume snapshots."'
op|')'
op|'%'
name|'ver'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'volume_snapshot_delete: delete_info: %s'"
op|','
name|'delete_info'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'delete_info'
op|'['
string|"'type'"
op|']'
op|'!='
string|"'qcow2'"
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|"'Unknown delete_info type %s'"
op|')'
op|'%'
name|'delete_info'
op|'['
string|"'type'"
op|']'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'.'
name|'name'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotRunning'
op|'('
name|'instance_id'
op|'='
name|'instance'
op|'.'
name|'uuid'
op|')'
newline|'\n'
nl|'\n'
comment|'# Find dev name'
nl|'\n'
dedent|''
name|'my_dev'
op|'='
name|'None'
newline|'\n'
name|'active_disk'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'xml'
op|'='
name|'virt_dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
name|'xml_doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
name|'device_info'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuest'
op|'('
op|')'
newline|'\n'
name|'device_info'
op|'.'
name|'parse_dom'
op|'('
name|'xml_doc'
op|')'
newline|'\n'
nl|'\n'
name|'active_disk_object'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'for'
name|'guest_disk'
name|'in'
name|'device_info'
op|'.'
name|'devices'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
name|'guest_disk'
op|'.'
name|'root_name'
op|'!='
string|"'disk'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'guest_disk'
op|'.'
name|'target_dev'
name|'is'
name|'None'
name|'or'
name|'guest_disk'
op|'.'
name|'serial'
name|'is'
name|'None'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'guest_disk'
op|'.'
name|'serial'
op|'=='
name|'volume_id'
op|':'
newline|'\n'
indent|'                '
name|'my_dev'
op|'='
name|'guest_disk'
op|'.'
name|'target_dev'
newline|'\n'
nl|'\n'
name|'active_disk'
op|'='
name|'guest_disk'
op|'.'
name|'source_path'
newline|'\n'
name|'active_protocol'
op|'='
name|'guest_disk'
op|'.'
name|'source_protocol'
newline|'\n'
name|'active_disk_object'
op|'='
name|'guest_disk'
newline|'\n'
name|'break'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'my_dev'
name|'is'
name|'None'
name|'or'
op|'('
name|'active_disk'
name|'is'
name|'None'
name|'and'
name|'active_protocol'
name|'is'
name|'None'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|"'Disk with id: %s '"
nl|'\n'
string|"'not found attached to instance.'"
op|')'
op|'%'
name|'volume_id'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Domain XML: %s'"
op|','
name|'xml'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"found device at %s"'
op|','
name|'my_dev'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_get_snap_dev
name|'def'
name|'_get_snap_dev'
op|'('
name|'filename'
op|','
name|'backing_store'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'filename'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
name|'_'
op|'('
string|"'filename cannot be None'"
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
comment|'# libgfapi delete'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"XML: %s"'
op|'%'
name|'xml'
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"active disk object: %s"'
op|'%'
name|'active_disk_object'
op|')'
newline|'\n'
nl|'\n'
comment|'# determine reference within backing store for desired image'
nl|'\n'
name|'filename_to_merge'
op|'='
name|'filename'
newline|'\n'
name|'matched_name'
op|'='
name|'None'
newline|'\n'
name|'b'
op|'='
name|'backing_store'
newline|'\n'
name|'index'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'current_filename'
op|'='
name|'active_disk_object'
op|'.'
name|'source_name'
op|'.'
name|'split'
op|'('
string|"'/'"
op|')'
op|'['
number|'1'
op|']'
newline|'\n'
name|'if'
name|'current_filename'
op|'=='
name|'filename_to_merge'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'my_dev'
op|'+'
string|"'[0]'"
newline|'\n'
nl|'\n'
dedent|''
name|'while'
name|'b'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'source_filename'
op|'='
name|'b'
op|'.'
name|'source_name'
op|'.'
name|'split'
op|'('
string|"'/'"
op|')'
op|'['
number|'1'
op|']'
newline|'\n'
name|'if'
name|'source_filename'
op|'=='
name|'filename_to_merge'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'found match: %s'"
op|'%'
name|'b'
op|'.'
name|'source_name'
op|')'
newline|'\n'
name|'matched_name'
op|'='
name|'b'
op|'.'
name|'source_name'
newline|'\n'
name|'index'
op|'='
name|'b'
op|'.'
name|'index'
newline|'\n'
name|'break'
newline|'\n'
nl|'\n'
dedent|''
name|'b'
op|'='
name|'b'
op|'.'
name|'backing_store'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'matched_name'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
name|'_'
op|'('
string|"'no match found for %s'"
op|')'
op|'%'
op|'('
name|'filename_to_merge'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'index of match (%s) is %s'"
op|'%'
op|'('
name|'b'
op|'.'
name|'source_name'
op|','
name|'index'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'my_snap_dev'
op|'='
string|"'%s[%s]'"
op|'%'
op|'('
name|'my_dev'
op|','
name|'index'
op|')'
newline|'\n'
name|'return'
name|'my_snap_dev'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'delete_info'
op|'['
string|"'merge_target_file'"
op|']'
name|'is'
name|'None'
op|':'
newline|'\n'
comment|'# pull via blockRebase()'
nl|'\n'
nl|'\n'
comment|'# Merge the most recent snapshot into the active image'
nl|'\n'
nl|'\n'
indent|'            '
name|'rebase_disk'
op|'='
name|'my_dev'
newline|'\n'
name|'rebase_flags'
op|'='
number|'0'
newline|'\n'
name|'rebase_base'
op|'='
name|'delete_info'
op|'['
string|"'file_to_merge'"
op|']'
comment|'# often None'
newline|'\n'
name|'if'
name|'active_protocol'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'rebase_base'
op|'='
name|'_get_snap_dev'
op|'('
name|'delete_info'
op|'['
string|"'file_to_merge'"
op|']'
op|','
nl|'\n'
name|'active_disk_object'
op|'.'
name|'backing_store'
op|')'
newline|'\n'
dedent|''
name|'rebase_bw'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'disk: %(disk)s, base: %(base)s, '"
nl|'\n'
string|"'bw: %(bw)s, flags: %(flags)s'"
op|','
nl|'\n'
op|'{'
string|"'disk'"
op|':'
name|'rebase_disk'
op|','
nl|'\n'
string|"'base'"
op|':'
name|'rebase_base'
op|','
nl|'\n'
string|"'bw'"
op|':'
name|'rebase_bw'
op|','
nl|'\n'
string|"'flags'"
op|':'
name|'rebase_flags'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'result'
op|'='
name|'virt_dom'
op|'.'
name|'blockRebase'
op|'('
name|'rebase_disk'
op|','
name|'rebase_base'
op|','
nl|'\n'
name|'rebase_bw'
op|','
name|'rebase_flags'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'result'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'blockRebase started successfully'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'while'
name|'self'
op|'.'
name|'_wait_for_block_job'
op|'('
name|'virt_dom'
op|','
name|'my_dev'
op|','
nl|'\n'
name|'abort_on_error'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'waiting for blockRebase job completion'"
op|')'
newline|'\n'
name|'time'
op|'.'
name|'sleep'
op|'('
number|'0.5'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# commit with blockCommit()'
nl|'\n'
indent|'            '
name|'my_snap_base'
op|'='
name|'None'
newline|'\n'
name|'my_snap_top'
op|'='
name|'None'
newline|'\n'
name|'commit_disk'
op|'='
name|'my_dev'
newline|'\n'
name|'commit_flags'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'if'
name|'active_protocol'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'my_snap_base'
op|'='
name|'_get_snap_dev'
op|'('
name|'delete_info'
op|'['
string|"'merge_target_file'"
op|']'
op|','
nl|'\n'
name|'active_disk_object'
op|'.'
name|'backing_store'
op|')'
newline|'\n'
name|'my_snap_top'
op|'='
name|'_get_snap_dev'
op|'('
name|'delete_info'
op|'['
string|"'file_to_merge'"
op|']'
op|','
nl|'\n'
name|'active_disk_object'
op|'.'
name|'backing_store'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'commit_flags'
op|'|='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_BLOCK_COMMIT_RELATIVE'
newline|'\n'
dedent|''
name|'except'
name|'AttributeError'
op|':'
newline|'\n'
indent|'                    '
name|'ver'
op|'='
string|"'.'"
op|'.'
name|'join'
op|'('
nl|'\n'
op|'['
name|'str'
op|'('
name|'x'
op|')'
name|'for'
name|'x'
name|'in'
nl|'\n'
name|'MIN_LIBVIRT_BLOCKCOMMIT_RELATIVE_VERSION'
op|']'
op|')'
newline|'\n'
name|'msg'
op|'='
name|'_'
op|'('
string|'"Relative blockcommit support was not detected. "'
nl|'\n'
string|'"Libvirt \'%s\' or later is required for online "'
nl|'\n'
string|'"deletion of network storage-backed volume "'
nl|'\n'
string|'"snapshots."'
op|')'
op|'%'
name|'ver'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'commit_base'
op|'='
name|'my_snap_base'
name|'or'
name|'delete_info'
op|'['
string|"'merge_target_file'"
op|']'
newline|'\n'
name|'commit_top'
op|'='
name|'my_snap_top'
name|'or'
name|'delete_info'
op|'['
string|"'file_to_merge'"
op|']'
newline|'\n'
name|'bandwidth'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'will call blockCommit with commit_disk=%(commit_disk)s '"
nl|'\n'
string|"'commit_base=%(commit_base)s '"
nl|'\n'
string|"'commit_top=%(commit_top)s '"
nl|'\n'
op|'%'
op|'{'
string|"'commit_disk'"
op|':'
name|'commit_disk'
op|','
nl|'\n'
string|"'commit_base'"
op|':'
name|'commit_base'
op|','
nl|'\n'
string|"'commit_top'"
op|':'
name|'commit_top'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'result'
op|'='
name|'virt_dom'
op|'.'
name|'blockCommit'
op|'('
name|'commit_disk'
op|','
name|'commit_base'
op|','
name|'commit_top'
op|','
nl|'\n'
name|'bandwidth'
op|','
name|'commit_flags'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'result'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'blockCommit started successfully'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'while'
name|'self'
op|'.'
name|'_wait_for_block_job'
op|'('
name|'virt_dom'
op|','
name|'my_dev'
op|','
nl|'\n'
name|'abort_on_error'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'waiting for blockCommit job completion'"
op|')'
newline|'\n'
name|'time'
op|'.'
name|'sleep'
op|'('
number|'0.5'
op|')'
newline|'\n'
nl|'\n'
DECL|member|volume_snapshot_delete
dedent|''
dedent|''
dedent|''
name|'def'
name|'volume_snapshot_delete'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'volume_id'
op|','
name|'snapshot_id'
op|','
nl|'\n'
name|'delete_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_volume_snapshot_delete'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'volume_id'
op|','
nl|'\n'
name|'snapshot_id'
op|','
name|'delete_info'
op|'='
name|'delete_info'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|"'Error occurred during '"
nl|'\n'
string|"'volume_snapshot_delete, '"
nl|'\n'
string|"'sending error status to Cinder.'"
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_volume_snapshot_update_status'
op|'('
nl|'\n'
name|'context'
op|','
name|'snapshot_id'
op|','
string|"'error_deleting'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_volume_snapshot_update_status'
op|'('
name|'context'
op|','
name|'snapshot_id'
op|','
string|"'deleting'"
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_volume_refresh_connection_info'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'volume_id'
op|')'
newline|'\n'
nl|'\n'
DECL|member|reboot
dedent|''
name|'def'
name|'reboot'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'reboot_type'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'bad_volumes_callback'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Reboot a virtual machine, given an instance reference."""'
newline|'\n'
name|'if'
name|'reboot_type'
op|'=='
string|"'SOFT'"
op|':'
newline|'\n'
comment|'# NOTE(vish): This will attempt to do a graceful shutdown/restart.'
nl|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'soft_reboot_success'
op|'='
name|'self'
op|'.'
name|'_soft_reboot'
op|'('
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Instance soft reboot failed: %s"'
op|','
name|'e'
op|')'
newline|'\n'
name|'soft_reboot_success'
op|'='
name|'False'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'soft_reboot_success'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance soft rebooted successfully."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Failed to soft reboot instance. "'
nl|'\n'
string|'"Trying hard reboot."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'_hard_reboot'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_soft_reboot
dedent|''
name|'def'
name|'_soft_reboot'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Attempt to shutdown and restart the instance gracefully.\n\n        We use shutdown and create here so we can return if the guest\n        responded and actually rebooted. Note that this method only\n        succeeds if the guest responds to acpi. Therefore we return\n        success or failure so we can fall back to a hard reboot if\n        necessary.\n\n        :returns: True if the reboot succeeded\n        """'
newline|'\n'
name|'dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|'"name"'
op|']'
op|')'
newline|'\n'
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'dom'
op|'.'
name|'info'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|']'
newline|'\n'
name|'old_domid'
op|'='
name|'dom'
op|'.'
name|'ID'
op|'('
op|')'
newline|'\n'
comment|'# NOTE(vish): This check allows us to reboot an instance that'
nl|'\n'
comment|'#             is already shutdown.'
nl|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
indent|'            '
name|'dom'
op|'.'
name|'shutdown'
op|'('
op|')'
newline|'\n'
comment|'# NOTE(vish): This actually could take slightly longer than the'
nl|'\n'
comment|'#             FLAG defines depending on how long the get_info'
nl|'\n'
comment|'#             call takes to return.'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_prepare_pci_devices_for_use'
op|'('
nl|'\n'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|','
string|"'all'"
op|')'
op|')'
newline|'\n'
name|'for'
name|'x'
name|'in'
name|'xrange'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'wait_soft_reboot_seconds'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|'"name"'
op|']'
op|')'
newline|'\n'
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'dom'
op|'.'
name|'info'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|']'
newline|'\n'
name|'new_domid'
op|'='
name|'dom'
op|'.'
name|'ID'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(ivoks): By checking domain IDs, we make sure we are'
nl|'\n'
comment|"#              not recreating domain that's already running."
nl|'\n'
name|'if'
name|'old_domid'
op|'!='
name|'new_domid'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'state'
name|'in'
op|'['
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|','
nl|'\n'
name|'power_state'
op|'.'
name|'CRASHED'
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance shutdown successfully."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_domain'
op|'('
name|'domain'
op|'='
name|'dom'
op|')'
newline|'\n'
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_wait_for_running'
op|','
name|'instance'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance may have been rebooted during soft "'
nl|'\n'
string|'"reboot, so return now."'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'greenthread'
op|'.'
name|'sleep'
op|'('
number|'1'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|_hard_reboot
dedent|''
name|'def'
name|'_hard_reboot'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Reboot a virtual machine, given an instance reference.\n\n        Performs a Libvirt reset (if supported) on the domain.\n\n        If Libvirt reset is unavailable this method actually destroys and\n        re-creates the domain to ensure the reboot happens, as the guest\n        OS cannot ignore this action.\n\n        If xml is set, it uses the passed in xml in place of the xml from the\n        existing domain.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# Get the system metadata from the instance'
nl|'\n'
name|'system_meta'
op|'='
name|'utils'
op|'.'
name|'instance_sys_meta'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# Convert the system metadata to image metadata'
nl|'\n'
name|'image_meta'
op|'='
name|'utils'
op|'.'
name|'get_image_from_system_metadata'
op|'('
name|'system_meta'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'image_meta'
op|':'
newline|'\n'
indent|'            '
name|'image_ref'
op|'='
name|'instance'
op|'.'
name|'get'
op|'('
string|"'image_ref'"
op|')'
newline|'\n'
name|'image_meta'
op|'='
name|'compute_utils'
op|'.'
name|'get_image_metadata'
op|'('
name|'context'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_image_api'
op|','
nl|'\n'
name|'image_ref'
op|','
nl|'\n'
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'block_device_info'
op|','
nl|'\n'
name|'image_meta'
op|')'
newline|'\n'
comment|'# NOTE(vish): This could generate the wrong device_format if we are'
nl|'\n'
comment|"#             using the raw backend and the images don't exist yet."
nl|'\n'
comment|"#             The create_images_and_backing below doesn't properly"
nl|'\n'
comment|'#             regenerate raw backend images, however, so when it'
nl|'\n'
comment|'#             does we need to (re)generate the xml after the images'
nl|'\n'
comment|'#             are in place.'
nl|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_guest_xml'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'image_meta'
op|'='
name|'image_meta'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|','
nl|'\n'
name|'write_to_disk'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE (rmk): Re-populate any missing backing files.'
nl|'\n'
name|'disk_info_json'
op|'='
name|'self'
op|'.'
name|'_get_instance_disk_info'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|','
name|'xml'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'instance_dir'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_images_and_backing'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'instance_dir'
op|','
nl|'\n'
name|'disk_info_json'
op|')'
newline|'\n'
nl|'\n'
comment|'# Initialize all the necessary networking, block devices and'
nl|'\n'
comment|'# start the instance.'
nl|'\n'
name|'self'
op|'.'
name|'_create_domain_and_network'
op|'('
name|'context'
op|','
name|'xml'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|','
name|'reboot'
op|'='
name|'True'
op|','
nl|'\n'
name|'vifs_already_plugged'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_prepare_pci_devices_for_use'
op|'('
nl|'\n'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|','
string|"'all'"
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_wait_for_reboot
name|'def'
name|'_wait_for_reboot'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Called at an interval until the VM is running again."""'
newline|'\n'
name|'state'
op|'='
name|'self'
op|'.'
name|'get_info'
op|'('
name|'instance'
op|')'
op|'['
string|"'state'"
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance rebooted successfully."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
name|'_wait_for_reboot'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|pause
dedent|''
name|'def'
name|'pause'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Pause VM instance."""'
newline|'\n'
name|'dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'dom'
op|'.'
name|'suspend'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|unpause
dedent|''
name|'def'
name|'unpause'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Unpause paused VM instance."""'
newline|'\n'
name|'dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'dom'
op|'.'
name|'resume'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_clean_shutdown
dedent|''
name|'def'
name|'_clean_shutdown'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'timeout'
op|','
name|'retry_interval'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Attempt to shutdown the instance gracefully.\n\n        :param instance: The instance to be shutdown\n        :param timeout: How long to wait in seconds for the instance to\n                        shutdown\n        :param retry_interval: How often in seconds to signal the instance\n                               to shutdown while waiting\n\n        :returns: True if the shutdown succeeded\n        """'
newline|'\n'
nl|'\n'
comment|'# List of states that represent a shutdown instance'
nl|'\n'
name|'SHUTDOWN_STATES'
op|'='
op|'['
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|','
nl|'\n'
name|'power_state'
op|'.'
name|'CRASHED'
op|']'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|'"name"'
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
comment|"# If the instance has gone then we don't need to"
nl|'\n'
comment|'# wait for it to shutdown'
nl|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
op|'('
name|'state'
op|','
name|'_max_mem'
op|','
name|'_mem'
op|','
name|'_cpus'
op|','
name|'_t'
op|')'
op|'='
name|'dom'
op|'.'
name|'info'
op|'('
op|')'
newline|'\n'
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'state'
op|']'
newline|'\n'
name|'if'
name|'state'
name|'in'
name|'SHUTDOWN_STATES'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance already shutdown."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Shutting down instance from state %s"'
op|','
name|'state'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'dom'
op|'.'
name|'shutdown'
op|'('
op|')'
newline|'\n'
name|'retry_countdown'
op|'='
name|'retry_interval'
newline|'\n'
nl|'\n'
name|'for'
name|'sec'
name|'in'
name|'six'
op|'.'
name|'moves'
op|'.'
name|'range'
op|'('
name|'timeout'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'            '
name|'dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|'"name"'
op|']'
op|')'
newline|'\n'
op|'('
name|'state'
op|','
name|'_max_mem'
op|','
name|'_mem'
op|','
name|'_cpus'
op|','
name|'_t'
op|')'
op|'='
name|'dom'
op|'.'
name|'info'
op|'('
op|')'
newline|'\n'
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'state'
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'state'
name|'in'
name|'SHUTDOWN_STATES'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance shutdown successfully after %d "'
nl|'\n'
string|'"seconds."'
op|')'
op|','
name|'sec'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
nl|'\n'
comment|"# Note(PhilD): We can't assume that the Guest was able to process"
nl|'\n'
comment|'#              any previous shutdown signal (for example it may'
nl|'\n'
comment|'#              have still been startingup, so within the overall'
nl|'\n'
comment|'#              timeout we re-trigger the shutdown every'
nl|'\n'
comment|'#              retry_interval'
nl|'\n'
dedent|''
name|'if'
name|'retry_countdown'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'retry_countdown'
op|'='
name|'retry_interval'
newline|'\n'
comment|'# Instance could shutdown at any time, in which case we'
nl|'\n'
comment|'# will get an exception when we call shutdown'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Instance in state %s after %d seconds - "'
nl|'\n'
string|'"resending shutdown"'
op|','
name|'state'
op|','
name|'sec'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'dom'
op|'.'
name|'shutdown'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
comment|'# Assume this is because its now shutdown, so loop'
nl|'\n'
comment|'# one more time to clean up.'
nl|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Ignoring libvirt exception from shutdown "'
nl|'\n'
string|'"request."'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'retry_countdown'
op|'-='
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'time'
op|'.'
name|'sleep'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance failed to shutdown in %d seconds."'
op|')'
op|','
nl|'\n'
name|'timeout'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|power_off
dedent|''
name|'def'
name|'power_off'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'timeout'
op|'='
number|'0'
op|','
name|'retry_interval'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Power off the specified instance."""'
newline|'\n'
name|'if'
name|'timeout'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_clean_shutdown'
op|'('
name|'instance'
op|','
name|'timeout'
op|','
name|'retry_interval'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|power_on
dedent|''
name|'def'
name|'power_on'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Power on the specified instance."""'
newline|'\n'
comment|'# We use _hard_reboot here to ensure that all backing files,'
nl|'\n'
comment|'# network, and block device connections, etc. are established'
nl|'\n'
comment|'# and available before we attempt to start the instance.'
nl|'\n'
name|'self'
op|'.'
name|'_hard_reboot'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|suspend
dedent|''
name|'def'
name|'suspend'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Suspend the specified instance."""'
newline|'\n'
name|'dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_detach_pci_devices'
op|'('
name|'dom'
op|','
nl|'\n'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_detach_sriov_ports'
op|'('
name|'instance'
op|','
name|'dom'
op|')'
newline|'\n'
name|'dom'
op|'.'
name|'managedSave'
op|'('
number|'0'
op|')'
newline|'\n'
nl|'\n'
DECL|member|resume
dedent|''
name|'def'
name|'resume'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""resume the specified instance."""'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_existing_domain_xml'
op|'('
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'dom'
op|'='
name|'self'
op|'.'
name|'_create_domain_and_network'
op|'('
name|'context'
op|','
name|'xml'
op|','
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|','
name|'block_device_info'
op|'='
name|'block_device_info'
op|','
nl|'\n'
name|'vifs_already_plugged'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_attach_pci_devices'
op|'('
name|'dom'
op|','
nl|'\n'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_attach_sriov_ports'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'dom'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|resume_state_on_host_boot
dedent|''
name|'def'
name|'resume_state_on_host_boot'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""resume guest state when a host is booted."""'
newline|'\n'
comment|'# Check if the instance is running already and avoid doing'
nl|'\n'
comment|'# anything if it is.'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'domain'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'state'
op|'='
name|'LIBVIRT_POWER_STATE'
op|'['
name|'domain'
op|'.'
name|'info'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|']'
newline|'\n'
nl|'\n'
name|'ignored_states'
op|'='
op|'('
name|'power_state'
op|'.'
name|'RUNNING'
op|','
nl|'\n'
name|'power_state'
op|'.'
name|'SUSPENDED'
op|','
nl|'\n'
name|'power_state'
op|'.'
name|'NOSTATE'
op|','
nl|'\n'
name|'power_state'
op|'.'
name|'PAUSED'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'state'
name|'in'
name|'ignored_states'
op|':'
newline|'\n'
indent|'                '
name|'return'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'exception'
op|'.'
name|'NovaException'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
comment|'# Instance is not up and could be in an unknown state.'
nl|'\n'
comment|'# Be as absolute as possible about getting it back into'
nl|'\n'
comment|'# a known and running state.'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_hard_reboot'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|rescue
dedent|''
name|'def'
name|'rescue'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'rescue_password'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Loads a VM using rescue images.\n\n        A rescue is normally performed when something goes wrong with the\n        primary images and data needs to be corrected/recovered. Rescuing\n        should not edit or over-ride the original image, only allow for\n        data recovery.\n\n        """'
newline|'\n'
name|'instance_dir'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'unrescue_xml'
op|'='
name|'self'
op|'.'
name|'_get_existing_domain_xml'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'unrescue_xml_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
string|"'unrescue.xml'"
op|')'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'write_to_file'
op|'('
name|'unrescue_xml_path'
op|','
name|'unrescue_xml'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'image_meta'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'rescue_image_id'
op|'='
name|'image_meta'
op|'.'
name|'get'
op|'('
string|"'id'"
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'rescue_image_id'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'rescue_images'
op|'='
op|'{'
nl|'\n'
string|"'image_id'"
op|':'
op|'('
name|'rescue_image_id'
name|'or'
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'rescue_image_id'
name|'or'
name|'instance'
op|'.'
name|'image_ref'
op|')'
op|','
nl|'\n'
string|"'kernel_id'"
op|':'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'rescue_kernel_id'
name|'or'
nl|'\n'
name|'instance'
op|'.'
name|'kernel_id'
op|')'
op|','
nl|'\n'
string|"'ramdisk_id'"
op|':'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'rescue_ramdisk_id'
name|'or'
nl|'\n'
name|'instance'
op|'.'
name|'ramdisk_id'
op|')'
op|','
nl|'\n'
op|'}'
newline|'\n'
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'None'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'rescue'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_image'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'disk_info'
op|'['
string|"'mapping'"
op|']'
op|','
nl|'\n'
name|'suffix'
op|'='
string|"'.rescue'"
op|','
name|'disk_images'
op|'='
name|'rescue_images'
op|','
nl|'\n'
name|'network_info'
op|'='
name|'network_info'
op|','
nl|'\n'
name|'admin_pass'
op|'='
name|'rescue_password'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_guest_xml'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'image_meta'
op|','
name|'rescue'
op|'='
name|'rescue_images'
op|','
nl|'\n'
name|'write_to_disk'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_domain'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
DECL|member|unrescue
dedent|''
name|'def'
name|'unrescue'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Reboot the VM which is being rescued back into primary images.\n        """'
newline|'\n'
name|'instance_dir'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'unrescue_xml_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
string|"'unrescue.xml'"
op|')'
newline|'\n'
name|'xml'
op|'='
name|'libvirt_utils'
op|'.'
name|'load_file'
op|'('
name|'unrescue_xml_path'
op|')'
newline|'\n'
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'.'
name|'name'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_destroy'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_domain'
op|'('
name|'xml'
op|','
name|'virt_dom'
op|')'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'file_delete'
op|'('
name|'unrescue_xml_path'
op|')'
newline|'\n'
name|'rescue_files'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
string|'"*.rescue"'
op|')'
newline|'\n'
name|'for'
name|'rescue_file'
name|'in'
name|'glob'
op|'.'
name|'iglob'
op|'('
name|'rescue_files'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'libvirt_utils'
op|'.'
name|'file_delete'
op|'('
name|'rescue_file'
op|')'
newline|'\n'
nl|'\n'
DECL|member|poll_rebooting_instances
dedent|''
dedent|''
name|'def'
name|'poll_rebooting_instances'
op|'('
name|'self'
op|','
name|'timeout'
op|','
name|'instances'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|_enable_hairpin
dedent|''
name|'def'
name|'_enable_hairpin'
op|'('
name|'self'
op|','
name|'xml'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'interfaces'
op|'='
name|'self'
op|'.'
name|'_get_interfaces'
op|'('
name|'xml'
op|')'
newline|'\n'
name|'for'
name|'interface'
name|'in'
name|'interfaces'
op|':'
newline|'\n'
indent|'            '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'tee'"
op|','
nl|'\n'
string|"'/sys/class/net/%s/brport/hairpin_mode'"
op|'%'
name|'interface'
op|','
nl|'\n'
name|'process_input'
op|'='
string|"'1'"
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|','
nl|'\n'
name|'check_exit_code'
op|'='
op|'['
number|'0'
op|','
number|'1'
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(ilyaalekseyev): Implementation like in multinics'
nl|'\n'
comment|'# for xenapi(tr3buchet)'
nl|'\n'
DECL|member|spawn
dedent|''
dedent|''
name|'def'
name|'spawn'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'injected_files'
op|','
nl|'\n'
name|'admin_password'
op|','
name|'network_info'
op|'='
name|'None'
op|','
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'block_device_info'
op|','
nl|'\n'
name|'image_meta'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_image'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'disk_info'
op|'['
string|"'mapping'"
op|']'
op|','
nl|'\n'
name|'network_info'
op|'='
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|','
nl|'\n'
name|'files'
op|'='
name|'injected_files'
op|','
nl|'\n'
name|'admin_pass'
op|'='
name|'admin_password'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_guest_xml'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'disk_info'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|','
nl|'\n'
name|'write_to_disk'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_domain_and_network'
op|'('
name|'context'
op|','
name|'xml'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|','
name|'disk_info'
op|'='
name|'disk_info'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Instance is running"'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_wait_for_boot
name|'def'
name|'_wait_for_boot'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Called at an interval until the VM is running."""'
newline|'\n'
name|'state'
op|'='
name|'self'
op|'.'
name|'get_info'
op|'('
name|'instance'
op|')'
op|'['
string|"'state'"
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance spawned successfully."'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
name|'_wait_for_boot'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_flush_libvirt_console
dedent|''
name|'def'
name|'_flush_libvirt_console'
op|'('
name|'self'
op|','
name|'pty'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'out'
op|','
name|'err'
op|'='
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'dd'"
op|','
nl|'\n'
string|"'if=%s'"
op|'%'
name|'pty'
op|','
nl|'\n'
string|"'iflag=nonblock'"
op|','
nl|'\n'
name|'run_as_root'
op|'='
name|'True'
op|','
nl|'\n'
name|'check_exit_code'
op|'='
name|'False'
op|')'
newline|'\n'
name|'return'
name|'out'
newline|'\n'
nl|'\n'
DECL|member|_append_to_file
dedent|''
name|'def'
name|'_append_to_file'
op|'('
name|'self'
op|','
name|'data'
op|','
name|'fpath'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'data: %(data)r, fpath: %(fpath)r'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'data'"
op|':'
name|'data'
op|','
string|"'fpath'"
op|':'
name|'fpath'
op|'}'
op|')'
newline|'\n'
name|'with'
name|'open'
op|'('
name|'fpath'
op|','
string|"'a+'"
op|')'
name|'as'
name|'fp'
op|':'
newline|'\n'
indent|'            '
name|'fp'
op|'.'
name|'write'
op|'('
name|'data'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'fpath'
newline|'\n'
nl|'\n'
DECL|member|get_console_output
dedent|''
name|'def'
name|'get_console_output'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'.'
name|'name'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'virt_dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
name|'tree'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
name|'console_types'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
comment|"# NOTE(comstud): We want to try 'file' types first, then try 'pty'"
nl|'\n'
comment|"# types.  We can't use Python 2.7 syntax of:"
nl|'\n'
comment|'# tree.find("./devices/console[@type=\'file\']/source")'
nl|'\n'
comment|'# because we need to support 2.6.'
nl|'\n'
name|'console_nodes'
op|'='
name|'tree'
op|'.'
name|'findall'
op|'('
string|"'./devices/console'"
op|')'
newline|'\n'
name|'for'
name|'console_node'
name|'in'
name|'console_nodes'
op|':'
newline|'\n'
indent|'            '
name|'console_type'
op|'='
name|'console_node'
op|'.'
name|'get'
op|'('
string|"'type'"
op|')'
newline|'\n'
name|'console_types'
op|'.'
name|'setdefault'
op|'('
name|'console_type'
op|','
op|'['
op|']'
op|')'
newline|'\n'
name|'console_types'
op|'['
name|'console_type'
op|']'
op|'.'
name|'append'
op|'('
name|'console_node'
op|')'
newline|'\n'
nl|'\n'
comment|'# If the guest has a console logging to a file prefer to use that'
nl|'\n'
dedent|''
name|'if'
name|'console_types'
op|'.'
name|'get'
op|'('
string|"'file'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'file_console'
name|'in'
name|'console_types'
op|'.'
name|'get'
op|'('
string|"'file'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'source_node'
op|'='
name|'file_console'
op|'.'
name|'find'
op|'('
string|"'./source'"
op|')'
newline|'\n'
name|'if'
name|'source_node'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'path'
op|'='
name|'source_node'
op|'.'
name|'get'
op|'('
string|'"path"'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'path'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'libvirt_utils'
op|'.'
name|'chown'
op|'('
name|'path'
op|','
name|'os'
op|'.'
name|'getuid'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'with'
name|'libvirt_utils'
op|'.'
name|'file_open'
op|'('
name|'path'
op|','
string|"'rb'"
op|')'
name|'as'
name|'fp'
op|':'
newline|'\n'
indent|'                    '
name|'log_data'
op|','
name|'remaining'
op|'='
name|'utils'
op|'.'
name|'last_bytes'
op|'('
name|'fp'
op|','
nl|'\n'
name|'MAX_CONSOLE_BYTES'
op|')'
newline|'\n'
name|'if'
name|'remaining'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                        '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Truncated console log returned, '"
nl|'\n'
string|"'%d bytes ignored'"
op|')'
op|','
name|'remaining'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'log_data'
newline|'\n'
nl|'\n'
comment|"# Try 'pty' types"
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'console_types'
op|'.'
name|'get'
op|'('
string|"'pty'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'pty_console'
name|'in'
name|'console_types'
op|'.'
name|'get'
op|'('
string|"'pty'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'source_node'
op|'='
name|'pty_console'
op|'.'
name|'find'
op|'('
string|"'./source'"
op|')'
newline|'\n'
name|'if'
name|'source_node'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'pty'
op|'='
name|'source_node'
op|'.'
name|'get'
op|'('
string|'"path"'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'pty'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|'"Guest does not have a console available"'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_chown_console_log_for_instance'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'data'
op|'='
name|'self'
op|'.'
name|'_flush_libvirt_console'
op|'('
name|'pty'
op|')'
newline|'\n'
name|'console_log'
op|'='
name|'self'
op|'.'
name|'_get_console_log_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'fpath'
op|'='
name|'self'
op|'.'
name|'_append_to_file'
op|'('
name|'data'
op|','
name|'console_log'
op|')'
newline|'\n'
nl|'\n'
name|'with'
name|'libvirt_utils'
op|'.'
name|'file_open'
op|'('
name|'fpath'
op|','
string|"'rb'"
op|')'
name|'as'
name|'fp'
op|':'
newline|'\n'
indent|'            '
name|'log_data'
op|','
name|'remaining'
op|'='
name|'utils'
op|'.'
name|'last_bytes'
op|'('
name|'fp'
op|','
name|'MAX_CONSOLE_BYTES'
op|')'
newline|'\n'
name|'if'
name|'remaining'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Truncated console log returned, '"
nl|'\n'
string|"'%d bytes ignored'"
op|')'
op|','
nl|'\n'
name|'remaining'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'log_data'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|get_host_ip_addr
name|'def'
name|'get_host_ip_addr'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'CONF'
op|'.'
name|'my_ip'
newline|'\n'
nl|'\n'
DECL|member|get_vnc_console
dedent|''
name|'def'
name|'get_vnc_console'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
DECL|function|get_vnc_port_for_instance
indent|'        '
name|'def'
name|'get_vnc_port_for_instance'
op|'('
name|'instance_name'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance_name'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'virt_dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
name|'dom'
op|'='
name|'minidom'
op|'.'
name|'parseString'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'graphic'
name|'in'
name|'dom'
op|'.'
name|'getElementsByTagName'
op|'('
string|"'graphics'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'graphic'
op|'.'
name|'getAttribute'
op|'('
string|"'type'"
op|')'
op|'=='
string|"'vnc'"
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'graphic'
op|'.'
name|'getAttribute'
op|'('
string|"'port'"
op|')'
newline|'\n'
comment|'# NOTE(rmk): We had VNC consoles enabled but the instance in'
nl|'\n'
comment|'# question is not actually listening for connections.'
nl|'\n'
dedent|''
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'ConsoleTypeUnavailable'
op|'('
name|'console_type'
op|'='
string|"'vnc'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'port'
op|'='
name|'get_vnc_port_for_instance'
op|'('
name|'instance'
op|'.'
name|'name'
op|')'
newline|'\n'
name|'host'
op|'='
name|'CONF'
op|'.'
name|'vncserver_proxyclient_address'
newline|'\n'
nl|'\n'
name|'return'
name|'ctype'
op|'.'
name|'ConsoleVNC'
op|'('
name|'host'
op|'='
name|'host'
op|','
name|'port'
op|'='
name|'port'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_spice_console
dedent|''
name|'def'
name|'get_spice_console'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
DECL|function|get_spice_ports_for_instance
indent|'        '
name|'def'
name|'get_spice_ports_for_instance'
op|'('
name|'instance_name'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance_name'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'virt_dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
comment|'# TODO(sleepsonthefloor): use etree instead of minidom'
nl|'\n'
name|'dom'
op|'='
name|'minidom'
op|'.'
name|'parseString'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'graphic'
name|'in'
name|'dom'
op|'.'
name|'getElementsByTagName'
op|'('
string|"'graphics'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'graphic'
op|'.'
name|'getAttribute'
op|'('
string|"'type'"
op|')'
op|'=='
string|"'spice'"
op|':'
newline|'\n'
indent|'                    '
name|'return'
op|'('
name|'graphic'
op|'.'
name|'getAttribute'
op|'('
string|"'port'"
op|')'
op|','
nl|'\n'
name|'graphic'
op|'.'
name|'getAttribute'
op|'('
string|"'tlsPort'"
op|')'
op|')'
newline|'\n'
comment|'# NOTE(rmk): We had Spice consoles enabled but the instance in'
nl|'\n'
comment|'# question is not actually listening for connections.'
nl|'\n'
dedent|''
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'ConsoleTypeUnavailable'
op|'('
name|'console_type'
op|'='
string|"'spice'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'ports'
op|'='
name|'get_spice_ports_for_instance'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'host'
op|'='
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'server_proxyclient_address'
newline|'\n'
nl|'\n'
name|'return'
name|'ctype'
op|'.'
name|'ConsoleSpice'
op|'('
name|'host'
op|'='
name|'host'
op|','
name|'port'
op|'='
name|'ports'
op|'['
number|'0'
op|']'
op|','
name|'tlsPort'
op|'='
name|'ports'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_serial_console
dedent|''
name|'def'
name|'get_serial_console'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'host'
op|','
name|'port'
name|'in'
name|'self'
op|'.'
name|'_get_serial_ports_from_instance'
op|'('
nl|'\n'
name|'instance'
op|','
name|'mode'
op|'='
string|"'bind'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'ctype'
op|'.'
name|'ConsoleSerial'
op|'('
name|'host'
op|'='
name|'host'
op|','
name|'port'
op|'='
name|'port'
op|')'
newline|'\n'
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'ConsoleTypeUnavailable'
op|'('
name|'console_type'
op|'='
string|"'serial'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_supports_direct_io
name|'def'
name|'_supports_direct_io'
op|'('
name|'dirpath'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'        '
name|'if'
name|'not'
name|'hasattr'
op|'('
name|'os'
op|','
string|"'O_DIRECT'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"This python runtime does not support direct I/O"'
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
name|'testfile'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'dirpath'
op|','
string|'".directio.test"'
op|')'
newline|'\n'
nl|'\n'
name|'hasDirectIO'
op|'='
name|'True'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'f'
op|'='
name|'os'
op|'.'
name|'open'
op|'('
name|'testfile'
op|','
name|'os'
op|'.'
name|'O_CREAT'
op|'|'
name|'os'
op|'.'
name|'O_WRONLY'
op|'|'
name|'os'
op|'.'
name|'O_DIRECT'
op|')'
newline|'\n'
comment|'# Check is the write allowed with 512 byte alignment'
nl|'\n'
name|'align_size'
op|'='
number|'512'
newline|'\n'
name|'m'
op|'='
name|'mmap'
op|'.'
name|'mmap'
op|'('
op|'-'
number|'1'
op|','
name|'align_size'
op|')'
newline|'\n'
name|'m'
op|'.'
name|'write'
op|'('
string|'r"x"'
op|'*'
name|'align_size'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'write'
op|'('
name|'f'
op|','
name|'m'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'f'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Path \'%(path)s\' supports direct I/O"'
op|','
nl|'\n'
op|'{'
string|"'path'"
op|':'
name|'dirpath'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'EINVAL'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Path \'%(path)s\' does not support direct I/O: "'
nl|'\n'
string|'"\'%(ex)s\'"'
op|','
op|'{'
string|"'path'"
op|':'
name|'dirpath'
op|','
string|"'ex'"
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
name|'hasDirectIO'
op|'='
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|'"Error on \'%(path)s\' while checking "'
nl|'\n'
string|'"direct I/O: \'%(ex)s\'"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'path'"
op|':'
name|'dirpath'
op|','
string|"'ex'"
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|'"Error on \'%(path)s\' while checking direct I/O: "'
nl|'\n'
string|'"\'%(ex)s\'"'
op|')'
op|','
op|'{'
string|"'path'"
op|':'
name|'dirpath'
op|','
string|"'ex'"
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'os'
op|'.'
name|'unlink'
op|'('
name|'testfile'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'hasDirectIO'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_create_local
name|'def'
name|'_create_local'
op|'('
name|'target'
op|','
name|'local_size'
op|','
name|'unit'
op|'='
string|"'G'"
op|','
nl|'\n'
name|'fs_format'
op|'='
name|'None'
op|','
name|'label'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a blank image of specified size."""'
newline|'\n'
nl|'\n'
name|'libvirt_utils'
op|'.'
name|'create_image'
op|'('
string|"'raw'"
op|','
name|'target'
op|','
nl|'\n'
string|"'%d%c'"
op|'%'
op|'('
name|'local_size'
op|','
name|'unit'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_create_ephemeral
dedent|''
name|'def'
name|'_create_ephemeral'
op|'('
name|'self'
op|','
name|'target'
op|','
name|'ephemeral_size'
op|','
nl|'\n'
name|'fs_label'
op|','
name|'os_type'
op|','
name|'is_block_dev'
op|'='
name|'False'
op|','
nl|'\n'
name|'max_size'
op|'='
name|'None'
op|','
name|'context'
op|'='
name|'None'
op|','
name|'specified_fs'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'is_block_dev'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_create_local'
op|'('
name|'target'
op|','
name|'ephemeral_size'
op|')'
newline|'\n'
nl|'\n'
comment|'# Run as root only for block devices.'
nl|'\n'
dedent|''
name|'disk'
op|'.'
name|'mkfs'
op|'('
name|'os_type'
op|','
name|'fs_label'
op|','
name|'target'
op|','
name|'run_as_root'
op|'='
name|'is_block_dev'
op|','
nl|'\n'
name|'specified_fs'
op|'='
name|'specified_fs'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_create_swap
name|'def'
name|'_create_swap'
op|'('
name|'target'
op|','
name|'swap_mb'
op|','
name|'max_size'
op|'='
name|'None'
op|','
name|'context'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a swap file of specified size."""'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'create_image'
op|'('
string|"'raw'"
op|','
name|'target'
op|','
string|"'%dM'"
op|'%'
name|'swap_mb'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'mkfs'
op|'('
string|"'swap'"
op|','
name|'target'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_get_console_log_path
name|'def'
name|'_get_console_log_path'
op|'('
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
op|','
nl|'\n'
string|"'console.log'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_get_disk_config_path
name|'def'
name|'_get_disk_config_path'
op|'('
name|'instance'
op|','
name|'suffix'
op|'='
string|"''"
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
op|','
nl|'\n'
string|"'disk.config'"
op|'+'
name|'suffix'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_chown_console_log_for_instance
dedent|''
name|'def'
name|'_chown_console_log_for_instance'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'console_log'
op|'='
name|'self'
op|'.'
name|'_get_console_log_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'console_log'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'libvirt_utils'
op|'.'
name|'chown'
op|'('
name|'console_log'
op|','
name|'os'
op|'.'
name|'getuid'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_chown_disk_config_for_instance
dedent|''
dedent|''
name|'def'
name|'_chown_disk_config_for_instance'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'disk_config'
op|'='
name|'self'
op|'.'
name|'_get_disk_config_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'disk_config'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'libvirt_utils'
op|'.'
name|'chown'
op|'('
name|'disk_config'
op|','
name|'os'
op|'.'
name|'getuid'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_is_booted_from_volume
name|'def'
name|'_is_booted_from_volume'
op|'('
name|'instance'
op|','
name|'disk_mapping'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Determines whether the VM is booting from volume\n\n        Determines whether the disk mapping indicates that the VM\n        is booting from a volume.\n        """'
newline|'\n'
name|'return'
op|'('
op|'('
name|'not'
name|'bool'
op|'('
name|'instance'
op|'.'
name|'get'
op|'('
string|"'image_ref'"
op|')'
op|')'
op|')'
nl|'\n'
name|'or'
string|"'disk'"
name|'not'
name|'in'
name|'disk_mapping'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_inject_data
dedent|''
name|'def'
name|'_inject_data'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'admin_pass'
op|','
name|'files'
op|','
name|'suffix'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Injects data in a disk image\n\n        Helper used for injecting data in a disk image file system.\n\n        Keyword arguments:\n          instance -- a dict that refers instance specifications\n          network_info -- a dict that refers network speficications\n          admin_pass -- a string used to set an admin password\n          files -- a list of files needs to be injected\n          suffix -- a string used as an image name suffix\n        """'
newline|'\n'
comment|'# Handles the partition need to be used.'
nl|'\n'
name|'target_partition'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'not'
name|'instance'
op|'['
string|"'kernel_id'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'target_partition'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'inject_partition'
newline|'\n'
name|'if'
name|'target_partition'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'target_partition'
op|'='
name|'None'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'lxc'"
op|':'
newline|'\n'
indent|'            '
name|'target_partition'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# Handles the key injection.'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'inject_key'
name|'and'
name|'instance'
op|'.'
name|'get'
op|'('
string|"'key_data'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'key'
op|'='
name|'str'
op|'('
name|'instance'
op|'['
string|"'key_data'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'key'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# Handles the admin password injection.'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'inject_password'
op|':'
newline|'\n'
indent|'            '
name|'admin_pass'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# Handles the network injection.'
nl|'\n'
dedent|''
name|'net'
op|'='
name|'netutils'
op|'.'
name|'get_injected_network_template'
op|'('
nl|'\n'
name|'network_info'
op|','
name|'libvirt_virt_type'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|')'
newline|'\n'
nl|'\n'
comment|'# Handles the metadata injection'
nl|'\n'
name|'metadata'
op|'='
name|'instance'
op|'.'
name|'get'
op|'('
string|"'metadata'"
op|')'
newline|'\n'
nl|'\n'
name|'image_type'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_type'
newline|'\n'
name|'if'
name|'any'
op|'('
op|'('
name|'key'
op|','
name|'net'
op|','
name|'metadata'
op|','
name|'admin_pass'
op|','
name|'files'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'injection_image'
op|'='
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'image'
op|'('
nl|'\n'
name|'instance'
op|','
nl|'\n'
string|"'disk'"
op|'+'
name|'suffix'
op|','
nl|'\n'
name|'image_type'
op|')'
newline|'\n'
name|'img_id'
op|'='
name|'instance'
op|'['
string|"'image_ref'"
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'injection_image'
op|'.'
name|'check_image_exists'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'Image %s not found on disk storage. '"
nl|'\n'
string|"'Continue without injecting data'"
op|')'
op|','
nl|'\n'
name|'injection_image'
op|'.'
name|'path'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'disk'
op|'.'
name|'inject_data'
op|'('
name|'injection_image'
op|'.'
name|'path'
op|','
nl|'\n'
name|'key'
op|','
name|'net'
op|','
name|'metadata'
op|','
name|'admin_pass'
op|','
name|'files'
op|','
nl|'\n'
name|'partition'
op|'='
name|'target_partition'
op|','
nl|'\n'
name|'use_cow'
op|'='
name|'CONF'
op|'.'
name|'use_cow_images'
op|','
nl|'\n'
name|'mandatory'
op|'='
op|'('
string|"'files'"
op|','
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'Error injecting data into image '"
nl|'\n'
string|"'%(img_id)s (%(e)s)'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'img_id'"
op|':'
name|'img_id'
op|','
string|"'e'"
op|':'
name|'e'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_create_image
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_create_image'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'disk_mapping'
op|','
name|'suffix'
op|'='
string|"''"
op|','
nl|'\n'
name|'disk_images'
op|'='
name|'None'
op|','
name|'network_info'
op|'='
name|'None'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'files'
op|'='
name|'None'
op|','
nl|'\n'
name|'admin_pass'
op|'='
name|'None'
op|','
name|'inject_files'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'booted_from_volume'
op|'='
name|'self'
op|'.'
name|'_is_booted_from_volume'
op|'('
nl|'\n'
name|'instance'
op|','
name|'disk_mapping'
op|')'
newline|'\n'
nl|'\n'
DECL|function|image
name|'def'
name|'image'
op|'('
name|'fname'
op|','
name|'image_type'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_type'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'image'
op|'('
name|'instance'
op|','
nl|'\n'
name|'fname'
op|'+'
name|'suffix'
op|','
name|'image_type'
op|')'
newline|'\n'
nl|'\n'
DECL|function|raw
dedent|''
name|'def'
name|'raw'
op|'('
name|'fname'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'image'
op|'('
name|'fname'
op|','
name|'image_type'
op|'='
string|"'raw'"
op|')'
newline|'\n'
nl|'\n'
comment|'# ensure directories exist and are writable'
nl|'\n'
dedent|''
name|'fileutils'
op|'.'
name|'ensure_tree'
op|'('
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Creating image'"
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(dprince): for rescue console.log may already exist... chown it.'
nl|'\n'
name|'self'
op|'.'
name|'_chown_console_log_for_instance'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(yaguang): For evacuate disk.config already exist in shared'
nl|'\n'
comment|'# storage, chown it.'
nl|'\n'
name|'self'
op|'.'
name|'_chown_disk_config_for_instance'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(vish): No need add the suffix to console.log'
nl|'\n'
name|'libvirt_utils'
op|'.'
name|'write_to_file'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_get_console_log_path'
op|'('
name|'instance'
op|')'
op|','
string|"''"
op|','
number|'7'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'disk_images'
op|':'
newline|'\n'
indent|'            '
name|'disk_images'
op|'='
op|'{'
string|"'image_id'"
op|':'
name|'instance'
op|'['
string|"'image_ref'"
op|']'
op|','
nl|'\n'
string|"'kernel_id'"
op|':'
name|'instance'
op|'['
string|"'kernel_id'"
op|']'
op|','
nl|'\n'
string|"'ramdisk_id'"
op|':'
name|'instance'
op|'['
string|"'ramdisk_id'"
op|']'
op|'}'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'disk_images'
op|'['
string|"'kernel_id'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'fname'
op|'='
name|'imagecache'
op|'.'
name|'get_cache_fname'
op|'('
name|'disk_images'
op|','
string|"'kernel_id'"
op|')'
newline|'\n'
name|'raw'
op|'('
string|"'kernel'"
op|')'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'libvirt_utils'
op|'.'
name|'fetch_image'
op|','
nl|'\n'
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'filename'
op|'='
name|'fname'
op|','
nl|'\n'
name|'image_id'
op|'='
name|'disk_images'
op|'['
string|"'kernel_id'"
op|']'
op|','
nl|'\n'
name|'user_id'
op|'='
name|'instance'
op|'['
string|"'user_id'"
op|']'
op|','
nl|'\n'
name|'project_id'
op|'='
name|'instance'
op|'['
string|"'project_id'"
op|']'
op|')'
newline|'\n'
name|'if'
name|'disk_images'
op|'['
string|"'ramdisk_id'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'fname'
op|'='
name|'imagecache'
op|'.'
name|'get_cache_fname'
op|'('
name|'disk_images'
op|','
string|"'ramdisk_id'"
op|')'
newline|'\n'
name|'raw'
op|'('
string|"'ramdisk'"
op|')'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'libvirt_utils'
op|'.'
name|'fetch_image'
op|','
nl|'\n'
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'filename'
op|'='
name|'fname'
op|','
nl|'\n'
name|'image_id'
op|'='
name|'disk_images'
op|'['
string|"'ramdisk_id'"
op|']'
op|','
nl|'\n'
name|'user_id'
op|'='
name|'instance'
op|'['
string|"'user_id'"
op|']'
op|','
nl|'\n'
name|'project_id'
op|'='
name|'instance'
op|'['
string|"'project_id'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'inst_type'
op|'='
name|'flavors'
op|'.'
name|'extract_flavor'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(ndipanov): Even if disk_mapping was passed in, which'
nl|'\n'
comment|"# currently happens only on rescue - we still don't want to"
nl|'\n'
comment|'# create a base image.'
nl|'\n'
name|'if'
name|'not'
name|'booted_from_volume'
op|':'
newline|'\n'
indent|'            '
name|'root_fname'
op|'='
name|'imagecache'
op|'.'
name|'get_cache_fname'
op|'('
name|'disk_images'
op|','
string|"'image_id'"
op|')'
newline|'\n'
name|'size'
op|'='
name|'instance'
op|'['
string|"'root_gb'"
op|']'
op|'*'
name|'units'
op|'.'
name|'Gi'
newline|'\n'
nl|'\n'
name|'if'
name|'size'
op|'=='
number|'0'
name|'or'
name|'suffix'
op|'=='
string|"'.rescue'"
op|':'
newline|'\n'
indent|'                '
name|'size'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'backend'
op|'='
name|'image'
op|'('
string|"'disk'"
op|')'
newline|'\n'
name|'if'
name|'backend'
op|'.'
name|'SUPPORTS_CLONE'
op|':'
newline|'\n'
DECL|function|clone_fallback_to_fetch
indent|'                '
name|'def'
name|'clone_fallback_to_fetch'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'try'
op|':'
newline|'\n'
indent|'                        '
name|'backend'
op|'.'
name|'clone'
op|'('
name|'context'
op|','
name|'disk_images'
op|'['
string|"'image_id'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'ImageUnacceptable'
op|':'
newline|'\n'
indent|'                        '
name|'libvirt_utils'
op|'.'
name|'fetch_image'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'fetch_func'
op|'='
name|'clone_fallback_to_fetch'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'fetch_func'
op|'='
name|'libvirt_utils'
op|'.'
name|'fetch_image'
newline|'\n'
dedent|''
name|'backend'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'fetch_func'
op|','
nl|'\n'
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'filename'
op|'='
name|'root_fname'
op|','
nl|'\n'
name|'size'
op|'='
name|'size'
op|','
nl|'\n'
name|'image_id'
op|'='
name|'disk_images'
op|'['
string|"'image_id'"
op|']'
op|','
nl|'\n'
name|'user_id'
op|'='
name|'instance'
op|'['
string|"'user_id'"
op|']'
op|','
nl|'\n'
name|'project_id'
op|'='
name|'instance'
op|'['
string|"'project_id'"
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Lookup the filesystem type if required'
nl|'\n'
dedent|''
name|'os_type_with_default'
op|'='
name|'disk'
op|'.'
name|'get_fs_type_for_os_type'
op|'('
nl|'\n'
name|'instance'
op|'['
string|"'os_type'"
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'ephemeral_gb'
op|'='
name|'instance'
op|'['
string|"'ephemeral_gb'"
op|']'
newline|'\n'
name|'if'
string|"'disk.local'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'            '
name|'disk_image'
op|'='
name|'image'
op|'('
string|"'disk.local'"
op|')'
newline|'\n'
name|'fn'
op|'='
name|'functools'
op|'.'
name|'partial'
op|'('
name|'self'
op|'.'
name|'_create_ephemeral'
op|','
nl|'\n'
name|'fs_label'
op|'='
string|"'ephemeral0'"
op|','
nl|'\n'
name|'os_type'
op|'='
name|'instance'
op|'['
string|'"os_type"'
op|']'
op|','
nl|'\n'
name|'is_block_dev'
op|'='
name|'disk_image'
op|'.'
name|'is_block_dev'
op|')'
newline|'\n'
name|'fname'
op|'='
string|'"ephemeral_%s_%s"'
op|'%'
op|'('
name|'ephemeral_gb'
op|','
name|'os_type_with_default'
op|')'
newline|'\n'
name|'size'
op|'='
name|'ephemeral_gb'
op|'*'
name|'units'
op|'.'
name|'Gi'
newline|'\n'
name|'disk_image'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'fn'
op|','
nl|'\n'
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'filename'
op|'='
name|'fname'
op|','
nl|'\n'
name|'size'
op|'='
name|'size'
op|','
nl|'\n'
name|'ephemeral_size'
op|'='
name|'ephemeral_gb'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'idx'
op|','
name|'eph'
name|'in'
name|'enumerate'
op|'('
name|'driver'
op|'.'
name|'block_device_info_get_ephemerals'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'disk_image'
op|'='
name|'image'
op|'('
name|'blockinfo'
op|'.'
name|'get_eph_disk'
op|'('
name|'idx'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'specified_fs'
op|'='
name|'eph'
op|'.'
name|'get'
op|'('
string|"'guest_format'"
op|')'
newline|'\n'
name|'if'
name|'specified_fs'
name|'and'
name|'not'
name|'self'
op|'.'
name|'is_supported_fs_format'
op|'('
name|'specified_fs'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
name|'_'
op|'('
string|'"%s format is not supported"'
op|')'
op|'%'
name|'specified_fs'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InvalidBDMFormat'
op|'('
name|'details'
op|'='
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'fn'
op|'='
name|'functools'
op|'.'
name|'partial'
op|'('
name|'self'
op|'.'
name|'_create_ephemeral'
op|','
nl|'\n'
name|'fs_label'
op|'='
string|"'ephemeral%d'"
op|'%'
name|'idx'
op|','
nl|'\n'
name|'os_type'
op|'='
name|'instance'
op|'['
string|'"os_type"'
op|']'
op|','
nl|'\n'
name|'is_block_dev'
op|'='
name|'disk_image'
op|'.'
name|'is_block_dev'
op|')'
newline|'\n'
name|'size'
op|'='
name|'eph'
op|'['
string|"'size'"
op|']'
op|'*'
name|'units'
op|'.'
name|'Gi'
newline|'\n'
name|'fname'
op|'='
string|'"ephemeral_%s_%s"'
op|'%'
op|'('
name|'eph'
op|'['
string|"'size'"
op|']'
op|','
name|'os_type_with_default'
op|')'
newline|'\n'
name|'disk_image'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'fn'
op|','
nl|'\n'
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'filename'
op|'='
name|'fname'
op|','
nl|'\n'
name|'size'
op|'='
name|'size'
op|','
nl|'\n'
name|'ephemeral_size'
op|'='
name|'eph'
op|'['
string|"'size'"
op|']'
op|','
nl|'\n'
name|'specified_fs'
op|'='
name|'specified_fs'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
string|"'disk.swap'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'            '
name|'mapping'
op|'='
name|'disk_mapping'
op|'['
string|"'disk.swap'"
op|']'
newline|'\n'
name|'swap_mb'
op|'='
number|'0'
newline|'\n'
nl|'\n'
name|'swap'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_swap'
op|'('
name|'block_device_info'
op|')'
newline|'\n'
name|'if'
name|'driver'
op|'.'
name|'swap_is_usable'
op|'('
name|'swap'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'swap_mb'
op|'='
name|'swap'
op|'['
string|"'swap_size'"
op|']'
newline|'\n'
dedent|''
name|'elif'
op|'('
name|'inst_type'
op|'['
string|"'swap'"
op|']'
op|'>'
number|'0'
name|'and'
nl|'\n'
name|'not'
name|'block_device'
op|'.'
name|'volume_in_mapping'
op|'('
nl|'\n'
name|'mapping'
op|'['
string|"'dev'"
op|']'
op|','
name|'block_device_info'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'swap_mb'
op|'='
name|'inst_type'
op|'['
string|"'swap'"
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'swap_mb'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'size'
op|'='
name|'swap_mb'
op|'*'
name|'units'
op|'.'
name|'Mi'
newline|'\n'
name|'image'
op|'('
string|"'disk.swap'"
op|')'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'self'
op|'.'
name|'_create_swap'
op|','
nl|'\n'
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'filename'
op|'='
string|'"swap_%s"'
op|'%'
name|'swap_mb'
op|','
nl|'\n'
name|'size'
op|'='
name|'size'
op|','
nl|'\n'
name|'swap_mb'
op|'='
name|'swap_mb'
op|')'
newline|'\n'
nl|'\n'
comment|'# Config drive'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'configdrive'
op|'.'
name|'required_by'
op|'('
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Using config drive'"
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'extra_md'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'if'
name|'admin_pass'
op|':'
newline|'\n'
indent|'                '
name|'extra_md'
op|'['
string|"'admin_pass'"
op|']'
op|'='
name|'admin_pass'
newline|'\n'
nl|'\n'
dedent|''
name|'inst_md'
op|'='
name|'instance_metadata'
op|'.'
name|'InstanceMetadata'
op|'('
name|'instance'
op|','
nl|'\n'
name|'content'
op|'='
name|'files'
op|','
name|'extra_md'
op|'='
name|'extra_md'
op|','
name|'network_info'
op|'='
name|'network_info'
op|')'
newline|'\n'
name|'with'
name|'configdrive'
op|'.'
name|'ConfigDriveBuilder'
op|'('
name|'instance_md'
op|'='
name|'inst_md'
op|')'
name|'as'
name|'cdb'
op|':'
newline|'\n'
indent|'                '
name|'configdrive_path'
op|'='
name|'self'
op|'.'
name|'_get_disk_config_path'
op|'('
name|'instance'
op|','
name|'suffix'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Creating config drive at %(path)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'path'"
op|':'
name|'configdrive_path'
op|'}'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'cdb'
op|'.'
name|'make_drive'
op|'('
name|'configdrive_path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'processutils'
op|'.'
name|'ProcessExecutionError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                    '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'Creating config drive failed '"
nl|'\n'
string|"'with error: %s'"
op|')'
op|','
nl|'\n'
name|'e'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# File injection only if needed'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'elif'
name|'inject_files'
name|'and'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'inject_partition'
op|'!='
op|'-'
number|'2'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'booted_from_volume'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'File injection into a boot from volume '"
nl|'\n'
string|"'instance is not supported'"
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_inject_data'
op|'('
nl|'\n'
name|'instance'
op|','
name|'network_info'
op|','
name|'admin_pass'
op|','
name|'files'
op|','
name|'suffix'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'uml'"
op|':'
newline|'\n'
indent|'            '
name|'libvirt_utils'
op|'.'
name|'chown'
op|'('
name|'image'
op|'('
string|"'disk'"
op|')'
op|'.'
name|'path'
op|','
string|"'root'"
op|')'
newline|'\n'
nl|'\n'
DECL|member|_prepare_pci_devices_for_use
dedent|''
dedent|''
name|'def'
name|'_prepare_pci_devices_for_use'
op|'('
name|'self'
op|','
name|'pci_devices'
op|')'
op|':'
newline|'\n'
comment|'# kvm , qemu support managed mode'
nl|'\n'
comment|'# In managed mode, the configured device will be automatically'
nl|'\n'
comment|'# detached from the host OS drivers when the guest is started,'
nl|'\n'
comment|'# and then re-attached when the guest shuts down.'
nl|'\n'
indent|'        '
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'!='
string|"'xen'"
op|':'
newline|'\n'
comment|'# we do manual detach only for xen'
nl|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'dev'
name|'in'
name|'pci_devices'
op|':'
newline|'\n'
indent|'                '
name|'libvirt_dev_addr'
op|'='
name|'dev'
op|'['
string|"'hypervisor_name'"
op|']'
newline|'\n'
name|'libvirt_dev'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'nodeDeviceLookupByName'
op|'('
name|'libvirt_dev_addr'
op|')'
newline|'\n'
comment|"# Note(yjiang5) Spelling for 'dettach' is correct, see"
nl|'\n'
comment|'# http://libvirt.org/html/libvirt-libvirt.html.'
nl|'\n'
name|'libvirt_dev'
op|'.'
name|'dettach'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Note(yjiang5): A reset of one PCI device may impact other'
nl|'\n'
comment|'# devices on the same bus, thus we need two separated loops'
nl|'\n'
comment|'# to detach and then reset it.'
nl|'\n'
dedent|''
name|'for'
name|'dev'
name|'in'
name|'pci_devices'
op|':'
newline|'\n'
indent|'                '
name|'libvirt_dev_addr'
op|'='
name|'dev'
op|'['
string|"'hypervisor_name'"
op|']'
newline|'\n'
name|'libvirt_dev'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'nodeDeviceLookupByName'
op|'('
name|'libvirt_dev_addr'
op|')'
newline|'\n'
name|'libvirt_dev'
op|'.'
name|'reset'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'PciDevicePrepareFailed'
op|'('
name|'id'
op|'='
name|'dev'
op|'['
string|"'id'"
op|']'
op|','
nl|'\n'
name|'instance_uuid'
op|'='
nl|'\n'
name|'dev'
op|'['
string|"'instance_uuid'"
op|']'
op|','
nl|'\n'
name|'reason'
op|'='
name|'six'
op|'.'
name|'text_type'
op|'('
name|'exc'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_detach_pci_devices
dedent|''
dedent|''
name|'def'
name|'_detach_pci_devices'
op|'('
name|'self'
op|','
name|'dom'
op|','
name|'pci_devs'
op|')'
op|':'
newline|'\n'
nl|'\n'
comment|'# for libvirt version < 1.1.1, this is race condition'
nl|'\n'
comment|'# so forbid detach if not had this version'
nl|'\n'
indent|'        '
name|'if'
name|'not'
name|'self'
op|'.'
name|'_has_min_version'
op|'('
name|'MIN_LIBVIRT_DEVICE_CALLBACK_VERSION'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'pci_devs'
op|':'
newline|'\n'
indent|'                '
name|'reason'
op|'='
op|'('
name|'_'
op|'('
string|'"Detaching PCI devices with libvirt < %(ver)s"'
nl|'\n'
string|'" is not permitted"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'ver'"
op|':'
name|'MIN_LIBVIRT_DEVICE_CALLBACK_VERSION'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'PciDeviceDetachFailed'
op|'('
name|'reason'
op|'='
name|'reason'
op|','
nl|'\n'
name|'dev'
op|'='
name|'pci_devs'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'dev'
name|'in'
name|'pci_devs'
op|':'
newline|'\n'
indent|'                '
name|'dom'
op|'.'
name|'detachDeviceFlags'
op|'('
name|'self'
op|'.'
name|'_get_guest_pci_device'
op|'('
name|'dev'
op|')'
op|'.'
name|'to_xml'
op|'('
op|')'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_AFFECT_LIVE'
op|')'
newline|'\n'
comment|'# after detachDeviceFlags returned, we should check the dom to'
nl|'\n'
comment|'# ensure the detaching is finished'
nl|'\n'
name|'xml'
op|'='
name|'dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
name|'xml_doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
name|'guest_config'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuest'
op|'('
op|')'
newline|'\n'
name|'guest_config'
op|'.'
name|'parse_dom'
op|'('
name|'xml_doc'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'hdev'
name|'in'
op|'['
name|'d'
name|'for'
name|'d'
name|'in'
name|'guest_config'
op|'.'
name|'devices'
nl|'\n'
name|'if'
name|'isinstance'
op|'('
name|'d'
op|','
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestHostdevPCI'
op|')'
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'hdbsf'
op|'='
op|'['
name|'hdev'
op|'.'
name|'domain'
op|','
name|'hdev'
op|'.'
name|'bus'
op|','
name|'hdev'
op|'.'
name|'slot'
op|','
name|'hdev'
op|'.'
name|'function'
op|']'
newline|'\n'
name|'dbsf'
op|'='
name|'pci_utils'
op|'.'
name|'parse_address'
op|'('
name|'dev'
op|'['
string|"'address'"
op|']'
op|')'
newline|'\n'
name|'if'
op|'['
name|'int'
op|'('
name|'x'
op|','
number|'16'
op|')'
name|'for'
name|'x'
name|'in'
name|'hdbsf'
op|']'
op|'=='
op|'['
name|'int'
op|'('
name|'x'
op|','
number|'16'
op|')'
name|'for'
name|'x'
name|'in'
name|'dbsf'
op|']'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
name|'exception'
op|'.'
name|'PciDeviceDetachFailed'
op|'('
name|'reason'
op|'='
nl|'\n'
string|'"timeout"'
op|','
nl|'\n'
name|'dev'
op|'='
name|'dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_DOMAIN'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Instance disappeared while detaching "'
nl|'\n'
string|'"a PCI device from it."'
op|')'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
nl|'\n'
DECL|member|_attach_pci_devices
dedent|''
dedent|''
dedent|''
name|'def'
name|'_attach_pci_devices'
op|'('
name|'self'
op|','
name|'dom'
op|','
name|'pci_devs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'dev'
name|'in'
name|'pci_devs'
op|':'
newline|'\n'
indent|'                '
name|'dom'
op|'.'
name|'attachDevice'
op|'('
name|'self'
op|'.'
name|'_get_guest_pci_device'
op|'('
name|'dev'
op|')'
op|'.'
name|'to_xml'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'Attaching PCI devices %(dev)s to %(dom)s failed.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'dev'"
op|':'
name|'pci_devs'
op|','
string|"'dom'"
op|':'
name|'dom'
op|'.'
name|'ID'
op|'('
op|')'
op|'}'
op|')'
newline|'\n'
name|'raise'
newline|'\n'
nl|'\n'
DECL|member|_prepare_args_for_get_config
dedent|''
dedent|''
name|'def'
name|'_prepare_args_for_get_config'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'flavor'
op|'='
name|'objects'
op|'.'
name|'Flavor'
op|'.'
name|'get_by_id'
op|'('
name|'context'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'instance_type_id'"
op|']'
op|')'
newline|'\n'
name|'image_ref'
op|'='
name|'instance'
op|'['
string|"'image_ref'"
op|']'
newline|'\n'
name|'image_meta'
op|'='
name|'compute_utils'
op|'.'
name|'get_image_metadata'
op|'('
nl|'\n'
name|'context'
op|','
name|'self'
op|'.'
name|'_image_api'
op|','
name|'image_ref'
op|','
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'flavor'
op|','
name|'image_meta'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_has_sriov_port
name|'def'
name|'_has_sriov_port'
op|'('
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'vif'
op|'['
string|"'vnic_type'"
op|']'
op|'=='
name|'network_model'
op|'.'
name|'VNIC_TYPE_DIRECT'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'True'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|_attach_sriov_ports
dedent|''
name|'def'
name|'_attach_sriov_ports'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'dom'
op|','
name|'network_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'network_info'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'network_info'
op|'='
name|'instance'
op|'.'
name|'info_cache'
op|'.'
name|'network_info'
newline|'\n'
dedent|''
name|'if'
name|'network_info'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_has_sriov_port'
op|'('
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'flavor'
op|','
name|'image_meta'
op|'='
name|'self'
op|'.'
name|'_prepare_args_for_get_config'
op|'('
name|'context'
op|','
nl|'\n'
name|'instance'
op|')'
newline|'\n'
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'vif'
op|'['
string|"'vnic_type'"
op|']'
op|'=='
name|'network_model'
op|'.'
name|'VNIC_TYPE_DIRECT'
op|':'
newline|'\n'
indent|'                    '
name|'cfg'
op|'='
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'get_config'
op|'('
name|'instance'
op|','
nl|'\n'
name|'vif'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'flavor'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Attaching SR-IOV port %(port)s to %(dom)s'"
op|','
nl|'\n'
op|'{'
string|"'port'"
op|':'
name|'vif'
op|','
string|"'dom'"
op|':'
name|'dom'
op|'.'
name|'ID'
op|'('
op|')'
op|'}'
op|')'
newline|'\n'
name|'dom'
op|'.'
name|'attachDevice'
op|'('
name|'cfg'
op|'.'
name|'to_xml'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_detach_sriov_ports
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_detach_sriov_ports'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'dom'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'network_info'
op|'='
name|'instance'
op|'.'
name|'info_cache'
op|'.'
name|'network_info'
newline|'\n'
name|'if'
name|'network_info'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'context'
op|'='
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_has_sriov_port'
op|'('
name|'network_info'
op|')'
op|':'
newline|'\n'
comment|'# for libvirt version < 1.1.1, this is race condition'
nl|'\n'
comment|"# so forbid detach if it's an older version"
nl|'\n'
indent|'            '
name|'if'
name|'not'
name|'self'
op|'.'
name|'_has_min_version'
op|'('
nl|'\n'
name|'MIN_LIBVIRT_DEVICE_CALLBACK_VERSION'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'reason'
op|'='
op|'('
name|'_'
op|'('
string|'"Detaching SR-IOV ports with"'
nl|'\n'
string|'" libvirt < %(ver)s is not permitted"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'ver'"
op|':'
name|'MIN_LIBVIRT_DEVICE_CALLBACK_VERSION'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'PciDeviceDetachFailed'
op|'('
name|'reason'
op|'='
name|'reason'
op|','
nl|'\n'
name|'dev'
op|'='
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'flavor'
op|','
name|'image_meta'
op|'='
name|'self'
op|'.'
name|'_prepare_args_for_get_config'
op|'('
name|'context'
op|','
nl|'\n'
name|'instance'
op|')'
newline|'\n'
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'vif'
op|'['
string|"'vnic_type'"
op|']'
op|'=='
name|'network_model'
op|'.'
name|'VNIC_TYPE_DIRECT'
op|':'
newline|'\n'
indent|'                    '
name|'cfg'
op|'='
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'get_config'
op|'('
name|'instance'
op|','
nl|'\n'
name|'vif'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'flavor'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|')'
newline|'\n'
name|'dom'
op|'.'
name|'detachDeviceFlags'
op|'('
name|'cfg'
op|'.'
name|'to_xml'
op|'('
op|')'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_AFFECT_LIVE'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_set_host_enabled
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_set_host_enabled'
op|'('
name|'self'
op|','
name|'enabled'
op|','
nl|'\n'
name|'disable_reason'
op|'='
name|'DISABLE_REASON_UNDEFINED'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Enables / Disables the compute service on this host.\n\n           This doesn\'t override non-automatic disablement with an automatic\n           setting; thereby permitting operators to keep otherwise\n           healthy hosts out of rotation.\n        """'
newline|'\n'
nl|'\n'
name|'status_name'
op|'='
op|'{'
name|'True'
op|':'
string|"'disabled'"
op|','
nl|'\n'
name|'False'
op|':'
string|"'enabled'"
op|'}'
newline|'\n'
nl|'\n'
name|'disable_service'
op|'='
name|'not'
name|'enabled'
newline|'\n'
nl|'\n'
name|'ctx'
op|'='
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'service'
op|'='
name|'objects'
op|'.'
name|'Service'
op|'.'
name|'get_by_compute_host'
op|'('
name|'ctx'
op|','
name|'CONF'
op|'.'
name|'host'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'service'
op|'.'
name|'disabled'
op|'!='
name|'disable_service'
op|':'
newline|'\n'
comment|'# Note(jang): this is a quick fix to stop operator-'
nl|'\n'
comment|'# disabled compute hosts from re-enabling themselves'
nl|'\n'
comment|'# automatically. We prefix any automatic reason code'
nl|'\n'
comment|'# with a fixed string. We only re-enable a host'
nl|'\n'
comment|'# automatically if we find that string in place.'
nl|'\n'
comment|'# This should probably be replaced with a separate flag.'
nl|'\n'
indent|'                '
name|'if'
name|'not'
name|'service'
op|'.'
name|'disabled'
name|'or'
op|'('
nl|'\n'
name|'service'
op|'.'
name|'disabled_reason'
name|'and'
nl|'\n'
name|'service'
op|'.'
name|'disabled_reason'
op|'.'
name|'startswith'
op|'('
name|'DISABLE_PREFIX'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'service'
op|'.'
name|'disabled'
op|'='
name|'disable_service'
newline|'\n'
name|'service'
op|'.'
name|'disabled_reason'
op|'='
op|'('
nl|'\n'
name|'DISABLE_PREFIX'
op|'+'
name|'disable_reason'
nl|'\n'
name|'if'
name|'disable_service'
name|'else'
name|'DISABLE_REASON_UNDEFINED'
op|')'
newline|'\n'
name|'service'
op|'.'
name|'save'
op|'('
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Updating compute service status to %s'"
op|','
nl|'\n'
name|'status_name'
op|'['
name|'disable_service'
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Not overriding manual compute service '"
nl|'\n'
string|"'status with: %s'"
op|','
nl|'\n'
name|'status_name'
op|'['
name|'disable_service'
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
name|'exception'
op|'.'
name|'ComputeHostNotFound'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'Cannot update service status on host: %s,'"
nl|'\n'
string|"'since it is not registered.'"
op|')'
op|','
name|'CONF'
op|'.'
name|'host'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'Cannot update service status on host: %s,'"
nl|'\n'
string|"'due to an unexpected exception.'"
op|')'
op|','
name|'CONF'
op|'.'
name|'host'
op|','
nl|'\n'
name|'exc_info'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_host_capabilities
dedent|''
dedent|''
name|'def'
name|'_get_host_capabilities'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns an instance of config.LibvirtConfigCaps representing\n           the capabilities of the host.\n        """'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_caps'
op|':'
newline|'\n'
indent|'            '
name|'xmlstr'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'getCapabilities'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_caps'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigCaps'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_caps'
op|'.'
name|'parse_str'
op|'('
name|'xmlstr'
op|')'
newline|'\n'
name|'if'
name|'hasattr'
op|'('
name|'libvirt'
op|','
string|"'VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'features'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'baselineCPU'
op|'('
nl|'\n'
op|'['
name|'self'
op|'.'
name|'_caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'to_xml'
op|'('
op|')'
op|']'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES'
op|')'
newline|'\n'
comment|'# FIXME(wangpan): the return value of baselineCPU should be'
nl|'\n'
comment|'#                 None or xml string, but libvirt has a bug'
nl|'\n'
comment|'#                 of it from 1.1.2 which is fixed in 1.2.0,'
nl|'\n'
comment|'#                 this -1 checking should be removed later.'
nl|'\n'
name|'if'
name|'features'
name|'and'
name|'features'
op|'!='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'                        '
name|'cpu'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigCPU'
op|'('
op|')'
newline|'\n'
name|'cpu'
op|'.'
name|'parse_str'
op|'('
name|'features'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'features'
op|'='
name|'cpu'
op|'.'
name|'features'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'                    '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_SUPPORT'
op|':'
newline|'\n'
indent|'                        '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"URI %(uri)s does not support full set"'
nl|'\n'
string|'" of host capabilities: "'
string|'"%(error)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'uri'"
op|':'
name|'self'
op|'.'
name|'uri'
op|'('
op|')'
op|','
string|"'error'"
op|':'
name|'ex'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'_caps'
newline|'\n'
nl|'\n'
DECL|member|_get_host_uuid
dedent|''
name|'def'
name|'_get_host_uuid'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns a UUID representing the host."""'
newline|'\n'
name|'caps'
op|'='
name|'self'
op|'.'
name|'_get_host_capabilities'
op|'('
op|')'
newline|'\n'
name|'return'
name|'caps'
op|'.'
name|'host'
op|'.'
name|'uuid'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_cpu_model_config
dedent|''
name|'def'
name|'_get_guest_cpu_model_config'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'mode'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'cpu_mode'
newline|'\n'
name|'model'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'cpu_model'
newline|'\n'
nl|'\n'
name|'if'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|'"kvm"'
name|'or'
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|'"qemu"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'mode'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'mode'
op|'='
string|'"host-model"'
newline|'\n'
dedent|''
name|'if'
name|'mode'
op|'=='
string|'"none"'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPU'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'mode'
name|'is'
name|'None'
name|'or'
name|'mode'
op|'=='
string|'"none"'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
op|'('
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'!='
string|'"kvm"'
name|'and'
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'!='
string|'"qemu"'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|'"Config requested an explicit CPU model, but "'
nl|'\n'
string|'"the current libvirt hypervisor \'%s\' does not "'
nl|'\n'
string|'"support selecting CPU models"'
op|')'
op|'%'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'mode'
op|'=='
string|'"custom"'
name|'and'
name|'model'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|'"Config requested a custom CPU model, but no "'
nl|'\n'
string|'"model name was provided"'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'msg'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'mode'
op|'!='
string|'"custom"'
name|'and'
name|'model'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|'"A CPU model name should not be set when a "'
nl|'\n'
string|'"host CPU model is requested"'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"CPU mode \'%(mode)s\' model \'%(model)s\' was chosen"'
op|','
nl|'\n'
op|'{'
string|"'mode'"
op|':'
name|'mode'
op|','
string|"'model'"
op|':'
op|'('
name|'model'
name|'or'
string|'""'
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'cpu'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPU'
op|'('
op|')'
newline|'\n'
name|'cpu'
op|'.'
name|'mode'
op|'='
name|'mode'
newline|'\n'
name|'cpu'
op|'.'
name|'model'
op|'='
name|'model'
newline|'\n'
nl|'\n'
name|'return'
name|'cpu'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_cpu_config
dedent|''
name|'def'
name|'_get_guest_cpu_config'
op|'('
name|'self'
op|','
name|'flavor'
op|','
name|'image'
op|','
name|'guest_cpu_numa'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'cpu'
op|'='
name|'self'
op|'.'
name|'_get_guest_cpu_model_config'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'cpu'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'topology'
op|'='
name|'hardware'
op|'.'
name|'VirtCPUTopology'
op|'.'
name|'get_best_config'
op|'('
name|'flavor'
op|','
nl|'\n'
name|'image'
op|')'
newline|'\n'
nl|'\n'
name|'cpu'
op|'.'
name|'sockets'
op|'='
name|'topology'
op|'.'
name|'sockets'
newline|'\n'
name|'cpu'
op|'.'
name|'cores'
op|'='
name|'topology'
op|'.'
name|'cores'
newline|'\n'
name|'cpu'
op|'.'
name|'threads'
op|'='
name|'topology'
op|'.'
name|'threads'
newline|'\n'
name|'cpu'
op|'.'
name|'numa'
op|'='
name|'guest_cpu_numa'
newline|'\n'
nl|'\n'
name|'return'
name|'cpu'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_disk_config
dedent|''
name|'def'
name|'_get_guest_disk_config'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'name'
op|','
name|'disk_mapping'
op|','
name|'inst_type'
op|','
nl|'\n'
name|'image_type'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'hw_disk_discard'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'not'
name|'self'
op|'.'
name|'_has_min_version'
op|'('
name|'MIN_LIBVIRT_DISCARD_VERSION'
op|','
nl|'\n'
name|'MIN_QEMU_DISCARD_VERSION'
op|','
nl|'\n'
name|'REQ_HYPERVISOR_DISCARD'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|"'Volume sets discard option, but libvirt %(libvirt)s'"
nl|'\n'
string|"' or later is required, qemu %(qemu)s'"
nl|'\n'
string|"' or later is required.'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'libvirt'"
op|':'
name|'MIN_LIBVIRT_DISCARD_VERSION'
op|','
nl|'\n'
string|"'qemu'"
op|':'
name|'MIN_QEMU_DISCARD_VERSION'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'image'
op|'='
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'image'
op|'('
name|'instance'
op|','
nl|'\n'
name|'name'
op|','
nl|'\n'
name|'image_type'
op|')'
newline|'\n'
name|'disk_info'
op|'='
name|'disk_mapping'
op|'['
name|'name'
op|']'
newline|'\n'
name|'return'
name|'image'
op|'.'
name|'libvirt_info'
op|'('
name|'disk_info'
op|'['
string|"'bus'"
op|']'
op|','
nl|'\n'
name|'disk_info'
op|'['
string|"'dev'"
op|']'
op|','
nl|'\n'
name|'disk_info'
op|'['
string|"'type'"
op|']'
op|','
nl|'\n'
name|'self'
op|'.'
name|'disk_cachemode'
op|','
nl|'\n'
name|'inst_type'
op|'['
string|"'extra_specs'"
op|']'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_get_hypervisor_version'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_storage_config
dedent|''
name|'def'
name|'_get_guest_storage_config'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'disk_info'
op|','
nl|'\n'
name|'rescue'
op|','
name|'block_device_info'
op|','
nl|'\n'
name|'inst_type'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'devices'
op|'='
op|'['
op|']'
newline|'\n'
name|'disk_mapping'
op|'='
name|'disk_info'
op|'['
string|"'mapping'"
op|']'
newline|'\n'
nl|'\n'
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'mount_rootfs'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|'"lxc"'
newline|'\n'
name|'if'
name|'mount_rootfs'
op|':'
newline|'\n'
indent|'            '
name|'fs'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestFilesys'
op|'('
op|')'
newline|'\n'
name|'fs'
op|'.'
name|'source_type'
op|'='
string|'"mount"'
newline|'\n'
name|'fs'
op|'.'
name|'source_dir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
nl|'\n'
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
op|','
string|"'rootfs'"
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'fs'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
nl|'\n'
indent|'            '
name|'if'
name|'rescue'
op|':'
newline|'\n'
indent|'                '
name|'diskrescue'
op|'='
name|'self'
op|'.'
name|'_get_guest_disk_config'
op|'('
name|'instance'
op|','
nl|'\n'
string|"'disk.rescue'"
op|','
nl|'\n'
name|'disk_mapping'
op|','
nl|'\n'
name|'inst_type'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'diskrescue'
op|')'
newline|'\n'
nl|'\n'
name|'diskos'
op|'='
name|'self'
op|'.'
name|'_get_guest_disk_config'
op|'('
name|'instance'
op|','
nl|'\n'
string|"'disk'"
op|','
nl|'\n'
name|'disk_mapping'
op|','
nl|'\n'
name|'inst_type'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'diskos'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'if'
string|"'disk'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'                    '
name|'diskos'
op|'='
name|'self'
op|'.'
name|'_get_guest_disk_config'
op|'('
name|'instance'
op|','
nl|'\n'
string|"'disk'"
op|','
nl|'\n'
name|'disk_mapping'
op|','
nl|'\n'
name|'inst_type'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'diskos'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
string|"'disk.local'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'                    '
name|'disklocal'
op|'='
name|'self'
op|'.'
name|'_get_guest_disk_config'
op|'('
name|'instance'
op|','
nl|'\n'
string|"'disk.local'"
op|','
nl|'\n'
name|'disk_mapping'
op|','
nl|'\n'
name|'inst_type'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'disklocal'
op|')'
newline|'\n'
name|'instance'
op|'.'
name|'default_ephemeral_device'
op|'='
op|'('
nl|'\n'
name|'block_device'
op|'.'
name|'prepend_dev'
op|'('
name|'disklocal'
op|'.'
name|'target_dev'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'idx'
op|','
name|'eph'
name|'in'
name|'enumerate'
op|'('
nl|'\n'
name|'driver'
op|'.'
name|'block_device_info_get_ephemerals'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'diskeph'
op|'='
name|'self'
op|'.'
name|'_get_guest_disk_config'
op|'('
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'blockinfo'
op|'.'
name|'get_eph_disk'
op|'('
name|'idx'
op|')'
op|','
nl|'\n'
name|'disk_mapping'
op|','
name|'inst_type'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'diskeph'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
string|"'disk.swap'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'                    '
name|'diskswap'
op|'='
name|'self'
op|'.'
name|'_get_guest_disk_config'
op|'('
name|'instance'
op|','
nl|'\n'
string|"'disk.swap'"
op|','
nl|'\n'
name|'disk_mapping'
op|','
nl|'\n'
name|'inst_type'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'diskswap'
op|')'
newline|'\n'
name|'instance'
op|'.'
name|'default_swap_device'
op|'='
op|'('
nl|'\n'
name|'block_device'
op|'.'
name|'prepend_dev'
op|'('
name|'diskswap'
op|'.'
name|'target_dev'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
string|"'disk.config'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'                '
name|'diskconfig'
op|'='
name|'self'
op|'.'
name|'_get_guest_disk_config'
op|'('
name|'instance'
op|','
nl|'\n'
string|"'disk.config'"
op|','
nl|'\n'
name|'disk_mapping'
op|','
nl|'\n'
name|'inst_type'
op|','
nl|'\n'
string|"'raw'"
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'diskconfig'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'for'
name|'vol'
name|'in'
name|'block_device'
op|'.'
name|'get_bdms_to_connect'
op|'('
name|'block_device_mapping'
op|','
nl|'\n'
name|'mount_rootfs'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'connection_info'
op|'='
name|'vol'
op|'['
string|"'connection_info'"
op|']'
newline|'\n'
name|'vol_dev'
op|'='
name|'block_device'
op|'.'
name|'prepend_dev'
op|'('
name|'vol'
op|'['
string|"'mount_device'"
op|']'
op|')'
newline|'\n'
name|'info'
op|'='
name|'disk_mapping'
op|'['
name|'vol_dev'
op|']'
newline|'\n'
name|'cfg'
op|'='
name|'self'
op|'.'
name|'_connect_volume'
op|'('
name|'connection_info'
op|','
name|'info'
op|')'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'cfg'
op|')'
newline|'\n'
name|'vol'
op|'['
string|"'connection_info'"
op|']'
op|'='
name|'connection_info'
newline|'\n'
name|'vol'
op|'.'
name|'save'
op|'('
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'d'
name|'in'
name|'devices'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_set_cache_mode'
op|'('
name|'d'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'image_meta'
name|'and'
nl|'\n'
name|'image_meta'
op|'.'
name|'get'
op|'('
string|"'properties'"
op|','
op|'{'
op|'}'
op|')'
op|'.'
name|'get'
op|'('
string|"'hw_scsi_model'"
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'hw_scsi_model'
op|'='
name|'image_meta'
op|'['
string|"'properties'"
op|']'
op|'['
string|"'hw_scsi_model'"
op|']'
newline|'\n'
name|'scsi_controller'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestController'
op|'('
op|')'
newline|'\n'
name|'scsi_controller'
op|'.'
name|'type'
op|'='
string|"'scsi'"
newline|'\n'
name|'scsi_controller'
op|'.'
name|'model'
op|'='
name|'hw_scsi_model'
newline|'\n'
name|'devices'
op|'.'
name|'append'
op|'('
name|'scsi_controller'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'devices'
newline|'\n'
nl|'\n'
DECL|member|_get_host_sysinfo_serial_hardware
dedent|''
name|'def'
name|'_get_host_sysinfo_serial_hardware'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get a UUID from the host hardware\n\n        Get a UUID for the host hardware reported by libvirt.\n        This is typically from the SMBIOS data, unless it has\n        been overridden in /etc/libvirt/libvirtd.conf\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_get_host_uuid'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_host_sysinfo_serial_os
dedent|''
name|'def'
name|'_get_host_sysinfo_serial_os'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get a UUID from the host operating system\n\n        Get a UUID for the host operating system. Modern Linux\n        distros based on systemd provide a /etc/machine-id\n        file containing a UUID. This is also provided inside\n        systemd based containers and can be provided by other\n        init systems too, since it is just a plain text file.\n        """'
newline|'\n'
name|'with'
name|'open'
op|'('
string|'"/etc/machine-id"'
op|')'
name|'as'
name|'f'
op|':'
newline|'\n'
comment|"# We want to have '-' in the right place"
nl|'\n'
comment|'# so we parse & reformat the value'
nl|'\n'
indent|'            '
name|'return'
name|'str'
op|'('
name|'uuid'
op|'.'
name|'UUID'
op|'('
name|'f'
op|'.'
name|'read'
op|'('
op|')'
op|'.'
name|'split'
op|'('
op|')'
op|'['
number|'0'
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_host_sysinfo_serial_auto
dedent|''
dedent|''
name|'def'
name|'_get_host_sysinfo_serial_auto'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
string|'"/etc/machine-id"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'_get_host_sysinfo_serial_os'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'_get_host_sysinfo_serial_hardware'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_config_sysinfo
dedent|''
dedent|''
name|'def'
name|'_get_guest_config_sysinfo'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'sysinfo'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSysinfo'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'sysinfo'
op|'.'
name|'system_manufacturer'
op|'='
name|'version'
op|'.'
name|'vendor_string'
op|'('
op|')'
newline|'\n'
name|'sysinfo'
op|'.'
name|'system_product'
op|'='
name|'version'
op|'.'
name|'product_string'
op|'('
op|')'
newline|'\n'
name|'sysinfo'
op|'.'
name|'system_version'
op|'='
name|'version'
op|'.'
name|'version_string_with_package'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'sysinfo'
op|'.'
name|'system_serial'
op|'='
name|'self'
op|'.'
name|'_sysinfo_serial_func'
op|'('
op|')'
newline|'\n'
name|'sysinfo'
op|'.'
name|'system_uuid'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
nl|'\n'
name|'return'
name|'sysinfo'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_pci_device
dedent|''
name|'def'
name|'_get_guest_pci_device'
op|'('
name|'self'
op|','
name|'pci_device'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'        '
name|'dbsf'
op|'='
name|'pci_utils'
op|'.'
name|'parse_address'
op|'('
name|'pci_device'
op|'['
string|"'address'"
op|']'
op|')'
newline|'\n'
name|'dev'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestHostdevPCI'
op|'('
op|')'
newline|'\n'
name|'dev'
op|'.'
name|'domain'
op|','
name|'dev'
op|'.'
name|'bus'
op|','
name|'dev'
op|'.'
name|'slot'
op|','
name|'dev'
op|'.'
name|'function'
op|'='
name|'dbsf'
newline|'\n'
nl|'\n'
comment|'# only kvm support managed mode'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
name|'in'
op|'('
string|"'xen'"
op|','
op|')'
op|':'
newline|'\n'
indent|'            '
name|'dev'
op|'.'
name|'managed'
op|'='
string|"'no'"
newline|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
name|'in'
op|'('
string|"'kvm'"
op|','
string|"'qemu'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'dev'
op|'.'
name|'managed'
op|'='
string|"'yes'"
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'dev'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_config_meta
dedent|''
name|'def'
name|'_get_guest_config_meta'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'flavor'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get metadata config for guest."""'
newline|'\n'
nl|'\n'
name|'meta'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestMetaNovaInstance'
op|'('
op|')'
newline|'\n'
name|'meta'
op|'.'
name|'package'
op|'='
name|'version'
op|'.'
name|'version_string_with_package'
op|'('
op|')'
newline|'\n'
name|'meta'
op|'.'
name|'name'
op|'='
name|'instance'
op|'['
string|'"display_name"'
op|']'
newline|'\n'
name|'meta'
op|'.'
name|'creationTime'
op|'='
name|'time'
op|'.'
name|'time'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'instance'
op|'['
string|'"image_ref"'
op|']'
name|'not'
name|'in'
op|'('
string|'""'
op|','
name|'None'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'meta'
op|'.'
name|'roottype'
op|'='
string|'"image"'
newline|'\n'
name|'meta'
op|'.'
name|'rootid'
op|'='
name|'instance'
op|'['
string|'"image_ref"'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'context'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'ometa'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestMetaNovaOwner'
op|'('
op|')'
newline|'\n'
name|'ometa'
op|'.'
name|'userid'
op|'='
name|'context'
op|'.'
name|'user_id'
newline|'\n'
name|'ometa'
op|'.'
name|'username'
op|'='
name|'context'
op|'.'
name|'user_name'
newline|'\n'
name|'ometa'
op|'.'
name|'projectid'
op|'='
name|'context'
op|'.'
name|'project_id'
newline|'\n'
name|'ometa'
op|'.'
name|'projectname'
op|'='
name|'context'
op|'.'
name|'project_name'
newline|'\n'
name|'meta'
op|'.'
name|'owner'
op|'='
name|'ometa'
newline|'\n'
nl|'\n'
dedent|''
name|'fmeta'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestMetaNovaFlavor'
op|'('
op|')'
newline|'\n'
name|'fmeta'
op|'.'
name|'name'
op|'='
name|'flavor'
op|'.'
name|'name'
newline|'\n'
name|'fmeta'
op|'.'
name|'memory'
op|'='
name|'flavor'
op|'.'
name|'memory_mb'
newline|'\n'
name|'fmeta'
op|'.'
name|'vcpus'
op|'='
name|'flavor'
op|'.'
name|'vcpus'
newline|'\n'
name|'fmeta'
op|'.'
name|'ephemeral'
op|'='
name|'flavor'
op|'.'
name|'ephemeral_gb'
newline|'\n'
name|'fmeta'
op|'.'
name|'disk'
op|'='
name|'flavor'
op|'.'
name|'root_gb'
newline|'\n'
name|'fmeta'
op|'.'
name|'swap'
op|'='
name|'flavor'
op|'.'
name|'swap'
newline|'\n'
nl|'\n'
name|'meta'
op|'.'
name|'flavor'
op|'='
name|'fmeta'
newline|'\n'
nl|'\n'
name|'return'
name|'meta'
newline|'\n'
nl|'\n'
DECL|member|_machine_type_mappings
dedent|''
name|'def'
name|'_machine_type_mappings'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'mappings'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'for'
name|'mapping'
name|'in'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'hw_machine_type'
op|':'
newline|'\n'
indent|'            '
name|'host_arch'
op|','
name|'_'
op|','
name|'machine_type'
op|'='
name|'mapping'
op|'.'
name|'partition'
op|'('
string|"'='"
op|')'
newline|'\n'
name|'mappings'
op|'['
name|'host_arch'
op|']'
op|'='
name|'machine_type'
newline|'\n'
dedent|''
name|'return'
name|'mappings'
newline|'\n'
nl|'\n'
DECL|member|_get_machine_type
dedent|''
name|'def'
name|'_get_machine_type'
op|'('
name|'self'
op|','
name|'image_meta'
op|','
name|'caps'
op|')'
op|':'
newline|'\n'
comment|'# The underlying machine type can be set as an image attribute,'
nl|'\n'
comment|'# or otherwise based on some architecture specific defaults'
nl|'\n'
nl|'\n'
indent|'        '
name|'mach_type'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'if'
op|'('
name|'image_meta'
name|'is'
name|'not'
name|'None'
name|'and'
name|'image_meta'
op|'.'
name|'get'
op|'('
string|"'properties'"
op|')'
name|'and'
nl|'\n'
name|'image_meta'
op|'['
string|"'properties'"
op|']'
op|'.'
name|'get'
op|'('
string|"'hw_machine_type'"
op|')'
nl|'\n'
name|'is'
name|'not'
name|'None'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'mach_type'
op|'='
name|'image_meta'
op|'['
string|"'properties'"
op|']'
op|'['
string|"'hw_machine_type'"
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# For ARM systems we will default to vexpress-a15 for armv7'
nl|'\n'
comment|'# and virt for aarch64'
nl|'\n'
indent|'            '
name|'if'
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'arch'
op|'=='
name|'arch'
op|'.'
name|'ARMV7'
op|':'
newline|'\n'
indent|'                '
name|'mach_type'
op|'='
string|'"vexpress-a15"'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'arch'
op|'=='
name|'arch'
op|'.'
name|'AARCH64'
op|':'
newline|'\n'
indent|'                '
name|'mach_type'
op|'='
string|'"virt"'
newline|'\n'
nl|'\n'
comment|'# If set in the config, use that as the default.'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'hw_machine_type'
op|':'
newline|'\n'
indent|'                '
name|'mappings'
op|'='
name|'self'
op|'.'
name|'_machine_type_mappings'
op|'('
op|')'
newline|'\n'
name|'mach_type'
op|'='
name|'mappings'
op|'.'
name|'get'
op|'('
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'arch'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'mach_type'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_create_idmaps
name|'def'
name|'_create_idmaps'
op|'('
name|'klass'
op|','
name|'map_strings'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'idmaps'
op|'='
op|'['
op|']'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'map_strings'
op|')'
op|'>'
number|'5'
op|':'
newline|'\n'
indent|'            '
name|'map_strings'
op|'='
name|'map_strings'
op|'['
number|'0'
op|':'
number|'5'
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Too many id maps, only included first five."'
op|')'
op|')'
newline|'\n'
dedent|''
name|'for'
name|'map_string'
name|'in'
name|'map_strings'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'idmap'
op|'='
name|'klass'
op|'('
op|')'
newline|'\n'
name|'values'
op|'='
op|'['
name|'int'
op|'('
name|'i'
op|')'
name|'for'
name|'i'
name|'in'
name|'map_string'
op|'.'
name|'split'
op|'('
string|'":"'
op|')'
op|']'
newline|'\n'
name|'idmap'
op|'.'
name|'start'
op|'='
name|'values'
op|'['
number|'0'
op|']'
newline|'\n'
name|'idmap'
op|'.'
name|'target'
op|'='
name|'values'
op|'['
number|'1'
op|']'
newline|'\n'
name|'idmap'
op|'.'
name|'count'
op|'='
name|'values'
op|'['
number|'2'
op|']'
newline|'\n'
name|'idmaps'
op|'.'
name|'append'
op|'('
name|'idmap'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'ValueError'
op|','
name|'IndexError'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Invalid value for id mapping %s"'
op|')'
op|','
name|'map_string'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'idmaps'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_idmaps
dedent|''
name|'def'
name|'_get_guest_idmaps'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'id_maps'
op|'='
op|'['
op|']'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'lxc'"
name|'and'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'uid_maps'
op|':'
newline|'\n'
indent|'            '
name|'uid_maps'
op|'='
name|'self'
op|'.'
name|'_create_idmaps'
op|'('
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestUIDMap'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'uid_maps'
op|')'
newline|'\n'
name|'id_maps'
op|'.'
name|'extend'
op|'('
name|'uid_maps'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'lxc'"
name|'and'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'gid_maps'
op|':'
newline|'\n'
indent|'            '
name|'gid_maps'
op|'='
name|'self'
op|'.'
name|'_create_idmaps'
op|'('
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestGIDMap'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'gid_maps'
op|')'
newline|'\n'
name|'id_maps'
op|'.'
name|'extend'
op|'('
name|'gid_maps'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'id_maps'
newline|'\n'
nl|'\n'
DECL|member|_get_cpu_numa_config_from_instance
dedent|''
name|'def'
name|'_get_cpu_numa_config_from_instance'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
comment|'# TODO(ndipanov): Remove this check once the test_virt_drivers.py'
nl|'\n'
comment|'# is using objects for all calls to _get_running_instance, as this'
nl|'\n'
comment|'# will confirm all code paths are using objects.'
nl|'\n'
indent|'        '
name|'if'
name|'isinstance'
op|'('
name|'instance'
op|','
name|'objects'
op|'.'
name|'Instance'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'instance_topology'
op|'='
name|'instance'
op|'.'
name|'numa_topology'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'instance_topology'
op|'='
op|'('
nl|'\n'
name|'objects'
op|'.'
name|'InstanceNUMATopology'
op|'.'
name|'get_by_instance_uuid'
op|'('
nl|'\n'
name|'context'
name|'or'
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'NumaTopologyNotFound'
op|':'
newline|'\n'
indent|'                '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'instance_topology'
op|':'
newline|'\n'
indent|'            '
name|'guest_cpu_numa'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPUNUMA'
op|'('
op|')'
newline|'\n'
name|'for'
name|'instance_cell'
name|'in'
name|'instance_topology'
op|'.'
name|'cells'
op|':'
newline|'\n'
indent|'                '
name|'guest_cell'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPUNUMACell'
op|'('
op|')'
newline|'\n'
name|'guest_cell'
op|'.'
name|'id'
op|'='
name|'instance_cell'
op|'.'
name|'id'
newline|'\n'
name|'guest_cell'
op|'.'
name|'cpus'
op|'='
name|'instance_cell'
op|'.'
name|'cpuset'
newline|'\n'
name|'guest_cell'
op|'.'
name|'memory'
op|'='
name|'instance_cell'
op|'.'
name|'memory'
op|'*'
name|'units'
op|'.'
name|'Ki'
newline|'\n'
name|'guest_cpu_numa'
op|'.'
name|'cells'
op|'.'
name|'append'
op|'('
name|'guest_cell'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'guest_cpu_numa'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_numa_config
dedent|''
dedent|''
name|'def'
name|'_get_guest_numa_config'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'flavor'
op|','
nl|'\n'
name|'allowed_cpus'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns the config objects for the guest NUMA specs.\n\n        Determines the CPUs that the guest can be pinned to if the guest\n        specifies a cell topology and the host supports it. Constructs the\n        libvirt XML config object representing the NUMA topology selected\n        for the guest. Returns a tuple of:\n\n            (cpu_set, guest_cpu_tune, guest_cpu_numa)\n\n        With the following caveats:\n\n            a) If there is no specified guest NUMA topology, then\n               guest_cpu_tune and guest_cpu_numa shall be None. cpu_set\n               will be populated with the chosen CPUs that the guest\n               allowed CPUs fit within, which could be the supplied\n               allowed_cpus value if the host doesn\'t support NUMA\n               topologies.\n\n            b) If there is a specified guest NUMA topology, then\n               cpu_set will be None and guest_cpu_numa will be the\n               LibvirtConfigGuestCPUNUMA object representing the guest\'s\n               NUMA topology. If the host supports NUMA, then guest_cpu_tune\n               will contain a LibvirtConfigGuestCPUTune object representing\n               the optimized chosen cells that match the host capabilities\n               with the instance\'s requested topology. If the host does\n               not support NUMA, then guest_cpu_tune will be None.\n        """'
newline|'\n'
name|'topology'
op|'='
name|'self'
op|'.'
name|'_get_host_numa_topology'
op|'('
op|')'
newline|'\n'
comment|'# We have instance NUMA so translate it to the config class'
nl|'\n'
name|'guest_cpu_numa'
op|'='
name|'self'
op|'.'
name|'_get_cpu_numa_config_from_instance'
op|'('
nl|'\n'
name|'context'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'guest_cpu_numa'
op|':'
newline|'\n'
comment|'# No NUMA topology defined for instance'
nl|'\n'
indent|'            '
name|'vcpus'
op|'='
name|'flavor'
op|'.'
name|'vcpus'
newline|'\n'
name|'memory'
op|'='
name|'flavor'
op|'.'
name|'memory_mb'
newline|'\n'
name|'if'
name|'topology'
op|':'
newline|'\n'
comment|'# Host is NUMA capable so try to keep the instance in a cell'
nl|'\n'
indent|'                '
name|'viable_cells_cpus'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'cell'
name|'in'
name|'topology'
op|'.'
name|'cells'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'vcpus'
op|'<='
name|'len'
op|'('
name|'cell'
op|'.'
name|'cpuset'
op|')'
name|'and'
name|'memory'
op|'<='
name|'cell'
op|'.'
name|'memory'
op|':'
newline|'\n'
indent|'                        '
name|'viable_cells_cpus'
op|'.'
name|'append'
op|'('
name|'cell'
op|'.'
name|'cpuset'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'viable_cells_cpus'
op|':'
newline|'\n'
comment|"# We can't contain the instance in a cell - do nothing for"
nl|'\n'
comment|'# now.'
nl|'\n'
comment|'# TODO(ndipanov): Attempt to spread the instance accross'
nl|'\n'
comment|'# NUMA nodes and expose the topology to the instance as an'
nl|'\n'
comment|'# optimisation'
nl|'\n'
indent|'                    '
name|'return'
name|'allowed_cpus'
op|','
name|'None'
op|','
name|'None'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'pin_cpuset'
op|'='
name|'random'
op|'.'
name|'choice'
op|'('
name|'viable_cells_cpus'
op|')'
newline|'\n'
name|'return'
name|'pin_cpuset'
op|','
name|'None'
op|','
name|'None'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# We have no NUMA topology in the host either'
nl|'\n'
indent|'                '
name|'return'
name|'allowed_cpus'
op|','
name|'None'
op|','
name|'None'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'topology'
op|':'
newline|'\n'
comment|'# Now get the CpuTune configuration from the numa_topology'
nl|'\n'
indent|'                '
name|'guest_cpu_tune'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPUTune'
op|'('
op|')'
newline|'\n'
name|'for'
name|'host_cell'
name|'in'
name|'topology'
op|'.'
name|'cells'
op|':'
newline|'\n'
indent|'                    '
name|'for'
name|'guest_cell'
name|'in'
name|'guest_cpu_numa'
op|'.'
name|'cells'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'guest_cell'
op|'.'
name|'id'
op|'=='
name|'host_cell'
op|'.'
name|'id'
op|':'
newline|'\n'
indent|'                            '
name|'for'
name|'cpu'
name|'in'
name|'guest_cell'
op|'.'
name|'cpus'
op|':'
newline|'\n'
indent|'                                '
name|'pin_cpuset'
op|'='
op|'('
nl|'\n'
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPUTuneVCPUPin'
op|'('
op|')'
op|')'
newline|'\n'
name|'pin_cpuset'
op|'.'
name|'id'
op|'='
name|'cpu'
newline|'\n'
name|'pin_cpuset'
op|'.'
name|'cpuset'
op|'='
name|'host_cell'
op|'.'
name|'cpuset'
newline|'\n'
name|'guest_cpu_tune'
op|'.'
name|'vcpupin'
op|'.'
name|'append'
op|'('
name|'pin_cpuset'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'return'
name|'None'
op|','
name|'guest_cpu_tune'
op|','
name|'guest_cpu_numa'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'allowed_cpus'
op|','
name|'None'
op|','
name|'guest_cpu_numa'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_config
dedent|''
dedent|''
dedent|''
name|'def'
name|'_get_guest_config'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'disk_info'
op|','
name|'rescue'
op|'='
name|'None'
op|','
name|'block_device_info'
op|'='
name|'None'
op|','
nl|'\n'
name|'context'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get config data for parameters.\n\n        :param rescue: optional dictionary that should contain the key\n            \'ramdisk_id\' if a ramdisk is needed for the rescue image and\n            \'kernel_id\' if a kernel is needed for the rescue image.\n        """'
newline|'\n'
nl|'\n'
name|'flavor'
op|'='
name|'objects'
op|'.'
name|'Flavor'
op|'.'
name|'get_by_id'
op|'('
nl|'\n'
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
name|'read_deleted'
op|'='
string|"'yes'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'instance_type_id'"
op|']'
op|')'
newline|'\n'
name|'inst_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'disk_mapping'
op|'='
name|'disk_info'
op|'['
string|"'mapping'"
op|']'
newline|'\n'
name|'img_meta_prop'
op|'='
name|'image_meta'
op|'.'
name|'get'
op|'('
string|"'properties'"
op|','
op|'{'
op|'}'
op|')'
name|'if'
name|'image_meta'
name|'else'
op|'{'
op|'}'
newline|'\n'
nl|'\n'
name|'CONSOLE'
op|'='
string|'"console=tty0 console=ttyS0"'
newline|'\n'
nl|'\n'
name|'guest'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuest'
op|'('
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'virt_type'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
newline|'\n'
name|'guest'
op|'.'
name|'name'
op|'='
name|'instance'
op|'['
string|"'name'"
op|']'
newline|'\n'
name|'guest'
op|'.'
name|'uuid'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
comment|'# We are using default unit for memory: KiB'
nl|'\n'
name|'guest'
op|'.'
name|'memory'
op|'='
name|'flavor'
op|'.'
name|'memory_mb'
op|'*'
name|'units'
op|'.'
name|'Ki'
newline|'\n'
name|'guest'
op|'.'
name|'vcpus'
op|'='
name|'flavor'
op|'.'
name|'vcpus'
newline|'\n'
name|'allowed_cpus'
op|'='
name|'hardware'
op|'.'
name|'get_vcpu_pin_set'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'cpuset'
op|','
name|'cputune'
op|','
name|'guest_cpu_numa'
op|'='
name|'self'
op|'.'
name|'_get_guest_numa_config'
op|'('
nl|'\n'
name|'context'
op|','
name|'instance'
op|','
name|'flavor'
op|','
name|'allowed_cpus'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'cpuset'
op|'='
name|'cpuset'
newline|'\n'
name|'guest'
op|'.'
name|'cputune'
op|'='
name|'cputune'
newline|'\n'
nl|'\n'
name|'guest'
op|'.'
name|'metadata'
op|'.'
name|'append'
op|'('
name|'self'
op|'.'
name|'_get_guest_config_meta'
op|'('
name|'context'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'flavor'
op|')'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'idmaps'
op|'='
name|'self'
op|'.'
name|'_get_guest_idmaps'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'cputuning'
op|'='
op|'['
string|"'shares'"
op|','
string|"'period'"
op|','
string|"'quota'"
op|']'
newline|'\n'
name|'for'
name|'name'
name|'in'
name|'cputuning'
op|':'
newline|'\n'
indent|'            '
name|'key'
op|'='
string|'"quota:cpu_"'
op|'+'
name|'name'
newline|'\n'
name|'if'
name|'key'
name|'in'
name|'flavor'
op|'.'
name|'extra_specs'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'guest'
op|'.'
name|'cputune'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'guest'
op|'.'
name|'cputune'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestCPUTune'
op|'('
op|')'
newline|'\n'
dedent|''
name|'setattr'
op|'('
name|'guest'
op|'.'
name|'cputune'
op|','
name|'name'
op|','
nl|'\n'
name|'int'
op|'('
name|'flavor'
op|'.'
name|'extra_specs'
op|'['
name|'key'
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'guest'
op|'.'
name|'cpu'
op|'='
name|'self'
op|'.'
name|'_get_guest_cpu_config'
op|'('
nl|'\n'
name|'flavor'
op|','
name|'image_meta'
op|','
name|'guest_cpu_numa'
op|')'
newline|'\n'
nl|'\n'
name|'if'
string|"'root'"
name|'in'
name|'disk_mapping'
op|':'
newline|'\n'
indent|'            '
name|'root_device_name'
op|'='
name|'block_device'
op|'.'
name|'prepend_dev'
op|'('
nl|'\n'
name|'disk_mapping'
op|'['
string|"'root'"
op|']'
op|'['
string|"'dev'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'root_device_name'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'root_device_name'
op|':'
newline|'\n'
comment|'# NOTE(yamahata):'
nl|'\n'
comment|'# for nova.api.ec2.cloud.CloudController.get_metadata()'
nl|'\n'
indent|'            '
name|'instance'
op|'.'
name|'root_device_name'
op|'='
name|'root_device_name'
newline|'\n'
nl|'\n'
dedent|''
name|'guest'
op|'.'
name|'os_type'
op|'='
name|'vm_mode'
op|'.'
name|'get_from_instance'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'guest'
op|'.'
name|'os_type'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|'"lxc"'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_type'
op|'='
name|'vm_mode'
op|'.'
name|'EXE'
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|'"uml"'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_type'
op|'='
name|'vm_mode'
op|'.'
name|'UML'
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|'"xen"'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_type'
op|'='
name|'vm_mode'
op|'.'
name|'XEN'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_type'
op|'='
name|'vm_mode'
op|'.'
name|'HVM'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'caps'
op|'='
name|'self'
op|'.'
name|'_get_host_capabilities'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|'"xen"'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'guest'
op|'.'
name|'os_type'
op|'=='
name|'vm_mode'
op|'.'
name|'HVM'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_loader'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'xen_hvmloader_path'
newline|'\n'
nl|'\n'
comment|'# PAE only makes sense in X86'
nl|'\n'
dedent|''
name|'if'
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'arch'
name|'in'
op|'('
name|'arch'
op|'.'
name|'I686'
op|','
name|'arch'
op|'.'
name|'X86_64'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'pae'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
name|'in'
op|'('
string|'"kvm"'
op|','
string|'"qemu"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'arch'
name|'in'
op|'('
name|'arch'
op|'.'
name|'I686'
op|','
name|'arch'
op|'.'
name|'X86_64'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'sysinfo'
op|'='
name|'self'
op|'.'
name|'_get_guest_config_sysinfo'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'os_smbios'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSMBIOS'
op|'('
op|')'
newline|'\n'
dedent|''
name|'guest'
op|'.'
name|'os_mach_type'
op|'='
name|'self'
op|'.'
name|'_get_machine_type'
op|'('
name|'image_meta'
op|','
name|'caps'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|'"lxc"'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'os_init_path'
op|'='
string|'"/sbin/init"'
newline|'\n'
name|'guest'
op|'.'
name|'os_cmdline'
op|'='
name|'CONSOLE'
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|'"uml"'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'os_kernel'
op|'='
string|'"/usr/bin/linux"'
newline|'\n'
name|'guest'
op|'.'
name|'os_root'
op|'='
name|'root_device_name'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'rescue'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'rescue'
op|'.'
name|'get'
op|'('
string|"'kernel_id'"
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'guest'
op|'.'
name|'os_kernel'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_path'
op|','
string|'"kernel.rescue"'
op|')'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|'"xen"'
op|':'
newline|'\n'
indent|'                        '
name|'guest'
op|'.'
name|'os_cmdline'
op|'='
string|'"ro root=%s"'
op|'%'
name|'root_device_name'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'guest'
op|'.'
name|'os_cmdline'
op|'='
op|'('
string|'"root=%s %s"'
op|'%'
op|'('
name|'root_device_name'
op|','
nl|'\n'
name|'CONSOLE'
op|')'
op|')'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|'"qemu"'
op|':'
newline|'\n'
indent|'                            '
name|'guest'
op|'.'
name|'os_cmdline'
op|'+='
string|'" no_timer_check"'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'rescue'
op|'.'
name|'get'
op|'('
string|"'ramdisk_id'"
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'guest'
op|'.'
name|'os_initrd'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_path'
op|','
string|'"ramdisk.rescue"'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'elif'
name|'instance'
op|'['
string|"'kernel_id'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_kernel'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_path'
op|','
string|'"kernel"'
op|')'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|'"xen"'
op|':'
newline|'\n'
indent|'                    '
name|'guest'
op|'.'
name|'os_cmdline'
op|'='
string|'"ro root=%s"'
op|'%'
name|'root_device_name'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'guest'
op|'.'
name|'os_cmdline'
op|'='
op|'('
string|'"root=%s %s"'
op|'%'
op|'('
name|'root_device_name'
op|','
nl|'\n'
name|'CONSOLE'
op|')'
op|')'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|'"qemu"'
op|':'
newline|'\n'
indent|'                        '
name|'guest'
op|'.'
name|'os_cmdline'
op|'+='
string|'" no_timer_check"'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'instance'
op|'['
string|"'ramdisk_id'"
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'guest'
op|'.'
name|'os_initrd'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_path'
op|','
string|'"ramdisk"'
op|')'
newline|'\n'
comment|'# we only support os_command_line with images with an explicit'
nl|'\n'
comment|"# kernel set and don't want to break nova if there's an"
nl|'\n'
comment|'# os_command_line property without a specified kernel_id param'
nl|'\n'
dedent|''
name|'if'
name|'image_meta'
op|':'
newline|'\n'
indent|'                    '
name|'img_props'
op|'='
name|'image_meta'
op|'.'
name|'get'
op|'('
string|"'properties'"
op|','
op|'{'
op|'}'
op|')'
newline|'\n'
name|'if'
name|'img_props'
op|'.'
name|'get'
op|'('
string|"'os_command_line'"
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'guest'
op|'.'
name|'os_cmdline'
op|'='
name|'img_props'
op|'.'
name|'get'
op|'('
string|"'os_command_line'"
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'os_boot_dev'
op|'='
name|'blockinfo'
op|'.'
name|'get_boot_order'
op|'('
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
op|'('
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'!='
string|'"lxc"'
name|'and'
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'!='
string|'"uml"'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'acpi'
op|'='
name|'True'
newline|'\n'
name|'guest'
op|'.'
name|'apic'
op|'='
name|'True'
newline|'\n'
nl|'\n'
comment|'# NOTE(mikal): Microsoft Windows expects the clock to be in'
nl|'\n'
comment|'# "localtime". If the clock is set to UTC, then you can use a'
nl|'\n'
comment|'# registry key to let windows know, but Microsoft says this is'
nl|'\n'
comment|'# buggy in http://support.microsoft.com/kb/2687252'
nl|'\n'
dedent|''
name|'clk'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestClock'
op|'('
op|')'
newline|'\n'
name|'if'
name|'instance'
op|'['
string|"'os_type'"
op|']'
op|'=='
string|"'windows'"
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Configuring timezone for windows instance to '"
nl|'\n'
string|"'localtime'"
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'clk'
op|'.'
name|'offset'
op|'='
string|"'localtime'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'clk'
op|'.'
name|'offset'
op|'='
string|"'utc'"
newline|'\n'
dedent|''
name|'guest'
op|'.'
name|'set_clock'
op|'('
name|'clk'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|'"kvm"'
op|':'
newline|'\n'
comment|'# TODO(berrange) One day this should be per-guest'
nl|'\n'
comment|'# OS type configurable'
nl|'\n'
indent|'            '
name|'tmpit'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestTimer'
op|'('
op|')'
newline|'\n'
name|'tmpit'
op|'.'
name|'name'
op|'='
string|'"pit"'
newline|'\n'
name|'tmpit'
op|'.'
name|'tickpolicy'
op|'='
string|'"delay"'
newline|'\n'
nl|'\n'
name|'tmrtc'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestTimer'
op|'('
op|')'
newline|'\n'
name|'tmrtc'
op|'.'
name|'name'
op|'='
string|'"rtc"'
newline|'\n'
name|'tmrtc'
op|'.'
name|'tickpolicy'
op|'='
string|'"catchup"'
newline|'\n'
nl|'\n'
name|'clk'
op|'.'
name|'add_timer'
op|'('
name|'tmpit'
op|')'
newline|'\n'
name|'clk'
op|'.'
name|'add_timer'
op|'('
name|'tmrtc'
op|')'
newline|'\n'
nl|'\n'
name|'guestarch'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_arch'
op|'('
name|'image_meta'
op|')'
newline|'\n'
name|'if'
name|'guestarch'
name|'in'
op|'('
name|'arch'
op|'.'
name|'I686'
op|','
name|'arch'
op|'.'
name|'X86_64'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(rfolco): HPET is a hardware timer for x86 arch.'
nl|'\n'
comment|'# qemu -no-hpet is not supported on non-x86 targets.'
nl|'\n'
indent|'                '
name|'tmhpet'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestTimer'
op|'('
op|')'
newline|'\n'
name|'tmhpet'
op|'.'
name|'name'
op|'='
string|'"hpet"'
newline|'\n'
name|'tmhpet'
op|'.'
name|'present'
op|'='
name|'False'
newline|'\n'
name|'clk'
op|'.'
name|'add_timer'
op|'('
name|'tmhpet'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'for'
name|'config'
name|'in'
name|'self'
op|'.'
name|'_get_guest_storage_config'
op|'('
name|'instance'
op|','
nl|'\n'
name|'image_meta'
op|','
nl|'\n'
name|'disk_info'
op|','
nl|'\n'
name|'rescue'
op|','
nl|'\n'
name|'block_device_info'
op|','
nl|'\n'
name|'flavor'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'config'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
indent|'            '
name|'config'
op|'='
name|'self'
op|'.'
name|'vif_driver'
op|'.'
name|'get_config'
op|'('
nl|'\n'
name|'instance'
op|','
name|'vif'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'flavor'
op|','
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'config'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|'"qemu"'
name|'or'
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|'"kvm"'
op|')'
op|')'
op|':'
newline|'\n'
comment|'# Create the serial console char devices'
nl|'\n'
indent|'            '
name|'if'
name|'CONF'
op|'.'
name|'serial_console'
op|'.'
name|'enabled'
op|':'
newline|'\n'
indent|'                '
name|'num_ports'
op|'='
name|'hardware'
op|'.'
name|'get_number_of_serial_ports'
op|'('
nl|'\n'
name|'flavor'
op|','
name|'image_meta'
op|')'
newline|'\n'
name|'for'
name|'port'
name|'in'
name|'six'
op|'.'
name|'moves'
op|'.'
name|'range'
op|'('
name|'num_ports'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'console'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSerial'
op|'('
op|')'
newline|'\n'
name|'console'
op|'.'
name|'port'
op|'='
name|'port'
newline|'\n'
name|'console'
op|'.'
name|'type'
op|'='
string|'"tcp"'
newline|'\n'
name|'console'
op|'.'
name|'listen_host'
op|'='
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'serial_console'
op|'.'
name|'proxyclient_address'
op|')'
newline|'\n'
name|'console'
op|'.'
name|'listen_port'
op|'='
op|'('
nl|'\n'
name|'serial_console'
op|'.'
name|'acquire_port'
op|'('
nl|'\n'
name|'console'
op|'.'
name|'listen_host'
op|')'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'console'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|"# The QEMU 'pty' driver throws away any data if no"
nl|'\n'
comment|"# client app is connected. Thus we can't get away"
nl|'\n'
comment|'# with a single type=pty console. Instead we have'
nl|'\n'
comment|'# to configure two separate consoles.'
nl|'\n'
indent|'                '
name|'consolelog'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSerial'
op|'('
op|')'
newline|'\n'
name|'consolelog'
op|'.'
name|'type'
op|'='
string|'"file"'
newline|'\n'
name|'consolelog'
op|'.'
name|'source_path'
op|'='
name|'self'
op|'.'
name|'_get_console_log_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'consolelog'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'consolepty'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestSerial'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'consolepty'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestConsole'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'consolepty'
op|'.'
name|'type'
op|'='
string|'"pty"'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'consolepty'
op|')'
newline|'\n'
nl|'\n'
comment|'# We want a tablet if VNC is enabled, or SPICE is enabled and'
nl|'\n'
comment|'# the SPICE agent is disabled. If the SPICE agent is enabled'
nl|'\n'
comment|'# it provides a paravirt mouse which drastically reduces'
nl|'\n'
comment|'# overhead (by eliminating USB polling).'
nl|'\n'
comment|'#'
nl|'\n'
comment|'# NB: this implies that if both SPICE + VNC are enabled'
nl|'\n'
comment|"# at the same time, we'll get the tablet whether the"
nl|'\n'
comment|'# SPICE agent is used or not.'
nl|'\n'
name|'need_usb_tablet'
op|'='
name|'False'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'vnc_enabled'
op|':'
newline|'\n'
indent|'            '
name|'need_usb_tablet'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'use_usb_tablet'
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'enabled'
name|'and'
name|'not'
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'agent_enabled'
op|':'
newline|'\n'
indent|'            '
name|'need_usb_tablet'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'use_usb_tablet'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'need_usb_tablet'
name|'and'
name|'guest'
op|'.'
name|'os_type'
op|'=='
name|'vm_mode'
op|'.'
name|'HVM'
op|':'
newline|'\n'
indent|'            '
name|'tablet'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestInput'
op|'('
op|')'
newline|'\n'
name|'tablet'
op|'.'
name|'type'
op|'='
string|'"tablet"'
newline|'\n'
name|'tablet'
op|'.'
name|'bus'
op|'='
string|'"usb"'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'tablet'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'enabled'
name|'and'
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'agent_enabled'
name|'and'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
name|'not'
name|'in'
op|'('
string|"'lxc'"
op|','
string|"'uml'"
op|','
string|"'xen'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'channel'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestChannel'
op|'('
op|')'
newline|'\n'
name|'channel'
op|'.'
name|'target_name'
op|'='
string|'"com.redhat.spice.0"'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'channel'
op|')'
newline|'\n'
nl|'\n'
comment|'# NB some versions of libvirt support both SPICE and VNC'
nl|'\n'
comment|"# at the same time. We're not trying to second guess which"
nl|'\n'
comment|"# those versions are. We'll just let libvirt report the"
nl|'\n'
comment|'# errors appropriately if the user enables both.'
nl|'\n'
dedent|''
name|'add_video_driver'
op|'='
name|'False'
newline|'\n'
name|'if'
op|'('
op|'('
name|'CONF'
op|'.'
name|'vnc_enabled'
name|'and'
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
name|'not'
name|'in'
op|'('
string|"'lxc'"
op|','
string|"'uml'"
op|')'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'graphics'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestGraphics'
op|'('
op|')'
newline|'\n'
name|'graphics'
op|'.'
name|'type'
op|'='
string|'"vnc"'
newline|'\n'
name|'graphics'
op|'.'
name|'keymap'
op|'='
name|'CONF'
op|'.'
name|'vnc_keymap'
newline|'\n'
name|'graphics'
op|'.'
name|'listen'
op|'='
name|'CONF'
op|'.'
name|'vncserver_listen'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'graphics'
op|')'
newline|'\n'
name|'add_video_driver'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'enabled'
name|'and'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
name|'not'
name|'in'
op|'('
string|"'lxc'"
op|','
string|"'uml'"
op|','
string|"'xen'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'graphics'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestGraphics'
op|'('
op|')'
newline|'\n'
name|'graphics'
op|'.'
name|'type'
op|'='
string|'"spice"'
newline|'\n'
name|'graphics'
op|'.'
name|'keymap'
op|'='
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'keymap'
newline|'\n'
name|'graphics'
op|'.'
name|'listen'
op|'='
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'server_listen'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'graphics'
op|')'
newline|'\n'
name|'add_video_driver'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'add_video_driver'
op|':'
newline|'\n'
indent|'            '
name|'VALID_VIDEO_DEVICES'
op|'='
op|'('
string|'"vga"'
op|','
string|'"cirrus"'
op|','
string|'"vmvga"'
op|','
string|'"xen"'
op|','
string|'"qxl"'
op|')'
newline|'\n'
name|'video'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestVideo'
op|'('
op|')'
newline|'\n'
comment|'# NOTE(ldbragst): The following logic sets the video.type'
nl|'\n'
comment|'# depending on supported defaults given the architecture,'
nl|'\n'
comment|'# virtualization type, and features. The video.type attribute can'
nl|'\n'
comment|"# be overridden by the user with image_meta['properties'], which"
nl|'\n'
comment|'# is carried out in the next if statement below this one.'
nl|'\n'
name|'guestarch'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_arch'
op|'('
name|'image_meta'
op|')'
newline|'\n'
name|'if'
name|'guest'
op|'.'
name|'os_type'
op|'=='
name|'vm_mode'
op|'.'
name|'XEN'
op|':'
newline|'\n'
indent|'                '
name|'video'
op|'.'
name|'type'
op|'='
string|"'xen'"
newline|'\n'
dedent|''
name|'elif'
name|'guestarch'
name|'in'
op|'('
name|'arch'
op|'.'
name|'PPC'
op|','
name|'arch'
op|'.'
name|'PPC64'
op|')'
op|':'
newline|'\n'
comment|"# NOTE(ldbragst): PowerKVM doesn't support 'cirrus' be default"
nl|'\n'
comment|"# so use 'vga' instead when running on Power hardware."
nl|'\n'
indent|'                '
name|'video'
op|'.'
name|'type'
op|'='
string|"'vga'"
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'enabled'
op|':'
newline|'\n'
indent|'                '
name|'video'
op|'.'
name|'type'
op|'='
string|"'qxl'"
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'img_meta_prop'
op|'.'
name|'get'
op|'('
string|"'hw_video_model'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'video'
op|'.'
name|'type'
op|'='
name|'img_meta_prop'
op|'.'
name|'get'
op|'('
string|"'hw_video_model'"
op|')'
newline|'\n'
name|'if'
op|'('
name|'video'
op|'.'
name|'type'
name|'not'
name|'in'
name|'VALID_VIDEO_DEVICES'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'exception'
op|'.'
name|'InvalidVideoMode'
op|'('
name|'model'
op|'='
name|'video'
op|'.'
name|'type'
op|')'
newline|'\n'
nl|'\n'
comment|"# Set video memory, only if the flavor's limit is set"
nl|'\n'
dedent|''
dedent|''
name|'video_ram'
op|'='
name|'int'
op|'('
name|'img_meta_prop'
op|'.'
name|'get'
op|'('
string|"'hw_video_ram'"
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'max_vram'
op|'='
name|'int'
op|'('
name|'flavor'
op|'.'
name|'extra_specs'
nl|'\n'
op|'.'
name|'get'
op|'('
string|"'hw_video:ram_max_mb'"
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'if'
name|'video_ram'
op|'>'
name|'max_vram'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'RequestedVRamTooHigh'
op|'('
name|'req_vram'
op|'='
name|'video_ram'
op|','
nl|'\n'
name|'max_vram'
op|'='
name|'max_vram'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'max_vram'
name|'and'
name|'video_ram'
op|':'
newline|'\n'
indent|'                '
name|'video'
op|'.'
name|'vram'
op|'='
name|'video_ram'
newline|'\n'
dedent|''
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'video'
op|')'
newline|'\n'
nl|'\n'
comment|"# Qemu guest agent only support 'qemu' and 'kvm' hypervisor"
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
name|'in'
op|'('
string|"'qemu'"
op|','
string|"'kvm'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'qga_enabled'
op|'='
name|'False'
newline|'\n'
comment|"# Enable qga only if the 'hw_qemu_guest_agent' is equal to yes"
nl|'\n'
name|'hw_qga'
op|'='
name|'img_meta_prop'
op|'.'
name|'get'
op|'('
string|"'hw_qemu_guest_agent'"
op|','
string|"'no'"
op|')'
newline|'\n'
name|'if'
name|'hw_qga'
op|'.'
name|'lower'
op|'('
op|')'
op|'=='
string|"'yes'"
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Qemu guest agent is enabled through image "'
nl|'\n'
string|'"metadata"'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'qga_enabled'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'qga_enabled'
op|':'
newline|'\n'
indent|'                '
name|'qga'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestChannel'
op|'('
op|')'
newline|'\n'
name|'qga'
op|'.'
name|'type'
op|'='
string|'"unix"'
newline|'\n'
name|'qga'
op|'.'
name|'target_name'
op|'='
string|'"org.qemu.guest_agent.0"'
newline|'\n'
name|'qga'
op|'.'
name|'source_path'
op|'='
op|'('
string|'"/var/lib/libvirt/qemu/%s.%s.sock"'
op|'%'
nl|'\n'
op|'('
string|'"org.qemu.guest_agent.0"'
op|','
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
op|')'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'qga'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'img_meta_prop'
op|'.'
name|'get'
op|'('
string|"'hw_rng_model'"
op|')'
op|'=='
string|"'virtio'"
name|'and'
nl|'\n'
name|'flavor'
op|'.'
name|'extra_specs'
op|'.'
name|'get'
op|'('
string|"'hw_rng:allowed'"
op|','
nl|'\n'
string|"''"
op|')'
op|'.'
name|'lower'
op|'('
op|')'
op|'=='
string|"'true'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'rng_device'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestRng'
op|'('
op|')'
newline|'\n'
name|'rate_bytes'
op|'='
name|'flavor'
op|'.'
name|'extra_specs'
op|'.'
name|'get'
op|'('
string|"'hw_rng:rate_bytes'"
op|','
number|'0'
op|')'
newline|'\n'
name|'period'
op|'='
name|'flavor'
op|'.'
name|'extra_specs'
op|'.'
name|'get'
op|'('
string|"'hw_rng:rate_period'"
op|','
number|'0'
op|')'
newline|'\n'
name|'if'
name|'rate_bytes'
op|':'
newline|'\n'
indent|'                    '
name|'rng_device'
op|'.'
name|'rate_bytes'
op|'='
name|'int'
op|'('
name|'rate_bytes'
op|')'
newline|'\n'
name|'rng_device'
op|'.'
name|'rate_period'
op|'='
name|'int'
op|'('
name|'period'
op|')'
newline|'\n'
dedent|''
name|'if'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'rng_dev_path'
name|'and'
nl|'\n'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'rng_dev_path'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'exception'
op|'.'
name|'RngDeviceNotExist'
op|'('
nl|'\n'
name|'path'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'rng_dev_path'
op|')'
newline|'\n'
dedent|''
name|'rng_device'
op|'.'
name|'backend'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'rng_dev_path'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'rng_device'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
name|'in'
op|'('
string|"'xen'"
op|','
string|"'qemu'"
op|','
string|"'kvm'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'pci_dev'
name|'in'
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'self'
op|'.'
name|'_get_guest_pci_device'
op|'('
name|'pci_dev'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'len'
op|'('
name|'pci_manager'
op|'.'
name|'get_instance_pci_devs'
op|'('
name|'instance'
op|')'
op|')'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'PciDeviceUnsupportedHypervisor'
op|'('
nl|'\n'
name|'type'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
string|"'hw_watchdog_action'"
name|'in'
name|'flavor'
op|'.'
name|'extra_specs'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'\'Old property name "hw_watchdog_action" is now \''
nl|'\n'
string|"'deprecated and will be removed in the next release. '"
nl|'\n'
string|"'Use updated property name '"
nl|'\n'
string|'\'"hw:watchdog_action" instead\''
op|')'
op|')'
newline|'\n'
comment|"# TODO(pkholkin): accepting old property name 'hw_watchdog_action'"
nl|'\n'
comment|'#                should be removed in the next release'
nl|'\n'
dedent|''
name|'watchdog_action'
op|'='
op|'('
name|'flavor'
op|'.'
name|'extra_specs'
op|'.'
name|'get'
op|'('
string|"'hw_watchdog_action'"
op|')'
name|'or'
nl|'\n'
name|'flavor'
op|'.'
name|'extra_specs'
op|'.'
name|'get'
op|'('
string|"'hw:watchdog_action'"
op|')'
nl|'\n'
name|'or'
string|"'disabled'"
op|')'
newline|'\n'
name|'if'
op|'('
name|'image_meta'
name|'is'
name|'not'
name|'None'
name|'and'
nl|'\n'
name|'image_meta'
op|'.'
name|'get'
op|'('
string|"'properties'"
op|','
op|'{'
op|'}'
op|')'
op|'.'
name|'get'
op|'('
string|"'hw_watchdog_action'"
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'watchdog_action'
op|'='
name|'image_meta'
op|'['
string|"'properties'"
op|']'
op|'['
string|"'hw_watchdog_action'"
op|']'
newline|'\n'
nl|'\n'
comment|'# NB(sross): currently only actually supported by KVM/QEmu'
nl|'\n'
dedent|''
name|'if'
name|'watchdog_action'
op|'!='
string|"'disabled'"
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'watchdog_actions'
op|'.'
name|'is_valid_watchdog_action'
op|'('
name|'watchdog_action'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'bark'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigGuestWatchdog'
op|'('
op|')'
newline|'\n'
name|'bark'
op|'.'
name|'action'
op|'='
name|'watchdog_action'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'bark'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'InvalidWatchdogAction'
op|'('
name|'action'
op|'='
name|'watchdog_action'
op|')'
newline|'\n'
nl|'\n'
comment|"# Memory balloon device only support 'qemu/kvm' and 'xen' hypervisor"
nl|'\n'
dedent|''
dedent|''
name|'if'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
name|'in'
op|'('
string|"'xen'"
op|','
string|"'qemu'"
op|','
string|"'kvm'"
op|')'
name|'and'
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'mem_stats_period_seconds'
op|'>'
number|'0'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'balloon'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigMemoryBalloon'
op|'('
op|')'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
name|'in'
op|'('
string|"'qemu'"
op|','
string|"'kvm'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'balloon'
op|'.'
name|'model'
op|'='
string|"'virtio'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'balloon'
op|'.'
name|'model'
op|'='
string|"'xen'"
newline|'\n'
dedent|''
name|'balloon'
op|'.'
name|'period'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'mem_stats_period_seconds'
newline|'\n'
name|'guest'
op|'.'
name|'add_device'
op|'('
name|'balloon'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'guest'
newline|'\n'
nl|'\n'
DECL|member|_get_guest_xml
dedent|''
name|'def'
name|'_get_guest_xml'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'image_meta'
op|'='
name|'None'
op|','
name|'rescue'
op|'='
name|'None'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'write_to_disk'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'        '
name|'if'
name|'image_meta'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'image_ref'
op|'='
name|'instance'
op|'['
string|"'image_ref'"
op|']'
newline|'\n'
name|'image_meta'
op|'='
name|'compute_utils'
op|'.'
name|'get_image_metadata'
op|'('
nl|'\n'
name|'context'
op|','
name|'self'
op|'.'
name|'_image_api'
op|','
name|'image_ref'
op|','
name|'instance'
op|')'
newline|'\n'
comment|'# NOTE(danms): Stringifying a NetworkInfo will take a lock. Do'
nl|'\n'
comment|"# this ahead of time so that we don't acquire it while also"
nl|'\n'
comment|'# holding the logging lock.'
nl|'\n'
dedent|''
name|'network_info_str'
op|'='
name|'str'
op|'('
name|'network_info'
op|')'
newline|'\n'
name|'msg'
op|'='
op|'('
string|"'Start _get_guest_xml '"
nl|'\n'
string|"'network_info=%(network_info)s '"
nl|'\n'
string|"'disk_info=%(disk_info)s '"
nl|'\n'
string|"'image_meta=%(image_meta)s rescue=%(rescue)s '"
nl|'\n'
string|"'block_device_info=%(block_device_info)s'"
op|'%'
nl|'\n'
op|'{'
string|"'network_info'"
op|':'
name|'network_info_str'
op|','
string|"'disk_info'"
op|':'
name|'disk_info'
op|','
nl|'\n'
string|"'image_meta'"
op|':'
name|'image_meta'
op|','
string|"'rescue'"
op|':'
name|'rescue'
op|','
nl|'\n'
string|"'block_device_info'"
op|':'
name|'block_device_info'
op|'}'
op|')'
newline|'\n'
comment|'# NOTE(mriedem): block_device_info can contain auth_password so we'
nl|'\n'
comment|'# need to sanitize the password in the message.'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'strutils'
op|'.'
name|'mask_password'
op|'('
name|'msg'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'conf'
op|'='
name|'self'
op|'.'
name|'_get_guest_config'
op|'('
name|'instance'
op|','
name|'network_info'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'disk_info'
op|','
name|'rescue'
op|','
name|'block_device_info'
op|','
nl|'\n'
name|'context'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'conf'
op|'.'
name|'to_xml'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'write_to_disk'
op|':'
newline|'\n'
indent|'            '
name|'instance_dir'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'xml_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
string|"'libvirt.xml'"
op|')'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'write_to_file'
op|'('
name|'xml_path'
op|','
name|'xml'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'End _get_guest_xml xml=%(xml)s'"
op|','
nl|'\n'
op|'{'
string|"'xml'"
op|':'
name|'xml'
op|'}'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'xml'
newline|'\n'
nl|'\n'
DECL|member|_lookup_by_id
dedent|''
name|'def'
name|'_lookup_by_id'
op|'('
name|'self'
op|','
name|'instance_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve libvirt domain object given an instance id.\n\n        All libvirt error handling should be handled in this method and\n        relevant nova exceptions should be raised in response.\n\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'lookupByID'
op|'('
name|'instance_id'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_DOMAIN'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|'('
name|'instance_id'
op|'='
name|'instance_id'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|'"Error from libvirt while looking up %(instance_id)s: "'
nl|'\n'
string|'"[Error Code %(error_code)s] %(ex)s"'
op|')'
nl|'\n'
op|'%'
op|'{'
string|"'instance_id'"
op|':'
name|'instance_id'
op|','
nl|'\n'
string|"'error_code'"
op|':'
name|'error_code'
op|','
nl|'\n'
string|"'ex'"
op|':'
name|'ex'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_lookup_by_name
dedent|''
dedent|''
name|'def'
name|'_lookup_by_name'
op|'('
name|'self'
op|','
name|'instance_name'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve libvirt domain object given an instance name.\n\n        All libvirt error handling should be handled in this method and\n        relevant nova exceptions should be raised in response.\n\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'lookupByName'
op|'('
name|'instance_name'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_DOMAIN'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|'('
name|'instance_id'
op|'='
name|'instance_name'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|"'Error from libvirt while looking up %(instance_name)s: '"
nl|'\n'
string|"'[Error Code %(error_code)s] %(ex)s'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'instance_name'"
op|':'
name|'instance_name'
op|','
nl|'\n'
string|"'error_code'"
op|':'
name|'error_code'
op|','
nl|'\n'
string|"'ex'"
op|':'
name|'ex'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_info
dedent|''
dedent|''
name|'def'
name|'get_info'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve information from libvirt for a specific instance name.\n\n        If a libvirt error is encountered during lookup, we might raise a\n        NotFound exception or Error exception depending on how severe the\n        libvirt error is.\n\n        """'
newline|'\n'
name|'virt_dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'dom_info'
op|'='
name|'virt_dom'
op|'.'
name|'info'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_DOMAIN'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|'('
name|'instance_id'
op|'='
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|"'Error from libvirt while getting domain info for '"
nl|'\n'
string|"'%(instance_name)s: [Error Code %(error_code)s] %(ex)s'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'instance_name'"
op|':'
name|'instance'
op|'['
string|"'name'"
op|']'
op|','
nl|'\n'
string|"'error_code'"
op|':'
name|'error_code'
op|','
nl|'\n'
string|"'ex'"
op|':'
name|'ex'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
op|'{'
string|"'state'"
op|':'
name|'LIBVIRT_POWER_STATE'
op|'['
name|'dom_info'
op|'['
number|'0'
op|']'
op|']'
op|','
nl|'\n'
string|"'max_mem'"
op|':'
name|'dom_info'
op|'['
number|'1'
op|']'
op|','
nl|'\n'
string|"'mem'"
op|':'
name|'dom_info'
op|'['
number|'2'
op|']'
op|','
nl|'\n'
string|"'num_cpu'"
op|':'
name|'dom_info'
op|'['
number|'3'
op|']'
op|','
nl|'\n'
string|"'cpu_time'"
op|':'
name|'dom_info'
op|'['
number|'4'
op|']'
op|','
nl|'\n'
string|"'id'"
op|':'
name|'virt_dom'
op|'.'
name|'ID'
op|'('
op|')'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|_create_domain_setup_lxc
dedent|''
name|'def'
name|'_create_domain_setup_lxc'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'block_device_info'
op|','
name|'disk_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'inst_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'disk_info'
op|'='
name|'disk_info'
name|'or'
op|'{'
op|'}'
newline|'\n'
name|'disk_mapping'
op|'='
name|'disk_info'
op|'.'
name|'get'
op|'('
string|"'mapping'"
op|','
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_is_booted_from_volume'
op|'('
name|'instance'
op|','
name|'disk_mapping'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'root_disk'
op|'='
name|'block_device'
op|'.'
name|'get_root_bdm'
op|'('
name|'block_device_mapping'
op|')'
newline|'\n'
name|'disk_path'
op|'='
name|'root_disk'
op|'['
string|"'connection_info'"
op|']'
op|'['
string|"'data'"
op|']'
op|'['
string|"'device_path'"
op|']'
newline|'\n'
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_info_from_bdm'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
name|'root_disk'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_connect_volume'
op|'('
name|'root_disk'
op|'['
string|"'connection_info'"
op|']'
op|','
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
comment|'# Get the system metadata from the instance'
nl|'\n'
name|'system_meta'
op|'='
name|'utils'
op|'.'
name|'instance_sys_meta'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'use_cow'
op|'='
name|'system_meta'
op|'['
string|"'image_disk_format'"
op|']'
op|'=='
string|"'qcow2'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'image'
op|'='
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'image'
op|'('
name|'instance'
op|','
string|"'disk'"
op|')'
newline|'\n'
name|'disk_path'
op|'='
name|'image'
op|'.'
name|'path'
newline|'\n'
name|'use_cow'
op|'='
name|'CONF'
op|'.'
name|'use_cow_images'
newline|'\n'
nl|'\n'
dedent|''
name|'container_dir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_path'
op|','
string|"'rootfs'"
op|')'
newline|'\n'
name|'fileutils'
op|'.'
name|'ensure_tree'
op|'('
name|'container_dir'
op|')'
newline|'\n'
name|'rootfs_dev'
op|'='
name|'disk'
op|'.'
name|'setup_container'
op|'('
name|'disk_path'
op|','
nl|'\n'
name|'container_dir'
op|'='
name|'container_dir'
op|','
nl|'\n'
name|'use_cow'
op|'='
name|'use_cow'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
comment|'# Save rootfs device to disconnect it when deleting the instance'
nl|'\n'
indent|'            '
name|'if'
name|'rootfs_dev'
op|':'
newline|'\n'
indent|'                '
name|'instance'
op|'.'
name|'system_metadata'
op|'['
string|"'rootfs_device_name'"
op|']'
op|'='
name|'rootfs_dev'
newline|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'uid_maps'
name|'or'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'gid_maps'
op|':'
newline|'\n'
indent|'                '
name|'id_maps'
op|'='
name|'self'
op|'.'
name|'_get_guest_idmaps'
op|'('
op|')'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'chown_for_id_maps'
op|'('
name|'container_dir'
op|','
name|'id_maps'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_create_domain_cleanup_lxc'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_create_domain_cleanup_lxc
dedent|''
dedent|''
dedent|''
name|'def'
name|'_create_domain_cleanup_lxc'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'inst_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'container_dir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_path'
op|','
string|"'rootfs'"
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'state'
op|'='
name|'self'
op|'.'
name|'get_info'
op|'('
name|'instance'
op|')'
op|'['
string|"'state'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
comment|'# The domain may not be present if the instance failed to start'
nl|'\n'
indent|'            '
name|'state'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
comment|'# NOTE(uni): Now the container is running with its own private'
nl|'\n'
comment|'# mount namespace and so there is no need to keep the container'
nl|'\n'
comment|'# rootfs mounted in the host namespace'
nl|'\n'
indent|'            '
name|'disk'
op|'.'
name|'clean_lxc_namespace'
op|'('
name|'container_dir'
op|'='
name|'container_dir'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'disk'
op|'.'
name|'teardown_container'
op|'('
name|'container_dir'
op|'='
name|'container_dir'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'contextlib'
op|'.'
name|'contextmanager'
newline|'\n'
DECL|member|_lxc_disk_handler
name|'def'
name|'_lxc_disk_handler'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'block_device_info'
op|','
name|'disk_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Context manager to handle the pre and post instance boot,\n           LXC specific disk operations.\n\n           An image or a volume path will be prepared and setup to be\n           used by the container, prior to starting it.\n           The disk will be disconnected and unmounted if a container has\n           failed to start.\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'!='
string|"'lxc'"
op|':'
newline|'\n'
indent|'            '
name|'yield'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_create_domain_setup_lxc'
op|'('
name|'instance'
op|','
name|'block_device_info'
op|','
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'yield'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_create_domain_cleanup_lxc'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_create_domain
dedent|''
dedent|''
name|'def'
name|'_create_domain'
op|'('
name|'self'
op|','
name|'xml'
op|'='
name|'None'
op|','
name|'domain'
op|'='
name|'None'
op|','
nl|'\n'
name|'instance'
op|'='
name|'None'
op|','
name|'launch_flags'
op|'='
number|'0'
op|','
name|'power_on'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a domain.\n\n        Either domain or xml must be passed in. If both are passed, then\n        the domain definition is overwritten from the xml.\n        """'
newline|'\n'
name|'err'
op|'='
name|'None'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'xml'
op|':'
newline|'\n'
indent|'                '
name|'err'
op|'='
name|'_LE'
op|'('
string|"'Error defining a domain with XML: %s'"
op|')'
op|'%'
name|'xml'
newline|'\n'
name|'domain'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'defineXML'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'power_on'
op|':'
newline|'\n'
indent|'                '
name|'err'
op|'='
name|'_LE'
op|'('
string|"'Error launching a defined domain with XML: %s'"
op|')'
op|'%'
name|'domain'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
name|'domain'
op|'.'
name|'createWithFlags'
op|'('
name|'launch_flags'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'utils'
op|'.'
name|'is_neutron'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'err'
op|'='
name|'_LE'
op|'('
string|"'Error enabling hairpin mode with XML: %s'"
op|')'
op|'%'
name|'domain'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_enable_hairpin'
op|'('
name|'domain'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'err'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'err'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'domain'
newline|'\n'
nl|'\n'
DECL|member|_neutron_failed_callback
dedent|''
name|'def'
name|'_neutron_failed_callback'
op|'('
name|'self'
op|','
name|'event_name'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'Neutron Reported failure on event '"
nl|'\n'
string|"'%(event)s for instance %(uuid)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'event'"
op|':'
name|'event_name'
op|','
string|"'uuid'"
op|':'
name|'instance'
op|'.'
name|'uuid'
op|'}'
op|')'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'vif_plugging_is_fatal'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'VirtualInterfaceCreateException'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_neutron_events
dedent|''
dedent|''
name|'def'
name|'_get_neutron_events'
op|'('
name|'self'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(danms): We need to collect any VIFs that are currently'
nl|'\n'
comment|'# down that we expect a down->up event for. Anything that is'
nl|'\n'
comment|'# already up will not undergo that transition, and for'
nl|'\n'
comment|"# anything that might be stale (cache-wise) assume it's"
nl|'\n'
comment|"# already up so we don't block on it."
nl|'\n'
indent|'        '
name|'return'
op|'['
op|'('
string|"'network-vif-plugged'"
op|','
name|'vif'
op|'['
string|"'id'"
op|']'
op|')'
nl|'\n'
name|'for'
name|'vif'
name|'in'
name|'network_info'
name|'if'
name|'vif'
op|'.'
name|'get'
op|'('
string|"'active'"
op|','
name|'True'
op|')'
name|'is'
name|'False'
op|']'
newline|'\n'
nl|'\n'
DECL|member|_create_domain_and_network
dedent|''
name|'def'
name|'_create_domain_and_network'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'xml'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'power_on'
op|'='
name|'True'
op|','
nl|'\n'
name|'reboot'
op|'='
name|'False'
op|','
name|'vifs_already_plugged'
op|'='
name|'False'
op|','
nl|'\n'
name|'disk_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'        '
string|'"""Do required network setup and create domain."""'
newline|'\n'
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'vol'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'            '
name|'connection_info'
op|'='
name|'vol'
op|'['
string|"'connection_info'"
op|']'
newline|'\n'
name|'info'
op|'='
name|'blockinfo'
op|'.'
name|'get_info_from_bdm'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
name|'vol'
op|')'
newline|'\n'
name|'conf'
op|'='
name|'self'
op|'.'
name|'_connect_volume'
op|'('
name|'connection_info'
op|','
name|'info'
op|')'
newline|'\n'
nl|'\n'
comment|'# cache device_path in connection_info -- required by encryptors'
nl|'\n'
name|'if'
string|"'data'"
name|'in'
name|'connection_info'
op|':'
newline|'\n'
indent|'                '
name|'connection_info'
op|'['
string|"'data'"
op|']'
op|'['
string|"'device_path'"
op|']'
op|'='
name|'conf'
op|'.'
name|'source_path'
newline|'\n'
name|'vol'
op|'['
string|"'connection_info'"
op|']'
op|'='
name|'connection_info'
newline|'\n'
name|'vol'
op|'.'
name|'save'
op|'('
name|'context'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'not'
name|'reboot'
name|'and'
string|"'data'"
name|'in'
name|'connection_info'
name|'and'
nl|'\n'
string|"'volume_id'"
name|'in'
name|'connection_info'
op|'['
string|"'data'"
op|']'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'volume_id'
op|'='
name|'connection_info'
op|'['
string|"'data'"
op|']'
op|'['
string|"'volume_id'"
op|']'
newline|'\n'
name|'encryption'
op|'='
name|'encryptors'
op|'.'
name|'get_encryption_metadata'
op|'('
nl|'\n'
name|'context'
op|','
name|'self'
op|'.'
name|'_volume_api'
op|','
name|'volume_id'
op|','
name|'connection_info'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'encryption'
op|':'
newline|'\n'
indent|'                    '
name|'encryptor'
op|'='
name|'self'
op|'.'
name|'_get_volume_encryptor'
op|'('
name|'connection_info'
op|','
nl|'\n'
name|'encryption'
op|')'
newline|'\n'
name|'encryptor'
op|'.'
name|'attach_volume'
op|'('
name|'context'
op|','
op|'**'
name|'encryption'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'timeout'
op|'='
name|'CONF'
op|'.'
name|'vif_plugging_timeout'
newline|'\n'
name|'if'
op|'('
name|'self'
op|'.'
name|'_conn_supports_start_paused'
name|'and'
nl|'\n'
name|'utils'
op|'.'
name|'is_neutron'
op|'('
op|')'
name|'and'
name|'not'
nl|'\n'
name|'vifs_already_plugged'
name|'and'
name|'power_on'
name|'and'
name|'timeout'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'='
name|'self'
op|'.'
name|'_get_neutron_events'
op|'('
name|'network_info'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'events'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'launch_flags'
op|'='
name|'events'
name|'and'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_START_PAUSED'
name|'or'
number|'0'
newline|'\n'
name|'domain'
op|'='
name|'None'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'self'
op|'.'
name|'virtapi'
op|'.'
name|'wait_for_instance_event'
op|'('
nl|'\n'
name|'instance'
op|','
name|'events'
op|','
name|'deadline'
op|'='
name|'timeout'
op|','
nl|'\n'
name|'error_callback'
op|'='
name|'self'
op|'.'
name|'_neutron_failed_callback'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'plug_vifs'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'setup_basic_filtering'
op|'('
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'prepare_instance_filter'
op|'('
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|')'
newline|'\n'
name|'with'
name|'self'
op|'.'
name|'_lxc_disk_handler'
op|'('
name|'instance'
op|','
name|'block_device_info'
op|','
nl|'\n'
name|'disk_info'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'domain'
op|'='
name|'self'
op|'.'
name|'_create_domain'
op|'('
nl|'\n'
name|'xml'
op|','
name|'instance'
op|'='
name|'instance'
op|','
nl|'\n'
name|'launch_flags'
op|'='
name|'launch_flags'
op|','
nl|'\n'
name|'power_on'
op|'='
name|'power_on'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'apply_instance_filter'
op|'('
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'exception'
op|'.'
name|'VirtualInterfaceCreateException'
op|':'
newline|'\n'
comment|"# Neutron reported failure and we didn't swallow it, so"
nl|'\n'
comment|'# bail here'
nl|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'domain'
op|':'
newline|'\n'
indent|'                    '
name|'domain'
op|'.'
name|'destroy'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'cleanup'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|'='
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'eventlet'
op|'.'
name|'timeout'
op|'.'
name|'Timeout'
op|':'
newline|'\n'
comment|'# We never heard from Neutron'
nl|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'Timeout waiting for vif plugging callback for '"
nl|'\n'
string|"'instance %(uuid)s'"
op|')'
op|','
op|'{'
string|"'uuid'"
op|':'
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|'}'
op|')'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'vif_plugging_is_fatal'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'domain'
op|':'
newline|'\n'
indent|'                    '
name|'domain'
op|'.'
name|'destroy'
op|'('
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'cleanup'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|'='
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'VirtualInterfaceCreateException'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Resume only if domain has been paused'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'launch_flags'
op|'&'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_START_PAUSED'
op|':'
newline|'\n'
indent|'            '
name|'domain'
op|'.'
name|'resume'
op|'('
op|')'
newline|'\n'
dedent|''
name|'return'
name|'domain'
newline|'\n'
nl|'\n'
DECL|member|_get_all_block_devices
dedent|''
name|'def'
name|'_get_all_block_devices'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return all block devices in use on this node."""'
newline|'\n'
name|'devices'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'dom'
name|'in'
name|'self'
op|'.'
name|'_list_instance_domains'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"couldn\'t obtain the XML from domain:"'
nl|'\n'
string|'" %(uuid)s, exception: %(ex)s"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|'"uuid"'
op|':'
name|'dom'
op|'.'
name|'UUIDString'
op|'('
op|')'
op|','
string|'"ex"'
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'ret'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
string|"'./devices/disk'"
op|')'
newline|'\n'
name|'for'
name|'node'
name|'in'
name|'ret'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'node'
op|'.'
name|'get'
op|'('
string|"'type'"
op|')'
op|'!='
string|"'block'"
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
dedent|''
name|'for'
name|'child'
name|'in'
name|'node'
op|'.'
name|'getchildren'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'child'
op|'.'
name|'tag'
op|'=='
string|"'source'"
op|':'
newline|'\n'
indent|'                        '
name|'devices'
op|'.'
name|'append'
op|'('
name|'child'
op|'.'
name|'get'
op|'('
string|"'dev'"
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'return'
name|'devices'
newline|'\n'
nl|'\n'
DECL|member|_get_interfaces
dedent|''
name|'def'
name|'_get_interfaces'
op|'('
name|'self'
op|','
name|'xml'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Note that this function takes a domain xml.\n\n        Returns a list of all network interfaces for this instance.\n        """'
newline|'\n'
name|'doc'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'['
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'interfaces'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'ret'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
string|"'./devices/interface'"
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'node'
name|'in'
name|'ret'
op|':'
newline|'\n'
indent|'            '
name|'devdst'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'for'
name|'child'
name|'in'
name|'list'
op|'('
name|'node'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'child'
op|'.'
name|'tag'
op|'=='
string|"'target'"
op|':'
newline|'\n'
indent|'                    '
name|'devdst'
op|'='
name|'child'
op|'.'
name|'attrib'
op|'['
string|"'dev'"
op|']'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'devdst'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'interfaces'
op|'.'
name|'append'
op|'('
name|'devdst'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'interfaces'
newline|'\n'
nl|'\n'
DECL|member|_get_vcpu_total
dedent|''
name|'def'
name|'_get_vcpu_total'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get available vcpu number of physical computer.\n\n        :returns: the number of cpu core instances can be used.\n\n        """'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_vcpu_total'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'self'
op|'.'
name|'_vcpu_total'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'total_pcpus'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'getInfo'
op|'('
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"Cannot get the number of cpu, because this "'
nl|'\n'
string|'"function is not implemented for this platform. "'
op|')'
op|')'
newline|'\n'
name|'return'
number|'0'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'vcpu_pin_set'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_vcpu_total'
op|'='
name|'total_pcpus'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_vcpu_total'
newline|'\n'
nl|'\n'
dedent|''
name|'available_ids'
op|'='
name|'hardware'
op|'.'
name|'get_vcpu_pin_set'
op|'('
op|')'
newline|'\n'
name|'if'
name|'sorted'
op|'('
name|'available_ids'
op|')'
op|'['
op|'-'
number|'1'
op|']'
op|'>='
name|'total_pcpus'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'Invalid'
op|'('
name|'_'
op|'('
string|'"Invalid vcpu_pin_set config, "'
nl|'\n'
string|'"out of hypervisor cpu range."'
op|')'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_vcpu_total'
op|'='
name|'len'
op|'('
name|'available_ids'
op|')'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_vcpu_total'
newline|'\n'
nl|'\n'
DECL|member|_get_memory_mb_total
dedent|''
name|'def'
name|'_get_memory_mb_total'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the total memory size(MB) of physical computer.\n\n        :returns: the total amount of memory(MB).\n\n        """'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'getInfo'
op|'('
op|')'
op|'['
number|'1'
op|']'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_get_local_gb_info
name|'def'
name|'_get_local_gb_info'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get local storage info of the compute node in GB.\n\n        :returns: A dict containing:\n             :total: How big the overall usable filesystem is (in gigabytes)\n             :free: How much space is free (in gigabytes)\n             :used: How much space is used (in gigabytes)\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_type'
op|'=='
string|"'lvm'"
op|':'
newline|'\n'
indent|'            '
name|'info'
op|'='
name|'lvm'
op|'.'
name|'get_volume_group_info'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_volume_group'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_type'
op|'=='
string|"'rbd'"
op|':'
newline|'\n'
indent|'            '
name|'info'
op|'='
name|'LibvirtDriver'
op|'.'
name|'_get_rbd_driver'
op|'('
op|')'
op|'.'
name|'get_pool_info'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'info'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_fs_info'
op|'('
name|'CONF'
op|'.'
name|'instances_path'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
op|'('
name|'k'
op|','
name|'v'
op|')'
name|'in'
name|'info'
op|'.'
name|'iteritems'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'info'
op|'['
name|'k'
op|']'
op|'='
name|'v'
op|'/'
name|'units'
op|'.'
name|'Gi'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'info'
newline|'\n'
nl|'\n'
DECL|member|_get_vcpu_used
dedent|''
name|'def'
name|'_get_vcpu_used'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get vcpu usage number of physical computer.\n\n        :returns: The total number of vcpu(s) that are currently being used.\n\n        """'
newline|'\n'
nl|'\n'
name|'total'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'lxc'"
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'total'
op|'+'
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'dom'
name|'in'
name|'self'
op|'.'
name|'_list_instance_domains'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'vcpus'
op|'='
name|'dom'
op|'.'
name|'vcpus'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"couldn\'t obtain the vpu count from domain id:"'
nl|'\n'
string|'" %(uuid)s, exception: %(ex)s"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|'"uuid"'
op|':'
name|'dom'
op|'.'
name|'UUIDString'
op|'('
op|')'
op|','
string|'"ex"'
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'vcpus'
name|'is'
name|'not'
name|'None'
name|'and'
name|'len'
op|'('
name|'vcpus'
op|')'
op|'>'
number|'1'
op|':'
newline|'\n'
indent|'                    '
name|'total'
op|'+='
name|'len'
op|'('
name|'vcpus'
op|'['
number|'1'
op|']'
op|')'
newline|'\n'
comment|'# NOTE(gtt116): give other tasks a chance.'
nl|'\n'
dedent|''
dedent|''
name|'greenthread'
op|'.'
name|'sleep'
op|'('
number|'0'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'total'
newline|'\n'
nl|'\n'
DECL|member|_get_memory_mb_used
dedent|''
name|'def'
name|'_get_memory_mb_used'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the used memory size(MB) of physical computer.\n\n        :returns: the total usage of memory(MB).\n\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'sys'
op|'.'
name|'platform'
op|'.'
name|'upper'
op|'('
op|')'
name|'not'
name|'in'
op|'['
string|"'LINUX2'"
op|','
string|"'LINUX3'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'return'
number|'0'
newline|'\n'
nl|'\n'
dedent|''
name|'with'
name|'open'
op|'('
string|"'/proc/meminfo'"
op|')'
name|'as'
name|'fp'
op|':'
newline|'\n'
indent|'            '
name|'m'
op|'='
name|'fp'
op|'.'
name|'read'
op|'('
op|')'
op|'.'
name|'split'
op|'('
op|')'
newline|'\n'
dedent|''
name|'idx1'
op|'='
name|'m'
op|'.'
name|'index'
op|'('
string|"'MemFree:'"
op|')'
newline|'\n'
name|'idx2'
op|'='
name|'m'
op|'.'
name|'index'
op|'('
string|"'Buffers:'"
op|')'
newline|'\n'
name|'idx3'
op|'='
name|'m'
op|'.'
name|'index'
op|'('
string|"'Cached:'"
op|')'
newline|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'xen'"
op|':'
newline|'\n'
indent|'            '
name|'used'
op|'='
number|'0'
newline|'\n'
name|'for'
name|'dom'
name|'in'
name|'self'
op|'.'
name|'_list_instance_domains'
op|'('
name|'only_guests'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'dom_mem'
op|'='
name|'int'
op|'('
name|'dom'
op|'.'
name|'info'
op|'('
op|')'
op|'['
number|'2'
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"couldn\'t obtain the memory from domain:"'
nl|'\n'
string|'" %(uuid)s, exception: %(ex)s"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|'"uuid"'
op|':'
name|'dom'
op|'.'
name|'UUIDString'
op|'('
op|')'
op|','
string|'"ex"'
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
comment|'# skip dom0'
nl|'\n'
dedent|''
name|'if'
name|'dom'
op|'.'
name|'ID'
op|'('
op|')'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'used'
op|'+='
name|'dom_mem'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# the mem reported by dom0 is be greater of what'
nl|'\n'
comment|'# it is being used'
nl|'\n'
indent|'                    '
name|'used'
op|'+='
op|'('
name|'dom_mem'
op|'-'
nl|'\n'
op|'('
name|'int'
op|'('
name|'m'
op|'['
name|'idx1'
op|'+'
number|'1'
op|']'
op|')'
op|'+'
nl|'\n'
name|'int'
op|'('
name|'m'
op|'['
name|'idx2'
op|'+'
number|'1'
op|']'
op|')'
op|'+'
nl|'\n'
name|'int'
op|'('
name|'m'
op|'['
name|'idx3'
op|'+'
number|'1'
op|']'
op|')'
op|')'
op|')'
newline|'\n'
comment|'# Convert it to MB'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'used'
op|'/'
name|'units'
op|'.'
name|'Ki'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'avail'
op|'='
op|'('
name|'int'
op|'('
name|'m'
op|'['
name|'idx1'
op|'+'
number|'1'
op|']'
op|')'
op|'+'
name|'int'
op|'('
name|'m'
op|'['
name|'idx2'
op|'+'
number|'1'
op|']'
op|')'
op|'+'
name|'int'
op|'('
name|'m'
op|'['
name|'idx3'
op|'+'
number|'1'
op|']'
op|')'
op|')'
newline|'\n'
comment|'# Convert it to MB'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'_get_memory_mb_total'
op|'('
op|')'
op|'-'
name|'avail'
op|'/'
name|'units'
op|'.'
name|'Ki'
newline|'\n'
nl|'\n'
DECL|member|_get_hypervisor_type
dedent|''
dedent|''
name|'def'
name|'_get_hypervisor_type'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get hypervisor type.\n\n        :returns: hypervisor type (ex. qemu)\n\n        """'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'getType'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_hypervisor_version
dedent|''
name|'def'
name|'_get_hypervisor_version'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get hypervisor version.\n\n        :returns: hypervisor version (ex. 12003)\n\n        """'
newline|'\n'
nl|'\n'
comment|'# NOTE(justinsb): getVersion moved between libvirt versions'
nl|'\n'
comment|'# Trying to do be compatible with older versions is a lost cause'
nl|'\n'
comment|'# But ... we can at least give the user a nice message'
nl|'\n'
name|'method'
op|'='
name|'getattr'
op|'('
name|'self'
op|'.'
name|'_conn'
op|','
string|"'getVersion'"
op|','
name|'None'
op|')'
newline|'\n'
name|'if'
name|'method'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'_'
op|'('
string|'"libvirt version is too old"'
nl|'\n'
string|'" (does not support getVersion)"'
op|')'
op|')'
newline|'\n'
comment|'# NOTE(justinsb): If we wanted to get the version, we could:'
nl|'\n'
comment|"# method = getattr(libvirt, 'getVersion', None)"
nl|'\n'
comment|'# NOTE(justinsb): This would then rely on a proper version check'
nl|'\n'
nl|'\n'
dedent|''
name|'return'
name|'method'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_hypervisor_hostname
dedent|''
name|'def'
name|'_get_hypervisor_hostname'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns the hostname of the hypervisor."""'
newline|'\n'
name|'hostname'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'getHostname'
op|'('
op|')'
newline|'\n'
name|'if'
name|'not'
name|'hasattr'
op|'('
name|'self'
op|','
string|"'_hypervisor_hostname'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_hypervisor_hostname'
op|'='
name|'hostname'
newline|'\n'
dedent|''
name|'elif'
name|'hostname'
op|'!='
name|'self'
op|'.'
name|'_hypervisor_hostname'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'Hostname has changed from %(old)s '"
nl|'\n'
string|"'to %(new)s. A restart is required to take effect.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'old'"
op|':'
name|'self'
op|'.'
name|'_hypervisor_hostname'
op|','
nl|'\n'
string|"'new'"
op|':'
name|'hostname'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_hypervisor_hostname'
newline|'\n'
nl|'\n'
DECL|member|_get_instance_capabilities
dedent|''
name|'def'
name|'_get_instance_capabilities'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get hypervisor instance capabilities\n\n        Returns a list of tuples that describe instances the\n        hypervisor is capable of hosting.  Each tuple consists\n        of the triplet (arch, hypervisor_type, vm_mode).\n\n        :returns: List of tuples describing instance capabilities\n        """'
newline|'\n'
name|'caps'
op|'='
name|'self'
op|'.'
name|'_get_host_capabilities'
op|'('
op|')'
newline|'\n'
name|'instance_caps'
op|'='
name|'list'
op|'('
op|')'
newline|'\n'
name|'for'
name|'g'
name|'in'
name|'caps'
op|'.'
name|'guests'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'dt'
name|'in'
name|'g'
op|'.'
name|'domtype'
op|':'
newline|'\n'
indent|'                '
name|'instance_cap'
op|'='
op|'('
nl|'\n'
name|'arch'
op|'.'
name|'canonicalize'
op|'('
name|'g'
op|'.'
name|'arch'
op|')'
op|','
nl|'\n'
name|'hvtype'
op|'.'
name|'canonicalize'
op|'('
name|'dt'
op|')'
op|','
nl|'\n'
name|'vm_mode'
op|'.'
name|'canonicalize'
op|'('
name|'g'
op|'.'
name|'ostype'
op|')'
op|')'
newline|'\n'
name|'instance_caps'
op|'.'
name|'append'
op|'('
name|'instance_cap'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'instance_caps'
newline|'\n'
nl|'\n'
DECL|member|_get_cpu_info
dedent|''
name|'def'
name|'_get_cpu_info'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get cpuinfo information.\n\n        Obtains cpu feature from virConnect.getCapabilities,\n        and returns as a json string.\n\n        :return: see above description\n\n        """'
newline|'\n'
nl|'\n'
name|'caps'
op|'='
name|'self'
op|'.'
name|'_get_host_capabilities'
op|'('
op|')'
newline|'\n'
name|'cpu_info'
op|'='
name|'dict'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'cpu_info'
op|'['
string|"'arch'"
op|']'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'arch'
newline|'\n'
name|'cpu_info'
op|'['
string|"'model'"
op|']'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'model'
newline|'\n'
name|'cpu_info'
op|'['
string|"'vendor'"
op|']'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'vendor'
newline|'\n'
nl|'\n'
name|'topology'
op|'='
name|'dict'
op|'('
op|')'
newline|'\n'
name|'topology'
op|'['
string|"'sockets'"
op|']'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'sockets'
newline|'\n'
name|'topology'
op|'['
string|"'cores'"
op|']'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'cores'
newline|'\n'
name|'topology'
op|'['
string|"'threads'"
op|']'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'threads'
newline|'\n'
name|'cpu_info'
op|'['
string|"'topology'"
op|']'
op|'='
name|'topology'
newline|'\n'
nl|'\n'
name|'features'
op|'='
name|'list'
op|'('
op|')'
newline|'\n'
name|'for'
name|'f'
name|'in'
name|'caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'features'
op|':'
newline|'\n'
indent|'            '
name|'features'
op|'.'
name|'append'
op|'('
name|'f'
op|'.'
name|'name'
op|')'
newline|'\n'
dedent|''
name|'cpu_info'
op|'['
string|"'features'"
op|']'
op|'='
name|'features'
newline|'\n'
nl|'\n'
comment|'# TODO(berrange): why do we bother converting the'
nl|'\n'
comment|'# libvirt capabilities XML into a special JSON format ?'
nl|'\n'
comment|'# The data format is different across all the drivers'
nl|'\n'
comment|'# so we could just return the raw capabilities XML'
nl|'\n'
comment|"# which 'compare_cpu' could use directly"
nl|'\n'
comment|'#'
nl|'\n'
comment|'# That said, arch_filter.py now seems to rely on'
nl|'\n'
comment|'# the libvirt drivers format which suggests this'
nl|'\n'
comment|'# data format needs to be standardized across drivers'
nl|'\n'
name|'return'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
name|'cpu_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_pcidev_info
dedent|''
name|'def'
name|'_get_pcidev_info'
op|'('
name|'self'
op|','
name|'devname'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns a dict of PCI device."""'
newline|'\n'
nl|'\n'
DECL|function|_get_device_type
name|'def'
name|'_get_device_type'
op|'('
name|'cfgdev'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Get a PCI device\'s device type.\n\n            An assignable PCI device can be a normal PCI device,\n            a SR-IOV Physical Function (PF), or a SR-IOV Virtual\n            Function (VF). Only normal PCI devices or SR-IOV VFs\n            are assignable, while SR-IOV PFs are always owned by\n            hypervisor.\n\n            Please notice that a PCI device with SR-IOV\n            capability but not enabled is reported as normal PCI device.\n            """'
newline|'\n'
name|'for'
name|'fun_cap'
name|'in'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'fun_capability'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'len'
op|'('
name|'fun_cap'
op|'.'
name|'device_addrs'
op|')'
op|'!='
number|'0'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'fun_cap'
op|'.'
name|'type'
op|'=='
string|"'virt_functions'"
op|':'
newline|'\n'
indent|'                        '
name|'return'
op|'{'
string|"'dev_type'"
op|':'
string|"'type-PF'"
op|'}'
newline|'\n'
dedent|''
name|'if'
name|'fun_cap'
op|'.'
name|'type'
op|'=='
string|"'phys_function'"
op|':'
newline|'\n'
indent|'                        '
name|'phys_address'
op|'='
string|'"%s:%s:%s.%s"'
op|'%'
op|'('
nl|'\n'
name|'fun_cap'
op|'.'
name|'device_addrs'
op|'['
number|'0'
op|']'
op|'['
number|'0'
op|']'
op|'.'
name|'replace'
op|'('
string|'"0x"'
op|','
string|"''"
op|')'
op|','
nl|'\n'
name|'fun_cap'
op|'.'
name|'device_addrs'
op|'['
number|'0'
op|']'
op|'['
number|'1'
op|']'
op|'.'
name|'replace'
op|'('
string|'"0x"'
op|','
string|"''"
op|')'
op|','
nl|'\n'
name|'fun_cap'
op|'.'
name|'device_addrs'
op|'['
number|'0'
op|']'
op|'['
number|'2'
op|']'
op|'.'
name|'replace'
op|'('
string|'"0x"'
op|','
string|"''"
op|')'
op|','
nl|'\n'
name|'fun_cap'
op|'.'
name|'device_addrs'
op|'['
number|'0'
op|']'
op|'['
number|'3'
op|']'
op|'.'
name|'replace'
op|'('
string|'"0x"'
op|','
string|"''"
op|')'
op|')'
newline|'\n'
name|'return'
op|'{'
string|"'dev_type'"
op|':'
string|"'type-VF'"
op|','
nl|'\n'
string|"'phys_function'"
op|':'
name|'phys_address'
op|'}'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
op|'{'
string|"'dev_type'"
op|':'
string|"'type-PCI'"
op|'}'
newline|'\n'
nl|'\n'
dedent|''
name|'virtdev'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'nodeDeviceLookupByName'
op|'('
name|'devname'
op|')'
newline|'\n'
name|'xmlstr'
op|'='
name|'virtdev'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
name|'cfgdev'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigNodeDevice'
op|'('
op|')'
newline|'\n'
name|'cfgdev'
op|'.'
name|'parse_str'
op|'('
name|'xmlstr'
op|')'
newline|'\n'
nl|'\n'
name|'address'
op|'='
string|'"%04x:%02x:%02x.%1x"'
op|'%'
op|'('
nl|'\n'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'domain'
op|','
nl|'\n'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'bus'
op|','
nl|'\n'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'slot'
op|','
nl|'\n'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'function'
op|')'
newline|'\n'
nl|'\n'
name|'device'
op|'='
op|'{'
nl|'\n'
string|'"dev_id"'
op|':'
name|'cfgdev'
op|'.'
name|'name'
op|','
nl|'\n'
string|'"address"'
op|':'
name|'address'
op|','
nl|'\n'
string|'"product_id"'
op|':'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'product_id'
op|'['
number|'2'
op|':'
number|'6'
op|']'
op|','
nl|'\n'
string|'"vendor_id"'
op|':'
name|'cfgdev'
op|'.'
name|'pci_capability'
op|'.'
name|'vendor_id'
op|'['
number|'2'
op|':'
number|'6'
op|']'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
comment|'# requirement by DataBase Model'
nl|'\n'
name|'device'
op|'['
string|"'label'"
op|']'
op|'='
string|"'label_%(vendor_id)s_%(product_id)s'"
op|'%'
name|'device'
newline|'\n'
name|'device'
op|'.'
name|'update'
op|'('
name|'_get_device_type'
op|'('
name|'cfgdev'
op|')'
op|')'
newline|'\n'
name|'return'
name|'device'
newline|'\n'
nl|'\n'
DECL|member|_pci_device_assignable
dedent|''
name|'def'
name|'_pci_device_assignable'
op|'('
name|'self'
op|','
name|'device'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'device'
op|'['
string|"'dev_type'"
op|']'
op|'=='
string|"'type-PF'"
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'dev_filter'
op|'.'
name|'device_assignable'
op|'('
name|'device'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_pci_passthrough_devices
dedent|''
name|'def'
name|'_get_pci_passthrough_devices'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get host PCI devices information.\n\n        Obtains pci devices information from libvirt, and returns\n        as a JSON string.\n\n        Each device information is a dictionary, with mandatory keys\n        of \'address\', \'vendor_id\', \'product_id\', \'dev_type\', \'dev_id\',\n        \'label\' and other optional device specific information.\n\n        Refer to the objects/pci_device.py for more idea of these keys.\n\n        :returns: a JSON string containaing a list of the assignable PCI\n                  devices information\n        """'
newline|'\n'
comment|"# Bail early if we know we can't support `listDevices` to avoid"
nl|'\n'
comment|'# repeated warnings within a periodic task'
nl|'\n'
name|'if'
name|'not'
name|'getattr'
op|'('
name|'self'
op|','
string|"'_list_devices_supported'"
op|','
name|'True'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'dev_names'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'listDevices'
op|'('
string|"'pci'"
op|','
number|'0'
op|')'
name|'or'
op|'['
op|']'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_SUPPORT'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_list_devices_supported'
op|'='
name|'False'
newline|'\n'
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"URI %(uri)s does not support "'
nl|'\n'
string|'"listDevices: "'
string|'"%(error)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'uri'"
op|':'
name|'self'
op|'.'
name|'uri'
op|'('
op|')'
op|','
string|"'error'"
op|':'
name|'ex'
op|'}'
op|')'
newline|'\n'
name|'return'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
op|'['
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'pci_info'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'name'
name|'in'
name|'dev_names'
op|':'
newline|'\n'
indent|'            '
name|'pci_dev'
op|'='
name|'self'
op|'.'
name|'_get_pcidev_info'
op|'('
name|'name'
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_pci_device_assignable'
op|'('
name|'pci_dev'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'pci_info'
op|'.'
name|'append'
op|'('
name|'pci_dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
name|'pci_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_host_numa_topology
dedent|''
name|'def'
name|'_get_host_numa_topology'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'self'
op|'.'
name|'_has_min_version'
op|'('
name|'MIN_LIBVIRT_NUMA_TOPOLOGY_VERSION'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'caps'
op|'='
name|'self'
op|'.'
name|'_get_host_capabilities'
op|'('
op|')'
newline|'\n'
name|'topology'
op|'='
name|'caps'
op|'.'
name|'host'
op|'.'
name|'topology'
newline|'\n'
nl|'\n'
name|'if'
name|'topology'
name|'is'
name|'None'
name|'or'
name|'not'
name|'topology'
op|'.'
name|'cells'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'topology'
op|'='
name|'hardware'
op|'.'
name|'VirtNUMAHostTopology'
op|'('
nl|'\n'
name|'cells'
op|'='
op|'['
name|'hardware'
op|'.'
name|'VirtNUMATopologyCellUsage'
op|'('
nl|'\n'
name|'cell'
op|'.'
name|'id'
op|','
name|'set'
op|'('
name|'cpu'
op|'.'
name|'id'
name|'for'
name|'cpu'
name|'in'
name|'cell'
op|'.'
name|'cpus'
op|')'
op|','
nl|'\n'
name|'cell'
op|'.'
name|'memory'
op|'/'
name|'units'
op|'.'
name|'Ki'
op|')'
nl|'\n'
name|'for'
name|'cell'
name|'in'
name|'topology'
op|'.'
name|'cells'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'allowed_cpus'
op|'='
name|'hardware'
op|'.'
name|'get_vcpu_pin_set'
op|'('
op|')'
newline|'\n'
name|'if'
name|'allowed_cpus'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'cell'
name|'in'
name|'topology'
op|'.'
name|'cells'
op|':'
newline|'\n'
indent|'                '
name|'cell'
op|'.'
name|'cpuset'
op|'&='
name|'allowed_cpus'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'topology'
newline|'\n'
nl|'\n'
DECL|member|get_all_volume_usage
dedent|''
name|'def'
name|'get_all_volume_usage'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'compute_host_bdms'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return usage info for volumes attached to vms on\n           a given host.\n        """'
newline|'\n'
name|'vol_usage'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'instance_bdms'
name|'in'
name|'compute_host_bdms'
op|':'
newline|'\n'
indent|'            '
name|'instance'
op|'='
name|'instance_bdms'
op|'['
string|"'instance'"
op|']'
newline|'\n'
nl|'\n'
name|'for'
name|'bdm'
name|'in'
name|'instance_bdms'
op|'['
string|"'instance_bdms'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'vol_stats'
op|'='
op|'['
op|']'
newline|'\n'
name|'mountpoint'
op|'='
name|'bdm'
op|'['
string|"'device_name'"
op|']'
newline|'\n'
name|'if'
name|'mountpoint'
op|'.'
name|'startswith'
op|'('
string|"'/dev/'"
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'mountpoint'
op|'='
name|'mountpoint'
op|'['
number|'5'
op|':'
op|']'
newline|'\n'
dedent|''
name|'volume_id'
op|'='
name|'bdm'
op|'['
string|"'volume_id'"
op|']'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Trying to get stats for the volume %s"'
op|','
nl|'\n'
name|'volume_id'
op|')'
newline|'\n'
name|'vol_stats'
op|'='
name|'self'
op|'.'
name|'block_stats'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|','
name|'mountpoint'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'vol_stats'
op|':'
newline|'\n'
indent|'                    '
name|'stats'
op|'='
name|'dict'
op|'('
name|'volume'
op|'='
name|'volume_id'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|','
nl|'\n'
name|'rd_req'
op|'='
name|'vol_stats'
op|'['
number|'0'
op|']'
op|','
nl|'\n'
name|'rd_bytes'
op|'='
name|'vol_stats'
op|'['
number|'1'
op|']'
op|','
nl|'\n'
name|'wr_req'
op|'='
name|'vol_stats'
op|'['
number|'2'
op|']'
op|','
nl|'\n'
name|'wr_bytes'
op|'='
name|'vol_stats'
op|'['
number|'3'
op|']'
op|','
nl|'\n'
name|'flush_operations'
op|'='
name|'vol_stats'
op|'['
number|'4'
op|']'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
nl|'\n'
string|'"Got volume usage stats for the volume=%(volume)s,"'
nl|'\n'
string|'" rd_req=%(rd_req)d, rd_bytes=%(rd_bytes)d, "'
nl|'\n'
string|'"wr_req=%(wr_req)d, wr_bytes=%(wr_bytes)d"'
op|','
nl|'\n'
name|'stats'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'vol_usage'
op|'.'
name|'append'
op|'('
name|'stats'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'vol_usage'
newline|'\n'
nl|'\n'
DECL|member|block_stats
dedent|''
name|'def'
name|'block_stats'
op|'('
name|'self'
op|','
name|'instance_name'
op|','
name|'disk_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Note that this function takes an instance name."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'domain'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance_name'
op|')'
newline|'\n'
name|'return'
name|'domain'
op|'.'
name|'blockStats'
op|'('
name|'disk_id'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'errcode'
op|'='
name|'e'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Getting block stats failed, device might have '"
nl|'\n'
string|"'been detached. Instance=%(instance_name)s '"
nl|'\n'
string|"'Disk=%(disk)s Code=%(errcode)s Error=%(e)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'instance_name'"
op|':'
name|'instance_name'
op|','
string|"'disk'"
op|':'
name|'disk_id'
op|','
nl|'\n'
string|"'errcode'"
op|':'
name|'errcode'
op|','
string|"'e'"
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Could not find domain in libvirt for instance %s. '"
nl|'\n'
string|"'Cannot get block stats for device'"
op|')'
op|','
name|'instance_name'
op|')'
newline|'\n'
nl|'\n'
DECL|member|interface_stats
dedent|''
dedent|''
name|'def'
name|'interface_stats'
op|'('
name|'self'
op|','
name|'instance_name'
op|','
name|'iface_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Note that this function takes an instance name."""'
newline|'\n'
name|'domain'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance_name'
op|')'
newline|'\n'
name|'return'
name|'domain'
op|'.'
name|'interfaceStats'
op|'('
name|'iface_id'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_console_pool_info
dedent|''
name|'def'
name|'get_console_pool_info'
op|'('
name|'self'
op|','
name|'console_type'
op|')'
op|':'
newline|'\n'
comment|'# TODO(mdragon): console proxy should be implemented for libvirt,'
nl|'\n'
comment|'#                in case someone wants to use it with kvm or'
nl|'\n'
comment|'#                such. For now return fake data.'
nl|'\n'
indent|'        '
name|'return'
op|'{'
string|"'address'"
op|':'
string|"'127.0.0.1'"
op|','
nl|'\n'
string|"'username'"
op|':'
string|"'fakeuser'"
op|','
nl|'\n'
string|"'password'"
op|':'
string|"'fakepassword'"
op|'}'
newline|'\n'
nl|'\n'
DECL|member|refresh_security_group_rules
dedent|''
name|'def'
name|'refresh_security_group_rules'
op|'('
name|'self'
op|','
name|'security_group_id'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'refresh_security_group_rules'
op|'('
name|'security_group_id'
op|')'
newline|'\n'
nl|'\n'
DECL|member|refresh_security_group_members
dedent|''
name|'def'
name|'refresh_security_group_members'
op|'('
name|'self'
op|','
name|'security_group_id'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'refresh_security_group_members'
op|'('
name|'security_group_id'
op|')'
newline|'\n'
nl|'\n'
DECL|member|refresh_instance_security_rules
dedent|''
name|'def'
name|'refresh_instance_security_rules'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'refresh_instance_security_rules'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|refresh_provider_fw_rules
dedent|''
name|'def'
name|'refresh_provider_fw_rules'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'refresh_provider_fw_rules'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_available_resource
dedent|''
name|'def'
name|'get_available_resource'
op|'('
name|'self'
op|','
name|'nodename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve resource information.\n\n        This method is called when nova-compute launches, and\n        as part of a periodic task that records the results in the DB.\n\n        :param nodename: will be put in PCI device\n        :returns: dictionary containing resource info\n        """'
newline|'\n'
nl|'\n'
name|'disk_info_dict'
op|'='
name|'self'
op|'.'
name|'_get_local_gb_info'
op|'('
op|')'
newline|'\n'
name|'data'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
comment|'# NOTE(dprince): calling capabilities before getVersion works around'
nl|'\n'
comment|'# an initialization issue with some versions of Libvirt (1.0.5.5).'
nl|'\n'
comment|'# See: https://bugzilla.redhat.com/show_bug.cgi?id=1000116'
nl|'\n'
comment|'# See: https://bugs.launchpad.net/nova/+bug/1215593'
nl|'\n'
nl|'\n'
comment|'# Temporary convert supported_instances into a string, while keeping'
nl|'\n'
comment|'# the RPC version as JSON. Can be changed when RPC broadcast is removed'
nl|'\n'
name|'data'
op|'['
string|'"supported_instances"'
op|']'
op|'='
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_get_instance_capabilities'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'data'
op|'['
string|'"vcpus"'
op|']'
op|'='
name|'self'
op|'.'
name|'_get_vcpu_total'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|'"memory_mb"'
op|']'
op|'='
name|'self'
op|'.'
name|'_get_memory_mb_total'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|'"local_gb"'
op|']'
op|'='
name|'disk_info_dict'
op|'['
string|"'total'"
op|']'
newline|'\n'
name|'data'
op|'['
string|'"vcpus_used"'
op|']'
op|'='
name|'self'
op|'.'
name|'_get_vcpu_used'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|'"memory_mb_used"'
op|']'
op|'='
name|'self'
op|'.'
name|'_get_memory_mb_used'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|'"local_gb_used"'
op|']'
op|'='
name|'disk_info_dict'
op|'['
string|"'used'"
op|']'
newline|'\n'
name|'data'
op|'['
string|'"hypervisor_type"'
op|']'
op|'='
name|'self'
op|'.'
name|'_get_hypervisor_type'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|'"hypervisor_version"'
op|']'
op|'='
name|'self'
op|'.'
name|'_get_hypervisor_version'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|'"hypervisor_hostname"'
op|']'
op|'='
name|'self'
op|'.'
name|'_get_hypervisor_hostname'
op|'('
op|')'
newline|'\n'
name|'data'
op|'['
string|'"cpu_info"'
op|']'
op|'='
name|'self'
op|'.'
name|'_get_cpu_info'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'disk_free_gb'
op|'='
name|'disk_info_dict'
op|'['
string|"'free'"
op|']'
newline|'\n'
name|'disk_over_committed'
op|'='
name|'self'
op|'.'
name|'_get_disk_over_committed_size_total'
op|'('
op|')'
newline|'\n'
name|'available_least'
op|'='
name|'disk_free_gb'
op|'*'
name|'units'
op|'.'
name|'Gi'
op|'-'
name|'disk_over_committed'
newline|'\n'
name|'data'
op|'['
string|"'disk_available_least'"
op|']'
op|'='
name|'available_least'
op|'/'
name|'units'
op|'.'
name|'Gi'
newline|'\n'
nl|'\n'
name|'data'
op|'['
string|"'pci_passthrough_devices'"
op|']'
op|'='
name|'self'
op|'.'
name|'_get_pci_passthrough_devices'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'numa_topology'
op|'='
name|'self'
op|'.'
name|'_get_host_numa_topology'
op|'('
op|')'
newline|'\n'
name|'if'
name|'numa_topology'
op|':'
newline|'\n'
indent|'            '
name|'data'
op|'['
string|"'numa_topology'"
op|']'
op|'='
name|'numa_topology'
op|'.'
name|'to_json'
op|'('
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'data'
op|'['
string|"'numa_topology'"
op|']'
op|'='
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'data'
newline|'\n'
nl|'\n'
DECL|member|check_instance_shared_storage_local
dedent|''
name|'def'
name|'check_instance_shared_storage_local'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'dirpath'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'dirpath'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
dedent|''
name|'fd'
op|','
name|'tmp_file'
op|'='
name|'tempfile'
op|'.'
name|'mkstemp'
op|'('
name|'dir'
op|'='
name|'dirpath'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Creating tmpfile %s to verify with other "'
nl|'\n'
string|'"compute node that the instance is on "'
nl|'\n'
string|'"the same shared storage."'
op|','
nl|'\n'
name|'tmp_file'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'fd'
op|')'
newline|'\n'
name|'return'
op|'{'
string|'"filename"'
op|':'
name|'tmp_file'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|check_instance_shared_storage_remote
dedent|''
name|'def'
name|'check_instance_shared_storage_remote'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'data'
op|'['
string|"'filename'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|check_instance_shared_storage_cleanup
dedent|''
name|'def'
name|'check_instance_shared_storage_cleanup'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'fileutils'
op|'.'
name|'delete_if_exists'
op|'('
name|'data'
op|'['
string|'"filename"'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|check_can_live_migrate_destination
dedent|''
name|'def'
name|'check_can_live_migrate_destination'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'src_compute_info'
op|','
name|'dst_compute_info'
op|','
nl|'\n'
name|'block_migration'
op|'='
name|'False'
op|','
nl|'\n'
name|'disk_over_commit'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check if it is possible to execute live migration.\n\n        This runs checks on the destination host, and then calls\n        back to the source host to check the results.\n\n        :param context: security context\n        :param instance: nova.db.sqlalchemy.models.Instance\n        :param block_migration: if true, prepare for block migration\n        :param disk_over_commit: if true, allow disk over commit\n        :returns: a dict containing:\n             :filename: name of the tmpfile under CONF.instances_path\n             :block_migration: whether this is block migration\n             :disk_over_commit: disk-over-commit factor on dest host\n             :disk_available_mb: available disk space on dest host\n        """'
newline|'\n'
name|'disk_available_mb'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'block_migration'
op|':'
newline|'\n'
indent|'            '
name|'disk_available_gb'
op|'='
name|'dst_compute_info'
op|'['
string|"'disk_available_least'"
op|']'
newline|'\n'
name|'disk_available_mb'
op|'='
op|'('
name|'disk_available_gb'
op|'*'
name|'units'
op|'.'
name|'Ki'
op|')'
op|'-'
name|'CONF'
op|'.'
name|'reserved_host_disk_mb'
newline|'\n'
nl|'\n'
comment|'# Compare CPU'
nl|'\n'
dedent|''
name|'source_cpu_info'
op|'='
name|'src_compute_info'
op|'['
string|"'cpu_info'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_compare_cpu'
op|'('
name|'source_cpu_info'
op|')'
newline|'\n'
nl|'\n'
comment|'# Create file on storage, to be checked on source host'
nl|'\n'
name|'filename'
op|'='
name|'self'
op|'.'
name|'_create_shared_storage_test_file'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'return'
op|'{'
string|'"filename"'
op|':'
name|'filename'
op|','
nl|'\n'
string|'"image_type"'
op|':'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_type'
op|','
nl|'\n'
string|'"block_migration"'
op|':'
name|'block_migration'
op|','
nl|'\n'
string|'"disk_over_commit"'
op|':'
name|'disk_over_commit'
op|','
nl|'\n'
string|'"disk_available_mb"'
op|':'
name|'disk_available_mb'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|check_can_live_migrate_destination_cleanup
dedent|''
name|'def'
name|'check_can_live_migrate_destination_cleanup'
op|'('
name|'self'
op|','
name|'context'
op|','
nl|'\n'
name|'dest_check_data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Do required cleanup on dest host after check_can_live_migrate calls\n\n        :param context: security context\n        """'
newline|'\n'
name|'filename'
op|'='
name|'dest_check_data'
op|'['
string|'"filename"'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_cleanup_shared_storage_test_file'
op|'('
name|'filename'
op|')'
newline|'\n'
nl|'\n'
DECL|member|check_can_live_migrate_source
dedent|''
name|'def'
name|'check_can_live_migrate_source'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'dest_check_data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check if it is possible to execute live migration.\n\n        This checks if the live migration can succeed, based on the\n        results from check_can_live_migrate_destination.\n\n        :param context: security context\n        :param instance: nova.db.sqlalchemy.models.Instance\n        :param dest_check_data: result of check_can_live_migrate_destination\n        :returns: a dict containing migration info\n        """'
newline|'\n'
comment|'# Checking shared storage connectivity'
nl|'\n'
comment|'# if block migration, instances_paths should not be on shared storage.'
nl|'\n'
name|'source'
op|'='
name|'CONF'
op|'.'
name|'host'
newline|'\n'
nl|'\n'
name|'dest_check_data'
op|'.'
name|'update'
op|'('
op|'{'
string|"'is_shared_instance_path'"
op|':'
nl|'\n'
name|'self'
op|'.'
name|'_check_shared_storage_test_file'
op|'('
nl|'\n'
name|'dest_check_data'
op|'['
string|"'filename'"
op|']'
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'dest_check_data'
op|'.'
name|'update'
op|'('
op|'{'
string|"'is_shared_block_storage'"
op|':'
nl|'\n'
name|'self'
op|'.'
name|'_is_shared_block_storage'
op|'('
name|'instance'
op|','
name|'dest_check_data'
op|')'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'dest_check_data'
op|'['
string|"'block_migration'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
name|'dest_check_data'
op|'['
string|"'is_shared_block_storage'"
op|']'
name|'or'
nl|'\n'
name|'dest_check_data'
op|'['
string|"'is_shared_instance_path'"
op|']'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'reason'
op|'='
name|'_'
op|'('
string|'"Block migration can not be used "'
nl|'\n'
string|'"with shared storage."'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InvalidLocalStorage'
op|'('
name|'reason'
op|'='
name|'reason'
op|','
name|'path'
op|'='
name|'source'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_assert_dest_node_has_enough_disk'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'dest_check_data'
op|'['
string|"'disk_available_mb'"
op|']'
op|','
nl|'\n'
name|'dest_check_data'
op|'['
string|"'disk_over_commit'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
name|'not'
op|'('
name|'dest_check_data'
op|'['
string|"'is_shared_block_storage'"
op|']'
name|'or'
nl|'\n'
name|'dest_check_data'
op|'['
string|"'is_shared_instance_path'"
op|']'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
name|'_'
op|'('
string|'"Live migration can not be used "'
nl|'\n'
string|'"without shared storage."'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InvalidSharedStorage'
op|'('
name|'reason'
op|'='
name|'reason'
op|','
name|'path'
op|'='
name|'source'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(mikal): include the instance directory name here because it'
nl|'\n'
comment|"# doesn't yet exist on the destination but we want to force that"
nl|'\n'
comment|'# same name to be used'
nl|'\n'
dedent|''
name|'instance_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|','
nl|'\n'
name|'relative'
op|'='
name|'True'
op|')'
newline|'\n'
name|'dest_check_data'
op|'['
string|"'instance_relative_path'"
op|']'
op|'='
name|'instance_path'
newline|'\n'
nl|'\n'
name|'return'
name|'dest_check_data'
newline|'\n'
nl|'\n'
DECL|member|_is_shared_block_storage
dedent|''
name|'def'
name|'_is_shared_block_storage'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'dest_check_data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check if all block storage of an instance can be shared\n        between source and destination of a live migration.\n\n        Returns true if the instance is volume backed and has no local disks,\n        or if the image backend is the same on source and destination and the\n        backend shares block storage between compute nodes.\n\n        :param instance: nova.objects.instance.Instance object\n        :param dest_check_data: dict with boolean fields image_type,\n                                is_shared_instance_path, and is_volume_backed\n        """'
newline|'\n'
name|'if'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_type'
op|'=='
name|'dest_check_data'
op|'.'
name|'get'
op|'('
string|"'image_type'"
op|')'
name|'and'
nl|'\n'
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'backend'
op|'('
op|')'
op|'.'
name|'is_shared_block_storage'
op|'('
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'dest_check_data'
op|'.'
name|'get'
op|'('
string|"'is_shared_instance_path'"
op|')'
name|'and'
nl|'\n'
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'backend'
op|'('
op|')'
op|'.'
name|'is_file_in_instance_path'
op|'('
op|')'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(angdraug): file based image backends (Raw, Qcow2)'
nl|'\n'
comment|'# place block device files under the instance path'
nl|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'dest_check_data'
op|'.'
name|'get'
op|'('
string|"'is_volume_backed'"
op|')'
name|'and'
nl|'\n'
name|'not'
name|'bool'
op|'('
name|'jsonutils'
op|'.'
name|'loads'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'get_instance_disk_info'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
op|')'
op|')'
op|')'
op|':'
newline|'\n'
comment|'# pylint: disable E1120'
nl|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|_assert_dest_node_has_enough_disk
dedent|''
name|'def'
name|'_assert_dest_node_has_enough_disk'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'available_mb'
op|','
name|'disk_over_commit'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Checks if destination has enough disk for block migration."""'
newline|'\n'
comment|'# Libvirt supports qcow2 disk format,which is usually compressed'
nl|'\n'
comment|'# on compute nodes.'
nl|'\n'
comment|'# Real disk image (compressed) may enlarged to "virtual disk size",'
nl|'\n'
comment|'# that is specified as the maximum disk size.'
nl|'\n'
comment|'# (See qemu-img -f path-to-disk)'
nl|'\n'
comment|'# Scheduler recognizes destination host still has enough disk space'
nl|'\n'
comment|'# if real disk size < available disk size'
nl|'\n'
comment|'# if disk_over_commit is True,'
nl|'\n'
comment|'#  otherwise virtual disk size < available disk size.'
nl|'\n'
nl|'\n'
name|'available'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'available_mb'
op|':'
newline|'\n'
indent|'            '
name|'available'
op|'='
name|'available_mb'
op|'*'
name|'units'
op|'.'
name|'Mi'
newline|'\n'
nl|'\n'
dedent|''
name|'ret'
op|'='
name|'self'
op|'.'
name|'get_instance_disk_info'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'disk_infos'
op|'='
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'ret'
op|')'
newline|'\n'
nl|'\n'
name|'necessary'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'disk_over_commit'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'info'
name|'in'
name|'disk_infos'
op|':'
newline|'\n'
indent|'                '
name|'necessary'
op|'+='
name|'int'
op|'('
name|'info'
op|'['
string|"'disk_size'"
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'info'
name|'in'
name|'disk_infos'
op|':'
newline|'\n'
indent|'                '
name|'necessary'
op|'+='
name|'int'
op|'('
name|'info'
op|'['
string|"'virt_disk_size'"
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# Check that available disk > necessary disk'
nl|'\n'
dedent|''
dedent|''
name|'if'
op|'('
name|'available'
op|'-'
name|'necessary'
op|')'
op|'<'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
op|'('
name|'_'
op|'('
string|"'Unable to migrate %(instance_uuid)s: '"
nl|'\n'
string|"'Disk of instance is too large(available'"
nl|'\n'
string|"' on destination host:%(available)s '"
nl|'\n'
string|"'< need:%(necessary)s)'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'instance_uuid'"
op|':'
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
string|"'available'"
op|':'
name|'available'
op|','
nl|'\n'
string|"'necessary'"
op|':'
name|'necessary'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'MigrationPreCheckError'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_compare_cpu
dedent|''
dedent|''
name|'def'
name|'_compare_cpu'
op|'('
name|'self'
op|','
name|'cpu_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Checks the host cpu is compatible to a cpu given by xml.\n        "xml" must be a part of libvirt.openAuth(...).getCapabilities().\n        return values follows by virCPUCompareResult.\n        if 0 > return value, do live migration.\n        \'http://libvirt.org/html/libvirt-libvirt.html#virCPUCompareResult\'\n\n        :param cpu_info: json string of cpu feature from _get_cpu_info()\n        :returns:\n            None. if given cpu info is not compatible to this server,\n            raise exception.\n        """'
newline|'\n'
nl|'\n'
comment|'# NOTE(berendt): virConnectCompareCPU not working for Xen'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|'=='
string|"'xen'"
op|':'
newline|'\n'
indent|'            '
name|'return'
number|'1'
newline|'\n'
nl|'\n'
dedent|''
name|'info'
op|'='
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'cpu_info'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Instance launched has CPU info: %s'"
op|')'
op|','
name|'cpu_info'
op|')'
newline|'\n'
name|'cpu'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigCPU'
op|'('
op|')'
newline|'\n'
name|'cpu'
op|'.'
name|'arch'
op|'='
name|'info'
op|'['
string|"'arch'"
op|']'
newline|'\n'
name|'cpu'
op|'.'
name|'model'
op|'='
name|'info'
op|'['
string|"'model'"
op|']'
newline|'\n'
name|'cpu'
op|'.'
name|'vendor'
op|'='
name|'info'
op|'['
string|"'vendor'"
op|']'
newline|'\n'
name|'cpu'
op|'.'
name|'sockets'
op|'='
name|'info'
op|'['
string|"'topology'"
op|']'
op|'['
string|"'sockets'"
op|']'
newline|'\n'
name|'cpu'
op|'.'
name|'cores'
op|'='
name|'info'
op|'['
string|"'topology'"
op|']'
op|'['
string|"'cores'"
op|']'
newline|'\n'
name|'cpu'
op|'.'
name|'threads'
op|'='
name|'info'
op|'['
string|"'topology'"
op|']'
op|'['
string|"'threads'"
op|']'
newline|'\n'
name|'for'
name|'f'
name|'in'
name|'info'
op|'['
string|"'features'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'cpu'
op|'.'
name|'add_feature'
op|'('
name|'vconfig'
op|'.'
name|'LibvirtConfigCPUFeature'
op|'('
name|'f'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'u'
op|'='
string|'"http://libvirt.org/html/libvirt-libvirt.html#virCPUCompareResult"'
newline|'\n'
name|'m'
op|'='
name|'_'
op|'('
string|'"CPU doesn\'t have compatibility.\\n\\n%(ret)s\\n\\nRefer to %(u)s"'
op|')'
newline|'\n'
comment|'# unknown character exists in xml, then libvirt complains'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'ret'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'compareCPU'
op|'('
name|'cpu'
op|'.'
name|'to_xml'
op|'('
op|')'
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'ret'
op|'='
name|'unicode'
op|'('
name|'e'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'error'
op|'('
name|'m'
op|','
op|'{'
string|"'ret'"
op|':'
name|'ret'
op|','
string|"'u'"
op|':'
name|'u'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'ret'
op|'<='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'m'
op|','
op|'{'
string|"'ret'"
op|':'
name|'ret'
op|','
string|"'u'"
op|':'
name|'u'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InvalidCPUInfo'
op|'('
name|'reason'
op|'='
name|'m'
op|'%'
op|'{'
string|"'ret'"
op|':'
name|'ret'
op|','
string|"'u'"
op|':'
name|'u'
op|'}'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_create_shared_storage_test_file
dedent|''
dedent|''
name|'def'
name|'_create_shared_storage_test_file'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Makes tmpfile under CONF.instances_path."""'
newline|'\n'
name|'dirpath'
op|'='
name|'CONF'
op|'.'
name|'instances_path'
newline|'\n'
name|'fd'
op|','
name|'tmp_file'
op|'='
name|'tempfile'
op|'.'
name|'mkstemp'
op|'('
name|'dir'
op|'='
name|'dirpath'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Creating tmpfile %s to notify to other "'
nl|'\n'
string|'"compute nodes that they should mount "'
nl|'\n'
string|'"the same storage."'
op|','
name|'tmp_file'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'close'
op|'('
name|'fd'
op|')'
newline|'\n'
name|'return'
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'tmp_file'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_check_shared_storage_test_file
dedent|''
name|'def'
name|'_check_shared_storage_test_file'
op|'('
name|'self'
op|','
name|'filename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Confirms existence of the tmpfile under CONF.instances_path.\n\n        Cannot confirm tmpfile return False.\n        """'
newline|'\n'
name|'tmp_file'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'CONF'
op|'.'
name|'instances_path'
op|','
name|'filename'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'tmp_file'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
nl|'\n'
DECL|member|_cleanup_shared_storage_test_file
dedent|''
dedent|''
name|'def'
name|'_cleanup_shared_storage_test_file'
op|'('
name|'self'
op|','
name|'filename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Removes existence of the tmpfile under CONF.instances_path."""'
newline|'\n'
name|'tmp_file'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'CONF'
op|'.'
name|'instances_path'
op|','
name|'filename'
op|')'
newline|'\n'
name|'os'
op|'.'
name|'remove'
op|'('
name|'tmp_file'
op|')'
newline|'\n'
nl|'\n'
DECL|member|ensure_filtering_rules_for_instance
dedent|''
name|'def'
name|'ensure_filtering_rules_for_instance'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Ensure that an instance\'s filtering rules are enabled.\n\n        When migrating an instance, we need the filtering rules to\n        be configured on the destination host before starting the\n        migration.\n\n        Also, when restarting the compute service, we need to ensure\n        that filtering rules exist for all running services.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'setup_basic_filtering'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'prepare_instance_filter'
op|'('
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
comment|'# nwfilters may be defined in a separate thread in the case'
nl|'\n'
comment|'# of libvirt non-blocking mode, so we wait for completion'
nl|'\n'
name|'timeout_count'
op|'='
name|'range'
op|'('
name|'CONF'
op|'.'
name|'live_migration_retry_count'
op|')'
newline|'\n'
name|'while'
name|'timeout_count'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'instance_filter_exists'
op|'('
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'break'
newline|'\n'
dedent|''
name|'timeout_count'
op|'.'
name|'pop'
op|'('
op|')'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'timeout_count'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'msg'
op|'='
name|'_'
op|'('
string|"'The firewall filter for %s does not exist'"
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|'%'
name|'instance'
op|'.'
name|'name'
op|')'
newline|'\n'
dedent|''
name|'greenthread'
op|'.'
name|'sleep'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
DECL|member|filter_defer_apply_on
dedent|''
dedent|''
name|'def'
name|'filter_defer_apply_on'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'filter_defer_apply_on'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|filter_defer_apply_off
dedent|''
name|'def'
name|'filter_defer_apply_off'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'filter_defer_apply_off'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|live_migration
dedent|''
name|'def'
name|'live_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
nl|'\n'
name|'post_method'
op|','
name|'recover_method'
op|','
name|'block_migration'
op|'='
name|'False'
op|','
nl|'\n'
name|'migrate_data'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Spawning live_migration operation for distributing high-load.\n\n        :param context: security context\n        :param instance:\n            nova.db.sqlalchemy.models.Instance object\n            instance object that is migrated.\n        :param dest: destination host\n        :param post_method:\n            post operation method.\n            expected nova.compute.manager._post_live_migration.\n        :param recover_method:\n            recovery method when any exception occurs.\n            expected nova.compute.manager._rollback_live_migration.\n        :param block_migration: if true, do block migration.\n        :param migrate_data: implementation specific params\n\n        """'
newline|'\n'
nl|'\n'
comment|"# 'dest' will be substituted into 'migration_uri' so ensure"
nl|'\n'
comment|"# it does't contain any characters that could be used to"
nl|'\n'
comment|'# exploit the URI accepted by libivrt'
nl|'\n'
name|'if'
name|'not'
name|'libvirt_utils'
op|'.'
name|'is_valid_hostname'
op|'('
name|'dest'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'InvalidHostname'
op|'('
name|'hostname'
op|'='
name|'dest'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'greenthread'
op|'.'
name|'spawn'
op|'('
name|'self'
op|'.'
name|'_live_migration'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
nl|'\n'
name|'post_method'
op|','
name|'recover_method'
op|','
name|'block_migration'
op|','
nl|'\n'
name|'migrate_data'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_correct_listen_addr
dedent|''
name|'def'
name|'_correct_listen_addr'
op|'('
name|'self'
op|','
name|'old_xml_str'
op|','
name|'listen_addrs'
op|')'
op|':'
newline|'\n'
comment|"# NB(sross): can't just use LibvirtConfigGuest#parse_str"
nl|'\n'
comment|"#            here b/c it doesn't capture the entire XML"
nl|'\n'
comment|'#            description'
nl|'\n'
indent|'        '
name|'xml_doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'old_xml_str'
op|')'
newline|'\n'
nl|'\n'
comment|'# change over listen addresses'
nl|'\n'
name|'for'
name|'dev'
name|'in'
name|'xml_doc'
op|'.'
name|'findall'
op|'('
string|"'./devices/graphics'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'gr_type'
op|'='
name|'dev'
op|'.'
name|'get'
op|'('
string|"'type'"
op|')'
newline|'\n'
name|'listen_tag'
op|'='
name|'dev'
op|'.'
name|'find'
op|'('
string|"'listen'"
op|')'
newline|'\n'
name|'if'
name|'gr_type'
name|'in'
op|'('
string|"'vnc'"
op|','
string|"'spice'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'listen_tag'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'listen_tag'
op|'.'
name|'set'
op|'('
string|"'address'"
op|','
name|'listen_addrs'
op|'['
name|'gr_type'
op|']'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'dev'
op|'.'
name|'get'
op|'('
string|"'listen'"
op|')'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'dev'
op|'.'
name|'set'
op|'('
string|"'listen'"
op|','
name|'listen_addrs'
op|'['
name|'gr_type'
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'etree'
op|'.'
name|'tostring'
op|'('
name|'xml_doc'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_check_graphics_addresses_can_live_migrate
dedent|''
name|'def'
name|'_check_graphics_addresses_can_live_migrate'
op|'('
name|'self'
op|','
name|'listen_addrs'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOCAL_ADDRS'
op|'='
op|'('
string|"'0.0.0.0'"
op|','
string|"'127.0.0.1'"
op|','
string|"'::'"
op|','
string|"'::1'"
op|')'
newline|'\n'
nl|'\n'
name|'local_vnc'
op|'='
name|'CONF'
op|'.'
name|'vncserver_listen'
name|'in'
name|'LOCAL_ADDRS'
newline|'\n'
name|'local_spice'
op|'='
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'server_listen'
name|'in'
name|'LOCAL_ADDRS'
newline|'\n'
nl|'\n'
name|'if'
op|'('
op|'('
name|'CONF'
op|'.'
name|'vnc_enabled'
name|'and'
name|'not'
name|'local_vnc'
op|')'
name|'or'
nl|'\n'
op|'('
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'enabled'
name|'and'
name|'not'
name|'local_spice'
op|')'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'MigrationError'
op|'('
nl|'\n'
name|'_'
op|'('
string|"'Your libvirt version does not support the'"
nl|'\n'
string|"' VIR_DOMAIN_XML_MIGRATABLE flag or your'"
nl|'\n'
string|"' destination node does not support'"
nl|'\n'
string|"' retrieving listen addresses.  In order'"
nl|'\n'
string|"' for live migration to work properly, you'"
nl|'\n'
string|"' must configure the graphics (VNC and/or'"
nl|'\n'
string|"' SPICE) listen addresses to be either'"
nl|'\n'
string|"' the catch-all address (0.0.0.0 or ::) or'"
nl|'\n'
string|"' the local address (127.0.0.1 or ::1).'"
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'listen_addrs'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'dest_local_vnc'
op|'='
name|'listen_addrs'
op|'['
string|"'vnc'"
op|']'
name|'in'
name|'LOCAL_ADDRS'
newline|'\n'
name|'dest_local_spice'
op|'='
name|'listen_addrs'
op|'['
string|"'spice'"
op|']'
name|'in'
name|'LOCAL_ADDRS'
newline|'\n'
nl|'\n'
name|'if'
op|'('
op|'('
name|'CONF'
op|'.'
name|'vnc_enabled'
name|'and'
name|'not'
name|'dest_local_vnc'
op|')'
name|'or'
nl|'\n'
op|'('
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'enabled'
name|'and'
name|'not'
name|'dest_local_spice'
op|')'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|"'Your libvirt version does not support the'"
nl|'\n'
string|"' VIR_DOMAIN_XML_MIGRATABLE flag, and the '"
nl|'\n'
string|"' graphics (VNC and/or SPICE) listen'"
nl|'\n'
string|"' addresses on the destination node do not'"
nl|'\n'
string|"' match the addresses on the source node.'"
nl|'\n'
string|"' Since the source node has listen'"
nl|'\n'
string|"' addresses set to either the catch-all'"
nl|'\n'
string|"' address (0.0.0.0 or ::) or the local'"
nl|'\n'
string|"' address (127.0.0.1 or ::1), the live'"
nl|'\n'
string|"' migration will succeed, but the VM will'"
nl|'\n'
string|"' continue to listen on the current'"
nl|'\n'
string|"' addresses.'"
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_live_migration
dedent|''
dedent|''
dedent|''
name|'def'
name|'_live_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
name|'post_method'
op|','
nl|'\n'
name|'recover_method'
op|','
name|'block_migration'
op|'='
name|'False'
op|','
nl|'\n'
name|'migrate_data'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Do live migration.\n\n        :param context: security context\n        :param instance:\n            nova.db.sqlalchemy.models.Instance object\n            instance object that is migrated.\n        :param dest: destination host\n        :param post_method:\n            post operation method.\n            expected nova.compute.manager._post_live_migration.\n        :param recover_method:\n            recovery method when any exception occurs.\n            expected nova.compute.manager._rollback_live_migration.\n        :param block_migration: if true, do block migration.\n        :param migrate_data: implementation specific params\n        """'
newline|'\n'
nl|'\n'
comment|'# Do live migration.'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'block_migration'
op|':'
newline|'\n'
indent|'                '
name|'flaglist'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'block_migration_flag'
op|'.'
name|'split'
op|'('
string|"','"
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'flaglist'
op|'='
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'live_migration_flag'
op|'.'
name|'split'
op|'('
string|"','"
op|')'
newline|'\n'
dedent|''
name|'flagvals'
op|'='
op|'['
name|'getattr'
op|'('
name|'libvirt'
op|','
name|'x'
op|'.'
name|'strip'
op|'('
op|')'
op|')'
name|'for'
name|'x'
name|'in'
name|'flaglist'
op|']'
newline|'\n'
name|'logical_sum'
op|'='
name|'reduce'
op|'('
name|'lambda'
name|'x'
op|','
name|'y'
op|':'
name|'x'
op|'|'
name|'y'
op|','
name|'flagvals'
op|')'
newline|'\n'
nl|'\n'
name|'dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|'"name"'
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'pre_live_migrate_data'
op|'='
op|'('
name|'migrate_data'
name|'or'
op|'{'
op|'}'
op|')'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'pre_live_migration_result'"
op|','
op|'{'
op|'}'
op|')'
newline|'\n'
name|'listen_addrs'
op|'='
name|'pre_live_migrate_data'
op|'.'
name|'get'
op|'('
string|"'graphics_listen_addrs'"
op|')'
newline|'\n'
nl|'\n'
name|'migratable_flag'
op|'='
name|'getattr'
op|'('
name|'libvirt'
op|','
string|"'VIR_DOMAIN_XML_MIGRATABLE'"
op|','
nl|'\n'
name|'None'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'migratable_flag'
name|'is'
name|'None'
name|'or'
name|'listen_addrs'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_check_graphics_addresses_can_live_migrate'
op|'('
name|'listen_addrs'
op|')'
newline|'\n'
name|'dom'
op|'.'
name|'migrateToURI'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'live_migration_uri'
op|'%'
name|'dest'
op|','
nl|'\n'
name|'logical_sum'
op|','
nl|'\n'
name|'None'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'live_migration_bandwidth'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'old_xml_str'
op|'='
name|'dom'
op|'.'
name|'XMLDesc'
op|'('
name|'migratable_flag'
op|')'
newline|'\n'
name|'new_xml_str'
op|'='
name|'self'
op|'.'
name|'_correct_listen_addr'
op|'('
name|'old_xml_str'
op|','
nl|'\n'
name|'listen_addrs'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'dom'
op|'.'
name|'migrateToURI2'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'live_migration_uri'
op|'%'
name|'dest'
op|','
nl|'\n'
name|'None'
op|','
nl|'\n'
name|'new_xml_str'
op|','
nl|'\n'
name|'logical_sum'
op|','
nl|'\n'
name|'None'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'live_migration_bandwidth'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
comment|'# NOTE(mriedem): There is a bug in older versions of'
nl|'\n'
comment|'# libvirt where the VIR_DOMAIN_XML_MIGRATABLE flag causes'
nl|'\n'
comment|'# virDomainDefCheckABIStability to not compare the source'
nl|'\n'
comment|"# and target domain xml's correctly for the CPU model."
nl|'\n'
comment|'# We try to handle that error here and attempt the legacy'
nl|'\n'
comment|'# migrateToURI path, which could fail if the console'
nl|'\n'
comment|'# addresses are not correct, but in that case we have the'
nl|'\n'
comment|'# _check_graphics_addresses_can_live_migrate check in place'
nl|'\n'
comment|'# to catch it.'
nl|'\n'
comment|'# TODO(mriedem): Remove this workaround when'
nl|'\n'
comment|'# Red Hat BZ #1141838 is closed.'
nl|'\n'
indent|'                    '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_CONFIG_UNSUPPORTED'
op|':'
newline|'\n'
indent|'                        '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'An error occurred trying to live '"
nl|'\n'
string|"'migrate. Falling back to legacy live '"
nl|'\n'
string|"'migrate flow. Error: %s'"
op|')'
op|','
name|'ex'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_check_graphics_addresses_can_live_migrate'
op|'('
nl|'\n'
name|'listen_addrs'
op|')'
newline|'\n'
name|'dom'
op|'.'
name|'migrateToURI'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'live_migration_uri'
op|'%'
name|'dest'
op|','
nl|'\n'
name|'logical_sum'
op|','
nl|'\n'
name|'None'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'live_migration_bandwidth'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|'"Live Migration failure: %s"'
op|')'
op|','
name|'e'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'recover_method'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
name|'block_migration'
op|')'
newline|'\n'
nl|'\n'
comment|'# Waiting for completion of live_migration.'
nl|'\n'
dedent|''
dedent|''
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
name|'f'
op|'='
name|'None'
op|')'
newline|'\n'
nl|'\n'
DECL|function|wait_for_live_migration
name|'def'
name|'wait_for_live_migration'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""waiting for live migration completion."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'get_info'
op|'('
name|'instance'
op|')'
op|'['
string|"'state'"
op|']'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'                '
name|'timer'
op|'.'
name|'stop'
op|'('
op|')'
newline|'\n'
name|'post_method'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
name|'block_migration'
op|','
nl|'\n'
name|'migrate_data'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'timer'
op|'.'
name|'f'
op|'='
name|'wait_for_live_migration'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_fetch_instance_kernel_ramdisk
dedent|''
name|'def'
name|'_fetch_instance_kernel_ramdisk'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Download kernel and ramdisk for instance in instance directory."""'
newline|'\n'
name|'instance_dir'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'instance'
op|'['
string|"'kernel_id'"
op|']'
op|':'
newline|'\n'
indent|'            '
name|'libvirt_utils'
op|'.'
name|'fetch_image'
op|'('
name|'context'
op|','
nl|'\n'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
string|"'kernel'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'kernel_id'"
op|']'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'user_id'"
op|']'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'project_id'"
op|']'
op|')'
newline|'\n'
name|'if'
name|'instance'
op|'['
string|"'ramdisk_id'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'libvirt_utils'
op|'.'
name|'fetch_image'
op|'('
name|'context'
op|','
nl|'\n'
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
nl|'\n'
string|"'ramdisk'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'ramdisk_id'"
op|']'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'user_id'"
op|']'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'project_id'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|rollback_live_migration_at_destination
dedent|''
dedent|''
dedent|''
name|'def'
name|'rollback_live_migration_at_destination'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|','
nl|'\n'
name|'destroy_disks'
op|'='
name|'True'
op|','
nl|'\n'
name|'migrate_data'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Clean up destination node after a failed live migration."""'
newline|'\n'
name|'self'
op|'.'
name|'destroy'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|','
nl|'\n'
name|'destroy_disks'
op|','
name|'migrate_data'
op|')'
newline|'\n'
nl|'\n'
DECL|member|pre_live_migration
dedent|''
name|'def'
name|'pre_live_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'block_device_info'
op|','
nl|'\n'
name|'network_info'
op|','
name|'disk_info'
op|','
name|'migrate_data'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Preparation live migration."""'
newline|'\n'
comment|'# Steps for volume backed instance live migration w/o shared storage.'
nl|'\n'
name|'is_shared_block_storage'
op|'='
name|'True'
newline|'\n'
name|'is_shared_instance_path'
op|'='
name|'True'
newline|'\n'
name|'is_block_migration'
op|'='
name|'True'
newline|'\n'
name|'instance_relative_path'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'migrate_data'
op|':'
newline|'\n'
indent|'            '
name|'is_shared_block_storage'
op|'='
name|'migrate_data'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'is_shared_block_storage'"
op|','
name|'True'
op|')'
newline|'\n'
name|'is_shared_instance_path'
op|'='
name|'migrate_data'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'is_shared_instance_path'"
op|','
name|'True'
op|')'
newline|'\n'
name|'is_block_migration'
op|'='
name|'migrate_data'
op|'.'
name|'get'
op|'('
string|"'block_migration'"
op|','
name|'True'
op|')'
newline|'\n'
name|'instance_relative_path'
op|'='
name|'migrate_data'
op|'.'
name|'get'
op|'('
string|"'instance_relative_path'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
op|'('
name|'is_shared_instance_path'
name|'and'
name|'is_shared_block_storage'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(mikal): live migration of instances using config drive is'
nl|'\n'
comment|'# not supported because of a bug in libvirt (read only devices'
nl|'\n'
comment|'# are not copied by libvirt). See bug/1246201'
nl|'\n'
indent|'            '
name|'if'
name|'configdrive'
op|'.'
name|'required_by'
op|'('
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'NoLiveMigrationForConfigDriveInLibVirt'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'is_shared_instance_path'
op|':'
newline|'\n'
comment|"# NOTE(mikal): this doesn't use libvirt_utils.get_instance_path"
nl|'\n'
comment|'# because we are ensuring that the same instance directory name'
nl|'\n'
comment|'# is used as was at the source'
nl|'\n'
indent|'            '
name|'if'
name|'instance_relative_path'
op|':'
newline|'\n'
indent|'                '
name|'instance_dir'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'CONF'
op|'.'
name|'instances_path'
op|','
nl|'\n'
name|'instance_relative_path'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'instance_dir'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'instance_dir'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'DestinationDiskExists'
op|'('
name|'path'
op|'='
name|'instance_dir'
op|')'
newline|'\n'
dedent|''
name|'os'
op|'.'
name|'mkdir'
op|'('
name|'instance_dir'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'is_shared_block_storage'
op|':'
newline|'\n'
comment|'# Ensure images and backing files are present.'
nl|'\n'
indent|'                '
name|'self'
op|'.'
name|'_create_images_and_backing'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'instance_dir'
op|','
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
op|'('
name|'is_block_migration'
name|'or'
name|'is_shared_instance_path'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(angdraug): when block storage is shared between source and'
nl|'\n'
comment|"# destination and instance path isn't (e.g. volume backed or rbd"
nl|'\n'
comment|'# backed instance), instance path on destination has to be prepared'
nl|'\n'
nl|'\n'
comment|'# Touch the console.log file, required by libvirt.'
nl|'\n'
indent|'            '
name|'console_file'
op|'='
name|'self'
op|'.'
name|'_get_console_log_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'libvirt_utils'
op|'.'
name|'file_open'
op|'('
name|'console_file'
op|','
string|"'a'"
op|')'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# if image has kernel and ramdisk, just download'
nl|'\n'
comment|'# following normal way.'
nl|'\n'
name|'self'
op|'.'
name|'_fetch_instance_kernel_ramdisk'
op|'('
name|'context'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# Establishing connection to volume server.'
nl|'\n'
dedent|''
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'for'
name|'vol'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'            '
name|'connection_info'
op|'='
name|'vol'
op|'['
string|"'connection_info'"
op|']'
newline|'\n'
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_info_from_bdm'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
name|'vol'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_connect_volume'
op|'('
name|'connection_info'
op|','
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
comment|'# We call plug_vifs before the compute manager calls'
nl|'\n'
comment|'# ensure_filtering_rules_for_instance, to ensure bridge is set up'
nl|'\n'
comment|'# Retry operation is necessary because continuously request comes,'
nl|'\n'
comment|'# concurrent request occurs to iptables, then it complains.'
nl|'\n'
dedent|''
name|'max_retry'
op|'='
name|'CONF'
op|'.'
name|'live_migration_retry_count'
newline|'\n'
name|'for'
name|'cnt'
name|'in'
name|'range'
op|'('
name|'max_retry'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'plug_vifs'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'except'
name|'processutils'
op|'.'
name|'ProcessExecutionError'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'cnt'
op|'=='
name|'max_retry'
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'plug_vifs() failed %(cnt)d. Retry up to '"
nl|'\n'
string|"'%(max_retry)d.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'cnt'"
op|':'
name|'cnt'
op|','
nl|'\n'
string|"'max_retry'"
op|':'
name|'max_retry'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'greenthread'
op|'.'
name|'sleep'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'res_data'
op|'='
op|'{'
string|"'graphics_listen_addrs'"
op|':'
op|'{'
op|'}'
op|'}'
newline|'\n'
name|'res_data'
op|'['
string|"'graphics_listen_addrs'"
op|']'
op|'['
string|"'vnc'"
op|']'
op|'='
name|'CONF'
op|'.'
name|'vncserver_listen'
newline|'\n'
name|'res_data'
op|'['
string|"'graphics_listen_addrs'"
op|']'
op|'['
string|"'spice'"
op|']'
op|'='
name|'CONF'
op|'.'
name|'spice'
op|'.'
name|'server_listen'
newline|'\n'
nl|'\n'
name|'return'
name|'res_data'
newline|'\n'
nl|'\n'
DECL|member|_create_images_and_backing
dedent|''
name|'def'
name|'_create_images_and_backing'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'instance_dir'
op|','
nl|'\n'
name|'disk_info_json'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'""":param context: security context\n           :param instance:\n               nova.db.sqlalchemy.models.Instance object\n               instance object that is migrated.\n           :param instance_dir:\n               instance path to use, calculated externally to handle block\n               migrating an instance with an old style instance path\n           :param disk_info_json:\n               json strings specified in get_instance_disk_info\n\n        """'
newline|'\n'
name|'if'
name|'not'
name|'disk_info_json'
op|':'
newline|'\n'
indent|'            '
name|'disk_info'
op|'='
op|'['
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'disk_info'
op|'='
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'disk_info_json'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'info'
name|'in'
name|'disk_info'
op|':'
newline|'\n'
indent|'            '
name|'base'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'info'
op|'['
string|"'path'"
op|']'
op|')'
newline|'\n'
comment|'# Get image type and create empty disk image, and'
nl|'\n'
comment|'# create backing file in case of qcow2.'
nl|'\n'
name|'instance_disk'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'instance_dir'
op|','
name|'base'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'info'
op|'['
string|"'backing_file'"
op|']'
name|'and'
name|'not'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'instance_disk'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'libvirt_utils'
op|'.'
name|'create_image'
op|'('
name|'info'
op|'['
string|"'type'"
op|']'
op|','
name|'instance_disk'
op|','
nl|'\n'
name|'info'
op|'['
string|"'virt_disk_size'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'info'
op|'['
string|"'backing_file'"
op|']'
op|':'
newline|'\n'
comment|'# Creating backing file follows same way as spawning instances.'
nl|'\n'
indent|'                '
name|'cache_name'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'info'
op|'['
string|"'backing_file'"
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'image'
op|'='
name|'self'
op|'.'
name|'image_backend'
op|'.'
name|'image'
op|'('
name|'instance'
op|','
nl|'\n'
name|'instance_disk'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_type'
op|')'
newline|'\n'
name|'if'
name|'cache_name'
op|'.'
name|'startswith'
op|'('
string|"'ephemeral'"
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'image'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'self'
op|'.'
name|'_create_ephemeral'
op|','
nl|'\n'
name|'fs_label'
op|'='
name|'cache_name'
op|','
nl|'\n'
name|'os_type'
op|'='
name|'instance'
op|'['
string|'"os_type"'
op|']'
op|','
nl|'\n'
name|'filename'
op|'='
name|'cache_name'
op|','
nl|'\n'
name|'size'
op|'='
name|'info'
op|'['
string|"'virt_disk_size'"
op|']'
op|','
nl|'\n'
name|'ephemeral_size'
op|'='
name|'instance'
op|'['
string|"'ephemeral_gb'"
op|']'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'cache_name'
op|'.'
name|'startswith'
op|'('
string|"'swap'"
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'inst_type'
op|'='
name|'flavors'
op|'.'
name|'extract_flavor'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'swap_mb'
op|'='
name|'inst_type'
op|'['
string|"'swap'"
op|']'
newline|'\n'
name|'image'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'self'
op|'.'
name|'_create_swap'
op|','
nl|'\n'
name|'filename'
op|'='
string|'"swap_%s"'
op|'%'
name|'swap_mb'
op|','
nl|'\n'
name|'size'
op|'='
name|'swap_mb'
op|'*'
name|'units'
op|'.'
name|'Mi'
op|','
nl|'\n'
name|'swap_mb'
op|'='
name|'swap_mb'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'image'
op|'.'
name|'cache'
op|'('
name|'fetch_func'
op|'='
name|'libvirt_utils'
op|'.'
name|'fetch_image'
op|','
nl|'\n'
name|'context'
op|'='
name|'context'
op|','
nl|'\n'
name|'filename'
op|'='
name|'cache_name'
op|','
nl|'\n'
name|'image_id'
op|'='
name|'instance'
op|'['
string|"'image_ref'"
op|']'
op|','
nl|'\n'
name|'user_id'
op|'='
name|'instance'
op|'['
string|"'user_id'"
op|']'
op|','
nl|'\n'
name|'project_id'
op|'='
name|'instance'
op|'['
string|"'project_id'"
op|']'
op|','
nl|'\n'
name|'size'
op|'='
name|'info'
op|'['
string|"'virt_disk_size'"
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# if image has kernel and ramdisk, just download'
nl|'\n'
comment|'# following normal way.'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'self'
op|'.'
name|'_fetch_instance_kernel_ramdisk'
op|'('
name|'context'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|post_live_migration
dedent|''
name|'def'
name|'post_live_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'block_device_info'
op|','
nl|'\n'
name|'migrate_data'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
comment|'# Disconnect from volume server'
nl|'\n'
indent|'        '
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'for'
name|'vol'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'            '
name|'connection_info'
op|'='
name|'vol'
op|'['
string|"'connection_info'"
op|']'
newline|'\n'
name|'disk_dev'
op|'='
name|'vol'
op|'['
string|"'mount_device'"
op|']'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_disconnect_volume'
op|'('
name|'connection_info'
op|','
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
DECL|member|post_live_migration_at_source
dedent|''
dedent|''
name|'def'
name|'post_live_migration_at_source'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Unplug VIFs from networks at source.\n\n        :param context: security context\n        :param instance: instance object reference\n        :param network_info: instance network information\n        """'
newline|'\n'
name|'self'
op|'.'
name|'unplug_vifs'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|post_live_migration_at_destination
dedent|''
name|'def'
name|'post_live_migration_at_destination'
op|'('
name|'self'
op|','
name|'context'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|','
nl|'\n'
name|'block_migration'
op|'='
name|'False'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Post operation of live migration at destination host.\n\n        :param context: security context\n        :param instance:\n            nova.db.sqlalchemy.models.Instance object\n            instance object that is migrated.\n        :param network_info: instance network information\n        :param block_migration: if true, post operation of block_migration.\n        """'
newline|'\n'
comment|'# Define migrated instance, otherwise, suspend/destroy does not work.'
nl|'\n'
name|'dom_list'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'listDefinedDomains'
op|'('
op|')'
newline|'\n'
name|'if'
name|'instance'
op|'['
string|'"name"'
op|']'
name|'not'
name|'in'
name|'dom_list'
op|':'
newline|'\n'
comment|'# In case of block migration, destination does not have'
nl|'\n'
comment|'# libvirt.xml'
nl|'\n'
indent|'            '
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
name|'instance'
op|','
name|'block_device_info'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_guest_xml'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|','
nl|'\n'
name|'write_to_disk'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'defineXML'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_instance_disk_info
dedent|''
dedent|''
name|'def'
name|'_get_instance_disk_info'
op|'('
name|'self'
op|','
name|'instance_name'
op|','
name|'xml'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
name|'volume_devices'
op|'='
name|'set'
op|'('
op|')'
newline|'\n'
name|'for'
name|'vol'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'            '
name|'disk_dev'
op|'='
name|'vol'
op|'['
string|"'mount_device'"
op|']'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'volume_devices'
op|'.'
name|'add'
op|'('
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'disk_info'
op|'='
op|'['
op|']'
newline|'\n'
name|'doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
name|'disk_nodes'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
string|"'.//devices/disk'"
op|')'
newline|'\n'
name|'path_nodes'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
string|"'.//devices/disk/source'"
op|')'
newline|'\n'
name|'driver_nodes'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
string|"'.//devices/disk/driver'"
op|')'
newline|'\n'
name|'target_nodes'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
string|"'.//devices/disk/target'"
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'cnt'
op|','
name|'path_node'
name|'in'
name|'enumerate'
op|'('
name|'path_nodes'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'disk_type'
op|'='
name|'disk_nodes'
op|'['
name|'cnt'
op|']'
op|'.'
name|'get'
op|'('
string|"'type'"
op|')'
newline|'\n'
name|'path'
op|'='
name|'path_node'
op|'.'
name|'get'
op|'('
string|"'file'"
op|')'
name|'or'
name|'path_node'
op|'.'
name|'get'
op|'('
string|"'dev'"
op|')'
newline|'\n'
name|'target'
op|'='
name|'target_nodes'
op|'['
name|'cnt'
op|']'
op|'.'
name|'attrib'
op|'['
string|"'dev'"
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'path'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'skipping disk for %s as it does not have a path'"
op|','
nl|'\n'
name|'instance_name'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'disk_type'
name|'not'
name|'in'
op|'['
string|"'file'"
op|','
string|"'block'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'skipping disk because it looks like a volume'"
op|','
name|'path'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'target'
name|'in'
name|'volume_devices'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'skipping disk %(path)s (%(target)s) as it is a '"
nl|'\n'
string|"'volume'"
op|','
op|'{'
string|"'path'"
op|':'
name|'path'
op|','
string|"'target'"
op|':'
name|'target'
op|'}'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
nl|'\n'
comment|'# get the real disk size or'
nl|'\n'
comment|'# raise a localized error if image is unavailable'
nl|'\n'
dedent|''
name|'if'
name|'disk_type'
op|'=='
string|"'file'"
op|':'
newline|'\n'
indent|'                '
name|'dk_size'
op|'='
name|'int'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'getsize'
op|'('
name|'path'
op|')'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'disk_type'
op|'=='
string|"'block'"
op|':'
newline|'\n'
indent|'                '
name|'dk_size'
op|'='
name|'lvm'
op|'.'
name|'get_volume_size'
op|'('
name|'path'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'disk_type'
op|'='
name|'driver_nodes'
op|'['
name|'cnt'
op|']'
op|'.'
name|'get'
op|'('
string|"'type'"
op|')'
newline|'\n'
name|'if'
name|'disk_type'
op|'=='
string|'"qcow2"'
op|':'
newline|'\n'
indent|'                '
name|'backing_file'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_disk_backing_file'
op|'('
name|'path'
op|')'
newline|'\n'
name|'virt_size'
op|'='
name|'disk'
op|'.'
name|'get_disk_size'
op|'('
name|'path'
op|')'
newline|'\n'
name|'over_commit_size'
op|'='
name|'int'
op|'('
name|'virt_size'
op|')'
op|'-'
name|'dk_size'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'backing_file'
op|'='
string|'""'
newline|'\n'
name|'virt_size'
op|'='
name|'dk_size'
newline|'\n'
name|'over_commit_size'
op|'='
number|'0'
newline|'\n'
nl|'\n'
dedent|''
name|'disk_info'
op|'.'
name|'append'
op|'('
op|'{'
string|"'type'"
op|':'
name|'disk_type'
op|','
nl|'\n'
string|"'path'"
op|':'
name|'path'
op|','
nl|'\n'
string|"'virt_disk_size'"
op|':'
name|'virt_size'
op|','
nl|'\n'
string|"'backing_file'"
op|':'
name|'backing_file'
op|','
nl|'\n'
string|"'disk_size'"
op|':'
name|'dk_size'
op|','
nl|'\n'
string|"'over_committed_disk_size'"
op|':'
name|'over_commit_size'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'jsonutils'
op|'.'
name|'dumps'
op|'('
name|'disk_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_instance_disk_info
dedent|''
name|'def'
name|'get_instance_disk_info'
op|'('
name|'self'
op|','
name|'instance_name'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'dom'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance_name'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|"'Error from libvirt while getting description of '"
nl|'\n'
string|"'%(instance_name)s: [Error Code %(error_code)s] '"
nl|'\n'
string|"'%(ex)s'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'instance_name'"
op|':'
name|'instance_name'
op|','
nl|'\n'
string|"'error_code'"
op|':'
name|'error_code'
op|','
nl|'\n'
string|"'ex'"
op|':'
name|'ex'
op|'}'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'msg'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|'('
name|'instance_id'
op|'='
name|'instance_name'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_get_instance_disk_info'
op|'('
name|'instance_name'
op|','
name|'xml'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_disk_over_committed_size_total
dedent|''
name|'def'
name|'_get_disk_over_committed_size_total'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return total over committed disk size for all instances."""'
newline|'\n'
comment|'# Disk size that all instance uses : virtual_size - disk_size'
nl|'\n'
name|'disk_over_committed_size'
op|'='
number|'0'
newline|'\n'
name|'for'
name|'dom'
name|'in'
name|'self'
op|'.'
name|'_list_instance_domains'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'xml'
op|'='
name|'dom'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
name|'disk_infos'
op|'='
name|'jsonutils'
op|'.'
name|'loads'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_get_instance_disk_info'
op|'('
name|'dom'
op|'.'
name|'name'
op|'('
op|')'
op|','
name|'xml'
op|')'
op|')'
newline|'\n'
name|'for'
name|'info'
name|'in'
name|'disk_infos'
op|':'
newline|'\n'
indent|'                    '
name|'disk_over_committed_size'
op|'+='
name|'int'
op|'('
nl|'\n'
name|'info'
op|'['
string|"'over_committed_disk_size'"
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'                '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
nl|'\n'
string|"'Error from libvirt while getting description of '"
nl|'\n'
string|"'%(instance_name)s: [Error Code %(error_code)s] %(ex)s'"
nl|'\n'
op|')'
op|'%'
op|'{'
string|"'instance_name'"
op|':'
name|'dom'
op|'.'
name|'name'
op|'('
op|')'
op|','
nl|'\n'
string|"'error_code'"
op|':'
name|'error_code'
op|','
nl|'\n'
string|"'ex'"
op|':'
name|'ex'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'Periodic task is updating the host stat, '"
nl|'\n'
string|"'it is trying to get disk %(i_name)s, '"
nl|'\n'
string|"'but disk file was removed by concurrent '"
nl|'\n'
string|"'operations such as resize.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'i_name'"
op|':'
name|'dom'
op|'.'
name|'name'
op|'('
op|')'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'e'
op|'.'
name|'errno'
op|'=='
name|'errno'
op|'.'
name|'EACCES'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'Periodic task is updating the host stat, '"
nl|'\n'
string|"'it is trying to get disk %(i_name)s, '"
nl|'\n'
string|"'but access is denied. It is most likely '"
nl|'\n'
string|"'due to a VM that exists on the compute '"
nl|'\n'
string|"'node but is not managed by Nova.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'i_name'"
op|':'
name|'dom'
op|'.'
name|'name'
op|'('
op|')'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'exception'
op|'.'
name|'VolumeBDMPathNotFound'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|"'Periodic task is updating the host stats, '"
nl|'\n'
string|"'it is trying to get disk info for %(i_name)s, '"
nl|'\n'
string|"'but the backing volume block device was removed '"
nl|'\n'
string|"'by concurrent operations such as resize. '"
nl|'\n'
string|"'Error: %(error)s'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'i_name'"
op|':'
name|'dom'
op|'.'
name|'name'
op|'('
op|')'
op|','
nl|'\n'
string|"'error'"
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
comment|'# NOTE(gtt116): give other tasks a chance.'
nl|'\n'
dedent|''
name|'greenthread'
op|'.'
name|'sleep'
op|'('
number|'0'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'disk_over_committed_size'
newline|'\n'
nl|'\n'
DECL|member|unfilter_instance
dedent|''
name|'def'
name|'unfilter_instance'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""See comments of same method in firewall_driver."""'
newline|'\n'
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'unfilter_instance'
op|'('
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|'='
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_available_nodes
dedent|''
name|'def'
name|'get_available_nodes'
op|'('
name|'self'
op|','
name|'refresh'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'['
name|'self'
op|'.'
name|'_get_hypervisor_hostname'
op|'('
op|')'
op|']'
newline|'\n'
nl|'\n'
DECL|member|get_host_cpu_stats
dedent|''
name|'def'
name|'get_host_cpu_stats'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the current CPU state of the host."""'
newline|'\n'
comment|"# Extract node's CPU statistics."
nl|'\n'
name|'stats'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'getCPUStats'
op|'('
name|'libvirt'
op|'.'
name|'VIR_NODE_CPU_STATS_ALL_CPUS'
op|','
number|'0'
op|')'
newline|'\n'
comment|'# getInfo() returns various information about the host node'
nl|'\n'
comment|'# No. 3 is the expected CPU frequency.'
nl|'\n'
name|'stats'
op|'['
string|'"frequency"'
op|']'
op|'='
name|'self'
op|'.'
name|'_conn'
op|'.'
name|'getInfo'
op|'('
op|')'
op|'['
number|'3'
op|']'
newline|'\n'
name|'return'
name|'stats'
newline|'\n'
nl|'\n'
DECL|member|get_host_uptime
dedent|''
name|'def'
name|'get_host_uptime'
op|'('
name|'self'
op|','
name|'host'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns the result of calling "uptime"."""'
newline|'\n'
comment|'# NOTE(dprince): host seems to be ignored for this call and in'
nl|'\n'
comment|'# other compute drivers as well. Perhaps we should remove it?'
nl|'\n'
name|'out'
op|','
name|'err'
op|'='
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'env'"
op|','
string|"'LANG=C'"
op|','
string|"'uptime'"
op|')'
newline|'\n'
name|'return'
name|'out'
newline|'\n'
nl|'\n'
DECL|member|manage_image_cache
dedent|''
name|'def'
name|'manage_image_cache'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'all_instances'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Manage the local cache of images."""'
newline|'\n'
name|'self'
op|'.'
name|'image_cache_manager'
op|'.'
name|'update'
op|'('
name|'context'
op|','
name|'all_instances'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_cleanup_remote_migration
dedent|''
name|'def'
name|'_cleanup_remote_migration'
op|'('
name|'self'
op|','
name|'dest'
op|','
name|'inst_base'
op|','
name|'inst_base_resize'
op|','
nl|'\n'
name|'shared_storage'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Used only for cleanup in case migrate_disk_and_power_off fails."""'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'inst_base_resize'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'rm'"
op|','
string|"'-rf'"
op|','
name|'inst_base'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'inst_base_resize'
op|','
name|'inst_base'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'shared_storage'
op|':'
newline|'\n'
indent|'                    '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'ssh'"
op|','
name|'dest'
op|','
string|"'rm'"
op|','
string|"'-rf'"
op|','
name|'inst_base'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|_is_storage_shared_with
dedent|''
dedent|''
name|'def'
name|'_is_storage_shared_with'
op|'('
name|'self'
op|','
name|'dest'
op|','
name|'inst_base'
op|')'
op|':'
newline|'\n'
comment|'# NOTE (rmk): There are two methods of determining whether we are'
nl|'\n'
comment|'#             on the same filesystem: the source and dest IP are the'
nl|'\n'
comment|'#             same, or we create a file on the dest system via SSH'
nl|'\n'
comment|'#             and check whether the source system can also see it.'
nl|'\n'
indent|'        '
name|'shared_storage'
op|'='
op|'('
name|'dest'
op|'=='
name|'self'
op|'.'
name|'get_host_ip_addr'
op|'('
op|')'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'shared_storage'
op|':'
newline|'\n'
indent|'            '
name|'tmp_file'
op|'='
name|'uuid'
op|'.'
name|'uuid4'
op|'('
op|')'
op|'.'
name|'hex'
op|'+'
string|"'.tmp'"
newline|'\n'
name|'tmp_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_base'
op|','
name|'tmp_file'
op|')'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'ssh'"
op|','
name|'dest'
op|','
string|"'touch'"
op|','
name|'tmp_path'
op|')'
newline|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'tmp_path'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'shared_storage'
op|'='
name|'True'
newline|'\n'
name|'os'
op|'.'
name|'unlink'
op|'('
name|'tmp_path'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'ssh'"
op|','
name|'dest'
op|','
string|"'rm'"
op|','
name|'tmp_path'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'shared_storage'
newline|'\n'
nl|'\n'
DECL|member|migrate_disk_and_power_off
dedent|''
name|'def'
name|'migrate_disk_and_power_off'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
nl|'\n'
name|'flavor'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
nl|'\n'
name|'timeout'
op|'='
number|'0'
op|','
name|'retry_interval'
op|'='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Starting migrate_disk_and_power_off"'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# Checks if the migration needs a disk resize down.'
nl|'\n'
name|'for'
name|'kind'
name|'in'
op|'('
string|"'root_gb'"
op|','
string|"'ephemeral_gb'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'flavor'
op|'['
name|'kind'
op|']'
op|'<'
name|'instance'
op|'['
name|'kind'
op|']'
op|':'
newline|'\n'
indent|'                '
name|'reason'
op|'='
name|'_'
op|'('
string|'"Unable to resize disk down."'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstanceFaultRollback'
op|'('
nl|'\n'
name|'exception'
op|'.'
name|'ResizeError'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'disk_info_text'
op|'='
name|'self'
op|'.'
name|'get_instance_disk_info'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|')'
newline|'\n'
name|'disk_info'
op|'='
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'disk_info_text'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(dgenin): Migration is not implemented for LVM backed instances.'
nl|'\n'
name|'if'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'images_type'
op|'=='
string|"'lvm'"
name|'and'
nl|'\n'
name|'not'
name|'self'
op|'.'
name|'_is_booted_from_volume'
op|'('
name|'instance'
op|','
name|'disk_info_text'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
string|'"Migration is not supported for LVM backed instances"'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'MigrationPreCheckError'
op|'('
name|'reason'
op|')'
newline|'\n'
nl|'\n'
comment|'# copy disks to destination'
nl|'\n'
comment|'# rename instance dir to +_resize at first for using'
nl|'\n'
comment|'# shared storage for instance dir (eg. NFS).'
nl|'\n'
dedent|''
name|'inst_base'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'inst_base_resize'
op|'='
name|'inst_base'
op|'+'
string|'"_resize"'
newline|'\n'
name|'shared_storage'
op|'='
name|'self'
op|'.'
name|'_is_storage_shared_with'
op|'('
name|'dest'
op|','
name|'inst_base'
op|')'
newline|'\n'
nl|'\n'
comment|'# try to create the directory on the remote compute node'
nl|'\n'
comment|'# if this fails we pass the exception up the stack so we can catch'
nl|'\n'
comment|'# failures here earlier'
nl|'\n'
name|'if'
name|'not'
name|'shared_storage'
op|':'
newline|'\n'
indent|'            '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'ssh'"
op|','
name|'dest'
op|','
string|"'mkdir'"
op|','
string|"'-p'"
op|','
name|'inst_base'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'power_off'
op|'('
name|'instance'
op|','
name|'timeout'
op|','
name|'retry_interval'
op|')'
newline|'\n'
nl|'\n'
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'for'
name|'vol'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'            '
name|'connection_info'
op|'='
name|'vol'
op|'['
string|"'connection_info'"
op|']'
newline|'\n'
name|'disk_dev'
op|'='
name|'vol'
op|'['
string|"'mount_device'"
op|']'
op|'.'
name|'rpartition'
op|'('
string|'"/"'
op|')'
op|'['
number|'2'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_disconnect_volume'
op|'('
name|'connection_info'
op|','
name|'disk_dev'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'inst_base'
op|','
name|'inst_base_resize'
op|')'
newline|'\n'
comment|'# if we are migrating the instance with shared storage then'
nl|'\n'
comment|'# create the directory.  If it is a remote node the directory'
nl|'\n'
comment|'# has already been created'
nl|'\n'
name|'if'
name|'shared_storage'
op|':'
newline|'\n'
indent|'                '
name|'dest'
op|'='
name|'None'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mkdir'"
op|','
string|"'-p'"
op|','
name|'inst_base'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'active_flavor'
op|'='
name|'flavors'
op|'.'
name|'extract_flavor'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'for'
name|'info'
name|'in'
name|'disk_info'
op|':'
newline|'\n'
comment|"# assume inst_base == dirname(info['path'])"
nl|'\n'
indent|'                '
name|'img_path'
op|'='
name|'info'
op|'['
string|"'path'"
op|']'
newline|'\n'
name|'fname'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'img_path'
op|')'
newline|'\n'
name|'from_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'inst_base_resize'
op|','
name|'fname'
op|')'
newline|'\n'
nl|'\n'
name|'if'
op|'('
name|'fname'
op|'=='
string|"'disk.swap'"
name|'and'
nl|'\n'
name|'active_flavor'
op|'.'
name|'get'
op|'('
string|"'swap'"
op|','
number|'0'
op|')'
op|'!='
name|'flavor'
op|'.'
name|'get'
op|'('
string|"'swap'"
op|','
number|'0'
op|')'
op|')'
op|':'
newline|'\n'
comment|'# To properly resize the swap partition, it must be'
nl|'\n'
comment|'# re-created with the proper size.  This is acceptable'
nl|'\n'
comment|'# because when an OS is shut down, the contents of the'
nl|'\n'
comment|"# swap space are just garbage, the OS doesn't bother about"
nl|'\n'
comment|'# what is in it.'
nl|'\n'
nl|'\n'
comment|'# We will not copy over the swap disk here, and rely on'
nl|'\n'
comment|'# finish_migration/_create_image to re-create it for us.'
nl|'\n'
indent|'                    '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'info'
op|'['
string|"'type'"
op|']'
op|'=='
string|"'qcow2'"
name|'and'
name|'info'
op|'['
string|"'backing_file'"
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'tmp_path'
op|'='
name|'from_path'
op|'+'
string|'"_rbase"'
newline|'\n'
comment|'# merge backing file'
nl|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'qemu-img'"
op|','
string|"'convert'"
op|','
string|"'-f'"
op|','
string|"'qcow2'"
op|','
nl|'\n'
string|"'-O'"
op|','
string|"'qcow2'"
op|','
name|'from_path'
op|','
name|'tmp_path'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'shared_storage'
op|':'
newline|'\n'
indent|'                        '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'tmp_path'
op|','
name|'img_path'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'libvirt_utils'
op|'.'
name|'copy_image'
op|'('
name|'tmp_path'
op|','
name|'img_path'
op|','
name|'host'
op|'='
name|'dest'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'rm'"
op|','
string|"'-f'"
op|','
name|'tmp_path'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'else'
op|':'
comment|'# raw or qcow2 with no backing file'
newline|'\n'
indent|'                    '
name|'libvirt_utils'
op|'.'
name|'copy_image'
op|'('
name|'from_path'
op|','
name|'img_path'
op|','
name|'host'
op|'='
name|'dest'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_cleanup_remote_migration'
op|'('
name|'dest'
op|','
name|'inst_base'
op|','
nl|'\n'
name|'inst_base_resize'
op|','
nl|'\n'
name|'shared_storage'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'disk_info_text'
newline|'\n'
nl|'\n'
DECL|member|_wait_for_running
dedent|''
name|'def'
name|'_wait_for_running'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'state'
op|'='
name|'self'
op|'.'
name|'get_info'
op|'('
name|'instance'
op|')'
op|'['
string|"'state'"
op|']'
newline|'\n'
nl|'\n'
name|'if'
name|'state'
op|'=='
name|'power_state'
op|'.'
name|'RUNNING'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Instance running successfully."'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'raise'
name|'loopingcall'
op|'.'
name|'LoopingCallDone'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_disk_size_from_instance
name|'def'
name|'_disk_size_from_instance'
op|'('
name|'instance'
op|','
name|'info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Determines the disk size from instance properties\n\n        Returns the disk size by using the disk name to determine whether it\n        is a root or an ephemeral disk, then by checking properties of the\n        instance returns the size converted to bytes.\n\n        Returns 0 if the disk name not match (disk, disk.local).\n        """'
newline|'\n'
name|'fname'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'info'
op|'['
string|"'path'"
op|']'
op|')'
newline|'\n'
name|'if'
name|'fname'
op|'=='
string|"'disk'"
op|':'
newline|'\n'
indent|'            '
name|'size'
op|'='
name|'instance'
op|'['
string|"'root_gb'"
op|']'
newline|'\n'
dedent|''
name|'elif'
name|'fname'
op|'=='
string|"'disk.local'"
op|':'
newline|'\n'
indent|'            '
name|'size'
op|'='
name|'instance'
op|'['
string|"'ephemeral_gb'"
op|']'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'size'
op|'='
number|'0'
newline|'\n'
dedent|''
name|'return'
name|'size'
op|'*'
name|'units'
op|'.'
name|'Gi'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_disk_raw_to_qcow2
name|'def'
name|'_disk_raw_to_qcow2'
op|'('
name|'path'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Converts a raw disk to qcow2."""'
newline|'\n'
name|'path_qcow'
op|'='
name|'path'
op|'+'
string|"'_qcow'"
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'qemu-img'"
op|','
string|"'convert'"
op|','
string|"'-f'"
op|','
string|"'raw'"
op|','
nl|'\n'
string|"'-O'"
op|','
string|"'qcow2'"
op|','
name|'path'
op|','
name|'path_qcow'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'path_qcow'
op|','
name|'path'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_disk_qcow2_to_raw
name|'def'
name|'_disk_qcow2_to_raw'
op|'('
name|'path'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Converts a qcow2 disk to raw."""'
newline|'\n'
name|'path_raw'
op|'='
name|'path'
op|'+'
string|"'_raw'"
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'qemu-img'"
op|','
string|"'convert'"
op|','
string|"'-f'"
op|','
string|"'qcow2'"
op|','
nl|'\n'
string|"'-O'"
op|','
string|"'raw'"
op|','
name|'path'
op|','
name|'path_raw'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'path_raw'
op|','
name|'path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_disk_resize
dedent|''
name|'def'
name|'_disk_resize'
op|'('
name|'self'
op|','
name|'info'
op|','
name|'size'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Attempts to resize a disk to size\n\n        Attempts to resize a disk by checking the capabilities and\n        preparing the format, then calling disk.api.extend.\n\n        Note: Currently only support disk extend.\n        """'
newline|'\n'
comment|'# If we have a non partitioned image that we can extend'
nl|'\n'
comment|"# then ensure we're in 'raw' format so we can extend file system."
nl|'\n'
name|'fmt'
op|','
name|'org'
op|'='
op|'['
name|'info'
op|'['
string|"'type'"
op|']'
op|']'
op|'*'
number|'2'
newline|'\n'
name|'pth'
op|'='
name|'info'
op|'['
string|"'path'"
op|']'
newline|'\n'
name|'if'
op|'('
name|'size'
name|'and'
name|'fmt'
op|'=='
string|"'qcow2'"
name|'and'
nl|'\n'
name|'disk'
op|'.'
name|'can_resize_image'
op|'('
name|'pth'
op|','
name|'size'
op|')'
name|'and'
nl|'\n'
name|'disk'
op|'.'
name|'is_image_partitionless'
op|'('
name|'pth'
op|','
name|'use_cow'
op|'='
name|'True'
op|')'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_disk_qcow2_to_raw'
op|'('
name|'pth'
op|')'
newline|'\n'
name|'fmt'
op|'='
string|"'raw'"
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'size'
op|':'
newline|'\n'
indent|'            '
name|'use_cow'
op|'='
name|'fmt'
op|'=='
string|"'qcow2'"
newline|'\n'
name|'disk'
op|'.'
name|'extend'
op|'('
name|'pth'
op|','
name|'size'
op|','
name|'use_cow'
op|'='
name|'use_cow'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'fmt'
op|'!='
name|'org'
op|':'
newline|'\n'
comment|'# back to qcow2 (no backing_file though) so that snapshot'
nl|'\n'
comment|'# will be available'
nl|'\n'
indent|'            '
name|'self'
op|'.'
name|'_disk_raw_to_qcow2'
op|'('
name|'pth'
op|')'
newline|'\n'
nl|'\n'
DECL|member|finish_migration
dedent|''
dedent|''
name|'def'
name|'finish_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'migration'
op|','
name|'instance'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'network_info'
op|','
name|'image_meta'
op|','
name|'resize_instance'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'power_on'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Starting finish_migration"'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# resize disks. only "disk" and "disk.local" are necessary.'
nl|'\n'
name|'disk_info'
op|'='
name|'jsonutils'
op|'.'
name|'loads'
op|'('
name|'disk_info'
op|')'
newline|'\n'
name|'for'
name|'info'
name|'in'
name|'disk_info'
op|':'
newline|'\n'
indent|'            '
name|'size'
op|'='
name|'self'
op|'.'
name|'_disk_size_from_instance'
op|'('
name|'instance'
op|','
name|'info'
op|')'
newline|'\n'
name|'if'
name|'resize_instance'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_disk_resize'
op|'('
name|'info'
op|','
name|'size'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'info'
op|'['
string|"'type'"
op|']'
op|'=='
string|"'raw'"
name|'and'
name|'CONF'
op|'.'
name|'use_cow_images'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_disk_raw_to_qcow2'
op|'('
name|'info'
op|'['
string|"'path'"
op|']'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'block_device_info'
op|','
nl|'\n'
name|'image_meta'
op|')'
newline|'\n'
comment|'# assume _create_image do nothing if a target file exists.'
nl|'\n'
name|'self'
op|'.'
name|'_create_image'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'disk_info'
op|'['
string|"'mapping'"
op|']'
op|','
nl|'\n'
name|'network_info'
op|'='
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'inject_files'
op|'='
name|'False'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_guest_xml'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|','
nl|'\n'
name|'write_to_disk'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_domain_and_network'
op|'('
name|'context'
op|','
name|'xml'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|','
name|'power_on'
op|','
nl|'\n'
name|'vifs_already_plugged'
op|'='
name|'True'
op|')'
newline|'\n'
name|'if'
name|'power_on'
op|':'
newline|'\n'
indent|'            '
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_wait_for_running'
op|','
nl|'\n'
name|'instance'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_cleanup_failed_migration
dedent|''
dedent|''
name|'def'
name|'_cleanup_failed_migration'
op|'('
name|'self'
op|','
name|'inst_base'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Make sure that a failed migrate doesn\'t prevent us from rolling\n        back in a revert.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'shutil'
op|'.'
name|'rmtree'
op|'('
name|'inst_base'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'e'
op|'.'
name|'errno'
op|'!='
name|'errno'
op|'.'
name|'ENOENT'
op|':'
newline|'\n'
indent|'                '
name|'raise'
newline|'\n'
nl|'\n'
DECL|member|finish_revert_migration
dedent|''
dedent|''
dedent|''
name|'def'
name|'finish_revert_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'power_on'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Starting finish_revert_migration"'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'inst_base'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'inst_base_resize'
op|'='
name|'inst_base'
op|'+'
string|'"_resize"'
newline|'\n'
nl|'\n'
comment|"# NOTE(danms): if we're recovering from a failed migration,"
nl|'\n'
comment|"# make sure we don't have a left-over same-host base directory"
nl|'\n'
comment|"# that would conflict. Also, don't fail on the rename if the"
nl|'\n'
comment|'# failure happened early.'
nl|'\n'
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'inst_base_resize'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_cleanup_failed_migration'
op|'('
name|'inst_base'
op|')'
newline|'\n'
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'inst_base_resize'
op|','
name|'inst_base'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'disk_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_info'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'self'
op|'.'
name|'_get_guest_xml'
op|'('
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'block_device_info'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_create_domain_and_network'
op|'('
name|'context'
op|','
name|'xml'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|','
name|'power_on'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'power_on'
op|':'
newline|'\n'
indent|'            '
name|'timer'
op|'='
name|'loopingcall'
op|'.'
name|'FixedIntervalLoopingCall'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_wait_for_running'
op|','
nl|'\n'
name|'instance'
op|')'
newline|'\n'
name|'timer'
op|'.'
name|'start'
op|'('
name|'interval'
op|'='
number|'0.5'
op|')'
op|'.'
name|'wait'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|confirm_migration
dedent|''
dedent|''
name|'def'
name|'confirm_migration'
op|'('
name|'self'
op|','
name|'migration'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Confirms a resize, destroying the source VM."""'
newline|'\n'
name|'self'
op|'.'
name|'_cleanup_resize'
op|'('
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_get_io_devices
name|'def'
name|'_get_io_devices'
op|'('
name|'xml_doc'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""get the list of io devices from the xml document."""'
newline|'\n'
name|'result'
op|'='
op|'{'
string|'"volumes"'
op|':'
op|'['
op|']'
op|','
string|'"ifaces"'
op|':'
op|'['
op|']'
op|'}'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml_doc'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'result'
newline|'\n'
dedent|''
name|'blocks'
op|'='
op|'['
op|'('
string|"'./devices/disk'"
op|','
string|"'volumes'"
op|')'
op|','
nl|'\n'
op|'('
string|"'./devices/interface'"
op|','
string|"'ifaces'"
op|')'
op|']'
newline|'\n'
name|'for'
name|'block'
op|','
name|'key'
name|'in'
name|'blocks'
op|':'
newline|'\n'
indent|'            '
name|'section'
op|'='
name|'doc'
op|'.'
name|'findall'
op|'('
name|'block'
op|')'
newline|'\n'
name|'for'
name|'node'
name|'in'
name|'section'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'child'
name|'in'
name|'node'
op|'.'
name|'getchildren'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'child'
op|'.'
name|'tag'
op|'=='
string|"'target'"
name|'and'
name|'child'
op|'.'
name|'get'
op|'('
string|"'dev'"
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'result'
op|'['
name|'key'
op|']'
op|'.'
name|'append'
op|'('
name|'child'
op|'.'
name|'get'
op|'('
string|"'dev'"
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'return'
name|'result'
newline|'\n'
nl|'\n'
DECL|member|get_diagnostics
dedent|''
name|'def'
name|'get_diagnostics'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'domain'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'output'
op|'='
op|'{'
op|'}'
newline|'\n'
comment|'# get cpu time, might launch an exception if the method'
nl|'\n'
comment|'# is not supported by the underlying hypervisor being'
nl|'\n'
comment|'# used by libvirt'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'cputime'
op|'='
name|'domain'
op|'.'
name|'vcpus'
op|'('
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'len'
op|'('
name|'cputime'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'output'
op|'['
string|'"cpu"'
op|'+'
name|'str'
op|'('
name|'i'
op|')'
op|'+'
string|'"_time"'
op|']'
op|'='
name|'cputime'
op|'['
name|'i'
op|']'
op|'['
number|'2'
op|']'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
comment|'# get io status'
nl|'\n'
dedent|''
name|'xml'
op|'='
name|'domain'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
name|'dom_io'
op|'='
name|'LibvirtDriver'
op|'.'
name|'_get_io_devices'
op|'('
name|'xml'
op|')'
newline|'\n'
name|'for'
name|'guest_disk'
name|'in'
name|'dom_io'
op|'['
string|'"volumes"'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
comment|'# blockStats might launch an exception if the method'
nl|'\n'
comment|'# is not supported by the underlying hypervisor being'
nl|'\n'
comment|'# used by libvirt'
nl|'\n'
indent|'                '
name|'stats'
op|'='
name|'domain'
op|'.'
name|'blockStats'
op|'('
name|'guest_disk'
op|')'
newline|'\n'
name|'output'
op|'['
name|'guest_disk'
op|'+'
string|'"_read_req"'
op|']'
op|'='
name|'stats'
op|'['
number|'0'
op|']'
newline|'\n'
name|'output'
op|'['
name|'guest_disk'
op|'+'
string|'"_read"'
op|']'
op|'='
name|'stats'
op|'['
number|'1'
op|']'
newline|'\n'
name|'output'
op|'['
name|'guest_disk'
op|'+'
string|'"_write_req"'
op|']'
op|'='
name|'stats'
op|'['
number|'2'
op|']'
newline|'\n'
name|'output'
op|'['
name|'guest_disk'
op|'+'
string|'"_write"'
op|']'
op|'='
name|'stats'
op|'['
number|'3'
op|']'
newline|'\n'
name|'output'
op|'['
name|'guest_disk'
op|'+'
string|'"_errors"'
op|']'
op|'='
name|'stats'
op|'['
number|'4'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'for'
name|'interface'
name|'in'
name|'dom_io'
op|'['
string|'"ifaces"'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
comment|'# interfaceStats might launch an exception if the method'
nl|'\n'
comment|'# is not supported by the underlying hypervisor being'
nl|'\n'
comment|'# used by libvirt'
nl|'\n'
indent|'                '
name|'stats'
op|'='
name|'domain'
op|'.'
name|'interfaceStats'
op|'('
name|'interface'
op|')'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_rx"'
op|']'
op|'='
name|'stats'
op|'['
number|'0'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_rx_packets"'
op|']'
op|'='
name|'stats'
op|'['
number|'1'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_rx_errors"'
op|']'
op|'='
name|'stats'
op|'['
number|'2'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_rx_drop"'
op|']'
op|'='
name|'stats'
op|'['
number|'3'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_tx"'
op|']'
op|'='
name|'stats'
op|'['
number|'4'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_tx_packets"'
op|']'
op|'='
name|'stats'
op|'['
number|'5'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_tx_errors"'
op|']'
op|'='
name|'stats'
op|'['
number|'6'
op|']'
newline|'\n'
name|'output'
op|'['
name|'interface'
op|'+'
string|'"_tx_drop"'
op|']'
op|'='
name|'stats'
op|'['
number|'7'
op|']'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'output'
op|'['
string|'"memory"'
op|']'
op|'='
name|'domain'
op|'.'
name|'maxMemory'
op|'('
op|')'
newline|'\n'
comment|'# memoryStats might launch an exception if the method'
nl|'\n'
comment|'# is not supported by the underlying hypervisor being'
nl|'\n'
comment|'# used by libvirt'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'mem'
op|'='
name|'domain'
op|'.'
name|'memoryStats'
op|'('
op|')'
newline|'\n'
name|'for'
name|'key'
name|'in'
name|'mem'
op|'.'
name|'keys'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'output'
op|'['
string|'"memory-"'
op|'+'
name|'key'
op|']'
op|'='
name|'mem'
op|'['
name|'key'
op|']'
newline|'\n'
dedent|''
dedent|''
name|'except'
op|'('
name|'libvirt'
op|'.'
name|'libvirtError'
op|','
name|'AttributeError'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
dedent|''
name|'return'
name|'output'
newline|'\n'
nl|'\n'
DECL|member|get_instance_diagnostics
dedent|''
name|'def'
name|'get_instance_diagnostics'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'domain'
op|'='
name|'self'
op|'.'
name|'_lookup_by_name'
op|'('
name|'instance'
op|'['
string|"'name'"
op|']'
op|')'
newline|'\n'
name|'xml'
op|'='
name|'domain'
op|'.'
name|'XMLDesc'
op|'('
number|'0'
op|')'
newline|'\n'
name|'xml_doc'
op|'='
name|'etree'
op|'.'
name|'fromstring'
op|'('
name|'xml'
op|')'
newline|'\n'
nl|'\n'
op|'('
name|'state'
op|','
name|'max_mem'
op|','
name|'mem'
op|','
name|'num_cpu'
op|','
name|'cpu_time'
op|')'
op|'='
name|'domain'
op|'.'
name|'info'
op|'('
op|')'
newline|'\n'
name|'config_drive'
op|'='
name|'configdrive'
op|'.'
name|'required_by'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'launched_at'
op|'='
name|'timeutils'
op|'.'
name|'normalize_time'
op|'('
name|'instance'
op|'['
string|"'launched_at'"
op|']'
op|')'
newline|'\n'
name|'uptime'
op|'='
name|'timeutils'
op|'.'
name|'delta_seconds'
op|'('
name|'launched_at'
op|','
nl|'\n'
name|'timeutils'
op|'.'
name|'utcnow'
op|'('
op|')'
op|')'
newline|'\n'
name|'diags'
op|'='
name|'diagnostics'
op|'.'
name|'Diagnostics'
op|'('
name|'state'
op|'='
name|'power_state'
op|'.'
name|'STATE_MAP'
op|'['
name|'state'
op|']'
op|','
nl|'\n'
name|'driver'
op|'='
string|"'libvirt'"
op|','
nl|'\n'
name|'config_drive'
op|'='
name|'config_drive'
op|','
nl|'\n'
name|'hypervisor_os'
op|'='
string|"'linux'"
op|','
nl|'\n'
name|'uptime'
op|'='
name|'uptime'
op|')'
newline|'\n'
name|'diags'
op|'.'
name|'memory_details'
op|'.'
name|'maximum'
op|'='
name|'max_mem'
op|'/'
name|'units'
op|'.'
name|'Mi'
newline|'\n'
name|'diags'
op|'.'
name|'memory_details'
op|'.'
name|'used'
op|'='
name|'mem'
op|'/'
name|'units'
op|'.'
name|'Mi'
newline|'\n'
nl|'\n'
comment|'# get cpu time, might launch an exception if the method'
nl|'\n'
comment|'# is not supported by the underlying hypervisor being'
nl|'\n'
comment|'# used by libvirt'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'cputime'
op|'='
name|'domain'
op|'.'
name|'vcpus'
op|'('
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'num_cpus'
op|'='
name|'len'
op|'('
name|'cputime'
op|')'
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'range'
op|'('
name|'num_cpus'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'diags'
op|'.'
name|'add_cpu'
op|'('
name|'time'
op|'='
name|'cputime'
op|'['
name|'i'
op|']'
op|'['
number|'2'
op|']'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'pass'
newline|'\n'
comment|'# get io status'
nl|'\n'
dedent|''
name|'dom_io'
op|'='
name|'LibvirtDriver'
op|'.'
name|'_get_io_devices'
op|'('
name|'xml'
op|')'
newline|'\n'
name|'for'
name|'guest_disk'
name|'in'
name|'dom_io'
op|'['
string|'"volumes"'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
comment|'# blockStats might launch an exception if the method'
nl|'\n'
comment|'# is not supported by the underlying hypervisor being'
nl|'\n'
comment|'# used by libvirt'
nl|'\n'
indent|'                '
name|'stats'
op|'='
name|'domain'
op|'.'
name|'blockStats'
op|'('
name|'guest_disk'
op|')'
newline|'\n'
name|'diags'
op|'.'
name|'add_disk'
op|'('
name|'read_bytes'
op|'='
name|'stats'
op|'['
number|'1'
op|']'
op|','
nl|'\n'
name|'read_requests'
op|'='
name|'stats'
op|'['
number|'0'
op|']'
op|','
nl|'\n'
name|'write_bytes'
op|'='
name|'stats'
op|'['
number|'3'
op|']'
op|','
nl|'\n'
name|'write_requests'
op|'='
name|'stats'
op|'['
number|'2'
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'for'
name|'interface'
name|'in'
name|'dom_io'
op|'['
string|'"ifaces"'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
comment|'# interfaceStats might launch an exception if the method'
nl|'\n'
comment|'# is not supported by the underlying hypervisor being'
nl|'\n'
comment|'# used by libvirt'
nl|'\n'
indent|'                '
name|'stats'
op|'='
name|'domain'
op|'.'
name|'interfaceStats'
op|'('
name|'interface'
op|')'
newline|'\n'
name|'diags'
op|'.'
name|'add_nic'
op|'('
name|'rx_octets'
op|'='
name|'stats'
op|'['
number|'0'
op|']'
op|','
nl|'\n'
name|'rx_errors'
op|'='
name|'stats'
op|'['
number|'2'
op|']'
op|','
nl|'\n'
name|'rx_drop'
op|'='
name|'stats'
op|'['
number|'3'
op|']'
op|','
nl|'\n'
name|'rx_packets'
op|'='
name|'stats'
op|'['
number|'1'
op|']'
op|','
nl|'\n'
name|'tx_octets'
op|'='
name|'stats'
op|'['
number|'4'
op|']'
op|','
nl|'\n'
name|'tx_errors'
op|'='
name|'stats'
op|'['
number|'6'
op|']'
op|','
nl|'\n'
name|'tx_drop'
op|'='
name|'stats'
op|'['
number|'7'
op|']'
op|','
nl|'\n'
name|'tx_packets'
op|'='
name|'stats'
op|'['
number|'5'
op|']'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
nl|'\n'
comment|'# Update mac addresses of interface if stats have been reported'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'len'
op|'('
name|'diags'
op|'.'
name|'nic_details'
op|')'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'ret'
op|'='
name|'xml_doc'
op|'.'
name|'findall'
op|'('
string|"'./devices/interface'"
op|')'
newline|'\n'
name|'index'
op|'='
number|'0'
newline|'\n'
name|'for'
name|'node'
name|'in'
name|'ret'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'child'
name|'in'
name|'node'
op|'.'
name|'getchildren'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'child'
op|'.'
name|'tag'
op|'=='
string|"'mac'"
op|':'
newline|'\n'
indent|'                        '
name|'diags'
op|'.'
name|'nic_details'
op|'['
name|'index'
op|']'
op|'.'
name|'mac_address'
op|'='
name|'child'
op|'.'
name|'get'
op|'('
nl|'\n'
string|"'address'"
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'return'
name|'diags'
newline|'\n'
nl|'\n'
DECL|member|instance_on_disk
dedent|''
name|'def'
name|'instance_on_disk'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
comment|'# ensure directories exist and are writable'
nl|'\n'
indent|'        '
name|'instance_path'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Checking instance files accessibility %s'"
op|','
name|'instance_path'
op|')'
newline|'\n'
name|'return'
name|'os'
op|'.'
name|'access'
op|'('
name|'instance_path'
op|','
name|'os'
op|'.'
name|'W_OK'
op|')'
newline|'\n'
nl|'\n'
DECL|member|inject_network_info
dedent|''
name|'def'
name|'inject_network_info'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'nw_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'firewall_driver'
op|'.'
name|'setup_basic_filtering'
op|'('
name|'instance'
op|','
name|'nw_info'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_delete_instance_files
dedent|''
name|'def'
name|'_delete_instance_files'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(mikal): a shim to handle this file not using instance objects'
nl|'\n'
comment|'# everywhere. Remove this when that conversion happens.'
nl|'\n'
indent|'        '
name|'context'
op|'='
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
name|'read_deleted'
op|'='
string|"'yes'"
op|')'
newline|'\n'
name|'inst_obj'
op|'='
name|'objects'
op|'.'
name|'Instance'
op|'.'
name|'get_by_uuid'
op|'('
name|'context'
op|','
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
nl|'\n'
comment|'# NOTE(mikal): this code should be pushed up a layer when this shim is'
nl|'\n'
comment|'# removed.'
nl|'\n'
name|'attempts'
op|'='
name|'int'
op|'('
name|'inst_obj'
op|'.'
name|'system_metadata'
op|'.'
name|'get'
op|'('
string|"'clean_attempts'"
op|','
string|"'0'"
op|')'
op|')'
newline|'\n'
name|'success'
op|'='
name|'self'
op|'.'
name|'delete_instance_files'
op|'('
name|'inst_obj'
op|')'
newline|'\n'
name|'inst_obj'
op|'.'
name|'system_metadata'
op|'['
string|"'clean_attempts'"
op|']'
op|'='
name|'str'
op|'('
name|'attempts'
op|'+'
number|'1'
op|')'
newline|'\n'
name|'if'
name|'success'
op|':'
newline|'\n'
indent|'            '
name|'inst_obj'
op|'.'
name|'cleaned'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'inst_obj'
op|'.'
name|'save'
op|'('
name|'context'
op|')'
newline|'\n'
nl|'\n'
DECL|member|delete_instance_files
dedent|''
name|'def'
name|'delete_instance_files'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'target'
op|'='
name|'libvirt_utils'
op|'.'
name|'get_instance_path'
op|'('
name|'instance'
op|')'
newline|'\n'
comment|'# A resize may be in progress'
nl|'\n'
name|'target_resize'
op|'='
name|'target'
op|'+'
string|"'_resize'"
newline|'\n'
comment|'# Other threads may attempt to rename the path, so renaming the path'
nl|'\n'
comment|"# to target + '_del' (because it is atomic) and iterating through"
nl|'\n'
comment|'# twice in the unlikely event that a concurrent rename occurs between'
nl|'\n'
comment|'# the two rename attempts in this method. In general this method'
nl|'\n'
comment|'# should be fairly thread-safe without these additional checks, since'
nl|'\n'
comment|'# other operations involving renames are not permitted when the task'
nl|'\n'
comment|'# state is not None and the task state should be set to something'
nl|'\n'
comment|'# other than None by the time this method is invoked.'
nl|'\n'
name|'target_del'
op|'='
name|'target'
op|'+'
string|"'_del'"
newline|'\n'
name|'for'
name|'i'
name|'in'
name|'six'
op|'.'
name|'moves'
op|'.'
name|'range'
op|'('
number|'2'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'target'
op|','
name|'target_del'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'utils'
op|'.'
name|'execute'
op|'('
string|"'mv'"
op|','
name|'target_resize'
op|','
name|'target_del'
op|')'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
comment|'# Either the target or target_resize path may still exist if all'
nl|'\n'
comment|'# rename attempts failed.'
nl|'\n'
dedent|''
dedent|''
name|'remaining_path'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'p'
name|'in'
op|'('
name|'target'
op|','
name|'target_resize'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'p'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'remaining_path'
op|'='
name|'p'
newline|'\n'
name|'break'
newline|'\n'
nl|'\n'
comment|'# A previous delete attempt may have been interrupted, so target_del'
nl|'\n'
comment|'# may exist even if all rename attempts during the present method'
nl|'\n'
comment|'# invocation failed due to the absence of both target and'
nl|'\n'
comment|'# target_resize.'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'remaining_path'
name|'and'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'target_del'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Deleting instance files %s'"
op|')'
op|','
name|'target_del'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'remaining_path'
op|'='
name|'target_del'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'shutil'
op|'.'
name|'rmtree'
op|'('
name|'target_del'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'OSError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'Failed to cleanup directory %(target)s: '"
nl|'\n'
string|"'%(e)s'"
op|')'
op|','
op|'{'
string|"'target'"
op|':'
name|'target_del'
op|','
string|"'e'"
op|':'
name|'e'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|"# It is possible that the delete failed, if so don't mark the instance"
nl|'\n'
comment|'# as cleaned.'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'remaining_path'
name|'and'
name|'os'
op|'.'
name|'path'
op|'.'
name|'exists'
op|'('
name|'remaining_path'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Deletion of %s failed'"
op|')'
op|','
name|'remaining_path'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|"'Deletion of %s complete'"
op|')'
op|','
name|'target_del'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|need_legacy_block_device_info
name|'def'
name|'need_legacy_block_device_info'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|default_root_device_name
dedent|''
name|'def'
name|'default_root_device_name'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'root_bdm'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'        '
name|'disk_bus'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_bus_for_device_type'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
name|'image_meta'
op|','
string|'"disk"'
op|')'
newline|'\n'
name|'cdrom_bus'
op|'='
name|'blockinfo'
op|'.'
name|'get_disk_bus_for_device_type'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
name|'image_meta'
op|','
string|'"cdrom"'
op|')'
newline|'\n'
name|'root_info'
op|'='
name|'blockinfo'
op|'.'
name|'get_root_info'
op|'('
nl|'\n'
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
name|'image_meta'
op|','
name|'root_bdm'
op|','
name|'disk_bus'
op|','
nl|'\n'
name|'cdrom_bus'
op|')'
newline|'\n'
name|'return'
name|'block_device'
op|'.'
name|'prepend_dev'
op|'('
name|'root_info'
op|'['
string|"'dev'"
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|default_device_names_for_instance
dedent|''
name|'def'
name|'default_device_names_for_instance'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'root_device_name'
op|','
nl|'\n'
op|'*'
name|'block_device_lists'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'ephemerals'
op|','
name|'swap'
op|','
name|'block_device_mapping'
op|'='
name|'block_device_lists'
op|'['
op|':'
number|'3'
op|']'
newline|'\n'
nl|'\n'
name|'blockinfo'
op|'.'
name|'default_device_names'
op|'('
name|'CONF'
op|'.'
name|'libvirt'
op|'.'
name|'virt_type'
op|','
nl|'\n'
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
op|','
nl|'\n'
name|'instance'
op|','
name|'root_device_name'
op|','
nl|'\n'
name|'ephemerals'
op|','
name|'swap'
op|','
nl|'\n'
name|'block_device_mapping'
op|')'
newline|'\n'
nl|'\n'
DECL|member|is_supported_fs_format
dedent|''
name|'def'
name|'is_supported_fs_format'
op|'('
name|'self'
op|','
name|'fs_type'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'fs_type'
name|'in'
op|'['
name|'disk'
op|'.'
name|'FS_FORMAT_EXT2'
op|','
name|'disk'
op|'.'
name|'FS_FORMAT_EXT3'
op|','
nl|'\n'
name|'disk'
op|'.'
name|'FS_FORMAT_EXT4'
op|','
name|'disk'
op|'.'
name|'FS_FORMAT_XFS'
op|']'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
