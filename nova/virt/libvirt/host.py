begin_unit
comment|'# Copyright 2010 United States Government as represented by the'
nl|'\n'
comment|'# Administrator of the National Aeronautics and Space Administration.'
nl|'\n'
comment|'# All Rights Reserved.'
nl|'\n'
comment|'# Copyright (c) 2010 Citrix Systems, Inc.'
nl|'\n'
comment|'# Copyright (c) 2011 Piston Cloud Computing, Inc'
nl|'\n'
comment|'# Copyright (c) 2012 University Of Minho'
nl|'\n'
comment|'# (c) Copyright 2013 Hewlett-Packard Development Company, L.P.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
nl|'\n'
string|'"""\nManages information about the host OS and hypervisor.\n\nThis class encapsulates a connection to the libvirt\ndaemon and provides certain higher level APIs around\nthe raw libvirt API. These APIs are then used by all\nthe other libvirt related classes\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'socket'
newline|'\n'
name|'import'
name|'threading'
newline|'\n'
nl|'\n'
name|'import'
name|'eventlet'
newline|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'greenio'
newline|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'greenthread'
newline|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'patcher'
newline|'\n'
name|'from'
name|'eventlet'
name|'import'
name|'tpool'
newline|'\n'
name|'from'
name|'oslo_config'
name|'import'
name|'cfg'
newline|'\n'
name|'from'
name|'oslo_utils'
name|'import'
name|'excutils'
newline|'\n'
nl|'\n'
name|'from'
name|'nova'
name|'import'
name|'context'
name|'as'
name|'nova_context'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'exception'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_LE'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_LI'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_LW'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'log'
name|'as'
name|'logging'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'rpc'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'utils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'event'
name|'as'
name|'virtevent'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'libvirt'
name|'import'
name|'config'
name|'as'
name|'vconfig'
newline|'\n'
nl|'\n'
DECL|variable|libvirt
name|'libvirt'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|variable|LOG
name|'LOG'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|native_socket
name|'native_socket'
op|'='
name|'patcher'
op|'.'
name|'original'
op|'('
string|"'socket'"
op|')'
newline|'\n'
DECL|variable|native_threading
name|'native_threading'
op|'='
name|'patcher'
op|'.'
name|'original'
op|'('
string|'"threading"'
op|')'
newline|'\n'
DECL|variable|native_Queue
name|'native_Queue'
op|'='
name|'patcher'
op|'.'
name|'original'
op|'('
string|'"Queue"'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|CONF
name|'CONF'
op|'='
name|'cfg'
op|'.'
name|'CONF'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'host'"
op|','
string|"'nova.netconf'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'my_ip'"
op|','
string|"'nova.netconf'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|Host
name|'class'
name|'Host'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
nl|'\n'
DECL|member|__init__
indent|'    '
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'uri'
op|','
name|'read_only'
op|'='
name|'False'
op|','
nl|'\n'
name|'conn_event_handler'
op|'='
name|'None'
op|','
nl|'\n'
name|'lifecycle_event_handler'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'        '
name|'global'
name|'libvirt'
newline|'\n'
name|'if'
name|'libvirt'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'libvirt'
op|'='
name|'__import__'
op|'('
string|"'libvirt'"
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_uri'
op|'='
name|'uri'
newline|'\n'
name|'self'
op|'.'
name|'_read_only'
op|'='
name|'read_only'
newline|'\n'
name|'self'
op|'.'
name|'_conn_event_handler'
op|'='
name|'conn_event_handler'
newline|'\n'
name|'self'
op|'.'
name|'_lifecycle_event_handler'
op|'='
name|'lifecycle_event_handler'
newline|'\n'
name|'self'
op|'.'
name|'_skip_list_all_domains'
op|'='
name|'False'
newline|'\n'
name|'self'
op|'.'
name|'_caps'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_hostname'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_wrapped_conn'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_wrapped_conn_lock'
op|'='
name|'threading'
op|'.'
name|'Lock'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_queue'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_events_delayed'
op|'='
op|'{'
op|'}'
newline|'\n'
comment|'# Note(toabctl): During a reboot of a Xen domain, STOPPED and'
nl|'\n'
comment|'#                STARTED events are sent. To prevent shutting'
nl|'\n'
comment|'#                down the domain during a reboot, delay the'
nl|'\n'
comment|'#                STOPPED lifecycle event some seconds.'
nl|'\n'
name|'if'
name|'uri'
op|'.'
name|'find'
op|'('
string|'"xen://"'
op|')'
op|'!='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_lifecycle_delay'
op|'='
number|'15'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_lifecycle_delay'
op|'='
number|'0'
newline|'\n'
nl|'\n'
DECL|member|_native_thread
dedent|''
dedent|''
name|'def'
name|'_native_thread'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Receives async events coming in from libvirtd.\n\n        This is a native thread which runs the default\n        libvirt event loop implementation. This processes\n        any incoming async events from libvirtd and queues\n        them for later dispatch. This thread is only\n        permitted to use libvirt python APIs, and the\n        driver.queue_event method. In particular any use\n        of logging is forbidden, since it will confuse\n        eventlet\'s greenthread integration\n        """'
newline|'\n'
nl|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'libvirt'
op|'.'
name|'virEventRunDefaultImpl'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_dispatch_thread
dedent|''
dedent|''
name|'def'
name|'_dispatch_thread'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Dispatches async events coming in from libvirtd.\n\n        This is a green thread which waits for events to\n        arrive from the libvirt event loop thread. This\n        then dispatches the events to the compute manager.\n        """'
newline|'\n'
nl|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_dispatch_events'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_event_lifecycle_callback
name|'def'
name|'_event_lifecycle_callback'
op|'('
name|'conn'
op|','
name|'dom'
op|','
name|'event'
op|','
name|'detail'
op|','
name|'opaque'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Receives lifecycle events from libvirt.\n\n        NB: this method is executing in a native thread, not\n        an eventlet coroutine. It can only invoke other libvirt\n        APIs, or use self._queue_event(). Any use of logging APIs\n        in particular is forbidden.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'='
name|'opaque'
newline|'\n'
nl|'\n'
name|'uuid'
op|'='
name|'dom'
op|'.'
name|'UUIDString'
op|'('
op|')'
newline|'\n'
name|'transition'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'event'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_EVENT_STOPPED'
op|':'
newline|'\n'
indent|'            '
name|'transition'
op|'='
name|'virtevent'
op|'.'
name|'EVENT_LIFECYCLE_STOPPED'
newline|'\n'
dedent|''
name|'elif'
name|'event'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_EVENT_STARTED'
op|':'
newline|'\n'
indent|'            '
name|'transition'
op|'='
name|'virtevent'
op|'.'
name|'EVENT_LIFECYCLE_STARTED'
newline|'\n'
dedent|''
name|'elif'
name|'event'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_EVENT_SUSPENDED'
op|':'
newline|'\n'
indent|'            '
name|'transition'
op|'='
name|'virtevent'
op|'.'
name|'EVENT_LIFECYCLE_PAUSED'
newline|'\n'
dedent|''
name|'elif'
name|'event'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_EVENT_RESUMED'
op|':'
newline|'\n'
indent|'            '
name|'transition'
op|'='
name|'virtevent'
op|'.'
name|'EVENT_LIFECYCLE_RESUMED'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'transition'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_queue_event'
op|'('
name|'virtevent'
op|'.'
name|'LifecycleEvent'
op|'('
name|'uuid'
op|','
name|'transition'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_close_callback
dedent|''
dedent|''
name|'def'
name|'_close_callback'
op|'('
name|'self'
op|','
name|'conn'
op|','
name|'reason'
op|','
name|'opaque'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'close_info'
op|'='
op|'{'
string|"'conn'"
op|':'
name|'conn'
op|','
string|"'reason'"
op|':'
name|'reason'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'_queue_event'
op|'('
name|'close_info'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_test_connection
name|'def'
name|'_test_connection'
op|'('
name|'conn'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'conn'
op|'.'
name|'getLibVersion'
op|'('
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
op|'('
name|'e'
op|'.'
name|'get_error_code'
op|'('
op|')'
name|'in'
op|'('
name|'libvirt'
op|'.'
name|'VIR_ERR_SYSTEM_ERROR'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_ERR_INTERNAL_ERROR'
op|')'
name|'and'
nl|'\n'
name|'e'
op|'.'
name|'get_error_domain'
op|'('
op|')'
name|'in'
op|'('
name|'libvirt'
op|'.'
name|'VIR_FROM_REMOTE'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_FROM_RPC'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Connection to libvirt broke'"
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'raise'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_connect_auth_cb
name|'def'
name|'_connect_auth_cb'
op|'('
name|'creds'
op|','
name|'opaque'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'len'
op|'('
name|'creds'
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'return'
number|'0'
newline|'\n'
dedent|''
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
nl|'\n'
name|'_'
op|'('
string|'"Can not handle authentication request for %d credentials"'
op|')'
nl|'\n'
op|'%'
name|'len'
op|'('
name|'creds'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_connect
name|'def'
name|'_connect'
op|'('
name|'uri'
op|','
name|'read_only'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'auth'
op|'='
op|'['
op|'['
name|'libvirt'
op|'.'
name|'VIR_CRED_AUTHNAME'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_CRED_ECHOPROMPT'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_CRED_REALM'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_CRED_PASSPHRASE'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_CRED_NOECHOPROMPT'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_CRED_EXTERNAL'
op|']'
op|','
nl|'\n'
name|'Host'
op|'.'
name|'_connect_auth_cb'
op|','
nl|'\n'
name|'None'
op|']'
newline|'\n'
nl|'\n'
name|'flags'
op|'='
number|'0'
newline|'\n'
name|'if'
name|'read_only'
op|':'
newline|'\n'
indent|'            '
name|'flags'
op|'='
name|'libvirt'
op|'.'
name|'VIR_CONNECT_RO'
newline|'\n'
comment|'# tpool.proxy_call creates a native thread. Due to limitations'
nl|'\n'
comment|'# with eventlet locking we cannot use the logging API inside'
nl|'\n'
comment|'# the called function.'
nl|'\n'
dedent|''
name|'return'
name|'tpool'
op|'.'
name|'proxy_call'
op|'('
nl|'\n'
op|'('
name|'libvirt'
op|'.'
name|'virDomain'
op|','
name|'libvirt'
op|'.'
name|'virConnect'
op|')'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'openAuth'
op|','
name|'uri'
op|','
name|'auth'
op|','
name|'flags'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_queue_event
dedent|''
name|'def'
name|'_queue_event'
op|'('
name|'self'
op|','
name|'event'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Puts an event on the queue for dispatch.\n\n        This method is called by the native event thread to\n        put events on the queue for later dispatch by the\n        green thread. Any use of logging APIs is forbidden.\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'_event_queue'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
comment|'# Queue the event...'
nl|'\n'
dedent|''
name|'self'
op|'.'
name|'_event_queue'
op|'.'
name|'put'
op|'('
name|'event'
op|')'
newline|'\n'
nl|'\n'
comment|'# ...then wakeup the green thread to dispatch it'
nl|'\n'
name|'c'
op|'='
string|"' '"
op|'.'
name|'encode'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_notify_send'
op|'.'
name|'write'
op|'('
name|'c'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_notify_send'
op|'.'
name|'flush'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_dispatch_events
dedent|''
name|'def'
name|'_dispatch_events'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Wait for & dispatch events from native thread\n\n        Blocks until native thread indicates some events\n        are ready. Then dispatches all queued events.\n        """'
newline|'\n'
nl|'\n'
comment|'# Wait to be notified that there are some'
nl|'\n'
comment|'# events pending'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'_c'
op|'='
name|'self'
op|'.'
name|'_event_notify_recv'
op|'.'
name|'read'
op|'('
number|'1'
op|')'
newline|'\n'
name|'assert'
name|'_c'
newline|'\n'
dedent|''
name|'except'
name|'ValueError'
op|':'
newline|'\n'
indent|'            '
name|'return'
comment|'# will be raised when pipe is closed'
newline|'\n'
nl|'\n'
comment|'# Process as many events as possible without'
nl|'\n'
comment|'# blocking'
nl|'\n'
dedent|''
name|'last_close_event'
op|'='
name|'None'
newline|'\n'
name|'while'
name|'not'
name|'self'
op|'.'
name|'_event_queue'
op|'.'
name|'empty'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'event'
op|'='
name|'self'
op|'.'
name|'_event_queue'
op|'.'
name|'get'
op|'('
name|'block'
op|'='
name|'False'
op|')'
newline|'\n'
name|'if'
name|'isinstance'
op|'('
name|'event'
op|','
name|'virtevent'
op|'.'
name|'LifecycleEvent'
op|')'
op|':'
newline|'\n'
comment|'# call possibly with delay'
nl|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_event_delayed_cleanup'
op|'('
name|'event'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_emit_delayed'
op|'('
name|'event'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'elif'
string|"'conn'"
name|'in'
name|'event'
name|'and'
string|"'reason'"
name|'in'
name|'event'
op|':'
newline|'\n'
indent|'                    '
name|'last_close_event'
op|'='
name|'event'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'native_Queue'
op|'.'
name|'Empty'
op|':'
newline|'\n'
indent|'                '
name|'pass'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'last_close_event'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
dedent|''
name|'conn'
op|'='
name|'last_close_event'
op|'['
string|"'conn'"
op|']'
newline|'\n'
comment|'# get_new_connection may already have disabled the host,'
nl|'\n'
comment|'# in which case _wrapped_conn is None.'
nl|'\n'
name|'with'
name|'self'
op|'.'
name|'_wrapped_conn_lock'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'conn'
op|'=='
name|'self'
op|'.'
name|'_wrapped_conn'
op|':'
newline|'\n'
indent|'                '
name|'reason'
op|'='
name|'str'
op|'('
name|'last_close_event'
op|'['
string|"'reason'"
op|']'
op|')'
newline|'\n'
name|'msg'
op|'='
name|'_'
op|'('
string|'"Connection to libvirt lost: %s"'
op|')'
op|'%'
name|'reason'
newline|'\n'
name|'self'
op|'.'
name|'_wrapped_conn'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_conn_event_handler'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_conn_event_handler'
op|'('
name|'False'
op|','
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_event_delayed_cleanup
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'_event_delayed_cleanup'
op|'('
name|'self'
op|','
name|'event'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Cleanup possible delayed stop events."""'
newline|'\n'
name|'if'
op|'('
name|'event'
op|'.'
name|'transition'
op|'=='
name|'virtevent'
op|'.'
name|'EVENT_LIFECYCLE_STARTED'
name|'or'
nl|'\n'
name|'event'
op|'.'
name|'transition'
op|'=='
name|'virtevent'
op|'.'
name|'EVENT_LIFECYCLE_RESUMED'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'event'
op|'.'
name|'uuid'
name|'in'
name|'self'
op|'.'
name|'_events_delayed'
op|'.'
name|'keys'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_events_delayed'
op|'['
name|'event'
op|'.'
name|'uuid'
op|']'
op|'.'
name|'cancel'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_events_delayed'
op|'.'
name|'pop'
op|'('
name|'event'
op|'.'
name|'uuid'
op|','
name|'None'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Removed pending event for %s due to "'
nl|'\n'
string|'"lifecycle event"'
op|','
name|'event'
op|'.'
name|'uuid'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_event_emit_delayed
dedent|''
dedent|''
dedent|''
name|'def'
name|'_event_emit_delayed'
op|'('
name|'self'
op|','
name|'event'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Emit events - possibly delayed."""'
newline|'\n'
DECL|function|event_cleanup
name|'def'
name|'event_cleanup'
op|'('
name|'gt'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Callback function for greenthread. Called\n            to cleanup the _events_delayed dictionary when a event\n            was called.\n            """'
newline|'\n'
name|'event'
op|'='
name|'args'
op|'['
number|'0'
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_events_delayed'
op|'.'
name|'pop'
op|'('
name|'event'
op|'.'
name|'uuid'
op|','
name|'None'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_lifecycle_delay'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'event'
op|'.'
name|'uuid'
name|'not'
name|'in'
name|'self'
op|'.'
name|'_events_delayed'
op|'.'
name|'keys'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'id_'
op|'='
name|'greenthread'
op|'.'
name|'spawn_after'
op|'('
name|'self'
op|'.'
name|'_lifecycle_delay'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_event_emit'
op|','
name|'event'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_events_delayed'
op|'['
name|'event'
op|'.'
name|'uuid'
op|']'
op|'='
name|'id_'
newline|'\n'
comment|'# add callback to cleanup self._events_delayed dict after'
nl|'\n'
comment|'# event was called'
nl|'\n'
name|'id_'
op|'.'
name|'link'
op|'('
name|'event_cleanup'
op|','
name|'event'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_event_emit'
op|'('
name|'event'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_event_emit
dedent|''
dedent|''
name|'def'
name|'_event_emit'
op|'('
name|'self'
op|','
name|'event'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'self'
op|'.'
name|'_lifecycle_event_handler'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_lifecycle_event_handler'
op|'('
name|'event'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_init_events_pipe
dedent|''
dedent|''
name|'def'
name|'_init_events_pipe'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a self-pipe for the native thread to synchronize on.\n\n        This code is taken from the eventlet tpool module, under terms\n        of the Apache License v2.0.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_event_queue'
op|'='
name|'native_Queue'
op|'.'
name|'Queue'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'rpipe'
op|','
name|'wpipe'
op|'='
name|'os'
op|'.'
name|'pipe'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_notify_send'
op|'='
name|'greenio'
op|'.'
name|'GreenPipe'
op|'('
name|'wpipe'
op|','
string|"'wb'"
op|','
number|'0'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_notify_recv'
op|'='
name|'greenio'
op|'.'
name|'GreenPipe'
op|'('
name|'rpipe'
op|','
string|"'rb'"
op|','
number|'0'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'ImportError'
op|','
name|'NotImplementedError'
op|')'
op|':'
newline|'\n'
comment|'# This is Windows compatibility -- use a socket instead'
nl|'\n'
comment|"#  of a pipe because pipes don't really exist on Windows."
nl|'\n'
indent|'            '
name|'sock'
op|'='
name|'native_socket'
op|'.'
name|'socket'
op|'('
name|'socket'
op|'.'
name|'AF_INET'
op|','
name|'socket'
op|'.'
name|'SOCK_STREAM'
op|')'
newline|'\n'
name|'sock'
op|'.'
name|'bind'
op|'('
op|'('
string|"'localhost'"
op|','
number|'0'
op|')'
op|')'
newline|'\n'
name|'sock'
op|'.'
name|'listen'
op|'('
number|'50'
op|')'
newline|'\n'
name|'csock'
op|'='
name|'native_socket'
op|'.'
name|'socket'
op|'('
name|'socket'
op|'.'
name|'AF_INET'
op|','
name|'socket'
op|'.'
name|'SOCK_STREAM'
op|')'
newline|'\n'
name|'csock'
op|'.'
name|'connect'
op|'('
op|'('
string|"'localhost'"
op|','
name|'sock'
op|'.'
name|'getsockname'
op|'('
op|')'
op|'['
number|'1'
op|']'
op|')'
op|')'
newline|'\n'
name|'nsock'
op|','
name|'addr'
op|'='
name|'sock'
op|'.'
name|'accept'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_notify_send'
op|'='
name|'nsock'
op|'.'
name|'makefile'
op|'('
string|"'wb'"
op|','
number|'0'
op|')'
newline|'\n'
name|'gsock'
op|'='
name|'greenio'
op|'.'
name|'GreenSocket'
op|'('
name|'csock'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_notify_recv'
op|'='
name|'gsock'
op|'.'
name|'makefile'
op|'('
string|"'rb'"
op|','
number|'0'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_init_events
dedent|''
dedent|''
name|'def'
name|'_init_events'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Initializes the libvirt events subsystem.\n\n        This requires running a native thread to provide the\n        libvirt event loop integration. This forwards events\n        to a green thread which does the actual dispatching.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_init_events_pipe'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Starting native event thread"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_thread'
op|'='
name|'native_threading'
op|'.'
name|'Thread'
op|'('
nl|'\n'
name|'target'
op|'='
name|'self'
op|'.'
name|'_native_thread'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_thread'
op|'.'
name|'setDaemon'
op|'('
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_event_thread'
op|'.'
name|'start'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Starting green dispatch thread"'
op|')'
newline|'\n'
name|'eventlet'
op|'.'
name|'spawn'
op|'('
name|'self'
op|'.'
name|'_dispatch_thread'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_new_connection
dedent|''
name|'def'
name|'_get_new_connection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# call with _wrapped_conn_lock held'
nl|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Connecting to libvirt: %s'"
op|','
name|'self'
op|'.'
name|'_uri'
op|')'
newline|'\n'
name|'wrapped_conn'
op|'='
name|'None'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'wrapped_conn'
op|'='
name|'self'
op|'.'
name|'_connect'
op|'('
name|'self'
op|'.'
name|'_uri'
op|','
name|'self'
op|'.'
name|'_read_only'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
comment|'# Enabling the compute service, in case it was disabled'
nl|'\n'
comment|'# since the connection was successful.'
nl|'\n'
indent|'            '
name|'disable_reason'
op|'='
name|'None'
newline|'\n'
name|'if'
name|'not'
name|'wrapped_conn'
op|':'
newline|'\n'
indent|'                '
name|'disable_reason'
op|'='
string|"'Failed to connect to libvirt'"
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'self'
op|'.'
name|'_conn_event_handler'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_conn_event_handler'
op|'('
name|'bool'
op|'('
name|'wrapped_conn'
op|')'
op|','
name|'disable_reason'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'self'
op|'.'
name|'_wrapped_conn'
op|'='
name|'wrapped_conn'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Registering for lifecycle events %s"'
op|','
name|'self'
op|')'
newline|'\n'
name|'wrapped_conn'
op|'.'
name|'domainEventRegisterAny'
op|'('
nl|'\n'
name|'None'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_DOMAIN_EVENT_ID_LIFECYCLE'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_event_lifecycle_callback'
op|','
nl|'\n'
name|'self'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"URI %(uri)s does not support events: %(error)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'uri'"
op|':'
name|'self'
op|'.'
name|'_uri'
op|','
string|"'error'"
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Registering for connection events: %s"'
op|','
name|'str'
op|'('
name|'self'
op|')'
op|')'
newline|'\n'
name|'wrapped_conn'
op|'.'
name|'registerCloseCallback'
op|'('
name|'self'
op|'.'
name|'_close_callback'
op|','
name|'None'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'TypeError'
op|','
name|'AttributeError'
op|')'
name|'as'
name|'e'
op|':'
newline|'\n'
comment|'# NOTE: The registerCloseCallback of python-libvirt 1.0.1+'
nl|'\n'
comment|'# is defined with 3 arguments, and the above registerClose-'
nl|'\n'
comment|'# Callback succeeds. However, the one of python-libvirt 1.0.0'
nl|'\n'
comment|'# is defined with 4 arguments and TypeError happens here.'
nl|'\n'
comment|'# Then python-libvirt 0.9 does not define a method register-'
nl|'\n'
comment|'# CloseCallback.'
nl|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"The version of python-libvirt does not support "'
nl|'\n'
string|'"registerCloseCallback or is too old: %s"'
op|','
name|'e'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"URI %(uri)s does not support connection"'
nl|'\n'
string|'" events: %(error)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'uri'"
op|':'
name|'self'
op|'.'
name|'_uri'
op|','
string|"'error'"
op|':'
name|'e'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'wrapped_conn'
newline|'\n'
nl|'\n'
DECL|member|_get_connection
dedent|''
name|'def'
name|'_get_connection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# multiple concurrent connections are protected by _wrapped_conn_lock'
nl|'\n'
indent|'        '
name|'with'
name|'self'
op|'.'
name|'_wrapped_conn_lock'
op|':'
newline|'\n'
indent|'            '
name|'wrapped_conn'
op|'='
name|'self'
op|'.'
name|'_wrapped_conn'
newline|'\n'
name|'if'
name|'not'
name|'wrapped_conn'
name|'or'
name|'not'
name|'self'
op|'.'
name|'_test_connection'
op|'('
name|'wrapped_conn'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'wrapped_conn'
op|'='
name|'self'
op|'.'
name|'_get_new_connection'
op|'('
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'wrapped_conn'
newline|'\n'
nl|'\n'
DECL|member|get_connection
dedent|''
name|'def'
name|'get_connection'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns a connection to the hypervisor\n\n        This method should be used to create and return a well\n        configured connection to the hypervisor.\n\n        :returns: a libvirt.virConnect object\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'conn'
op|'='
name|'self'
op|'.'
name|'_get_connection'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_LE'
op|'('
string|'"Connection to libvirt failed: %s"'
op|')'
op|','
name|'ex'
op|')'
newline|'\n'
name|'payload'
op|'='
name|'dict'
op|'('
name|'ip'
op|'='
name|'CONF'
op|'.'
name|'my_ip'
op|','
nl|'\n'
name|'method'
op|'='
string|"'_connect'"
op|','
nl|'\n'
name|'reason'
op|'='
name|'ex'
op|')'
newline|'\n'
name|'rpc'
op|'.'
name|'get_notifier'
op|'('
string|"'compute'"
op|')'
op|'.'
name|'error'
op|'('
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
op|','
nl|'\n'
string|"'compute.libvirt.error'"
op|','
nl|'\n'
name|'payload'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'HypervisorUnavailable'
op|'('
name|'host'
op|'='
name|'CONF'
op|'.'
name|'host'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'conn'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_libvirt_error_handler
name|'def'
name|'_libvirt_error_handler'
op|'('
name|'context'
op|','
name|'err'
op|')'
op|':'
newline|'\n'
comment|'# Just ignore instead of default outputting to stderr.'
nl|'\n'
indent|'        '
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|initialize
dedent|''
name|'def'
name|'initialize'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
comment|'# NOTE(dkliban): Error handler needs to be registered before libvirt'
nl|'\n'
comment|'#                connection is used for the first time.  Otherwise, the'
nl|'\n'
comment|'#                handler does not get registered.'
nl|'\n'
indent|'        '
name|'libvirt'
op|'.'
name|'registerErrorHandler'
op|'('
name|'self'
op|'.'
name|'_libvirt_error_handler'
op|','
name|'None'
op|')'
newline|'\n'
name|'libvirt'
op|'.'
name|'virEventRegisterDefaultImpl'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_init_events'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|has_min_version
dedent|''
name|'def'
name|'has_min_version'
op|'('
name|'self'
op|','
name|'lv_ver'
op|'='
name|'None'
op|','
name|'hv_ver'
op|'='
name|'None'
op|','
name|'hv_type'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'conn'
op|'='
name|'self'
op|'.'
name|'get_connection'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'lv_ver'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'libvirt_version'
op|'='
name|'conn'
op|'.'
name|'getLibVersion'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'libvirt_version'
op|'<'
name|'utils'
op|'.'
name|'convert_version_to_int'
op|'('
name|'lv_ver'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'hv_ver'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'hypervisor_version'
op|'='
name|'conn'
op|'.'
name|'getVersion'
op|'('
op|')'
newline|'\n'
name|'if'
name|'hypervisor_version'
op|'<'
name|'utils'
op|'.'
name|'convert_version_to_int'
op|'('
name|'hv_ver'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'hv_type'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'hypervisor_type'
op|'='
name|'conn'
op|'.'
name|'getType'
op|'('
op|')'
newline|'\n'
name|'if'
name|'hypervisor_type'
op|'!='
name|'hv_type'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|get_domain
dedent|''
dedent|''
name|'def'
name|'get_domain'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve libvirt domain object for an instance.\n\n        :param instance: an nova.objects.Instance object\n\n        Attempt to lookup the libvirt domain objects\n        corresponding to the Nova instance, based on\n        its name. If not found it will raise an\n        exception.InstanceNotFound exception. On other\n        errors, it will raise a exception.NovaException\n        exception.\n\n        :returns: a libvirt.Domain object\n        """'
newline|'\n'
name|'return'
name|'self'
op|'.'
name|'_get_domain_by_name'
op|'('
name|'instance'
op|'.'
name|'name'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_domain_by_id
dedent|''
name|'def'
name|'_get_domain_by_id'
op|'('
name|'self'
op|','
name|'instance_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve libvirt domain object given an instance id.\n\n        All libvirt error handling should be handled in this method and\n        relevant nova exceptions should be raised in response.\n\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'conn'
op|'='
name|'self'
op|'.'
name|'get_connection'
op|'('
op|')'
newline|'\n'
name|'return'
name|'conn'
op|'.'
name|'lookupByID'
op|'('
name|'instance_id'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_DOMAIN'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|'('
name|'instance_id'
op|'='
name|'instance_id'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|'"Error from libvirt while looking up %(instance_id)s: "'
nl|'\n'
string|'"[Error Code %(error_code)s] %(ex)s"'
op|')'
nl|'\n'
op|'%'
op|'{'
string|"'instance_id'"
op|':'
name|'instance_id'
op|','
nl|'\n'
string|"'error_code'"
op|':'
name|'error_code'
op|','
nl|'\n'
string|"'ex'"
op|':'
name|'ex'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_domain_by_name
dedent|''
dedent|''
name|'def'
name|'_get_domain_by_name'
op|'('
name|'self'
op|','
name|'instance_name'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve libvirt domain object given an instance name.\n\n        All libvirt error handling should be handled in this method and\n        relevant nova exceptions should be raised in response.\n\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'conn'
op|'='
name|'self'
op|'.'
name|'get_connection'
op|'('
op|')'
newline|'\n'
name|'return'
name|'conn'
op|'.'
name|'lookupByName'
op|'('
name|'instance_name'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_DOMAIN'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|'('
name|'instance_id'
op|'='
name|'instance_name'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'msg'
op|'='
op|'('
name|'_'
op|'('
string|"'Error from libvirt while looking up %(instance_name)s: '"
nl|'\n'
string|"'[Error Code %(error_code)s] %(ex)s'"
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'instance_name'"
op|':'
name|'instance_name'
op|','
nl|'\n'
string|"'error_code'"
op|':'
name|'error_code'
op|','
nl|'\n'
string|"'ex'"
op|':'
name|'ex'
op|'}'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_list_instance_domains_fast
dedent|''
dedent|''
name|'def'
name|'_list_instance_domains_fast'
op|'('
name|'self'
op|','
name|'only_running'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
comment|'# The modern (>= 0.9.13) fast way - 1 single API call for all domains'
nl|'\n'
indent|'        '
name|'flags'
op|'='
name|'libvirt'
op|'.'
name|'VIR_CONNECT_LIST_DOMAINS_ACTIVE'
newline|'\n'
name|'if'
name|'not'
name|'only_running'
op|':'
newline|'\n'
indent|'            '
name|'flags'
op|'='
name|'flags'
op|'|'
name|'libvirt'
op|'.'
name|'VIR_CONNECT_LIST_DOMAINS_INACTIVE'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'get_connection'
op|'('
op|')'
op|'.'
name|'listAllDomains'
op|'('
name|'flags'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_list_instance_domains_slow
dedent|''
name|'def'
name|'_list_instance_domains_slow'
op|'('
name|'self'
op|','
name|'only_running'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
comment|'# The legacy (< 0.9.13) slow way - O(n) API call for n domains'
nl|'\n'
indent|'        '
name|'uuids'
op|'='
op|'['
op|']'
newline|'\n'
name|'doms'
op|'='
op|'['
op|']'
newline|'\n'
comment|'# Redundant numOfDomains check is for libvirt bz #836647'
nl|'\n'
name|'if'
name|'self'
op|'.'
name|'get_connection'
op|'('
op|')'
op|'.'
name|'numOfDomains'
op|'('
op|')'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'id'
name|'in'
name|'self'
op|'.'
name|'get_connection'
op|'('
op|')'
op|'.'
name|'listDomainsID'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'dom'
op|'='
name|'self'
op|'.'
name|'_get_domain_by_id'
op|'('
name|'id'
op|')'
newline|'\n'
name|'doms'
op|'.'
name|'append'
op|'('
name|'dom'
op|')'
newline|'\n'
name|'uuids'
op|'.'
name|'append'
op|'('
name|'dom'
op|'.'
name|'UUIDString'
op|'('
op|')'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'                    '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'if'
name|'only_running'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'doms'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'name'
name|'in'
name|'self'
op|'.'
name|'get_connection'
op|'('
op|')'
op|'.'
name|'listDefinedDomains'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'dom'
op|'='
name|'self'
op|'.'
name|'_get_domain_by_name'
op|'('
name|'name'
op|')'
newline|'\n'
name|'if'
name|'dom'
op|'.'
name|'UUIDString'
op|'('
op|')'
name|'not'
name|'in'
name|'uuids'
op|':'
newline|'\n'
indent|'                    '
name|'doms'
op|'.'
name|'append'
op|'('
name|'dom'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'return'
name|'doms'
newline|'\n'
nl|'\n'
DECL|member|list_instance_domains
dedent|''
name|'def'
name|'list_instance_domains'
op|'('
name|'self'
op|','
name|'only_running'
op|'='
name|'True'
op|','
name|'only_guests'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get a list of libvirt.Domain objects for nova instances\n\n        :param only_running: True to only return running instances\n        :param only_guests: True to filter out any host domain (eg Dom-0)\n\n        Query libvirt to a get a list of all libvirt.Domain objects\n        that correspond to nova instances. If the only_running parameter\n        is true this list will only include active domains, otherwise\n        inactive domains will be included too. If the only_guests parameter\n        is true the list will have any "host" domain (aka Xen Domain-0)\n        filtered out.\n\n        :returns: list of libvirt.Domain objects\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_skip_list_all_domains'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'alldoms'
op|'='
name|'self'
op|'.'
name|'_list_instance_domains_fast'
op|'('
name|'only_running'
op|')'
newline|'\n'
dedent|''
name|'except'
op|'('
name|'libvirt'
op|'.'
name|'libvirtError'
op|','
name|'AttributeError'
op|')'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_LI'
op|'('
string|'"Unable to use bulk domain list APIs, "'
nl|'\n'
string|'"falling back to slow code path: %(ex)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'ex'"
op|':'
name|'ex'
op|'}'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_skip_list_all_domains'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'self'
op|'.'
name|'_skip_list_all_domains'
op|':'
newline|'\n'
comment|"# Old libvirt, or a libvirt driver which doesn't"
nl|'\n'
comment|'# implement the new API'
nl|'\n'
indent|'            '
name|'alldoms'
op|'='
name|'self'
op|'.'
name|'_list_instance_domains_slow'
op|'('
name|'only_running'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'doms'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'dom'
name|'in'
name|'alldoms'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'only_guests'
name|'and'
name|'dom'
op|'.'
name|'ID'
op|'('
op|')'
op|'=='
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'continue'
newline|'\n'
dedent|''
name|'doms'
op|'.'
name|'append'
op|'('
name|'dom'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'doms'
newline|'\n'
nl|'\n'
DECL|member|get_capabilities
dedent|''
name|'def'
name|'get_capabilities'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns the host capabilities information\n\n        Returns an instance of config.LibvirtConfigCaps representing\n        the capabilities of the host.\n\n        Note: The result is cached in the member attribute _caps.\n\n        :returns: a config.LibvirtConfigCaps object\n        """'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_caps'
op|':'
newline|'\n'
indent|'            '
name|'xmlstr'
op|'='
name|'self'
op|'.'
name|'get_connection'
op|'('
op|')'
op|'.'
name|'getCapabilities'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_caps'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigCaps'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_caps'
op|'.'
name|'parse_str'
op|'('
name|'xmlstr'
op|')'
newline|'\n'
name|'if'
name|'hasattr'
op|'('
name|'libvirt'
op|','
string|"'VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'features'
op|'='
name|'self'
op|'.'
name|'get_connection'
op|'('
op|')'
op|'.'
name|'baselineCPU'
op|'('
nl|'\n'
op|'['
name|'self'
op|'.'
name|'_caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'to_xml'
op|'('
op|')'
op|']'
op|','
nl|'\n'
name|'libvirt'
op|'.'
name|'VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES'
op|')'
newline|'\n'
comment|'# FIXME(wangpan): the return value of baselineCPU should be'
nl|'\n'
comment|'#                 None or xml string, but libvirt has a bug'
nl|'\n'
comment|'#                 of it from 1.1.2 which is fixed in 1.2.0,'
nl|'\n'
comment|'#                 this -1 checking should be removed later.'
nl|'\n'
name|'if'
name|'features'
name|'and'
name|'features'
op|'!='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'                        '
name|'cpu'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigCPU'
op|'('
op|')'
newline|'\n'
name|'cpu'
op|'.'
name|'parse_str'
op|'('
name|'features'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_caps'
op|'.'
name|'host'
op|'.'
name|'cpu'
op|'.'
name|'features'
op|'='
name|'cpu'
op|'.'
name|'features'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'                    '
name|'error_code'
op|'='
name|'ex'
op|'.'
name|'get_error_code'
op|'('
op|')'
newline|'\n'
name|'if'
name|'error_code'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_SUPPORT'
op|':'
newline|'\n'
indent|'                        '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_LW'
op|'('
string|'"URI %(uri)s does not support full set"'
nl|'\n'
string|'" of host capabilities: "'
string|'"%(error)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'uri'"
op|':'
name|'self'
op|'.'
name|'_uri'
op|','
string|"'error'"
op|':'
name|'ex'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                        '
name|'raise'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'return'
name|'self'
op|'.'
name|'_caps'
newline|'\n'
nl|'\n'
DECL|member|get_driver_type
dedent|''
name|'def'
name|'get_driver_type'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get hypervisor type.\n\n        :returns: hypervisor type (ex. qemu)\n\n        """'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'get_connection'
op|'('
op|')'
op|'.'
name|'getType'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_version
dedent|''
name|'def'
name|'get_version'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get hypervisor version.\n\n        :returns: hypervisor version (ex. 12003)\n\n        """'
newline|'\n'
nl|'\n'
name|'return'
name|'self'
op|'.'
name|'get_connection'
op|'('
op|')'
op|'.'
name|'getVersion'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_hostname
dedent|''
name|'def'
name|'get_hostname'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns the hostname of the hypervisor."""'
newline|'\n'
name|'hostname'
op|'='
name|'self'
op|'.'
name|'get_connection'
op|'('
op|')'
op|'.'
name|'getHostname'
op|'('
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'_hostname'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_hostname'
op|'='
name|'hostname'
newline|'\n'
dedent|''
name|'elif'
name|'hostname'
op|'!='
name|'self'
op|'.'
name|'_hostname'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'Hostname has changed from %(old)s '"
nl|'\n'
string|"'to %(new)s. A restart is required to take effect.'"
op|')'
op|','
nl|'\n'
op|'{'
string|"'old'"
op|':'
name|'self'
op|'.'
name|'_hostname'
op|','
nl|'\n'
string|"'new'"
op|':'
name|'hostname'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'self'
op|'.'
name|'_hostname'
newline|'\n'
nl|'\n'
DECL|member|find_secret
dedent|''
name|'def'
name|'find_secret'
op|'('
name|'self'
op|','
name|'usage_type'
op|','
name|'usage_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Find a secret.\n\n        usage_type: one of \'iscsi\', \'ceph\', \'rbd\' or \'volume\'\n        usage_id: name of resource in secret\n        """'
newline|'\n'
name|'if'
name|'usage_type'
op|'=='
string|"'iscsi'"
op|':'
newline|'\n'
indent|'            '
name|'usage_type_const'
op|'='
name|'libvirt'
op|'.'
name|'VIR_SECRET_USAGE_TYPE_ISCSI'
newline|'\n'
dedent|''
name|'elif'
name|'usage_type'
name|'in'
op|'('
string|"'rbd'"
op|','
string|"'ceph'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'usage_type_const'
op|'='
name|'libvirt'
op|'.'
name|'VIR_SECRET_USAGE_TYPE_CEPH'
newline|'\n'
dedent|''
name|'elif'
name|'usage_type'
op|'=='
string|"'volume'"
op|':'
newline|'\n'
indent|'            '
name|'usage_type_const'
op|'='
name|'libvirt'
op|'.'
name|'VIR_SECRET_USAGE_TYPE_VOLUME'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|'"Invalid usage_type: %s"'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|'%'
name|'usage_type'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'conn'
op|'='
name|'self'
op|'.'
name|'get_connection'
op|'('
op|')'
newline|'\n'
name|'return'
name|'conn'
op|'.'
name|'secretLookupByUsage'
op|'('
name|'usage_type_const'
op|','
name|'usage_id'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'e'
op|'.'
name|'get_error_code'
op|'('
op|')'
op|'=='
name|'libvirt'
op|'.'
name|'VIR_ERR_NO_SECRET'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'None'
newline|'\n'
nl|'\n'
DECL|member|create_secret
dedent|''
dedent|''
dedent|''
name|'def'
name|'create_secret'
op|'('
name|'self'
op|','
name|'usage_type'
op|','
name|'usage_id'
op|','
name|'password'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a secret.\n\n        usage_type: one of \'iscsi\', \'ceph\', \'rbd\' or \'volume\'\n                           \'rbd\' will be converted to \'ceph\'.\n        usage_id: name of resource in secret\n        """'
newline|'\n'
name|'secret_conf'
op|'='
name|'vconfig'
op|'.'
name|'LibvirtConfigSecret'
op|'('
op|')'
newline|'\n'
name|'secret_conf'
op|'.'
name|'ephemeral'
op|'='
name|'False'
newline|'\n'
name|'secret_conf'
op|'.'
name|'private'
op|'='
name|'False'
newline|'\n'
name|'secret_conf'
op|'.'
name|'usage_id'
op|'='
name|'usage_id'
newline|'\n'
name|'if'
name|'usage_type'
name|'in'
op|'('
string|"'rbd'"
op|','
string|"'ceph'"
op|')'
op|':'
newline|'\n'
indent|'            '
name|'secret_conf'
op|'.'
name|'usage_type'
op|'='
string|"'ceph'"
newline|'\n'
dedent|''
name|'elif'
name|'usage_type'
op|'=='
string|"'iscsi'"
op|':'
newline|'\n'
indent|'            '
name|'secret_conf'
op|'.'
name|'usage_type'
op|'='
string|"'iscsi'"
newline|'\n'
dedent|''
name|'elif'
name|'usage_type'
op|'=='
string|"'volume'"
op|':'
newline|'\n'
indent|'            '
name|'secret_conf'
op|'.'
name|'usage_type'
op|'='
string|"'volume'"
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'msg'
op|'='
name|'_'
op|'('
string|'"Invalid usage_type: %s"'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'NovaException'
op|'('
name|'msg'
op|'%'
name|'usage_type'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'xml'
op|'='
name|'secret_conf'
op|'.'
name|'to_xml'
op|'('
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|"'Secret XML: %s'"
op|'%'
name|'xml'
op|')'
newline|'\n'
name|'conn'
op|'='
name|'self'
op|'.'
name|'get_connection'
op|'('
op|')'
newline|'\n'
name|'secret'
op|'='
name|'conn'
op|'.'
name|'secretDefineXML'
op|'('
name|'xml'
op|')'
newline|'\n'
name|'if'
name|'password'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'secret'
op|'.'
name|'setValue'
op|'('
name|'password'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'secret'
newline|'\n'
dedent|''
name|'except'
name|'libvirt'
op|'.'
name|'libvirtError'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_LE'
op|'('
string|"'Error defining a secret with XML: %s'"
op|')'
op|'%'
name|'xml'
op|')'
newline|'\n'
nl|'\n'
DECL|member|delete_secret
dedent|''
dedent|''
dedent|''
name|'def'
name|'delete_secret'
op|'('
name|'self'
op|','
name|'usage_type'
op|','
name|'usage_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Delete a secret.\n\n        usage_type: one of \'iscsi\', \'ceph\', \'rbd\' or \'volume\'\n        usage_id: name of resource in secret\n        """'
newline|'\n'
name|'secret'
op|'='
name|'self'
op|'.'
name|'find_secret'
op|'('
name|'usage_type'
op|','
name|'usage_id'
op|')'
newline|'\n'
name|'if'
name|'secret'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'secret'
op|'.'
name|'undefine'
op|'('
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
