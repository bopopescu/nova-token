begin_unit
comment|'# Copyright 2011 Justin Santa Barbara'
nl|'\n'
comment|'# All Rights Reserved.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
nl|'\n'
string|'"""\nDriver base-classes:\n\n    (Beginning of) the contract that compute drivers must follow, and shared\n    types that support that contract\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'sys'
newline|'\n'
nl|'\n'
name|'from'
name|'oslo'
op|'.'
name|'config'
name|'import'
name|'cfg'
newline|'\n'
nl|'\n'
name|'from'
name|'nova'
op|'.'
name|'i18n'
name|'import'
name|'_'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'importutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'log'
name|'as'
name|'logging'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'utils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'event'
name|'as'
name|'virtevent'
newline|'\n'
nl|'\n'
DECL|variable|driver_opts
name|'driver_opts'
op|'='
op|'['
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'compute_driver'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Driver to use for controlling virtualization. Options '"
nl|'\n'
string|"'include: libvirt.LibvirtDriver, xenapi.XenAPIDriver, '"
nl|'\n'
string|"'fake.FakeDriver, baremetal.BareMetalDriver, '"
nl|'\n'
string|"'vmwareapi.VMwareVCDriver, hyperv.HyperVDriver'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'default_ephemeral_format'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'The default format an ephemeral_volume will be '"
nl|'\n'
string|"'formatted with on creation.'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'preallocate_images'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'none'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'VM image preallocation mode: '"
nl|'\n'
string|'\'"none" => no storage provisioning is done up front, \''
nl|'\n'
string|'\'"space" => storage is fully allocated at instance start\''
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'BoolOpt'
op|'('
string|"'use_cow_images'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
name|'True'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Whether to use cow images'"
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'BoolOpt'
op|'('
string|"'vif_plugging_is_fatal'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
name|'True'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|'"Fail instance boot if vif plugging fails"'
op|')'
op|','
nl|'\n'
name|'cfg'
op|'.'
name|'IntOpt'
op|'('
string|"'vif_plugging_timeout'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
number|'300'
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Number of seconds to wait for neutron vif plugging '"
nl|'\n'
string|"'events to arrive before continuing or failing (see '"
nl|'\n'
string|"'vif_plugging_is_fatal). If this is set to zero and '"
nl|'\n'
string|"'vif_plugging_is_fatal is False, events should not '"
nl|'\n'
string|"'be expected to arrive at all.'"
op|')'
op|','
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
DECL|variable|CONF
name|'CONF'
op|'='
name|'cfg'
op|'.'
name|'CONF'
newline|'\n'
name|'CONF'
op|'.'
name|'register_opts'
op|'('
name|'driver_opts'
op|')'
newline|'\n'
DECL|variable|LOG
name|'LOG'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|driver_dict_from_config
name|'def'
name|'driver_dict_from_config'
op|'('
name|'named_driver_config'
op|','
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'driver_registry'
op|'='
name|'dict'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'for'
name|'driver_str'
name|'in'
name|'named_driver_config'
op|':'
newline|'\n'
indent|'        '
name|'driver_type'
op|','
name|'_sep'
op|','
name|'driver'
op|'='
name|'driver_str'
op|'.'
name|'partition'
op|'('
string|"'='"
op|')'
newline|'\n'
name|'driver_class'
op|'='
name|'importutils'
op|'.'
name|'import_class'
op|'('
name|'driver'
op|')'
newline|'\n'
name|'driver_registry'
op|'['
name|'driver_type'
op|']'
op|'='
name|'driver_class'
op|'('
op|'*'
name|'args'
op|','
op|'**'
name|'kwargs'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'driver_registry'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|block_device_info_get_root
dedent|''
name|'def'
name|'block_device_info_get_root'
op|'('
name|'block_device_info'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'block_device_info'
op|'='
name|'block_device_info'
name|'or'
op|'{'
op|'}'
newline|'\n'
name|'return'
name|'block_device_info'
op|'.'
name|'get'
op|'('
string|"'root_device_name'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|block_device_info_get_swap
dedent|''
name|'def'
name|'block_device_info_get_swap'
op|'('
name|'block_device_info'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'block_device_info'
op|'='
name|'block_device_info'
name|'or'
op|'{'
op|'}'
newline|'\n'
name|'return'
name|'block_device_info'
op|'.'
name|'get'
op|'('
string|"'swap'"
op|')'
name|'or'
op|'{'
string|"'device_name'"
op|':'
name|'None'
op|','
nl|'\n'
string|"'swap_size'"
op|':'
number|'0'
op|'}'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|swap_is_usable
dedent|''
name|'def'
name|'swap_is_usable'
op|'('
name|'swap'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'return'
name|'swap'
name|'and'
name|'swap'
op|'['
string|"'device_name'"
op|']'
name|'and'
name|'swap'
op|'['
string|"'swap_size'"
op|']'
op|'>'
number|'0'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|block_device_info_get_ephemerals
dedent|''
name|'def'
name|'block_device_info_get_ephemerals'
op|'('
name|'block_device_info'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'block_device_info'
op|'='
name|'block_device_info'
name|'or'
op|'{'
op|'}'
newline|'\n'
name|'ephemerals'
op|'='
name|'block_device_info'
op|'.'
name|'get'
op|'('
string|"'ephemerals'"
op|')'
name|'or'
op|'['
op|']'
newline|'\n'
name|'return'
name|'ephemerals'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|block_device_info_get_mapping
dedent|''
name|'def'
name|'block_device_info_get_mapping'
op|'('
name|'block_device_info'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'block_device_info'
op|'='
name|'block_device_info'
name|'or'
op|'{'
op|'}'
newline|'\n'
name|'block_device_mapping'
op|'='
name|'block_device_info'
op|'.'
name|'get'
op|'('
string|"'block_device_mapping'"
op|')'
name|'or'
op|'['
op|']'
newline|'\n'
name|'return'
name|'block_device_mapping'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|ComputeDriver
dedent|''
name|'class'
name|'ComputeDriver'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Base class for compute drivers.\n\n    The interface to this class talks in terms of \'instances\' (Amazon EC2 and\n    internal Nova terminology), by which we mean \'running virtual machine\'\n    (XenAPI terminology) or domain (Xen or libvirt terminology).\n\n    An instance has an ID, which is the identifier chosen by Nova to represent\n    the instance further up the stack.  This is unfortunately also called a\n    \'name\' elsewhere.  As far as this layer is concerned, \'instance ID\' and\n    \'instance name\' are synonyms.\n\n    Note that the instance ID or name is not human-readable or\n    customer-controlled -- it\'s an internal ID chosen by Nova.  At the\n    nova.virt layer, instances do not have human-readable names at all -- such\n    things are only known higher up the stack.\n\n    Most virtualization platforms will also have their own identity schemes,\n    to uniquely identify a VM or domain.  These IDs must stay internal to the\n    platform-specific layer, and never escape the connection interface.  The\n    platform-specific layer is responsible for keeping track of which instance\n    ID maps to which platform-specific ID, and vice versa.\n\n    Some methods here take an instance of nova.compute.service.Instance.  This\n    is the data structure used by nova.compute to store details regarding an\n    instance, and pass them into this layer.  This layer is responsible for\n    translating that generic data structure into terms that are specific to the\n    virtualization platform.\n\n    """'
newline|'\n'
nl|'\n'
DECL|variable|capabilities
name|'capabilities'
op|'='
op|'{'
nl|'\n'
string|'"has_imagecache"'
op|':'
name|'False'
op|','
nl|'\n'
string|'"supports_recreate"'
op|':'
name|'False'
op|','
nl|'\n'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'virtapi'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'virtapi'
op|'='
name|'virtapi'
newline|'\n'
name|'self'
op|'.'
name|'_compute_event_callback'
op|'='
name|'None'
newline|'\n'
nl|'\n'
DECL|member|init_host
dedent|''
name|'def'
name|'init_host'
op|'('
name|'self'
op|','
name|'host'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Initialize anything that is necessary for the driver to function,\n        including catching up with currently running VM\'s on the given host.\n        """'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|cleanup_host
dedent|''
name|'def'
name|'cleanup_host'
op|'('
name|'self'
op|','
name|'host'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Clean up anything that is necessary for the driver gracefully stop,\n        including ending remote sessions. This is optional.\n        """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|get_info
dedent|''
name|'def'
name|'get_info'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the current status of an instance, by name (not ID!)\n\n        :param instance: nova.objects.instance.Instance object\n\n        Returns a dict containing:\n\n        :state:           the running state, one of the power_state codes\n        :max_mem:         (int) the maximum memory in KBytes allowed\n        :mem:             (int) the memory in KBytes used by the domain\n        :num_cpu:         (int) the number of virtual CPUs for the domain\n        :cpu_time:        (int) the CPU time used in nanoseconds\n        """'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_num_instances
dedent|''
name|'def'
name|'get_num_instances'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the total number of virtual machines.\n\n        Return the number of virtual machines that the hypervisor knows\n        about.\n\n        .. note::\n\n            This implementation works for all drivers, but it is\n            not particularly efficient. Maintainers of the virt drivers are\n            encouraged to override this method with something more\n            efficient.\n        """'
newline|'\n'
name|'return'
name|'len'
op|'('
name|'self'
op|'.'
name|'list_instances'
op|'('
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|instance_exists
dedent|''
name|'def'
name|'instance_exists'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Checks existence of an instance on the host.\n\n        :param instance: The instance to lookup\n\n        Returns True if an instance with the supplied ID exists on\n        the host, False otherwise.\n\n        .. note::\n\n            This implementation works for all drivers, but it is\n            not particularly efficient. Maintainers of the virt drivers are\n            encouraged to override this method with something more\n            efficient.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'instance'
op|'.'
name|'uuid'
name|'in'
name|'self'
op|'.'
name|'list_instance_uuids'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'NotImplementedError'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'instance'
op|'.'
name|'name'
name|'in'
name|'self'
op|'.'
name|'list_instances'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|estimate_instance_overhead
dedent|''
dedent|''
name|'def'
name|'estimate_instance_overhead'
op|'('
name|'self'
op|','
name|'instance_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Estimate the virtualization overhead required to build an instance\n        of the given flavor.\n\n        Defaults to zero, drivers should override if per-instance overhead\n        calculations are desired.\n\n        :param instance_info: Instance/flavor to calculate overhead for.\n        :returns: Dict of estimated overhead values.\n        """'
newline|'\n'
name|'return'
op|'{'
string|"'memory_mb'"
op|':'
number|'0'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|list_instances
dedent|''
name|'def'
name|'list_instances'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the names of all the instances known to the virtualization\n        layer, as a list.\n        """'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|list_instance_uuids
dedent|''
name|'def'
name|'list_instance_uuids'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return the UUIDS of all the instances known to the virtualization\n        layer, as a list.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|rebuild
dedent|''
name|'def'
name|'rebuild'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'injected_files'
op|','
nl|'\n'
name|'admin_password'
op|','
name|'bdms'
op|','
name|'detach_block_devices'
op|','
nl|'\n'
name|'attach_block_devices'
op|','
name|'network_info'
op|'='
name|'None'
op|','
nl|'\n'
name|'recreate'
op|'='
name|'False'
op|','
name|'block_device_info'
op|'='
name|'None'
op|','
nl|'\n'
name|'preserve_ephemeral'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Destroy and re-make this instance.\n\n        A \'rebuild\' effectively purges all existing data from the system and\n        remakes the VM with given \'metadata\' and \'personalities\'.\n\n        This base class method shuts down the VM, detaches all block devices,\n        then spins up the new VM afterwards. It may be overridden by\n        hypervisors that need to - e.g. for optimisations, or when the \'VM\'\n        is actually proxied and needs to be held across the shutdown + spin\n        up steps.\n\n        :param context: security context\n        :param instance: nova.objects.instance.Instance\n                         This function should use the data there to guide\n                         the creation of the new instance.\n        :param image_meta: image object returned by nova.image.glance that\n                           defines the image from which to boot this instance\n        :param injected_files: User files to inject into instance.\n        :param admin_password: Administrator password to set in instance.\n        :param bdms: block-device-mappings to use for rebuild\n        :param detach_block_devices: function to detach block devices. See\n            nova.compute.manager.ComputeManager:_rebuild_default_impl for\n            usage.\n        :param attach_block_devices: function to attach block devices. See\n            nova.compute.manager.ComputeManager:_rebuild_default_impl for\n            usage.\n        :param network_info:\n           :py:meth:`~nova.network.manager.NetworkManager.get_instance_nw_info`\n        :param recreate: True if the instance is being recreated on a new\n            hypervisor - all the cleanup of old state is skipped.\n        :param block_device_info: Information about block devices to be\n                                  attached to the instance.\n        :param preserve_ephemeral: True if the default ephemeral storage\n                                   partition must be preserved on rebuild\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|spawn
dedent|''
name|'def'
name|'spawn'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'injected_files'
op|','
nl|'\n'
name|'admin_password'
op|','
name|'network_info'
op|'='
name|'None'
op|','
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create a new instance/VM/domain on the virtualization platform.\n\n        Once this successfully completes, the instance should be\n        running (power_state.RUNNING).\n\n        If this fails, any partial instance should be completely\n        cleaned up, and the virtualization platform should be in the state\n        that it was before this call began.\n\n        :param context: security context\n        :param instance: nova.objects.instance.Instance\n                         This function should use the data there to guide\n                         the creation of the new instance.\n        :param image_meta: image object returned by nova.image.glance that\n                           defines the image from which to boot this instance\n        :param injected_files: User files to inject into instance.\n        :param admin_password: Administrator password to set in instance.\n        :param network_info:\n           :py:meth:`~nova.network.manager.NetworkManager.get_instance_nw_info`\n        :param block_device_info: Information about block devices to be\n                                  attached to the instance.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|destroy
dedent|''
name|'def'
name|'destroy'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|'='
name|'None'
op|','
nl|'\n'
name|'destroy_disks'
op|'='
name|'True'
op|','
name|'migrate_data'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Destroy the specified instance from the Hypervisor.\n\n        If the instance is not found (for example if networking failed), this\n        function should still succeed.  It\'s probably a good idea to log a\n        warning in that case.\n\n        :param context: security context\n        :param instance: Instance object as returned by DB layer.\n        :param network_info:\n           :py:meth:`~nova.network.manager.NetworkManager.get_instance_nw_info`\n        :param block_device_info: Information about block devices that should\n                                  be detached from the instance.\n        :param destroy_disks: Indicates if disks should be destroyed\n        :param migrate_data: implementation specific params\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|cleanup
dedent|''
name|'def'
name|'cleanup'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|'='
name|'None'
op|','
nl|'\n'
name|'destroy_disks'
op|'='
name|'True'
op|','
name|'migrate_data'
op|'='
name|'None'
op|','
name|'destroy_vifs'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Cleanup the instance resources .\n\n        Instance should have been destroyed from the Hypervisor before calling\n        this method.\n\n        :param context: security context\n        :param instance: Instance object as returned by DB layer.\n        :param network_info:\n           :py:meth:`~nova.network.manager.NetworkManager.get_instance_nw_info`\n        :param block_device_info: Information about block devices that should\n                                  be detached from the instance.\n        :param destroy_disks: Indicates if disks should be destroyed\n        :param migrate_data: implementation specific params\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|reboot
dedent|''
name|'def'
name|'reboot'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'reboot_type'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'bad_volumes_callback'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Reboot the specified instance.\n\n        After this is called successfully, the instance\'s state\n        goes back to power_state.RUNNING. The virtualization\n        platform should ensure that the reboot action has completed\n        successfully even in cases in which the underlying domain/vm\n        is paused or halted/stopped.\n\n        :param instance: nova.objects.instance.Instance\n        :param network_info:\n           :py:meth:`~nova.network.manager.NetworkManager.get_instance_nw_info`\n        :param reboot_type: Either a HARD or SOFT reboot\n        :param block_device_info: Info pertaining to attached volumes\n        :param bad_volumes_callback: Function to handle any bad volumes\n            encountered\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_console_pool_info
dedent|''
name|'def'
name|'get_console_pool_info'
op|'('
name|'self'
op|','
name|'console_type'
op|')'
op|':'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
indent|'        '
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_console_output
dedent|''
name|'def'
name|'get_console_output'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get console output for an instance\n\n        :param context: security context\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_vnc_console
dedent|''
name|'def'
name|'get_vnc_console'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get connection info for a vnc console.\n\n        :param context: security context\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_spice_console
dedent|''
name|'def'
name|'get_spice_console'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get connection info for a spice console.\n\n        :param context: security context\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_rdp_console
dedent|''
name|'def'
name|'get_rdp_console'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get connection info for a rdp console.\n\n        :param context: security context\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_diagnostics
dedent|''
name|'def'
name|'get_diagnostics'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return data about VM diagnostics.\n\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_instance_diagnostics
dedent|''
name|'def'
name|'get_instance_diagnostics'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return data about VM diagnostics.\n\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_all_bw_counters
dedent|''
name|'def'
name|'get_all_bw_counters'
op|'('
name|'self'
op|','
name|'instances'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return bandwidth usage counters for each interface on each\n           running VM.\n\n        :param instances: nova.objects.instance.InstanceList\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_all_volume_usage
dedent|''
name|'def'
name|'get_all_volume_usage'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'compute_host_bdms'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return usage info for volumes attached to vms on\n           a given host.-\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_host_ip_addr
dedent|''
name|'def'
name|'get_host_ip_addr'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieves the IP address of the dom0\n        """'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|attach_volume
dedent|''
name|'def'
name|'attach_volume'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'connection_info'
op|','
name|'instance'
op|','
name|'mountpoint'
op|','
nl|'\n'
name|'disk_bus'
op|'='
name|'None'
op|','
name|'device_type'
op|'='
name|'None'
op|','
name|'encryption'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Attach the disk to the instance at mountpoint using info."""'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|detach_volume
dedent|''
name|'def'
name|'detach_volume'
op|'('
name|'self'
op|','
name|'connection_info'
op|','
name|'instance'
op|','
name|'mountpoint'
op|','
nl|'\n'
name|'encryption'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Detach the disk attached to the instance."""'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|swap_volume
dedent|''
name|'def'
name|'swap_volume'
op|'('
name|'self'
op|','
name|'old_connection_info'
op|','
name|'new_connection_info'
op|','
nl|'\n'
name|'instance'
op|','
name|'mountpoint'
op|','
name|'resize_to'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Replace the disk attached to the instance.\n\n        :param instance: nova.objects.instance.Instance\n        :param resize_to: This parameter is used to indicate the new volume\n                          size when the new volume lager than old volume.\n                          And the units is Gigabyte.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|attach_interface
dedent|''
name|'def'
name|'attach_interface'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'vif'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Attach an interface to the instance.\n\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|detach_interface
dedent|''
name|'def'
name|'detach_interface'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'vif'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Detach an interface from the instance.\n\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|migrate_disk_and_power_off
dedent|''
name|'def'
name|'migrate_disk_and_power_off'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
nl|'\n'
name|'flavor'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Transfers the disk of a running instance in multiple phases, turning\n        off the instance before the end.\n\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|snapshot
dedent|''
name|'def'
name|'snapshot'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'image_id'
op|','
name|'update_task_state'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Snapshots the specified instance.\n\n        :param context: security context\n        :param instance: nova.objects.instance.Instance\n        :param image_id: Reference to a pre-created image that will\n                         hold the snapshot.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|finish_migration
dedent|''
name|'def'
name|'finish_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'migration'
op|','
name|'instance'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'network_info'
op|','
name|'image_meta'
op|','
name|'resize_instance'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'power_on'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Completes a resize.\n\n        :param context: the context for the migration/resize\n        :param migration: the migrate/resize information\n        :param instance: nova.objects.instance.Instance being migrated/resized\n        :param disk_info: the newly transferred disk information\n        :param network_info:\n           :py:meth:`~nova.network.manager.NetworkManager.get_instance_nw_info`\n        :param image_meta: image object returned by nova.image.glance that\n                           defines the image from which this instance\n                           was created\n        :param resize_instance: True if the instance is being resized,\n                                False otherwise\n        :param block_device_info: instance volume block device info\n        :param power_on: True if the instance should be powered on, False\n                         otherwise\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|confirm_migration
dedent|''
name|'def'
name|'confirm_migration'
op|'('
name|'self'
op|','
name|'migration'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Confirms a resize, destroying the source VM.\n\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|finish_revert_migration
dedent|''
name|'def'
name|'finish_revert_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'power_on'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Finish reverting a resize.\n\n        :param context: the context for the finish_revert_migration\n        :param instance: nova.objects.instance.Instance being migrated/resized\n        :param network_info:\n           :py:meth:`~nova.network.manager.NetworkManager.get_instance_nw_info`\n        :param block_device_info: instance volume block device info\n        :param power_on: True if the instance should be powered on, False\n                         otherwise\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|pause
dedent|''
name|'def'
name|'pause'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Pause the specified instance.\n\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|unpause
dedent|''
name|'def'
name|'unpause'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Unpause paused VM instance.\n\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|suspend
dedent|''
name|'def'
name|'suspend'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""suspend the specified instance.\n\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|resume
dedent|''
name|'def'
name|'resume'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""resume the specified instance.\n\n        :param context: the context for the resume\n        :param instance: nova.objects.instance.Instance being resumed\n        :param network_info:\n           :py:meth:`~nova.network.manager.NetworkManager.get_instance_nw_info`\n        :param block_device_info: instance volume block device info\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|resume_state_on_host_boot
dedent|''
name|'def'
name|'resume_state_on_host_boot'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""resume guest state when a host is booted.\n\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|rescue
dedent|''
name|'def'
name|'rescue'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'rescue_password'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Rescue the specified instance.\n\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|set_bootable
dedent|''
name|'def'
name|'set_bootable'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'is_bootable'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Set the ability to power on/off an instance.\n\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|unrescue
dedent|''
name|'def'
name|'unrescue'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Unrescue the specified instance.\n\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|power_off
dedent|''
name|'def'
name|'power_off'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Power off the specified instance.\n\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|power_on
dedent|''
name|'def'
name|'power_on'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Power on the specified instance.\n\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|soft_delete
dedent|''
name|'def'
name|'soft_delete'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Soft delete the specified instance.\n\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|restore
dedent|''
name|'def'
name|'restore'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Restore the specified instance.\n\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_available_resource
dedent|''
name|'def'
name|'get_available_resource'
op|'('
name|'self'
op|','
name|'nodename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve resource information.\n\n        This method is called when nova-compute launches, and\n        as part of a periodic task that records the results in the DB.\n\n        :param nodename:\n            node which the caller want to get resources from\n            a driver that manages only one node can safely ignore this\n        :returns: Dictionary describing resources\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|pre_live_migration
dedent|''
name|'def'
name|'pre_live_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'block_device_info'
op|','
nl|'\n'
name|'network_info'
op|','
name|'disk_info'
op|','
name|'migrate_data'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Prepare an instance for live migration\n\n        :param context: security context\n        :param instance: nova.objects.instance.Instance object\n        :param block_device_info: instance block device information\n        :param network_info: instance network information\n        :param disk_info: instance disk information\n        :param migrate_data: implementation specific data dict.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|live_migration
dedent|''
name|'def'
name|'live_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
nl|'\n'
name|'post_method'
op|','
name|'recover_method'
op|','
name|'block_migration'
op|'='
name|'False'
op|','
nl|'\n'
name|'migrate_data'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Live migration of an instance to another host.\n\n        :param context: security context\n        :param instance:\n            nova.db.sqlalchemy.models.Instance object\n            instance object that is migrated.\n        :param dest: destination host\n        :param post_method:\n            post operation method.\n            expected nova.compute.manager._post_live_migration.\n        :param recover_method:\n            recovery method when any exception occurs.\n            expected nova.compute.manager._rollback_live_migration.\n        :param block_migration: if true, migrate VM disk.\n        :param migrate_data: implementation specific params.\n\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|rollback_live_migration_at_destination
dedent|''
name|'def'
name|'rollback_live_migration_at_destination'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|','
nl|'\n'
name|'destroy_disks'
op|'='
name|'True'
op|','
nl|'\n'
name|'migrate_data'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Clean up destination node after a failed live migration.\n\n        :param context: security context\n        :param instance: instance object that was being migrated\n        :param network_info: instance network information\n        :param block_device_info: instance block device information\n        :param destroy_disks:\n            if true, destroy disks at destination during cleanup\n        :param migrate_data: implementation specific params\n\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|post_live_migration
dedent|''
name|'def'
name|'post_live_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'block_device_info'
op|','
nl|'\n'
name|'migrate_data'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Post operation of live migration at source host.\n\n        :param context: security context\n        :instance: instance object that was migrated\n        :block_device_info: instance block device information\n        :param migrate_data: if not None, it is a dict which has data\n        """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|post_live_migration_at_source
dedent|''
name|'def'
name|'post_live_migration_at_source'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Unplug VIFs from networks at source.\n\n        :param context: security context\n        :param instance: instance object reference\n        :param network_info: instance network information\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
name|'_'
op|'('
string|'"Hypervisor driver does not support "'
nl|'\n'
string|'"post_live_migration_at_source method"'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|post_live_migration_at_destination
dedent|''
name|'def'
name|'post_live_migration_at_destination'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'network_info'
op|','
nl|'\n'
name|'block_migration'
op|'='
name|'False'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Post operation of live migration at destination host.\n\n        :param context: security context\n        :param instance: instance object that is migrated\n        :param network_info: instance network information\n        :param block_migration: if true, post operation of block_migration.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|check_instance_shared_storage_local
dedent|''
name|'def'
name|'check_instance_shared_storage_local'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check if instance files located on shared storage.\n\n        This runs check on the destination host, and then calls\n        back to the source host to check the results.\n\n        :param context: security context\n        :param instance: nova.db.sqlalchemy.models.Instance\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|check_instance_shared_storage_remote
dedent|''
name|'def'
name|'check_instance_shared_storage_remote'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check if instance files located on shared storage.\n\n        :param context: security context\n        :param data: result of check_instance_shared_storage_local\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|check_instance_shared_storage_cleanup
dedent|''
name|'def'
name|'check_instance_shared_storage_cleanup'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Do cleanup on host after check_instance_shared_storage calls\n\n        :param context: security context\n        :param data: result of check_instance_shared_storage_local\n        """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|check_can_live_migrate_destination
dedent|''
name|'def'
name|'check_can_live_migrate_destination'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'src_compute_info'
op|','
name|'dst_compute_info'
op|','
nl|'\n'
name|'block_migration'
op|'='
name|'False'
op|','
nl|'\n'
name|'disk_over_commit'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check if it is possible to execute live migration.\n\n        This runs checks on the destination host, and then calls\n        back to the source host to check the results.\n\n        :param context: security context\n        :param instance: nova.db.sqlalchemy.models.Instance\n        :param src_compute_info: Info about the sending machine\n        :param dst_compute_info: Info about the receiving machine\n        :param block_migration: if true, prepare for block migration\n        :param disk_over_commit: if true, allow disk over commit\n        :returns: a dict containing migration info (hypervisor-dependent)\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|check_can_live_migrate_destination_cleanup
dedent|''
name|'def'
name|'check_can_live_migrate_destination_cleanup'
op|'('
name|'self'
op|','
name|'context'
op|','
nl|'\n'
name|'dest_check_data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Do required cleanup on dest host after check_can_live_migrate calls\n\n        :param context: security context\n        :param dest_check_data: result of check_can_live_migrate_destination\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|check_can_live_migrate_source
dedent|''
name|'def'
name|'check_can_live_migrate_source'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'dest_check_data'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check if it is possible to execute live migration.\n\n        This checks if the live migration can succeed, based on the\n        results from check_can_live_migrate_destination.\n\n        :param context: security context\n        :param instance: nova.db.sqlalchemy.models.Instance\n        :param dest_check_data: result of check_can_live_migrate_destination\n        :returns: a dict containing migration info (hypervisor-dependent)\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_instance_disk_info
dedent|''
name|'def'
name|'get_instance_disk_info'
op|'('
name|'self'
op|','
name|'instance_name'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Retrieve information about actual disk sizes of an instance.\n\n        :param instance_name:\n            name of a nova instance as returned by list_instances()\n        :param block_device_info:\n            Optional; Can be used to filter out devices which are\n            actually volumes.\n        :return:\n            json strings with below format::\n\n                "[{\'path\':\'disk\',\n                   \'type\':\'raw\',\n                   \'virt_disk_size\':\'10737418240\',\n                   \'backing_file\':\'backing_file\',\n                   \'disk_size\':\'83886080\'\n                   \'over_committed_disk_size\':\'10737418240\'},\n                   ...]"\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|refresh_security_group_rules
dedent|''
name|'def'
name|'refresh_security_group_rules'
op|'('
name|'self'
op|','
name|'security_group_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""This method is called after a change to security groups.\n\n        All security groups and their associated rules live in the datastore,\n        and calling this method should apply the updated rules to instances\n        running the specified security group.\n\n        An error should be raised if the operation cannot complete.\n\n        """'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|refresh_security_group_members
dedent|''
name|'def'
name|'refresh_security_group_members'
op|'('
name|'self'
op|','
name|'security_group_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""This method is called when a security group is added to an instance.\n\n        This message is sent to the virtualization drivers on hosts that are\n        running an instance that belongs to a security group that has a rule\n        that references the security group identified by `security_group_id`.\n        It is the responsibility of this method to make sure any rules\n        that authorize traffic flow with members of the security group are\n        updated and any new members can communicate, and any removed members\n        cannot.\n\n        Scenario:\n            * we are running on host \'H0\' and we have an instance \'i-0\'.\n            * instance \'i-0\' is a member of security group \'speaks-b\'\n            * group \'speaks-b\' has an ingress rule that authorizes group \'b\'\n            * another host \'H1\' runs an instance \'i-1\'\n            * instance \'i-1\' is a member of security group \'b\'\n\n            When \'i-1\' launches or terminates we will receive the message\n            to update members of group \'b\', at which time we will make\n            any changes needed to the rules for instance \'i-0\' to allow\n            or deny traffic coming from \'i-1\', depending on if it is being\n            added or removed from the group.\n\n        In this scenario, \'i-1\' could just as easily have been running on our\n        host \'H0\' and this method would still have been called.  The point was\n        that this method isn\'t called on the host where instances of that\n        group are running (as is the case with\n        :py:meth:`refresh_security_group_rules`) but is called where references\n        are made to authorizing those instances.\n\n        An error should be raised if the operation cannot complete.\n\n        """'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|refresh_provider_fw_rules
dedent|''
name|'def'
name|'refresh_provider_fw_rules'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""This triggers a firewall update based on database changes.\n\n        When this is called, rules have either been added or removed from the\n        datastore.  You can retrieve rules with\n        :py:meth:`nova.db.provider_fw_rule_get_all`.\n\n        Provider rules take precedence over security group rules.  If an IP\n        would be allowed by a security group ingress rule, but blocked by\n        a provider rule, then packets from the IP are dropped.  This includes\n        intra-project traffic in the case of the allow_project_net_traffic\n        flag for the libvirt-derived classes.\n\n        """'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|refresh_instance_security_rules
dedent|''
name|'def'
name|'refresh_instance_security_rules'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Refresh security group rules\n\n        Gets called when an instance gets added to or removed from\n        the security group the instance is a member of or if the\n        group gains or loses a rule.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|reset_network
dedent|''
name|'def'
name|'reset_network'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""reset networking for specified instance."""'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|ensure_filtering_rules_for_instance
dedent|''
name|'def'
name|'ensure_filtering_rules_for_instance'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Setting up filtering rules and waiting for its completion.\n\n        To migrate an instance, filtering rules to hypervisors\n        and firewalls are inevitable on destination host.\n        ( Waiting only for filtering rules to hypervisor,\n        since filtering rules to firewall rules can be set faster).\n\n        Concretely, the below method must be called.\n        - setup_basic_filtering (for nova-basic, etc.)\n        - prepare_instance_filter(for nova-instance-instance-xxx, etc.)\n\n        to_xml may have to be called since it defines PROJNET, PROJMASK.\n        but libvirt migrates those value through migrateToURI(),\n        so , no need to be called.\n\n        Don\'t use thread for this method since migration should\n        not be started when setting-up filtering rules operations\n        are not completed.\n\n        :param instance: nova.objects.instance.Instance object\n\n        """'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|filter_defer_apply_on
dedent|''
name|'def'
name|'filter_defer_apply_on'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Defer application of IPTables rules."""'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|filter_defer_apply_off
dedent|''
name|'def'
name|'filter_defer_apply_off'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Turn off deferral of IPTables rules and apply the rules now."""'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|unfilter_instance
dedent|''
name|'def'
name|'unfilter_instance'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Stop filtering instance."""'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|set_admin_password
dedent|''
name|'def'
name|'set_admin_password'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'new_pass'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Set the root password on the specified instance.\n\n        :param instance: nova.objects.instance.Instance\n        :param new_password: the new password\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|inject_file
dedent|''
name|'def'
name|'inject_file'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'b64_path'
op|','
name|'b64_contents'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Writes a file on the specified instance.\n\n        The first parameter is an instance of nova.compute.service.Instance,\n        and so the instance is being specified as instance.name. The second\n        parameter is the base64-encoded path to which the file is to be\n        written on the instance; the third is the contents of the file, also\n        base64-encoded.\n\n        NOTE(russellb) This method is deprecated and will be removed once it\n        can be removed from nova.compute.manager.\n        """'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|change_instance_metadata
dedent|''
name|'def'
name|'change_instance_metadata'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'diff'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Applies a diff to the instance metadata.\n\n        This is an optional driver method which is used to publish\n        changes to the instance\'s metadata to the hypervisor.  If the\n        hypervisor has no means of publishing the instance metadata to\n        the instance, then this method should not be implemented.\n\n        :param context: security context\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|inject_network_info
dedent|''
name|'def'
name|'inject_network_info'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'nw_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""inject network info for specified instance."""'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|poll_rebooting_instances
dedent|''
name|'def'
name|'poll_rebooting_instances'
op|'('
name|'self'
op|','
name|'timeout'
op|','
name|'instances'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Poll for rebooting instances\n\n        :param timeout: the currently configured timeout for considering\n                        rebooting instances to be stuck\n        :param instances: instances that have been in rebooting state\n                          longer than the configured timeout\n        """'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|host_power_action
dedent|''
name|'def'
name|'host_power_action'
op|'('
name|'self'
op|','
name|'host'
op|','
name|'action'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Reboots, shuts down or powers up the host."""'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|host_maintenance_mode
dedent|''
name|'def'
name|'host_maintenance_mode'
op|'('
name|'self'
op|','
name|'host'
op|','
name|'mode'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Start/Stop host maintenance window. On start, it triggers\n        guest VMs evacuation.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|set_host_enabled
dedent|''
name|'def'
name|'set_host_enabled'
op|'('
name|'self'
op|','
name|'host'
op|','
name|'enabled'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Sets the specified host\'s ability to accept new instances."""'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_host_uptime
dedent|''
name|'def'
name|'get_host_uptime'
op|'('
name|'self'
op|','
name|'host'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns the result of calling "uptime" on the target host."""'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|plug_vifs
dedent|''
name|'def'
name|'plug_vifs'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Plug VIFs into networks.\n\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
comment|'# TODO(Vek): Need to pass context in for access to auth_token'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|unplug_vifs
dedent|''
name|'def'
name|'unplug_vifs'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Unplug VIFs from networks.\n\n        :param instance: nova.objects.instance.Instance\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_host_stats
dedent|''
name|'def'
name|'get_host_stats'
op|'('
name|'self'
op|','
name|'refresh'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return currently known host stats.\n\n        If the hypervisor supports pci passthrough, the returned\n        dictionary includes a key-value pair for it.\n        The key of pci passthrough device is "pci_passthrough_devices"\n        and the value is a json string for the list of assignable\n        pci devices. Each device is a dictionary, with mandatory\n        keys of \'address\', \'vendor_id\', \'product_id\', \'dev_type\',\n        \'dev_id\', \'label\' and other optional device specific information.\n\n        Refer to the objects/pci_device.py for more idea of these keys.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_host_cpu_stats
dedent|''
name|'def'
name|'get_host_cpu_stats'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the currently known host CPU stats.\n\n        :returns: a dict containing the CPU stat info, eg:\n\n            | {\'kernel\': kern,\n            |  \'idle\': idle,\n            |  \'user\': user,\n            |  \'iowait\': wait,\n            |   \'frequency\': freq},\n\n                  where kern and user indicate the cumulative CPU time\n                  (nanoseconds) spent by kernel and user processes\n                  respectively, idle indicates the cumulative idle CPU time\n                  (nanoseconds), wait indicates the cumulative I/O wait CPU\n                  time (nanoseconds), since the host is booting up; freq\n                  indicates the current CPU frequency (MHz). All values are\n                  long integers.\n\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|block_stats
dedent|''
name|'def'
name|'block_stats'
op|'('
name|'self'
op|','
name|'instance_name'
op|','
name|'disk_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return performance counters associated with the given disk_id on the\n        given instance_name.  These are returned as [rd_req, rd_bytes, wr_req,\n        wr_bytes, errs], where rd indicates read, wr indicates write, req is\n        the total number of I/O requests made, bytes is the total number of\n        bytes transferred, and errs is the number of requests held up due to a\n        full pipeline.\n\n        All counters are long integers.\n\n        This method is optional.  On some platforms (e.g. XenAPI) performance\n        statistics can be retrieved directly in aggregate form, without Nova\n        having to do the aggregation.  On those platforms, this method is\n        unused.\n\n        Note that this function takes an instance ID.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|interface_stats
dedent|''
name|'def'
name|'interface_stats'
op|'('
name|'self'
op|','
name|'instance_name'
op|','
name|'iface_id'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return performance counters associated with the given iface_id\n        on the given instance_id.  These are returned as [rx_bytes, rx_packets,\n        rx_errs, rx_drop, tx_bytes, tx_packets, tx_errs, tx_drop], where rx\n        indicates receive, tx indicates transmit, bytes and packets indicate\n        the total number of bytes or packets transferred, and errs and dropped\n        is the total number of packets failed / dropped.\n\n        All counters are long integers.\n\n        This method is optional.  On some platforms (e.g. XenAPI) performance\n        statistics can be retrieved directly in aggregate form, without Nova\n        having to do the aggregation.  On those platforms, this method is\n        unused.\n\n        Note that this function takes an instance ID.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|deallocate_networks_on_reschedule
dedent|''
name|'def'
name|'deallocate_networks_on_reschedule'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Does the driver want networks deallocated on reschedule?"""'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|macs_for_instance
dedent|''
name|'def'
name|'macs_for_instance'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""What MAC addresses must this instance have?\n\n        Some hypervisors (such as bare metal) cannot do freeform virtualisation\n        of MAC addresses. This method allows drivers to return a set of MAC\n        addresses that the instance is to have. allocate_for_instance will take\n        this into consideration when provisioning networking for the instance.\n\n        Mapping of MAC addresses to actual networks (or permitting them to be\n        freeform) is up to the network implementation layer. For instance,\n        with openflow switches, fixed MAC addresses can still be virtualised\n        onto any L2 domain, with arbitrary VLANs etc, but regular switches\n        require pre-configured MAC->network mappings that will match the\n        actual configuration.\n\n        Most hypervisors can use the default implementation which returns None.\n        Hypervisors with MAC limits should return a set of MAC addresses, which\n        will be supplied to the allocate_for_instance call by the compute\n        manager, and it is up to that call to ensure that all assigned network\n        details are compatible with the set of MAC addresses.\n\n        This is called during spawn_instance by the compute manager.\n\n        :return: None, or a set of MAC ids (e.g. set([\'12:34:56:78:90:ab\'])).\n            None means \'no constraints\', a set means \'these and only these\n            MAC addresses\'.\n        """'
newline|'\n'
name|'return'
name|'None'
newline|'\n'
nl|'\n'
DECL|member|dhcp_options_for_instance
dedent|''
name|'def'
name|'dhcp_options_for_instance'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get DHCP options for this instance.\n\n        Some hypervisors (such as bare metal) require that instances boot from\n        the network, and manage their own TFTP service. This requires passing\n        the appropriate options out to the DHCP service. Most hypervisors can\n        use the default implementation which returns None.\n\n        This is called during spawn_instance by the compute manager.\n\n        Note that the format of the return value is specific to Quantum\n        client API.\n\n        :return: None, or a set of DHCP options, eg:\n\n             |    [{\'opt_name\': \'bootfile-name\',\n             |      \'opt_value\': \'/tftpboot/path/to/config\'},\n             |     {\'opt_name\': \'server-ip-address\',\n             |      \'opt_value\': \'1.2.3.4\'},\n             |     {\'opt_name\': \'tftp-server\',\n             |      \'opt_value\': \'1.2.3.4\'}\n             |    ]\n\n        """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|manage_image_cache
dedent|''
name|'def'
name|'manage_image_cache'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'all_instances'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Manage the driver\'s local image cache.\n\n        Some drivers chose to cache images for instances on disk. This method\n        is an opportunity to do management of that cache which isn\'t directly\n        related to other calls into the driver. The prime example is to clean\n        the cache and remove images which are no longer of interest.\n\n        :param instances: nova.objects.instance.InstanceList\n        """'
newline|'\n'
name|'pass'
newline|'\n'
nl|'\n'
DECL|member|add_to_aggregate
dedent|''
name|'def'
name|'add_to_aggregate'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'aggregate'
op|','
name|'host'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Add a compute host to an aggregate."""'
newline|'\n'
comment|'# NOTE(jogo) Currently only used for XenAPI-Pool'
nl|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|remove_from_aggregate
dedent|''
name|'def'
name|'remove_from_aggregate'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'aggregate'
op|','
name|'host'
op|','
op|'**'
name|'kwargs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Remove a compute host from an aggregate."""'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|undo_aggregate_operation
dedent|''
name|'def'
name|'undo_aggregate_operation'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'op'
op|','
name|'aggregate'
op|','
nl|'\n'
name|'host'
op|','
name|'set_error'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Undo for Resource Pools."""'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_volume_connector
dedent|''
name|'def'
name|'get_volume_connector'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get connector information for the instance for attaching to volumes.\n\n        Connector information is a dictionary representing the ip of the\n        machine that will be making the connection, the name of the iscsi\n        initiator and the hostname of the machine as follows::\n\n            {\n                \'ip\': ip,\n                \'initiator\': initiator,\n                \'host\': hostname\n            }\n\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_available_nodes
dedent|''
name|'def'
name|'get_available_nodes'
op|'('
name|'self'
op|','
name|'refresh'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Returns nodenames of all nodes managed by the compute service.\n\n        This method is for multi compute-nodes support. If a driver supports\n        multi compute-nodes, this method returns a list of nodenames managed\n        by the service. Otherwise, this method should return\n        [hypervisor_hostname].\n        """'
newline|'\n'
name|'stats'
op|'='
name|'self'
op|'.'
name|'get_host_stats'
op|'('
name|'refresh'
op|'='
name|'refresh'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'stats'
op|','
name|'list'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'stats'
op|'='
op|'['
name|'stats'
op|']'
newline|'\n'
dedent|''
name|'return'
op|'['
name|'s'
op|'['
string|"'hypervisor_hostname'"
op|']'
name|'for'
name|'s'
name|'in'
name|'stats'
op|']'
newline|'\n'
nl|'\n'
DECL|member|node_is_available
dedent|''
name|'def'
name|'node_is_available'
op|'('
name|'self'
op|','
name|'nodename'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return whether this compute service manages a particular node."""'
newline|'\n'
name|'if'
name|'nodename'
name|'in'
name|'self'
op|'.'
name|'get_available_nodes'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
comment|'# Refresh and check again.'
nl|'\n'
dedent|''
name|'return'
name|'nodename'
name|'in'
name|'self'
op|'.'
name|'get_available_nodes'
op|'('
name|'refresh'
op|'='
name|'True'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_per_instance_usage
dedent|''
name|'def'
name|'get_per_instance_usage'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get information about instance resource usage.\n\n        :returns: dict of  nova uuid => dict of usage info\n        """'
newline|'\n'
name|'return'
op|'{'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|instance_on_disk
dedent|''
name|'def'
name|'instance_on_disk'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Checks access of instance files on the host.\n\n        :param instance: nova.objects.instance.Instance to lookup\n\n        Returns True if files of an instance with the supplied ID accessible on\n        the host, False otherwise.\n\n        .. note::\n            Used in rebuild for HA implementation and required for validation\n            of access to instance shared disk files\n        """'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
nl|'\n'
DECL|member|register_event_listener
dedent|''
name|'def'
name|'register_event_listener'
op|'('
name|'self'
op|','
name|'callback'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Register a callback to receive events.\n\n        Register a callback to receive asynchronous event\n        notifications from hypervisors. The callback will\n        be invoked with a single parameter, which will be\n        an instance of the nova.virt.event.Event class.\n        """'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'_compute_event_callback'
op|'='
name|'callback'
newline|'\n'
nl|'\n'
DECL|member|emit_event
dedent|''
name|'def'
name|'emit_event'
op|'('
name|'self'
op|','
name|'event'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Dispatches an event to the compute manager.\n\n        Invokes the event callback registered by the\n        compute manager to dispatch the event. This\n        must only be invoked from a green thread.\n        """'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_compute_event_callback'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Discarding event %s"'
op|','
name|'str'
op|'('
name|'event'
op|')'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'isinstance'
op|'('
name|'event'
op|','
name|'virtevent'
op|'.'
name|'Event'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'ValueError'
op|'('
nl|'\n'
name|'_'
op|'('
string|'"Event must be an instance of nova.virt.event.Event"'
op|')'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
string|'"Emitting event %s"'
op|','
name|'str'
op|'('
name|'event'
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_compute_event_callback'
op|'('
name|'event'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'ex'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|'"Exception dispatching event %(event)s: %(ex)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'event'"
op|':'
name|'event'
op|','
string|"'ex'"
op|':'
name|'ex'
op|'}'
op|')'
newline|'\n'
nl|'\n'
DECL|member|delete_instance_files
dedent|''
dedent|''
name|'def'
name|'delete_instance_files'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Delete any lingering instance files for an instance.\n\n        :param instance: nova.objects.instance.Instance\n        :returns: True if the instance was deleted from disk, False otherwise.\n        """'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'property'
newline|'\n'
DECL|member|need_legacy_block_device_info
name|'def'
name|'need_legacy_block_device_info'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Tell the caller if the driver requires legacy block device info.\n\n        Tell the caller whether we expect the legacy format of block\n        device info to be passed in to methods that expect it.\n        """'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
nl|'\n'
DECL|member|volume_snapshot_create
dedent|''
name|'def'
name|'volume_snapshot_create'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'volume_id'
op|','
nl|'\n'
name|'create_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Snapshots volumes attached to a specified instance.\n\n        :param context: request context\n        :param instance: nova.objects.instance.Instance that has the volume\n               attached\n        :param volume_id: Volume to be snapshotted\n        :param create_info: The data needed for nova to be able to attach\n               to the volume.  This is the same data format returned by\n               Cinder\'s initialize_connection() API call.  In the case of\n               doing a snapshot, it is the image file Cinder expects to be\n               used as the active disk after the snapshot operation has\n               completed.  There may be other data included as well that is\n               needed for creating the snapshot.\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|volume_snapshot_delete
dedent|''
name|'def'
name|'volume_snapshot_delete'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'volume_id'
op|','
nl|'\n'
name|'snapshot_id'
op|','
name|'delete_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Snapshots volumes attached to a specified instance.\n\n        :param context: request context\n        :param instance: nova.objects.instance.Instance that has the volume\n               attached\n        :param volume_id: Attached volume associated with the snapshot\n        :param snapshot_id: The snapshot to delete.\n        :param delete_info: Volume backend technology specific data needed to\n               be able to complete the snapshot.  For example, in the case of\n               qcow2 backed snapshots, this would include the file being\n               merged, and the file being merged into (if appropriate).\n        """'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|default_root_device_name
dedent|''
name|'def'
name|'default_root_device_name'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'root_bdm'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Provide a default root device name for the driver."""'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|default_device_names_for_instance
dedent|''
name|'def'
name|'default_device_names_for_instance'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'root_device_name'
op|','
nl|'\n'
op|'*'
name|'block_device_lists'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Default the missing device names in the block device mapping."""'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|is_supported_fs_format
dedent|''
name|'def'
name|'is_supported_fs_format'
op|'('
name|'self'
op|','
name|'fs_type'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check whether the file format is supported by this driver\n\n        :param fs_type: the file system type to be checked,\n                        the validate values are defined at disk API module.\n        """'
newline|'\n'
comment|'# NOTE(jichenjc): Return False here so that every hypervisor'
nl|'\n'
comment|'#                 need to define their supported file system'
nl|'\n'
comment|'#                 type and implement this function at their'
nl|'\n'
comment|'#                 virt layer.'
nl|'\n'
name|'return'
name|'False'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|load_compute_driver
dedent|''
dedent|''
name|'def'
name|'load_compute_driver'
op|'('
name|'virtapi'
op|','
name|'compute_driver'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Load a compute driver module.\n\n    Load the compute driver module specified by the compute_driver\n    configuration option or, if supplied, the driver name supplied as an\n    argument.\n\n    Compute drivers constructors take a VirtAPI object as their first object\n    and this must be supplied.\n\n    :param virtapi: a VirtAPI instance\n    :param compute_driver: a compute driver name to override the config opt\n    :returns: a ComputeDriver instance\n    """'
newline|'\n'
name|'if'
name|'not'
name|'compute_driver'
op|':'
newline|'\n'
indent|'        '
name|'compute_driver'
op|'='
name|'CONF'
op|'.'
name|'compute_driver'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'compute_driver'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|'"Compute driver option required, but not specified"'
op|')'
op|')'
newline|'\n'
name|'sys'
op|'.'
name|'exit'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"Loading compute driver \'%s\'"'
op|')'
op|'%'
name|'compute_driver'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'driver'
op|'='
name|'importutils'
op|'.'
name|'import_object_ns'
op|'('
string|"'nova.virt'"
op|','
nl|'\n'
name|'compute_driver'
op|','
nl|'\n'
name|'virtapi'
op|')'
newline|'\n'
name|'return'
name|'utils'
op|'.'
name|'check_isinstance'
op|'('
name|'driver'
op|','
name|'ComputeDriver'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'_'
op|'('
string|'"Unable to load the virtualization driver"'
op|')'
op|')'
newline|'\n'
name|'sys'
op|'.'
name|'exit'
op|'('
number|'1'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|compute_driver_matches
dedent|''
dedent|''
name|'def'
name|'compute_driver_matches'
op|'('
name|'match'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'return'
name|'CONF'
op|'.'
name|'compute_driver'
name|'and'
name|'CONF'
op|'.'
name|'compute_driver'
op|'.'
name|'endswith'
op|'('
name|'match'
op|')'
newline|'\n'
dedent|''
endmarker|''
end_unit
