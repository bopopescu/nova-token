begin_unit
comment|'# Copyright (c) 2013 Hewlett-Packard Development Company, L.P.'
nl|'\n'
comment|'# Copyright (c) 2012 VMware, Inc.'
nl|'\n'
comment|'# Copyright (c) 2011 Citrix Systems, Inc.'
nl|'\n'
comment|'# Copyright 2011 OpenStack Foundation'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
nl|'\n'
string|'"""\nClass for VM tasks like spawn, snapshot, suspend, resume etc.\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'collections'
newline|'\n'
name|'import'
name|'copy'
newline|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'time'
newline|'\n'
nl|'\n'
name|'from'
name|'oslo'
op|'.'
name|'config'
name|'import'
name|'cfg'
newline|'\n'
nl|'\n'
name|'from'
name|'nova'
op|'.'
name|'api'
op|'.'
name|'metadata'
name|'import'
name|'base'
name|'as'
name|'instance_metadata'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'compute'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'power_state'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'compute'
name|'import'
name|'task_states'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'context'
name|'as'
name|'nova_context'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'exception'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'excutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
op|'.'
name|'gettextutils'
name|'import'
name|'_'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'log'
name|'as'
name|'logging'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'strutils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'units'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'openstack'
op|'.'
name|'common'
name|'import'
name|'uuidutils'
newline|'\n'
name|'from'
name|'nova'
name|'import'
name|'utils'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'configdrive'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
name|'import'
name|'driver'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'vmwareapi'
name|'import'
name|'error_util'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'vmwareapi'
name|'import'
name|'vif'
name|'as'
name|'vmwarevif'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'vmwareapi'
name|'import'
name|'vim'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'vmwareapi'
name|'import'
name|'vim_util'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'vmwareapi'
name|'import'
name|'vm_util'
newline|'\n'
name|'from'
name|'nova'
op|'.'
name|'virt'
op|'.'
name|'vmwareapi'
name|'import'
name|'vmware_images'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|vmware_vif_opts
name|'vmware_vif_opts'
op|'='
op|'['
nl|'\n'
name|'cfg'
op|'.'
name|'StrOpt'
op|'('
string|"'integration_bridge'"
op|','
nl|'\n'
DECL|variable|default
name|'default'
op|'='
string|"'br-int'"
op|','
nl|'\n'
DECL|variable|help
name|'help'
op|'='
string|"'Name of Integration Bridge'"
op|')'
op|','
nl|'\n'
op|']'
newline|'\n'
nl|'\n'
DECL|variable|vmware_group
name|'vmware_group'
op|'='
name|'cfg'
op|'.'
name|'OptGroup'
op|'('
name|'name'
op|'='
string|"'vmware'"
op|','
nl|'\n'
DECL|variable|title
name|'title'
op|'='
string|"'VMware Options'"
op|')'
newline|'\n'
nl|'\n'
DECL|variable|CONF
name|'CONF'
op|'='
name|'cfg'
op|'.'
name|'CONF'
newline|'\n'
name|'CONF'
op|'.'
name|'register_group'
op|'('
name|'vmware_group'
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'register_opts'
op|'('
name|'vmware_vif_opts'
op|','
name|'vmware_group'
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'image_cache_subdirectory_name'"
op|','
string|"'nova.virt.imagecache'"
op|')'
newline|'\n'
name|'CONF'
op|'.'
name|'import_opt'
op|'('
string|"'vnc_enabled'"
op|','
string|"'nova.vnc'"
op|')'
newline|'\n'
nl|'\n'
DECL|variable|LOG
name|'LOG'
op|'='
name|'logging'
op|'.'
name|'getLogger'
op|'('
name|'__name__'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|VMWARE_POWER_STATES
name|'VMWARE_POWER_STATES'
op|'='
op|'{'
nl|'\n'
string|"'poweredOff'"
op|':'
name|'power_state'
op|'.'
name|'SHUTDOWN'
op|','
nl|'\n'
string|"'poweredOn'"
op|':'
name|'power_state'
op|'.'
name|'RUNNING'
op|','
nl|'\n'
string|"'suspended'"
op|':'
name|'power_state'
op|'.'
name|'SUSPENDED'
op|'}'
newline|'\n'
nl|'\n'
DECL|variable|VMWARE_LINKED_CLONE
name|'VMWARE_LINKED_CLONE'
op|'='
string|"'vmware_linked_clone'"
newline|'\n'
nl|'\n'
DECL|variable|RESIZE_TOTAL_STEPS
name|'RESIZE_TOTAL_STEPS'
op|'='
number|'4'
newline|'\n'
nl|'\n'
DECL|variable|DcInfo
name|'DcInfo'
op|'='
name|'collections'
op|'.'
name|'namedtuple'
op|'('
string|"'DcInfo'"
op|','
nl|'\n'
op|'['
string|"'ref'"
op|','
string|"'name'"
op|','
string|"'vmFolder'"
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|VMwareVMOps
name|'class'
name|'VMwareVMOps'
op|'('
name|'object'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Management class for VM-related tasks."""'
newline|'\n'
nl|'\n'
DECL|member|__init__
name|'def'
name|'__init__'
op|'('
name|'self'
op|','
name|'session'
op|','
name|'virtapi'
op|','
name|'volumeops'
op|','
name|'cluster'
op|'='
name|'None'
op|','
nl|'\n'
name|'datastore_regex'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Initializer."""'
newline|'\n'
name|'self'
op|'.'
name|'compute_api'
op|'='
name|'compute'
op|'.'
name|'API'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'='
name|'session'
newline|'\n'
name|'self'
op|'.'
name|'_virtapi'
op|'='
name|'virtapi'
newline|'\n'
name|'self'
op|'.'
name|'_volumeops'
op|'='
name|'volumeops'
newline|'\n'
name|'self'
op|'.'
name|'_cluster'
op|'='
name|'cluster'
newline|'\n'
name|'self'
op|'.'
name|'_datastore_regex'
op|'='
name|'datastore_regex'
newline|'\n'
name|'self'
op|'.'
name|'_base_folder'
op|'='
name|'CONF'
op|'.'
name|'image_cache_subdirectory_name'
newline|'\n'
name|'self'
op|'.'
name|'_tmp_folder'
op|'='
string|"'vmware_temp'"
newline|'\n'
name|'self'
op|'.'
name|'_default_root_device'
op|'='
string|"'vda'"
newline|'\n'
name|'self'
op|'.'
name|'_rescue_suffix'
op|'='
string|"'-rescue'"
newline|'\n'
name|'self'
op|'.'
name|'_poll_rescue_last_ran'
op|'='
name|'None'
newline|'\n'
name|'self'
op|'.'
name|'_is_neutron'
op|'='
name|'utils'
op|'.'
name|'is_neutron'
op|'('
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_datastore_dc_mapping'
op|'='
op|'{'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|list_instances
dedent|''
name|'def'
name|'list_instances'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Lists the VM instances that are registered with the ESX host."""'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Getting list of instances"'
op|')'
op|')'
newline|'\n'
name|'vms'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
string|'"get_objects"'
op|','
nl|'\n'
string|'"VirtualMachine"'
op|','
nl|'\n'
op|'['
string|'"name"'
op|','
string|'"runtime.connectionState"'
op|']'
op|')'
newline|'\n'
name|'lst_vm_names'
op|'='
op|'['
op|']'
newline|'\n'
nl|'\n'
name|'while'
name|'vms'
op|':'
newline|'\n'
indent|'            '
name|'token'
op|'='
name|'vm_util'
op|'.'
name|'_get_token'
op|'('
name|'vms'
op|')'
newline|'\n'
name|'for'
name|'vm'
name|'in'
name|'vms'
op|'.'
name|'objects'
op|':'
newline|'\n'
indent|'                '
name|'vm_name'
op|'='
name|'None'
newline|'\n'
name|'conn_state'
op|'='
name|'None'
newline|'\n'
name|'for'
name|'prop'
name|'in'
name|'vm'
op|'.'
name|'propSet'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'prop'
op|'.'
name|'name'
op|'=='
string|'"name"'
op|':'
newline|'\n'
indent|'                        '
name|'vm_name'
op|'='
name|'prop'
op|'.'
name|'val'
newline|'\n'
dedent|''
name|'elif'
name|'prop'
op|'.'
name|'name'
op|'=='
string|'"runtime.connectionState"'
op|':'
newline|'\n'
indent|'                        '
name|'conn_state'
op|'='
name|'prop'
op|'.'
name|'val'
newline|'\n'
comment|'# Ignoring the orphaned or inaccessible VMs'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'conn_state'
name|'not'
name|'in'
op|'['
string|'"orphaned"'
op|','
string|'"inaccessible"'
op|']'
op|':'
newline|'\n'
indent|'                    '
name|'lst_vm_names'
op|'.'
name|'append'
op|'('
name|'vm_name'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'token'
op|':'
newline|'\n'
indent|'                '
name|'vms'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
nl|'\n'
string|'"continue_to_get_objects"'
op|','
nl|'\n'
name|'token'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'break'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Got total of %s instances"'
op|')'
op|'%'
name|'str'
op|'('
name|'len'
op|'('
name|'lst_vm_names'
op|')'
op|')'
op|')'
newline|'\n'
name|'return'
name|'lst_vm_names'
newline|'\n'
nl|'\n'
DECL|member|_extend_virtual_disk
dedent|''
name|'def'
name|'_extend_virtual_disk'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'requested_size'
op|','
name|'name'
op|','
name|'dc_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'service_content'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|'.'
name|'get_service_content'
op|'('
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Extending root virtual disk to %s"'
op|')'
op|','
name|'requested_size'
op|')'
newline|'\n'
name|'vmdk_extend_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"ExtendVirtualDisk_Task"'
op|','
nl|'\n'
name|'service_content'
op|'.'
name|'virtualDiskManager'
op|','
nl|'\n'
name|'name'
op|'='
name|'name'
op|','
nl|'\n'
name|'datacenter'
op|'='
name|'dc_ref'
op|','
nl|'\n'
name|'newCapacityKb'
op|'='
name|'requested_size'
op|','
nl|'\n'
name|'eagerZero'
op|'='
name|'False'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
name|'vmdk_extend_task'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|"'Extending virtual disk failed with error: %s'"
op|')'
op|','
nl|'\n'
name|'e'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
comment|'# Clean up files created during the extend operation'
nl|'\n'
name|'files'
op|'='
op|'['
name|'name'
op|'.'
name|'replace'
op|'('
string|'".vmdk"'
op|','
string|'"-flat.vmdk"'
op|')'
op|','
name|'name'
op|']'
newline|'\n'
name|'for'
name|'file'
name|'in'
name|'files'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_delete_datastore_file'
op|'('
name|'instance'
op|','
name|'file'
op|','
name|'dc_ref'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Extended root virtual disk"'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_delete_datastore_file
dedent|''
name|'def'
name|'_delete_datastore_file'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'datastore_path'
op|','
name|'dc_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Deleting the datastore file %s"'
op|')'
op|'%'
name|'datastore_path'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'vim'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
newline|'\n'
name|'file_delete_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"DeleteDatastoreFile_Task"'
op|','
nl|'\n'
name|'vim'
op|'.'
name|'get_service_content'
op|'('
op|')'
op|'.'
name|'fileManager'
op|','
nl|'\n'
name|'name'
op|'='
name|'datastore_path'
op|','
nl|'\n'
name|'datacenter'
op|'='
name|'dc_ref'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
name|'file_delete_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Deleted the datastore file"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|spawn
dedent|''
name|'def'
name|'spawn'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'image_meta'
op|','
name|'injected_files'
op|','
nl|'\n'
name|'admin_password'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|'='
name|'None'
op|','
nl|'\n'
name|'instance_name'
op|'='
name|'None'
op|','
name|'power_on'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Creates a VM instance.\n\n        Steps followed are:\n\n        1. Create a VM with no disk and the specifics in the instance object\n           like RAM size.\n        2. For flat disk\n          2.1. Create a dummy vmdk of the size of the disk file that is to be\n               uploaded. This is required just to create the metadata file.\n          2.2. Delete the -flat.vmdk file created in the above step and retain\n               the metadata .vmdk file.\n          2.3. Upload the disk file.\n        3. For sparse disk\n          3.1. Upload the disk file to a -sparse.vmdk file.\n          3.2. Copy/Clone the -sparse.vmdk file to a thin vmdk.\n          3.3. Delete the -sparse.vmdk file.\n        4. Attach the disk to the VM by reconfiguring the same.\n        5. Power on the VM.\n        """'
newline|'\n'
name|'ebs_root'
op|'='
name|'False'
newline|'\n'
name|'if'
name|'block_device_info'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Block device information present: %s"'
op|')'
nl|'\n'
op|'%'
name|'block_device_info'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'block_device_mapping'
op|'='
name|'driver'
op|'.'
name|'block_device_info_get_mapping'
op|'('
nl|'\n'
name|'block_device_info'
op|')'
newline|'\n'
name|'if'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'                '
name|'ebs_root'
op|'='
name|'True'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'client_factory'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|'.'
name|'client'
op|'.'
name|'factory'
newline|'\n'
name|'service_content'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|'.'
name|'get_service_content'
op|'('
op|')'
newline|'\n'
name|'ds'
op|'='
name|'vm_util'
op|'.'
name|'get_datastore_ref_and_name'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'self'
op|'.'
name|'_cluster'
op|','
nl|'\n'
name|'datastore_regex'
op|'='
name|'self'
op|'.'
name|'_datastore_regex'
op|')'
newline|'\n'
name|'data_store_ref'
op|'='
name|'ds'
op|'['
number|'0'
op|']'
newline|'\n'
name|'data_store_name'
op|'='
name|'ds'
op|'['
number|'1'
op|']'
newline|'\n'
name|'dc_info'
op|'='
name|'self'
op|'.'
name|'get_datacenter_ref_and_name'
op|'('
name|'data_store_ref'
op|')'
newline|'\n'
nl|'\n'
comment|'#TODO(hartsocks): this pattern is confusing, reimplement as methods'
nl|'\n'
comment|'# The use of nested functions in this file makes for a confusing and'
nl|'\n'
comment|'# hard to maintain file. At some future date, refactor this method to'
nl|'\n'
comment|'# be a full-fledged method. This will also make unit testing easier.'
nl|'\n'
DECL|function|_get_image_properties
name|'def'
name|'_get_image_properties'
op|'('
name|'root_size'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""\n            Get the Size of the flat vmdk file that is there on the storage\n            repository.\n            """'
newline|'\n'
name|'image_ref'
op|'='
name|'instance'
op|'.'
name|'get'
op|'('
string|"'image_ref'"
op|')'
newline|'\n'
name|'if'
name|'image_ref'
op|':'
newline|'\n'
indent|'                '
name|'_image_info'
op|'='
name|'vmware_images'
op|'.'
name|'get_vmdk_size_and_properties'
op|'('
nl|'\n'
name|'context'
op|','
name|'image_ref'
op|','
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# The case that the image may be booted from a volume'
nl|'\n'
indent|'                '
name|'_image_info'
op|'='
op|'('
name|'root_size'
op|','
op|'{'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'image_size'
op|','
name|'image_properties'
op|'='
name|'_image_info'
newline|'\n'
name|'vmdk_file_size_in_kb'
op|'='
name|'int'
op|'('
name|'image_size'
op|')'
op|'/'
number|'1024'
newline|'\n'
name|'os_type'
op|'='
name|'image_properties'
op|'.'
name|'get'
op|'('
string|'"vmware_ostype"'
op|','
string|'"otherGuest"'
op|')'
newline|'\n'
name|'adapter_type'
op|'='
name|'image_properties'
op|'.'
name|'get'
op|'('
string|'"vmware_adaptertype"'
op|','
nl|'\n'
string|'"lsiLogic"'
op|')'
newline|'\n'
name|'disk_type'
op|'='
name|'image_properties'
op|'.'
name|'get'
op|'('
string|'"vmware_disktype"'
op|','
nl|'\n'
string|'"preallocated"'
op|')'
newline|'\n'
comment|'# Get the network card type from the image properties.'
nl|'\n'
name|'vif_model'
op|'='
name|'image_properties'
op|'.'
name|'get'
op|'('
string|'"hw_vif_model"'
op|','
string|'"VirtualE1000"'
op|')'
newline|'\n'
nl|'\n'
comment|'# Fetch the image_linked_clone data here. It is retrieved'
nl|'\n'
comment|'# with the above network based API call. To retrieve it'
nl|'\n'
comment|'# later will necessitate additional network calls using the'
nl|'\n'
comment|'# identical method. Consider this a cache.'
nl|'\n'
name|'image_linked_clone'
op|'='
name|'image_properties'
op|'.'
name|'get'
op|'('
name|'VMWARE_LINKED_CLONE'
op|')'
newline|'\n'
nl|'\n'
name|'return'
op|'('
name|'vmdk_file_size_in_kb'
op|','
name|'os_type'
op|','
name|'adapter_type'
op|','
name|'disk_type'
op|','
nl|'\n'
name|'vif_model'
op|','
name|'image_linked_clone'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'root_gb'
op|'='
name|'instance'
op|'['
string|"'root_gb'"
op|']'
newline|'\n'
name|'root_gb_in_kb'
op|'='
name|'root_gb'
op|'*'
name|'units'
op|'.'
name|'Mi'
newline|'\n'
nl|'\n'
op|'('
name|'vmdk_file_size_in_kb'
op|','
name|'os_type'
op|','
name|'adapter_type'
op|','
name|'disk_type'
op|','
name|'vif_model'
op|','
nl|'\n'
name|'image_linked_clone'
op|')'
op|'='
name|'_get_image_properties'
op|'('
name|'root_gb_in_kb'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'root_gb_in_kb'
name|'and'
name|'vmdk_file_size_in_kb'
op|'>'
name|'root_gb_in_kb'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
name|'_'
op|'('
string|'"Image disk size greater than requested disk size"'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstanceUnacceptable'
op|'('
name|'instance_id'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'node_mo_id'
op|'='
name|'vm_util'
op|'.'
name|'get_mo_id_from_instance'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'res_pool_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_res_pool_ref'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_cluster'
op|','
name|'node_mo_id'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_get_vif_infos
name|'def'
name|'_get_vif_infos'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
name|'vif_infos'
op|'='
op|'['
op|']'
newline|'\n'
name|'if'
name|'network_info'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'vif_infos'
newline|'\n'
dedent|''
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
indent|'                '
name|'mac_address'
op|'='
name|'vif'
op|'['
string|"'address'"
op|']'
newline|'\n'
name|'network_name'
op|'='
name|'vif'
op|'['
string|"'network'"
op|']'
op|'['
string|"'bridge'"
op|']'
name|'or'
name|'CONF'
op|'.'
name|'vmware'
op|'.'
name|'integration_bridge'
newline|'\n'
name|'network_ref'
op|'='
name|'vmwarevif'
op|'.'
name|'get_network_ref'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_cluster'
op|','
nl|'\n'
name|'vif'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_is_neutron'
op|')'
newline|'\n'
name|'vif_infos'
op|'.'
name|'append'
op|'('
op|'{'
string|"'network_name'"
op|':'
name|'network_name'
op|','
nl|'\n'
string|"'mac_address'"
op|':'
name|'mac_address'
op|','
nl|'\n'
string|"'network_ref'"
op|':'
name|'network_ref'
op|','
nl|'\n'
string|"'iface_id'"
op|':'
name|'vif'
op|'['
string|"'id'"
op|']'
op|','
nl|'\n'
string|"'vif_model'"
op|':'
name|'vif_model'
nl|'\n'
op|'}'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'vif_infos'
newline|'\n'
nl|'\n'
dedent|''
name|'vif_infos'
op|'='
name|'_get_vif_infos'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|"# Get the instance name. In some cases this may differ from the 'uuid',"
nl|'\n'
comment|'# for example when the spawn of a rescue instance takes place.'
nl|'\n'
name|'if'
name|'not'
name|'instance_name'
op|':'
newline|'\n'
indent|'            '
name|'instance_name'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
comment|'# Get the create vm config spec'
nl|'\n'
dedent|''
name|'config_spec'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_create_spec'
op|'('
nl|'\n'
name|'client_factory'
op|','
name|'instance'
op|','
name|'instance_name'
op|','
nl|'\n'
name|'data_store_name'
op|','
name|'vif_infos'
op|','
name|'os_type'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_execute_create_vm
name|'def'
name|'_execute_create_vm'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Create VM on ESX host."""'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Creating VM on the ESX host"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
comment|'# Create the VM on the ESX host'
nl|'\n'
name|'vm_create_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"CreateVM_Task"'
op|','
name|'dc_info'
op|'.'
name|'vmFolder'
op|','
nl|'\n'
name|'config'
op|'='
name|'config_spec'
op|','
name|'pool'
op|'='
name|'res_pool_ref'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
name|'vm_create_task'
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Created VM on the ESX host"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'_execute_create_vm'
op|'('
op|')'
newline|'\n'
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref_from_name'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'instance_name'
op|')'
newline|'\n'
nl|'\n'
comment|'# Set the machine.id parameter of the instance to inject'
nl|'\n'
comment|'# the NIC configuration inside the VM'
nl|'\n'
name|'if'
name|'CONF'
op|'.'
name|'flat_injected'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_set_machine_id'
op|'('
name|'client_factory'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
comment|'# Set the vnc configuration of the instance, vnc port starts from 5900'
nl|'\n'
dedent|''
name|'if'
name|'CONF'
op|'.'
name|'vnc_enabled'
op|':'
newline|'\n'
indent|'            '
name|'vnc_port'
op|'='
name|'self'
op|'.'
name|'_get_vnc_port'
op|'('
name|'vm_ref'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_set_vnc_config'
op|'('
name|'client_factory'
op|','
name|'instance'
op|','
name|'vnc_port'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_create_virtual_disk
dedent|''
name|'def'
name|'_create_virtual_disk'
op|'('
name|'folder'
op|','
name|'virtual_disk_path'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Create a virtual disk of the size of flat vmdk file."""'
newline|'\n'
comment|'# Create a Virtual Disk of the size of the flat vmdk file. This is'
nl|'\n'
comment|'# done just to generate the meta-data file whose specifics'
nl|'\n'
comment|'# depend on the size of the disk, thin/thick provisioning and the'
nl|'\n'
comment|'# storage adapter type.'
nl|'\n'
comment|'# Here we assume thick provisioning and lsiLogic for the adapter'
nl|'\n'
comment|'# type'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Creating temporary folder for %(folder)s on "'
nl|'\n'
string|'"datastore %(datastore)s."'
op|')'
op|','
nl|'\n'
op|'{'
string|"'folder'"
op|':'
name|'folder'
op|','
string|"'datastore'"
op|':'
name|'data_store_name'
op|'}'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_mkdir'
op|'('
name|'vm_util'
op|'.'
name|'build_datastore_path'
op|'('
name|'data_store_name'
op|','
nl|'\n'
name|'folder'
op|')'
op|','
nl|'\n'
name|'data_store_ref'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Creating Virtual Disk of size  "'
nl|'\n'
string|'"%(vmdk_file_size_in_kb)s KB and adapter type "'
nl|'\n'
string|'"%(adapter_type)s on the ESX host local store "'
nl|'\n'
string|'"%(data_store_name)s"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|'"vmdk_file_size_in_kb"'
op|':'
name|'vmdk_file_size_in_kb'
op|','
nl|'\n'
string|'"adapter_type"'
op|':'
name|'adapter_type'
op|','
nl|'\n'
string|'"data_store_name"'
op|':'
name|'data_store_name'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'vmdk_create_spec'
op|'='
name|'vm_util'
op|'.'
name|'get_vmdk_create_spec'
op|'('
name|'client_factory'
op|','
nl|'\n'
name|'vmdk_file_size_in_kb'
op|','
name|'adapter_type'
op|','
nl|'\n'
name|'disk_type'
op|')'
newline|'\n'
name|'vmdk_create_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"CreateVirtualDisk_Task"'
op|','
nl|'\n'
name|'service_content'
op|'.'
name|'virtualDiskManager'
op|','
nl|'\n'
name|'name'
op|'='
name|'virtual_disk_path'
op|','
nl|'\n'
name|'datacenter'
op|'='
name|'dc_info'
op|'.'
name|'ref'
op|','
nl|'\n'
name|'spec'
op|'='
name|'vmdk_create_spec'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
name|'vmdk_create_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Created Virtual Disk of size %(vmdk_file_size_in_kb)s"'
nl|'\n'
string|'" KB and type %(disk_type)s on "'
nl|'\n'
string|'"the ESX host local store %(data_store_name)s"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|'"vmdk_file_size_in_kb"'
op|':'
name|'vmdk_file_size_in_kb'
op|','
nl|'\n'
string|'"disk_type"'
op|':'
name|'disk_type'
op|','
nl|'\n'
string|'"data_store_name"'
op|':'
name|'data_store_name'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_move_image_to_cache_folder
dedent|''
name|'def'
name|'_move_image_to_cache_folder'
op|'('
name|'tmp_folder'
op|','
name|'base_folder'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Moving temporary folder %(tmp)s to cache "'
nl|'\n'
string|'"folder %(cache)s."'
op|')'
op|','
nl|'\n'
op|'{'
string|"'tmp'"
op|':'
name|'tmp_folder'
op|','
string|"'cache'"
op|':'
name|'base_folder'
op|'}'
op|')'
newline|'\n'
name|'vmdk_move_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"MoveDatastoreFile_Task"'
op|','
nl|'\n'
name|'service_content'
op|'.'
name|'fileManager'
op|','
nl|'\n'
name|'sourceName'
op|'='
name|'vm_util'
op|'.'
name|'build_datastore_path'
op|'('
name|'data_store_name'
op|','
nl|'\n'
name|'tmp_folder'
op|')'
op|','
nl|'\n'
name|'sourceDatacenter'
op|'='
name|'dc_info'
op|'.'
name|'ref'
op|','
nl|'\n'
name|'destinationName'
op|'='
name|'vm_util'
op|'.'
name|'build_datastore_path'
op|'('
name|'data_store_name'
op|','
nl|'\n'
name|'base_folder'
op|')'
op|','
nl|'\n'
name|'destinationDatacenter'
op|'='
name|'dc_info'
op|'.'
name|'ref'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
name|'vmdk_move_task'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'error_util'
op|'.'
name|'FileAlreadyExistsException'
op|':'
newline|'\n'
comment|'# File move has failed. This may be due to the fact that a'
nl|'\n'
comment|'# process or thread has already completed the opertaion.'
nl|'\n'
comment|'# In the event of a FileAlreadyExists we continue, all other'
nl|'\n'
comment|'# exceptions will be raised.'
nl|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"File %(folder)s already exists on %(ds)s."'
op|')'
op|','
nl|'\n'
op|'{'
string|"'folder'"
op|':'
name|'base_folder'
op|','
string|"'ds'"
op|':'
name|'data_store_name'
op|'}'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_fetch_image_on_datastore
dedent|''
dedent|''
name|'def'
name|'_fetch_image_on_datastore'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Fetch image from Glance to datastore."""'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Downloading image file data %(image_ref)s to the "'
nl|'\n'
string|'"data store %(data_store_name)s"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'image_ref'"
op|':'
name|'instance'
op|'['
string|"'image_ref'"
op|']'
op|','
nl|'\n'
string|"'data_store_name'"
op|':'
name|'data_store_name'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
comment|'# For flat disk, upload the -flat.vmdk file whose meta-data file'
nl|'\n'
comment|'# we just created above'
nl|'\n'
comment|'# For sparse disk, upload the -sparse.vmdk file to be copied into'
nl|'\n'
comment|'# a flat vmdk'
nl|'\n'
name|'upload_vmdk_name'
op|'='
name|'sparse_uploaded_vmdk_name'
name|'if'
name|'disk_type'
op|'=='
string|'"sparse"'
name|'else'
name|'flat_uploaded_vmdk_name'
newline|'\n'
name|'vmware_images'
op|'.'
name|'fetch_image'
op|'('
nl|'\n'
name|'context'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'image_ref'"
op|']'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'host'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_host_ip'
op|','
nl|'\n'
name|'data_center_name'
op|'='
name|'dc_info'
op|'.'
name|'name'
op|','
nl|'\n'
name|'datastore_name'
op|'='
name|'data_store_name'
op|','
nl|'\n'
name|'cookies'
op|'='
name|'cookies'
op|','
nl|'\n'
name|'file_path'
op|'='
name|'upload_vmdk_name'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Downloaded image file data %(image_ref)s to "'
nl|'\n'
string|'"%(upload_vmdk_name)s on the data store "'
nl|'\n'
string|'"%(data_store_name)s"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'image_ref'"
op|':'
name|'instance'
op|'['
string|"'image_ref'"
op|']'
op|','
nl|'\n'
string|"'upload_vmdk_name'"
op|':'
name|'upload_vmdk_name'
op|','
nl|'\n'
string|"'data_store_name'"
op|':'
name|'data_store_name'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_copy_virtual_disk
dedent|''
name|'def'
name|'_copy_virtual_disk'
op|'('
name|'source'
op|','
name|'dest'
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Copy a sparse virtual disk to a thin virtual disk."""'
newline|'\n'
comment|'# Copy a sparse virtual disk to a thin virtual disk. This is also'
nl|'\n'
comment|'# done to generate the meta-data file whose specifics'
nl|'\n'
comment|'# depend on the size of the disk, thin/thick provisioning and the'
nl|'\n'
comment|'# storage adapter type.'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Copying Virtual Disk of size "'
nl|'\n'
string|'"%(vmdk_file_size_in_kb)s KB and adapter type "'
nl|'\n'
string|'"%(adapter_type)s on the ESX host local store "'
nl|'\n'
string|'"%(data_store_name)s to disk type %(disk_type)s"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|'"vmdk_file_size_in_kb"'
op|':'
name|'vmdk_file_size_in_kb'
op|','
nl|'\n'
string|'"adapter_type"'
op|':'
name|'adapter_type'
op|','
nl|'\n'
string|'"data_store_name"'
op|':'
name|'data_store_name'
op|','
nl|'\n'
string|'"disk_type"'
op|':'
name|'disk_type'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'vmdk_copy_spec'
op|'='
name|'self'
op|'.'
name|'get_copy_virtual_disk_spec'
op|'('
name|'client_factory'
op|','
nl|'\n'
name|'adapter_type'
op|','
nl|'\n'
name|'disk_type'
op|')'
newline|'\n'
name|'vmdk_copy_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"CopyVirtualDisk_Task"'
op|','
nl|'\n'
name|'service_content'
op|'.'
name|'virtualDiskManager'
op|','
nl|'\n'
name|'sourceName'
op|'='
name|'source'
op|','
nl|'\n'
name|'sourceDatacenter'
op|'='
name|'dc_info'
op|'.'
name|'ref'
op|','
nl|'\n'
name|'destName'
op|'='
name|'dest'
op|','
nl|'\n'
name|'destSpec'
op|'='
name|'vmdk_copy_spec'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
name|'vmdk_copy_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Copied Virtual Disk of size %(vmdk_file_size_in_kb)s"'
nl|'\n'
string|'" KB and type %(disk_type)s on "'
nl|'\n'
string|'"the ESX host local store %(data_store_name)s"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|'"vmdk_file_size_in_kb"'
op|':'
name|'vmdk_file_size_in_kb'
op|','
nl|'\n'
string|'"disk_type"'
op|':'
name|'disk_type'
op|','
nl|'\n'
string|'"data_store_name"'
op|':'
name|'data_store_name'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'ebs_root'
op|':'
newline|'\n'
comment|'# this logic allows for instances or images to decide'
nl|'\n'
comment|'# for themselves which strategy is best for them.'
nl|'\n'
nl|'\n'
indent|'            '
name|'linked_clone'
op|'='
name|'VMwareVMOps'
op|'.'
name|'decide_linked_clone'
op|'('
nl|'\n'
name|'image_linked_clone'
op|','
nl|'\n'
name|'CONF'
op|'.'
name|'vmware'
op|'.'
name|'use_linked_clone'
nl|'\n'
op|')'
newline|'\n'
name|'upload_name'
op|'='
name|'instance'
op|'['
string|"'image_ref'"
op|']'
newline|'\n'
name|'upload_folder'
op|'='
string|"'%s/%s'"
op|'%'
op|'('
name|'self'
op|'.'
name|'_base_folder'
op|','
name|'upload_name'
op|')'
newline|'\n'
nl|'\n'
comment|'# The vmdk meta-data file'
nl|'\n'
name|'uploaded_vmdk_name'
op|'='
string|'"%s/%s.vmdk"'
op|'%'
op|'('
name|'upload_folder'
op|','
name|'upload_name'
op|')'
newline|'\n'
name|'uploaded_vmdk_path'
op|'='
name|'vm_util'
op|'.'
name|'build_datastore_path'
op|'('
name|'data_store_name'
op|','
nl|'\n'
name|'uploaded_vmdk_name'
op|')'
newline|'\n'
nl|'\n'
name|'session_vim'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
newline|'\n'
name|'cookies'
op|'='
name|'session_vim'
op|'.'
name|'client'
op|'.'
name|'options'
op|'.'
name|'transport'
op|'.'
name|'cookiejar'
newline|'\n'
nl|'\n'
name|'if'
name|'not'
op|'('
name|'self'
op|'.'
name|'_check_if_folder_file_exists'
op|'('
nl|'\n'
name|'data_store_ref'
op|','
name|'data_store_name'
op|','
nl|'\n'
name|'upload_folder'
op|','
name|'upload_name'
op|'+'
string|'".vmdk"'
op|')'
op|')'
op|':'
newline|'\n'
comment|'# Upload will be done to the self._tmp_folder and then moved'
nl|'\n'
comment|'# to the self._base_folder'
nl|'\n'
indent|'                '
name|'tmp_upload_folder'
op|'='
string|"'%s/%s'"
op|'%'
op|'('
name|'self'
op|'.'
name|'_tmp_folder'
op|','
nl|'\n'
name|'uuidutils'
op|'.'
name|'generate_uuid'
op|'('
op|')'
op|')'
newline|'\n'
name|'upload_folder'
op|'='
string|"'%s/%s'"
op|'%'
op|'('
name|'tmp_upload_folder'
op|','
name|'upload_name'
op|')'
newline|'\n'
nl|'\n'
comment|'# Naming the VM files in correspondence with the VM instance'
nl|'\n'
comment|'# The flat vmdk file name'
nl|'\n'
name|'flat_uploaded_vmdk_name'
op|'='
string|'"%s/%s-flat.vmdk"'
op|'%'
op|'('
nl|'\n'
name|'upload_folder'
op|','
name|'upload_name'
op|')'
newline|'\n'
comment|'# The sparse vmdk file name for sparse disk image'
nl|'\n'
name|'sparse_uploaded_vmdk_name'
op|'='
string|'"%s/%s-sparse.vmdk"'
op|'%'
op|'('
nl|'\n'
name|'upload_folder'
op|','
name|'upload_name'
op|')'
newline|'\n'
nl|'\n'
name|'flat_uploaded_vmdk_path'
op|'='
name|'vm_util'
op|'.'
name|'build_datastore_path'
op|'('
nl|'\n'
name|'data_store_name'
op|','
nl|'\n'
name|'flat_uploaded_vmdk_name'
op|')'
newline|'\n'
name|'sparse_uploaded_vmdk_path'
op|'='
name|'vm_util'
op|'.'
name|'build_datastore_path'
op|'('
nl|'\n'
name|'data_store_name'
op|','
nl|'\n'
name|'sparse_uploaded_vmdk_name'
op|')'
newline|'\n'
nl|'\n'
name|'vmdk_name'
op|'='
string|'"%s/%s.vmdk"'
op|'%'
op|'('
name|'upload_folder'
op|','
name|'upload_name'
op|')'
newline|'\n'
name|'vmdk_path'
op|'='
name|'vm_util'
op|'.'
name|'build_datastore_path'
op|'('
name|'data_store_name'
op|','
nl|'\n'
name|'vmdk_name'
op|')'
newline|'\n'
name|'if'
name|'disk_type'
op|'!='
string|'"sparse"'
op|':'
newline|'\n'
comment|'# Create a flat virtual disk and retain the metadata file.'
nl|'\n'
indent|'                    '
name|'_create_virtual_disk'
op|'('
name|'upload_folder'
op|','
name|'vmdk_path'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_delete_datastore_file'
op|'('
name|'instance'
op|','
nl|'\n'
name|'flat_uploaded_vmdk_path'
op|','
nl|'\n'
name|'dc_info'
op|'.'
name|'ref'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'_fetch_image_on_datastore'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'disk_type'
op|'=='
string|'"sparse"'
op|':'
newline|'\n'
comment|'# Copy the sparse virtual disk to a thin virtual disk.'
nl|'\n'
indent|'                    '
name|'disk_type'
op|'='
string|'"thin"'
newline|'\n'
name|'_copy_virtual_disk'
op|'('
name|'sparse_uploaded_vmdk_path'
op|','
name|'vmdk_path'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_delete_datastore_file'
op|'('
name|'instance'
op|','
nl|'\n'
name|'sparse_uploaded_vmdk_path'
op|','
nl|'\n'
name|'dc_info'
op|'.'
name|'ref'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'base_folder'
op|'='
string|"'%s/%s'"
op|'%'
op|'('
name|'self'
op|'.'
name|'_base_folder'
op|','
name|'upload_name'
op|')'
newline|'\n'
name|'_move_image_to_cache_folder'
op|'('
name|'upload_folder'
op|','
name|'base_folder'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_delete_datastore_file'
op|'('
name|'instance'
op|','
nl|'\n'
name|'vm_util'
op|'.'
name|'build_datastore_path'
op|'('
name|'data_store_name'
op|','
nl|'\n'
name|'tmp_upload_folder'
op|')'
op|','
nl|'\n'
name|'dc_info'
op|'.'
name|'ref'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# linked clone base disk exists'
nl|'\n'
indent|'                '
name|'if'
name|'disk_type'
op|'=='
string|'"sparse"'
op|':'
newline|'\n'
indent|'                    '
name|'disk_type'
op|'='
string|'"thin"'
newline|'\n'
nl|'\n'
comment|'# Extend the disk size if necessary'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'linked_clone'
op|':'
newline|'\n'
comment|'# If we are not using linked_clone, copy the image from'
nl|'\n'
comment|'# the cache into the instance directory.  If we are using'
nl|'\n'
comment|'# linked clone it is references from the cache directory'
nl|'\n'
indent|'                '
name|'dest_folder'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'dest_name'
op|'='
name|'instance_name'
newline|'\n'
name|'dest_vmdk_name'
op|'='
string|'"%s/%s.vmdk"'
op|'%'
op|'('
name|'dest_folder'
op|','
nl|'\n'
name|'dest_name'
op|')'
newline|'\n'
name|'dest_vmdk_path'
op|'='
name|'vm_util'
op|'.'
name|'build_datastore_path'
op|'('
nl|'\n'
name|'data_store_name'
op|','
name|'dest_vmdk_name'
op|')'
newline|'\n'
name|'_copy_virtual_disk'
op|'('
name|'uploaded_vmdk_path'
op|','
name|'dest_vmdk_path'
op|')'
newline|'\n'
nl|'\n'
name|'root_vmdk_path'
op|'='
name|'dest_vmdk_path'
newline|'\n'
name|'if'
name|'root_gb_in_kb'
op|'>'
name|'vmdk_file_size_in_kb'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_extend_virtual_disk'
op|'('
name|'instance'
op|','
name|'root_gb_in_kb'
op|','
nl|'\n'
name|'root_vmdk_path'
op|','
name|'dc_info'
op|'.'
name|'ref'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'upload_folder'
op|'='
string|"'%s/%s'"
op|'%'
op|'('
name|'self'
op|'.'
name|'_base_folder'
op|','
name|'upload_name'
op|')'
newline|'\n'
name|'root_vmdk_name'
op|'='
string|'"%s/%s.%s.vmdk"'
op|'%'
op|'('
name|'upload_folder'
op|','
name|'upload_name'
op|','
nl|'\n'
name|'root_gb'
op|')'
newline|'\n'
name|'root_vmdk_path'
op|'='
name|'vm_util'
op|'.'
name|'build_datastore_path'
op|'('
name|'data_store_name'
op|','
nl|'\n'
name|'root_vmdk_name'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_check_if_folder_file_exists'
op|'('
nl|'\n'
name|'data_store_ref'
op|','
name|'data_store_name'
op|','
nl|'\n'
name|'upload_folder'
op|','
nl|'\n'
name|'upload_name'
op|'+'
string|'".%s.vmdk"'
op|'%'
name|'root_gb'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Copying root disk of size %sGb"'
op|')'
op|','
name|'root_gb'
op|')'
newline|'\n'
name|'copy_spec'
op|'='
name|'self'
op|'.'
name|'get_copy_virtual_disk_spec'
op|'('
nl|'\n'
name|'client_factory'
op|','
name|'adapter_type'
op|','
name|'disk_type'
op|')'
newline|'\n'
name|'vmdk_copy_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"CopyVirtualDisk_Task"'
op|','
nl|'\n'
name|'service_content'
op|'.'
name|'virtualDiskManager'
op|','
nl|'\n'
name|'sourceName'
op|'='
name|'uploaded_vmdk_path'
op|','
nl|'\n'
name|'sourceDatacenter'
op|'='
name|'dc_info'
op|'.'
name|'ref'
op|','
nl|'\n'
name|'destName'
op|'='
name|'root_vmdk_path'
op|','
nl|'\n'
name|'destSpec'
op|'='
name|'copy_spec'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
name|'vmdk_copy_task'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'                        '
name|'LOG'
op|'.'
name|'warning'
op|'('
name|'_'
op|'('
string|'"Root disk file creation "'
nl|'\n'
string|'"failed - %s"'
op|')'
op|','
name|'e'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'root_gb_in_kb'
op|'>'
name|'vmdk_file_size_in_kb'
op|':'
newline|'\n'
indent|'                        '
name|'self'
op|'.'
name|'_extend_virtual_disk'
op|'('
name|'instance'
op|','
name|'root_gb_in_kb'
op|','
nl|'\n'
name|'root_vmdk_path'
op|','
nl|'\n'
name|'dc_info'
op|'.'
name|'ref'
op|')'
newline|'\n'
nl|'\n'
comment|'# Attach the root disk to the VM.'
nl|'\n'
dedent|''
dedent|''
dedent|''
name|'self'
op|'.'
name|'_volumeops'
op|'.'
name|'attach_disk_to_vm'
op|'('
nl|'\n'
name|'vm_ref'
op|','
name|'instance'
op|','
nl|'\n'
name|'adapter_type'
op|','
name|'disk_type'
op|','
name|'root_vmdk_path'
op|','
nl|'\n'
name|'root_gb_in_kb'
op|','
name|'linked_clone'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'configdrive'
op|'.'
name|'required_by'
op|'('
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'uploaded_iso_path'
op|'='
name|'self'
op|'.'
name|'_create_config_drive'
op|'('
name|'instance'
op|','
nl|'\n'
name|'injected_files'
op|','
nl|'\n'
name|'admin_password'
op|','
nl|'\n'
name|'data_store_name'
op|','
nl|'\n'
name|'dc_info'
op|'.'
name|'name'
op|','
nl|'\n'
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
name|'cookies'
op|')'
newline|'\n'
name|'uploaded_iso_path'
op|'='
name|'vm_util'
op|'.'
name|'build_datastore_path'
op|'('
nl|'\n'
name|'data_store_name'
op|','
nl|'\n'
name|'uploaded_iso_path'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_attach_cdrom_to_vm'
op|'('
nl|'\n'
name|'vm_ref'
op|','
name|'instance'
op|','
nl|'\n'
name|'data_store_ref'
op|','
nl|'\n'
name|'uploaded_iso_path'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Attach the root disk to the VM.'
nl|'\n'
indent|'            '
name|'for'
name|'root_disk'
name|'in'
name|'block_device_mapping'
op|':'
newline|'\n'
indent|'                '
name|'connection_info'
op|'='
name|'root_disk'
op|'['
string|"'connection_info'"
op|']'
newline|'\n'
name|'self'
op|'.'
name|'_volumeops'
op|'.'
name|'attach_root_volume'
op|'('
name|'connection_info'
op|','
name|'instance'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_default_root_device'
op|','
nl|'\n'
name|'data_store_ref'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_power_on_vm
dedent|''
dedent|''
name|'def'
name|'_power_on_vm'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""Power on the VM."""'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Powering on the VM instance"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
comment|'# Power On the VM'
nl|'\n'
name|'power_on_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"PowerOnVM_Task"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
name|'power_on_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Powered on the VM instance"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'power_on'
op|':'
newline|'\n'
indent|'            '
name|'_power_on_vm'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_create_config_drive
dedent|''
dedent|''
name|'def'
name|'_create_config_drive'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'injected_files'
op|','
name|'admin_password'
op|','
nl|'\n'
name|'data_store_name'
op|','
name|'dc_name'
op|','
name|'upload_folder'
op|','
name|'cookies'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'CONF'
op|'.'
name|'config_drive_format'
op|'!='
string|"'iso9660'"
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
op|'('
name|'_'
op|'('
string|'\'Invalid config_drive_format "%s"\''
op|')'
op|'%'
nl|'\n'
name|'CONF'
op|'.'
name|'config_drive_format'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstancePowerOnFailure'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|"'Using config drive for instance'"
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'extra_md'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'if'
name|'admin_password'
op|':'
newline|'\n'
indent|'            '
name|'extra_md'
op|'['
string|"'admin_pass'"
op|']'
op|'='
name|'admin_password'
newline|'\n'
nl|'\n'
dedent|''
name|'inst_md'
op|'='
name|'instance_metadata'
op|'.'
name|'InstanceMetadata'
op|'('
name|'instance'
op|','
nl|'\n'
name|'content'
op|'='
name|'injected_files'
op|','
nl|'\n'
name|'extra_md'
op|'='
name|'extra_md'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'configdrive'
op|'.'
name|'ConfigDriveBuilder'
op|'('
name|'instance_md'
op|'='
name|'inst_md'
op|')'
name|'as'
name|'cdb'
op|':'
newline|'\n'
indent|'                '
name|'with'
name|'utils'
op|'.'
name|'tempdir'
op|'('
op|')'
name|'as'
name|'tmp_path'
op|':'
newline|'\n'
indent|'                    '
name|'tmp_file'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'tmp_path'
op|','
string|"'configdrive.iso'"
op|')'
newline|'\n'
name|'cdb'
op|'.'
name|'make_drive'
op|'('
name|'tmp_file'
op|')'
newline|'\n'
name|'upload_iso_path'
op|'='
string|'"%s/configdrive.iso"'
op|'%'
op|'('
nl|'\n'
name|'upload_folder'
op|')'
newline|'\n'
name|'vmware_images'
op|'.'
name|'upload_iso_to_datastore'
op|'('
nl|'\n'
name|'tmp_file'
op|','
name|'instance'
op|','
nl|'\n'
name|'host'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_host_ip'
op|','
nl|'\n'
name|'data_center_name'
op|'='
name|'dc_name'
op|','
nl|'\n'
name|'datastore_name'
op|'='
name|'data_store_name'
op|','
nl|'\n'
name|'cookies'
op|'='
name|'cookies'
op|','
nl|'\n'
name|'file_path'
op|'='
name|'upload_iso_path'
op|')'
newline|'\n'
name|'return'
name|'upload_iso_path'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'error'
op|'('
name|'_'
op|'('
string|"'Creating config drive failed with error: %s'"
op|')'
op|','
nl|'\n'
name|'e'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_attach_cdrom_to_vm
dedent|''
dedent|''
dedent|''
name|'def'
name|'_attach_cdrom_to_vm'
op|'('
name|'self'
op|','
name|'vm_ref'
op|','
name|'instance'
op|','
nl|'\n'
name|'datastore'
op|','
name|'file_path'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Attach cdrom to VM by reconfiguration."""'
newline|'\n'
name|'instance_name'
op|'='
name|'instance'
op|'['
string|"'name'"
op|']'
newline|'\n'
name|'instance_uuid'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'client_factory'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|'.'
name|'client'
op|'.'
name|'factory'
newline|'\n'
name|'devices'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
nl|'\n'
string|'"get_dynamic_property"'
op|','
name|'vm_ref'
op|','
nl|'\n'
string|'"VirtualMachine"'
op|','
string|'"config.hardware.device"'
op|')'
newline|'\n'
op|'('
name|'controller_key'
op|','
name|'unit_number'
op|','
nl|'\n'
name|'controller_spec'
op|')'
op|'='
name|'vm_util'
op|'.'
name|'allocate_controller_key_and_unit_number'
op|'('
nl|'\n'
name|'client_factory'
op|','
nl|'\n'
name|'devices'
op|','
nl|'\n'
string|"'ide'"
op|')'
newline|'\n'
name|'cdrom_attach_config_spec'
op|'='
name|'vm_util'
op|'.'
name|'get_cdrom_attach_config_spec'
op|'('
nl|'\n'
name|'client_factory'
op|','
name|'datastore'
op|','
name|'file_path'
op|','
nl|'\n'
name|'controller_key'
op|','
name|'unit_number'
op|')'
newline|'\n'
name|'if'
name|'controller_spec'
op|':'
newline|'\n'
indent|'            '
name|'cdrom_attach_config_spec'
op|'.'
name|'deviceChange'
op|'.'
name|'append'
op|'('
name|'controller_spec'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Reconfiguring VM instance %(instance_name)s to attach "'
nl|'\n'
string|'"cdrom %(file_path)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'instance_name'"
op|':'
name|'instance_name'
op|','
string|"'file_path'"
op|':'
name|'file_path'
op|'}'
op|')'
newline|'\n'
name|'reconfig_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"ReconfigVM_Task"'
op|','
name|'vm_ref'
op|','
nl|'\n'
name|'spec'
op|'='
name|'cdrom_attach_config_spec'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance_uuid'
op|','
name|'reconfig_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Reconfigured VM instance %(instance_name)s to attach "'
nl|'\n'
string|'"cdrom %(file_path)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'instance_name'"
op|':'
name|'instance_name'
op|','
string|"'file_path'"
op|':'
name|'file_path'
op|'}'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|decide_linked_clone
name|'def'
name|'decide_linked_clone'
op|'('
name|'image_linked_clone'
op|','
name|'global_linked_clone'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Explicit decision logic: whether to use linked clone on a vmdk.\n\n        This is *override* logic not boolean logic.\n\n        1. let the image over-ride if set at all\n        2. default to the global setting\n\n        In math terms, I need to allow:\n        glance image to override global config.\n\n        That is g vs c. "g" for glance. "c" for Config.\n\n        So, I need  g=True vs c=False to be True.\n        And, I need g=False vs c=True to be False.\n        And, I need g=None vs c=True to be True.\n\n        Some images maybe independently best tuned for use_linked_clone=True\n        saving datastorage space. Alternatively a whole OpenStack install may\n        be tuned to performance use_linked_clone=False but a single image\n        in this environment may be best configured to save storage space and\n        set use_linked_clone=True only for itself.\n\n        The point is: let each layer of control override the layer beneath it.\n\n        rationale:\n        For technical discussion on the clone strategies and their trade-offs\n        see: https://www.vmware.com/support/ws5/doc/ws_clone_typeofclone.html\n\n        :param image_linked_clone: boolean or string or None\n        :param global_linked_clone: boolean or string or None\n        :return: Boolean\n        """'
newline|'\n'
nl|'\n'
name|'value'
op|'='
name|'None'
newline|'\n'
nl|'\n'
comment|'# Consider the values in order of override.'
nl|'\n'
name|'if'
name|'image_linked_clone'
name|'is'
name|'not'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'value'
op|'='
name|'image_linked_clone'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# this will never be not-set by this point.'
nl|'\n'
indent|'            '
name|'value'
op|'='
name|'global_linked_clone'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'strutils'
op|'.'
name|'bool_from_string'
op|'('
name|'value'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_copy_virtual_disk_spec
dedent|''
name|'def'
name|'get_copy_virtual_disk_spec'
op|'('
name|'self'
op|','
name|'client_factory'
op|','
name|'adapter_type'
op|','
nl|'\n'
name|'disk_type'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'vm_util'
op|'.'
name|'get_copy_virtual_disk_spec'
op|'('
name|'client_factory'
op|','
nl|'\n'
name|'adapter_type'
op|','
nl|'\n'
name|'disk_type'
op|')'
newline|'\n'
nl|'\n'
DECL|member|snapshot
dedent|''
name|'def'
name|'snapshot'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'image_id'
op|','
name|'update_task_state'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Create snapshot from a running VM instance.\n\n        Steps followed are:\n\n        1. Get the name of the vmdk file which the VM points to right now.\n           Can be a chain of snapshots, so we need to know the last in the\n           chain.\n        2. Create the snapshot. A new vmdk is created which the VM points to\n           now. The earlier vmdk becomes read-only.\n        3. Call CopyVirtualDisk which coalesces the disk chain to form a single\n           vmdk, rather a .vmdk metadata file and a -flat.vmdk disk data file.\n        4. Now upload the -flat.vmdk file to the image store.\n        5. Delete the coalesced .vmdk and -flat.vmdk created.\n        """'
newline|'\n'
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'instance'
op|')'
newline|'\n'
name|'client_factory'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|'.'
name|'client'
op|'.'
name|'factory'
newline|'\n'
name|'service_content'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|'.'
name|'get_service_content'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|_get_vm_and_vmdk_attribs
name|'def'
name|'_get_vm_and_vmdk_attribs'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# Get the vmdk file name that the VM is pointing to'
nl|'\n'
indent|'            '
name|'hw_devices'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
nl|'\n'
string|'"get_dynamic_property"'
op|','
name|'vm_ref'
op|','
nl|'\n'
string|'"VirtualMachine"'
op|','
string|'"config.hardware.device"'
op|')'
newline|'\n'
op|'('
name|'vmdk_file_path_before_snapshot'
op|','
name|'adapter_type'
op|','
nl|'\n'
name|'disk_type'
op|')'
op|'='
name|'vm_util'
op|'.'
name|'get_vmdk_path_and_adapter_type'
op|'('
nl|'\n'
name|'hw_devices'
op|','
name|'uuid'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
name|'datastore_name'
op|'='
name|'vm_util'
op|'.'
name|'split_datastore_path'
op|'('
nl|'\n'
name|'vmdk_file_path_before_snapshot'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'os_type'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
nl|'\n'
string|'"get_dynamic_property"'
op|','
name|'vm_ref'
op|','
nl|'\n'
string|'"VirtualMachine"'
op|','
string|'"summary.config.guestId"'
op|')'
newline|'\n'
name|'return'
op|'('
name|'vmdk_file_path_before_snapshot'
op|','
name|'adapter_type'
op|','
name|'disk_type'
op|','
nl|'\n'
name|'datastore_name'
op|','
name|'os_type'
op|')'
newline|'\n'
nl|'\n'
dedent|''
op|'('
name|'vmdk_file_path_before_snapshot'
op|','
name|'adapter_type'
op|','
name|'disk_type'
op|','
nl|'\n'
name|'datastore_name'
op|','
name|'os_type'
op|')'
op|'='
name|'_get_vm_and_vmdk_attribs'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|_create_vm_snapshot
name|'def'
name|'_create_vm_snapshot'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# Create a snapshot of the VM'
nl|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Creating Snapshot of the VM instance"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'snapshot_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"CreateSnapshot_Task"'
op|','
name|'vm_ref'
op|','
nl|'\n'
name|'name'
op|'='
string|'"%s-snapshot"'
op|'%'
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
name|'description'
op|'='
string|'"Taking Snapshot of the VM"'
op|','
nl|'\n'
name|'memory'
op|'='
name|'False'
op|','
nl|'\n'
name|'quiesce'
op|'='
name|'True'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
name|'snapshot_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Created Snapshot of the VM instance"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'_create_vm_snapshot'
op|'('
op|')'
newline|'\n'
name|'update_task_state'
op|'('
name|'task_state'
op|'='
name|'task_states'
op|'.'
name|'IMAGE_PENDING_UPLOAD'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_check_if_tmp_folder_exists
name|'def'
name|'_check_if_tmp_folder_exists'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# Copy the contents of the VM that were there just before the'
nl|'\n'
comment|'# snapshot was taken'
nl|'\n'
indent|'            '
name|'ds_ref_ret'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'vim_util'
op|','
string|'"get_dynamic_property"'
op|','
name|'vm_ref'
op|','
string|'"VirtualMachine"'
op|','
nl|'\n'
string|'"datastore"'
op|')'
newline|'\n'
name|'if'
name|'ds_ref_ret'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'exception'
op|'.'
name|'DatastoreNotFound'
op|'('
op|')'
newline|'\n'
dedent|''
name|'ds_ref'
op|'='
name|'ds_ref_ret'
op|'.'
name|'ManagedObjectReference'
op|'['
number|'0'
op|']'
newline|'\n'
name|'ds_browser'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'vim_util'
op|','
string|'"get_dynamic_property"'
op|','
name|'ds_ref'
op|','
string|'"Datastore"'
op|','
nl|'\n'
string|'"browser"'
op|')'
newline|'\n'
comment|'# Check if the vmware-tmp folder exists or not. If not, create one'
nl|'\n'
name|'tmp_folder_path'
op|'='
name|'vm_util'
op|'.'
name|'build_datastore_path'
op|'('
name|'datastore_name'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_tmp_folder'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'self'
op|'.'
name|'_path_exists'
op|'('
name|'ds_browser'
op|','
name|'tmp_folder_path'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_mkdir'
op|'('
name|'vm_util'
op|'.'
name|'build_datastore_path'
op|'('
name|'datastore_name'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_tmp_folder'
op|')'
op|','
nl|'\n'
name|'ds_ref'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'ds_ref'
newline|'\n'
nl|'\n'
dedent|''
name|'ds_ref'
op|'='
name|'_check_if_tmp_folder_exists'
op|'('
op|')'
newline|'\n'
nl|'\n'
comment|'# Generate a random vmdk file name to which the coalesced vmdk content'
nl|'\n'
comment|"# will be copied to. A random name is chosen so that we don't have"
nl|'\n'
comment|'# name clashes.'
nl|'\n'
name|'random_name'
op|'='
name|'uuidutils'
op|'.'
name|'generate_uuid'
op|'('
op|')'
newline|'\n'
name|'dest_vmdk_file_path'
op|'='
name|'vm_util'
op|'.'
name|'build_datastore_path'
op|'('
name|'datastore_name'
op|','
nl|'\n'
string|'"%s/%s.vmdk"'
op|'%'
op|'('
name|'self'
op|'.'
name|'_tmp_folder'
op|','
name|'random_name'
op|')'
op|')'
newline|'\n'
name|'dest_vmdk_data_file_path'
op|'='
name|'vm_util'
op|'.'
name|'build_datastore_path'
op|'('
name|'datastore_name'
op|','
nl|'\n'
string|'"%s/%s-flat.vmdk"'
op|'%'
op|'('
name|'self'
op|'.'
name|'_tmp_folder'
op|','
name|'random_name'
op|')'
op|')'
newline|'\n'
name|'dc_info'
op|'='
name|'self'
op|'.'
name|'get_datacenter_ref_and_name'
op|'('
name|'ds_ref'
op|')'
newline|'\n'
nl|'\n'
DECL|function|_copy_vmdk_content
name|'def'
name|'_copy_vmdk_content'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# Copy the contents of the disk (or disks, if there were snapshots'
nl|'\n'
comment|'# done earlier) to a temporary vmdk file.'
nl|'\n'
indent|'            '
name|'copy_spec'
op|'='
name|'self'
op|'.'
name|'get_copy_virtual_disk_spec'
op|'('
name|'client_factory'
op|','
nl|'\n'
name|'adapter_type'
op|','
nl|'\n'
name|'disk_type'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|"'Copying disk data before snapshot of the VM'"
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'copy_disk_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"CopyVirtualDisk_Task"'
op|','
nl|'\n'
name|'service_content'
op|'.'
name|'virtualDiskManager'
op|','
nl|'\n'
name|'sourceName'
op|'='
name|'vmdk_file_path_before_snapshot'
op|','
nl|'\n'
name|'sourceDatacenter'
op|'='
name|'dc_info'
op|'.'
name|'ref'
op|','
nl|'\n'
name|'destName'
op|'='
name|'dest_vmdk_file_path'
op|','
nl|'\n'
name|'destDatacenter'
op|'='
name|'dc_info'
op|'.'
name|'ref'
op|','
nl|'\n'
name|'destSpec'
op|'='
name|'copy_spec'
op|','
nl|'\n'
name|'force'
op|'='
name|'False'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
name|'copy_disk_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Copied disk data before snapshot of the VM"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'_copy_vmdk_content'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'cookies'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|'.'
name|'client'
op|'.'
name|'options'
op|'.'
name|'transport'
op|'.'
name|'cookiejar'
newline|'\n'
nl|'\n'
DECL|function|_upload_vmdk_to_image_repository
name|'def'
name|'_upload_vmdk_to_image_repository'
op|'('
op|')'
op|':'
newline|'\n'
comment|'# Upload the contents of -flat.vmdk file which has the disk data.'
nl|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Uploading image %s"'
op|')'
op|'%'
name|'image_id'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'vmware_images'
op|'.'
name|'upload_image'
op|'('
nl|'\n'
name|'context'
op|','
nl|'\n'
name|'image_id'
op|','
nl|'\n'
name|'instance'
op|','
nl|'\n'
name|'os_type'
op|'='
name|'os_type'
op|','
nl|'\n'
name|'disk_type'
op|'='
string|'"preallocated"'
op|','
nl|'\n'
name|'adapter_type'
op|'='
name|'adapter_type'
op|','
nl|'\n'
name|'image_version'
op|'='
number|'1'
op|','
nl|'\n'
name|'host'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_host_ip'
op|','
nl|'\n'
name|'data_center_name'
op|'='
name|'dc_info'
op|'.'
name|'name'
op|','
nl|'\n'
name|'datastore_name'
op|'='
name|'datastore_name'
op|','
nl|'\n'
name|'cookies'
op|'='
name|'cookies'
op|','
nl|'\n'
name|'file_path'
op|'='
string|'"%s/%s-flat.vmdk"'
op|'%'
op|'('
name|'self'
op|'.'
name|'_tmp_folder'
op|','
name|'random_name'
op|')'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Uploaded image %s"'
op|')'
op|'%'
name|'image_id'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'update_task_state'
op|'('
name|'task_state'
op|'='
name|'task_states'
op|'.'
name|'IMAGE_UPLOADING'
op|','
nl|'\n'
name|'expected_state'
op|'='
name|'task_states'
op|'.'
name|'IMAGE_PENDING_UPLOAD'
op|')'
newline|'\n'
name|'_upload_vmdk_to_image_repository'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|function|_clean_temp_data
name|'def'
name|'_clean_temp_data'
op|'('
op|')'
op|':'
newline|'\n'
indent|'            '
string|'"""\n            Delete temporary vmdk files generated in image handling\n            operations.\n            """'
newline|'\n'
comment|'# The data file is the one occupying space, and likelier to see'
nl|'\n'
comment|'# deletion problems, so prioritize its deletion first. In the'
nl|'\n'
comment|'# unlikely event that its deletion fails, the small descriptor file'
nl|'\n'
comment|'# is retained too by design since it makes little sense to remove'
nl|'\n'
comment|'# it when the data disk it refers to still lingers.'
nl|'\n'
name|'for'
name|'f'
name|'in'
name|'dest_vmdk_data_file_path'
op|','
name|'dest_vmdk_file_path'
op|':'
newline|'\n'
indent|'                '
name|'self'
op|'.'
name|'_delete_datastore_file'
op|'('
name|'instance'
op|','
name|'f'
op|','
name|'dc_info'
op|'.'
name|'ref'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'_clean_temp_data'
op|'('
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_values_from_object_properties
dedent|''
name|'def'
name|'_get_values_from_object_properties'
op|'('
name|'self'
op|','
name|'props'
op|','
name|'query'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'while'
name|'props'
op|':'
newline|'\n'
indent|'            '
name|'token'
op|'='
name|'vm_util'
op|'.'
name|'_get_token'
op|'('
name|'props'
op|')'
newline|'\n'
name|'for'
name|'elem'
name|'in'
name|'props'
op|'.'
name|'objects'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'prop'
name|'in'
name|'elem'
op|'.'
name|'propSet'
op|':'
newline|'\n'
indent|'                    '
name|'for'
name|'key'
name|'in'
name|'query'
op|'.'
name|'keys'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'if'
name|'prop'
op|'.'
name|'name'
op|'=='
name|'key'
op|':'
newline|'\n'
indent|'                            '
name|'query'
op|'['
name|'key'
op|']'
op|'='
name|'prop'
op|'.'
name|'val'
newline|'\n'
name|'break'
newline|'\n'
dedent|''
dedent|''
dedent|''
dedent|''
name|'if'
name|'token'
op|':'
newline|'\n'
indent|'                '
name|'props'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
nl|'\n'
string|'"continue_to_get_objects"'
op|','
nl|'\n'
name|'token'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'break'
newline|'\n'
nl|'\n'
DECL|member|reboot
dedent|''
dedent|''
dedent|''
name|'def'
name|'reboot'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Reboot a VM instance."""'
newline|'\n'
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'instance'
op|')'
newline|'\n'
name|'lst_properties'
op|'='
op|'['
string|'"summary.guest.toolsStatus"'
op|','
string|'"runtime.powerState"'
op|','
nl|'\n'
string|'"summary.guest.toolsRunningStatus"'
op|']'
newline|'\n'
name|'props'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
string|'"get_object_properties"'
op|','
nl|'\n'
name|'None'
op|','
name|'vm_ref'
op|','
string|'"VirtualMachine"'
op|','
nl|'\n'
name|'lst_properties'
op|')'
newline|'\n'
name|'query'
op|'='
op|'{'
string|"'runtime.powerState'"
op|':'
name|'None'
op|','
nl|'\n'
string|"'summary.guest.toolsStatus'"
op|':'
name|'None'
op|','
nl|'\n'
string|"'summary.guest.toolsRunningStatus'"
op|':'
name|'False'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'_get_values_from_object_properties'
op|'('
name|'props'
op|','
name|'query'
op|')'
newline|'\n'
name|'pwr_state'
op|'='
name|'query'
op|'['
string|"'runtime.powerState'"
op|']'
newline|'\n'
name|'tools_status'
op|'='
name|'query'
op|'['
string|"'summary.guest.toolsStatus'"
op|']'
newline|'\n'
name|'tools_running_status'
op|'='
name|'query'
op|'['
string|"'summary.guest.toolsRunningStatus'"
op|']'
newline|'\n'
nl|'\n'
comment|'# Raise an exception if the VM is not powered On.'
nl|'\n'
name|'if'
name|'pwr_state'
name|'not'
name|'in'
op|'['
string|'"poweredOn"'
op|']'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
name|'_'
op|'('
string|'"instance is not powered on"'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstanceRebootFailure'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
nl|'\n'
comment|'# If latest vmware tools are installed in the VM, and that the tools'
nl|'\n'
comment|'# are running, then only do a guest reboot. Otherwise do a hard reset.'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'tools_status'
op|'=='
string|'"toolsOk"'
name|'and'
nl|'\n'
name|'tools_running_status'
op|'=='
string|'"guestToolsRunning"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Rebooting guest OS of VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
string|'"RebootGuest"'
op|','
nl|'\n'
name|'vm_ref'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Rebooted guest OS of VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Doing hard reboot of VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'reset_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"ResetVM_Task"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
name|'reset_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Did hard reboot of VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_delete
dedent|''
dedent|''
name|'def'
name|'_delete'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Destroy a VM instance. Steps followed are:\n        1. Power off the VM, if it is in poweredOn state.\n        2. Destroy the VM.\n        """'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'power_off'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Destroying the VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'destroy_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"Destroy_Task"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
name|'destroy_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Destroyed the VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'excep'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|'"In vmwareapi:vmops:delete, got this exception"'
nl|'\n'
string|'" while destroying the VM: %s"'
op|')'
op|'%'
name|'str'
op|'('
name|'excep'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'exc'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|destroy
dedent|''
dedent|''
name|'def'
name|'destroy'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'destroy_disks'
op|'='
name|'True'
op|','
nl|'\n'
name|'instance_name'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Destroy a VM instance. Steps followed are:\n        1. Power off the VM, if it is in poweredOn state.\n        2. Un-register a VM.\n        3. Delete the contents of the folder holding the VM related data.\n        """'
newline|'\n'
comment|"# Get the instance name. In some cases this may differ from the 'uuid',"
nl|'\n'
comment|'# for example when the spawn of a rescue instance takes place.'
nl|'\n'
name|'if'
name|'not'
name|'instance_name'
op|':'
newline|'\n'
indent|'            '
name|'instance_name'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref_from_name'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'instance_name'
op|')'
newline|'\n'
name|'lst_properties'
op|'='
op|'['
string|'"config.files.vmPathName"'
op|','
string|'"runtime.powerState"'
op|','
nl|'\n'
string|'"datastore"'
op|']'
newline|'\n'
name|'props'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
nl|'\n'
string|'"get_object_properties"'
op|','
nl|'\n'
name|'None'
op|','
name|'vm_ref'
op|','
string|'"VirtualMachine"'
op|','
name|'lst_properties'
op|')'
newline|'\n'
name|'query'
op|'='
op|'{'
string|"'runtime.powerState'"
op|':'
name|'None'
op|','
nl|'\n'
string|"'config.files.vmPathName'"
op|':'
name|'None'
op|','
nl|'\n'
string|"'datastore'"
op|':'
name|'None'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'_get_values_from_object_properties'
op|'('
name|'props'
op|','
name|'query'
op|')'
newline|'\n'
name|'pwr_state'
op|'='
name|'query'
op|'['
string|"'runtime.powerState'"
op|']'
newline|'\n'
name|'vm_config_pathname'
op|'='
name|'query'
op|'['
string|"'config.files.vmPathName'"
op|']'
newline|'\n'
name|'if'
name|'vm_config_pathname'
op|':'
newline|'\n'
indent|'                '
name|'_ds_path'
op|'='
name|'vm_util'
op|'.'
name|'split_datastore_path'
op|'('
name|'vm_config_pathname'
op|')'
newline|'\n'
name|'datastore_name'
op|','
name|'vmx_file_path'
op|'='
name|'_ds_path'
newline|'\n'
comment|'# Power off the VM if it is in PoweredOn state.'
nl|'\n'
dedent|''
name|'if'
name|'pwr_state'
op|'=='
string|'"poweredOn"'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Powering off the VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'poweroff_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"PowerOffVM_Task"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
name|'poweroff_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Powered off the VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
comment|'# Un-register the VM'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Unregistering the VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"UnregisterVM"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Unregistered the VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'excep'
op|':'
newline|'\n'
indent|'                '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|'"In vmwareapi:vmops:destroy, got this exception"'
nl|'\n'
string|'" while un-registering the VM: %s"'
op|')'
op|'%'
name|'str'
op|'('
name|'excep'
op|')'
op|')'
newline|'\n'
comment|'# Delete the folder holding the VM related content on'
nl|'\n'
comment|'# the datastore.'
nl|'\n'
dedent|''
name|'if'
name|'destroy_disks'
op|':'
newline|'\n'
indent|'                '
name|'try'
op|':'
newline|'\n'
indent|'                    '
name|'dir_ds_compliant_path'
op|'='
name|'vm_util'
op|'.'
name|'build_datastore_path'
op|'('
nl|'\n'
name|'datastore_name'
op|','
nl|'\n'
name|'os'
op|'.'
name|'path'
op|'.'
name|'dirname'
op|'('
name|'vmx_file_path'
op|')'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Deleting contents of the VM from "'
nl|'\n'
string|'"datastore %(datastore_name)s"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'datastore_name'"
op|':'
name|'datastore_name'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'ds_ref_ret'
op|'='
name|'query'
op|'['
string|"'datastore'"
op|']'
newline|'\n'
name|'ds_ref'
op|'='
name|'ds_ref_ret'
op|'.'
name|'ManagedObjectReference'
op|'['
number|'0'
op|']'
newline|'\n'
name|'dc_info'
op|'='
name|'self'
op|'.'
name|'get_datacenter_ref_and_name'
op|'('
name|'ds_ref'
op|')'
newline|'\n'
name|'vim'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
newline|'\n'
name|'delete_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'vim'
op|','
nl|'\n'
string|'"DeleteDatastoreFile_Task"'
op|','
nl|'\n'
name|'vim'
op|'.'
name|'get_service_content'
op|'('
op|')'
op|'.'
name|'fileManager'
op|','
nl|'\n'
name|'name'
op|'='
name|'dir_ds_compliant_path'
op|','
nl|'\n'
name|'datacenter'
op|'='
name|'dc_info'
op|'.'
name|'ref'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
name|'delete_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Deleted contents of the VM from "'
nl|'\n'
string|'"datastore %(datastore_name)s"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|"'datastore_name'"
op|':'
name|'datastore_name'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'excep'
op|':'
newline|'\n'
indent|'                    '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|'"In vmwareapi:vmops:destroy, "'
nl|'\n'
string|'"got this exception while deleting"'
nl|'\n'
string|'" the VM contents from the disk: %s"'
op|')'
nl|'\n'
op|'%'
name|'str'
op|'('
name|'excep'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'exc'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'exception'
op|'('
name|'exc'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|pause
dedent|''
dedent|''
name|'def'
name|'pause'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'msg'
op|'='
name|'_'
op|'('
string|'"pause not supported for vmwareapi"'
op|')'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|unpause
dedent|''
name|'def'
name|'unpause'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'msg'
op|'='
name|'_'
op|'('
string|'"unpause not supported for vmwareapi"'
op|')'
newline|'\n'
name|'raise'
name|'NotImplementedError'
op|'('
name|'msg'
op|')'
newline|'\n'
nl|'\n'
DECL|member|suspend
dedent|''
name|'def'
name|'suspend'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Suspend the specified instance."""'
newline|'\n'
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'instance'
op|')'
newline|'\n'
name|'pwr_state'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
nl|'\n'
string|'"get_dynamic_property"'
op|','
name|'vm_ref'
op|','
nl|'\n'
string|'"VirtualMachine"'
op|','
string|'"runtime.powerState"'
op|')'
newline|'\n'
comment|'# Only PoweredOn VMs can be suspended.'
nl|'\n'
name|'if'
name|'pwr_state'
op|'=='
string|'"poweredOn"'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Suspending the VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'suspend_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"SuspendVM_Task"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
name|'suspend_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Suspended the VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
comment|'# Raise Exception if VM is poweredOff'
nl|'\n'
dedent|''
name|'elif'
name|'pwr_state'
op|'=='
string|'"poweredOff"'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
name|'_'
op|'('
string|'"instance is powered off and cannot be suspended."'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstanceSuspendFailure'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"VM was already in suspended state. So returning "'
nl|'\n'
string|'"without doing anything"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|resume
dedent|''
dedent|''
name|'def'
name|'resume'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Resume the specified instance."""'
newline|'\n'
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'instance'
op|')'
newline|'\n'
name|'pwr_state'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
nl|'\n'
string|'"get_dynamic_property"'
op|','
name|'vm_ref'
op|','
nl|'\n'
string|'"VirtualMachine"'
op|','
string|'"runtime.powerState"'
op|')'
newline|'\n'
name|'if'
name|'pwr_state'
op|'.'
name|'lower'
op|'('
op|')'
op|'=='
string|'"suspended"'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Resuming the VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'suspend_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"PowerOnVM_Task"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
name|'suspend_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Resumed the VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
name|'_'
op|'('
string|'"instance is not in a suspended state"'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstanceResumeFailure'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
nl|'\n'
DECL|member|rescue
dedent|''
dedent|''
name|'def'
name|'rescue'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'image_meta'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Rescue the specified instance.\n\n            - shutdown the instance VM.\n            - spawn a rescue VM (the vm name-label will be instance-N-rescue).\n\n        """'
newline|'\n'
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'self'
op|'.'
name|'power_off'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'r_instance'
op|'='
name|'copy'
op|'.'
name|'deepcopy'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'instance_name'
op|'='
name|'r_instance'
op|'['
string|"'uuid'"
op|']'
op|'+'
name|'self'
op|'.'
name|'_rescue_suffix'
newline|'\n'
name|'self'
op|'.'
name|'spawn'
op|'('
name|'context'
op|','
name|'r_instance'
op|','
name|'image_meta'
op|','
nl|'\n'
name|'None'
op|','
name|'None'
op|','
name|'network_info'
op|','
nl|'\n'
name|'instance_name'
op|'='
name|'instance_name'
op|','
nl|'\n'
name|'power_on'
op|'='
name|'False'
op|')'
newline|'\n'
nl|'\n'
comment|'# Attach vmdk to the rescue VM'
nl|'\n'
name|'hardware_devices'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
nl|'\n'
string|'"get_dynamic_property"'
op|','
name|'vm_ref'
op|','
nl|'\n'
string|'"VirtualMachine"'
op|','
string|'"config.hardware.device"'
op|')'
newline|'\n'
op|'('
name|'vmdk_path'
op|','
name|'adapter_type'
op|','
nl|'\n'
name|'disk_type'
op|')'
op|'='
name|'vm_util'
op|'.'
name|'get_vmdk_path_and_adapter_type'
op|'('
nl|'\n'
name|'hardware_devices'
op|','
name|'uuid'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
name|'rescue_vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref_from_name'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
nl|'\n'
name|'instance_name'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_volumeops'
op|'.'
name|'attach_disk_to_vm'
op|'('
nl|'\n'
name|'rescue_vm_ref'
op|','
name|'r_instance'
op|','
nl|'\n'
name|'adapter_type'
op|','
name|'disk_type'
op|','
name|'vmdk_path'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_power_on'
op|'('
name|'instance'
op|','
name|'vm_ref'
op|'='
name|'rescue_vm_ref'
op|')'
newline|'\n'
nl|'\n'
DECL|member|unrescue
dedent|''
name|'def'
name|'unrescue'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Unrescue the specified instance."""'
newline|'\n'
comment|'# Get the original vmdk_path'
nl|'\n'
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'instance'
op|')'
newline|'\n'
name|'hardware_devices'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
nl|'\n'
string|'"get_dynamic_property"'
op|','
name|'vm_ref'
op|','
nl|'\n'
string|'"VirtualMachine"'
op|','
string|'"config.hardware.device"'
op|')'
newline|'\n'
op|'('
name|'vmdk_path'
op|','
name|'adapter_type'
op|','
nl|'\n'
name|'disk_type'
op|')'
op|'='
name|'vm_util'
op|'.'
name|'get_vmdk_path_and_adapter_type'
op|'('
nl|'\n'
name|'hardware_devices'
op|','
name|'uuid'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
nl|'\n'
name|'r_instance'
op|'='
name|'copy'
op|'.'
name|'deepcopy'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'instance_name'
op|'='
name|'r_instance'
op|'['
string|"'uuid'"
op|']'
op|'+'
name|'self'
op|'.'
name|'_rescue_suffix'
newline|'\n'
comment|'# detach the original instance disk from the rescue disk'
nl|'\n'
name|'vm_rescue_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref_from_name'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
nl|'\n'
name|'instance_name'
op|')'
newline|'\n'
name|'hardware_devices'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
nl|'\n'
string|'"get_dynamic_property"'
op|','
name|'vm_rescue_ref'
op|','
nl|'\n'
string|'"VirtualMachine"'
op|','
string|'"config.hardware.device"'
op|')'
newline|'\n'
name|'device'
op|'='
name|'vm_util'
op|'.'
name|'get_vmdk_volume_disk'
op|'('
name|'hardware_devices'
op|','
name|'path'
op|'='
name|'vmdk_path'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_volumeops'
op|'.'
name|'detach_disk_from_vm'
op|'('
name|'vm_rescue_ref'
op|','
name|'r_instance'
op|','
name|'device'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'destroy'
op|'('
name|'r_instance'
op|','
name|'None'
op|','
name|'instance_name'
op|'='
name|'instance_name'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_power_on'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|power_off
dedent|''
name|'def'
name|'power_off'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Power off the specified instance."""'
newline|'\n'
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'pwr_state'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
nl|'\n'
string|'"get_dynamic_property"'
op|','
name|'vm_ref'
op|','
nl|'\n'
string|'"VirtualMachine"'
op|','
string|'"runtime.powerState"'
op|')'
newline|'\n'
comment|'# Only PoweredOn VMs can be powered off.'
nl|'\n'
name|'if'
name|'pwr_state'
op|'=='
string|'"poweredOn"'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Powering off the VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'poweroff_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"PowerOffVM_Task"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
name|'poweroff_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Powered off the VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
comment|'# Raise Exception if VM is suspended'
nl|'\n'
dedent|''
name|'elif'
name|'pwr_state'
op|'=='
string|'"suspended"'
op|':'
newline|'\n'
indent|'            '
name|'reason'
op|'='
name|'_'
op|'('
string|'"instance is suspended and cannot be powered off."'
op|')'
newline|'\n'
name|'raise'
name|'exception'
op|'.'
name|'InstancePowerOffFailure'
op|'('
name|'reason'
op|'='
name|'reason'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"VM was already in powered off state. So returning "'
nl|'\n'
string|'"without doing anything"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_power_on
dedent|''
dedent|''
name|'def'
name|'_power_on'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'vm_ref'
op|'='
name|'None'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Power on the specified instance."""'
newline|'\n'
name|'if'
name|'not'
name|'vm_ref'
op|':'
newline|'\n'
indent|'            '
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'pwr_state'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
nl|'\n'
string|'"get_dynamic_property"'
op|','
name|'vm_ref'
op|','
nl|'\n'
string|'"VirtualMachine"'
op|','
string|'"runtime.powerState"'
op|')'
newline|'\n'
name|'if'
name|'pwr_state'
op|'=='
string|'"poweredOn"'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"VM was already in powered on state. So returning "'
nl|'\n'
string|'"without doing anything"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
comment|'# Only PoweredOff and Suspended VMs can be powered on.'
nl|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Powering on the VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'poweron_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"PowerOnVM_Task"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
name|'poweron_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Powered on the VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|power_on
dedent|''
dedent|''
name|'def'
name|'power_on'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
name|'block_device_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'self'
op|'.'
name|'_power_on'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_get_orig_vm_name_label
dedent|''
name|'def'
name|'_get_orig_vm_name_label'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|'+'
string|"'-orig'"
newline|'\n'
nl|'\n'
DECL|member|_update_instance_progress
dedent|''
name|'def'
name|'_update_instance_progress'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'step'
op|','
name|'total_steps'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Update instance progress percent to reflect current step number\n        """'
newline|'\n'
comment|'# Divide the action\'s workflow into discrete steps and "bump" the'
nl|'\n'
comment|"# instance's progress field as each step is completed."
nl|'\n'
comment|'#'
nl|'\n'
comment|'# For a first cut this should be fine, however, for large VM images,'
nl|'\n'
comment|'# the clone disk step begins to dominate the equation. A'
nl|'\n'
comment|'# better approximation would use the percentage of the VM image that'
nl|'\n'
comment|'# has been streamed to the destination host.'
nl|'\n'
name|'progress'
op|'='
name|'round'
op|'('
name|'float'
op|'('
name|'step'
op|')'
op|'/'
name|'total_steps'
op|'*'
number|'100'
op|')'
newline|'\n'
name|'instance_uuid'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Updating instance \'%(instance_uuid)s\' progress to"'
nl|'\n'
string|'" %(progress)d"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'instance_uuid'"
op|':'
name|'instance_uuid'
op|','
string|"'progress'"
op|':'
name|'progress'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_virtapi'
op|'.'
name|'instance_update'
op|'('
name|'context'
op|','
name|'instance_uuid'
op|','
nl|'\n'
op|'{'
string|"'progress'"
op|':'
name|'progress'
op|'}'
op|')'
newline|'\n'
nl|'\n'
DECL|member|migrate_disk_and_power_off
dedent|''
name|'def'
name|'migrate_disk_and_power_off'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'dest'
op|','
nl|'\n'
name|'flavor'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Transfers the disk of a running instance in multiple phases, turning\n        off the instance before the end.\n        """'
newline|'\n'
comment|'# 0. Zero out the progress to begin'
nl|'\n'
name|'self'
op|'.'
name|'_update_instance_progress'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'step'
op|'='
number|'0'
op|','
nl|'\n'
name|'total_steps'
op|'='
name|'RESIZE_TOTAL_STEPS'
op|')'
newline|'\n'
nl|'\n'
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'instance'
op|')'
newline|'\n'
comment|'# Read the host_ref for the destination. If this is None then the'
nl|'\n'
comment|'# VC will decide on placement'
nl|'\n'
name|'host_ref'
op|'='
name|'self'
op|'.'
name|'_get_host_ref_from_name'
op|'('
name|'dest'
op|')'
newline|'\n'
nl|'\n'
comment|'# 1. Power off the instance'
nl|'\n'
name|'self'
op|'.'
name|'power_off'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_update_instance_progress'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'step'
op|'='
number|'1'
op|','
nl|'\n'
name|'total_steps'
op|'='
name|'RESIZE_TOTAL_STEPS'
op|')'
newline|'\n'
nl|'\n'
comment|"# 2. Rename the original VM with suffix '-orig'"
nl|'\n'
name|'name_label'
op|'='
name|'self'
op|'.'
name|'_get_orig_vm_name_label'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Renaming the VM to %s"'
op|')'
op|'%'
name|'name_label'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'rename_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"Rename_Task"'
op|','
name|'vm_ref'
op|','
name|'newName'
op|'='
name|'name_label'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
name|'rename_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Renamed the VM to %s"'
op|')'
op|'%'
name|'name_label'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_update_instance_progress'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'step'
op|'='
number|'2'
op|','
nl|'\n'
name|'total_steps'
op|'='
name|'RESIZE_TOTAL_STEPS'
op|')'
newline|'\n'
nl|'\n'
comment|'# Get the clone vm spec'
nl|'\n'
name|'ds_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_datastore_ref_and_name'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|','
name|'self'
op|'.'
name|'_cluster'
op|','
name|'host_ref'
op|','
nl|'\n'
name|'datastore_regex'
op|'='
name|'self'
op|'.'
name|'_datastore_regex'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'client_factory'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|'.'
name|'client'
op|'.'
name|'factory'
newline|'\n'
name|'rel_spec'
op|'='
name|'vm_util'
op|'.'
name|'relocate_vm_spec'
op|'('
name|'client_factory'
op|','
name|'ds_ref'
op|','
name|'host_ref'
op|')'
newline|'\n'
name|'clone_spec'
op|'='
name|'vm_util'
op|'.'
name|'clone_vm_spec'
op|'('
name|'client_factory'
op|','
name|'rel_spec'
op|')'
newline|'\n'
name|'dc_info'
op|'='
name|'self'
op|'.'
name|'get_datacenter_ref_and_name'
op|'('
name|'ds_ref'
op|')'
newline|'\n'
nl|'\n'
comment|'# 3. Clone VM on ESX host'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Cloning VM to host %s"'
op|')'
op|'%'
name|'dest'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'vm_clone_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"CloneVM_Task"'
op|','
name|'vm_ref'
op|','
nl|'\n'
name|'folder'
op|'='
name|'dc_info'
op|'.'
name|'vmFolder'
op|','
nl|'\n'
name|'name'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
nl|'\n'
name|'spec'
op|'='
name|'clone_spec'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
name|'vm_clone_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Cloned VM to host %s"'
op|')'
op|'%'
name|'dest'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_update_instance_progress'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'step'
op|'='
number|'3'
op|','
nl|'\n'
name|'total_steps'
op|'='
name|'RESIZE_TOTAL_STEPS'
op|')'
newline|'\n'
nl|'\n'
DECL|member|confirm_migration
dedent|''
name|'def'
name|'confirm_migration'
op|'('
name|'self'
op|','
name|'migration'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Confirms a resize, destroying the source VM."""'
newline|'\n'
name|'instance_name'
op|'='
name|'self'
op|'.'
name|'_get_orig_vm_name_label'
op|'('
name|'instance'
op|')'
newline|'\n'
comment|'# Destroy the original VM. The vm_ref is via the instance_name'
nl|'\n'
comment|'# and not the UUID'
nl|'\n'
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref_from_name'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'instance_name'
op|')'
newline|'\n'
name|'if'
name|'vm_ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"instance not present"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Destroying the VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'destroy_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"Destroy_Task"'
op|','
name|'vm_ref'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance_name'
op|','
name|'destroy_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Destroyed the VM"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
name|'as'
name|'excep'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'warn'
op|'('
name|'_'
op|'('
string|'"In vmwareapi:vmops:confirm_migration, got this "'
nl|'\n'
string|'"exception while destroying the VM: %s"'
op|')'
op|'%'
name|'str'
op|'('
name|'excep'
op|')'
op|')'
newline|'\n'
nl|'\n'
DECL|member|finish_revert_migration
dedent|''
dedent|''
name|'def'
name|'finish_revert_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance'
op|','
name|'network_info'
op|','
nl|'\n'
name|'block_device_info'
op|','
name|'power_on'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Finish reverting a resize."""'
newline|'\n'
comment|"# The original vm was suffixed with '-orig'; find it using"
nl|'\n'
comment|'# the old suffix, remove the suffix, then power it back on.'
nl|'\n'
name|'name_label'
op|'='
name|'self'
op|'.'
name|'_get_orig_vm_name_label'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref_from_name'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'name_label'
op|')'
newline|'\n'
name|'if'
name|'vm_ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'InstanceNotFound'
op|'('
name|'instance_id'
op|'='
name|'name_label'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Renaming the VM from %s"'
op|')'
op|'%'
name|'name_label'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'rename_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"Rename_Task"'
op|','
name|'vm_ref'
op|','
name|'newName'
op|'='
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
name|'rename_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Renamed the VM from %s"'
op|')'
op|'%'
name|'name_label'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'if'
name|'power_on'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_power_on'
op|'('
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|finish_migration
dedent|''
dedent|''
name|'def'
name|'finish_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'migration'
op|','
name|'instance'
op|','
name|'disk_info'
op|','
nl|'\n'
name|'network_info'
op|','
name|'image_meta'
op|','
name|'resize_instance'
op|'='
name|'False'
op|','
nl|'\n'
name|'block_device_info'
op|'='
name|'None'
op|','
name|'power_on'
op|'='
name|'True'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Completes a resize, turning on the migrated instance."""'
newline|'\n'
name|'if'
name|'resize_instance'
op|':'
newline|'\n'
indent|'            '
name|'client_factory'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|'.'
name|'client'
op|'.'
name|'factory'
newline|'\n'
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'instance'
op|')'
newline|'\n'
name|'vm_resize_spec'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_resize_spec'
op|'('
name|'client_factory'
op|','
nl|'\n'
name|'instance'
op|')'
newline|'\n'
name|'reconfig_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"ReconfigVM_Task"'
op|','
name|'vm_ref'
op|','
nl|'\n'
name|'spec'
op|'='
name|'vm_resize_spec'
op|')'
newline|'\n'
nl|'\n'
comment|'# 4. Start VM'
nl|'\n'
dedent|''
name|'if'
name|'power_on'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_power_on'
op|'('
name|'instance'
op|')'
newline|'\n'
dedent|''
name|'self'
op|'.'
name|'_update_instance_progress'
op|'('
name|'context'
op|','
name|'instance'
op|','
nl|'\n'
name|'step'
op|'='
number|'4'
op|','
nl|'\n'
name|'total_steps'
op|'='
name|'RESIZE_TOTAL_STEPS'
op|')'
newline|'\n'
nl|'\n'
DECL|member|live_migration
dedent|''
name|'def'
name|'live_migration'
op|'('
name|'self'
op|','
name|'context'
op|','
name|'instance_ref'
op|','
name|'dest'
op|','
nl|'\n'
name|'post_method'
op|','
name|'recover_method'
op|','
name|'block_migration'
op|'='
name|'False'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Spawning live_migration operation for distributing high-load."""'
newline|'\n'
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'instance_ref'
op|')'
newline|'\n'
nl|'\n'
name|'host_ref'
op|'='
name|'self'
op|'.'
name|'_get_host_ref_from_name'
op|'('
name|'dest'
op|')'
newline|'\n'
name|'if'
name|'host_ref'
name|'is'
name|'None'
op|':'
newline|'\n'
indent|'            '
name|'raise'
name|'exception'
op|'.'
name|'HostNotFound'
op|'('
name|'host'
op|'='
name|'dest'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Migrating VM to host %s"'
op|')'
op|'%'
name|'dest'
op|','
name|'instance'
op|'='
name|'instance_ref'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'vm_migrate_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"MigrateVM_Task"'
op|','
name|'vm_ref'
op|','
nl|'\n'
name|'host'
op|'='
name|'host_ref'
op|','
nl|'\n'
name|'priority'
op|'='
string|'"defaultPriority"'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance_ref'
op|'['
string|"'uuid'"
op|']'
op|','
name|'vm_migrate_task'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|':'
newline|'\n'
indent|'            '
name|'with'
name|'excutils'
op|'.'
name|'save_and_reraise_exception'
op|'('
op|')'
op|':'
newline|'\n'
indent|'                '
name|'recover_method'
op|'('
name|'context'
op|','
name|'instance_ref'
op|','
name|'dest'
op|','
name|'block_migration'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'post_method'
op|'('
name|'context'
op|','
name|'instance_ref'
op|','
name|'dest'
op|','
name|'block_migration'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Migrated VM to host %s"'
op|')'
op|'%'
name|'dest'
op|','
name|'instance'
op|'='
name|'instance_ref'
op|')'
newline|'\n'
nl|'\n'
DECL|member|poll_rebooting_instances
dedent|''
name|'def'
name|'poll_rebooting_instances'
op|'('
name|'self'
op|','
name|'timeout'
op|','
name|'instances'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Poll for rebooting instances."""'
newline|'\n'
name|'ctxt'
op|'='
name|'nova_context'
op|'.'
name|'get_admin_context'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'instances_info'
op|'='
name|'dict'
op|'('
name|'instance_count'
op|'='
name|'len'
op|'('
name|'instances'
op|')'
op|','
nl|'\n'
name|'timeout'
op|'='
name|'timeout'
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'instances_info'
op|'['
string|'"instance_count"'
op|']'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"Found %(instance_count)d hung reboots "'
nl|'\n'
string|'"older than %(timeout)d seconds"'
op|')'
op|'%'
name|'instances_info'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'for'
name|'instance'
name|'in'
name|'instances'
op|':'
newline|'\n'
indent|'            '
name|'LOG'
op|'.'
name|'info'
op|'('
name|'_'
op|'('
string|'"Automatically hard rebooting"'
op|')'
op|','
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'compute_api'
op|'.'
name|'reboot'
op|'('
name|'ctxt'
op|','
name|'instance'
op|','
string|'"HARD"'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_info
dedent|''
dedent|''
name|'def'
name|'get_info'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return data about the VM instance."""'
newline|'\n'
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'lst_properties'
op|'='
op|'['
string|'"summary.config.numCpu"'
op|','
nl|'\n'
string|'"summary.config.memorySizeMB"'
op|','
nl|'\n'
string|'"runtime.powerState"'
op|']'
newline|'\n'
name|'vm_props'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
nl|'\n'
string|'"get_object_properties"'
op|','
name|'None'
op|','
name|'vm_ref'
op|','
string|'"VirtualMachine"'
op|','
nl|'\n'
name|'lst_properties'
op|')'
newline|'\n'
name|'query'
op|'='
op|'{'
string|"'summary.config.numCpu'"
op|':'
name|'None'
op|','
nl|'\n'
string|"'summary.config.memorySizeMB'"
op|':'
name|'None'
op|','
nl|'\n'
string|"'runtime.powerState'"
op|':'
name|'None'
op|'}'
newline|'\n'
name|'self'
op|'.'
name|'_get_values_from_object_properties'
op|'('
name|'vm_props'
op|','
name|'query'
op|')'
newline|'\n'
name|'max_mem'
op|'='
name|'int'
op|'('
name|'query'
op|'['
string|"'summary.config.memorySizeMB'"
op|']'
op|')'
op|'*'
number|'1024'
newline|'\n'
name|'return'
op|'{'
string|"'state'"
op|':'
name|'VMWARE_POWER_STATES'
op|'['
name|'query'
op|'['
string|"'runtime.powerState'"
op|']'
op|']'
op|','
nl|'\n'
string|"'max_mem'"
op|':'
name|'max_mem'
op|','
nl|'\n'
string|"'mem'"
op|':'
name|'max_mem'
op|','
nl|'\n'
string|"'num_cpu'"
op|':'
name|'int'
op|'('
name|'query'
op|'['
string|"'summary.config.numCpu'"
op|']'
op|')'
op|','
nl|'\n'
string|"'cpu_time'"
op|':'
number|'0'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|_get_diagnostic_from_object_properties
dedent|''
name|'def'
name|'_get_diagnostic_from_object_properties'
op|'('
name|'self'
op|','
name|'props'
op|','
name|'wanted_props'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'diagnostics'
op|'='
op|'{'
op|'}'
newline|'\n'
name|'while'
name|'props'
op|':'
newline|'\n'
indent|'            '
name|'for'
name|'elem'
name|'in'
name|'props'
op|'.'
name|'objects'
op|':'
newline|'\n'
indent|'                '
name|'for'
name|'prop'
name|'in'
name|'elem'
op|'.'
name|'propSet'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'prop'
op|'.'
name|'name'
name|'in'
name|'wanted_props'
op|':'
newline|'\n'
indent|'                        '
name|'prop_dict'
op|'='
name|'vim'
op|'.'
name|'object_to_dict'
op|'('
name|'prop'
op|'.'
name|'val'
op|','
name|'list_depth'
op|'='
number|'1'
op|')'
newline|'\n'
name|'diagnostics'
op|'.'
name|'update'
op|'('
name|'prop_dict'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'token'
op|'='
name|'vm_util'
op|'.'
name|'_get_token'
op|'('
name|'props'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'token'
op|':'
newline|'\n'
indent|'                '
name|'break'
newline|'\n'
nl|'\n'
dedent|''
name|'props'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
nl|'\n'
string|'"continue_to_get_objects"'
op|','
nl|'\n'
name|'token'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'diagnostics'
newline|'\n'
nl|'\n'
DECL|member|get_diagnostics
dedent|''
name|'def'
name|'get_diagnostics'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return data about VM diagnostics."""'
newline|'\n'
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'instance'
op|')'
newline|'\n'
name|'lst_properties'
op|'='
op|'['
string|'"summary.config"'
op|','
nl|'\n'
string|'"summary.quickStats"'
op|','
nl|'\n'
string|'"summary.runtime"'
op|']'
newline|'\n'
name|'vm_props'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
nl|'\n'
string|'"get_object_properties"'
op|','
name|'None'
op|','
name|'vm_ref'
op|','
string|'"VirtualMachine"'
op|','
nl|'\n'
name|'lst_properties'
op|')'
newline|'\n'
name|'data'
op|'='
name|'self'
op|'.'
name|'_get_diagnostic_from_object_properties'
op|'('
name|'vm_props'
op|','
nl|'\n'
name|'set'
op|'('
name|'lst_properties'
op|')'
op|')'
newline|'\n'
comment|'# Add a namespace to all of the diagnostsics'
nl|'\n'
name|'return'
name|'dict'
op|'('
op|'['
op|'('
string|"'vmware:'"
op|'+'
name|'k'
op|','
name|'v'
op|')'
name|'for'
name|'k'
op|','
name|'v'
name|'in'
name|'data'
op|'.'
name|'items'
op|'('
op|')'
op|']'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_vnc_console
dedent|''
name|'def'
name|'get_vnc_console'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return connection info for a vnc console."""'
newline|'\n'
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'return'
op|'{'
string|"'host'"
op|':'
name|'CONF'
op|'.'
name|'vmware'
op|'.'
name|'host_ip'
op|','
nl|'\n'
string|"'port'"
op|':'
name|'self'
op|'.'
name|'_get_vnc_port'
op|'('
name|'vm_ref'
op|')'
op|','
nl|'\n'
string|"'internal_access_path'"
op|':'
name|'None'
op|'}'
newline|'\n'
nl|'\n'
DECL|member|get_vnc_console_vcenter
dedent|''
name|'def'
name|'get_vnc_console_vcenter'
op|'('
name|'self'
op|','
name|'instance'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return connection info for a vnc console using vCenter logic."""'
newline|'\n'
nl|'\n'
comment|'# vCenter does not run virtual machines and does not run'
nl|'\n'
comment|'# a VNC proxy. Instead, you need to tell OpenStack to talk'
nl|'\n'
comment|'# directly to the ESX host running the VM you are attempting'
nl|'\n'
comment|'# to connect to via VNC.'
nl|'\n'
nl|'\n'
name|'vnc_console'
op|'='
name|'self'
op|'.'
name|'get_vnc_console'
op|'('
name|'instance'
op|')'
newline|'\n'
name|'host_name'
op|'='
name|'vm_util'
op|'.'
name|'get_host_name_for_vm'
op|'('
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|','
nl|'\n'
name|'instance'
op|')'
newline|'\n'
name|'vnc_console'
op|'['
string|"'host'"
op|']'
op|'='
name|'host_name'
newline|'\n'
nl|'\n'
comment|'# NOTE: VM can move hosts in some situations. Debug for admins.'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"VM %(uuid)s is currently on host %(host_name)s"'
op|')'
op|','
nl|'\n'
op|'{'
string|"'uuid'"
op|':'
name|'instance'
op|'['
string|"'name'"
op|']'
op|','
string|"'host_name'"
op|':'
name|'host_name'
op|'}'
op|')'
newline|'\n'
nl|'\n'
name|'return'
name|'vnc_console'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_get_vnc_port
name|'def'
name|'_get_vnc_port'
op|'('
name|'vm_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Return VNC port for an VM."""'
newline|'\n'
name|'vm_id'
op|'='
name|'int'
op|'('
name|'vm_ref'
op|'.'
name|'value'
op|'.'
name|'replace'
op|'('
string|"'vm-'"
op|','
string|"''"
op|')'
op|')'
newline|'\n'
name|'port'
op|'='
name|'CONF'
op|'.'
name|'vmware'
op|'.'
name|'vnc_port'
op|'+'
name|'vm_id'
op|'%'
name|'CONF'
op|'.'
name|'vmware'
op|'.'
name|'vnc_port_total'
newline|'\n'
nl|'\n'
name|'return'
name|'port'
newline|'\n'
nl|'\n'
dedent|''
op|'@'
name|'staticmethod'
newline|'\n'
DECL|member|_get_machine_id_str
name|'def'
name|'_get_machine_id_str'
op|'('
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'machine_id_str'
op|'='
string|"''"
newline|'\n'
name|'for'
name|'vif'
name|'in'
name|'network_info'
op|':'
newline|'\n'
comment|'# TODO(vish): add support for dns2'
nl|'\n'
comment|'# TODO(sateesh): add support for injection of ipv6 configuration'
nl|'\n'
indent|'            '
name|'network'
op|'='
name|'vif'
op|'['
string|"'network'"
op|']'
newline|'\n'
name|'ip_v4'
op|'='
name|'netmask_v4'
op|'='
name|'gateway_v4'
op|'='
name|'broadcast_v4'
op|'='
name|'dns'
op|'='
name|'None'
newline|'\n'
name|'subnets_v4'
op|'='
op|'['
name|'s'
name|'for'
name|'s'
name|'in'
name|'network'
op|'['
string|"'subnets'"
op|']'
name|'if'
name|'s'
op|'['
string|"'version'"
op|']'
op|'=='
number|'4'
op|']'
newline|'\n'
name|'if'
name|'len'
op|'('
name|'subnets_v4'
op|'['
number|'0'
op|']'
op|'['
string|"'ips'"
op|']'
op|')'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'ip_v4'
op|'='
name|'subnets_v4'
op|'['
number|'0'
op|']'
op|'['
string|"'ips'"
op|']'
op|'['
number|'0'
op|']'
newline|'\n'
dedent|''
name|'if'
name|'len'
op|'('
name|'subnets_v4'
op|'['
number|'0'
op|']'
op|'['
string|"'dns'"
op|']'
op|')'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'                '
name|'dns'
op|'='
name|'subnets_v4'
op|'['
number|'0'
op|']'
op|'['
string|"'dns'"
op|']'
op|'['
number|'0'
op|']'
op|'['
string|"'address'"
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'netmask_v4'
op|'='
name|'str'
op|'('
name|'subnets_v4'
op|'['
number|'0'
op|']'
op|'.'
name|'as_netaddr'
op|'('
op|')'
op|'.'
name|'netmask'
op|')'
newline|'\n'
name|'gateway_v4'
op|'='
name|'subnets_v4'
op|'['
number|'0'
op|']'
op|'['
string|"'gateway'"
op|']'
op|'['
string|"'address'"
op|']'
newline|'\n'
name|'broadcast_v4'
op|'='
name|'str'
op|'('
name|'subnets_v4'
op|'['
number|'0'
op|']'
op|'.'
name|'as_netaddr'
op|'('
op|')'
op|'.'
name|'broadcast'
op|')'
newline|'\n'
nl|'\n'
name|'interface_str'
op|'='
string|'";"'
op|'.'
name|'join'
op|'('
op|'['
name|'vif'
op|'['
string|"'address'"
op|']'
op|','
nl|'\n'
name|'ip_v4'
name|'and'
name|'ip_v4'
op|'['
string|"'address'"
op|']'
name|'or'
string|"''"
op|','
nl|'\n'
name|'netmask_v4'
name|'or'
string|"''"
op|','
nl|'\n'
name|'gateway_v4'
name|'or'
string|"''"
op|','
nl|'\n'
name|'broadcast_v4'
name|'or'
string|"''"
op|','
nl|'\n'
name|'dns'
name|'or'
string|"''"
op|']'
op|')'
newline|'\n'
name|'machine_id_str'
op|'='
name|'machine_id_str'
op|'+'
name|'interface_str'
op|'+'
string|"'#'"
newline|'\n'
dedent|''
name|'return'
name|'machine_id_str'
newline|'\n'
nl|'\n'
DECL|member|_set_machine_id
dedent|''
name|'def'
name|'_set_machine_id'
op|'('
name|'self'
op|','
name|'client_factory'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Set the machine id of the VM for guest tools to pick up and reconfigure\n        the network interfaces.\n        """'
newline|'\n'
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'machine_id_change_spec'
op|'='
name|'vm_util'
op|'.'
name|'get_machine_id_change_spec'
op|'('
nl|'\n'
name|'client_factory'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_get_machine_id_str'
op|'('
name|'network_info'
op|')'
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Reconfiguring VM instance to set the machine id"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'reconfig_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"ReconfigVM_Task"'
op|','
name|'vm_ref'
op|','
nl|'\n'
name|'spec'
op|'='
name|'machine_id_change_spec'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
name|'reconfig_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Reconfigured VM instance to set the machine id"'
op|')'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_set_vnc_config
dedent|''
name|'def'
name|'_set_vnc_config'
op|'('
name|'self'
op|','
name|'client_factory'
op|','
name|'instance'
op|','
name|'port'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Set the vnc configuration of the VM.\n        """'
newline|'\n'
name|'vm_ref'
op|'='
name|'vm_util'
op|'.'
name|'get_vm_ref'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'instance'
op|')'
newline|'\n'
nl|'\n'
name|'vnc_config_spec'
op|'='
name|'vm_util'
op|'.'
name|'get_vnc_config_spec'
op|'('
nl|'\n'
name|'client_factory'
op|','
name|'port'
op|')'
newline|'\n'
nl|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Reconfiguring VM instance to enable vnc on "'
nl|'\n'
string|'"port - %(port)s"'
op|')'
op|'%'
op|'{'
string|"'port'"
op|':'
name|'port'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
name|'reconfig_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"ReconfigVM_Task"'
op|','
name|'vm_ref'
op|','
nl|'\n'
name|'spec'
op|'='
name|'vnc_config_spec'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_wait_for_task'
op|'('
name|'instance'
op|'['
string|"'uuid'"
op|']'
op|','
name|'reconfig_task'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Reconfigured VM instance to enable vnc on "'
nl|'\n'
string|'"port - %(port)s"'
op|')'
op|'%'
op|'{'
string|"'port'"
op|':'
name|'port'
op|'}'
op|','
nl|'\n'
name|'instance'
op|'='
name|'instance'
op|')'
newline|'\n'
nl|'\n'
DECL|member|get_datacenter_ref_and_name
dedent|''
name|'def'
name|'get_datacenter_ref_and_name'
op|'('
name|'self'
op|','
name|'ds_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the datacenter name and the reference."""'
newline|'\n'
name|'map'
op|'='
name|'self'
op|'.'
name|'_datastore_dc_mapping'
op|'.'
name|'get'
op|'('
name|'ds_ref'
op|'.'
name|'value'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'map'
op|':'
newline|'\n'
indent|'            '
name|'dc_obj'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
string|'"get_objects"'
op|','
nl|'\n'
string|'"Datacenter"'
op|','
op|'['
string|'"name"'
op|']'
op|')'
newline|'\n'
name|'vm_util'
op|'.'
name|'_cancel_retrieve_if_necessary'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'dc_obj'
op|')'
newline|'\n'
name|'map'
op|'='
name|'DcInfo'
op|'('
name|'ref'
op|'='
name|'dc_obj'
op|'.'
name|'objects'
op|'['
number|'0'
op|']'
op|'.'
name|'obj'
op|','
nl|'\n'
name|'name'
op|'='
name|'dc_obj'
op|'.'
name|'objects'
op|'['
number|'0'
op|']'
op|'.'
name|'propSet'
op|'['
number|'0'
op|']'
op|'.'
name|'val'
op|','
nl|'\n'
name|'vmFolder'
op|'='
name|'self'
op|'.'
name|'_get_vmfolder_ref'
op|'('
op|')'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_datastore_dc_mapping'
op|'['
name|'ds_ref'
op|'.'
name|'value'
op|']'
op|'='
name|'map'
newline|'\n'
dedent|''
name|'return'
name|'map'
newline|'\n'
nl|'\n'
DECL|member|_get_host_ref_from_name
dedent|''
name|'def'
name|'_get_host_ref_from_name'
op|'('
name|'self'
op|','
name|'host_name'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get reference to the host with the name specified."""'
newline|'\n'
name|'host_objs'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
string|'"get_objects"'
op|','
nl|'\n'
string|'"HostSystem"'
op|','
op|'['
string|'"name"'
op|']'
op|')'
newline|'\n'
name|'vm_util'
op|'.'
name|'_cancel_retrieve_if_necessary'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'host_objs'
op|')'
newline|'\n'
name|'for'
name|'host'
name|'in'
name|'host_objs'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'hasattr'
op|'('
name|'host'
op|','
string|"'propSet'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'host'
op|'.'
name|'propSet'
op|'['
number|'0'
op|']'
op|'.'
name|'val'
op|'=='
name|'host_name'
op|':'
newline|'\n'
indent|'                    '
name|'return'
name|'host'
op|'.'
name|'obj'
newline|'\n'
dedent|''
dedent|''
dedent|''
name|'return'
name|'None'
newline|'\n'
nl|'\n'
DECL|member|_get_vmfolder_ref
dedent|''
name|'def'
name|'_get_vmfolder_ref'
op|'('
name|'self'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the Vm folder ref from the datacenter."""'
newline|'\n'
name|'dc_objs'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
string|'"get_objects"'
op|','
nl|'\n'
string|'"Datacenter"'
op|','
op|'['
string|'"vmFolder"'
op|']'
op|')'
newline|'\n'
name|'vm_util'
op|'.'
name|'_cancel_retrieve_if_necessary'
op|'('
name|'self'
op|'.'
name|'_session'
op|','
name|'dc_objs'
op|')'
newline|'\n'
comment|'# There is only one default datacenter in a standalone ESX host'
nl|'\n'
name|'vm_folder_ref'
op|'='
name|'dc_objs'
op|'.'
name|'objects'
op|'['
number|'0'
op|']'
op|'.'
name|'propSet'
op|'['
number|'0'
op|']'
op|'.'
name|'val'
newline|'\n'
name|'return'
name|'vm_folder_ref'
newline|'\n'
nl|'\n'
DECL|member|_path_exists
dedent|''
name|'def'
name|'_path_exists'
op|'('
name|'self'
op|','
name|'ds_browser'
op|','
name|'ds_path'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check if the path exists on the datastore."""'
newline|'\n'
name|'search_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"SearchDatastore_Task"'
op|','
nl|'\n'
name|'ds_browser'
op|','
nl|'\n'
name|'datastorePath'
op|'='
name|'ds_path'
op|')'
newline|'\n'
comment|'# Wait till the state changes from queued or running.'
nl|'\n'
comment|"# If an error state is returned, it means that the path doesn't exist."
nl|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'task_info'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
nl|'\n'
string|'"get_dynamic_property"'
op|','
nl|'\n'
name|'search_task'
op|','
string|'"Task"'
op|','
string|'"info"'
op|')'
newline|'\n'
name|'if'
name|'task_info'
op|'.'
name|'state'
name|'in'
op|'['
string|"'queued'"
op|','
string|"'running'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'time'
op|'.'
name|'sleep'
op|'('
number|'2'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'break'
newline|'\n'
dedent|''
name|'if'
name|'task_info'
op|'.'
name|'state'
op|'=='
string|'"error"'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'return'
name|'True'
newline|'\n'
nl|'\n'
DECL|member|_path_file_exists
dedent|''
name|'def'
name|'_path_file_exists'
op|'('
name|'self'
op|','
name|'ds_browser'
op|','
name|'ds_path'
op|','
name|'file_name'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Check if the path and file exists on the datastore."""'
newline|'\n'
name|'client_factory'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|'.'
name|'client'
op|'.'
name|'factory'
newline|'\n'
name|'search_spec'
op|'='
name|'vm_util'
op|'.'
name|'search_datastore_spec'
op|'('
name|'client_factory'
op|','
name|'file_name'
op|')'
newline|'\n'
name|'search_task'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
nl|'\n'
string|'"SearchDatastore_Task"'
op|','
nl|'\n'
name|'ds_browser'
op|','
nl|'\n'
name|'datastorePath'
op|'='
name|'ds_path'
op|','
nl|'\n'
name|'searchSpec'
op|'='
name|'search_spec'
op|')'
newline|'\n'
comment|'# Wait till the state changes from queued or running.'
nl|'\n'
comment|"# If an error state is returned, it means that the path doesn't exist."
nl|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'            '
name|'task_info'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
nl|'\n'
string|'"get_dynamic_property"'
op|','
nl|'\n'
name|'search_task'
op|','
string|'"Task"'
op|','
string|'"info"'
op|')'
newline|'\n'
name|'if'
name|'task_info'
op|'.'
name|'state'
name|'in'
op|'['
string|"'queued'"
op|','
string|"'running'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'time'
op|'.'
name|'sleep'
op|'('
number|'2'
op|')'
newline|'\n'
name|'continue'
newline|'\n'
dedent|''
name|'break'
newline|'\n'
dedent|''
name|'if'
name|'task_info'
op|'.'
name|'state'
op|'=='
string|'"error"'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'False'
op|','
name|'False'
newline|'\n'
nl|'\n'
dedent|''
name|'file_exists'
op|'='
op|'('
name|'getattr'
op|'('
name|'task_info'
op|'.'
name|'result'
op|','
string|"'file'"
op|','
name|'False'
op|')'
name|'and'
nl|'\n'
name|'task_info'
op|'.'
name|'result'
op|'.'
name|'file'
op|'['
number|'0'
op|']'
op|'.'
name|'path'
op|'=='
name|'file_name'
op|')'
newline|'\n'
name|'return'
name|'True'
op|','
name|'file_exists'
newline|'\n'
nl|'\n'
DECL|member|_mkdir
dedent|''
name|'def'
name|'_mkdir'
op|'('
name|'self'
op|','
name|'ds_path'
op|','
name|'ds_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""\n        Creates a directory at the path specified. If it is just "NAME",\n        then a directory with this name is created at the topmost level of the\n        DataStore.\n        """'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Creating directory with path %s"'
op|')'
op|'%'
name|'ds_path'
op|')'
newline|'\n'
name|'dc_info'
op|'='
name|'self'
op|'.'
name|'get_datacenter_ref_and_name'
op|'('
name|'ds_ref'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|','
string|'"MakeDirectory"'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|'.'
name|'get_service_content'
op|'('
op|')'
op|'.'
name|'fileManager'
op|','
nl|'\n'
name|'name'
op|'='
name|'ds_path'
op|','
name|'datacenter'
op|'='
name|'dc_info'
op|'.'
name|'ref'
op|','
nl|'\n'
name|'createParentDirectories'
op|'='
name|'True'
op|')'
newline|'\n'
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Created directory with path %s"'
op|')'
op|'%'
name|'ds_path'
op|')'
newline|'\n'
nl|'\n'
DECL|member|_check_if_folder_file_exists
dedent|''
name|'def'
name|'_check_if_folder_file_exists'
op|'('
name|'self'
op|','
name|'ds_ref'
op|','
name|'ds_name'
op|','
nl|'\n'
name|'folder_name'
op|','
name|'file_name'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'ds_browser'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
nl|'\n'
name|'vim_util'
op|','
string|'"get_dynamic_property"'
op|','
name|'ds_ref'
op|','
string|'"Datastore"'
op|','
string|'"browser"'
op|')'
newline|'\n'
comment|'# Check if the folder exists or not. If not, create one'
nl|'\n'
comment|'# Check if the file exists or not.'
nl|'\n'
name|'folder_path'
op|'='
name|'vm_util'
op|'.'
name|'build_datastore_path'
op|'('
name|'ds_name'
op|','
name|'folder_name'
op|')'
newline|'\n'
name|'folder_exists'
op|','
name|'file_exists'
op|'='
name|'self'
op|'.'
name|'_path_file_exists'
op|'('
name|'ds_browser'
op|','
nl|'\n'
name|'folder_path'
op|','
nl|'\n'
name|'file_name'
op|')'
newline|'\n'
comment|'# Ensure that the cache folder exists'
nl|'\n'
name|'if'
name|'not'
name|'folder_exists'
op|':'
newline|'\n'
indent|'            '
name|'self'
op|'.'
name|'_mkdir'
op|'('
name|'vm_util'
op|'.'
name|'build_datastore_path'
op|'('
name|'ds_name'
op|','
nl|'\n'
name|'self'
op|'.'
name|'_base_folder'
op|')'
op|','
nl|'\n'
name|'ds_ref'
op|')'
newline|'\n'
nl|'\n'
dedent|''
name|'return'
name|'file_exists'
newline|'\n'
nl|'\n'
DECL|member|inject_network_info
dedent|''
name|'def'
name|'inject_network_info'
op|'('
name|'self'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""inject network info for specified instance."""'
newline|'\n'
comment|'# Set the machine.id parameter of the instance to inject'
nl|'\n'
comment|'# the NIC configuration inside the VM'
nl|'\n'
name|'client_factory'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_get_vim'
op|'('
op|')'
op|'.'
name|'client'
op|'.'
name|'factory'
newline|'\n'
name|'self'
op|'.'
name|'_set_machine_id'
op|'('
name|'client_factory'
op|','
name|'instance'
op|','
name|'network_info'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|VMwareVCVMOps
dedent|''
dedent|''
name|'class'
name|'VMwareVCVMOps'
op|'('
name|'VMwareVMOps'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Management class for VM-related tasks.\n\n    Contains specializations to account for differences in vSphere API behavior\n    when invoked on Virtual Center instead of ESX host.\n    """'
newline|'\n'
nl|'\n'
DECL|member|get_copy_virtual_disk_spec
name|'def'
name|'get_copy_virtual_disk_spec'
op|'('
name|'self'
op|','
name|'client_factory'
op|','
name|'adapter_type'
op|','
nl|'\n'
name|'disk_type'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'LOG'
op|'.'
name|'debug'
op|'('
name|'_'
op|'('
string|'"Will copy while retaining adapter type "'
nl|'\n'
string|'"%(adapter_type)s and disk type %(disk_type)s"'
op|')'
op|'%'
nl|'\n'
op|'{'
string|'"disk_type"'
op|':'
name|'disk_type'
op|','
nl|'\n'
string|'"adapter_type"'
op|':'
name|'adapter_type'
op|'}'
op|')'
newline|'\n'
comment|'# Passing of the destination copy spec is not supported when'
nl|'\n'
comment|'# VirtualDiskManager.CopyVirtualDisk is called on VC. The behavior of a'
nl|'\n'
comment|'# spec-less copy is to consolidate to the target disk while keeping its'
nl|'\n'
comment|'# disk and adapter type unchanged.'
nl|'\n'
nl|'\n'
DECL|member|_update_datacenter_cache_from_objects
dedent|''
name|'def'
name|'_update_datacenter_cache_from_objects'
op|'('
name|'self'
op|','
name|'dcs'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Updates the datastore/datacenter cache."""'
newline|'\n'
nl|'\n'
name|'while'
name|'dcs'
op|':'
newline|'\n'
indent|'            '
name|'token'
op|'='
name|'vm_util'
op|'.'
name|'_get_token'
op|'('
name|'dcs'
op|')'
newline|'\n'
name|'for'
name|'dco'
name|'in'
name|'dcs'
op|'.'
name|'objects'
op|':'
newline|'\n'
indent|'                '
name|'name'
op|'='
name|'None'
newline|'\n'
name|'vmFolder'
op|'='
name|'None'
newline|'\n'
name|'dc_ref'
op|'='
name|'dco'
op|'.'
name|'obj'
newline|'\n'
name|'ds_refs'
op|'='
op|'['
op|']'
newline|'\n'
name|'for'
name|'p'
name|'in'
name|'dco'
op|'.'
name|'propSet'
op|':'
newline|'\n'
indent|'                    '
name|'if'
name|'p'
op|'.'
name|'name'
op|'=='
string|"'name'"
op|':'
newline|'\n'
indent|'                        '
name|'name'
op|'='
name|'p'
op|'.'
name|'val'
newline|'\n'
dedent|''
name|'if'
name|'p'
op|'.'
name|'name'
op|'=='
string|"'datastore'"
op|':'
newline|'\n'
indent|'                        '
name|'datastore_refs'
op|'='
name|'p'
op|'.'
name|'val'
op|'.'
name|'ManagedObjectReference'
newline|'\n'
name|'for'
name|'ds'
name|'in'
name|'datastore_refs'
op|':'
newline|'\n'
indent|'                            '
name|'ds_refs'
op|'.'
name|'append'
op|'('
name|'ds'
op|'.'
name|'value'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'p'
op|'.'
name|'name'
op|'=='
string|"'vmFolder'"
op|':'
newline|'\n'
indent|'                        '
name|'vmFolder'
op|'='
name|'p'
op|'.'
name|'val'
newline|'\n'
dedent|''
dedent|''
name|'for'
name|'ds_ref'
name|'in'
name|'ds_refs'
op|':'
newline|'\n'
indent|'                    '
name|'self'
op|'.'
name|'_datastore_dc_mapping'
op|'['
name|'ds_ref'
op|']'
op|'='
name|'DcInfo'
op|'('
name|'ref'
op|'='
name|'dc_ref'
op|','
nl|'\n'
name|'name'
op|'='
name|'name'
op|','
name|'vmFolder'
op|'='
name|'vmFolder'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'token'
op|':'
newline|'\n'
indent|'                '
name|'dcs'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
nl|'\n'
string|'"continue_to_get_objects"'
op|','
nl|'\n'
name|'token'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                '
name|'break'
newline|'\n'
nl|'\n'
DECL|member|get_datacenter_ref_and_name
dedent|''
dedent|''
dedent|''
name|'def'
name|'get_datacenter_ref_and_name'
op|'('
name|'self'
op|','
name|'ds_ref'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Get the datacenter name and the reference."""'
newline|'\n'
name|'dc_info'
op|'='
name|'self'
op|'.'
name|'_datastore_dc_mapping'
op|'.'
name|'get'
op|'('
name|'ds_ref'
op|'.'
name|'value'
op|')'
newline|'\n'
name|'if'
name|'not'
name|'dc_info'
op|':'
newline|'\n'
indent|'            '
name|'dcs'
op|'='
name|'self'
op|'.'
name|'_session'
op|'.'
name|'_call_method'
op|'('
name|'vim_util'
op|','
string|'"get_objects"'
op|','
nl|'\n'
string|'"Datacenter"'
op|','
op|'['
string|'"name"'
op|','
string|'"datastore"'
op|','
string|'"vmFolder"'
op|']'
op|')'
newline|'\n'
name|'self'
op|'.'
name|'_update_datacenter_cache_from_objects'
op|'('
name|'dcs'
op|')'
newline|'\n'
name|'dc_info'
op|'='
name|'self'
op|'.'
name|'_datastore_dc_mapping'
op|'.'
name|'get'
op|'('
name|'ds_ref'
op|'.'
name|'value'
op|')'
newline|'\n'
dedent|''
name|'return'
name|'dc_info'
newline|'\n'
dedent|''
dedent|''
endmarker|''
end_unit
