begin_unit
comment|'#!/usr/bin/env python'
nl|'\n'
comment|'# vim: tabstop=4 shiftwidth=4 softtabstop=4'
nl|'\n'
nl|'\n'
comment|'# Copyright (c) 2012, Cloudscaling'
nl|'\n'
comment|'# All Rights Reserved.'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Licensed under the Apache License, Version 2.0 (the "License"); you may'
nl|'\n'
comment|'#    not use this file except in compliance with the License. You may obtain'
nl|'\n'
comment|'#    a copy of the License at'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#         http://www.apache.org/licenses/LICENSE-2.0'
nl|'\n'
comment|'#'
nl|'\n'
comment|'#    Unless required by applicable law or agreed to in writing, software'
nl|'\n'
comment|'#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT'
nl|'\n'
comment|'#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the'
nl|'\n'
comment|'#    License for the specific language governing permissions and limitations'
nl|'\n'
comment|'#    under the License.'
nl|'\n'
nl|'\n'
string|'"""nova HACKING file compliance testing\n\nBuilt on top of pep8.py\n"""'
newline|'\n'
nl|'\n'
name|'import'
name|'gettext'
newline|'\n'
name|'import'
name|'imp'
newline|'\n'
name|'import'
name|'inspect'
newline|'\n'
name|'import'
name|'logging'
newline|'\n'
name|'import'
name|'os'
newline|'\n'
name|'import'
name|'re'
newline|'\n'
name|'import'
name|'subprocess'
newline|'\n'
name|'import'
name|'sys'
newline|'\n'
name|'import'
name|'tokenize'
newline|'\n'
name|'import'
name|'traceback'
newline|'\n'
nl|'\n'
name|'import'
name|'pep8'
newline|'\n'
nl|'\n'
comment|"# Don't need this for testing"
nl|'\n'
name|'logging'
op|'.'
name|'disable'
op|'('
string|"'LOG'"
op|')'
newline|'\n'
nl|'\n'
comment|'#N1xx comments'
nl|'\n'
comment|'#N2xx except'
nl|'\n'
comment|'#N3xx imports'
nl|'\n'
comment|'#N4xx docstrings'
nl|'\n'
comment|'#N5xx dictionaries/lists'
nl|'\n'
comment|'#N6xx calling methods'
nl|'\n'
comment|'#N7xx localization'
nl|'\n'
comment|'#N8xx git commit messages'
nl|'\n'
comment|'#N9xx other'
nl|'\n'
nl|'\n'
DECL|variable|IMPORT_EXCEPTIONS
name|'IMPORT_EXCEPTIONS'
op|'='
op|'['
string|"'sqlalchemy'"
op|','
string|"'migrate'"
op|','
string|"'nova.db.sqlalchemy.session'"
op|','
nl|'\n'
string|"'nova.db.sqlalchemy.migration.versioning_api'"
op|']'
newline|'\n'
comment|'# Paste is missing a __init__ in top level directory'
nl|'\n'
DECL|variable|START_DOCSTRING_TRIPLE
name|'START_DOCSTRING_TRIPLE'
op|'='
op|'['
string|'\'u"""\''
op|','
string|'\'r"""\''
op|','
string|'\'"""\''
op|','
string|'"u\'\'\'"'
op|','
string|'"r\'\'\'"'
op|','
string|'"\'\'\'"'
op|']'
newline|'\n'
DECL|variable|END_DOCSTRING_TRIPLE
name|'END_DOCSTRING_TRIPLE'
op|'='
op|'['
string|'\'"""\''
op|','
string|'"\'\'\'"'
op|']'
newline|'\n'
DECL|variable|VERBOSE_MISSING_IMPORT
name|'VERBOSE_MISSING_IMPORT'
op|'='
name|'os'
op|'.'
name|'getenv'
op|'('
string|"'HACKING_VERBOSE_MISSING_IMPORT'"
op|','
string|"'False'"
op|')'
newline|'\n'
nl|'\n'
DECL|variable|_missingImport
name|'_missingImport'
op|'='
name|'set'
op|'('
op|'['
op|']'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'# Monkey patch broken excluded filter in pep8'
nl|'\n'
comment|'# See https://github.com/jcrocholl/pep8/pull/111'
nl|'\n'
DECL|function|excluded
name|'def'
name|'excluded'
op|'('
name|'self'
op|','
name|'filename'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Check if options.exclude contains a pattern that matches filename."""'
newline|'\n'
name|'basename'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'filename'
op|')'
newline|'\n'
name|'return'
name|'any'
op|'('
op|'('
name|'pep8'
op|'.'
name|'filename_match'
op|'('
name|'filename'
op|','
name|'self'
op|'.'
name|'options'
op|'.'
name|'exclude'
op|','
nl|'\n'
name|'default'
op|'='
name|'False'
op|')'
op|','
nl|'\n'
name|'pep8'
op|'.'
name|'filename_match'
op|'('
name|'basename'
op|','
name|'self'
op|'.'
name|'options'
op|'.'
name|'exclude'
op|','
nl|'\n'
name|'default'
op|'='
name|'False'
op|')'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|input_dir
dedent|''
name|'def'
name|'input_dir'
op|'('
name|'self'
op|','
name|'dirname'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Check all files in this directory and all subdirectories."""'
newline|'\n'
name|'dirname'
op|'='
name|'dirname'
op|'.'
name|'rstrip'
op|'('
string|"'/'"
op|')'
newline|'\n'
name|'if'
name|'self'
op|'.'
name|'excluded'
op|'('
name|'dirname'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
number|'0'
newline|'\n'
dedent|''
name|'counters'
op|'='
name|'self'
op|'.'
name|'options'
op|'.'
name|'report'
op|'.'
name|'counters'
newline|'\n'
name|'verbose'
op|'='
name|'self'
op|'.'
name|'options'
op|'.'
name|'verbose'
newline|'\n'
name|'filepatterns'
op|'='
name|'self'
op|'.'
name|'options'
op|'.'
name|'filename'
newline|'\n'
name|'runner'
op|'='
name|'self'
op|'.'
name|'runner'
newline|'\n'
name|'for'
name|'root'
op|','
name|'dirs'
op|','
name|'files'
name|'in'
name|'os'
op|'.'
name|'walk'
op|'('
name|'dirname'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'verbose'
op|':'
newline|'\n'
indent|'            '
name|'print'
op|'('
string|"'directory '"
op|'+'
name|'root'
op|')'
newline|'\n'
dedent|''
name|'counters'
op|'['
string|"'directories'"
op|']'
op|'+='
number|'1'
newline|'\n'
name|'for'
name|'subdir'
name|'in'
name|'sorted'
op|'('
name|'dirs'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'self'
op|'.'
name|'excluded'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'root'
op|','
name|'subdir'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'dirs'
op|'.'
name|'remove'
op|'('
name|'subdir'
op|')'
newline|'\n'
dedent|''
dedent|''
name|'for'
name|'filename'
name|'in'
name|'sorted'
op|'('
name|'files'
op|')'
op|':'
newline|'\n'
comment|'# contain a pattern that matches?'
nl|'\n'
indent|'            '
name|'if'
op|'('
op|'('
name|'pep8'
op|'.'
name|'filename_match'
op|'('
name|'filename'
op|','
name|'filepatterns'
op|')'
name|'and'
nl|'\n'
name|'not'
name|'self'
op|'.'
name|'excluded'
op|'('
name|'filename'
op|')'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'runner'
op|'('
name|'os'
op|'.'
name|'path'
op|'.'
name|'join'
op|'('
name|'root'
op|','
name|'filename'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|is_import_exception
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'is_import_exception'
op|'('
name|'mod'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'return'
op|'('
name|'mod'
name|'in'
name|'IMPORT_EXCEPTIONS'
name|'or'
nl|'\n'
name|'any'
op|'('
name|'mod'
op|'.'
name|'startswith'
op|'('
name|'m'
op|'+'
string|"'.'"
op|')'
name|'for'
name|'m'
name|'in'
name|'IMPORT_EXCEPTIONS'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|import_normalize
dedent|''
name|'def'
name|'import_normalize'
op|'('
name|'line'
op|')'
op|':'
newline|'\n'
comment|'# convert "from x import y" to "import x.y"'
nl|'\n'
comment|'# handle "from x import y as z" to "import x.y as z"'
nl|'\n'
indent|'    '
name|'split_line'
op|'='
name|'line'
op|'.'
name|'split'
op|'('
op|')'
newline|'\n'
name|'if'
op|'('
string|'"import"'
name|'in'
name|'line'
name|'and'
name|'line'
op|'.'
name|'startswith'
op|'('
string|'"from "'
op|')'
name|'and'
string|'","'
name|'not'
name|'in'
name|'line'
name|'and'
nl|'\n'
name|'split_line'
op|'['
number|'2'
op|']'
op|'=='
string|'"import"'
name|'and'
name|'split_line'
op|'['
number|'3'
op|']'
op|'!='
string|'"*"'
name|'and'
nl|'\n'
name|'split_line'
op|'['
number|'1'
op|']'
op|'!='
string|'"__future__"'
name|'and'
nl|'\n'
op|'('
name|'len'
op|'('
name|'split_line'
op|')'
op|'=='
number|'4'
name|'or'
nl|'\n'
op|'('
name|'len'
op|'('
name|'split_line'
op|')'
op|'=='
number|'6'
name|'and'
name|'split_line'
op|'['
number|'4'
op|']'
op|'=='
string|'"as"'
op|')'
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
string|'"import %s.%s"'
op|'%'
op|'('
name|'split_line'
op|'['
number|'1'
op|']'
op|','
name|'split_line'
op|'['
number|'3'
op|']'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'line'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|nova_todo_format
dedent|''
dedent|''
name|'def'
name|'nova_todo_format'
op|'('
name|'physical_line'
op|','
name|'tokens'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Check for \'TODO()\'.\n\n    nova HACKING guide recommendation for TODO:\n    Include your name with TODOs as in "#TODO(termie)"\n\n    Okay: #TODO(sdague)\n    N101: #TODO fail\n    N101: #TODO (jogo) fail\n    """'
newline|'\n'
comment|"# TODO(sdague): TODO check shouldn't fail inside of space"
nl|'\n'
name|'pos'
op|'='
name|'physical_line'
op|'.'
name|'find'
op|'('
string|"'TODO'"
op|')'
newline|'\n'
name|'pos1'
op|'='
name|'physical_line'
op|'.'
name|'find'
op|'('
string|"'TODO('"
op|')'
newline|'\n'
name|'pos2'
op|'='
name|'physical_line'
op|'.'
name|'find'
op|'('
string|"'#'"
op|')'
comment|"# make sure it's a comment"
newline|'\n'
name|'if'
op|'('
name|'pos'
op|'!='
name|'pos1'
name|'and'
name|'pos2'
op|'>='
number|'0'
name|'and'
name|'pos2'
op|'<'
name|'pos'
name|'and'
name|'len'
op|'('
name|'tokens'
op|')'
op|'=='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
name|'pos'
op|','
string|'"N101: Use TODO(NAME)"'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|nova_except_format
dedent|''
dedent|''
name|'def'
name|'nova_except_format'
op|'('
name|'logical_line'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'r"""Check for \'except:\'.\n\n    nova HACKING guide recommends not using except:\n    Do not write "except:", use "except Exception:" at the very least\n\n    Okay: except Exception:\n    N201: except:\n    """'
newline|'\n'
name|'if'
name|'logical_line'
op|'.'
name|'startswith'
op|'('
string|'"except:"'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'yield'
number|'6'
op|','
string|'"N201: no \'except:\' at least use \'except Exception:\'"'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|nova_except_format_assert
dedent|''
dedent|''
name|'def'
name|'nova_except_format_assert'
op|'('
name|'logical_line'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'r"""Check for \'assertRaises(Exception\'.\n\n    nova HACKING guide recommends not using assertRaises(Exception...):\n    Do not use overly broad Exception type\n\n    Okay: self.assertRaises(NovaException)\n    N202: self.assertRaises(Exception)\n    """'
newline|'\n'
name|'if'
name|'logical_line'
op|'.'
name|'startswith'
op|'('
string|'"self.assertRaises(Exception"'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'yield'
number|'1'
op|','
string|'"N202: assertRaises Exception too broad"'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|modules_cache
dedent|''
dedent|''
name|'modules_cache'
op|'='
name|'dict'
op|'('
op|'('
name|'mod'
op|','
name|'True'
op|')'
name|'for'
name|'mod'
name|'in'
name|'tuple'
op|'('
name|'sys'
op|'.'
name|'modules'
op|'.'
name|'keys'
op|'('
op|')'
op|')'
nl|'\n'
op|'+'
name|'sys'
op|'.'
name|'builtin_module_names'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|RE_RELATIVE_IMPORT
name|'RE_RELATIVE_IMPORT'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"'^from\\s*[.]'"
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|nova_import_rules
name|'def'
name|'nova_import_rules'
op|'('
name|'logical_line'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'r"""Check for imports.\n\n    nova HACKING guide recommends one import per line:\n    Do not import more than one module per line\n\n    Examples:\n    Okay: from nova.compute import api\n    N301: from nova.compute import api, utils\n\n\n    Imports should usually be on separate lines.\n\n    nova HACKING guide recommends importing only modules:\n    Do not import objects, only modules\n\n    Examples:\n    Okay: from os import path\n    Okay: from os import path as p\n    Okay: from os import (path as p)\n    Okay: import os.path\n    Okay: from nova.compute import rpcapi\n    N302: from os.path import dirname as dirname2\n    N302: from os.path import (dirname as dirname2)\n    N303: from os.path import *\n    N304: from .compute import rpcapi\n    """'
newline|'\n'
comment|'#NOTE(afazekas): An old style relative import example will not be able to'
nl|'\n'
comment|"# pass the doctest, since the relativity depends on the file's locality"
nl|'\n'
nl|'\n'
DECL|function|is_module_for_sure
name|'def'
name|'is_module_for_sure'
op|'('
name|'mod'
op|','
name|'search_path'
op|'='
name|'sys'
op|'.'
name|'path'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'mod'
op|'='
name|'mod'
op|'.'
name|'replace'
op|'('
string|"'('"
op|','
string|"''"
op|')'
comment|'# Ignore parentheses'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'mod_name'
op|'='
name|'mod'
newline|'\n'
name|'while'
string|"'.'"
name|'in'
name|'mod_name'
op|':'
newline|'\n'
indent|'                '
name|'pack_name'
op|','
name|'_sep'
op|','
name|'mod_name'
op|'='
name|'mod'
op|'.'
name|'partition'
op|'('
string|"'.'"
op|')'
newline|'\n'
name|'f'
op|','
name|'p'
op|','
name|'d'
op|'='
name|'imp'
op|'.'
name|'find_module'
op|'('
name|'pack_name'
op|','
name|'search_path'
op|')'
newline|'\n'
name|'search_path'
op|'='
op|'['
name|'p'
op|']'
newline|'\n'
dedent|''
name|'imp'
op|'.'
name|'find_module'
op|'('
name|'mod_name'
op|','
name|'search_path'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|':'
newline|'\n'
indent|'            '
name|'try'
op|':'
newline|'\n'
comment|'# NOTE(vish): handle namespace modules'
nl|'\n'
indent|'                '
name|'module'
op|'='
name|'__import__'
op|'('
name|'mod'
op|')'
newline|'\n'
dedent|''
name|'except'
name|'ImportError'
op|','
name|'exc'
op|':'
newline|'\n'
comment|'# NOTE(vish): the import error might be due'
nl|'\n'
comment|'#             to a missing dependency'
nl|'\n'
indent|'                '
name|'missing'
op|'='
name|'str'
op|'('
name|'exc'
op|')'
op|'.'
name|'split'
op|'('
op|')'
op|'['
op|'-'
number|'1'
op|']'
newline|'\n'
name|'if'
op|'('
name|'missing'
op|'!='
name|'mod'
op|'.'
name|'split'
op|'('
string|"'.'"
op|')'
op|'['
op|'-'
number|'1'
op|']'
name|'or'
nl|'\n'
string|'"cannot import"'
name|'in'
name|'str'
op|'('
name|'exc'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'_missingImport'
op|'.'
name|'add'
op|'('
name|'missing'
op|')'
newline|'\n'
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'return'
name|'False'
newline|'\n'
dedent|''
name|'except'
name|'Exception'
op|','
name|'exc'
op|':'
newline|'\n'
comment|"# NOTE(jogo) don't stack trace if unexpected import error,"
nl|'\n'
comment|'# log and continue.'
nl|'\n'
indent|'                '
name|'traceback'
op|'.'
name|'print_exc'
op|'('
op|')'
newline|'\n'
name|'return'
name|'False'
newline|'\n'
dedent|''
dedent|''
name|'return'
name|'True'
newline|'\n'
nl|'\n'
DECL|function|is_module
dedent|''
name|'def'
name|'is_module'
op|'('
name|'mod'
op|')'
op|':'
newline|'\n'
indent|'        '
string|'"""Checks for non module imports."""'
newline|'\n'
name|'if'
name|'mod'
name|'in'
name|'modules_cache'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'modules_cache'
op|'['
name|'mod'
op|']'
newline|'\n'
dedent|''
name|'res'
op|'='
name|'is_module_for_sure'
op|'('
name|'mod'
op|')'
newline|'\n'
name|'modules_cache'
op|'['
name|'mod'
op|']'
op|'='
name|'res'
newline|'\n'
name|'return'
name|'res'
newline|'\n'
nl|'\n'
dedent|''
name|'current_path'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'dirname'
op|'('
name|'pep8'
op|'.'
name|'current_file'
op|')'
newline|'\n'
name|'current_mod'
op|'='
name|'os'
op|'.'
name|'path'
op|'.'
name|'basename'
op|'('
name|'pep8'
op|'.'
name|'current_file'
op|')'
newline|'\n'
name|'if'
name|'current_mod'
op|'['
op|'-'
number|'3'
op|':'
op|']'
op|'=='
string|'".py"'
op|':'
newline|'\n'
indent|'        '
name|'current_mod'
op|'='
name|'current_mod'
op|'['
op|':'
op|'-'
number|'3'
op|']'
newline|'\n'
nl|'\n'
dedent|''
name|'split_line'
op|'='
name|'logical_line'
op|'.'
name|'split'
op|'('
op|')'
newline|'\n'
name|'split_line_len'
op|'='
name|'len'
op|'('
name|'split_line'
op|')'
newline|'\n'
name|'if'
op|'('
name|'split_line'
op|'['
number|'0'
op|']'
name|'in'
op|'('
string|"'import'"
op|','
string|"'from'"
op|')'
name|'and'
name|'split_line_len'
op|'>'
number|'1'
name|'and'
nl|'\n'
name|'not'
name|'is_import_exception'
op|'('
name|'split_line'
op|'['
number|'1'
op|']'
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pos'
op|'='
name|'logical_line'
op|'.'
name|'find'
op|'('
string|"','"
op|')'
newline|'\n'
name|'if'
name|'pos'
op|'!='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'split_line'
op|'['
number|'0'
op|']'
op|'=='
string|"'from'"
op|':'
newline|'\n'
indent|'                '
name|'yield'
name|'pos'
op|','
string|'"N301: one import per line"'
newline|'\n'
dedent|''
name|'return'
comment|"# ',' is not supported by the N302 checker yet"
newline|'\n'
dedent|''
name|'pos'
op|'='
name|'logical_line'
op|'.'
name|'find'
op|'('
string|"'*'"
op|')'
newline|'\n'
name|'if'
name|'pos'
op|'!='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'            '
name|'yield'
name|'pos'
op|','
string|'"N303: No wildcard (*) import."'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'split_line_len'
name|'in'
op|'('
number|'2'
op|','
number|'4'
op|','
number|'6'
op|')'
name|'and'
name|'split_line'
op|'['
number|'1'
op|']'
op|'!='
string|'"__future__"'
op|':'
newline|'\n'
indent|'            '
name|'if'
string|"'from'"
op|'=='
name|'split_line'
op|'['
number|'0'
op|']'
name|'and'
name|'split_line_len'
op|'>'
number|'3'
op|':'
newline|'\n'
indent|'                '
name|'mod'
op|'='
string|"'.'"
op|'.'
name|'join'
op|'('
op|'('
name|'split_line'
op|'['
number|'1'
op|']'
op|','
name|'split_line'
op|'['
number|'3'
op|']'
op|')'
op|')'
newline|'\n'
name|'if'
name|'is_import_exception'
op|'('
name|'mod'
op|')'
op|':'
newline|'\n'
indent|'                        '
name|'return'
newline|'\n'
dedent|''
name|'if'
name|'RE_RELATIVE_IMPORT'
op|'.'
name|'search'
op|'('
name|'logical_line'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'yield'
name|'logical_line'
op|'.'
name|'find'
op|'('
string|"'.'"
op|')'
op|','
op|'('
string|'"N304: No "'
nl|'\n'
string|'"relative imports. \'%s\' is a relative import"'
nl|'\n'
op|'%'
name|'logical_line'
op|')'
newline|'\n'
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
name|'not'
name|'is_module'
op|'('
name|'mod'
op|')'
op|':'
newline|'\n'
indent|'                    '
name|'yield'
number|'0'
op|','
op|'('
string|'"N302: import only modules."'
nl|'\n'
string|'"\'%s\' does not import a module"'
op|'%'
name|'logical_line'
op|')'
newline|'\n'
dedent|''
name|'return'
newline|'\n'
nl|'\n'
comment|'#NOTE(afazekas): import searches first in the package'
nl|'\n'
comment|'# The import keyword just imports modules'
nl|'\n'
comment|'# The guestfs module now imports guestfs'
nl|'\n'
dedent|''
dedent|''
name|'mod'
op|'='
name|'split_line'
op|'['
number|'1'
op|']'
newline|'\n'
name|'if'
op|'('
name|'current_mod'
op|'!='
name|'mod'
name|'and'
nl|'\n'
name|'not'
name|'is_module'
op|'('
name|'mod'
op|')'
name|'and'
nl|'\n'
name|'is_module_for_sure'
op|'('
name|'mod'
op|','
op|'['
name|'current_path'
op|']'
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'yield'
number|'0'
op|','
op|'('
string|'"N304: No relative imports."'
nl|'\n'
string|'" \'%s\' is a relative import"'
nl|'\n'
op|'%'
name|'logical_line'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
comment|'#TODO(jogo): import template: N305'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|nova_import_alphabetical
dedent|''
dedent|''
dedent|''
name|'def'
name|'nova_import_alphabetical'
op|'('
name|'logical_line'
op|','
name|'blank_lines'
op|','
name|'previous_logical'
op|','
nl|'\n'
name|'indent_level'
op|','
name|'previous_indent_level'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'r"""Check for imports in alphabetical order.\n\n    nova HACKING guide recommendation for imports:\n    imports in human alphabetical order\n\n    Okay: import os\\nimport sys\\n\\nimport nova\\nfrom nova import test\n    N306: import sys\\nimport os\n    """'
newline|'\n'
comment|'# handle import x'
nl|'\n'
comment|"# use .lower since capitalization shouldn't dictate order"
nl|'\n'
name|'split_line'
op|'='
name|'import_normalize'
op|'('
name|'logical_line'
op|'.'
name|'strip'
op|'('
op|')'
op|')'
op|'.'
name|'lower'
op|'('
op|')'
op|'.'
name|'split'
op|'('
op|')'
newline|'\n'
name|'split_previous'
op|'='
name|'import_normalize'
op|'('
name|'previous_logical'
op|'.'
name|'strip'
op|'('
op|')'
op|')'
op|'.'
name|'lower'
op|'('
op|')'
op|'.'
name|'split'
op|'('
op|')'
newline|'\n'
nl|'\n'
name|'if'
name|'blank_lines'
op|'<'
number|'1'
name|'and'
name|'indent_level'
op|'=='
name|'previous_indent_level'
op|':'
newline|'\n'
indent|'        '
name|'length'
op|'='
op|'['
number|'2'
op|','
number|'4'
op|']'
newline|'\n'
name|'if'
op|'('
name|'len'
op|'('
name|'split_line'
op|')'
name|'in'
name|'length'
name|'and'
name|'len'
op|'('
name|'split_previous'
op|')'
name|'in'
name|'length'
name|'and'
nl|'\n'
name|'split_line'
op|'['
number|'0'
op|']'
op|'=='
string|'"import"'
name|'and'
name|'split_previous'
op|'['
number|'0'
op|']'
op|'=='
string|'"import"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'split_line'
op|'['
number|'1'
op|']'
op|'<'
name|'split_previous'
op|'['
number|'1'
op|']'
op|':'
newline|'\n'
indent|'                '
name|'yield'
op|'('
number|'0'
op|','
string|'"N306: imports not in alphabetical order (%s, %s)"'
nl|'\n'
op|'%'
op|'('
name|'split_previous'
op|'['
number|'1'
op|']'
op|','
name|'split_line'
op|'['
number|'1'
op|']'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|nova_import_no_db_in_virt
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'nova_import_no_db_in_virt'
op|'('
name|'logical_line'
op|','
name|'filename'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Check for db calls from nova/virt\n\n    As of grizzly-2 all the database calls have been removed from\n    nova/virt, and we want to keep it that way.\n\n    N307\n    """'
newline|'\n'
name|'if'
string|'"nova/virt"'
name|'in'
name|'filename'
name|'and'
name|'not'
name|'filename'
op|'.'
name|'endswith'
op|'('
string|'"fake.py"'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'logical_line'
op|'.'
name|'startswith'
op|'('
string|'"from nova import db"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'yield'
op|'('
number|'0'
op|','
string|'"N307: nova.db import not allowed in nova/virt/*"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|is_docstring
dedent|''
dedent|''
dedent|''
name|'def'
name|'is_docstring'
op|'('
name|'physical_line'
op|','
name|'previous_logical'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Return True if found docstring\n    \'A docstring is a string literal that occurs as the first statement in a\n    module, function, class,\'\n    http://www.python.org/dev/peps/pep-0257/#what-is-a-docstring\n    """'
newline|'\n'
name|'line'
op|'='
name|'physical_line'
op|'.'
name|'lstrip'
op|'('
op|')'
newline|'\n'
name|'start'
op|'='
name|'max'
op|'('
op|'['
name|'line'
op|'.'
name|'find'
op|'('
name|'i'
op|')'
name|'for'
name|'i'
name|'in'
name|'START_DOCSTRING_TRIPLE'
op|']'
op|')'
newline|'\n'
name|'end'
op|'='
name|'max'
op|'('
op|'['
name|'line'
op|'['
op|'-'
number|'4'
op|':'
op|'-'
number|'1'
op|']'
op|'=='
name|'i'
name|'for'
name|'i'
name|'in'
name|'END_DOCSTRING_TRIPLE'
op|']'
op|')'
newline|'\n'
name|'if'
op|'('
name|'previous_logical'
op|'.'
name|'startswith'
op|'('
string|'"def "'
op|')'
name|'or'
nl|'\n'
name|'previous_logical'
op|'.'
name|'startswith'
op|'('
string|'"class "'
op|')'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'start'
name|'is'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'return'
name|'True'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
comment|'# Handle multi line comments'
nl|'\n'
indent|'            '
name|'return'
name|'end'
name|'and'
name|'start'
name|'in'
op|'('
op|'-'
number|'1'
op|','
name|'len'
op|'('
name|'line'
op|')'
op|'-'
number|'4'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|nova_docstring_start_space
dedent|''
dedent|''
dedent|''
name|'def'
name|'nova_docstring_start_space'
op|'('
name|'physical_line'
op|','
name|'previous_logical'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'r"""Check for docstring not start with space.\n\n    nova HACKING guide recommendation for docstring:\n    Docstring should not start with space\n\n    Okay: def foo():\\n    \'\'\'This is good.\'\'\'\n    Okay: def foo():\\n    a = \'\'\' This is not a docstring.\'\'\'\n    Okay: def foo():\\n    pass\\n    \'\'\' This is not.\'\'\'\n    N401: def foo():\\n    \'\'\' This is not.\'\'\'\n    """'
newline|'\n'
comment|"# short circuit so that we don't fail on our own fail test"
nl|'\n'
comment|'# when running under external pep8'
nl|'\n'
name|'if'
name|'physical_line'
op|'.'
name|'find'
op|'('
string|'"N401: def foo()"'
op|')'
op|'!='
op|'-'
number|'1'
op|':'
newline|'\n'
indent|'        '
name|'return'
newline|'\n'
nl|'\n'
comment|"# it's important that we determine this is actually a docstring,"
nl|'\n'
comment|'# and not a doc block used somewhere after the first line of a'
nl|'\n'
comment|'# function def'
nl|'\n'
dedent|''
name|'if'
name|'is_docstring'
op|'('
name|'physical_line'
op|','
name|'previous_logical'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pos'
op|'='
name|'max'
op|'('
op|'['
name|'physical_line'
op|'.'
name|'find'
op|'('
name|'i'
op|')'
name|'for'
name|'i'
name|'in'
name|'START_DOCSTRING_TRIPLE'
op|']'
op|')'
newline|'\n'
name|'if'
name|'physical_line'
op|'['
name|'pos'
op|'+'
number|'3'
op|']'
op|'=='
string|"' '"
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'('
name|'pos'
op|','
string|'"N401: docstring should not start with"'
nl|'\n'
string|'" a space"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|nova_docstring_one_line
dedent|''
dedent|''
dedent|''
name|'def'
name|'nova_docstring_one_line'
op|'('
name|'physical_line'
op|','
name|'previous_logical'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'r"""Check one line docstring end.\n\n    nova HACKING guide recommendation for one line docstring:\n    A one line docstring looks like this and ends in punctuation.\n\n    Okay: def foo():\\n    \'\'\'This is good.\'\'\'\n    Okay: def foo():\\n    \'\'\'This is good too!\'\'\'\n    Okay: def foo():\\n    \'\'\'How about this?\'\'\'\n    Okay: def foo():\\n    a = \'\'\'This is not a docstring\'\'\'\n    Okay: def foo():\\n    pass\\n    \'\'\'This is not a docstring\'\'\'\n    Okay: class Foo:\\n    pass\\n    \'\'\'This is not a docstring\'\'\'\n    N402: def foo():\\n    \'\'\'This is not\'\'\'\n    N402: def foo():\\n    \'\'\'Bad punctuation,\'\'\'\n    N402: class Foo:\\n    \'\'\'Bad punctuation,\'\'\'\n    """'
newline|'\n'
comment|'#TODO(jogo) make this apply to multi line docstrings as well'
nl|'\n'
name|'line'
op|'='
name|'physical_line'
op|'.'
name|'lstrip'
op|'('
op|')'
newline|'\n'
name|'if'
name|'is_docstring'
op|'('
name|'physical_line'
op|','
name|'previous_logical'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pos'
op|'='
name|'max'
op|'('
op|'['
name|'line'
op|'.'
name|'find'
op|'('
name|'i'
op|')'
name|'for'
name|'i'
name|'in'
name|'START_DOCSTRING_TRIPLE'
op|']'
op|')'
comment|'# start'
newline|'\n'
name|'end'
op|'='
name|'max'
op|'('
op|'['
name|'line'
op|'['
op|'-'
number|'4'
op|':'
op|'-'
number|'1'
op|']'
op|'=='
name|'i'
name|'for'
name|'i'
name|'in'
name|'END_DOCSTRING_TRIPLE'
op|']'
op|')'
comment|'# end'
newline|'\n'
nl|'\n'
name|'if'
name|'pos'
op|'!='
op|'-'
number|'1'
name|'and'
name|'end'
name|'and'
name|'len'
op|'('
name|'line'
op|')'
op|'>'
name|'pos'
op|'+'
number|'4'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'line'
op|'['
op|'-'
number|'5'
op|']'
name|'not'
name|'in'
op|'['
string|"'.'"
op|','
string|"'?'"
op|','
string|"'!'"
op|']'
op|':'
newline|'\n'
indent|'                '
name|'return'
name|'pos'
op|','
string|'"N402: one line docstring needs punctuation."'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|nova_docstring_multiline_end
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'nova_docstring_multiline_end'
op|'('
name|'physical_line'
op|','
name|'previous_logical'
op|','
name|'tokens'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'r"""Check multi line docstring end.\n\n    nova HACKING guide recommendation for docstring:\n    Docstring should end on a new line\n\n    Okay: \'\'\'foobar\\nfoo\\nbar\\n\'\'\'\n    Okay: def foo():\\n    \'\'\'foobar\\nfoo\\nbar\\n\'\'\'\n    Okay: class Foo:\\n    \'\'\'foobar\\nfoo\\nbar\\n\'\'\'\n    Okay: def foo():\\n    a = \'\'\'not\\na\\ndocstring\'\'\'\n    Okay: def foo():\\n    pass\\n\'\'\'foobar\\nfoo\\nbar\\n   d\'\'\'\n    N403: def foo():\\n    \'\'\'foobar\\nfoo\\nbar\\ndocstring\'\'\'\n    N403: class Foo:\\n    \'\'\'foobar\\nfoo\\nbar\\ndocstring\'\'\'\\n\\n\n    """'
newline|'\n'
comment|'# if find OP tokens, not a docstring'
nl|'\n'
name|'ops'
op|'='
op|'['
name|'t'
name|'for'
name|'t'
op|','
name|'_'
op|','
name|'_'
op|','
name|'_'
op|','
name|'_'
name|'in'
name|'tokens'
name|'if'
name|'t'
op|'=='
name|'tokenize'
op|'.'
name|'OP'
op|']'
newline|'\n'
name|'if'
op|'('
name|'is_docstring'
op|'('
name|'physical_line'
op|','
name|'previous_logical'
op|')'
name|'and'
name|'len'
op|'('
name|'tokens'
op|')'
op|'>'
number|'0'
name|'and'
nl|'\n'
name|'len'
op|'('
name|'ops'
op|')'
op|'=='
number|'0'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pos'
op|'='
name|'max'
op|'('
name|'physical_line'
op|'.'
name|'find'
op|'('
name|'i'
op|')'
name|'for'
name|'i'
name|'in'
name|'END_DOCSTRING_TRIPLE'
op|')'
newline|'\n'
name|'if'
name|'physical_line'
op|'.'
name|'strip'
op|'('
op|')'
name|'not'
name|'in'
name|'START_DOCSTRING_TRIPLE'
op|':'
newline|'\n'
indent|'            '
name|'return'
op|'('
name|'pos'
op|','
string|'"N403: multi line docstring end on new line"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|nova_docstring_multiline_start
dedent|''
dedent|''
dedent|''
name|'def'
name|'nova_docstring_multiline_start'
op|'('
name|'physical_line'
op|','
name|'previous_logical'
op|','
name|'tokens'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'r"""Check multi line docstring start with summary.\n\n    nova HACKING guide recommendation for docstring:\n    Docstring should start with A multi line docstring has a one-line summary\n\n    Okay: \'\'\'foobar\\nfoo\\nbar\\n\'\'\'\n    Okay: def foo():\\n    a = \'\'\'\\nnot\\na docstring\\n\'\'\'\n    N404: def foo():\\n\'\'\'\\nfoo\\nbar\\n\'\'\'\\n\\n\n    """'
newline|'\n'
name|'if'
name|'is_docstring'
op|'('
name|'physical_line'
op|','
name|'previous_logical'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'pos'
op|'='
name|'max'
op|'('
op|'['
name|'physical_line'
op|'.'
name|'find'
op|'('
name|'i'
op|')'
name|'for'
name|'i'
name|'in'
name|'START_DOCSTRING_TRIPLE'
op|']'
op|')'
newline|'\n'
comment|'# start of docstring when len(tokens)==0'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'tokens'
op|')'
op|'=='
number|'0'
name|'and'
name|'pos'
op|'!='
op|'-'
number|'1'
name|'and'
name|'len'
op|'('
name|'physical_line'
op|')'
op|'=='
name|'pos'
op|'+'
number|'4'
op|':'
newline|'\n'
indent|'            '
name|'if'
name|'physical_line'
op|'.'
name|'strip'
op|'('
op|')'
name|'in'
name|'START_DOCSTRING_TRIPLE'
op|':'
newline|'\n'
indent|'                '
name|'return'
op|'('
name|'pos'
op|','
string|'"N404: multi line docstring "'
nl|'\n'
string|'"should start with a summary"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|nova_no_cr
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'nova_no_cr'
op|'('
name|'physical_line'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'r"""Check that we only use newlines not carriage returns.\n\n    Okay: import os\\nimport sys\n    # pep8 doesn\'t yet replace \\r in strings, will work on an\n    # upstream fix\n    N901 import os\\r\\nimport sys\n    """'
newline|'\n'
name|'pos'
op|'='
name|'physical_line'
op|'.'
name|'find'
op|'('
string|"'\\r'"
op|')'
newline|'\n'
name|'if'
name|'pos'
op|'!='
op|'-'
number|'1'
name|'and'
name|'pos'
op|'=='
op|'('
name|'len'
op|'('
name|'physical_line'
op|')'
op|'-'
number|'2'
op|')'
op|':'
newline|'\n'
indent|'        '
name|'return'
op|'('
name|'pos'
op|','
string|'"N901: Windows style line endings not allowed in code"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|variable|FORMAT_RE
dedent|''
dedent|''
name|'FORMAT_RE'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|'"%(?:"'
nl|'\n'
string|'"%|"'
comment|'# Ignore plain percents'
nl|'\n'
string|'"(\\(\\w+\\))?"'
comment|'# mapping key'
nl|'\n'
string|'"([#0 +-]?"'
comment|'# flag'
nl|'\n'
string|'"(?:\\d+|\\*)?"'
comment|'# width'
nl|'\n'
string|'"(?:\\.\\d+)?"'
comment|'# precision'
nl|'\n'
string|'"[hlL]?"'
comment|'# length mod'
nl|'\n'
string|'"\\w))"'
op|')'
comment|'# type'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|class|LocalizationError
name|'class'
name|'LocalizationError'
op|'('
name|'Exception'
op|')'
op|':'
newline|'\n'
indent|'    '
name|'pass'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|check_i18n
dedent|''
name|'def'
name|'check_i18n'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Generator that checks token stream for localization errors.\n\n    Expects tokens to be ``send``ed one by one.\n    Raises LocalizationError if some error is found.\n    """'
newline|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'        '
name|'try'
op|':'
newline|'\n'
indent|'            '
name|'token_type'
op|','
name|'text'
op|','
name|'_'
op|','
name|'_'
op|','
name|'line'
op|'='
name|'yield'
newline|'\n'
dedent|''
name|'except'
name|'GeneratorExit'
op|':'
newline|'\n'
indent|'            '
name|'return'
newline|'\n'
nl|'\n'
dedent|''
name|'if'
op|'('
name|'token_type'
op|'=='
name|'tokenize'
op|'.'
name|'NAME'
name|'and'
name|'text'
op|'=='
string|'"_"'
name|'and'
nl|'\n'
name|'not'
name|'line'
op|'.'
name|'startswith'
op|'('
string|"'def _(msg):'"
op|')'
op|')'
op|':'
newline|'\n'
nl|'\n'
indent|'            '
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'                '
name|'token_type'
op|','
name|'text'
op|','
name|'start'
op|','
name|'_'
op|','
name|'_'
op|'='
name|'yield'
newline|'\n'
name|'if'
name|'token_type'
op|'!='
name|'tokenize'
op|'.'
name|'NL'
op|':'
newline|'\n'
indent|'                    '
name|'break'
newline|'\n'
dedent|''
dedent|''
name|'if'
name|'token_type'
op|'!='
name|'tokenize'
op|'.'
name|'OP'
name|'or'
name|'text'
op|'!='
string|'"("'
op|':'
newline|'\n'
indent|'                '
name|'continue'
comment|'# not a localization call'
newline|'\n'
nl|'\n'
dedent|''
name|'format_string'
op|'='
string|"''"
newline|'\n'
name|'while'
name|'True'
op|':'
newline|'\n'
indent|'                '
name|'token_type'
op|','
name|'text'
op|','
name|'start'
op|','
name|'_'
op|','
name|'_'
op|'='
name|'yield'
newline|'\n'
name|'if'
name|'token_type'
op|'=='
name|'tokenize'
op|'.'
name|'STRING'
op|':'
newline|'\n'
indent|'                    '
name|'format_string'
op|'+='
name|'eval'
op|'('
name|'text'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'token_type'
op|'=='
name|'tokenize'
op|'.'
name|'NL'
op|':'
newline|'\n'
indent|'                    '
name|'pass'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'break'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'if'
name|'not'
name|'format_string'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'LocalizationError'
op|'('
name|'start'
op|','
nl|'\n'
string|'"N701: Empty localization string"'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'token_type'
op|'!='
name|'tokenize'
op|'.'
name|'OP'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'LocalizationError'
op|'('
name|'start'
op|','
nl|'\n'
string|'"N701: Invalid localization call"'
op|')'
newline|'\n'
dedent|''
name|'if'
name|'text'
op|'!='
string|'")"'
op|':'
newline|'\n'
indent|'                '
name|'if'
name|'text'
op|'=='
string|'"%"'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'LocalizationError'
op|'('
name|'start'
op|','
nl|'\n'
string|'"N702: Formatting operation should be outside"'
nl|'\n'
string|'" of localization method call"'
op|')'
newline|'\n'
dedent|''
name|'elif'
name|'text'
op|'=='
string|'"+"'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'LocalizationError'
op|'('
name|'start'
op|','
nl|'\n'
string|'"N702: Use bare string concatenation instead"'
nl|'\n'
string|'" of +"'
op|')'
newline|'\n'
dedent|''
name|'else'
op|':'
newline|'\n'
indent|'                    '
name|'raise'
name|'LocalizationError'
op|'('
name|'start'
op|','
nl|'\n'
string|'"N702: Argument to _ must be just a string"'
op|')'
newline|'\n'
nl|'\n'
dedent|''
dedent|''
name|'format_specs'
op|'='
name|'FORMAT_RE'
op|'.'
name|'findall'
op|'('
name|'format_string'
op|')'
newline|'\n'
name|'positional_specs'
op|'='
op|'['
op|'('
name|'key'
op|','
name|'spec'
op|')'
name|'for'
name|'key'
op|','
name|'spec'
name|'in'
name|'format_specs'
nl|'\n'
name|'if'
name|'not'
name|'key'
name|'and'
name|'spec'
op|']'
newline|'\n'
comment|'# not spec means %%, key means %(smth)s'
nl|'\n'
name|'if'
name|'len'
op|'('
name|'positional_specs'
op|')'
op|'>'
number|'1'
op|':'
newline|'\n'
indent|'                '
name|'raise'
name|'LocalizationError'
op|'('
name|'start'
op|','
nl|'\n'
string|'"N703: Multiple positional placeholders"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|nova_localization_strings
dedent|''
dedent|''
dedent|''
dedent|''
name|'def'
name|'nova_localization_strings'
op|'('
name|'logical_line'
op|','
name|'tokens'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'r"""Check localization in line.\n\n    Okay: _("This is fine")\n    Okay: _("This is also fine %s")\n    N701: _(\'\')\n    N702: _("Bob" + " foo")\n    N702: _("Bob %s" % foo)\n    # N703 check is not quite right, disabled by removing colon\n    N703 _("%s %s" % (foo, bar))\n    """'
newline|'\n'
comment|'# TODO(sdague) actually get these tests working'
nl|'\n'
name|'gen'
op|'='
name|'check_i18n'
op|'('
op|')'
newline|'\n'
name|'next'
op|'('
name|'gen'
op|')'
newline|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'map'
op|'('
name|'gen'
op|'.'
name|'send'
op|','
name|'tokens'
op|')'
newline|'\n'
name|'gen'
op|'.'
name|'close'
op|'('
op|')'
newline|'\n'
dedent|''
name|'except'
name|'LocalizationError'
name|'as'
name|'e'
op|':'
newline|'\n'
indent|'        '
name|'yield'
name|'e'
op|'.'
name|'args'
newline|'\n'
nl|'\n'
comment|'#TODO(jogo) Dict and list objects'
nl|'\n'
nl|'\n'
nl|'\n'
DECL|function|nova_is_not
dedent|''
dedent|''
name|'def'
name|'nova_is_not'
op|'('
name|'logical_line'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'r"""Check localization in line.\n\n    Okay: if x is not y\n    N901: if not X is Y\n    N901: if not X.B is Y\n    """'
newline|'\n'
name|'split_line'
op|'='
name|'logical_line'
op|'.'
name|'split'
op|'('
op|')'
newline|'\n'
name|'if'
op|'('
name|'len'
op|'('
name|'split_line'
op|')'
op|'=='
number|'5'
name|'and'
name|'split_line'
op|'['
number|'0'
op|']'
op|'=='
string|"'if'"
name|'and'
nl|'\n'
name|'split_line'
op|'['
number|'1'
op|']'
op|'=='
string|"'not'"
name|'and'
name|'split_line'
op|'['
number|'3'
op|']'
op|'=='
string|"'is'"
op|')'
op|':'
newline|'\n'
indent|'                '
name|'yield'
op|'('
name|'logical_line'
op|'.'
name|'find'
op|'('
string|"'not'"
op|')'
op|','
string|'"N901: Use the \'is not\' "'
nl|'\n'
string|'"operator for when testing for unequal identities"'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|nova_not_in
dedent|''
dedent|''
name|'def'
name|'nova_not_in'
op|'('
name|'logical_line'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'r"""Check localization in line.\n\n    Okay: if x not in y\n    Okay: if not (X in Y or X is Z)\n    Okay: if not (X in Y)\n    N902: if not X in Y\n    N902: if not X.B in Y\n    """'
newline|'\n'
name|'split_line'
op|'='
name|'logical_line'
op|'.'
name|'split'
op|'('
op|')'
newline|'\n'
name|'if'
op|'('
name|'len'
op|'('
name|'split_line'
op|')'
op|'=='
number|'5'
name|'and'
name|'split_line'
op|'['
number|'0'
op|']'
op|'=='
string|"'if'"
name|'and'
nl|'\n'
name|'split_line'
op|'['
number|'1'
op|']'
op|'=='
string|"'not'"
name|'and'
name|'split_line'
op|'['
number|'3'
op|']'
op|'=='
string|"'in'"
name|'and'
name|'not'
nl|'\n'
name|'split_line'
op|'['
number|'2'
op|']'
op|'.'
name|'startswith'
op|'('
string|"'('"
op|')'
op|')'
op|':'
newline|'\n'
indent|'                '
name|'yield'
op|'('
name|'logical_line'
op|'.'
name|'find'
op|'('
string|"'not'"
op|')'
op|','
string|'"N902: Use the \'not in\' "'
nl|'\n'
string|'"operator for collection membership evaluation"'
op|')'
newline|'\n'
nl|'\n'
DECL|variable|current_file
dedent|''
dedent|''
name|'current_file'
op|'='
string|'""'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|readlines
name|'def'
name|'readlines'
op|'('
name|'filename'
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Record the current file being tested."""'
newline|'\n'
name|'pep8'
op|'.'
name|'current_file'
op|'='
name|'filename'
newline|'\n'
name|'return'
name|'open'
op|'('
name|'filename'
op|')'
op|'.'
name|'readlines'
op|'('
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|add_nova
dedent|''
name|'def'
name|'add_nova'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Monkey patch in nova guidelines.\n\n    Look for functions that start with nova_  and have arguments\n    and add them to pep8 module\n    Assumes you know how to write pep8.py checks\n    """'
newline|'\n'
name|'for'
name|'name'
op|','
name|'function'
name|'in'
name|'globals'
op|'('
op|')'
op|'.'
name|'items'
op|'('
op|')'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'not'
name|'inspect'
op|'.'
name|'isfunction'
op|'('
name|'function'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'continue'
newline|'\n'
dedent|''
name|'args'
op|'='
name|'inspect'
op|'.'
name|'getargspec'
op|'('
name|'function'
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'if'
name|'args'
name|'and'
name|'name'
op|'.'
name|'startswith'
op|'('
string|'"nova"'
op|')'
op|':'
newline|'\n'
indent|'            '
name|'exec'
op|'('
string|'"pep8.%s = %s"'
op|'%'
op|'('
name|'name'
op|','
name|'name'
op|')'
op|')'
newline|'\n'
nl|'\n'
nl|'\n'
DECL|function|once_git_check_commit_title
dedent|''
dedent|''
dedent|''
name|'def'
name|'once_git_check_commit_title'
op|'('
op|')'
op|':'
newline|'\n'
indent|'    '
string|'"""Check git commit messages.\n\n    nova HACKING recommends not referencing a bug or blueprint in first line,\n    it should provide an accurate description of the change\n    N801\n    N802 Title limited to 72 chars\n    """'
newline|'\n'
comment|'#Get title of most recent commit'
nl|'\n'
nl|'\n'
name|'subp'
op|'='
name|'subprocess'
op|'.'
name|'Popen'
op|'('
op|'['
string|"'git'"
op|','
string|"'log'"
op|','
string|"'--no-merges'"
op|','
string|"'--pretty=%s'"
op|','
string|"'-1'"
op|']'
op|','
nl|'\n'
name|'stdout'
op|'='
name|'subprocess'
op|'.'
name|'PIPE'
op|')'
newline|'\n'
name|'title'
op|'='
name|'subp'
op|'.'
name|'communicate'
op|'('
op|')'
op|'['
number|'0'
op|']'
newline|'\n'
name|'if'
name|'subp'
op|'.'
name|'returncode'
op|':'
newline|'\n'
indent|'        '
name|'raise'
name|'Exception'
op|'('
string|'"git log failed with code %s"'
op|'%'
name|'subp'
op|'.'
name|'returncode'
op|')'
newline|'\n'
nl|'\n'
comment|'#From https://github.com/openstack/openstack-ci-puppet'
nl|'\n'
comment|'#       /blob/master/modules/gerrit/manifests/init.pp#L74'
nl|'\n'
comment|'#Changeid|bug|blueprint'
nl|'\n'
dedent|''
name|'git_keywords'
op|'='
op|'('
string|"r'(I[0-9a-f]{8,40})|'"
nl|'\n'
string|"'([Bb]ug|[Ll][Pp])[\\s\\#:]*(\\d+)|'"
nl|'\n'
string|"'([Bb]lue[Pp]rint|[Bb][Pp])[\\s\\#:]*([A-Za-z0-9\\\\-]+)'"
op|')'
newline|'\n'
name|'GIT_REGEX'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
name|'git_keywords'
op|')'
newline|'\n'
nl|'\n'
name|'error'
op|'='
name|'False'
newline|'\n'
comment|'#NOTE(jogo) if match regex but over 3 words, acceptable title'
nl|'\n'
name|'if'
name|'GIT_REGEX'
op|'.'
name|'search'
op|'('
name|'title'
op|')'
name|'is'
name|'not'
name|'None'
name|'and'
name|'len'
op|'('
name|'title'
op|'.'
name|'split'
op|'('
op|')'
op|')'
op|'<='
number|'3'
op|':'
newline|'\n'
indent|'        '
name|'print'
op|'('
string|'"N801: git commit title (\'%s\') should provide an accurate "'
nl|'\n'
string|'"description of the change, not just a reference to a bug "'
nl|'\n'
string|'"or blueprint"'
op|'%'
name|'title'
op|'.'
name|'strip'
op|'('
op|')'
op|')'
newline|'\n'
name|'error'
op|'='
name|'True'
newline|'\n'
comment|'# HACKING.rst recommends commit titles 50 chars or less, but enforces'
nl|'\n'
comment|'# a 72 character limit'
nl|'\n'
dedent|''
name|'if'
name|'len'
op|'('
name|'title'
op|'.'
name|'decode'
op|'('
string|"'utf-8'"
op|')'
op|')'
op|'>'
number|'72'
op|':'
newline|'\n'
indent|'        '
name|'print'
op|'('
string|'"N802: git commit title (\'%s\') should be under 50 chars"'
nl|'\n'
op|'%'
name|'title'
op|'.'
name|'strip'
op|'('
op|')'
op|')'
newline|'\n'
name|'error'
op|'='
name|'True'
newline|'\n'
dedent|''
name|'return'
name|'error'
newline|'\n'
nl|'\n'
dedent|''
name|'imports_on_separate_lines_N301_compliant'
op|'='
string|'r"""\n    Imports should usually be on separate lines.\n\n    Okay: import os\\nimport sys\n    E401: import sys, os\n\n    N301: from subprocess import Popen, PIPE\n    Okay: from myclas import MyClass\n    Okay: from foo.bar.yourclass import YourClass\n    Okay: import myclass\n    Okay: import foo.bar.yourclass\n    """'
newline|'\n'
nl|'\n'
name|'if'
name|'__name__'
op|'=='
string|'"__main__"'
op|':'
newline|'\n'
indent|'    '
name|'gettext'
op|'.'
name|'install'
op|'('
string|"'nova'"
op|','
name|'unicode'
op|'='
number|'1'
op|')'
newline|'\n'
comment|'#include nova path'
nl|'\n'
name|'sys'
op|'.'
name|'path'
op|'.'
name|'append'
op|'('
name|'os'
op|'.'
name|'getcwd'
op|'('
op|')'
op|')'
newline|'\n'
comment|'#Run once tests (not per line)'
nl|'\n'
DECL|variable|once_error
name|'once_error'
op|'='
name|'once_git_check_commit_title'
op|'('
op|')'
newline|'\n'
comment|'#NOVA error codes start with an N'
nl|'\n'
name|'pep8'
op|'.'
name|'SELFTEST_REGEX'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'(Okay|[EWN]\\d{3}):\\s(.*)'"
op|')'
newline|'\n'
name|'pep8'
op|'.'
name|'ERRORCODE_REGEX'
op|'='
name|'re'
op|'.'
name|'compile'
op|'('
string|"r'[EWN]\\d{3}'"
op|')'
newline|'\n'
name|'add_nova'
op|'('
op|')'
newline|'\n'
name|'pep8'
op|'.'
name|'current_file'
op|'='
name|'current_file'
newline|'\n'
name|'pep8'
op|'.'
name|'readlines'
op|'='
name|'readlines'
newline|'\n'
name|'pep8'
op|'.'
name|'StyleGuide'
op|'.'
name|'excluded'
op|'='
name|'excluded'
newline|'\n'
name|'pep8'
op|'.'
name|'StyleGuide'
op|'.'
name|'input_dir'
op|'='
name|'input_dir'
newline|'\n'
comment|'# we need to kill this doctring otherwise the self tests fail'
nl|'\n'
name|'pep8'
op|'.'
name|'imports_on_separate_lines'
op|'.'
name|'__doc__'
op|'='
name|'imports_on_separate_lines_N301_compliant'
newline|'\n'
nl|'\n'
name|'try'
op|':'
newline|'\n'
indent|'        '
name|'pep8'
op|'.'
name|'_main'
op|'('
op|')'
newline|'\n'
name|'sys'
op|'.'
name|'exit'
op|'('
name|'once_error'
op|')'
newline|'\n'
dedent|''
name|'finally'
op|':'
newline|'\n'
indent|'        '
name|'if'
name|'len'
op|'('
name|'_missingImport'
op|')'
op|'>'
number|'0'
op|':'
newline|'\n'
indent|'            '
name|'print'
op|'>>'
name|'sys'
op|'.'
name|'stderr'
op|','
op|'('
string|'"%i imports missing in this test environment"'
nl|'\n'
op|'%'
name|'len'
op|'('
name|'_missingImport'
op|')'
op|')'
newline|'\n'
dedent|''
dedent|''
dedent|''
endmarker|''
end_unit
